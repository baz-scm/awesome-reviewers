[
  {
    "discussion_id": "2185778500",
    "pr_number": 10457,
    "pr_file": "src/poetry/console/commands/init.py",
    "created_at": "2025-07-04T16:50:51+00:00",
    "commented_code": "return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "2185778500",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-04T16:50:51+00:00",
        "comment_author": "radoering",
        "comment_body": "The output is not so nicely formatted. It contains a raw dict, e.g.:\r\n```\r\nValidation failed: {'errors': ['project.name must match pattern ^([a-zA-Z\\\\d]|[a-zA-Z\\\\d][\\\\w.-]*[a-zA-Z\\\\d])$'], 'warnings': []}\r\n```\r\n\r\nYou may take a look at https://github.com/python-poetry/poetry-core/blob/002aa3e16f98d21645bb9a45f698b55adc40f317/src/poetry/core/factory.py#L53-L60 for better formatting.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190689718",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-07T17:29:38+00:00",
        "comment_author": "rbogart1990",
        "comment_body": "@radoering , thanks for the feedback about this. \r\n\r\nWould this format be acceptable?\r\n```\r\nValidation failed:\r\n  - project.name must match pattern ^([a-zA-Z\\d]|[a-zA-Z\\d][\\w.-]*[a-zA-Z\\d])$\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2190708662",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-07T17:41:19+00:00",
        "comment_author": "radoering",
        "comment_body": "Absolutely.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190759476",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-07T18:14:17+00:00",
        "comment_author": "rbogart1990",
        "comment_body": "Thank you!",
        "pr_file_module": null
      },
      {
        "comment_id": "2190826415",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-07T18:56:49+00:00",
        "comment_author": "rbogart1990",
        "comment_body": "@radoering , change made.",
        "pr_file_module": null
      },
      {
        "comment_id": "2191089039",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-07T22:16:28+00:00",
        "comment_author": "Secrus",
        "comment_body": "You must be kidding. Error messages should be readable and clear for users. Imagine some beginner developer getting hit by that error message. Hell, 9/10 seasoned developers would have a hard time understanding that error message without some sort of regex explorer. This should be a clear message, that a 5 year old is able to understand. I would split the checks and make a separate clear message for each condition, gather the errors and list them clearly. Poetry's motto is \"Python packaging and dependency management made easy\". Getting hit with a regex is not \"easy\" by any means.",
        "pr_file_module": null
      },
      {
        "comment_id": "2194001492",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10457,
        "pr_file": "src/poetry/console/commands/init.py",
        "discussion_id": "2185778500",
        "commented_code": "@@ -265,6 +267,14 @@ def _init_pyproject(\n \n             return 1\n \n+        # Validate fields before creating pyproject.toml file. If any validations fail, throw an error.\n+        # Convert TOML string to a TOMLDocument (a dict-like object) for validation.\n+        pyproject_dict = parse(pyproject.data.as_string())\n+        validation_results = self._validate(pyproject_dict)\n+        if validation_results.get(\"errors\"):\n+            self.line_error(f\"<error>Validation failed: {validation_results}</error>\")\n+            return 1",
        "comment_created_at": "2025-07-09T04:42:11+00:00",
        "comment_author": "radoering",
        "comment_body": "My comment was just about formatting the output. At this point, we get a dict with lists of messages and the output should just be nicely formatted. The content of the single messages has been created before and is fixed at this point.\r\n\r\nIn my opinion, it is too much effort to improve each possible message that comes from schema validation - or at least this is clearly out of scope of this PR. The message is the same message if you run `poetry check` on such an invalid pyproject.toml.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1936974735",
    "pr_number": 10126,
    "pr_file": "src/poetry/installation/chooser.py",
    "created_at": "2025-01-31T09:57:06+00:00",
    "commented_code": "link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []\n+            info = (\n+                f\"This is likely not a Poetry issue.\n\n\"\n+                f\"  - {links_seen} candidates were identified for the package\n\"\n+            )\n+\n+            if wheels_skipped > 0:\n+                info += f\"  - {wheels_skipped} wheels were skipped due to your <c1>installer.no-binary</> policy\n\"\n+\n+            if sdists_skipped > 0:\n+                info += f\"  - {sdists_skipped} source distributions were skipped due to your <c1>installer.only-binary</> policy\n\"\n+\n+            if unsupported_wheels:\n+                info += (\n+                    f\"  - {len(unsupported_wheels)} wheels were skipped as your project's environment does not support \"\n+                    f\"the identified abi tags\n\"\n+                )\n+\n+            messages.append(ConsoleMessage(info))\n+\n+            if unsupported_wheels:\n+                messages += [\n+                    ConsoleMessage(\n+                        \"The following wheels were skipped as the current project environment does not support them \"\n+                        \"due to abi compatibility issues.\",\n+                        debug=True,\n+                    ),\n+                    ConsoleMessage(\"\n\".join(unsupported_wheels), debug=True)\n+                    .indent(\"  - \")\n+                    .wrap(\"warning\"),\n+                    ConsoleMessage(\n+                        \"If you would like to see the supported tags in your project environment, you can execute \"\n+                        \"the following command:\n\n\"\n+                        \"    <c1>python -c 'from packaging.tags import sys_tags; print(\\\"\\\n\\\".join(set(str(t) for t in sys_tags())))'</>\n\n\"\n+                        \"<warning>The above expects you to have <c1>packaging</> package installed in the environment.\",\n+                        debug=True,\n+                    ),\n+                ]\n+\n+            messages.append(\n+                ConsoleMessage(\n+                    f\"Make sure the lockfile is up-to-date. You can try one of the following;\n\n\"\n+                    f\"    1. <b>Regenerate lockfile: </><fg=yellow>poetry lock --no-cache --regenerate</>\n\"\n+                    f\"    2. <b>Update package     : </><fg=yellow>poetry update --no-cache {package.name}</>\n\n\"\n+                    f\"If neither works, please check your source to verify {package.name} has released distributions \"",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1936974735",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936974735",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []\n+            info = (\n+                f\"This is likely not a Poetry issue.\\n\\n\"\n+                f\"  - {links_seen} candidates were identified for the package\\n\"\n+            )\n+\n+            if wheels_skipped > 0:\n+                info += f\"  - {wheels_skipped} wheels were skipped due to your <c1>installer.no-binary</> policy\\n\"\n+\n+            if sdists_skipped > 0:\n+                info += f\"  - {sdists_skipped} source distributions were skipped due to your <c1>installer.only-binary</> policy\\n\"\n+\n+            if unsupported_wheels:\n+                info += (\n+                    f\"  - {len(unsupported_wheels)} wheels were skipped as your project's environment does not support \"\n+                    f\"the identified abi tags\\n\"\n+                )\n+\n+            messages.append(ConsoleMessage(info))\n+\n+            if unsupported_wheels:\n+                messages += [\n+                    ConsoleMessage(\n+                        \"The following wheels were skipped as the current project environment does not support them \"\n+                        \"due to abi compatibility issues.\",\n+                        debug=True,\n+                    ),\n+                    ConsoleMessage(\"\\n\".join(unsupported_wheels), debug=True)\n+                    .indent(\"  - \")\n+                    .wrap(\"warning\"),\n+                    ConsoleMessage(\n+                        \"If you would like to see the supported tags in your project environment, you can execute \"\n+                        \"the following command:\\n\\n\"\n+                        \"    <c1>python -c 'from packaging.tags import sys_tags; print(\\\"\\\\n\\\".join(set(str(t) for t in sys_tags())))'</>\\n\\n\"\n+                        \"<warning>The above expects you to have <c1>packaging</> package installed in the environment.\",\n+                        debug=True,\n+                    ),\n+                ]\n+\n+            messages.append(\n+                ConsoleMessage(\n+                    f\"Make sure the lockfile is up-to-date. You can try one of the following;\\n\\n\"\n+                    f\"    1. <b>Regenerate lockfile: </><fg=yellow>poetry lock --no-cache --regenerate</>\\n\"\n+                    f\"    2. <b>Update package     : </><fg=yellow>poetry update --no-cache {package.name}</>\\n\\n\"\n+                    f\"If neither works, please check your source to verify {package.name} has released distributions \"",
        "comment_created_at": "2025-01-31T09:57:06+00:00",
        "comment_author": "Secrus",
        "comment_body": "```suggestion\r\n                    f\"If neither works, please check your package source to verify {package.name} has released distributions \"\r\n```\r\n\r\nOne option, although I am still not sure if that will be clear enough for most users",
        "pr_file_module": null
      },
      {
        "comment_id": "1937356072",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936974735",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []\n+            info = (\n+                f\"This is likely not a Poetry issue.\\n\\n\"\n+                f\"  - {links_seen} candidates were identified for the package\\n\"\n+            )\n+\n+            if wheels_skipped > 0:\n+                info += f\"  - {wheels_skipped} wheels were skipped due to your <c1>installer.no-binary</> policy\\n\"\n+\n+            if sdists_skipped > 0:\n+                info += f\"  - {sdists_skipped} source distributions were skipped due to your <c1>installer.only-binary</> policy\\n\"\n+\n+            if unsupported_wheels:\n+                info += (\n+                    f\"  - {len(unsupported_wheels)} wheels were skipped as your project's environment does not support \"\n+                    f\"the identified abi tags\\n\"\n+                )\n+\n+            messages.append(ConsoleMessage(info))\n+\n+            if unsupported_wheels:\n+                messages += [\n+                    ConsoleMessage(\n+                        \"The following wheels were skipped as the current project environment does not support them \"\n+                        \"due to abi compatibility issues.\",\n+                        debug=True,\n+                    ),\n+                    ConsoleMessage(\"\\n\".join(unsupported_wheels), debug=True)\n+                    .indent(\"  - \")\n+                    .wrap(\"warning\"),\n+                    ConsoleMessage(\n+                        \"If you would like to see the supported tags in your project environment, you can execute \"\n+                        \"the following command:\\n\\n\"\n+                        \"    <c1>python -c 'from packaging.tags import sys_tags; print(\\\"\\\\n\\\".join(set(str(t) for t in sys_tags())))'</>\\n\\n\"\n+                        \"<warning>The above expects you to have <c1>packaging</> package installed in the environment.\",\n+                        debug=True,\n+                    ),\n+                ]\n+\n+            messages.append(\n+                ConsoleMessage(\n+                    f\"Make sure the lockfile is up-to-date. You can try one of the following;\\n\\n\"\n+                    f\"    1. <b>Regenerate lockfile: </><fg=yellow>poetry lock --no-cache --regenerate</>\\n\"\n+                    f\"    2. <b>Update package     : </><fg=yellow>poetry update --no-cache {package.name}</>\\n\\n\"\n+                    f\"If neither works, please check your source to verify {package.name} has released distributions \"",
        "comment_created_at": "2025-01-31T13:53:39+00:00",
        "comment_author": "abn",
        "comment_body": "I have improved the message to include the source name explicitly as well. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1414132345",
    "pr_number": 8737,
    "pr_file": "src/poetry/installation/installer.py",
    "created_at": "2023-12-04T16:06:57+00:00",
    "commented_code": "locked_repository = self._locker.locked_repository()\n \n             if not self._locker.is_fresh():\n-                self._io.write_error_line(\n-                    \"<warning>\"\n-                    \"Warning: poetry.lock is not consistent with pyproject.toml. \"\n+                raise ValueError(\n+                    \"<error>\"\n+                    \"Error: poetry.lock is not consistent with pyproject.toml. \"\n                     \"You may be getting improper dependencies. \"\n                     \"Run `poetry lock [--no-update]` to fix it.\"\n-                    \"</warning>\"\n+                    \"</error>\"",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1414132345",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8737,
        "pr_file": "src/poetry/installation/installer.py",
        "discussion_id": "1414132345",
        "commented_code": "@@ -245,12 +245,12 @@ def _do_install(self) -> int:\n             locked_repository = self._locker.locked_repository()\n \n             if not self._locker.is_fresh():\n-                self._io.write_error_line(\n-                    \"<warning>\"\n-                    \"Warning: poetry.lock is not consistent with pyproject.toml. \"\n+                raise ValueError(\n+                    \"<error>\"\n+                    \"Error: poetry.lock is not consistent with pyproject.toml. \"\n                     \"You may be getting improper dependencies. \"\n                     \"Run `poetry lock [--no-update]` to fix it.\"\n-                    \"</warning>\"\n+                    \"</error>\"",
        "comment_created_at": "2023-12-04T16:06:57+00:00",
        "comment_author": "radoering",
        "comment_body": "I assume we don't need `<error>` and `Error:` when raising an error. Further, we can remove `\"You may be getting improper dependencies.\"` because now you can't install anymore.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1156940937",
    "pr_number": 7529,
    "pr_file": "src/poetry/console/commands/group_command.py",
    "created_at": "2023-04-04T08:55:35+00:00",
    "commented_code": "return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1156940937",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7529,
        "pr_file": "src/poetry/console/commands/group_command.py",
        "discussion_id": "1156940937",
        "commented_code": "@@ -107,3 +111,36 @@ def project_with_activated_groups_only(self) -> ProjectPackage:\n         return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
        "comment_created_at": "2023-04-04T08:55:35+00:00",
        "comment_author": "radoering",
        "comment_body": "Printing an error and raising an exception is a bit like \"Two is better than one.\" IMO one should suffice.\r\n\r\nPrinting an error and returning exit code 1 is probably not easily possible here, because we're not in the `handle` method of a command. Thus, I'd propose to only raise an exception.",
        "pr_file_module": null
      },
      {
        "comment_id": "1157299784",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7529,
        "pr_file": "src/poetry/console/commands/group_command.py",
        "discussion_id": "1156940937",
        "commented_code": "@@ -107,3 +111,36 @@ def project_with_activated_groups_only(self) -> ProjectPackage:\n         return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
        "comment_created_at": "2023-04-04T13:57:23+00:00",
        "comment_author": "samypr100",
        "comment_body": "I collapsed the output in d9aaafe64f8602e6832a2f098275dc9ed0ff7c56\r\n\r\nThis is how the new output looks like\r\n![new_output](https://user-images.githubusercontent.com/3933065/229815930-bdb5376e-7eb3-4d7d-954c-e3d9e73e5727.png)\r\n\r\nOpen to feedback if we want to change it further\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1157347197",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7529,
        "pr_file": "src/poetry/console/commands/group_command.py",
        "discussion_id": "1156940937",
        "commented_code": "@@ -107,3 +111,36 @@ def project_with_activated_groups_only(self) -> ProjectPackage:\n         return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
        "comment_created_at": "2023-04-04T14:30:46+00:00",
        "comment_author": "radoering",
        "comment_body": "IMO it's not required to mention that only valid groups are allowed and it's not really necessary to mention the option to which the invalid group has been provided. The name of the invalid group should be enough for the user to notice what's wrong. I'd probably just print `Group(s) not found: batman, robin`\r\n\r\nOf course, I'm not the average user so if you think that's too consise please tell me. \ud83d\ude04 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1157378726",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7529,
        "pr_file": "src/poetry/console/commands/group_command.py",
        "discussion_id": "1156940937",
        "commented_code": "@@ -107,3 +111,36 @@ def project_with_activated_groups_only(self) -> ProjectPackage:\n         return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
        "comment_created_at": "2023-04-04T14:53:13+00:00",
        "comment_author": "johnthagen",
        "comment_body": "I agree with @radoering . I think it should be obvious to a user that you need to specify valid groups when using a CLI argument that expects groups.",
        "pr_file_module": null
      },
      {
        "comment_id": "1157431594",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7529,
        "pr_file": "src/poetry/console/commands/group_command.py",
        "discussion_id": "1156940937",
        "commented_code": "@@ -107,3 +111,36 @@ def project_with_activated_groups_only(self) -> ProjectPackage:\n         return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
        "comment_created_at": "2023-04-04T15:30:59+00:00",
        "comment_author": "samypr100",
        "comment_body": "I've updated the message based on the feedback in 0db123efe5c06639d738532efc8fb9118d563f06\r\n\r\nHow about this one?\r\n![new_new_output](https://user-images.githubusercontent.com/3933065/229842581-d946feb2-745a-4756-9633-85b22591a124.png)\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1157433815",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7529,
        "pr_file": "src/poetry/console/commands/group_command.py",
        "discussion_id": "1156940937",
        "commented_code": "@@ -107,3 +111,36 @@ def project_with_activated_groups_only(self) -> ProjectPackage:\n         return self.poetry.package.with_dependency_groups(\n             list(self.activated_groups), only=True\n         )\n+\n+    def validate_group_options(self, group_options: dict[str, set[str]]) -> bool:\n+        \"\"\"\n+        Currently raises en error if it detects that a group is\n+        not part of pyproject.toml\n+\n+        Can be overridden to adapt behavior.\n+        \"\"\"\n+        invalid_options = defaultdict(set)\n+        for opt, groups in group_options.items():\n+            for group in groups:\n+                if not self.poetry.package.has_dependency_group(group):\n+                    invalid_options[opt].add(group)\n+        if invalid_options:\n+            line_err = (\n+                \"<error>The <fg=yellow;options=bold>--with</>, \"\n+                \"<fg=yellow;options=bold>--without</>, \"\n+                \"and <fg=yellow;options=bold>--only</> \"\n+                \"options may only have valid groups.\"\n+            )\n+            for opt, invalid_groups in invalid_options.items():\n+                line_err += (\n+                    \" <fg=red;options=bold>Invalid\"\n+                    f\" [{', '.join(sorted(invalid_groups))}] provided to --{opt}.</>\"\n+                )\n+            line_err += \"</error>\"\n+            self.line_error(line_err)\n+        if len(invalid_options) != 0:\n+            invalid_groups_str = \", \".join(\n+                sorted(set(chain(*invalid_options.values())))\n+            )\n+            raise GroupNotFound(f\"Group(s) [{invalid_groups_str}] were not found.\")",
        "comment_created_at": "2023-04-04T15:32:46+00:00",
        "comment_author": "johnthagen",
        "comment_body": "This looks great to me.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1215345090",
    "pr_number": 8015,
    "pr_file": "src/poetry/console/commands/check.py",
    "created_at": "2023-06-03T08:38:40+00:00",
    "commented_code": "return errors, warnings\n \n     def handle(self) -> int:\n+        if self.option(\"lock\"):\n+            if self.poetry.locker.is_locked() and self.poetry.locker.is_fresh():\n+                self.line(\"poetry.lock is consistent with pyproject.toml.\")\n+                return 0\n+            self.line_error(\n+                \"<error>\"\n+                \"Error: poetry.lock is not consistent with pyproject.toml. \"\n+                \"Run `poetry lock [--no-update]` to fix it.\"\n+                \"</error>\"",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1215345090",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8015,
        "pr_file": "src/poetry/console/commands/check.py",
        "discussion_id": "1215345090",
        "commented_code": "@@ -58,6 +71,18 @@ def validate_classifiers(\n         return errors, warnings\n \n     def handle(self) -> int:\n+        if self.option(\"lock\"):\n+            if self.poetry.locker.is_locked() and self.poetry.locker.is_fresh():\n+                self.line(\"poetry.lock is consistent with pyproject.toml.\")\n+                return 0\n+            self.line_error(\n+                \"<error>\"\n+                \"Error: poetry.lock is not consistent with pyproject.toml. \"\n+                \"Run `poetry lock [--no-update]` to fix it.\"\n+                \"</error>\"",
        "comment_created_at": "2023-06-03T08:38:40+00:00",
        "comment_author": "radoering",
        "comment_body": "I just noticed that we print this error even if there is no lockfile. Maybe, we should make a distinction between \"no lockfile\" and \"inconsistent lockfile\"?",
        "pr_file_module": null
      },
      {
        "comment_id": "1216049753",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8015,
        "pr_file": "src/poetry/console/commands/check.py",
        "discussion_id": "1215345090",
        "commented_code": "@@ -58,6 +71,18 @@ def validate_classifiers(\n         return errors, warnings\n \n     def handle(self) -> int:\n+        if self.option(\"lock\"):\n+            if self.poetry.locker.is_locked() and self.poetry.locker.is_fresh():\n+                self.line(\"poetry.lock is consistent with pyproject.toml.\")\n+                return 0\n+            self.line_error(\n+                \"<error>\"\n+                \"Error: poetry.lock is not consistent with pyproject.toml. \"\n+                \"Run `poetry lock [--no-update]` to fix it.\"\n+                \"</error>\"",
        "comment_created_at": "2023-06-04T01:58:24+00:00",
        "comment_author": "samypr100",
        "comment_body": "Likely resolved by 6125b6a18cdbb7aa1ef8386fcbbe461f3ac81d52 since those errors are now separate checks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1155878603",
    "pr_number": 7756,
    "pr_file": "src/poetry/masonry/builders/editable.py",
    "created_at": "2023-04-03T12:13:33+00:00",
    "commented_code": "scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1155878603",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-03T12:13:33+00:00",
        "comment_author": "radoering",
        "comment_body": "```suggestion\r\n                raise ValueError(f\"Failed to parse script entry point '{script}'\") from exc\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1157523266",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-04T16:52:31+00:00",
        "comment_author": "christokur",
        "comment_body": "Several lint tools recommend against interpolation when instantiating Exceptions. \r\nDo you really want this?",
        "pr_file_module": null
      },
      {
        "comment_id": "1158269382",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-05T09:31:44+00:00",
        "comment_author": "radoering",
        "comment_body": "> Several lint tools recommend against interpolation when instantiating Exceptions.\r\n\r\nSorry, I don't follow. Can you give an example?\r\n\r\nMy reasoning is that you get the original exception via `from exc`. Thus, you don't need `exc.args` it in the derived exception.",
        "pr_file_module": null
      },
      {
        "comment_id": "1158772985",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-05T16:46:47+00:00",
        "comment_author": "christokur",
        "comment_body": "Poetry does not display the stack trace so you have to add the exception info to the message so the user can see what the symptom and cause is in one message",
        "pr_file_module": null
      },
      {
        "comment_id": "1158812105",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-05T17:26:39+00:00",
        "comment_author": "christokur",
        "comment_body": "Also the example\r\n```\r\nresources.py:45: [EM102] Exception must not use an f-string literal, assign to variable first\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1158834299",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-05T17:49:48+00:00",
        "comment_author": "radoering",
        "comment_body": "Thanks for the example. I read the [reasoning to EM102](https://pypi.org/project/flake8-errmsg/0.4.0/) and I'm not sure I'm convinced (especially since we are not printing the traceback by default). Normally, we are using string literals and f-strings without assigning it to a variable first, so there is no reason to deviate from that here.\r\n\r\n> Poetry does not display the stack trace so you have to add the exception info to the message so the user can see what the symptom and cause is in one message\r\n\r\nYou will see the traceback by running poetry with `-vvv`. When not in verbose mode, we shouldn't print the original error message since it is not very helpful anyway. If you think that `f\"Failed to parse script entry point '{script}'\"` is not enough information, then what about `f\"Failed to parse script entry point '{script}', ':' not found\"` or similar?\r\n\r\nBy the way, we have the same script parsing with the same issue in https://github.com/python-poetry/poetry/blob/161b19cb4e4686fc5a0a7925001534a87f6c4052/src/poetry/console/commands/run.py#L73",
        "pr_file_module": null
      },
      {
        "comment_id": "1158854536",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-05T18:11:37+00:00",
        "comment_author": "christokur",
        "comment_body": "This also catches cases where someone does not place any \":\"\r\nAre we overthinking this?",
        "pr_file_module": null
      },
      {
        "comment_id": "1159944082",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7756,
        "pr_file": "src/poetry/masonry/builders/editable.py",
        "discussion_id": "1155878603",
        "commented_code": "@@ -174,7 +174,11 @@ def _add_scripts(self) -> list[Path]:\n         scripts = entry_points.get(\"console_scripts\", [])\n         for script in scripts:\n             name, script = script.split(\" = \")\n-            module, callable_ = script.split(\":\")\n+            try:\n+                module, callable_ = script.split(\":\")\n+            except ValueError as exc:\n+                msg = f\"{exc.args}  - Failed to parse script entry point '{script}'\"\n+                raise ValueError(msg) from exc",
        "comment_created_at": "2023-04-06T15:17:31+00:00",
        "comment_author": "radoering",
        "comment_body": "Good point, my proposal is not accurate enough. However, I still stand by my initial statement.\r\n\r\nIMO `('not enough values to unpack (expected 2, got 1)',)  - Failed to parse script entry point '...'` is not a good error message. Without any context `not enough values to unpack` does not really help. `Failed to parse script entry point '...'` should be good enough. If you want more details you have to run `poetry install -v`. That way you will get the `not enough values to unpack` with the line where it happened.",
        "pr_file_module": null
      }
    ]
  }
]