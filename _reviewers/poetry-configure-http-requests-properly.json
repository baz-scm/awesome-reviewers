[
  {
    "discussion_id": "1503444008",
    "pr_number": 9040,
    "pr_file": "src/poetry/inspection/lazy_wheel.py",
    "created_at": "2024-02-26T23:38:57+00:00",
    "commented_code": "logger.debug(\"initial bytes request: %s\", headers[\"Range\"])\n \n         self._request_count += 1\n-        tail = self._session.get(self._url, headers=headers, stream=True)\n+        tail = self._session.get(self._url, headers=headers, stream=True, allow_redirects=True)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1503444008",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9040,
        "pr_file": "src/poetry/inspection/lazy_wheel.py",
        "discussion_id": "1503444008",
        "commented_code": "@@ -569,7 +571,7 @@ def _try_initial_chunk_request(\n         logger.debug(\"initial bytes request: %s\", headers[\"Range\"])\n \n         self._request_count += 1\n-        tail = self._session.get(self._url, headers=headers, stream=True)\n+        tail = self._session.get(self._url, headers=headers, stream=True, allow_redirects=True)",
        "comment_created_at": "2024-02-26T23:38:57+00:00",
        "comment_author": "abn",
        "comment_body": "```suggestion\r\n        tail = self._session.get(self._url, headers=headers, stream=True)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1029504584",
    "pr_number": 7072,
    "pr_file": "src/poetry/utils/constants.py",
    "created_at": "2022-11-22T15:44:32+00:00",
    "commented_code": "# Timeout for HTTP requests using the requests library.\n REQUESTS_TIMEOUT = 15\n+\n+RETRY_AFTER_HEADER = \"retry-after\"\n+\n+# Server response codes to retry requests on.\n+STATUS_FORCELIST = [429, 500, 501, 502, 503, 504]",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1029504584",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7072,
        "pr_file": "src/poetry/utils/constants.py",
        "discussion_id": "1029504584",
        "commented_code": "@@ -3,3 +3,8 @@\n \n # Timeout for HTTP requests using the requests library.\n REQUESTS_TIMEOUT = 15\n+\n+RETRY_AFTER_HEADER = \"retry-after\"\n+\n+# Server response codes to retry requests on.\n+STATUS_FORCELIST = [429, 500, 501, 502, 503, 504]",
        "comment_created_at": "2022-11-22T15:44:32+00:00",
        "comment_author": "nejch",
        "comment_body": "Notes:\r\n* I'm not sure about the 501, but it was already in the uploader code so kept it for compatibility\r\n* Potentially we could add cloudflare 52x codes since it powers so much of the internet, even if it's not standard. See [Cloudflare docs](https://support.cloudflare.com/hc/en-us/articles/206973867-Status-code-metrics-in-Cloudflare-Site-Analytics#h_3VPW9Ekh0e580wUvfawvQv), [another example](https://github.com/python-gitlab/python-gitlab/blob/1020ce965ff0cd3bfc283d4f0ad40e41e4d1bcee/gitlab/client.py#L25)",
        "pr_file_module": null
      },
      {
        "comment_id": "1155830652",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7072,
        "pr_file": "src/poetry/utils/constants.py",
        "discussion_id": "1029504584",
        "commented_code": "@@ -3,3 +3,8 @@\n \n # Timeout for HTTP requests using the requests library.\n REQUESTS_TIMEOUT = 15\n+\n+RETRY_AFTER_HEADER = \"retry-after\"\n+\n+# Server response codes to retry requests on.\n+STATUS_FORCELIST = [429, 500, 501, 502, 503, 504]",
        "comment_created_at": "2023-04-03T11:24:06+00:00",
        "comment_author": "radoering",
        "comment_body": "I'm fine with adding them if you add a comment with a link so we see where these codes come from.",
        "pr_file_module": null
      },
      {
        "comment_id": "1155920575",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7072,
        "pr_file": "src/poetry/utils/constants.py",
        "discussion_id": "1029504584",
        "commented_code": "@@ -3,3 +3,8 @@\n \n # Timeout for HTTP requests using the requests library.\n REQUESTS_TIMEOUT = 15\n+\n+RETRY_AFTER_HEADER = \"retry-after\"\n+\n+# Server response codes to retry requests on.\n+STATUS_FORCELIST = [429, 500, 501, 502, 503, 504]",
        "comment_created_at": "2023-04-03T12:51:17+00:00",
        "comment_author": "nejch",
        "comment_body": "Thanks - I tried adding them but currently tests will error as httpretty also has a hardcoded list (https://github.com/gabrielfalcao/HTTPretty/blob/f9f012711597634d40066d144a36888b3addcc46/httpretty/http.py#L105-L106), and won't properly mock the non-standard codes.\r\n\r\nMaybe I can add those as a follow-up to keep this PR cleaner then, and I'll see how to make it play well with httpretty.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "748800239",
    "pr_number": 3315,
    "pr_file": "poetry/publishing/uploader.py",
    "created_at": "2021-11-14T05:26:26+00:00",
    "commented_code": ")\n                     )\n                     bar.finish()\n-                elif resp.status_code == 301:\n+                elif resp.status_code in (301, 308):",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "748800239",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 3315,
        "pr_file": "poetry/publishing/uploader.py",
        "discussion_id": "748800239",
        "commented_code": "@@ -272,7 +272,7 @@ def _upload_file(\n                         )\n                     )\n                     bar.finish()\n-                elif resp.status_code == 301:\n+                elif resp.status_code in (301, 308):",
        "comment_created_at": "2021-11-14T05:26:26+00:00",
        "comment_author": "neersighted",
        "comment_body": "Since we're dropping Python 2 support, let's take advantage of the enums in https://docs.python.org/3/library/http.html#http.HTTPStatus instead of using the raw status codes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "315956880",
    "pr_number": 1310,
    "pr_file": "poetry/masonry/publishing/uploader.py",
    "created_at": "2019-08-21T00:25:40+00:00",
    "commented_code": "encoder, lambda monitor: bar.set_progress(monitor.bytes_read)\n             )\n \n+            # Check for a redirect first\n+            resp = session.head(url)\n+            if resp.status_code == status_codes.codes.moved:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "315956880",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 1310,
        "pr_file": "poetry/masonry/publishing/uploader.py",
        "discussion_id": "315956880",
        "commented_code": "@@ -228,6 +229,11 @@ def _upload_file(self, session, url, file):\n                 encoder, lambda monitor: bar.set_progress(monitor.bytes_read)\n             )\n \n+            # Check for a redirect first\n+            resp = session.head(url)\n+            if resp.status_code == status_codes.codes.moved:",
        "comment_created_at": "2019-08-21T00:25:40+00:00",
        "comment_author": "brycedrennan",
        "comment_body": "This approach means we'd have to make two requests every time, even when there is no redirect. Wouldn't we be able to just try the endpoint and then follow the redirect if necessary?",
        "pr_file_module": null
      },
      {
        "comment_id": "316081711",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 1310,
        "pr_file": "poetry/masonry/publishing/uploader.py",
        "discussion_id": "315956880",
        "commented_code": "@@ -228,6 +229,11 @@ def _upload_file(self, session, url, file):\n                 encoder, lambda monitor: bar.set_progress(monitor.bytes_read)\n             )\n \n+            # Check for a redirect first\n+            resp = session.head(url)\n+            if resp.status_code == status_codes.codes.moved:",
        "comment_created_at": "2019-08-21T09:20:09+00:00",
        "comment_author": "sztomi",
        "comment_body": "That's what I did originally, but that means POSTing the package data twice, so anyone who configured the wrong URL for their repo will have a big perf hit. On the other hand, a HEAD request is very cheap and isn't noticeable. Happy to do some benchmarks if you are not convinced.",
        "pr_file_module": null
      },
      {
        "comment_id": "320021942",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 1310,
        "pr_file": "poetry/masonry/publishing/uploader.py",
        "discussion_id": "315956880",
        "commented_code": "@@ -228,6 +229,11 @@ def _upload_file(self, session, url, file):\n                 encoder, lambda monitor: bar.set_progress(monitor.bytes_read)\n             )\n \n+            # Check for a redirect first\n+            resp = session.head(url)\n+            if resp.status_code == status_codes.codes.moved:",
        "comment_created_at": "2019-09-02T17:10:22+00:00",
        "comment_author": "brycedrennan",
        "comment_body": "That's a good point that it would be expensive to POST twice.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "264789902",
    "pr_number": 842,
    "pr_file": "get-poetry.py",
    "created_at": "2019-03-12T17:14:33+00:00",
    "commented_code": "return subprocess.check_output(args, stderr=subprocess.STDOUT)\n \n     def _get(self, url):\n+        \"\"\"Perform a GET request through Python to a specific URL\n+\n+        The URL connection has a specific timeout set to 2 seconds\n+        to prevent indefinite hanging in certain edge cases\n+        \"\"\"\n         request = Request(url, headers={\"User-Agent\": \"Python Poetry\"})\n \n-        with closing(urlopen(request)) as r:\n+        with closing(urlopen(request, timeout=2)) as r:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "264789902",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 842,
        "pr_file": "get-poetry.py",
        "discussion_id": "264789902",
        "commented_code": "@@ -814,9 +814,14 @@ def call(self, *args):\n         return subprocess.check_output(args, stderr=subprocess.STDOUT)\n \n     def _get(self, url):\n+        \"\"\"Perform a GET request through Python to a specific URL\n+\n+        The URL connection has a specific timeout set to 2 seconds\n+        to prevent indefinite hanging in certain edge cases\n+        \"\"\"\n         request = Request(url, headers={\"User-Agent\": \"Python Poetry\"})\n \n-        with closing(urlopen(request)) as r:\n+        with closing(urlopen(request, timeout=2)) as r:",
        "comment_created_at": "2019-03-12T17:14:33+00:00",
        "comment_author": "floer32",
        "comment_body": "This is a good idea but should probably support `POETRY_GET_TIMEOUT` or something with only a _default_ of this value. Also the default value should probably be 60s + ",
        "pr_file_module": null
      }
    ]
  }
]