[
  {
    "discussion_id": "868490225",
    "pr_number": 5584,
    "pr_file": "src/poetry/publishing/publisher.py",
    "created_at": "2022-05-09T21:36:13+00:00",
    "commented_code": "raise RuntimeError(f\"Repository {repository_name} is not defined\")\n \n         if not (username and password):\n-            # Check if we have a token first\n-            token = self._authenticator.get_pypi_token(repository_name)\n+            token = None\n+            if not (username or password):",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "868490225",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 5584,
        "pr_file": "src/poetry/publishing/publisher.py",
        "discussion_id": "868490225",
        "commented_code": "@@ -57,8 +57,11 @@ def publish(\n                 raise RuntimeError(f\"Repository {repository_name} is not defined\")\n \n         if not (username and password):\n-            # Check if we have a token first\n-            token = self._authenticator.get_pypi_token(repository_name)\n+            token = None\n+            if not (username or password):",
        "comment_created_at": "2022-05-09T21:36:13+00:00",
        "comment_author": "abn",
        "comment_body": "I don't think this is desired. ",
        "pr_file_module": null
      },
      {
        "comment_id": "869169701",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 5584,
        "pr_file": "src/poetry/publishing/publisher.py",
        "discussion_id": "868490225",
        "commented_code": "@@ -57,8 +57,11 @@ def publish(\n                 raise RuntimeError(f\"Repository {repository_name} is not defined\")\n \n         if not (username and password):\n-            # Check if we have a token first\n-            token = self._authenticator.get_pypi_token(repository_name)\n+            token = None\n+            if not (username or password):",
        "comment_created_at": "2022-05-10T12:23:40+00:00",
        "comment_author": "dszakallas",
        "comment_body": "The original behavior would overwrite any value passed via CLI, if either is missing and a token is found (e.g if a username is passed and a token is found, then it would discard the username). Do we want to consider token auth if there's a username? I am happy to change back to the original behavior, although I find it a bit unintuitive.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1125940162",
    "pr_number": 7594,
    "pr_file": "src/poetry/installation/executor.py",
    "created_at": "2023-03-06T05:41:32+00:00",
    "commented_code": "@staticmethod\n     def _validate_archive_hash(archive: Path, package: Package) -> str:\n         archive_hash: str = \"sha256:\" + get_file_hash(archive)\n-        known_hashes = {f[\"hash\"] for f in package.files}\n+        known_hashes = {f[\"hash\"] for f in package.files if f[\"file\"] == archive.name}\n \n-        if archive_hash not in known_hashes:\n+        if known_hashes and archive_hash not in known_hashes:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1125940162",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "src/poetry/installation/executor.py",
        "discussion_id": "1125940162",
        "commented_code": "@@ -729,9 +743,9 @@ def _populate_hashes_dict(self, archive: Path, package: Package) -> None:\n     @staticmethod\n     def _validate_archive_hash(archive: Path, package: Package) -> str:\n         archive_hash: str = \"sha256:\" + get_file_hash(archive)\n-        known_hashes = {f[\"hash\"] for f in package.files}\n+        known_hashes = {f[\"hash\"] for f in package.files if f[\"file\"] == archive.name}\n \n-        if archive_hash not in known_hashes:\n+        if known_hashes and archive_hash not in known_hashes:",
        "comment_created_at": "2023-03-06T05:41:32+00:00",
        "comment_author": "radoering",
        "comment_body": "Is this still necessary? Shouldn't there always be as hash now?",
        "pr_file_module": null
      },
      {
        "comment_id": "1126138770",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "src/poetry/installation/executor.py",
        "discussion_id": "1125940162",
        "commented_code": "@@ -729,9 +743,9 @@ def _populate_hashes_dict(self, archive: Path, package: Package) -> None:\n     @staticmethod\n     def _validate_archive_hash(archive: Path, package: Package) -> str:\n         archive_hash: str = \"sha256:\" + get_file_hash(archive)\n-        known_hashes = {f[\"hash\"] for f in package.files}\n+        known_hashes = {f[\"hash\"] for f in package.files if f[\"file\"] == archive.name}\n \n-        if archive_hash not in known_hashes:\n+        if known_hashes and archive_hash not in known_hashes:",
        "comment_created_at": "2023-03-06T09:24:12+00:00",
        "comment_author": "quantum-byte",
        "comment_body": "I am not sure about this. Is there a standard in pypy that a package downloaded from a url needs to provide a hash ? \r\n\r\nIn case there is no hash we would run into an empty set here. On second though, it would already fail in line 746 accessing `f[\"hash\"]`\r\n\r\nI can remove it, if we can assume that every package.files entry has a hash",
        "pr_file_module": null
      },
      {
        "comment_id": "1126736439",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "src/poetry/installation/executor.py",
        "discussion_id": "1125940162",
        "commented_code": "@@ -729,9 +743,9 @@ def _populate_hashes_dict(self, archive: Path, package: Package) -> None:\n     @staticmethod\n     def _validate_archive_hash(archive: Path, package: Package) -> str:\n         archive_hash: str = \"sha256:\" + get_file_hash(archive)\n-        known_hashes = {f[\"hash\"] for f in package.files}\n+        known_hashes = {f[\"hash\"] for f in package.files if f[\"file\"] == archive.name}\n \n-        if archive_hash not in known_hashes:\n+        if known_hashes and archive_hash not in known_hashes:",
        "comment_created_at": "2023-03-06T16:41:55+00:00",
        "comment_author": "radoering",
        "comment_body": "We assumed it before this PR. If there the set of known hashes is empty, the hash is not known and we should fail for security reasons. I wouldn't weaken that constraint if it is not necessary.",
        "pr_file_module": null
      },
      {
        "comment_id": "1126880490",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "src/poetry/installation/executor.py",
        "discussion_id": "1125940162",
        "commented_code": "@@ -729,9 +743,9 @@ def _populate_hashes_dict(self, archive: Path, package: Package) -> None:\n     @staticmethod\n     def _validate_archive_hash(archive: Path, package: Package) -> str:\n         archive_hash: str = \"sha256:\" + get_file_hash(archive)\n-        known_hashes = {f[\"hash\"] for f in package.files}\n+        known_hashes = {f[\"hash\"] for f in package.files if f[\"file\"] == archive.name}\n \n-        if archive_hash not in known_hashes:\n+        if known_hashes and archive_hash not in known_hashes:",
        "comment_created_at": "2023-03-06T18:46:21+00:00",
        "comment_author": "quantum-byte",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "204576678",
    "pr_number": 306,
    "pr_file": "poetry/repositories/legacy_repository.py",
    "created_at": "2018-07-23T22:47:09+00:00",
    "commented_code": "requests.session(), cache=FileCache(str(self._cache_dir / \"_http\"))\n         )\n \n+        url_parts = urlparse.urlparse(self._url)\n+        if not url_parts.username:\n+            username, password = get_http_basic_auth(self.name)\n+            if username and password:\n+                netloc = \"{}:{}@{}\".format(username, password, url_parts.netloc)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "204576678",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 306,
        "pr_file": "poetry/repositories/legacy_repository.py",
        "discussion_id": "204576678",
        "commented_code": "@@ -159,6 +160,15 @@ def __init__(self, name, url, disable_cache=False):\n             requests.session(), cache=FileCache(str(self._cache_dir / \"_http\"))\n         )\n \n+        url_parts = urlparse.urlparse(self._url)\n+        if not url_parts.username:\n+            username, password = get_http_basic_auth(self.name)\n+            if username and password:\n+                netloc = \"{}:{}@{}\".format(username, password, url_parts.netloc)",
        "comment_created_at": "2018-07-23T22:47:09+00:00",
        "comment_author": "sdispater",
        "comment_body": "Instead of recreating the url by hand we can just pass the auth information to the session created in `__init__()`. That way the `_url` attribute is left untouched while still providing the auth information to each request made to the remote url.\r\n\r\n```python\r\nself._session.auth = get_http_basic_auth(self.name)\r\n```\r\nFor this to work we have to make a small change to `get_http_basic_auth()` so that it returns `None` when no authentication information could be found. This makes the code much simpler since we don't have to chech each time if username/password exist.\u00a0\r\n```",
        "pr_file_module": null
      }
    ]
  }
]