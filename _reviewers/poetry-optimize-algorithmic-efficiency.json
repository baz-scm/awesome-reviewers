[
  {
    "discussion_id": "1836822671",
    "pr_number": 9748,
    "pr_file": "src/poetry/vcs/git/backend.py",
    "created_at": "2024-11-11T15:08:19+00:00",
    "commented_code": "if isinstance(e, AssertionError) and \"Invalid object name\" not in str(e):\n                 raise\n \n-            logger.debug(\n-                \"\nRequested ref (<c2>%s</c2>) was not fetched to local copy and\"\n-                \" cannot be used. The following error was\"\n-                \" raised:\n\n\\t<warning>%s</>\",\n-                refspec.key,\n-                e,\n-            )\n+            short_ref_found = False\n \n-            raise PoetryConsoleError(\n-                f\"Failed to clone {url} at '{refspec.key}', verify ref exists on\"\n-                \" remote.\"\n-            )\n+            if refspec.is_sha_short:\n+                commit = cls._find_object_by_sha_prefix(local, refspec.key.encode())\n+                if commit is not None:\n+                    logger.debug(\n+                        \"\nResolved short SHA <c2>%s</c2> as <c2>%s</c2>\",\n+                        refspec.key,\n+                        commit.id,\n+                    )\n+                    local.refs[b\"HEAD\"] = commit.id\n+                    with local:\n+                        local.reset_index()\n+                    short_ref_found = True\n+\n+            if not short_ref_found:\n+                raise PoetryConsoleError(\n+                    f\"Failed to clone {url} at '{refspec.key}', verify ref exists on\"\n+                    \" remote.\"\n+                )\n \n         return local\n \n+    @classmethod\n+    def _find_object_by_sha_prefix(cls, repo: Repo, sha_prefix: bytes) -> Commit | None:\n+        for sha in repo.object_store:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1836822671",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9748,
        "pr_file": "src/poetry/vcs/git/backend.py",
        "discussion_id": "1836822671",
        "commented_code": "@@ -313,21 +314,38 @@ def _clone(cls, url: str, refspec: GitRefSpec, target: Path) -> Repo:\n             if isinstance(e, AssertionError) and \"Invalid object name\" not in str(e):\n                 raise\n \n-            logger.debug(\n-                \"\\nRequested ref (<c2>%s</c2>) was not fetched to local copy and\"\n-                \" cannot be used. The following error was\"\n-                \" raised:\\n\\n\\t<warning>%s</>\",\n-                refspec.key,\n-                e,\n-            )\n+            short_ref_found = False\n \n-            raise PoetryConsoleError(\n-                f\"Failed to clone {url} at '{refspec.key}', verify ref exists on\"\n-                \" remote.\"\n-            )\n+            if refspec.is_sha_short:\n+                commit = cls._find_object_by_sha_prefix(local, refspec.key.encode())\n+                if commit is not None:\n+                    logger.debug(\n+                        \"\\nResolved short SHA <c2>%s</c2> as <c2>%s</c2>\",\n+                        refspec.key,\n+                        commit.id,\n+                    )\n+                    local.refs[b\"HEAD\"] = commit.id\n+                    with local:\n+                        local.reset_index()\n+                    short_ref_found = True\n+\n+            if not short_ref_found:\n+                raise PoetryConsoleError(\n+                    f\"Failed to clone {url} at '{refspec.key}', verify ref exists on\"\n+                    \" remote.\"\n+                )\n \n         return local\n \n+    @classmethod\n+    def _find_object_by_sha_prefix(cls, repo: Repo, sha_prefix: bytes) -> Commit | None:\n+        for sha in repo.object_store:",
        "comment_created_at": "2024-11-11T15:08:19+00:00",
        "comment_author": "jelmer",
        "comment_body": "```suggestion\n        for sha in repo.object_store.iter_prefix(prefix):\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "950870877",
    "pr_number": 5841,
    "pr_file": "src/poetry/repositories/link_sources/base.py",
    "created_at": "2022-08-21T16:32:15+00:00",
    "commented_code": "the link, it will be rewritten to %20 (while not over-quoting\n         % or other characters).\"\"\"\n         return self.CLEAN_REGEX.sub(lambda match: f\"%{ord(match.group(0)):02x}\", url)\n+\n+    def yanked(self, name: NormalizedName, version: Version) -> str | bool:\n+        reasons = []\n+        for link in self.links_for_version(name, version):\n+            if link.yanked:\n+                if link.yanked_reason and link.yanked_reason not in reasons:\n+                    reasons.append(link.yanked_reason)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "950870877",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 5841,
        "pr_file": "src/poetry/repositories/link_sources/base.py",
        "discussion_id": "950870877",
        "commented_code": "@@ -113,3 +113,17 @@ def clean_link(self, url: str) -> str:\n         the link, it will be rewritten to %20 (while not over-quoting\n         % or other characters).\"\"\"\n         return self.CLEAN_REGEX.sub(lambda match: f\"%{ord(match.group(0)):02x}\", url)\n+\n+    def yanked(self, name: NormalizedName, version: Version) -> str | bool:\n+        reasons = []\n+        for link in self.links_for_version(name, version):\n+            if link.yanked:\n+                if link.yanked_reason and link.yanked_reason not in reasons:\n+                    reasons.append(link.yanked_reason)",
        "comment_created_at": "2022-08-21T16:32:15+00:00",
        "comment_author": "mkniewallner",
        "comment_body": "Is the order for `reasons` important? If not, what about:\r\n```suggestion\r\n        reasons = set()\r\n        for link in self.links_for_version(name, version):\r\n            if link.yanked:\r\n                if link.yanked_reason:\r\n                    reasons.add(link.yanked_reason)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "950886346",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 5841,
        "pr_file": "src/poetry/repositories/link_sources/base.py",
        "discussion_id": "950870877",
        "commented_code": "@@ -113,3 +113,17 @@ def clean_link(self, url: str) -> str:\n         the link, it will be rewritten to %20 (while not over-quoting\n         % or other characters).\"\"\"\n         return self.CLEAN_REGEX.sub(lambda match: f\"%{ord(match.group(0)):02x}\", url)\n+\n+    def yanked(self, name: NormalizedName, version: Version) -> str | bool:\n+        reasons = []\n+        for link in self.links_for_version(name, version):\n+            if link.yanked:\n+                if link.yanked_reason and link.yanked_reason not in reasons:\n+                    reasons.append(link.yanked_reason)",
        "comment_created_at": "2022-08-21T18:53:56+00:00",
        "comment_author": "radoering",
        "comment_body": "Probably not. I'm not even sure if there are real world examples for this edge case. Usually, there is just one reason. I'll change it to a `set` and add a `sorted` to the `join` (for reproducable output).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1688474077",
    "pr_number": 6969,
    "pr_file": "src/poetry/puzzle/provider.py",
    "created_at": "2024-07-23T17:49:25+00:00",
    "commented_code": "and (not self._env or marker.validate(self._env.marker_env))\n         )\n \n+    def _add_implicit_dependencies(\n+        self,\n+        dependencies: Iterable[Dependency],\n+        active_extras: Collection[NormalizedName] | None,\n+    ) -> list[Dependency]:\n+        \"\"\"\n+        This handles an edge case where the dependency is not required for a subset\n+        of possible environments. We have to create such an implicit \"not required\"\n+        dependency in order to not miss other dependencies later.\n+        For instance:\n+            \u2022 foo (1.0) ; python == 3.7\n+            \u2022 foo (2.0) ; python == 3.8\n+            \u2022 bar (2.0) ; python == 3.8\n+            \u2022 bar (3.0) ; python == 3.9\n+        the last dependency would be missed without this,\n+        because the intersection with both foo dependencies is empty.\n+\n+        A special case of this edge case is a restricted dependency with a single\n+        constraint, see https://github.com/python-poetry/poetry/issues/5506\n+        for details.\n+        \"\"\"\n+        by_name: dict[str, list[Dependency]] = defaultdict(list)\n+        for dep in dependencies:\n+            by_name[dep.name].append(dep)\n+        for _name, deps in by_name.items():\n+            marker = marker_union(*[d.marker for d in deps])\n+            if marker.is_any():\n+                continue\n+            inverted_marker = marker.invert()\n+            if self._is_relevant_marker(inverted_marker, active_extras):\n+                # Set constraint to empty to mark dependency as \"not required\".\n+                inverted_marker_dep = deps[0].with_constraint(EmptyConstraint())\n+                inverted_marker_dep.marker = inverted_marker\n+                deps.append(inverted_marker_dep)\n+        return [dep for deps in by_name.values() for dep in deps]",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1688474077",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 6969,
        "pr_file": "src/poetry/puzzle/provider.py",
        "discussion_id": "1688474077",
        "commented_code": "@@ -856,6 +858,42 @@ def _is_relevant_marker(\n             and (not self._env or marker.validate(self._env.marker_env))\n         )\n \n+    def _add_implicit_dependencies(\n+        self,\n+        dependencies: Iterable[Dependency],\n+        active_extras: Collection[NormalizedName] | None,\n+    ) -> list[Dependency]:\n+        \"\"\"\n+        This handles an edge case where the dependency is not required for a subset\n+        of possible environments. We have to create such an implicit \"not required\"\n+        dependency in order to not miss other dependencies later.\n+        For instance:\n+            \u2022 foo (1.0) ; python == 3.7\n+            \u2022 foo (2.0) ; python == 3.8\n+            \u2022 bar (2.0) ; python == 3.8\n+            \u2022 bar (3.0) ; python == 3.9\n+        the last dependency would be missed without this,\n+        because the intersection with both foo dependencies is empty.\n+\n+        A special case of this edge case is a restricted dependency with a single\n+        constraint, see https://github.com/python-poetry/poetry/issues/5506\n+        for details.\n+        \"\"\"\n+        by_name: dict[str, list[Dependency]] = defaultdict(list)\n+        for dep in dependencies:\n+            by_name[dep.name].append(dep)\n+        for _name, deps in by_name.items():\n+            marker = marker_union(*[d.marker for d in deps])\n+            if marker.is_any():\n+                continue\n+            inverted_marker = marker.invert()\n+            if self._is_relevant_marker(inverted_marker, active_extras):\n+                # Set constraint to empty to mark dependency as \"not required\".\n+                inverted_marker_dep = deps[0].with_constraint(EmptyConstraint())\n+                inverted_marker_dep.marker = inverted_marker\n+                deps.append(inverted_marker_dep)\n+        return [dep for deps in by_name.values() for dep in deps]",
        "comment_created_at": "2024-07-23T17:49:25+00:00",
        "comment_author": "jorenham",
        "comment_body": "```suggestion\r\n        return itertools.chain.from_iterable(by_name.values())\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1688486460",
    "pr_number": 6969,
    "pr_file": "src/poetry/puzzle/provider.py",
    "created_at": "2024-07-23T17:59:41+00:00",
    "commented_code": "and (not self._env or marker.validate(self._env.marker_env))\n         )\n \n+    def _add_implicit_dependencies(\n+        self,\n+        dependencies: Iterable[Dependency],\n+        active_extras: Collection[NormalizedName] | None,\n+    ) -> list[Dependency]:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1688486460",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 6969,
        "pr_file": "src/poetry/puzzle/provider.py",
        "discussion_id": "1688486460",
        "commented_code": "@@ -856,6 +858,42 @@ def _is_relevant_marker(\n             and (not self._env or marker.validate(self._env.marker_env))\n         )\n \n+    def _add_implicit_dependencies(\n+        self,\n+        dependencies: Iterable[Dependency],\n+        active_extras: Collection[NormalizedName] | None,\n+    ) -> list[Dependency]:",
        "comment_created_at": "2024-07-23T17:59:41+00:00",
        "comment_author": "jorenham",
        "comment_body": "The return value here is used only for `_get_dependencies_with_overrides`, which (unlike the annotations suggest), should accept any `Iterable[Dependency]`.\r\nSo it doesn't need to return a list; any iterable will do:\r\n\r\n```suggestion\r\n    ) -> Iterable[Dependency]:\r\n```\r\n\r\nWith this, you can avoid creating the entire dependency list, e.g. using `itertools`, or by turning this method into a generator .",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1688523351",
    "pr_number": 6969,
    "pr_file": "src/poetry/puzzle/provider.py",
    "created_at": "2024-07-23T18:33:11+00:00",
    "commented_code": "dependencies = self._merge_dependencies_by_constraint(dependencies)\n \n         new_dependencies = []\n+\n+        # We have can sort out the implicit \"not required\" dependency determined\n+        # in _add_implicit_dependencies, because it does not overlap with\n+        # any other dependency for sure.\n+        for i, dep in enumerate(dependencies):\n+            if dep.constraint.is_empty():\n+                new_dependencies.append(dependencies.pop(i))",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1688523351",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 6969,
        "pr_file": "src/poetry/puzzle/provider.py",
        "discussion_id": "1688523351",
        "commented_code": "@@ -878,7 +916,20 @@ def _resolve_overlapping_markers(\n         dependencies = self._merge_dependencies_by_constraint(dependencies)\n \n         new_dependencies = []\n+\n+        # We have can sort out the implicit \"not required\" dependency determined\n+        # in _add_implicit_dependencies, because it does not overlap with\n+        # any other dependency for sure.\n+        for i, dep in enumerate(dependencies):\n+            if dep.constraint.is_empty():\n+                new_dependencies.append(dependencies.pop(i))",
        "comment_created_at": "2024-07-23T18:33:11+00:00",
        "comment_author": "jorenham",
        "comment_body": "The `list.pop` method can be very slow operation, and I think that it can be avoided here, by using a \"blacklist\" approach, e.g.\r\n\r\n```python\r\nblacklist = set()\r\nfor dep in dependencies:\r\n    if dep.constraint.is_empty():\r\n        blacklist.add(dep)\r\n        break\r\n```\r\n\r\nThen later on in `itertools.product` use \r\n`repeat=len(dependencies) - len(blacklist)`.\r\nAnd when looping over `dep in dependencies` again, simply skip it if `dep in blacklist`.\r\n\r\nThis avoids the `list.pop` operation, which has a time-complexity `O(n)`, by relying on `set.__contains__`, which is only `O(1)`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1305857945",
    "pr_number": 8359,
    "pr_file": "src/poetry/utils/env/virtual_env.py",
    "created_at": "2023-08-25T16:09:12+00:00",
    "commented_code": "def _updated_path(self) -> str:\n         return os.pathsep.join([str(self._bin_dir), os.environ.get(\"PATH\", \"\")])\n+\n+    def includes_system_site_packages(self) -> bool:\n+        pyvenv_cfg = self._path / \"pyvenv.cfg\"\n+        return \"include-system-site-packages = true\" in pyvenv_cfg.read_text()\n+\n+    def is_path_relative_to_lib(self, path: Path) -> bool:\n+        system_env = SystemEnv(Path(sys.prefix))\n+        return (\n+            self.includes_system_site_packages()\n+            and system_env.is_path_relative_to_lib(path)\n+        ) or super().is_path_relative_to_lib(path)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1305857945",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8359,
        "pr_file": "src/poetry/utils/env/virtual_env.py",
        "discussion_id": "1305857945",
        "commented_code": "@@ -133,3 +135,14 @@ def temp_environ(self) -> Iterator[None]:\n \n     def _updated_path(self) -> str:\n         return os.pathsep.join([str(self._bin_dir), os.environ.get(\"PATH\", \"\")])\n+\n+    def includes_system_site_packages(self) -> bool:\n+        pyvenv_cfg = self._path / \"pyvenv.cfg\"\n+        return \"include-system-site-packages = true\" in pyvenv_cfg.read_text()\n+\n+    def is_path_relative_to_lib(self, path: Path) -> bool:\n+        system_env = SystemEnv(Path(sys.prefix))\n+        return (\n+            self.includes_system_site_packages()\n+            and system_env.is_path_relative_to_lib(path)\n+        ) or super().is_path_relative_to_lib(path)",
        "comment_created_at": "2023-08-25T16:09:12+00:00",
        "comment_author": "radoering",
        "comment_body": "```suggestion\r\n        return super().is_path_relative_to_lib(path) or (\r\n            self.includes_system_site_packages()\r\n            and SystemEnv(Path(sys.prefix)).is_path_relative_to_lib(path)\r\n        )\r\n```\r\n\r\nThat way we don't have to create a SystemEnv and call additional methods in the default case (where system site packages are not included).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1443967708",
    "pr_number": 8851,
    "pr_file": "src/poetry/utils/helpers.py",
    "created_at": "2024-01-07T09:24:36+00:00",
    "commented_code": "from poetry.utils.authenticator import Authenticator\n \n \n+prioritised_hash_types: list[str] = [\n+    t\n+    for t in [\n+        \"sha3_512\",\n+        \"sha3_384\",\n+        \"sha3_256\",\n+        \"sha3_224\",\n+        \"sha512\",\n+        \"sha384\",\n+        \"sha256\",\n+        \"sha224\",\n+        \"shake_256\",\n+        \"shake_128\",\n+        \"blake2s\",\n+        \"blake2b\",\n+        \"sha1\",\n+        \"md5\",\n+    ]\n+    if t in hashlib.algorithms_available\n+]\n+\n+",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1443967708",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8851,
        "pr_file": "src/poetry/utils/helpers.py",
        "discussion_id": "1443967708",
        "commented_code": "@@ -37,6 +37,28 @@\n     from poetry.utils.authenticator import Authenticator\n \n \n+prioritised_hash_types: list[str] = [\n+    t\n+    for t in [\n+        \"sha3_512\",\n+        \"sha3_384\",\n+        \"sha3_256\",\n+        \"sha3_224\",\n+        \"sha512\",\n+        \"sha384\",\n+        \"sha256\",\n+        \"sha224\",\n+        \"shake_256\",\n+        \"shake_128\",\n+        \"blake2s\",\n+        \"blake2b\",\n+        \"sha1\",\n+        \"md5\",\n+    ]\n+    if t in hashlib.algorithms_available\n+]\n+\n+",
        "comment_created_at": "2024-01-07T09:24:36+00:00",
        "comment_author": "radoering",
        "comment_body": "```suggestion\r\n\r\nnon_prioritized_hash_types = hashlib.algorithms_available - set(prioritized_hash_types)\r\n\r\n```",
        "pr_file_module": null
      }
    ]
  }
]