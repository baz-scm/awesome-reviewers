[
  {
    "discussion_id": "2071909328",
    "pr_number": 10361,
    "pr_file": "tests/utils/env/test_env.py",
    "created_at": "2025-05-02T17:08:07+00:00",
    "commented_code": "assert re.match(r\"pip \\S+ from\", output)\n \n \n+@pytest.mark.parametrize(\"differing_platform\", [True, False])\n def test_env_get_supported_tags_matches_inside_virtualenv(\n-    tmp_path: Path, manager: EnvManager\n+    tmp_path: Path, manager: EnvManager, mocker: MockerFixture, differing_platform: bool\n ) -> None:\n     venv_path = tmp_path / \"Virtual Env\"\n     manager.build_venv(venv_path)\n     venv = VirtualEnv(venv_path)\n \n-    import packaging.tags\n+    run_python_script_spy = mocker.spy(venv, \"run_python_script\")\n+\n+    # determine expected tags before patching sysconfig!\n+    expected_tags = list(packaging.tags.sys_tags())\n+\n+    if differing_platform:\n+        mocker.patch(\"sysconfig.get_platform\", return_value=\"some_other_platform\")\n \n-    assert venv.get_supported_tags() == list(packaging.tags.sys_tags())\n+    assert venv.get_supported_tags() == expected_tags\n+    assert run_python_script_spy.call_count == (2 if differing_platform else 1)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "2071909328",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10361,
        "pr_file": "tests/utils/env/test_env.py",
        "discussion_id": "2071909328",
        "commented_code": "@@ -92,16 +93,24 @@ def test_env_commands_with_spaces_in_their_arg_work_as_expected(\n     assert re.match(r\"pip \\S+ from\", output)\n \n \n+@pytest.mark.parametrize(\"differing_platform\", [True, False])\n def test_env_get_supported_tags_matches_inside_virtualenv(\n-    tmp_path: Path, manager: EnvManager\n+    tmp_path: Path, manager: EnvManager, mocker: MockerFixture, differing_platform: bool\n ) -> None:\n     venv_path = tmp_path / \"Virtual Env\"\n     manager.build_venv(venv_path)\n     venv = VirtualEnv(venv_path)\n \n-    import packaging.tags\n+    run_python_script_spy = mocker.spy(venv, \"run_python_script\")\n+\n+    # determine expected tags before patching sysconfig!\n+    expected_tags = list(packaging.tags.sys_tags())\n+\n+    if differing_platform:\n+        mocker.patch(\"sysconfig.get_platform\", return_value=\"some_other_platform\")\n \n-    assert venv.get_supported_tags() == list(packaging.tags.sys_tags())\n+    assert venv.get_supported_tags() == expected_tags\n+    assert run_python_script_spy.call_count == (2 if differing_platform else 1)",
        "comment_created_at": "2025-05-02T17:08:07+00:00",
        "comment_author": "Secrus",
        "comment_body": "Instead of inline condition, can you add an extra variable and set it in the `if` in line 109, so that we have a single conditioning place? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2071962210",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10361,
        "pr_file": "tests/utils/env/test_env.py",
        "discussion_id": "2071909328",
        "commented_code": "@@ -92,16 +93,24 @@ def test_env_commands_with_spaces_in_their_arg_work_as_expected(\n     assert re.match(r\"pip \\S+ from\", output)\n \n \n+@pytest.mark.parametrize(\"differing_platform\", [True, False])\n def test_env_get_supported_tags_matches_inside_virtualenv(\n-    tmp_path: Path, manager: EnvManager\n+    tmp_path: Path, manager: EnvManager, mocker: MockerFixture, differing_platform: bool\n ) -> None:\n     venv_path = tmp_path / \"Virtual Env\"\n     manager.build_venv(venv_path)\n     venv = VirtualEnv(venv_path)\n \n-    import packaging.tags\n+    run_python_script_spy = mocker.spy(venv, \"run_python_script\")\n+\n+    # determine expected tags before patching sysconfig!\n+    expected_tags = list(packaging.tags.sys_tags())\n+\n+    if differing_platform:\n+        mocker.patch(\"sysconfig.get_platform\", return_value=\"some_other_platform\")\n \n-    assert venv.get_supported_tags() == list(packaging.tags.sys_tags())\n+    assert venv.get_supported_tags() == expected_tags\n+    assert run_python_script_spy.call_count == (2 if differing_platform else 1)",
        "comment_created_at": "2025-05-02T17:56:07+00:00",
        "comment_author": "radoering",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1997285412",
    "pr_number": 10278,
    "pr_file": "src/poetry/installation/chooser.py",
    "created_at": "2025-03-15T20:21:47+00:00",
    "commented_code": "continue\n \n             if link.is_sdist and not self._only_binary_policy.allows(package.name):\n-                logger.debug(\n-                    \"Skipping source distribution for %s as requested in only binary policy for\"\n-                    \" package (%s)\",\n-                    link.filename,\n-                    package.name,\n-                )\n-                sdists_skipped += 1\n-                continue\n+                if not self._no_binary_policy.allows(package.name):",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1997285412",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10278,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1997285412",
        "commented_code": "@@ -85,14 +85,18 @@ def choose_for(self, package: Package) -> Link:\n                 continue\n \n             if link.is_sdist and not self._only_binary_policy.allows(package.name):\n-                logger.debug(\n-                    \"Skipping source distribution for %s as requested in only binary policy for\"\n-                    \" package (%s)\",\n-                    link.filename,\n-                    package.name,\n-                )\n-                sdists_skipped += 1\n-                continue\n+                if not self._no_binary_policy.allows(package.name):",
        "comment_created_at": "2025-03-15T20:21:47+00:00",
        "comment_author": "dimbleby",
        "comment_body": "Don't write:\r\n```python\r\nif not condition:\r\n    pass\r\nelse:\r\n    do something\r\n```\r\n\r\nPrefer simply\r\n```python\r\nif condition:\r\n    do something\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1997407851",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10278,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1997285412",
        "commented_code": "@@ -85,14 +85,18 @@ def choose_for(self, package: Package) -> Link:\n                 continue\n \n             if link.is_sdist and not self._only_binary_policy.allows(package.name):\n-                logger.debug(\n-                    \"Skipping source distribution for %s as requested in only binary policy for\"\n-                    \" package (%s)\",\n-                    link.filename,\n-                    package.name,\n-                )\n-                sdists_skipped += 1\n-                continue\n+                if not self._no_binary_policy.allows(package.name):",
        "comment_created_at": "2025-03-15T23:20:54+00:00",
        "comment_author": "yokomotod",
        "comment_body": "fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1936979960",
    "pr_number": 10126,
    "pr_file": "src/poetry/installation/chooser.py",
    "created_at": "2025-01-31T10:01:27+00:00",
    "commented_code": "link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1936979960",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936979960",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []",
        "comment_created_at": "2025-01-31T10:01:27+00:00",
        "comment_author": "Secrus",
        "comment_body": "Should we move that error message gluing to a separate method to avoid having long methods/functions?",
        "pr_file_module": null
      },
      {
        "comment_id": "1937136318",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936979960",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []",
        "comment_created_at": "2025-01-31T12:14:44+00:00",
        "comment_author": "abn",
        "comment_body": "Kind of feel that is an unnecessary optimisation. And it can increase cognitive load. But if you really think there is a benefit to it, I won't oppose.",
        "pr_file_module": null
      },
      {
        "comment_id": "1937143951",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936979960",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []",
        "comment_created_at": "2025-01-31T12:20:57+00:00",
        "comment_author": "abn",
        "comment_body": "On second though, might not be a bad idea as this allows for better testing.",
        "pr_file_module": null
      },
      {
        "comment_id": "1937298055",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936979960",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []",
        "comment_created_at": "2025-01-31T13:12:41+00:00",
        "comment_author": "Secrus",
        "comment_body": "The main benefit I see is not having methods that require scrolling up and down to understand context. I like to be able to read the whole method on one screen and if needed go to another function for more details.",
        "pr_file_module": null
      },
      {
        "comment_id": "1937360169",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10126,
        "pr_file": "src/poetry/installation/chooser.py",
        "discussion_id": "1936979960",
        "commented_code": "@@ -80,12 +91,67 @@ def choose_for(self, package: Package) -> Link:\n                     link.filename,\n                     package.name,\n                 )\n+                sdists_skipped += 1\n                 continue\n \n             links.append(link)\n \n         if not links:\n-            raise RuntimeError(f\"Unable to find installation candidates for {package}\")\n+            messages = []",
        "comment_created_at": "2025-01-31T13:55:46+00:00",
        "comment_author": "abn",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1904113709",
    "pr_number": 9946,
    "pr_file": "src/poetry/console/commands/sync.py",
    "created_at": "2025-01-06T12:49:26+00:00",
    "commented_code": "If you want to use Poetry only for dependency management but not for packaging,\n you can set the \"package-mode\" to false in your pyproject.toml file.\n \"\"\"\n+\n+    def handle(self) -> int:\n+        return self._handle_install(True)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1904113709",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9946,
        "pr_file": "src/poetry/console/commands/sync.py",
        "discussion_id": "1904113709",
        "commented_code": "@@ -34,3 +34,6 @@ class SyncCommand(InstallCommand):\n If you want to use Poetry only for dependency management but not for packaging,\n you can set the \"package-mode\" to false in your pyproject.toml file.\n \"\"\"\n+\n+    def handle(self) -> int:\n+        return self._handle_install(True)",
        "comment_created_at": "2025-01-06T12:49:26+00:00",
        "comment_author": "Secrus",
        "comment_body": "```suggestion\r\n        return self._handle_install(with_synchronization=True)\r\n```\r\nA small nitpick, but let's avoid nameless boolean calls.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "950869323",
    "pr_number": 5841,
    "pr_file": "src/poetry/repositories/link_sources/html.py",
    "created_at": "2022-08-21T16:19:13+00:00",
    "commented_code": "url = self.clean_link(urllib.parse.urljoin(self._url, href))\n                 pyrequire = anchor.get(\"data-requires-python\")\n                 pyrequire = unescape(pyrequire) if pyrequire else None\n-                link = Link(url, requires_python=pyrequire)\n+                yanked_value = anchor.get(\"data-yanked\")\n+                yanked: str | bool\n+                if yanked_value:\n+                    yanked = unescape(yanked_value)\n+                else:\n+                    yanked = \"data-yanked\" in anchor.keys()  # noqa: SIM118",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "950869323",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 5841,
        "pr_file": "src/poetry/repositories/link_sources/html.py",
        "discussion_id": "950869323",
        "commented_code": "@@ -33,7 +33,13 @@ def links(self) -> Iterator[Link]:\n                 url = self.clean_link(urllib.parse.urljoin(self._url, href))\n                 pyrequire = anchor.get(\"data-requires-python\")\n                 pyrequire = unescape(pyrequire) if pyrequire else None\n-                link = Link(url, requires_python=pyrequire)\n+                yanked_value = anchor.get(\"data-yanked\")\n+                yanked: str | bool\n+                if yanked_value:\n+                    yanked = unescape(yanked_value)\n+                else:\n+                    yanked = \"data-yanked\" in anchor.keys()  # noqa: SIM118",
        "comment_created_at": "2022-08-21T16:19:13+00:00",
        "comment_author": "mkniewallner",
        "comment_body": "nit: This clearly is a false positive of `flake8-simplify`, but in case we want to avoid a `# noqa`, this should work the same, since we'll access the raw dictionary:\r\n```suggestion\r\n                    yanked = \"data-yanked\" in anchor.attrib\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1766702843",
    "pr_number": 9658,
    "pr_file": "src/poetry/installation/executor.py",
    "created_at": "2024-09-19T11:58:58+00:00",
    "commented_code": "operation.package.develop\n                     and operation.package.source_type in {\"directory\", \"git\"}\n                 )\n-                if not operation.skipped and is_parallel_unsafe:\n+\n+                if operation.skipped:\n+                    # Skipped operations are safe to execute in parallel\n+                    tasks.append(\n+                        self._executor.submit(self._execute_operation, operation)\n+                    )\n+                elif is_parallel_unsafe:\n                     serial_operations.append(operation)\n-                    continue\n+                elif operation.package.source_type == \"git\":\n+                    # Git operations on the same repository should be executed serially\n+                    serial_git_operations[operation.package.source_url].append(\n+                        operation\n+                    )\n+                else:\n+                    tasks.append(\n+                        self._executor.submit(self._execute_operation, operation)\n+                    )\n \n-                tasks.append(self._executor.submit(self._execute_operation, operation))\n+            # For each git repository, execute all operations serially\n+            for repository_git_operations in serial_git_operations.values():\n+\n+                def _serialize(\n+                    repository_serial_operations: list[Operation],\n+                ) -> None:\n+                    for operation in repository_serial_operations:\n+                        self._execute_operation(operation)\n+\n+                tasks.append(\n+                    self._executor.submit(\n+                        functools.partial(\n+                            _serialize,\n+                            repository_serial_operations=repository_git_operations,",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1766702843",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9658,
        "pr_file": "src/poetry/installation/executor.py",
        "discussion_id": "1766702843",
        "commented_code": "@@ -158,11 +160,41 @@ def execute(self, operations: list[Operation]) -> int:\n                     operation.package.develop\n                     and operation.package.source_type in {\"directory\", \"git\"}\n                 )\n-                if not operation.skipped and is_parallel_unsafe:\n+\n+                if operation.skipped:\n+                    # Skipped operations are safe to execute in parallel\n+                    tasks.append(\n+                        self._executor.submit(self._execute_operation, operation)\n+                    )\n+                elif is_parallel_unsafe:\n                     serial_operations.append(operation)\n-                    continue\n+                elif operation.package.source_type == \"git\":\n+                    # Git operations on the same repository should be executed serially\n+                    serial_git_operations[operation.package.source_url].append(\n+                        operation\n+                    )\n+                else:\n+                    tasks.append(\n+                        self._executor.submit(self._execute_operation, operation)\n+                    )\n \n-                tasks.append(self._executor.submit(self._execute_operation, operation))\n+            # For each git repository, execute all operations serially\n+            for repository_git_operations in serial_git_operations.values():\n+\n+                def _serialize(\n+                    repository_serial_operations: list[Operation],\n+                ) -> None:\n+                    for operation in repository_serial_operations:\n+                        self._execute_operation(operation)\n+\n+                tasks.append(\n+                    self._executor.submit(\n+                        functools.partial(\n+                            _serialize,\n+                            repository_serial_operations=repository_git_operations,",
        "comment_created_at": "2024-09-19T11:58:58+00:00",
        "comment_author": "TheSven73",
        "comment_body": "Is `functools.partial` an unnecessary complication here? Isn't this code just equivalent to\r\n```python\r\ntasks.append(self._executor.submit(_serialize, repository_git_operations))\r\n```\r\n?",
        "pr_file_module": null
      },
      {
        "comment_id": "1774661741",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9658,
        "pr_file": "src/poetry/installation/executor.py",
        "discussion_id": "1766702843",
        "commented_code": "@@ -158,11 +160,41 @@ def execute(self, operations: list[Operation]) -> int:\n                     operation.package.develop\n                     and operation.package.source_type in {\"directory\", \"git\"}\n                 )\n-                if not operation.skipped and is_parallel_unsafe:\n+\n+                if operation.skipped:\n+                    # Skipped operations are safe to execute in parallel\n+                    tasks.append(\n+                        self._executor.submit(self._execute_operation, operation)\n+                    )\n+                elif is_parallel_unsafe:\n                     serial_operations.append(operation)\n-                    continue\n+                elif operation.package.source_type == \"git\":\n+                    # Git operations on the same repository should be executed serially\n+                    serial_git_operations[operation.package.source_url].append(\n+                        operation\n+                    )\n+                else:\n+                    tasks.append(\n+                        self._executor.submit(self._execute_operation, operation)\n+                    )\n \n-                tasks.append(self._executor.submit(self._execute_operation, operation))\n+            # For each git repository, execute all operations serially\n+            for repository_git_operations in serial_git_operations.values():\n+\n+                def _serialize(\n+                    repository_serial_operations: list[Operation],\n+                ) -> None:\n+                    for operation in repository_serial_operations:\n+                        self._execute_operation(operation)\n+\n+                tasks.append(\n+                    self._executor.submit(\n+                        functools.partial(\n+                            _serialize,\n+                            repository_serial_operations=repository_git_operations,",
        "comment_created_at": "2024-09-25T07:13:23+00:00",
        "comment_author": "gustavgransbo",
        "comment_body": "You are right! Fixed it now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1688512916",
    "pr_number": 6969,
    "pr_file": "src/poetry/puzzle/provider.py",
    "created_at": "2024-07-23T18:23:43+00:00",
    "commented_code": "continue\n                     self.search_for_direct_origin_dependency(dep)\n \n+        active_extras = None if package.is_root() else dependency.extras\n+        _dependencies = self._add_implicit_dependencies(_dependencies, active_extras)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1688512916",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 6969,
        "pr_file": "src/poetry/puzzle/provider.py",
        "discussion_id": "1688512916",
        "commented_code": "@@ -570,6 +570,9 @@ def complete_package(\n                         continue\n                     self.search_for_direct_origin_dependency(dep)\n \n+        active_extras = None if package.is_root() else dependency.extras\n+        _dependencies = self._add_implicit_dependencies(_dependencies, active_extras)",
        "comment_created_at": "2024-07-23T18:23:43+00:00",
        "comment_author": "jorenham",
        "comment_body": "Since `_dependencies` is only used once, it's probably better to skip the variable assignment, by inlining in into the `_add_implicit_dependencies` call",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1125749922",
    "pr_number": 7412,
    "pr_file": "tests/installation/test_executor.py",
    "created_at": "2023-03-05T22:53:18+00:00",
    "commented_code": "@pytest.fixture()\n-def copy_wheel(tmp_dir: Path) -> Callable[[], Path]:\n+def copy_wheel(tmp_path: Path) -> Callable[[], Path]:\n     def _copy_wheel() -> Path:\n         tmp_name = tempfile.mktemp()\n-        Path(tmp_dir).joinpath(tmp_name).mkdir()\n+        tmp_path.joinpath(tmp_name).mkdir()\n \n         shutil.copyfile(\n             Path(__file__)\n             .parent.parent.joinpath(\n                 \"fixtures/distributions/demo-0.1.2-py2.py3-none-any.whl\"\n             )\n             .as_posix(),\n-            Path(tmp_dir)\n-            .joinpath(tmp_name)\n+            tmp_path.joinpath(tmp_name)\n             .joinpath(\"demo-0.1.2-py2.py3-none-any.whl\")\n             .as_posix(),\n         )\n \n-        return (\n-            Path(tmp_dir).joinpath(tmp_name).joinpath(\"demo-0.1.2-py2.py3-none-any.whl\")\n-        )\n+        return tmp_path.joinpath(tmp_name).joinpath(\"demo-0.1.2-py2.py3-none-any.whl\")",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1125749922",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7412,
        "pr_file": "tests/installation/test_executor.py",
        "discussion_id": "1125749922",
        "commented_code": "@@ -153,26 +153,23 @@ def callback(\n \n \n @pytest.fixture()\n-def copy_wheel(tmp_dir: Path) -> Callable[[], Path]:\n+def copy_wheel(tmp_path: Path) -> Callable[[], Path]:\n     def _copy_wheel() -> Path:\n         tmp_name = tempfile.mktemp()\n-        Path(tmp_dir).joinpath(tmp_name).mkdir()\n+        tmp_path.joinpath(tmp_name).mkdir()\n \n         shutil.copyfile(\n             Path(__file__)\n             .parent.parent.joinpath(\n                 \"fixtures/distributions/demo-0.1.2-py2.py3-none-any.whl\"\n             )\n             .as_posix(),\n-            Path(tmp_dir)\n-            .joinpath(tmp_name)\n+            tmp_path.joinpath(tmp_name)\n             .joinpath(\"demo-0.1.2-py2.py3-none-any.whl\")\n             .as_posix(),\n         )\n \n-        return (\n-            Path(tmp_dir).joinpath(tmp_name).joinpath(\"demo-0.1.2-py2.py3-none-any.whl\")\n-        )\n+        return tmp_path.joinpath(tmp_name).joinpath(\"demo-0.1.2-py2.py3-none-any.whl\")",
        "comment_created_at": "2023-03-05T22:53:18+00:00",
        "comment_author": "eamanu",
        "comment_body": "I think is more readable write:\r\n\r\n`tmp_path / tmp_name / \"demo-0.1.2-py2.py3-none-any.whl\"`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1320546656",
    "pr_number": 8401,
    "pr_file": "src/poetry/vcs/git/system.py",
    "created_at": "2023-09-09T11:42:24+00:00",
    "commented_code": "@classmethod\n     def checkout(cls, rev: str, target: Path | None = None) -> str:\n-        args = []\n-\n-        if target:\n-            args += [\n-                \"--git-dir\",\n-                (target / \".git\").as_posix(),\n-                \"--work-tree\",\n-                target.as_posix(),\n-            ]\n-\n         cls._check_parameter(rev)\n \n-        args += [\"checkout\", rev]\n+        args = (\"checkout\", rev)\n \n-        return cls.run(*args)\n+        if target:\n+            return cls.run(*args, folder=target)\n+        else:\n+            return cls.run(*args)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1320546656",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8401,
        "pr_file": "src/poetry/vcs/git/system.py",
        "discussion_id": "1320546656",
        "commented_code": "@@ -22,21 +22,14 @@ def clone(cls, repository: str, dest: Path) -> str:\n \n     @classmethod\n     def checkout(cls, rev: str, target: Path | None = None) -> str:\n-        args = []\n-\n-        if target:\n-            args += [\n-                \"--git-dir\",\n-                (target / \".git\").as_posix(),\n-                \"--work-tree\",\n-                target.as_posix(),\n-            ]\n-\n         cls._check_parameter(rev)\n \n-        args += [\"checkout\", rev]\n+        args = (\"checkout\", rev)\n \n-        return cls.run(*args)\n+        if target:\n+            return cls.run(*args, folder=target)\n+        else:\n+            return cls.run(*args)",
        "comment_created_at": "2023-09-09T11:42:24+00:00",
        "comment_author": "radoering",
        "comment_body": "```suggestion\r\n        return cls.run(\"checkout\", rev, folder=target)\r\n```\r\n\r\nThis should be sufficient because `None` is handled in `run()`. (The `args` variable in line 27 can be removed then.)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "333022129",
    "pr_number": 1418,
    "pr_file": "poetry/masonry/builders/sdist.py",
    "created_at": "2019-10-09T13:46:29+00:00",
    "commented_code": "if not target_dir.exists():\n             target_dir.mkdir(parents=True)\n \n-        target = target_dir / \"{}-{}.tar.gz\".format(\n-            self._package.pretty_name, self._meta.version\n+        basename = (\n+            self._package.pretty_name\n+            if self._package.distribution is None\n+            else self._package.distribution\n         )",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "333022129",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 1418,
        "pr_file": "poetry/masonry/builders/sdist.py",
        "discussion_id": "333022129",
        "commented_code": "@@ -55,16 +55,19 @@ def build(self, target_dir=None):  # type: (Path) -> Path\n         if not target_dir.exists():\n             target_dir.mkdir(parents=True)\n \n-        target = target_dir / \"{}-{}.tar.gz\".format(\n-            self._package.pretty_name, self._meta.version\n+        basename = (\n+            self._package.pretty_name\n+            if self._package.distribution is None\n+            else self._package.distribution\n         )",
        "comment_created_at": "2019-10-09T13:46:29+00:00",
        "comment_author": "funkyfuture",
        "comment_body": "you can shorten this expression to: `basename = self._package.distribution or self._package.pretty_name`. also apllies for the `wheels` module in this package.",
        "pr_file_module": null
      }
    ]
  }
]