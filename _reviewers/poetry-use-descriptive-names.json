[
  {
    "discussion_id": "884304202",
    "pr_number": 5715,
    "pr_file": "src/poetry/installation/installer.py",
    "created_at": "2022-05-29T17:48:05+00:00",
    "commented_code": "):\n             ops = solver.solve(use_latest=[]).calculate_operations()\n \n-        local_repo = Repository()\n+        local_repo = LockfileRepository()",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "884304202",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 5715,
        "pr_file": "src/poetry/installation/installer.py",
        "discussion_id": "884304202",
        "commented_code": "@@ -204,14 +203,14 @@ def _do_refresh(self) -> int:\n         ):\n             ops = solver.solve(use_latest=[]).calculate_operations()\n \n-        local_repo = Repository()\n+        local_repo = LockfileRepository()",
        "comment_created_at": "2022-05-29T17:48:05+00:00",
        "comment_author": "neersighted",
        "comment_body": "I think the introduction of a new type here makes the code/intention a fair bit more obvious as an ancillary benefit. I think we should probably go ahead and change the use of `local_repo` to `lockfile_repo` in this file to capitalize on that further.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "753752986",
    "pr_number": 4618,
    "pr_file": "src/poetry/mixology/version_solver.py",
    "created_at": "2021-11-21T06:13:20+00:00",
    "commented_code": ")\n                 return dependency.complete_name\n \n-            try:\n-                version = packages[0]\n-            except IndexError:\n-                version = None\n+            version = None\n+            if dependency.name not in self._use_latest:\n+                # prefer locked version of compatible (not exact same) dependency;\n+                # required in order to not unnecessarily update dependencies with\n+                # extras, e.g. \"coverage\" vs. \"coverage[toml]\"\n+                locked = self._locked.get(dependency.name, None)\n+                if locked is not None:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "753752986",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 4618,
        "pr_file": "src/poetry/mixology/version_solver.py",
        "discussion_id": "753752986",
        "commented_code": "@@ -374,10 +375,20 @@ def _get_min(dependency: Dependency) -> Tuple[bool, int]:\n                 )\n                 return dependency.complete_name\n \n-            try:\n-                version = packages[0]\n-            except IndexError:\n-                version = None\n+            version = None\n+            if dependency.name not in self._use_latest:\n+                # prefer locked version of compatible (not exact same) dependency;\n+                # required in order to not unnecessarily update dependencies with\n+                # extras, e.g. \"coverage\" vs. \"coverage[toml]\"\n+                locked = self._locked.get(dependency.name, None)\n+                if locked is not None:",
        "comment_created_at": "2021-11-21T06:13:20+00:00",
        "comment_author": "neersighted",
        "comment_body": "There's not a good way to unroll the nested logic here, is there? This is a bit dense, but I'm not seeing an obvious simplification myself.",
        "pr_file_module": null
      },
      {
        "comment_id": "753757327",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 4618,
        "pr_file": "src/poetry/mixology/version_solver.py",
        "discussion_id": "753752986",
        "commented_code": "@@ -374,10 +375,20 @@ def _get_min(dependency: Dependency) -> Tuple[bool, int]:\n                 )\n                 return dependency.complete_name\n \n-            try:\n-                version = packages[0]\n-            except IndexError:\n-                version = None\n+            version = None\n+            if dependency.name not in self._use_latest:\n+                # prefer locked version of compatible (not exact same) dependency;\n+                # required in order to not unnecessarily update dependencies with\n+                # extras, e.g. \"coverage\" vs. \"coverage[toml]\"\n+                locked = self._locked.get(dependency.name, None)\n+                if locked is not None:",
        "comment_created_at": "2021-11-21T07:07:34+00:00",
        "comment_author": "radoering",
        "comment_body": "If you want to refrain from taking advantage of the fact that the list is sorted and thus from the early return if the version is not found, you can simplify the loop as follows:\r\n\r\n```\r\nif locked is not None:\r\n    for version in packages:\r\n        if version.version == locked.version:\r\n            break\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "753759279",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 4618,
        "pr_file": "src/poetry/mixology/version_solver.py",
        "discussion_id": "753752986",
        "commented_code": "@@ -374,10 +375,20 @@ def _get_min(dependency: Dependency) -> Tuple[bool, int]:\n                 )\n                 return dependency.complete_name\n \n-            try:\n-                version = packages[0]\n-            except IndexError:\n-                version = None\n+            version = None\n+            if dependency.name not in self._use_latest:\n+                # prefer locked version of compatible (not exact same) dependency;\n+                # required in order to not unnecessarily update dependencies with\n+                # extras, e.g. \"coverage\" vs. \"coverage[toml]\"\n+                locked = self._locked.get(dependency.name, None)\n+                if locked is not None:",
        "comment_created_at": "2021-11-21T07:28:12+00:00",
        "comment_author": "neersighted",
        "comment_body": "In that case I'm wondering if `next()` wouldn't be clearer -- e.g.\r\n\r\n```python\r\n    version = next((p.version for p in packages if p.version == locked.version), None)\r\n```\r\n\r\nThoughts?",
        "pr_file_module": null
      },
      {
        "comment_id": "753765559",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 4618,
        "pr_file": "src/poetry/mixology/version_solver.py",
        "discussion_id": "753752986",
        "commented_code": "@@ -374,10 +375,20 @@ def _get_min(dependency: Dependency) -> Tuple[bool, int]:\n                 )\n                 return dependency.complete_name\n \n-            try:\n-                version = packages[0]\n-            except IndexError:\n-                version = None\n+            version = None\n+            if dependency.name not in self._use_latest:\n+                # prefer locked version of compatible (not exact same) dependency;\n+                # required in order to not unnecessarily update dependencies with\n+                # extras, e.g. \"coverage\" vs. \"coverage[toml]\"\n+                locked = self._locked.get(dependency.name, None)\n+                if locked is not None:",
        "comment_created_at": "2021-11-21T08:29:37+00:00",
        "comment_author": "radoering",
        "comment_body": "I like it, but it has to be:\r\n\r\n```\r\nversion = next((p for p in packages if p.version == locked.version), None)\r\n```\r\n\r\nMaybe a bit confusing that the variable `version` is a `package`. Should we rename it to `package`?",
        "pr_file_module": null
      },
      {
        "comment_id": "785470817",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 4618,
        "pr_file": "src/poetry/mixology/version_solver.py",
        "discussion_id": "753752986",
        "commented_code": "@@ -374,10 +375,20 @@ def _get_min(dependency: Dependency) -> Tuple[bool, int]:\n                 )\n                 return dependency.complete_name\n \n-            try:\n-                version = packages[0]\n-            except IndexError:\n-                version = None\n+            version = None\n+            if dependency.name not in self._use_latest:\n+                # prefer locked version of compatible (not exact same) dependency;\n+                # required in order to not unnecessarily update dependencies with\n+                # extras, e.g. \"coverage\" vs. \"coverage[toml]\"\n+                locked = self._locked.get(dependency.name, None)\n+                if locked is not None:",
        "comment_created_at": "2022-01-16T17:14:30+00:00",
        "comment_author": "radoering",
        "comment_body": "@neersighted Sorry for bothering, but I had the impression that the review of this PR has already been well advanced - maybe, the naming of the variable being the only point to be clarified before merging. (Correct me if I'm wrong.) I'd appreciate if you find some minutes so that we may finalize it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1730341481",
    "pr_number": 9050,
    "pr_file": "src/poetry/utils/env/python_manager.py",
    "created_at": "2024-08-25T13:20:35+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1730341481",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9050,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1730341481",
        "commented_code": "@@ -0,0 +1,163 @@\n+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
        "comment_created_at": "2024-08-25T13:20:35+00:00",
        "comment_author": "TBBle",
        "comment_body": "Is this the right name for this function? If Poetry is installed in a venv, e.g., using pipx, it'll pick up the pipx venv's Python binary, which seems surprising as a \"system\" Python version, which to me would imply \"shared instance, outside any venv\".\r\n\r\nI don't see this function being used excepts in the tests, so I'm not clear what the intended behaviour is, but perhaps `get_running_python` or `get_poetry_python` would be more-accurate? (`get_preferred_python` open-codes the same behaviour so it will also pick up a pipx-poetry Python executable and not a system-shared instance, but it only appears to be used to extract the version and create new venvs, so that seems like the expected/intended behaviour there.)",
        "pr_file_module": null
      },
      {
        "comment_id": "1730361695",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9050,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1730341481",
        "commented_code": "@@ -0,0 +1,163 @@\n+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
        "comment_created_at": "2024-08-25T13:57:55+00:00",
        "comment_author": "finswimmer",
        "comment_body": "Good catch :+1: I guess my initial thought was, that there is a need to get the Python executable that poetry itself uses. But obviously the only place where this is required is within `get_preferred_python`, where we decide whether we use this executable or the one used in the current shell. We can either keep this method and used in within `get_preffered_python` to make the choice options more explicit or remove it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1732106317",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9050,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1730341481",
        "commented_code": "@@ -0,0 +1,163 @@\n+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
        "comment_created_at": "2024-08-27T04:23:50+00:00",
        "comment_author": "finswimmer",
        "comment_body": "I kept this method and used in `get_preffered_python`.\r\n\r\nRegarding the name: @Secrus & @radoering Are you fine with  `get_system_python` or do you prefer any other name?",
        "pr_file_module": null
      },
      {
        "comment_id": "1733061602",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9050,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1730341481",
        "commented_code": "@@ -0,0 +1,163 @@\n+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
        "comment_created_at": "2024-08-27T15:11:52+00:00",
        "comment_author": "radoering",
        "comment_body": "I understand the confusion.\r\n\r\nOn the one hand, `SystemEnv` is the env Poetry is installed in. `poetry env use system` tells Poetry to use it's own Python version as default for new venvs. Thus, in our wording `system` is Poetry's own env.\r\n\r\nOne the other hand, `virtualenvs.options.system-site-packages` does not refer to Poetry's own env. And most people will probably not associate `system` with Poetry's own env.\r\n\r\nNot sure, if `get_poetry_python` is a better name or if it can be confused with the project's python. At least, `system` is quite consistent in our code. No strong opinion on this. \ud83e\udd37",
        "pr_file_module": null
      },
      {
        "comment_id": "1760021429",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9050,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1730341481",
        "commented_code": "@@ -0,0 +1,163 @@\n+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
        "comment_created_at": "2024-09-15T10:59:57+00:00",
        "comment_author": "Secrus",
        "comment_body": "For me `system python` was always confusing, but I agree with @radoering that it is quite consistent in the code now, so we can leave it as is.",
        "pr_file_module": null
      },
      {
        "comment_id": "1770830596",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 9050,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1730341481",
        "commented_code": "@@ -0,0 +1,163 @@\n+from __future__ import annotations\n+\n+import shutil\n+import subprocess\n+import sys\n+\n+from functools import cached_property\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+from cleo.io.null_io import NullIO\n+from cleo.io.outputs.output import Verbosity\n+from poetry.core.constraints.version import Version\n+from poetry.core.constraints.version import parse_constraint\n+\n+from poetry.utils._compat import decode\n+from poetry.utils.env.exceptions import NoCompatiblePythonVersionFound\n+from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n+\n+\n+if TYPE_CHECKING:\n+    from cleo.io.io import IO\n+\n+    from poetry.config.config import Config\n+    from poetry.poetry import Poetry\n+\n+\n+class Python:\n+    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n+        self.executable = Path(executable)\n+        self._version = version\n+\n+    @property\n+    def version(self) -> Version:\n+        if not self._version:\n+            if self.executable == Path(sys.executable):\n+                _python_version = \".\".join(str(v) for v in sys.version_info[:3])\n+            else:\n+                encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+                _python_version = decode(\n+                    subprocess.check_output(\n+                        [str(self.executable), \"-c\", GET_PYTHON_VERSION_ONELINER],\n+                        text=True,\n+                        encoding=encoding,\n+                    ).strip()\n+                )\n+            self._version = Version.parse(_python_version)\n+\n+        return self._version\n+\n+    @cached_property\n+    def patch_version(self) -> Version:\n+        return Version.from_parts(\n+            major=self.version.major,\n+            minor=self.version.minor,\n+            patch=self.version.patch,\n+        )\n+\n+    @cached_property\n+    def minor_version(self) -> Version:\n+        return Version.from_parts(major=self.version.major, minor=self.version.minor)\n+\n+    @staticmethod\n+    def _full_python_path(python: str) -> Path | None:\n+        # eg first find pythonXY.bat on windows.\n+        path_python = shutil.which(python)\n+        if path_python is None:\n+            return None\n+\n+        try:\n+            encoding = \"locale\" if sys.version_info >= (3, 10) else None\n+            executable = subprocess.check_output(\n+                [path_python, \"-c\", \"import sys; print(sys.executable)\"],\n+                text=True,\n+                encoding=encoding,\n+            ).strip()\n+            return Path(executable)\n+\n+        except subprocess.CalledProcessError:\n+            return None\n+\n+    @staticmethod\n+    def _detect_active_python(io: IO) -> Path | None:\n+        io.write_error_line(\n+            \"Trying to detect current active python executable as specified in\"\n+            \" the config.\",\n+            verbosity=Verbosity.VERBOSE,\n+        )\n+\n+        executable = Python._full_python_path(\"python\")\n+\n+        if executable is not None:\n+            io.write_error_line(f\"Found: {executable}\", verbosity=Verbosity.VERBOSE)\n+        else:\n+            io.write_error_line(\n+                \"Unable to detect the current active python executable. Falling\"\n+                \" back to default.\",\n+                verbosity=Verbosity.VERBOSE,\n+            )\n+\n+        return executable\n+\n+    @classmethod\n+    def get_system_python(cls) -> Python:\n+        return cls(executable=sys.executable)",
        "comment_created_at": "2024-09-23T06:34:29+00:00",
        "comment_author": "finswimmer",
        "comment_body": "Good to see that we are on the same boat :smile: So I would leave it at it is for now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "503893160",
    "pr_number": 3190,
    "pr_file": "tests/console/commands/test_add.py",
    "created_at": "2020-10-13T12:01:42+00:00",
    "commented_code": "return tester\n \n \n-def test_add_no_constraint(app, repo, tester):\n+@pytest.fixture()\n+def repo_with_packages(repo):",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "503893160",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 3190,
        "pr_file": "tests/console/commands/test_add.py",
        "discussion_id": "503893160",
        "commented_code": "@@ -24,10 +24,18 @@ def old_tester(tester):\n     return tester\n \n \n-def test_add_no_constraint(app, repo, tester):\n+@pytest.fixture()\n+def repo_with_packages(repo):",
        "comment_created_at": "2020-10-13T12:01:42+00:00",
        "comment_author": "abn",
        "comment_body": "Since this is more an action than an object, I'd more inclined to name it something along the lines of `repo_add_default_packages` or `add_default_packages_to_repo`  or similar. Just a personal preference. ",
        "pr_file_module": null
      },
      {
        "comment_id": "503954246",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 3190,
        "pr_file": "tests/console/commands/test_add.py",
        "discussion_id": "503893160",
        "commented_code": "@@ -24,10 +24,18 @@ def old_tester(tester):\n     return tester\n \n \n-def test_add_no_constraint(app, repo, tester):\n+@pytest.fixture()\n+def repo_with_packages(repo):",
        "comment_created_at": "2020-10-13T13:32:17+00:00",
        "comment_author": "sanders41",
        "comment_body": "Agreed, this makes sense. I will update.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1174372732",
    "pr_number": 7792,
    "pr_file": "src/poetry/utils/env.py",
    "created_at": "2023-04-22T10:51:01+00:00",
    "commented_code": "return VirtualEnv(venv_path, venv_path)\n \n+    def use_root_env(self) -> bool:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1174372732",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7792,
        "pr_file": "src/poetry/utils/env.py",
        "discussion_id": "1174372732",
        "commented_code": "@@ -891,6 +883,14 @@ def remove(self, python: str) -> Env:\n \n         return VirtualEnv(venv_path, venv_path)\n \n+    def use_root_env(self) -> bool:",
        "comment_created_at": "2023-04-22T10:51:01+00:00",
        "comment_author": "radoering",
        "comment_body": "Maybe, we should rename it to `use_in_project_venv` instead. At least to me, `root_env` is a bit vague.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1270345072",
    "pr_number": 8218,
    "pr_file": "tests/console/commands/test_init.py",
    "created_at": "2023-07-21T07:49:01+00:00",
    "commented_code": "),\n     )\n \n-    packages = \"\" if include is None else f'packages = [{{include = \"{include}\"}}]\n'\n+    def module_name(name: str) -> str:\n+        return name.replace(\"_\", \"-\")",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1270345072",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8218,
        "pr_file": "tests/console/commands/test_init.py",
        "discussion_id": "1270345072",
        "commented_code": "@@ -1043,7 +1025,17 @@ def test_package_include(\n         ),\n     )\n \n-    packages = \"\" if include is None else f'packages = [{{include = \"{include}\"}}]\\n'\n+    def module_name(name: str) -> str:\n+        return name.replace(\"_\", \"-\")",
        "comment_created_at": "2023-07-21T07:49:01+00:00",
        "comment_author": "dimbleby",
        "comment_body": "this is roughly the opposite of what `module_name()` should do - see https://github.com/python-poetry/poetry-core/blob/637316754a284da2faf6ff953c094776f14e9c7e/src/poetry/core/utils/helpers.py#L30",
        "pr_file_module": null
      },
      {
        "comment_id": "1271486919",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 8218,
        "pr_file": "tests/console/commands/test_init.py",
        "discussion_id": "1270345072",
        "commented_code": "@@ -1043,7 +1025,17 @@ def test_package_include(\n         ),\n     )\n \n-    packages = \"\" if include is None else f'packages = [{{include = \"{include}\"}}]\\n'\n+    def module_name(name: str) -> str:\n+        return name.replace(\"_\", \"-\")",
        "comment_created_at": "2023-07-23T17:41:34+00:00",
        "comment_author": "wdonofrio",
        "comment_body": "You're right. Thanks for the callout!\r\n\r\nI realized my mistake and refactored to leverage poetry-core directly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1125955390",
    "pr_number": 7594,
    "pr_file": "tests/installation/test_executor.py",
    "created_at": "2023-03-06T06:01:42+00:00",
    "commented_code": "verify_installed_distribution(tmp_venv, package, expected_url_reference)\n \n \n+@pytest.mark.parametrize(\"cached\", [False, True])\n+def test_executor_should_write_pep610_url_references_for_non_wheel_urls(\n+    tmp_venv: VirtualEnv,\n+    pool: RepositoryPool,\n+    config: Config,\n+    io: BufferedIO,\n+    mock_file_downloads: None,\n+    mocker: MockerFixture,\n+    fixture_dir: FixtureDirGetter,\n+    cached: bool,",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1125955390",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "tests/installation/test_executor.py",
        "discussion_id": "1125955390",
        "commented_code": "@@ -739,6 +787,60 @@ def test_executor_should_write_pep610_url_references_for_urls(\n     verify_installed_distribution(tmp_venv, package, expected_url_reference)\n \n \n+@pytest.mark.parametrize(\"cached\", [False, True])\n+def test_executor_should_write_pep610_url_references_for_non_wheel_urls(\n+    tmp_venv: VirtualEnv,\n+    pool: RepositoryPool,\n+    config: Config,\n+    io: BufferedIO,\n+    mock_file_downloads: None,\n+    mocker: MockerFixture,\n+    fixture_dir: FixtureDirGetter,\n+    cached: bool,",
        "comment_created_at": "2023-03-06T06:01:42+00:00",
        "comment_author": "radoering",
        "comment_body": "```suggestion\r\n    cached_wheel: bool,\r\n```\r\n\r\nMaybe, we should name it more clear because it doesn't matter if the sdist is cached, only if a generated wheel is cached or not.",
        "pr_file_module": null
      },
      {
        "comment_id": "1126146307",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "tests/installation/test_executor.py",
        "discussion_id": "1125955390",
        "commented_code": "@@ -739,6 +787,60 @@ def test_executor_should_write_pep610_url_references_for_urls(\n     verify_installed_distribution(tmp_venv, package, expected_url_reference)\n \n \n+@pytest.mark.parametrize(\"cached\", [False, True])\n+def test_executor_should_write_pep610_url_references_for_non_wheel_urls(\n+    tmp_venv: VirtualEnv,\n+    pool: RepositoryPool,\n+    config: Config,\n+    io: BufferedIO,\n+    mock_file_downloads: None,\n+    mocker: MockerFixture,\n+    fixture_dir: FixtureDirGetter,\n+    cached: bool,",
        "comment_created_at": "2023-03-06T09:30:08+00:00",
        "comment_author": "quantum-byte",
        "comment_body": "How about `is_artifact_cached` since its not only about wheels?",
        "pr_file_module": null
      },
      {
        "comment_id": "1126736622",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7594,
        "pr_file": "tests/installation/test_executor.py",
        "discussion_id": "1125955390",
        "commented_code": "@@ -739,6 +787,60 @@ def test_executor_should_write_pep610_url_references_for_urls(\n     verify_installed_distribution(tmp_venv, package, expected_url_reference)\n \n \n+@pytest.mark.parametrize(\"cached\", [False, True])\n+def test_executor_should_write_pep610_url_references_for_non_wheel_urls(\n+    tmp_venv: VirtualEnv,\n+    pool: RepositoryPool,\n+    config: Config,\n+    io: BufferedIO,\n+    mock_file_downloads: None,\n+    mocker: MockerFixture,\n+    fixture_dir: FixtureDirGetter,\n+    cached: bool,",
        "comment_created_at": "2023-03-06T16:42:02+00:00",
        "comment_author": "radoering",
        "comment_body": "Ah, I thought caching is only turned on/off for the generated wheel and the sdist is always cached, but it is also turned on/off for the sdist. In that case `cached` would have been fine, but `is_artifact_cached` is better. \ud83d\ude04 ",
        "pr_file_module": null
      }
    ]
  }
]