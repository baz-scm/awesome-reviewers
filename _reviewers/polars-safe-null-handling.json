[
  {
    "discussion_id": "2125761809",
    "pr_number": 22840,
    "pr_file": "crates/polars-ops/src/chunked_array/binary/cast_binary_to_numerical.rs",
    "created_at": "2025-06-04T06:34:33+00:00",
    "commented_code": "is_little_endian,\n     )))\n }\n+\n+/// Casts a [`BinaryArray`] to a [`PrimitiveArray`], making any un-castable value a Null.\n+pub(super) fn try_cast_binview_to_array_primitive<T>(\n+    from: &BinaryViewArray,\n+    to: &ArrowDataType,\n+    is_little_endian: bool,\n+    element_size: usize,\n+) -> PolarsResult<FixedSizeListArray>\n+where\n+    T: Cast + NativeType,\n+{\n+    let ArrowDataType::FixedSizeList(_, size) = to else {\n+        panic!(\"Bug, non-Array passed in.\")\n+    };\n+    let size = *size;\n+    let mut result = MutableFixedSizeListArray::new(\n+        MutablePrimitiveArray::<T>::with_capacity(\n+            from.len()\n+                * from\n+                    .get(0)\n+                    .map(|bytes| bytes.len() / element_size)\n+                    .unwrap_or(0),",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "2125761809",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 22840,
        "pr_file": "crates/polars-ops/src/chunked_array/binary/cast_binary_to_numerical.rs",
        "discussion_id": "2125761809",
        "commented_code": "@@ -78,3 +81,74 @@ where\n         is_little_endian,\n     )))\n }\n+\n+/// Casts a [`BinaryArray`] to a [`PrimitiveArray`], making any un-castable value a Null.\n+pub(super) fn try_cast_binview_to_array_primitive<T>(\n+    from: &BinaryViewArray,\n+    to: &ArrowDataType,\n+    is_little_endian: bool,\n+    element_size: usize,\n+) -> PolarsResult<FixedSizeListArray>\n+where\n+    T: Cast + NativeType,\n+{\n+    let ArrowDataType::FixedSizeList(_, size) = to else {\n+        panic!(\"Bug, non-Array passed in.\")\n+    };\n+    let size = *size;\n+    let mut result = MutableFixedSizeListArray::new(\n+        MutablePrimitiveArray::<T>::with_capacity(\n+            from.len()\n+                * from\n+                    .get(0)\n+                    .map(|bytes| bytes.len() / element_size)\n+                    .unwrap_or(0),",
        "comment_created_at": "2025-06-04T06:34:33+00:00",
        "comment_author": "nameexhaustion",
        "comment_body": "~~The allocation length here should be sourced as `num_valid_rows * (element_size * size)` `len() * (element_size * size)` instead of from the first element. I would also recommend having a `let width = element_size * size` earlier in the function.~~\r\n\r\nThis currently also ends up allocating a 0-length array if the first element is NULL.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2127393660",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 22840,
        "pr_file": "crates/polars-ops/src/chunked_array/binary/cast_binary_to_numerical.rs",
        "discussion_id": "2125761809",
        "commented_code": "@@ -78,3 +81,74 @@ where\n         is_little_endian,\n     )))\n }\n+\n+/// Casts a [`BinaryArray`] to a [`PrimitiveArray`], making any un-castable value a Null.\n+pub(super) fn try_cast_binview_to_array_primitive<T>(\n+    from: &BinaryViewArray,\n+    to: &ArrowDataType,\n+    is_little_endian: bool,\n+    element_size: usize,\n+) -> PolarsResult<FixedSizeListArray>\n+where\n+    T: Cast + NativeType,\n+{\n+    let ArrowDataType::FixedSizeList(_, size) = to else {\n+        panic!(\"Bug, non-Array passed in.\")\n+    };\n+    let size = *size;\n+    let mut result = MutableFixedSizeListArray::new(\n+        MutablePrimitiveArray::<T>::with_capacity(\n+            from.len()\n+                * from\n+                    .get(0)\n+                    .map(|bytes| bytes.len() / element_size)\n+                    .unwrap_or(0),",
        "comment_created_at": "2025-06-04T20:33:36+00:00",
        "comment_author": "itamarst",
        "comment_body": "Done, but this suggests the need for another test.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160318673",
    "pr_number": 23273,
    "pr_file": "crates/polars-plan/src/dsl/mod.rs",
    "created_at": "2025-06-22T12:09:37+00:00",
    "commented_code": "self.map_unary(BooleanFunction::IsUnique)\n     }\n \n+    /// Check whether floating point values are close to each other.\n+    #[allow(clippy::wrong_self_convention)]\n+    #[cfg(feature = \"is_close\")]\n+    pub fn is_close<E: Into<Expr>>(\n+        self,\n+        expr: E,\n+        abs_tol: f64,\n+        rel_tol: f64,\n+        nans_equal: bool,\n+    ) -> Self {\n+        self.map_binary(\n+            BooleanFunction::IsClose {\n+                abs_tol: NotNan::new(abs_tol).expect(\"`abs_tol` must not be NaN\"),",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "2160318673",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 23273,
        "pr_file": "crates/polars-plan/src/dsl/mod.rs",
        "discussion_id": "2160318673",
        "commented_code": "@@ -958,6 +960,26 @@ impl Expr {\n         self.map_unary(BooleanFunction::IsUnique)\n     }\n \n+    /// Check whether floating point values are close to each other.\n+    #[allow(clippy::wrong_self_convention)]\n+    #[cfg(feature = \"is_close\")]\n+    pub fn is_close<E: Into<Expr>>(\n+        self,\n+        expr: E,\n+        abs_tol: f64,\n+        rel_tol: f64,\n+        nans_equal: bool,\n+    ) -> Self {\n+        self.map_binary(\n+            BooleanFunction::IsClose {\n+                abs_tol: NotNan::new(abs_tol).expect(\"`abs_tol` must not be NaN\"),",
        "comment_created_at": "2025-06-22T12:09:37+00:00",
        "comment_author": "ritchie46",
        "comment_body": "We can check `is_nan` on the floats.\r\n\r\nWe can make our own `NonNan` wrapper type in `polars-utils`, which does this check on entry.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1851406169",
    "pr_number": 19898,
    "pr_file": "crates/polars-plan/src/plans/optimizer/predicate_pushdown/join.rs",
    "created_at": "2024-11-21T06:00:39+00:00",
    "commented_code": "},\n             _ => join_produces_null(how),\n         },\n-        _ => LeftRight(false, false),\n+        _ => join_produces_null(how),",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1851406169",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19898,
        "pr_file": "crates/polars-plan/src/plans/optimizer/predicate_pushdown/join.rs",
        "discussion_id": "1851406169",
        "commented_code": "@@ -62,7 +61,7 @@ fn should_block_join_specific(\n             },\n             _ => join_produces_null(how),\n         },\n-        _ => LeftRight(false, false),\n+        _ => join_produces_null(how),",
        "comment_created_at": "2024-11-21T06:00:39+00:00",
        "comment_author": "nameexhaustion",
        "comment_body": "for catch-all we need to at least follow the `join_produces_null` rule\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1831790031",
    "pr_number": 19669,
    "pr_file": "crates/polars-arrow/src/compute/cast/mod.rs",
    "created_at": "2024-11-06T22:29:55+00:00",
    "commented_code": "}\n         }\n \n-        // Build take indices for the values. This is used to fill in the null slots.\n-        let mut indices =\n-            MutablePrimitiveArray::<IdxSize>::with_capacity(list.values().len() + null_cnt * size);\n-        for i in 0..list.len() {\n-            if list.is_null(i) {\n-                indices.extend_constant(size, None)\n-            } else {\n-                // SAFETY: we know the index is in bound.\n-                let current_offset = unsafe { *offsets.get_unchecked(i) };\n-                for j in 0..size {\n-                    indices.push(Some(\n-                        (current_offset + O::from_as_usize(j)).to_usize() as IdxSize\n-                    ));\n+        let list_validity = list.validity().unwrap();\n+        let mut growable = make_growable(&[list.values().as_ref()], true, list.len());\n+\n+        if cfg!(debug_assertions) {\n+            let msg = \"fn cast_list_to_fixed_size_list < nullable >\";\n+            dbg!(msg);\n+        }\n+\n+        for (outer_idx, x) in offsets.windows(2).enumerate() {\n+            let [i, j] = x else { unreachable!() };\n+            let i = i.to_usize();\n+            let j = j.to_usize();\n+\n+            unsafe {\n+                let outer_is_valid = list_validity.get_bit_unchecked(outer_idx);\n+\n+                if outer_is_valid {\n+                    growable.extend(0, i, j - i);\n+                } else {\n+                    growable.extend_validity(size)\n                 }\n-            }\n+            };\n         }\n-        let take_values = unsafe {\n-            crate::compute::take::take_unchecked(list.values().as_ref(), &indices.freeze())",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1831790031",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19669,
        "pr_file": "crates/polars-arrow/src/compute/cast/mod.rs",
        "discussion_id": "1831790031",
        "commented_code": "@@ -206,27 +211,33 @@ fn cast_list_to_fixed_size_list<O: Offset>(\n             }\n         }\n \n-        // Build take indices for the values. This is used to fill in the null slots.\n-        let mut indices =\n-            MutablePrimitiveArray::<IdxSize>::with_capacity(list.values().len() + null_cnt * size);\n-        for i in 0..list.len() {\n-            if list.is_null(i) {\n-                indices.extend_constant(size, None)\n-            } else {\n-                // SAFETY: we know the index is in bound.\n-                let current_offset = unsafe { *offsets.get_unchecked(i) };\n-                for j in 0..size {\n-                    indices.push(Some(\n-                        (current_offset + O::from_as_usize(j)).to_usize() as IdxSize\n-                    ));\n+        let list_validity = list.validity().unwrap();\n+        let mut growable = make_growable(&[list.values().as_ref()], true, list.len());\n+\n+        if cfg!(debug_assertions) {\n+            let msg = \"fn cast_list_to_fixed_size_list < nullable >\";\n+            dbg!(msg);\n+        }\n+\n+        for (outer_idx, x) in offsets.windows(2).enumerate() {\n+            let [i, j] = x else { unreachable!() };\n+            let i = i.to_usize();\n+            let j = j.to_usize();\n+\n+            unsafe {\n+                let outer_is_valid = list_validity.get_bit_unchecked(outer_idx);\n+\n+                if outer_is_valid {\n+                    growable.extend(0, i, j - i);\n+                } else {\n+                    growable.extend_validity(size)\n                 }\n-            }\n+            };\n         }\n-        let take_values = unsafe {\n-            crate::compute::take::take_unchecked(list.values().as_ref(), &indices.freeze())",
        "comment_created_at": "2024-11-06T22:29:55+00:00",
        "comment_author": "nameexhaustion",
        "comment_body": "Casting nullable List -> FixedSizeList, used a gather to ensure the width of the null slots - have updated this to use `Growable` instead.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860305618",
    "pr_number": 19708,
    "pr_file": "crates/polars-time/src/replace.rs",
    "created_at": "2024-11-27T09:28:18+00:00",
    "commented_code": "+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1860305618",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19708,
        "pr_file": "crates/polars-time/src/replace.rs",
        "discussion_id": "1860305618",
        "commented_code": "@@ -0,0 +1,187 @@\n+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {",
        "comment_created_at": "2024-11-27T09:28:18+00:00",
        "comment_author": "ritchie46",
        "comment_body": "No need to use unsafe for a single value.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860305740",
    "pr_number": 19708,
    "pr_file": "crates/polars-time/src/replace.rs",
    "created_at": "2024-11-27T09:28:22+00:00",
    "commented_code": "+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.second()\n+            }\n+        } else {\n+            &second.zip_with(&second.is_not_null(), &self.second())?\n+        };\n+        let microsecond = if microsecond.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { microsecond.get_unchecked(0) } {",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1860305740",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19708,
        "pr_file": "crates/polars-time/src/replace.rs",
        "discussion_id": "1860305740",
        "commented_code": "@@ -0,0 +1,187 @@\n+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.second()\n+            }\n+        } else {\n+            &second.zip_with(&second.is_not_null(), &self.second())?\n+        };\n+        let microsecond = if microsecond.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { microsecond.get_unchecked(0) } {",
        "comment_created_at": "2024-11-27T09:28:22+00:00",
        "comment_author": "ritchie46",
        "comment_body": "No need to use unsafe for a single value.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860305854",
    "pr_number": 19708,
    "pr_file": "crates/polars-time/src/replace.rs",
    "created_at": "2024-11-27T09:28:25+00:00",
    "commented_code": "+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1860305854",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19708,
        "pr_file": "crates/polars-time/src/replace.rs",
        "discussion_id": "1860305854",
        "commented_code": "@@ -0,0 +1,187 @@\n+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {",
        "comment_created_at": "2024-11-27T09:28:25+00:00",
        "comment_author": "ritchie46",
        "comment_body": "No need to use unsafe for a single value.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860306278",
    "pr_number": 19708,
    "pr_file": "crates/polars-time/src/replace.rs",
    "created_at": "2024-11-27T09:28:39+00:00",
    "commented_code": "+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.second()\n+            }\n+        } else {\n+            &second.zip_with(&second.is_not_null(), &self.second())?\n+        };\n+        let microsecond = if microsecond.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { microsecond.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &(self.nanosecond() / 1000)\n+            }\n+        } else {\n+            &microsecond.zip_with(&microsecond.is_not_null(), &(self.nanosecond() / 1000))?\n+        };\n+\n+        let out = DatetimeChunked::new_from_parts(\n+            year,\n+            month,\n+            day,\n+            hour,\n+            minute,\n+            second,\n+            microsecond,\n+            ambiguous,\n+            &self.time_unit(),\n+            self.time_zone().as_deref(),\n+            self.name().clone(),\n+        )?;\n+        Ok(out)\n+    }\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+impl PolarsReplaceDate for DateChunked {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1860306278",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19708,
        "pr_file": "crates/polars-time/src/replace.rs",
        "discussion_id": "1860306278",
        "commented_code": "@@ -0,0 +1,187 @@\n+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.second()\n+            }\n+        } else {\n+            &second.zip_with(&second.is_not_null(), &self.second())?\n+        };\n+        let microsecond = if microsecond.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { microsecond.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &(self.nanosecond() / 1000)\n+            }\n+        } else {\n+            &microsecond.zip_with(&microsecond.is_not_null(), &(self.nanosecond() / 1000))?\n+        };\n+\n+        let out = DatetimeChunked::new_from_parts(\n+            year,\n+            month,\n+            day,\n+            hour,\n+            minute,\n+            second,\n+            microsecond,\n+            ambiguous,\n+            &self.time_unit(),\n+            self.time_zone().as_deref(),\n+            self.name().clone(),\n+        )?;\n+        Ok(out)\n+    }\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+impl PolarsReplaceDate for DateChunked {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {",
        "comment_created_at": "2024-11-27T09:28:39+00:00",
        "comment_author": "ritchie46",
        "comment_body": "No need to use unsafe for a single value.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860306339",
    "pr_number": 19708,
    "pr_file": "crates/polars-time/src/replace.rs",
    "created_at": "2024-11-27T09:28:42+00:00",
    "commented_code": "+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.second()\n+            }\n+        } else {\n+            &second.zip_with(&second.is_not_null(), &self.second())?\n+        };\n+        let microsecond = if microsecond.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { microsecond.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &(self.nanosecond() / 1000)\n+            }\n+        } else {\n+            &microsecond.zip_with(&microsecond.is_not_null(), &(self.nanosecond() / 1000))?\n+        };\n+\n+        let out = DatetimeChunked::new_from_parts(\n+            year,\n+            month,\n+            day,\n+            hour,\n+            minute,\n+            second,\n+            microsecond,\n+            ambiguous,\n+            &self.time_unit(),\n+            self.time_zone().as_deref(),\n+            self.name().clone(),\n+        )?;\n+        Ok(out)\n+    }\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+impl PolarsReplaceDate for DateChunked {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1860306339",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 19708,
        "pr_file": "crates/polars-time/src/replace.rs",
        "discussion_id": "1860306339",
        "commented_code": "@@ -0,0 +1,187 @@\n+use polars_core::prelude::*;\n+\n+use crate::prelude::*;\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+pub trait PolarsReplaceDatetime: DatetimeMethods {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+pub trait PolarsReplaceDate: DateMethods {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+#[cfg(feature = \"dtype-datetime\")]\n+impl PolarsReplaceDatetime for DatetimeChunked {\n+    #[allow(clippy::too_many_arguments)]\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+        hour: &Int8Chunked,\n+        minute: &Int8Chunked,\n+        second: &Int8Chunked,\n+        microsecond: &Int32Chunked,\n+        ambiguous: &StringChunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        // For each argument, we must check if:\n+        // 1. No value was supplied (None)       --> Use existing year from Series\n+        // 2. Value was supplied and is a Scalar --> Create full Series of value\n+        // 3. Value was supplied and is Series   --> Update all elements with the non-null values\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { month.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.month()\n+            }\n+        } else {\n+            &month.zip_with(&month.is_not_null(), &self.month())?\n+        };\n+        let day = if day.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { day.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.day()\n+            }\n+        } else {\n+            &day.zip_with(&day.is_not_null(), &self.day())?\n+        };\n+        let hour = if hour.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { hour.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.hour()\n+            }\n+        } else {\n+            &hour.zip_with(&hour.is_not_null(), &self.hour())?\n+        };\n+        let minute = if minute.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { minute.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.minute()\n+            }\n+        } else {\n+            &minute.zip_with(&minute.is_not_null(), &self.minute())?\n+        };\n+        let second = if second.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { second.get_unchecked(0) } {\n+                &Int8Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.second()\n+            }\n+        } else {\n+            &second.zip_with(&second.is_not_null(), &self.second())?\n+        };\n+        let microsecond = if microsecond.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { microsecond.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &(self.nanosecond() / 1000)\n+            }\n+        } else {\n+            &microsecond.zip_with(&microsecond.is_not_null(), &(self.nanosecond() / 1000))?\n+        };\n+\n+        let out = DatetimeChunked::new_from_parts(\n+            year,\n+            month,\n+            day,\n+            hour,\n+            minute,\n+            second,\n+            microsecond,\n+            ambiguous,\n+            &self.time_unit(),\n+            self.time_zone().as_deref(),\n+            self.name().clone(),\n+        )?;\n+        Ok(out)\n+    }\n+}\n+\n+#[cfg(feature = \"dtype-date\")]\n+impl PolarsReplaceDate for DateChunked {\n+    fn replace(\n+        &self,\n+        year: &Int32Chunked,\n+        month: &Int8Chunked,\n+        day: &Int8Chunked,\n+    ) -> PolarsResult<Self> {\n+        let n = self.len();\n+\n+        let year = if year.len() == 1 {\n+            // SAFETY: array has one value.\n+            if let Some(value) = unsafe { year.get_unchecked(0) } {\n+                &Int32Chunked::full(\"\".into(), value, n)\n+            } else {\n+                &self.year()\n+            }\n+        } else {\n+            &year.zip_with(&year.is_not_null(), &self.year())?\n+        };\n+        let month = if month.len() == 1 {",
        "comment_created_at": "2024-11-27T09:28:42+00:00",
        "comment_author": "ritchie46",
        "comment_body": "No need to use unsafe for a single value.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1885001505",
    "pr_number": 20286,
    "pr_file": "crates/polars-core/src/datatypes/dtype.rs",
    "created_at": "2024-12-14T09:48:07+00:00",
    "commented_code": "}\n     }\n \n+    /// Return whether the cast to `to` makes sense.\n+    ///\n+    /// This will never be precise but gives an initial estimate.\n+    pub fn can_cast_to(&self, to: &DataType) -> bool {",
    "repo_full_name": "pola-rs/polars",
    "discussion_comments": [
      {
        "comment_id": "1885001505",
        "repo_full_name": "pola-rs/polars",
        "pr_number": 20286,
        "pr_file": "crates/polars-core/src/datatypes/dtype.rs",
        "discussion_id": "1885001505",
        "commented_code": "@@ -320,6 +320,57 @@ impl DataType {\n         }\n     }\n \n+    /// Return whether the cast to `to` makes sense.\n+    ///\n+    /// This will never be precise but gives an initial estimate.\n+    pub fn can_cast_to(&self, to: &DataType) -> bool {",
        "comment_created_at": "2024-12-14T09:48:07+00:00",
        "comment_author": "ritchie46",
        "comment_body": "Can this return `Option<bool>`? On `None` we don't know and we must continue. But on `Some<false>` we could already error early.",
        "pr_file_module": null
      }
    ]
  }
]