[
  {
    "discussion_id": "2270897306",
    "pr_number": 36374,
    "pr_file": "products/surveys/backend/max_tools.py",
    "created_at": "2025-08-12T19:07:19+00:00",
    "commented_code": "survey_data[\"appearance\"] = appearance\n \n         return survey_data\n+\n+\n+class FeatureFlagToolkit(TaxonomyAgentToolkit):\n+    \"\"\"Toolkit for feature flag lookup operations.\"\"\"\n+\n+    def __init__(self, team: Team):\n+        super().__init__(team)\n+        self._last_lookup_result: FeatureFlagLookupResult | None = None\n+\n+    def get_tools(self) -> list:\n+        \"\"\"Get all tools (default + custom). Override in subclasses to add custom tools.\"\"\"\n+        return self._get_custom_tools()\n+\n+    def _get_custom_tools(self) -> list:\n+        \"\"\"Get custom tools for feature flag lookup.\"\"\"\n+\n+        class lookup_feature_flag(BaseModel):\n+            \"\"\"\n+            Use this tool to lookup a feature flag by its key/name to get detailed information including ID and variants.\n+            Returns a message with the flag ID and the variants if the flag is found and the variants are available.\n+            \"\"\"\n+\n+            flag_key: str = Field(description=\"The key/name of the feature flag to look up\")\n+\n+        class final_answer(base_final_answer[SurveyCreationSchema]):\n+            __doc__ = base_final_answer.__doc__\n+\n+        return [lookup_feature_flag, final_answer]\n+\n+    def handle_tools(self, tool_name: str, tool_input) -> tuple[str, str]:\n+        \"\"\"Handle custom tool execution.\"\"\"\n+        if tool_name == \"lookup_feature_flag\":\n+            result = self._lookup_feature_flag(tool_input.arguments.flag_key)\n+            return tool_name, result\n+        return super().handle_tools(tool_name, tool_input)\n+\n+    def _lookup_feature_flag(self, flag_key: str) -> str:\n+        \"\"\"Look up feature flag information by key.\"\"\"\n+        try:\n+            # Look up the feature flag by key for the current team\n+            feature_flag = FeatureFlag.objects.select_related(\"team\").get(key=flag_key, team_id=self._team.id)",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2270897306",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36374,
        "pr_file": "products/surveys/backend/max_tools.py",
        "discussion_id": "2270897306",
        "commented_code": "@@ -167,3 +151,133 @@ def _prepare_survey_data(self, survey_schema: SurveyCreationSchema, team: Team)\n         survey_data[\"appearance\"] = appearance\n \n         return survey_data\n+\n+\n+class FeatureFlagToolkit(TaxonomyAgentToolkit):\n+    \"\"\"Toolkit for feature flag lookup operations.\"\"\"\n+\n+    def __init__(self, team: Team):\n+        super().__init__(team)\n+        self._last_lookup_result: FeatureFlagLookupResult | None = None\n+\n+    def get_tools(self) -> list:\n+        \"\"\"Get all tools (default + custom). Override in subclasses to add custom tools.\"\"\"\n+        return self._get_custom_tools()\n+\n+    def _get_custom_tools(self) -> list:\n+        \"\"\"Get custom tools for feature flag lookup.\"\"\"\n+\n+        class lookup_feature_flag(BaseModel):\n+            \"\"\"\n+            Use this tool to lookup a feature flag by its key/name to get detailed information including ID and variants.\n+            Returns a message with the flag ID and the variants if the flag is found and the variants are available.\n+            \"\"\"\n+\n+            flag_key: str = Field(description=\"The key/name of the feature flag to look up\")\n+\n+        class final_answer(base_final_answer[SurveyCreationSchema]):\n+            __doc__ = base_final_answer.__doc__\n+\n+        return [lookup_feature_flag, final_answer]\n+\n+    def handle_tools(self, tool_name: str, tool_input) -> tuple[str, str]:\n+        \"\"\"Handle custom tool execution.\"\"\"\n+        if tool_name == \"lookup_feature_flag\":\n+            result = self._lookup_feature_flag(tool_input.arguments.flag_key)\n+            return tool_name, result\n+        return super().handle_tools(tool_name, tool_input)\n+\n+    def _lookup_feature_flag(self, flag_key: str) -> str:\n+        \"\"\"Look up feature flag information by key.\"\"\"\n+        try:\n+            # Look up the feature flag by key for the current team\n+            feature_flag = FeatureFlag.objects.select_related(\"team\").get(key=flag_key, team_id=self._team.id)",
        "comment_created_at": "2025-08-12T19:07:19+00:00",
        "comment_author": "lucasheriques",
        "comment_body": "```suggestion\r\n            feature_flag = FeatureFlag.objects.get(key=flag_key, team_id=self._team.id)\r\n```\r\n\r\n`select_related(\"team\")` is unnecessary here since we're filtering by `team_id` and don't use the team object",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2251849409",
    "pr_number": 35726,
    "pr_file": "ee/hogai/graph/insights/nodes.py",
    "created_at": "2025-08-04T15:32:55+00:00",
    "commented_code": "\"insight__team\",\n                 \"insight__short_id\",\n                 \"insight__query\",\n+                \"insight__filters\",\n             )\n             .order_by(\"insight_id\", \"-last_viewed_at\")\n             .distinct(\"insight_id\")\n         )\n \n-        self._all_insights = list(\n+    def _get_total_insights_count(self) -> int:\n+        if self._total_insights_count is None:\n+            self._total_insights_count = self._get_insights_queryset().count()\n+        return self._total_insights_count\n+\n+    def _load_insights_page(self, page_number: int) -> list[dict]:",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2251849409",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 35726,
        "pr_file": "ee/hogai/graph/insights/nodes.py",
        "discussion_id": "2251849409",
        "commented_code": "@@ -135,33 +142,52 @@ def _load_all_insights(self) -> None:\n                 \"insight__team\",\n                 \"insight__short_id\",\n                 \"insight__query\",\n+                \"insight__filters\",\n             )\n             .order_by(\"insight_id\", \"-last_viewed_at\")\n             .distinct(\"insight_id\")\n         )\n \n-        self._all_insights = list(\n+    def _get_total_insights_count(self) -> int:\n+        if self._total_insights_count is None:\n+            self._total_insights_count = self._get_insights_queryset().count()\n+        return self._total_insights_count\n+\n+    def _load_insights_page(self, page_number: int) -> list[dict]:",
        "comment_created_at": "2025-08-04T15:32:55+00:00",
        "comment_author": "kappa90",
        "comment_body": "You're loading `InsightViewed` then extracting fields from the related `Insight` model as a dict, and then you reconstruct the insight queries and filters later in other parts of the class. This sounds convoluted. You should use the `Insight` model directly, ar the viewed one would be a sunset. Then you can directly keep the loaded insights in `loaded_pages`, and avoid the formatting down the line.",
        "pr_file_module": null
      },
      {
        "comment_id": "2251873141",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 35726,
        "pr_file": "ee/hogai/graph/insights/nodes.py",
        "discussion_id": "2251849409",
        "commented_code": "@@ -135,33 +142,52 @@ def _load_all_insights(self) -> None:\n                 \"insight__team\",\n                 \"insight__short_id\",\n                 \"insight__query\",\n+                \"insight__filters\",\n             )\n             .order_by(\"insight_id\", \"-last_viewed_at\")\n             .distinct(\"insight_id\")\n         )\n \n-        self._all_insights = list(\n+    def _get_total_insights_count(self) -> int:\n+        if self._total_insights_count is None:\n+            self._total_insights_count = self._get_insights_queryset().count()\n+        return self._total_insights_count\n+\n+    def _load_insights_page(self, page_number: int) -> list[dict]:",
        "comment_created_at": "2025-08-04T15:44:04+00:00",
        "comment_author": "kappa90",
        "comment_body": "Also, this is a blocking thread, use async queries.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2250936978",
    "pr_number": 36014,
    "pr_file": "dags/web_preaggregated_team_selection_strategies.py",
    "created_at": "2025-08-04T09:31:44+00:00",
    "commented_code": "+import os\n+from abc import ABC, abstractmethod\n+\n+import dagster\n+from posthog.clickhouse.client import sync_execute\n+from posthog.models.web_preaggregated.team_selection import (\n+    DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT,\n+    get_top_teams_by_median_pageviews_sql,\n+)\n+\n+\n+class TeamSelectionStrategy(ABC):\n+    \"\"\"Abstract base class for team selection strategies.\"\"\"\n+\n+    @abstractmethod\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        \"\"\"Get teams using this strategy.\"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_name(self) -> str:\n+        \"\"\"Get the strategy name.\"\"\"\n+        pass\n+\n+\n+class EnvironmentVariableStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams from environment variable configuration.\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"environment_variable\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        env_teams = os.getenv(\"WEB_ANALYTICS_ENABLED_TEAM_IDS\")\n+        if not env_teams:\n+            context.log.info(\"No teams found in WEB_ANALYTICS_ENABLED_TEAM_IDS environment variable\")\n+            return set()\n+\n+        team_ids = set()\n+        invalid_ids = []\n+\n+        for tid in env_teams.split(\",\"):\n+            tid = tid.strip()\n+            if tid:\n+                try:\n+                    team_ids.add(int(tid))\n+                except ValueError:\n+                    invalid_ids.append(tid)\n+\n+        if invalid_ids:\n+            context.log.warning(f\"Invalid team IDs in environment variable: {invalid_ids}\")\n+\n+        context.log.info(f\"Found {len(team_ids)} valid teams from environment variable\")\n+        return team_ids\n+\n+\n+class HighPageviewsStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams with the highest pageview counts (default: 30).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"high_pageviews\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        try:\n+            limit = int(os.getenv(\"WEB_ANALYTICS_TOP_TEAMS_LIMIT\", str(DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT)))\n+            sql = get_top_teams_by_median_pageviews_sql(limit)\n+            result = sync_execute(sql)\n+            team_ids = {row[0] for row in result}\n+            context.log.info(f\"Found {len(team_ids)} teams with high pageviews\")\n+            return team_ids\n+        except ValueError as e:\n+            context.log.exception(f\"Invalid configuration for pageviews query: {e}\")\n+            return set()\n+        except Exception as e:\n+            context.log.warning(f\"Failed to fetch top teams by pageviews: {e}\")\n+            return set()\n+\n+\n+class FeatureEnrollmentStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams where users have enrolled in a specific feature preview (default: web-analytics-api).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"feature_enrollment\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        flag_key = os.getenv(\"WEB_ANALYTICS_FEATURE_FLAG_KEY\", \"web-analytics-api\")\n+\n+        try:\n+            from posthog.models.person.person import Person\n+\n+            # Query PostgreSQL for teams with enrolled users\n+            enrollment_key = f\"$feature_enrollment/{flag_key}\"\n+            team_ids = (\n+                Person.objects.filter(**{f\"properties__{enrollment_key}\": True})",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2250936978",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36014,
        "pr_file": "dags/web_preaggregated_team_selection_strategies.py",
        "discussion_id": "2250936978",
        "commented_code": "@@ -0,0 +1,131 @@\n+import os\n+from abc import ABC, abstractmethod\n+\n+import dagster\n+from posthog.clickhouse.client import sync_execute\n+from posthog.models.web_preaggregated.team_selection import (\n+    DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT,\n+    get_top_teams_by_median_pageviews_sql,\n+)\n+\n+\n+class TeamSelectionStrategy(ABC):\n+    \"\"\"Abstract base class for team selection strategies.\"\"\"\n+\n+    @abstractmethod\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        \"\"\"Get teams using this strategy.\"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_name(self) -> str:\n+        \"\"\"Get the strategy name.\"\"\"\n+        pass\n+\n+\n+class EnvironmentVariableStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams from environment variable configuration.\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"environment_variable\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        env_teams = os.getenv(\"WEB_ANALYTICS_ENABLED_TEAM_IDS\")\n+        if not env_teams:\n+            context.log.info(\"No teams found in WEB_ANALYTICS_ENABLED_TEAM_IDS environment variable\")\n+            return set()\n+\n+        team_ids = set()\n+        invalid_ids = []\n+\n+        for tid in env_teams.split(\",\"):\n+            tid = tid.strip()\n+            if tid:\n+                try:\n+                    team_ids.add(int(tid))\n+                except ValueError:\n+                    invalid_ids.append(tid)\n+\n+        if invalid_ids:\n+            context.log.warning(f\"Invalid team IDs in environment variable: {invalid_ids}\")\n+\n+        context.log.info(f\"Found {len(team_ids)} valid teams from environment variable\")\n+        return team_ids\n+\n+\n+class HighPageviewsStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams with the highest pageview counts (default: 30).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"high_pageviews\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        try:\n+            limit = int(os.getenv(\"WEB_ANALYTICS_TOP_TEAMS_LIMIT\", str(DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT)))\n+            sql = get_top_teams_by_median_pageviews_sql(limit)\n+            result = sync_execute(sql)\n+            team_ids = {row[0] for row in result}\n+            context.log.info(f\"Found {len(team_ids)} teams with high pageviews\")\n+            return team_ids\n+        except ValueError as e:\n+            context.log.exception(f\"Invalid configuration for pageviews query: {e}\")\n+            return set()\n+        except Exception as e:\n+            context.log.warning(f\"Failed to fetch top teams by pageviews: {e}\")\n+            return set()\n+\n+\n+class FeatureEnrollmentStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams where users have enrolled in a specific feature preview (default: web-analytics-api).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"feature_enrollment\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        flag_key = os.getenv(\"WEB_ANALYTICS_FEATURE_FLAG_KEY\", \"web-analytics-api\")\n+\n+        try:\n+            from posthog.models.person.person import Person\n+\n+            # Query PostgreSQL for teams with enrolled users\n+            enrollment_key = f\"$feature_enrollment/{flag_key}\"\n+            team_ids = (\n+                Person.objects.filter(**{f\"properties__{enrollment_key}\": True})",
        "comment_created_at": "2025-08-04T09:31:44+00:00",
        "comment_author": "joshsny",
        "comment_body": "I think this will fail in prod - it'll scan the entire persons table in postgres (which I've done before, and it'd just timeout). Maybe it's fine as it's in a dag \ud83e\udd37\r\n\r\nThis probs needs to hit CH instead, see here for an example query: https://github.com/PostHog/posthog/blob/9d5516ce483705fc0912e45b2bb409361396236c/posthog/tasks/early_access_feature.py#L34",
        "pr_file_module": null
      },
      {
        "comment_id": "2250938616",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36014,
        "pr_file": "dags/web_preaggregated_team_selection_strategies.py",
        "discussion_id": "2250936978",
        "commented_code": "@@ -0,0 +1,131 @@\n+import os\n+from abc import ABC, abstractmethod\n+\n+import dagster\n+from posthog.clickhouse.client import sync_execute\n+from posthog.models.web_preaggregated.team_selection import (\n+    DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT,\n+    get_top_teams_by_median_pageviews_sql,\n+)\n+\n+\n+class TeamSelectionStrategy(ABC):\n+    \"\"\"Abstract base class for team selection strategies.\"\"\"\n+\n+    @abstractmethod\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        \"\"\"Get teams using this strategy.\"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_name(self) -> str:\n+        \"\"\"Get the strategy name.\"\"\"\n+        pass\n+\n+\n+class EnvironmentVariableStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams from environment variable configuration.\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"environment_variable\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        env_teams = os.getenv(\"WEB_ANALYTICS_ENABLED_TEAM_IDS\")\n+        if not env_teams:\n+            context.log.info(\"No teams found in WEB_ANALYTICS_ENABLED_TEAM_IDS environment variable\")\n+            return set()\n+\n+        team_ids = set()\n+        invalid_ids = []\n+\n+        for tid in env_teams.split(\",\"):\n+            tid = tid.strip()\n+            if tid:\n+                try:\n+                    team_ids.add(int(tid))\n+                except ValueError:\n+                    invalid_ids.append(tid)\n+\n+        if invalid_ids:\n+            context.log.warning(f\"Invalid team IDs in environment variable: {invalid_ids}\")\n+\n+        context.log.info(f\"Found {len(team_ids)} valid teams from environment variable\")\n+        return team_ids\n+\n+\n+class HighPageviewsStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams with the highest pageview counts (default: 30).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"high_pageviews\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        try:\n+            limit = int(os.getenv(\"WEB_ANALYTICS_TOP_TEAMS_LIMIT\", str(DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT)))\n+            sql = get_top_teams_by_median_pageviews_sql(limit)\n+            result = sync_execute(sql)\n+            team_ids = {row[0] for row in result}\n+            context.log.info(f\"Found {len(team_ids)} teams with high pageviews\")\n+            return team_ids\n+        except ValueError as e:\n+            context.log.exception(f\"Invalid configuration for pageviews query: {e}\")\n+            return set()\n+        except Exception as e:\n+            context.log.warning(f\"Failed to fetch top teams by pageviews: {e}\")\n+            return set()\n+\n+\n+class FeatureEnrollmentStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams where users have enrolled in a specific feature preview (default: web-analytics-api).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"feature_enrollment\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        flag_key = os.getenv(\"WEB_ANALYTICS_FEATURE_FLAG_KEY\", \"web-analytics-api\")\n+\n+        try:\n+            from posthog.models.person.person import Person\n+\n+            # Query PostgreSQL for teams with enrolled users\n+            enrollment_key = f\"$feature_enrollment/{flag_key}\"\n+            team_ids = (\n+                Person.objects.filter(**{f\"properties__{enrollment_key}\": True})",
        "comment_created_at": "2025-08-04T09:32:27+00:00",
        "comment_author": "joshsny",
        "comment_body": "it would be really nice if we had a way for teams to opt into previews for all their users \ud83e\udd14",
        "pr_file_module": null
      },
      {
        "comment_id": "2250956446",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36014,
        "pr_file": "dags/web_preaggregated_team_selection_strategies.py",
        "discussion_id": "2250936978",
        "commented_code": "@@ -0,0 +1,131 @@\n+import os\n+from abc import ABC, abstractmethod\n+\n+import dagster\n+from posthog.clickhouse.client import sync_execute\n+from posthog.models.web_preaggregated.team_selection import (\n+    DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT,\n+    get_top_teams_by_median_pageviews_sql,\n+)\n+\n+\n+class TeamSelectionStrategy(ABC):\n+    \"\"\"Abstract base class for team selection strategies.\"\"\"\n+\n+    @abstractmethod\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        \"\"\"Get teams using this strategy.\"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def get_name(self) -> str:\n+        \"\"\"Get the strategy name.\"\"\"\n+        pass\n+\n+\n+class EnvironmentVariableStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams from environment variable configuration.\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"environment_variable\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        env_teams = os.getenv(\"WEB_ANALYTICS_ENABLED_TEAM_IDS\")\n+        if not env_teams:\n+            context.log.info(\"No teams found in WEB_ANALYTICS_ENABLED_TEAM_IDS environment variable\")\n+            return set()\n+\n+        team_ids = set()\n+        invalid_ids = []\n+\n+        for tid in env_teams.split(\",\"):\n+            tid = tid.strip()\n+            if tid:\n+                try:\n+                    team_ids.add(int(tid))\n+                except ValueError:\n+                    invalid_ids.append(tid)\n+\n+        if invalid_ids:\n+            context.log.warning(f\"Invalid team IDs in environment variable: {invalid_ids}\")\n+\n+        context.log.info(f\"Found {len(team_ids)} valid teams from environment variable\")\n+        return team_ids\n+\n+\n+class HighPageviewsStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams with the highest pageview counts (default: 30).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"high_pageviews\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        try:\n+            limit = int(os.getenv(\"WEB_ANALYTICS_TOP_TEAMS_LIMIT\", str(DEFAULT_TOP_TEAMS_BY_PAGEVIEWS_LIMIT)))\n+            sql = get_top_teams_by_median_pageviews_sql(limit)\n+            result = sync_execute(sql)\n+            team_ids = {row[0] for row in result}\n+            context.log.info(f\"Found {len(team_ids)} teams with high pageviews\")\n+            return team_ids\n+        except ValueError as e:\n+            context.log.exception(f\"Invalid configuration for pageviews query: {e}\")\n+            return set()\n+        except Exception as e:\n+            context.log.warning(f\"Failed to fetch top teams by pageviews: {e}\")\n+            return set()\n+\n+\n+class FeatureEnrollmentStrategy(TeamSelectionStrategy):\n+    \"\"\"Select teams where users have enrolled in a specific feature preview (default: web-analytics-api).\"\"\"\n+\n+    def get_name(self) -> str:\n+        return \"feature_enrollment\"\n+\n+    def get_teams(self, context: dagster.OpExecutionContext) -> set[int]:\n+        flag_key = os.getenv(\"WEB_ANALYTICS_FEATURE_FLAG_KEY\", \"web-analytics-api\")\n+\n+        try:\n+            from posthog.models.person.person import Person\n+\n+            # Query PostgreSQL for teams with enrolled users\n+            enrollment_key = f\"$feature_enrollment/{flag_key}\"\n+            team_ids = (\n+                Person.objects.filter(**{f\"properties__{enrollment_key}\": True})",
        "comment_created_at": "2025-08-04T09:39:51+00:00",
        "comment_author": "lricoy",
        "comment_body": "Oh, that makes sense. I saw that query and considered it, but I thought this would be more direct as it wouldn't require an exposure event. I will change it!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2247307893",
    "pr_number": 35980,
    "pr_file": "ee/clickhouse/views/groups.py",
    "created_at": "2025-08-01T08:24:38+00:00",
    "commented_code": "fields = [\"group_type_index\", \"group_key\", \"group_properties\", \"created_at\"]\n \n \n+class FindGroupSerializer(GroupSerializer):\n+    notebook = serializers.SerializerMethodField()\n+\n+    class Meta:\n+        model = Group\n+        fields = [*GroupSerializer.Meta.fields, \"notebook\"]\n+\n+    def get_notebook(self, obj: Group) -> str | None:\n+        relationship = obj.notebook_relationships.first()\n+        return relationship.notebook.short_id if relationship else None",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2247307893",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 35980,
        "pr_file": "ee/clickhouse/views/groups.py",
        "discussion_id": "2247307893",
        "commented_code": "@@ -105,6 +108,18 @@ class Meta:\n         fields = [\"group_type_index\", \"group_key\", \"group_properties\", \"created_at\"]\n \n \n+class FindGroupSerializer(GroupSerializer):\n+    notebook = serializers.SerializerMethodField()\n+\n+    class Meta:\n+        model = Group\n+        fields = [*GroupSerializer.Meta.fields, \"notebook\"]\n+\n+    def get_notebook(self, obj: Group) -> str | None:\n+        relationship = obj.notebook_relationships.first()\n+        return relationship.notebook.short_id if relationship else None",
        "comment_created_at": "2025-08-01T08:24:38+00:00",
        "comment_author": "daibhin",
        "comment_body": "Can we avoid the N+1 here by doing something like `prefetch_related(\"notebook_relationships__notebook\")` when finding the groups?",
        "pr_file_module": null
      }
    ]
  }
]