[
  {
    "discussion_id": "2281664198",
    "pr_number": 36307,
    "pr_file": "posthog/migrations/0822_alter_team_session_recording_retention_period.py",
    "created_at": "2025-08-18T08:26:44+00:00",
    "commented_code": null,
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2281664198",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36307,
        "pr_file": "posthog/migrations/0822_alter_team_session_recording_retention_period.py",
        "discussion_id": "2281664198",
        "commented_code": null,
        "comment_created_at": "2025-08-18T08:26:44+00:00",
        "comment_author": "pauldambra",
        "comment_body": "i'd collapse these two to one new migration instead of creating and altering in one go\r\ncould also just do that in a different PR and then all the `ambr` changes are out of the way for this PR\r\ni think this setting change is more than safe enough to just go in by itself",
        "pr_file_module": null
      },
      {
        "comment_id": "2281664925",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36307,
        "pr_file": "posthog/migrations/0822_alter_team_session_recording_retention_period.py",
        "discussion_id": "2281664198",
        "commented_code": null,
        "comment_created_at": "2025-08-18T08:27:04+00:00",
        "comment_author": "pauldambra",
        "comment_body": "we used to have a job that failed if more than one migration (i don't remember why \ud83d\ude48)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2273123945",
    "pr_number": 36283,
    "pr_file": "posthog/models/cohort/cohort.py",
    "created_at": "2025-08-13T11:43:05+00:00",
    "commented_code": "is_static = models.BooleanField(default=False)\n \n+    cohort_type = models.CharField(\n+        max_length=20,\n+        choices=COHORT_TYPE_CHOICES,\n+        null=True,\n+        blank=True,",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2273123945",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36283,
        "pr_file": "posthog/models/cohort/cohort.py",
        "discussion_id": "2273123945",
        "commented_code": "@@ -164,6 +175,14 @@ class Cohort(FileSystemSyncMixin, RootTeamMixin, models.Model):\n \n     is_static = models.BooleanField(default=False)\n \n+    cohort_type = models.CharField(\n+        max_length=20,\n+        choices=COHORT_TYPE_CHOICES,\n+        null=True,\n+        blank=True,",
        "comment_created_at": "2025-08-13T11:43:05+00:00",
        "comment_author": "meikelmosby",
        "comment_body": "leaving this null bc we still need to migrate the types of existing cohorts or do we actually _want_ this to be null?",
        "pr_file_module": null
      },
      {
        "comment_id": "2274235279",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36283,
        "pr_file": "posthog/models/cohort/cohort.py",
        "discussion_id": "2273123945",
        "commented_code": "@@ -164,6 +175,14 @@ class Cohort(FileSystemSyncMixin, RootTeamMixin, models.Model):\n \n     is_static = models.BooleanField(default=False)\n \n+    cohort_type = models.CharField(\n+        max_length=20,\n+        choices=COHORT_TYPE_CHOICES,\n+        null=True,\n+        blank=True,",
        "comment_created_at": "2025-08-13T18:02:52+00:00",
        "comment_author": "dmarticus",
        "comment_body": "the former\u00a0\u2013 I want to do the migration safely, so my vision was that the migration that actually populates the data will be a separate PR.  My proposed flow is\r\n\r\nCreate the nullable field -> migrate all existing cohorts based on their filters -> drop null constraint",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2273138394",
    "pr_number": 36283,
    "pr_file": "posthog/models/cohort/cohort.py",
    "created_at": "2025-08-13T11:47:58+00:00",
    "commented_code": "return True\n         return False\n \n+    def determine_cohort_type(self) -> str:\n+        \"\"\"Determine cohort type based on filters\"\"\"\n+        if self.is_static:\n+            return COHORT_TYPE_STATIC\n+\n+        # Analyze all properties to determine maximum complexity\n+        has_cohort_filters = False\n+        has_person_filters = False\n+        has_behavioral_filters = False\n+\n+        for prop in self.properties.flat:\n+            if prop.type == \"cohort\":\n+                has_cohort_filters = True\n+            elif prop.type == \"person\":\n+                has_person_filters = True\n+            elif prop.type == \"behavioral\":\n+                has_behavioral_filters = True\n+\n+        # Return the most complex type\n+        if self.has_analytical_filters:\n+            return COHORT_TYPE_ANALYTICAL\n+        elif has_behavioral_filters:\n+            return COHORT_TYPE_BEHAVIORAL\n+        elif has_person_filters or has_cohort_filters:\n+            return COHORT_TYPE_PERSON_PROPERTY\n+        else:\n+            return COHORT_TYPE_PERSON_PROPERTY  # Default for empty cohorts\n+\n+    def can_be_used_in_feature_flag(self) -> bool:\n+        \"\"\"Determine if cohort can be used in feature flag targeting\"\"\"\n+        if self.is_static:\n+            return True\n+\n+        # Legacy check for backward compatibility\n+        if not self.cohort_type:\n+            # Fall back to determining type dynamically for unmigrated cohorts\n+            # This ensures consistent behavior for legacy cohorts\n+            determined_type = self.determine_cohort_type()\n+            return determined_type in [COHORT_TYPE_STATIC, COHORT_TYPE_PERSON_PROPERTY]",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2273138394",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36283,
        "pr_file": "posthog/models/cohort/cohort.py",
        "discussion_id": "2273138394",
        "commented_code": "@@ -269,6 +289,56 @@ def has_complex_behavioral_filter(self) -> bool:\n                 return True\n         return False\n \n+    def determine_cohort_type(self) -> str:\n+        \"\"\"Determine cohort type based on filters\"\"\"\n+        if self.is_static:\n+            return COHORT_TYPE_STATIC\n+\n+        # Analyze all properties to determine maximum complexity\n+        has_cohort_filters = False\n+        has_person_filters = False\n+        has_behavioral_filters = False\n+\n+        for prop in self.properties.flat:\n+            if prop.type == \"cohort\":\n+                has_cohort_filters = True\n+            elif prop.type == \"person\":\n+                has_person_filters = True\n+            elif prop.type == \"behavioral\":\n+                has_behavioral_filters = True\n+\n+        # Return the most complex type\n+        if self.has_analytical_filters:\n+            return COHORT_TYPE_ANALYTICAL\n+        elif has_behavioral_filters:\n+            return COHORT_TYPE_BEHAVIORAL\n+        elif has_person_filters or has_cohort_filters:\n+            return COHORT_TYPE_PERSON_PROPERTY\n+        else:\n+            return COHORT_TYPE_PERSON_PROPERTY  # Default for empty cohorts\n+\n+    def can_be_used_in_feature_flag(self) -> bool:\n+        \"\"\"Determine if cohort can be used in feature flag targeting\"\"\"\n+        if self.is_static:\n+            return True\n+\n+        # Legacy check for backward compatibility\n+        if not self.cohort_type:\n+            # Fall back to determining type dynamically for unmigrated cohorts\n+            # This ensures consistent behavior for legacy cohorts\n+            determined_type = self.determine_cohort_type()\n+            return determined_type in [COHORT_TYPE_STATIC, COHORT_TYPE_PERSON_PROPERTY]",
        "comment_created_at": "2025-08-13T11:47:58+00:00",
        "comment_author": "meikelmosby",
        "comment_body": "i wish we would have split this PR differently .. as in \n\n1. introduce the cohort_type & create the new cohort_type for every new cohort created\n2. do the actual migration of migrating existing cohorts to the new types \n3. -- now we have state were every new cohort created has a type and every old cohort is migrated over -- \n4. introduce the rest of the logic etc (we would not need any of the backwards compatible query stuff to dynamically determine the cohort types.. )\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2274236102",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36283,
        "pr_file": "posthog/models/cohort/cohort.py",
        "discussion_id": "2273138394",
        "commented_code": "@@ -269,6 +289,56 @@ def has_complex_behavioral_filter(self) -> bool:\n                 return True\n         return False\n \n+    def determine_cohort_type(self) -> str:\n+        \"\"\"Determine cohort type based on filters\"\"\"\n+        if self.is_static:\n+            return COHORT_TYPE_STATIC\n+\n+        # Analyze all properties to determine maximum complexity\n+        has_cohort_filters = False\n+        has_person_filters = False\n+        has_behavioral_filters = False\n+\n+        for prop in self.properties.flat:\n+            if prop.type == \"cohort\":\n+                has_cohort_filters = True\n+            elif prop.type == \"person\":\n+                has_person_filters = True\n+            elif prop.type == \"behavioral\":\n+                has_behavioral_filters = True\n+\n+        # Return the most complex type\n+        if self.has_analytical_filters:\n+            return COHORT_TYPE_ANALYTICAL\n+        elif has_behavioral_filters:\n+            return COHORT_TYPE_BEHAVIORAL\n+        elif has_person_filters or has_cohort_filters:\n+            return COHORT_TYPE_PERSON_PROPERTY\n+        else:\n+            return COHORT_TYPE_PERSON_PROPERTY  # Default for empty cohorts\n+\n+    def can_be_used_in_feature_flag(self) -> bool:\n+        \"\"\"Determine if cohort can be used in feature flag targeting\"\"\"\n+        if self.is_static:\n+            return True\n+\n+        # Legacy check for backward compatibility\n+        if not self.cohort_type:\n+            # Fall back to determining type dynamically for unmigrated cohorts\n+            # This ensures consistent behavior for legacy cohorts\n+            determined_type = self.determine_cohort_type()\n+            return determined_type in [COHORT_TYPE_STATIC, COHORT_TYPE_PERSON_PROPERTY]",
        "comment_created_at": "2025-08-13T18:03:17+00:00",
        "comment_author": "dmarticus",
        "comment_body": "this is super fair and I'm gonna blow up this PR into 3 parts, as I mentioned here: https://posthog.slack.com/archives/C09494B1AN5/p1755092140443499?thread_ts=1755087666.737709&cid=C09494B1AN5",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2246534353",
    "pr_number": 35980,
    "pr_file": "posthog/migrations/0816_notebook_hidden.py",
    "created_at": "2025-07-31T22:55:37+00:00",
    "commented_code": "+# Generated by Django 4.2.22 on 2025-07-31 18:16\n+\n+from django.db import migrations, models",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2246534353",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 35980,
        "pr_file": "posthog/migrations/0816_notebook_hidden.py",
        "discussion_id": "2246534353",
        "commented_code": "@@ -0,0 +1,15 @@\n+# Generated by Django 4.2.22 on 2025-07-31 18:16\n+\n+from django.db import migrations, models",
        "comment_created_at": "2025-07-31T22:55:37+00:00",
        "comment_author": "zlwaterfield",
        "comment_body": "Feedback on migrations, I don't like PRs with multiple migrations because if one succeeds and the other one fails, the deploy could be stopped and the db could get out of sync with the codebase. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2247805819",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 35980,
        "pr_file": "posthog/migrations/0816_notebook_hidden.py",
        "discussion_id": "2246534353",
        "commented_code": "@@ -0,0 +1,15 @@\n+# Generated by Django 4.2.22 on 2025-07-31 18:16\n+\n+from django.db import migrations, models",
        "comment_created_at": "2025-08-01T12:02:45+00:00",
        "comment_author": "arthurdedeus",
        "comment_body": "makes sense! will split this PR into 2",
        "pr_file_module": null
      }
    ]
  }
]