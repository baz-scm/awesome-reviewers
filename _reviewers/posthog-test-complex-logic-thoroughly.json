[
  {
    "discussion_id": "2277295206",
    "pr_number": 36647,
    "pr_file": "frontend/src/scenes/session-recordings/player/rrweb/canvas/canvas-plugin.ts",
    "created_at": "2025-08-14T17:30:43+00:00",
    "commented_code": "const handleMutationError = (error: unknown): void => {\n     posthog.captureException(error)\n }\n+\n+const objectUrlsById = new Map<number, Set<string>>()\n+\n+const trackUrl = (id: number, url: string): void => {\n+    let set = objectUrlsById.get(id)\n+    if (!set) {\n+        set = new Set()\n+        objectUrlsById.set(id, set)\n+    }\n+    set.add(url)\n+}\n+\n+const revokeAllForIdExcept = (id: number, keep?: string): void => {\n+    const set = objectUrlsById.get(id)\n+    if (!set) {\n+        return\n+    }\n+    for (const u of set) {\n+        if (keep && u === keep) {\n+            continue\n+        }\n+        URL.revokeObjectURL(u)\n+        set.delete(u)\n+    }\n+    if (set.size === 0) {\n+        objectUrlsById.delete(id)\n+    }\n+}\n+\n+const finalizeUrl = (id: number, url: string): void => {\n+    // This runs on load/error. Revoke the url we just used and drop it from the set.\n+    URL.revokeObjectURL(url)\n+    const set = objectUrlsById.get(id)\n+    if (set) {\n+        set.delete(url)\n+        if (set.size === 0) {\n+            objectUrlsById.delete(id)\n+        }\n+    }",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2277295206",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36647,
        "pr_file": "frontend/src/scenes/session-recordings/player/rrweb/canvas/canvas-plugin.ts",
        "discussion_id": "2277295206",
        "commented_code": "@@ -251,3 +270,43 @@ export const CanvasReplayerPlugin = (events: eventWithTime[]): ReplayPlugin => {\n const handleMutationError = (error: unknown): void => {\n     posthog.captureException(error)\n }\n+\n+const objectUrlsById = new Map<number, Set<string>>()\n+\n+const trackUrl = (id: number, url: string): void => {\n+    let set = objectUrlsById.get(id)\n+    if (!set) {\n+        set = new Set()\n+        objectUrlsById.set(id, set)\n+    }\n+    set.add(url)\n+}\n+\n+const revokeAllForIdExcept = (id: number, keep?: string): void => {\n+    const set = objectUrlsById.get(id)\n+    if (!set) {\n+        return\n+    }\n+    for (const u of set) {\n+        if (keep && u === keep) {\n+            continue\n+        }\n+        URL.revokeObjectURL(u)\n+        set.delete(u)\n+    }\n+    if (set.size === 0) {\n+        objectUrlsById.delete(id)\n+    }\n+}\n+\n+const finalizeUrl = (id: number, url: string): void => {\n+    // This runs on load/error. Revoke the url we just used and drop it from the set.\n+    URL.revokeObjectURL(url)\n+    const set = objectUrlsById.get(id)\n+    if (set) {\n+        set.delete(url)\n+        if (set.size === 0) {\n+            objectUrlsById.delete(id)\n+        }\n+    }",
        "comment_created_at": "2025-08-14T17:30:43+00:00",
        "comment_author": "pauldambra",
        "comment_body": "nice\r\nif i was nit-picking we're relying on instance equality here cos we mutate the set without putting it back in the map\r\n\r\nthat's probably OK \r\n\r\nwe could also wrap this in some unit/developer tests since there's some logic here now\r\nbut let's prove it helps before polishing anythin \ud83d\ude0a ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2263821803",
    "pr_number": 36391,
    "pr_file": "products/llm_observability/frontend/llmObservabilityTraceLogic.ts",
    "created_at": "2025-08-08T19:16:17+00:00",
    "commented_code": "setDisplayOption: ({ displayOption }) => {\n             localStorage.setItem('llm-observability-display-option', JSON.stringify(displayOption))\n         },\n+        initializeMessageStates: ({ inputCount, outputCount }) => {",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2263821803",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36391,
        "pr_file": "products/llm_observability/frontend/llmObservabilityTraceLogic.ts",
        "discussion_id": "2263821803",
        "commented_code": "@@ -182,6 +215,48 @@ export const llmObservabilityTraceLogic = kea<llmObservabilityTraceLogicType>([\n         setDisplayOption: ({ displayOption }) => {\n             localStorage.setItem('llm-observability-display-option', JSON.stringify(displayOption))\n         },\n+        initializeMessageStates: ({ inputCount, outputCount }) => {",
        "comment_created_at": "2025-08-08T19:16:17+00:00",
        "comment_author": "k11kirky",
        "comment_body": "Overall these state changes could have a bunch of edge cases that my brain cannot figure out while reading this. I would love a test on this. It might force us to extract some of this state calculation into util functions so they can be more easily tested",
        "pr_file_module": null
      },
      {
        "comment_id": "2263986207",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 36391,
        "pr_file": "products/llm_observability/frontend/llmObservabilityTraceLogic.ts",
        "discussion_id": "2263821803",
        "commented_code": "@@ -182,6 +215,48 @@ export const llmObservabilityTraceLogic = kea<llmObservabilityTraceLogicType>([\n         setDisplayOption: ({ displayOption }) => {\n             localStorage.setItem('llm-observability-display-option', JSON.stringify(displayOption))\n         },\n+        initializeMessageStates: ({ inputCount, outputCount }) => {",
        "comment_created_at": "2025-08-08T21:05:22+00:00",
        "comment_author": "Radu-Raicea",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2260660994",
    "pr_number": 35926,
    "pr_file": "plugin-server/src/worker/ingestion/persons/repositories/postgres-person-repository.test.ts",
    "created_at": "2025-08-07T15:21:08+00:00",
    "commented_code": "})\n     })\n \n+    describe('person properties size violation handling', () => {\n+        let oversizedRepository: PostgresPersonRepository\n+\n+        beforeEach(() => {\n+            oversizedRepository = new PostgresPersonRepository(postgres, {\n+                calculatePropertiesSize: 0,\n+                personPropertiesSizeLimit: 50,\n+            })\n+        })\n+\n+        describe('trimPropertiesToFitSize', () => {\n+            it('should return original properties if they are under the size limit', () => {\n+                const properties = { name: 'John', age: 30 }\n+                const targetSize = 1000\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toEqual(properties)\n+            })\n+\n+            it('should remove properties to fit under size limit', () => {\n+                const properties = {\n+                    name: 'John Doe',\n+                    email: 'john@example.com',\n+                    description: 'A very long description that takes up a lot of space',\n+                    age: 30,\n+                    city: 'New York',\n+                }\n+                const targetSize = 50\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(Object.keys(result).length).toBeLessThan(Object.keys(properties).length)\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeLessThanOrEqual(targetSize)\n+            })\n+\n+            it('should preserve protected properties even when trimming', () => {\n+                const properties = {\n+                    url: 'https://example.com',\n+                    name: 'John Doe',\n+                    email: 'john@example.com',\n+                    description: 'A very long description that takes up a lot of space',\n+                    age: 30,\n+                }\n+                const targetSize = 50\n+                const protectedKeys = ['url']\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toHaveProperty('url', 'https://example.com')\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeLessThanOrEqual(targetSize)\n+            })\n+\n+            it('should handle empty properties object', () => {\n+                const properties = {}\n+                const targetSize = 50\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toEqual({})\n+            })\n+\n+            it('should handle case where even protected properties exceed size limit', () => {\n+                const properties = {\n+                    url: 'https://example.com/very/long/path/that/exceeds/our/tiny/size/limit/for/testing/purposes',\n+                    name: 'John',\n+                }\n+                const targetSize = 50\n+                const protectedKeys = ['url']\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toHaveProperty('url')\n+\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeGreaterThan(targetSize)\n+            })\n+\n+            it('should remove properties in order until size limit is met', () => {\n+                const properties = {\n+                    a: '1',\n+                    b: '2',\n+                    c: '3',\n+                    d: '4',\n+                    e: '5',\n+                }\n+                const targetSize = 20\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(Object.keys(result).length).toBeLessThan(Object.keys(properties).length)\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeLessThanOrEqual(targetSize)\n+            })\n+        })\n+\n+        describe('PersonPropertiesSizeViolationError', () => {\n+            it('should create error with correct properties', () => {\n+                const error = new PersonPropertiesSizeViolationError('Test message', 123, 'person-id', 'distinct-id')\n+\n+                expect(error.message).toBe('Test message')\n+                expect(error.teamId).toBe(123)\n+                expect(error.personId).toBe('person-id')\n+                expect(error.distinctId).toBe('distinct-id')\n+                expect(error.name).toBe('PersonPropertiesSizeViolationError')\n+            })\n+        })\n+\n+        describe('createPerson with oversized properties', () => {\n+            it('should throw PersonPropertiesSizeViolationError when properties exceed size limit', async () => {\n+                const team = await getFirstTeam(hub)\n+                const uuid = new UUIDT().toString()\n+                const oversizedProperties = {\n+                    description: 'x'.repeat(200),\n+                }\n+\n+                const originalQuery = postgres.query.bind(postgres)\n+                const mockQuery = jest.spyOn(postgres, 'query').mockImplementation(async (use, query, values, tag) => {\n+                    if (typeof query === 'string' && query.includes('INSERT INTO posthog_person')) {\n+                        const error = new Error('Check constraint violation')\n+                        ;(error as any).code = '23514'\n+                        ;(error as any).constraint = 'check_properties_size'\n+                        throw error\n+                    }\n+                    return originalQuery(use, query, values, tag)\n+                })\n+\n+                await expect(\n+                    oversizedRepository.createPerson(\n+                        TIMESTAMP,\n+                        oversizedProperties,\n+                        {},\n+                        {},\n+                        team.id,\n+                        null,\n+                        true,\n+                        uuid,\n+                        [{ distinctId: 'test-oversized' }]\n+                    )\n+                ).rejects.toThrow(PersonPropertiesSizeViolationError)\n+\n+                await expect(\n+                    oversizedRepository.createPerson(\n+                        TIMESTAMP,\n+                        oversizedProperties,\n+                        {},\n+                        {},\n+                        team.id,\n+                        null,\n+                        true,\n+                        uuid,\n+                        [{ distinctId: 'test-oversized-2' }]\n+                    )\n+                ).rejects.toThrow('Person properties create would exceed size limit')\n+\n+                mockQuery.mockRestore()\n+            })\n+        })\n+\n+        describe('updatePerson with oversized properties', () => {\n+            it('should trim existing oversized person properties and update successfully', async () => {",
    "repo_full_name": "PostHog/posthog",
    "discussion_comments": [
      {
        "comment_id": "2260660994",
        "repo_full_name": "PostHog/posthog",
        "pr_number": 35926,
        "pr_file": "plugin-server/src/worker/ingestion/persons/repositories/postgres-person-repository.test.ts",
        "discussion_id": "2260660994",
        "commented_code": "@@ -1128,6 +1135,512 @@ describe('PostgresPersonRepository', () => {\n         })\n     })\n \n+    describe('person properties size violation handling', () => {\n+        let oversizedRepository: PostgresPersonRepository\n+\n+        beforeEach(() => {\n+            oversizedRepository = new PostgresPersonRepository(postgres, {\n+                calculatePropertiesSize: 0,\n+                personPropertiesSizeLimit: 50,\n+            })\n+        })\n+\n+        describe('trimPropertiesToFitSize', () => {\n+            it('should return original properties if they are under the size limit', () => {\n+                const properties = { name: 'John', age: 30 }\n+                const targetSize = 1000\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toEqual(properties)\n+            })\n+\n+            it('should remove properties to fit under size limit', () => {\n+                const properties = {\n+                    name: 'John Doe',\n+                    email: 'john@example.com',\n+                    description: 'A very long description that takes up a lot of space',\n+                    age: 30,\n+                    city: 'New York',\n+                }\n+                const targetSize = 50\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(Object.keys(result).length).toBeLessThan(Object.keys(properties).length)\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeLessThanOrEqual(targetSize)\n+            })\n+\n+            it('should preserve protected properties even when trimming', () => {\n+                const properties = {\n+                    url: 'https://example.com',\n+                    name: 'John Doe',\n+                    email: 'john@example.com',\n+                    description: 'A very long description that takes up a lot of space',\n+                    age: 30,\n+                }\n+                const targetSize = 50\n+                const protectedKeys = ['url']\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toHaveProperty('url', 'https://example.com')\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeLessThanOrEqual(targetSize)\n+            })\n+\n+            it('should handle empty properties object', () => {\n+                const properties = {}\n+                const targetSize = 50\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toEqual({})\n+            })\n+\n+            it('should handle case where even protected properties exceed size limit', () => {\n+                const properties = {\n+                    url: 'https://example.com/very/long/path/that/exceeds/our/tiny/size/limit/for/testing/purposes',\n+                    name: 'John',\n+                }\n+                const targetSize = 50\n+                const protectedKeys = ['url']\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(result).toHaveProperty('url')\n+\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeGreaterThan(targetSize)\n+            })\n+\n+            it('should remove properties in order until size limit is met', () => {\n+                const properties = {\n+                    a: '1',\n+                    b: '2',\n+                    c: '3',\n+                    d: '4',\n+                    e: '5',\n+                }\n+                const targetSize = 20\n+                const protectedKeys: string[] = []\n+\n+                const result = (oversizedRepository as any).trimPropertiesToFitSize(\n+                    properties,\n+                    targetSize,\n+                    protectedKeys\n+                )\n+\n+                expect(Object.keys(result).length).toBeLessThan(Object.keys(properties).length)\n+                expect(Buffer.byteLength(JSON.stringify(result), 'utf8')).toBeLessThanOrEqual(targetSize)\n+            })\n+        })\n+\n+        describe('PersonPropertiesSizeViolationError', () => {\n+            it('should create error with correct properties', () => {\n+                const error = new PersonPropertiesSizeViolationError('Test message', 123, 'person-id', 'distinct-id')\n+\n+                expect(error.message).toBe('Test message')\n+                expect(error.teamId).toBe(123)\n+                expect(error.personId).toBe('person-id')\n+                expect(error.distinctId).toBe('distinct-id')\n+                expect(error.name).toBe('PersonPropertiesSizeViolationError')\n+            })\n+        })\n+\n+        describe('createPerson with oversized properties', () => {\n+            it('should throw PersonPropertiesSizeViolationError when properties exceed size limit', async () => {\n+                const team = await getFirstTeam(hub)\n+                const uuid = new UUIDT().toString()\n+                const oversizedProperties = {\n+                    description: 'x'.repeat(200),\n+                }\n+\n+                const originalQuery = postgres.query.bind(postgres)\n+                const mockQuery = jest.spyOn(postgres, 'query').mockImplementation(async (use, query, values, tag) => {\n+                    if (typeof query === 'string' && query.includes('INSERT INTO posthog_person')) {\n+                        const error = new Error('Check constraint violation')\n+                        ;(error as any).code = '23514'\n+                        ;(error as any).constraint = 'check_properties_size'\n+                        throw error\n+                    }\n+                    return originalQuery(use, query, values, tag)\n+                })\n+\n+                await expect(\n+                    oversizedRepository.createPerson(\n+                        TIMESTAMP,\n+                        oversizedProperties,\n+                        {},\n+                        {},\n+                        team.id,\n+                        null,\n+                        true,\n+                        uuid,\n+                        [{ distinctId: 'test-oversized' }]\n+                    )\n+                ).rejects.toThrow(PersonPropertiesSizeViolationError)\n+\n+                await expect(\n+                    oversizedRepository.createPerson(\n+                        TIMESTAMP,\n+                        oversizedProperties,\n+                        {},\n+                        {},\n+                        team.id,\n+                        null,\n+                        true,\n+                        uuid,\n+                        [{ distinctId: 'test-oversized-2' }]\n+                    )\n+                ).rejects.toThrow('Person properties create would exceed size limit')\n+\n+                mockQuery.mockRestore()\n+            })\n+        })\n+\n+        describe('updatePerson with oversized properties', () => {\n+            it('should trim existing oversized person properties and update successfully', async () => {",
        "comment_created_at": "2025-08-07T15:21:08+00:00",
        "comment_author": "pl",
        "comment_body": "suggestion: Would be great to have one more test at the `updatePerson` method level for updating a person whose stored properties can't be trimmed enough, i.e. the protected properties stored in the DB before the update exceed the limit. \n\nThere's potential for infinite loops in this scenario, so it would be great to have a test that covers this edge case.",
        "pr_file_module": null
      }
    ]
  }
]