[
  {
    "discussion_id": "997233305",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/print-whitespace.js",
    "created_at": "2022-10-17T15:47:28+00:00",
    "commented_code": "+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);\n+  const characterAfter = adjacentNodes.next.value[0];\n+\n+  // From here down, only line breaks between CJ and non-CJK characters are covered.\n+\n+  // Convert newline between CJ and specific symbol characters (e.g. ASCII punctuation)  to Space.\n+  // e.g. :::\n\u53e5\u5b50\u53e5\u5b50\u53e5\u5b50\n::: \u2192 ::: \u53e5\u5b50\u53e5\u5b50\u53e5\u5b50 :::\n+  //\n+  // Note: Line breaks like \"(\n\u53e5\u5b50\u53e5\u5b50\n)\" or \"\u53e5\u5b50\n.\" by Prettier are suppressed in `isBreakable(...)`.\n+  if (\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterAfter) ||\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterBefore)\n+  ) {\n+    return true;\n+  }\n+\n+  // Converting newline between CJ and non-ASCII punctuation to Space does not seem to be better in many cases. (PR welcome)\n+  // e.g.\n+  // 1. \u201c\u30a2\u301c\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\u201d\n+  // \"\u301c\" (U+301C) belongs to Pd, and \"\n\" in \"\u30a2\u301c\n\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\" must not be converted to Space.\n+  // 2. \u201c\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\u201d\n+  // \"\u2026\" (U+2026) belongs to Po, and \"\n\" in \"\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\n\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\" must not, either.\n+  if (\n+    adjacentNodes.previous.hasTrailingPunctuation ||\n+    adjacentNodes.next.hasLeadingPunctuation\n+  ) {\n+    return false;\n+  }\n+\n+  // If the sentence uses the style with spaces between CJ and alphanumerics, \"\n\" can be converted to Space.\n+  return isInSentenceWithCJSpaces(path);\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is CJK (including punctuation marks)\n+ */\n+function isCJK(kind) {\n+  return (\n+    kind === KIND_CJ_LETTER ||\n+    kind === KIND_K_LETTER ||\n+    kind === KIND_CJK_PUNCTUATION\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is letter (not CJK punctuation)\n+ */\n+function isLetter(kind) {\n+  return (\n+    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is western or Korean letters (divides words by Space)\n+ */\n+function isWesternOrKoreanLetter(kind) {\n+  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n+}\n+\n+/**\n+ * Returns whether \u201cwhitespace\u201d (`\"\" | \" \" | \"\n\"`; see `WhitespaceValue`) can be converted to `\"\n\"`\n+ *\n+ * @param {AstPath} path\n+ * @param {WhitespaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ * @returns {boolean | \"trueIfSpace\"} `true` if \u201cwhitespace\u201d can be converted to `\"\n\"`;\n+ * `trueIfSpace` means it can be converted only if `canBeConvertedToSpace` returns `true`\n+ */\n+function isBreakable(path, value, options, adjacentNodes) {\n+  if (\n+    options.proseWrap !== \"always\" ||\n+    getAncestorNode(path, SINGLE_LINE_NODE_TYPES)\n+  ) {\n+    return false;\n+  }\n+\n+  if (\n+    adjacentNodes === undefined ||\n+    // Space are always breakable\n+    value === \" \"\n+  ) {\n+    return true;\n+  }\n+\n+  // Simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  // [Latin][\"\"][Hangul] & vice versa => Don't break\n+  // [han & kana][\"\"][hangul], either\n+  if (\n+    value === \"\" &&\n+    ((adjacentNodes.previous?.kind === KIND_K_LETTER &&\n+      isLetter(adjacentNodes.next?.kind)) ||\n+      (adjacentNodes.next?.kind === KIND_K_LETTER &&\n+        isLetter(adjacentNodes.previous?.kind)))\n+  ) {\n+    return false;\n+  }\n+\n+  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+  const violatesCJKLineBreakingRule =\n+    (adjacentNodes.next !== undefined &&\n+      noBreakBefore.has(adjacentNodes.next.value[0])) ||\n+    (adjacentNodes.previous !== undefined &&\n+      noBreakAfter.has(adjacentNodes.previous.value.at(-1)));\n+\n+  // When violates the CJK line breaking rules if breaks lines there (\"\") or leaves surrounding lines divided (\"\n\")...\n+  // - \"\"   => always `false` (i.e. disallows to break lines there)\n+  // - \"\n\" => `true` (i.e. don't force surrounding lines to be joined) only when it should be converted to Space\n+  //           `false` (i.e. join surrounding lines into a single line) otherwise\n+  // The mandatory joining behavior when Space is not allowed is necessary because intentional violation of the line breaking rules (e.g. \u201c\u30eb\n\u30fc\u30eb\u5b88\u308c\n\uff01\u201d) tends to be \u201ccorrected\u201d (\"\n\" -> \"\") by formatted with a large value of `printWidth`.\n+  // Eventually, by reformatted with a smaller value of `printWidth` or because of a paragraph revision, the rules are going to be applied to the place that used to violate them.",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "997233305",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997233305",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);\n+  const characterAfter = adjacentNodes.next.value[0];\n+\n+  // From here down, only line breaks between CJ and non-CJK characters are covered.\n+\n+  // Convert newline between CJ and specific symbol characters (e.g. ASCII punctuation)  to Space.\n+  // e.g. :::\\n\u53e5\u5b50\u53e5\u5b50\u53e5\u5b50\\n::: \u2192 ::: \u53e5\u5b50\u53e5\u5b50\u53e5\u5b50 :::\n+  //\n+  // Note: Line breaks like \"(\\n\u53e5\u5b50\u53e5\u5b50\\n)\" or \"\u53e5\u5b50\\n.\" by Prettier are suppressed in `isBreakable(...)`.\n+  if (\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterAfter) ||\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterBefore)\n+  ) {\n+    return true;\n+  }\n+\n+  // Converting newline between CJ and non-ASCII punctuation to Space does not seem to be better in many cases. (PR welcome)\n+  // e.g.\n+  // 1. \u201c\u30a2\u301c\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\u201d\n+  // \"\u301c\" (U+301C) belongs to Pd, and \"\\n\" in \"\u30a2\u301c\\n\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\" must not be converted to Space.\n+  // 2. \u201c\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\u201d\n+  // \"\u2026\" (U+2026) belongs to Po, and \"\\n\" in \"\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\\n\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\" must not, either.\n+  if (\n+    adjacentNodes.previous.hasTrailingPunctuation ||\n+    adjacentNodes.next.hasLeadingPunctuation\n+  ) {\n+    return false;\n+  }\n+\n+  // If the sentence uses the style with spaces between CJ and alphanumerics, \"\\n\" can be converted to Space.\n+  return isInSentenceWithCJSpaces(path);\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is CJK (including punctuation marks)\n+ */\n+function isCJK(kind) {\n+  return (\n+    kind === KIND_CJ_LETTER ||\n+    kind === KIND_K_LETTER ||\n+    kind === KIND_CJK_PUNCTUATION\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is letter (not CJK punctuation)\n+ */\n+function isLetter(kind) {\n+  return (\n+    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is western or Korean letters (divides words by Space)\n+ */\n+function isWesternOrKoreanLetter(kind) {\n+  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n+}\n+\n+/**\n+ * Returns whether \u201cwhitespace\u201d (`\"\" | \" \" | \"\\n\"`; see `WhitespaceValue`) can be converted to `\"\\n\"`\n+ *\n+ * @param {AstPath} path\n+ * @param {WhitespaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ * @returns {boolean | \"trueIfSpace\"} `true` if \u201cwhitespace\u201d can be converted to `\"\\n\"`;\n+ * `trueIfSpace` means it can be converted only if `canBeConvertedToSpace` returns `true`\n+ */\n+function isBreakable(path, value, options, adjacentNodes) {\n+  if (\n+    options.proseWrap !== \"always\" ||\n+    getAncestorNode(path, SINGLE_LINE_NODE_TYPES)\n+  ) {\n+    return false;\n+  }\n+\n+  if (\n+    adjacentNodes === undefined ||\n+    // Space are always breakable\n+    value === \" \"\n+  ) {\n+    return true;\n+  }\n+\n+  // Simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  // [Latin][\"\"][Hangul] & vice versa => Don't break\n+  // [han & kana][\"\"][hangul], either\n+  if (\n+    value === \"\" &&\n+    ((adjacentNodes.previous?.kind === KIND_K_LETTER &&\n+      isLetter(adjacentNodes.next?.kind)) ||\n+      (adjacentNodes.next?.kind === KIND_K_LETTER &&\n+        isLetter(adjacentNodes.previous?.kind)))\n+  ) {\n+    return false;\n+  }\n+\n+  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+  const violatesCJKLineBreakingRule =\n+    (adjacentNodes.next !== undefined &&\n+      noBreakBefore.has(adjacentNodes.next.value[0])) ||\n+    (adjacentNodes.previous !== undefined &&\n+      noBreakAfter.has(adjacentNodes.previous.value.at(-1)));\n+\n+  // When violates the CJK line breaking rules if breaks lines there (\"\") or leaves surrounding lines divided (\"\\n\")...\n+  // - \"\"   => always `false` (i.e. disallows to break lines there)\n+  // - \"\\n\" => `true` (i.e. don't force surrounding lines to be joined) only when it should be converted to Space\n+  //           `false` (i.e. join surrounding lines into a single line) otherwise\n+  // The mandatory joining behavior when Space is not allowed is necessary because intentional violation of the line breaking rules (e.g. \u201c\u30eb\\n\u30fc\u30eb\u5b88\u308c\\n\uff01\u201d) tends to be \u201ccorrected\u201d (\"\\n\" -> \"\") by formatted with a large value of `printWidth`.\n+  // Eventually, by reformatted with a smaller value of `printWidth` or because of a paragraph revision, the rules are going to be applied to the place that used to violate them.",
        "comment_created_at": "2022-10-17T15:47:28+00:00",
        "comment_author": "thorn0",
        "comment_body": "I thought we got rid of this eventual reformatting and the rules are always applied. Am I wrong?",
        "pr_file_module": null
      },
      {
        "comment_id": "997599219",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997233305",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);\n+  const characterAfter = adjacentNodes.next.value[0];\n+\n+  // From here down, only line breaks between CJ and non-CJK characters are covered.\n+\n+  // Convert newline between CJ and specific symbol characters (e.g. ASCII punctuation)  to Space.\n+  // e.g. :::\\n\u53e5\u5b50\u53e5\u5b50\u53e5\u5b50\\n::: \u2192 ::: \u53e5\u5b50\u53e5\u5b50\u53e5\u5b50 :::\n+  //\n+  // Note: Line breaks like \"(\\n\u53e5\u5b50\u53e5\u5b50\\n)\" or \"\u53e5\u5b50\\n.\" by Prettier are suppressed in `isBreakable(...)`.\n+  if (\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterAfter) ||\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterBefore)\n+  ) {\n+    return true;\n+  }\n+\n+  // Converting newline between CJ and non-ASCII punctuation to Space does not seem to be better in many cases. (PR welcome)\n+  // e.g.\n+  // 1. \u201c\u30a2\u301c\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\u201d\n+  // \"\u301c\" (U+301C) belongs to Pd, and \"\\n\" in \"\u30a2\u301c\\n\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\" must not be converted to Space.\n+  // 2. \u201c\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\u201d\n+  // \"\u2026\" (U+2026) belongs to Po, and \"\\n\" in \"\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\\n\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\" must not, either.\n+  if (\n+    adjacentNodes.previous.hasTrailingPunctuation ||\n+    adjacentNodes.next.hasLeadingPunctuation\n+  ) {\n+    return false;\n+  }\n+\n+  // If the sentence uses the style with spaces between CJ and alphanumerics, \"\\n\" can be converted to Space.\n+  return isInSentenceWithCJSpaces(path);\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is CJK (including punctuation marks)\n+ */\n+function isCJK(kind) {\n+  return (\n+    kind === KIND_CJ_LETTER ||\n+    kind === KIND_K_LETTER ||\n+    kind === KIND_CJK_PUNCTUATION\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is letter (not CJK punctuation)\n+ */\n+function isLetter(kind) {\n+  return (\n+    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is western or Korean letters (divides words by Space)\n+ */\n+function isWesternOrKoreanLetter(kind) {\n+  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n+}\n+\n+/**\n+ * Returns whether \u201cwhitespace\u201d (`\"\" | \" \" | \"\\n\"`; see `WhitespaceValue`) can be converted to `\"\\n\"`\n+ *\n+ * @param {AstPath} path\n+ * @param {WhitespaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ * @returns {boolean | \"trueIfSpace\"} `true` if \u201cwhitespace\u201d can be converted to `\"\\n\"`;\n+ * `trueIfSpace` means it can be converted only if `canBeConvertedToSpace` returns `true`\n+ */\n+function isBreakable(path, value, options, adjacentNodes) {\n+  if (\n+    options.proseWrap !== \"always\" ||\n+    getAncestorNode(path, SINGLE_LINE_NODE_TYPES)\n+  ) {\n+    return false;\n+  }\n+\n+  if (\n+    adjacentNodes === undefined ||\n+    // Space are always breakable\n+    value === \" \"\n+  ) {\n+    return true;\n+  }\n+\n+  // Simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  // [Latin][\"\"][Hangul] & vice versa => Don't break\n+  // [han & kana][\"\"][hangul], either\n+  if (\n+    value === \"\" &&\n+    ((adjacentNodes.previous?.kind === KIND_K_LETTER &&\n+      isLetter(adjacentNodes.next?.kind)) ||\n+      (adjacentNodes.next?.kind === KIND_K_LETTER &&\n+        isLetter(adjacentNodes.previous?.kind)))\n+  ) {\n+    return false;\n+  }\n+\n+  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+  const violatesCJKLineBreakingRule =\n+    (adjacentNodes.next !== undefined &&\n+      noBreakBefore.has(adjacentNodes.next.value[0])) ||\n+    (adjacentNodes.previous !== undefined &&\n+      noBreakAfter.has(adjacentNodes.previous.value.at(-1)));\n+\n+  // When violates the CJK line breaking rules if breaks lines there (\"\") or leaves surrounding lines divided (\"\\n\")...\n+  // - \"\"   => always `false` (i.e. disallows to break lines there)\n+  // - \"\\n\" => `true` (i.e. don't force surrounding lines to be joined) only when it should be converted to Space\n+  //           `false` (i.e. join surrounding lines into a single line) otherwise\n+  // The mandatory joining behavior when Space is not allowed is necessary because intentional violation of the line breaking rules (e.g. \u201c\u30eb\\n\u30fc\u30eb\u5b88\u308c\\n\uff01\u201d) tends to be \u201ccorrected\u201d (\"\\n\" -> \"\") by formatted with a large value of `printWidth`.\n+  // Eventually, by reformatted with a smaller value of `printWidth` or because of a paragraph revision, the rules are going to be applied to the place that used to violate them.",
        "comment_created_at": "2022-10-17T23:54:16+00:00",
        "comment_author": "tats-u",
        "comment_body": "This describes why it is needed to correct intentional violations, and what happens and why you will need this feature when it is not implemented. It is better to improve the description though.",
        "pr_file_module": null
      },
      {
        "comment_id": "997885983",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997233305",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);\n+  const characterAfter = adjacentNodes.next.value[0];\n+\n+  // From here down, only line breaks between CJ and non-CJK characters are covered.\n+\n+  // Convert newline between CJ and specific symbol characters (e.g. ASCII punctuation)  to Space.\n+  // e.g. :::\\n\u53e5\u5b50\u53e5\u5b50\u53e5\u5b50\\n::: \u2192 ::: \u53e5\u5b50\u53e5\u5b50\u53e5\u5b50 :::\n+  //\n+  // Note: Line breaks like \"(\\n\u53e5\u5b50\u53e5\u5b50\\n)\" or \"\u53e5\u5b50\\n.\" by Prettier are suppressed in `isBreakable(...)`.\n+  if (\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterAfter) ||\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterBefore)\n+  ) {\n+    return true;\n+  }\n+\n+  // Converting newline between CJ and non-ASCII punctuation to Space does not seem to be better in many cases. (PR welcome)\n+  // e.g.\n+  // 1. \u201c\u30a2\u301c\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\u201d\n+  // \"\u301c\" (U+301C) belongs to Pd, and \"\\n\" in \"\u30a2\u301c\\n\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\" must not be converted to Space.\n+  // 2. \u201c\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\u201d\n+  // \"\u2026\" (U+2026) belongs to Po, and \"\\n\" in \"\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\\n\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\" must not, either.\n+  if (\n+    adjacentNodes.previous.hasTrailingPunctuation ||\n+    adjacentNodes.next.hasLeadingPunctuation\n+  ) {\n+    return false;\n+  }\n+\n+  // If the sentence uses the style with spaces between CJ and alphanumerics, \"\\n\" can be converted to Space.\n+  return isInSentenceWithCJSpaces(path);\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is CJK (including punctuation marks)\n+ */\n+function isCJK(kind) {\n+  return (\n+    kind === KIND_CJ_LETTER ||\n+    kind === KIND_K_LETTER ||\n+    kind === KIND_CJK_PUNCTUATION\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is letter (not CJK punctuation)\n+ */\n+function isLetter(kind) {\n+  return (\n+    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is western or Korean letters (divides words by Space)\n+ */\n+function isWesternOrKoreanLetter(kind) {\n+  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n+}\n+\n+/**\n+ * Returns whether \u201cwhitespace\u201d (`\"\" | \" \" | \"\\n\"`; see `WhitespaceValue`) can be converted to `\"\\n\"`\n+ *\n+ * @param {AstPath} path\n+ * @param {WhitespaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ * @returns {boolean | \"trueIfSpace\"} `true` if \u201cwhitespace\u201d can be converted to `\"\\n\"`;\n+ * `trueIfSpace` means it can be converted only if `canBeConvertedToSpace` returns `true`\n+ */\n+function isBreakable(path, value, options, adjacentNodes) {\n+  if (\n+    options.proseWrap !== \"always\" ||\n+    getAncestorNode(path, SINGLE_LINE_NODE_TYPES)\n+  ) {\n+    return false;\n+  }\n+\n+  if (\n+    adjacentNodes === undefined ||\n+    // Space are always breakable\n+    value === \" \"\n+  ) {\n+    return true;\n+  }\n+\n+  // Simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  // [Latin][\"\"][Hangul] & vice versa => Don't break\n+  // [han & kana][\"\"][hangul], either\n+  if (\n+    value === \"\" &&\n+    ((adjacentNodes.previous?.kind === KIND_K_LETTER &&\n+      isLetter(adjacentNodes.next?.kind)) ||\n+      (adjacentNodes.next?.kind === KIND_K_LETTER &&\n+        isLetter(adjacentNodes.previous?.kind)))\n+  ) {\n+    return false;\n+  }\n+\n+  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+  const violatesCJKLineBreakingRule =\n+    (adjacentNodes.next !== undefined &&\n+      noBreakBefore.has(adjacentNodes.next.value[0])) ||\n+    (adjacentNodes.previous !== undefined &&\n+      noBreakAfter.has(adjacentNodes.previous.value.at(-1)));\n+\n+  // When violates the CJK line breaking rules if breaks lines there (\"\") or leaves surrounding lines divided (\"\\n\")...\n+  // - \"\"   => always `false` (i.e. disallows to break lines there)\n+  // - \"\\n\" => `true` (i.e. don't force surrounding lines to be joined) only when it should be converted to Space\n+  //           `false` (i.e. join surrounding lines into a single line) otherwise\n+  // The mandatory joining behavior when Space is not allowed is necessary because intentional violation of the line breaking rules (e.g. \u201c\u30eb\\n\u30fc\u30eb\u5b88\u308c\\n\uff01\u201d) tends to be \u201ccorrected\u201d (\"\\n\" -> \"\") by formatted with a large value of `printWidth`.\n+  // Eventually, by reformatted with a smaller value of `printWidth` or because of a paragraph revision, the rules are going to be applied to the place that used to violate them.",
        "comment_created_at": "2022-10-18T08:26:34+00:00",
        "comment_author": "thorn0",
        "comment_body": "I'm afraid this explanation is more confusing than helpful. Let's just remove it. The code doesn't look like it needs an explanation.",
        "pr_file_module": null
      },
      {
        "comment_id": "998365109",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997233305",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);\n+  const characterAfter = adjacentNodes.next.value[0];\n+\n+  // From here down, only line breaks between CJ and non-CJK characters are covered.\n+\n+  // Convert newline between CJ and specific symbol characters (e.g. ASCII punctuation)  to Space.\n+  // e.g. :::\\n\u53e5\u5b50\u53e5\u5b50\u53e5\u5b50\\n::: \u2192 ::: \u53e5\u5b50\u53e5\u5b50\u53e5\u5b50 :::\n+  //\n+  // Note: Line breaks like \"(\\n\u53e5\u5b50\u53e5\u5b50\\n)\" or \"\u53e5\u5b50\\n.\" by Prettier are suppressed in `isBreakable(...)`.\n+  if (\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterAfter) ||\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterBefore)\n+  ) {\n+    return true;\n+  }\n+\n+  // Converting newline between CJ and non-ASCII punctuation to Space does not seem to be better in many cases. (PR welcome)\n+  // e.g.\n+  // 1. \u201c\u30a2\u301c\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\u201d\n+  // \"\u301c\" (U+301C) belongs to Pd, and \"\\n\" in \"\u30a2\u301c\\n\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\" must not be converted to Space.\n+  // 2. \u201c\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\u201d\n+  // \"\u2026\" (U+2026) belongs to Po, and \"\\n\" in \"\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\\n\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\" must not, either.\n+  if (\n+    adjacentNodes.previous.hasTrailingPunctuation ||\n+    adjacentNodes.next.hasLeadingPunctuation\n+  ) {\n+    return false;\n+  }\n+\n+  // If the sentence uses the style with spaces between CJ and alphanumerics, \"\\n\" can be converted to Space.\n+  return isInSentenceWithCJSpaces(path);\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is CJK (including punctuation marks)\n+ */\n+function isCJK(kind) {\n+  return (\n+    kind === KIND_CJ_LETTER ||\n+    kind === KIND_K_LETTER ||\n+    kind === KIND_CJK_PUNCTUATION\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is letter (not CJK punctuation)\n+ */\n+function isLetter(kind) {\n+  return (\n+    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is western or Korean letters (divides words by Space)\n+ */\n+function isWesternOrKoreanLetter(kind) {\n+  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n+}\n+\n+/**\n+ * Returns whether \u201cwhitespace\u201d (`\"\" | \" \" | \"\\n\"`; see `WhitespaceValue`) can be converted to `\"\\n\"`\n+ *\n+ * @param {AstPath} path\n+ * @param {WhitespaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ * @returns {boolean | \"trueIfSpace\"} `true` if \u201cwhitespace\u201d can be converted to `\"\\n\"`;\n+ * `trueIfSpace` means it can be converted only if `canBeConvertedToSpace` returns `true`\n+ */\n+function isBreakable(path, value, options, adjacentNodes) {\n+  if (\n+    options.proseWrap !== \"always\" ||\n+    getAncestorNode(path, SINGLE_LINE_NODE_TYPES)\n+  ) {\n+    return false;\n+  }\n+\n+  if (\n+    adjacentNodes === undefined ||\n+    // Space are always breakable\n+    value === \" \"\n+  ) {\n+    return true;\n+  }\n+\n+  // Simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  // [Latin][\"\"][Hangul] & vice versa => Don't break\n+  // [han & kana][\"\"][hangul], either\n+  if (\n+    value === \"\" &&\n+    ((adjacentNodes.previous?.kind === KIND_K_LETTER &&\n+      isLetter(adjacentNodes.next?.kind)) ||\n+      (adjacentNodes.next?.kind === KIND_K_LETTER &&\n+        isLetter(adjacentNodes.previous?.kind)))\n+  ) {\n+    return false;\n+  }\n+\n+  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+  const violatesCJKLineBreakingRule =\n+    (adjacentNodes.next !== undefined &&\n+      noBreakBefore.has(adjacentNodes.next.value[0])) ||\n+    (adjacentNodes.previous !== undefined &&\n+      noBreakAfter.has(adjacentNodes.previous.value.at(-1)));\n+\n+  // When violates the CJK line breaking rules if breaks lines there (\"\") or leaves surrounding lines divided (\"\\n\")...\n+  // - \"\"   => always `false` (i.e. disallows to break lines there)\n+  // - \"\\n\" => `true` (i.e. don't force surrounding lines to be joined) only when it should be converted to Space\n+  //           `false` (i.e. join surrounding lines into a single line) otherwise\n+  // The mandatory joining behavior when Space is not allowed is necessary because intentional violation of the line breaking rules (e.g. \u201c\u30eb\\n\u30fc\u30eb\u5b88\u308c\\n\uff01\u201d) tends to be \u201ccorrected\u201d (\"\\n\" -> \"\") by formatted with a large value of `printWidth`.\n+  // Eventually, by reformatted with a smaller value of `printWidth` or because of a paragraph revision, the rules are going to be applied to the place that used to violate them.",
        "comment_created_at": "2022-10-18T15:06:28+00:00",
        "comment_author": "tats-u",
        "comment_body": "I decided to delete it and improve surrounding lines. How about this?",
        "pr_file_module": null
      },
      {
        "comment_id": "998409257",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997233305",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);\n+  const characterAfter = adjacentNodes.next.value[0];\n+\n+  // From here down, only line breaks between CJ and non-CJK characters are covered.\n+\n+  // Convert newline between CJ and specific symbol characters (e.g. ASCII punctuation)  to Space.\n+  // e.g. :::\\n\u53e5\u5b50\u53e5\u5b50\u53e5\u5b50\\n::: \u2192 ::: \u53e5\u5b50\u53e5\u5b50\u53e5\u5b50 :::\n+  //\n+  // Note: Line breaks like \"(\\n\u53e5\u5b50\u53e5\u5b50\\n)\" or \"\u53e5\u5b50\\n.\" by Prettier are suppressed in `isBreakable(...)`.\n+  if (\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterAfter) ||\n+    lineBreakBetweenTheseAndCJKConvertsToSpace.has(characterBefore)\n+  ) {\n+    return true;\n+  }\n+\n+  // Converting newline between CJ and non-ASCII punctuation to Space does not seem to be better in many cases. (PR welcome)\n+  // e.g.\n+  // 1. \u201c\u30a2\u301c\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\u201d\n+  // \"\u301c\" (U+301C) belongs to Pd, and \"\\n\" in \"\u30a2\u301c\\n\u30a8\u306e\u4e2d\u304b\u30891\u3064\u9078\u3079\u3002\" must not be converted to Space.\n+  // 2. \u201c\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\u201d\n+  // \"\u2026\" (U+2026) belongs to Po, and \"\\n\" in \"\u3053\u308c\u306f\u3072\u3069\u3044\u2026\u2026\\n\u306a\u3093\u3068\u6c5a\u3044\u30b3\u30df\u30c3\u30c8\u30ed\u30b0\u306a\u3093\u3060\u2026\u2026\" must not, either.\n+  if (\n+    adjacentNodes.previous.hasTrailingPunctuation ||\n+    adjacentNodes.next.hasLeadingPunctuation\n+  ) {\n+    return false;\n+  }\n+\n+  // If the sentence uses the style with spaces between CJ and alphanumerics, \"\\n\" can be converted to Space.\n+  return isInSentenceWithCJSpaces(path);\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is CJK (including punctuation marks)\n+ */\n+function isCJK(kind) {\n+  return (\n+    kind === KIND_CJ_LETTER ||\n+    kind === KIND_K_LETTER ||\n+    kind === KIND_CJK_PUNCTUATION\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is letter (not CJK punctuation)\n+ */\n+function isLetter(kind) {\n+  return (\n+    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n+  );\n+}\n+\n+/**\n+ * @param {WordKind | undefined} kind\n+ * @returns {boolean} `true` if `kind` is western or Korean letters (divides words by Space)\n+ */\n+function isWesternOrKoreanLetter(kind) {\n+  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n+}\n+\n+/**\n+ * Returns whether \u201cwhitespace\u201d (`\"\" | \" \" | \"\\n\"`; see `WhitespaceValue`) can be converted to `\"\\n\"`\n+ *\n+ * @param {AstPath} path\n+ * @param {WhitespaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ * @returns {boolean | \"trueIfSpace\"} `true` if \u201cwhitespace\u201d can be converted to `\"\\n\"`;\n+ * `trueIfSpace` means it can be converted only if `canBeConvertedToSpace` returns `true`\n+ */\n+function isBreakable(path, value, options, adjacentNodes) {\n+  if (\n+    options.proseWrap !== \"always\" ||\n+    getAncestorNode(path, SINGLE_LINE_NODE_TYPES)\n+  ) {\n+    return false;\n+  }\n+\n+  if (\n+    adjacentNodes === undefined ||\n+    // Space are always breakable\n+    value === \" \"\n+  ) {\n+    return true;\n+  }\n+\n+  // Simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  // [Latin][\"\"][Hangul] & vice versa => Don't break\n+  // [han & kana][\"\"][hangul], either\n+  if (\n+    value === \"\" &&\n+    ((adjacentNodes.previous?.kind === KIND_K_LETTER &&\n+      isLetter(adjacentNodes.next?.kind)) ||\n+      (adjacentNodes.next?.kind === KIND_K_LETTER &&\n+        isLetter(adjacentNodes.previous?.kind)))\n+  ) {\n+    return false;\n+  }\n+\n+  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+  const violatesCJKLineBreakingRule =\n+    (adjacentNodes.next !== undefined &&\n+      noBreakBefore.has(adjacentNodes.next.value[0])) ||\n+    (adjacentNodes.previous !== undefined &&\n+      noBreakAfter.has(adjacentNodes.previous.value.at(-1)));\n+\n+  // When violates the CJK line breaking rules if breaks lines there (\"\") or leaves surrounding lines divided (\"\\n\")...\n+  // - \"\"   => always `false` (i.e. disallows to break lines there)\n+  // - \"\\n\" => `true` (i.e. don't force surrounding lines to be joined) only when it should be converted to Space\n+  //           `false` (i.e. join surrounding lines into a single line) otherwise\n+  // The mandatory joining behavior when Space is not allowed is necessary because intentional violation of the line breaking rules (e.g. \u201c\u30eb\\n\u30fc\u30eb\u5b88\u308c\\n\uff01\u201d) tends to be \u201ccorrected\u201d (\"\\n\" -> \"\") by formatted with a large value of `printWidth`.\n+  // Eventually, by reformatted with a smaller value of `printWidth` or because of a paragraph revision, the rules are going to be applied to the place that used to violate them.",
        "comment_created_at": "2022-10-18T15:39:38+00:00",
        "comment_author": "thorn0",
        "comment_body": "I think the comments aren't needed there at all (the link to Wikipedia should stay though). The code looks simple enough: don't break if the rules are violated and this whitespace node is not a (potential) space.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1389085380",
    "pr_number": 15606,
    "pr_file": "src/language-html/clean.js",
    "created_at": "2023-11-10T08:44:28+00:00",
    "commented_code": "if (ast.type === \"docType\") {\n     delete newNode.value;\n   }\n+\n+  if (ast.type === \"block\") {\n+    const isEmbed = [\"if\", \"else if\", \"for\", \"switch\", \"case\"].includes(",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1389085380",
        "repo_full_name": "prettier/prettier",
        "pr_number": 15606,
        "pr_file": "src/language-html/clean.js",
        "discussion_id": "1389085380",
        "commented_code": "@@ -29,6 +29,19 @@ function clean(ast, newNode) {\n   if (ast.type === \"docType\") {\n     delete newNode.value;\n   }\n+\n+  if (ast.type === \"block\") {\n+    const isEmbed = [\"if\", \"else if\", \"for\", \"switch\", \"case\"].includes(",
        "comment_created_at": "2023-11-10T08:44:28+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "Can we add comment  like `// Block names that can have parameters` ?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1008785940",
    "pr_number": 13735,
    "pr_file": "src/language-js/needs-parens.js",
    "created_at": "2022-10-30T03:24:39+00:00",
    "commented_code": "// fallthrough\n     case \"CallExpression\":\n     case \"MemberExpression\":\n+      if (\n+        path.match(\n+          () =>\n+            node.type === \"CallExpression\" || node.type === \"MemberExpression\",\n+          (node, name) =>\n+            name === \"expression\" && node.type === \"ChainExpression\"\n+        ) &&\n+        (path.match(\n+          undefined,\n+          undefined,\n+          (node, name) =>\n+            (name === \"callee\" &&\n+              ((node.type === \"CallExpression\" && !node.optional) ||\n+                node.type === \"NewExpression\")) ||\n+            (name === \"object\" &&\n+              node.type === \"MemberExpression\" &&\n+              !node.optional)\n+        ) ||\n+          path.match(\n+            undefined,\n+            undefined,\n+            (node, name) =>\n+              name === \"expression\" && node.type === \"TSNonNullExpression\",\n+            (node, name) =>\n+              name === \"object\" && node.type === \"MemberExpression\"\n+          ))",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1008785940",
        "repo_full_name": "prettier/prettier",
        "pr_number": 13735,
        "pr_file": "src/language-js/needs-parens.js",
        "discussion_id": "1008785940",
        "commented_code": "@@ -687,6 +687,37 @@ function needsParens(path, options) {\n     // fallthrough\n     case \"CallExpression\":\n     case \"MemberExpression\":\n+      if (\n+        path.match(\n+          () =>\n+            node.type === \"CallExpression\" || node.type === \"MemberExpression\",\n+          (node, name) =>\n+            name === \"expression\" && node.type === \"ChainExpression\"\n+        ) &&\n+        (path.match(\n+          undefined,\n+          undefined,\n+          (node, name) =>\n+            (name === \"callee\" &&\n+              ((node.type === \"CallExpression\" && !node.optional) ||\n+                node.type === \"NewExpression\")) ||\n+            (name === \"object\" &&\n+              node.type === \"MemberExpression\" &&\n+              !node.optional)\n+        ) ||\n+          path.match(\n+            undefined,\n+            undefined,\n+            (node, name) =>\n+              name === \"expression\" && node.type === \"TSNonNullExpression\",\n+            (node, name) =>\n+              name === \"object\" && node.type === \"MemberExpression\"\n+          ))",
        "comment_created_at": "2022-10-30T03:24:39+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "It seems unreadable to me... Can you add comment or extract these conditions to variables?",
        "pr_file_module": null
      },
      {
        "comment_id": "1011084494",
        "repo_full_name": "prettier/prettier",
        "pr_number": 13735,
        "pr_file": "src/language-js/needs-parens.js",
        "discussion_id": "1008785940",
        "commented_code": "@@ -687,6 +687,37 @@ function needsParens(path, options) {\n     // fallthrough\n     case \"CallExpression\":\n     case \"MemberExpression\":\n+      if (\n+        path.match(\n+          () =>\n+            node.type === \"CallExpression\" || node.type === \"MemberExpression\",\n+          (node, name) =>\n+            name === \"expression\" && node.type === \"ChainExpression\"\n+        ) &&\n+        (path.match(\n+          undefined,\n+          undefined,\n+          (node, name) =>\n+            (name === \"callee\" &&\n+              ((node.type === \"CallExpression\" && !node.optional) ||\n+                node.type === \"NewExpression\")) ||\n+            (name === \"object\" &&\n+              node.type === \"MemberExpression\" &&\n+              !node.optional)\n+        ) ||\n+          path.match(\n+            undefined,\n+            undefined,\n+            (node, name) =>\n+              name === \"expression\" && node.type === \"TSNonNullExpression\",\n+            (node, name) =>\n+              name === \"object\" && node.type === \"MemberExpression\"\n+          ))",
        "comment_created_at": "2022-11-02T02:17:43+00:00",
        "comment_author": "fisker",
        "comment_body": "What kind of comment do you expect? Similar code exists\r\n\r\nhttps://github.com/prettier/prettier/blob/67e121a20b9d5d983970bdc2dcba5de2bd0f7beb/src/language-js/print/function-parameters.js#L246\r\nhttps://github.com/prettier/prettier/blob/67e121a20b9d5d983970bdc2dcba5de2bd0f7beb/src/language-js/print/object.js#L200",
        "pr_file_module": null
      },
      {
        "comment_id": "1012057833",
        "repo_full_name": "prettier/prettier",
        "pr_number": 13735,
        "pr_file": "src/language-js/needs-parens.js",
        "discussion_id": "1008785940",
        "commented_code": "@@ -687,6 +687,37 @@ function needsParens(path, options) {\n     // fallthrough\n     case \"CallExpression\":\n     case \"MemberExpression\":\n+      if (\n+        path.match(\n+          () =>\n+            node.type === \"CallExpression\" || node.type === \"MemberExpression\",\n+          (node, name) =>\n+            name === \"expression\" && node.type === \"ChainExpression\"\n+        ) &&\n+        (path.match(\n+          undefined,\n+          undefined,\n+          (node, name) =>\n+            (name === \"callee\" &&\n+              ((node.type === \"CallExpression\" && !node.optional) ||\n+                node.type === \"NewExpression\")) ||\n+            (name === \"object\" &&\n+              node.type === \"MemberExpression\" &&\n+              !node.optional)\n+        ) ||\n+          path.match(\n+            undefined,\n+            undefined,\n+            (node, name) =>\n+              name === \"expression\" && node.type === \"TSNonNullExpression\",\n+            (node, name) =>\n+              name === \"object\" && node.type === \"MemberExpression\"\n+          ))",
        "comment_created_at": "2022-11-02T16:57:20+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "I expect comments that describes what concrete syntax each matcher represents.",
        "pr_file_module": null
      },
      {
        "comment_id": "1090131817",
        "repo_full_name": "prettier/prettier",
        "pr_number": 13735,
        "pr_file": "src/language-js/needs-parens.js",
        "discussion_id": "1008785940",
        "commented_code": "@@ -687,6 +687,37 @@ function needsParens(path, options) {\n     // fallthrough\n     case \"CallExpression\":\n     case \"MemberExpression\":\n+      if (\n+        path.match(\n+          () =>\n+            node.type === \"CallExpression\" || node.type === \"MemberExpression\",\n+          (node, name) =>\n+            name === \"expression\" && node.type === \"ChainExpression\"\n+        ) &&\n+        (path.match(\n+          undefined,\n+          undefined,\n+          (node, name) =>\n+            (name === \"callee\" &&\n+              ((node.type === \"CallExpression\" && !node.optional) ||\n+                node.type === \"NewExpression\")) ||\n+            (name === \"object\" &&\n+              node.type === \"MemberExpression\" &&\n+              !node.optional)\n+        ) ||\n+          path.match(\n+            undefined,\n+            undefined,\n+            (node, name) =>\n+              name === \"expression\" && node.type === \"TSNonNullExpression\",\n+            (node, name) =>\n+              name === \"object\" && node.type === \"MemberExpression\"\n+          ))",
        "comment_created_at": "2023-01-30T02:47:23+00:00",
        "comment_author": "fisker",
        "comment_body": "[`e849c94`](https://github.com/prettier/prettier/pull/13735/commits/e849c94bbf45d4ceb502402fadf2ea425b5e4dc1)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "862413092",
    "pr_number": 12707,
    "pr_file": "src/language-html/utils/index.js",
    "created_at": "2022-05-01T01:54:50+00:00",
    "commented_code": "if (lang === \"less\") {\n     return \"less\";\n   }\n+\n+  if (lang === \"stylus\") {\n+    return inferParserByLanguage(\"stylus\", options);\n+  }",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "862413092",
        "repo_full_name": "prettier/prettier",
        "pr_number": 12707,
        "pr_file": "src/language-html/utils/index.js",
        "discussion_id": "862413092",
        "commented_code": "@@ -386,6 +386,10 @@ function inferStyleParser(node) {\n   if (lang === \"less\") {\n     return \"less\";\n   }\n+\n+  if (lang === \"stylus\") {\n+    return inferParserByLanguage(\"stylus\", options);\n+  }",
        "comment_created_at": "2022-05-01T01:54:50+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "Can you add a comment that explains why `\"stylus\"` is here? e.g.:\r\n\r\n```suggestion\r\n  // Prettier does not officially support stylus.\r\n  // But, we need to handle `\"stylus\"` here for printing a style block in Vue SFC as stylus code by external plugin.\r\n  // https://github.com/prettier/prettier/pull/12707\r\n  if (lang === \"stylus\") {\r\n    return inferParserByLanguage(\"stylus\", options);\r\n  }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "862418222",
        "repo_full_name": "prettier/prettier",
        "pr_number": 12707,
        "pr_file": "src/language-html/utils/index.js",
        "discussion_id": "862413092",
        "commented_code": "@@ -386,6 +386,10 @@ function inferStyleParser(node) {\n   if (lang === \"less\") {\n     return \"less\";\n   }\n+\n+  if (lang === \"stylus\") {\n+    return inferParserByLanguage(\"stylus\", options);\n+  }",
        "comment_created_at": "2022-05-01T03:31:18+00:00",
        "comment_author": "lsdsjy",
        "comment_body": "Makes Sense. Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1059483698",
    "pr_number": 14089,
    "pr_file": "src/language-css/printer-postcss.js",
    "created_at": "2022-12-30T18:13:51+00:00",
    "commented_code": "continue;\n         }\n \n+        if (isMapItemNode) {\n+          const isPartOfValue =\n+            node.groups?.[1]?.type === \"value-colon\" && i > 1;\n+          if (",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1059483698",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14089,
        "pr_file": "src/language-css/printer-postcss.js",
        "discussion_id": "1059483698",
        "commented_code": "@@ -853,6 +856,20 @@ function genericPrint(path, options, print) {\n           continue;\n         }\n \n+        if (isMapItemNode) {\n+          const isPartOfValue =\n+            node.groups?.[1]?.type === \"value-colon\" && i > 1;\n+          if (",
        "comment_created_at": "2022-12-30T18:13:51+00:00",
        "comment_author": "fisker",
        "comment_body": "Can you add an example here to show what this condition supposed to match?",
        "pr_file_module": null
      },
      {
        "comment_id": "1059512974",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14089,
        "pr_file": "src/language-css/printer-postcss.js",
        "discussion_id": "1059483698",
        "commented_code": "@@ -853,6 +856,20 @@ function genericPrint(path, options, print) {\n           continue;\n         }\n \n+        if (isMapItemNode) {\n+          const isPartOfValue =\n+            node.groups?.[1]?.type === \"value-colon\" && i > 1;\n+          if (",
        "comment_created_at": "2022-12-30T20:30:14+00:00",
        "comment_author": "fisker",
        "comment_body": "Actually, I mean example for the code in this condition, not sure those `value-string`/`value-word` suppose to match.",
        "pr_file_module": null
      },
      {
        "comment_id": "1059659717",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14089,
        "pr_file": "src/language-css/printer-postcss.js",
        "discussion_id": "1059483698",
        "commented_code": "@@ -853,6 +856,20 @@ function genericPrint(path, options, print) {\n           continue;\n         }\n \n+        if (isMapItemNode) {\n+          const isPartOfValue =\n+            node.groups?.[1]?.type === \"value-colon\" && i > 1;\n+          if (",
        "comment_created_at": "2022-12-31T16:08:06+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "What do you think the following comment?\r\n\r\n```js\r\n// For example, there is the following key-value pair:\r\n//\r\n//   \"xs-only\": \"only screen and (max-width: #{map-get($grid-breakpoints, \"sm\")-1})\"\r\n//\r\n// \"only screen and (max-width: #{map-get($grid-breakpoints, \" is a \"value-string\"\r\n// and \"sm\" is a \"value-word\"\r\n// We should not insert any spaces and lines here.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]