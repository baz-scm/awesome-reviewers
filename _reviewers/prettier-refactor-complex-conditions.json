[
  {
    "discussion_id": "2059445809",
    "pr_number": 17398,
    "pr_file": "src/language-css/loc.js",
    "created_at": "2025-04-25T01:49:37+00:00",
    "commented_code": "import lineColumnToIndex from \"../utils/line-column-to-index.js\";\n import { skipEverythingButNewLine } from \"../utils/skip.js\";\n \n+function fixValueWordLoc(node, originalIndex) {\n+  if (node.value.startsWith(\"--\")) {\n+    if (node.value.length > 2) {\n+      return originalIndex - 2;\n+    }\n+  } else if (node.value.startsWith(\"-\") && node.value.length > 1) {",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "2059445809",
        "repo_full_name": "prettier/prettier",
        "pr_number": 17398,
        "pr_file": "src/language-css/loc.js",
        "discussion_id": "2059445809",
        "commented_code": "@@ -2,6 +2,17 @@ import isNonEmptyArray from \"../utils/is-non-empty-array.js\";\n import lineColumnToIndex from \"../utils/line-column-to-index.js\";\n import { skipEverythingButNewLine } from \"../utils/skip.js\";\n \n+function fixValueWordLoc(node, originalIndex) {\n+  if (node.value.startsWith(\"--\")) {\n+    if (node.value.length > 2) {\n+      return originalIndex - 2;\n+    }\n+  } else if (node.value.startsWith(\"-\") && node.value.length > 1) {",
        "comment_created_at": "2025-04-25T01:49:37+00:00",
        "comment_author": "fisker",
        "comment_body": "Why don't we destruct `value` here. Maybe also return early if `value === '' || !value.startsWith('-')` then we can check `value.charAt(1)` instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1716282648",
    "pr_number": 7111,
    "pr_file": "src/language-js/print/binaryish.js",
    "created_at": "2024-08-14T04:07:56+00:00",
    "commented_code": "parent.type !== node.type &&\n       node.left.type !== node.type &&\n       node.right.type !== node.type);\n+  if (shouldGroup) {\n+    right = group(right, { shouldBreak });",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1716282648",
        "repo_full_name": "prettier/prettier",
        "pr_number": 7111,
        "pr_file": "src/language-js/print/binaryish.js",
        "discussion_id": "1716282648",
        "commented_code": "@@ -289,11 +318,15 @@ function printBinaryishExpressions(\n       parent.type !== node.type &&\n       node.left.type !== node.type &&\n       node.right.type !== node.type);\n+  if (shouldGroup) {\n+    right = group(right, { shouldBreak });",
        "comment_created_at": "2024-08-14T04:07:56+00:00",
        "comment_author": "btmills",
        "comment_body": "This line came from the inline expression `shouldGroup ? group(right, { shouldBreak }) : right`. Now the possibly-grouped `right` is used by both branches' `.push()` calls below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "955111708",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/printer-markdown.js",
    "created_at": "2022-08-25T15:26:07+00:00",
    "commented_code": "return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "955111708",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "955111708",
        "commented_code": "@@ -540,15 +547,104 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
        "comment_created_at": "2022-08-25T15:26:07+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "This isn't related directly to your change, but can you refactor this complex inline condition?\r\n\r\ne.g.\r\n\r\n```js\r\nif (value !== \"\" && canLineBreakBeConvertedToSpace(path, value, adjacentNodes)) {\r\n  if (isBreakable) {\r\n    return line;\r\n  }\r\n  return \" \";\r\n}\r\nif (isBreakable) {\r\n  return softline;\r\n}\r\nreturn \"\";\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "955115504",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "955111708",
        "commented_code": "@@ -540,15 +547,104 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
        "comment_created_at": "2022-08-25T15:29:12+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "Also can you extract `canLineBreakBeConvertedToSpace` as an another function?",
        "pr_file_module": null
      },
      {
        "comment_id": "962175846",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "955111708",
        "commented_code": "@@ -540,15 +547,104 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
        "comment_created_at": "2022-09-03T16:15:08+00:00",
        "comment_author": "tats-u",
        "comment_body": "@sosukesuzuki \r\nDo you think this is still too complex? Nested `if` looks ugly and verbose for me.\r\n\r\n```js\r\nif (value !== \"\" && canLineBreakBeConvertedToSpace(path, value, adjacentNodes)) {\r\n  return isBreakable ? line : \" \";\r\n}\r\n// Space is not allowed, just \"\" or \"\\n\"\r\nreturn isBreakable ? softline : \"\";\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "962234565",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "955111708",
        "commented_code": "@@ -540,15 +547,104 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
        "comment_created_at": "2022-09-04T03:21:27+00:00",
        "comment_author": "tats-u",
        "comment_body": "@sosukesuzuki \r\nNew idea: use an internal function\r\n\r\n```js\r\n  if (\r\n    value !== \"\" &&\r\n    // Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\r\n    // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\r\n    canBeConvertedToSpace(path, value, adjacentNodes)\r\n  ) {\r\n    return convertToLineIfBreakable(\" \");\r\n  }\r\n  // Space is not allowed, just \"\" or \"\\n\"\r\n  return convertToLineIfBreakable(\"\");\r\n\r\n  /**\r\n   * @param value {\" \" | \"\"}\r\n   */\r\n  function convertToLineIfBreakable(value) {\r\n    if (!isBreakable) {\r\n      return value;\r\n    }\r\n    switch (value) {\r\n      case \" \":\r\n        return line;\r\n      case \"\":\r\n        return softline;\r\n    }\r\n  }\r\n```\r\n\r\nI suppose this is simpler.\r\n\r\n```js\r\n  if (value !== \"\\n\") {\r\n    return convertToLineIfBreakable(value);\r\n  }\r\n  // Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\r\n  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\r\n  return convertToLineIfBreakable(\r\n    canBeConvertedToSpace(path, value, adjacentNodes) ? \" \" : \"\"\r\n  );\r\n\r\n  /**\r\n   * @param value {\" \" | \"\"}\r\n   */\r\n  function convertToLineIfBreakable(value) {\r\n    if (!isBreakable) {\r\n      return value;\r\n    }\r\n    switch (value) {\r\n      case \" \":\r\n        return line;\r\n      case \"\":\r\n        return softline;\r\n    }\r\n  }\r\n```\r\n\r\n`switch` can be replaced with `return value === \" \" ? line : softline;`.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "962280229",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "955111708",
        "commented_code": "@@ -540,15 +547,104 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
        "comment_created_at": "2022-09-04T09:19:54+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "> Do you think this is still too complex? Nested if looks ugly and verbose for me.\r\n\r\nThank you, the below code that you showed first looks enough readable to me (I prefer the first one than second one.)\r\n\r\n```js\r\nif (value !== \"\" && canLineBreakBeConvertedToSpace(path, value, adjacentNodes)) {\r\n  return isBreakable ? line : \" \";\r\n}\r\n// Space is not allowed, just \"\" or \"\\n\"\r\nreturn isBreakable ? softline : \"\";\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "962288648",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "955111708",
        "commented_code": "@@ -540,15 +547,104 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between `\u5b57` (ideograph & kana) and `A` (other letters e.g. alphanumerics) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {*} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n+  // Chinese and Japanese does not use U+0020 Space to dive words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  const canLineBreakBeConvertedToSpace = !(\n+    value === \"\\n\" &&\n+    typeof adjacentNodes === \"object\" &&\n+    (adjacentNodes?.previous?.kind === \"cj-letter\" ||\n+      adjacentNodes?.next?.kind === \"cj-letter\") &&\n+    // we wonder if there are other marks to be considered.\n+    (adjacentNodes.next.value !== \":::\" ||\n+      !isCorrespondingMarkFollowedBySpaceBefore(\n+        path,\n+        adjacentNodes.next.value\n+      )) &&\n+    !isSentenceUseCJDividingSpace(path)\n+  );\n+  return value !== \"\" && canLineBreakBeConvertedToSpace",
        "comment_created_at": "2022-09-04T10:25:00+00:00",
        "comment_author": "tats-u",
        "comment_body": "Please see the comment in the updated lines.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "962286975",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/printer-markdown.js",
    "created_at": "2022-09-04T10:11:52+00:00",
    "commented_code": "return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {string} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhiteSpaceValue} WhiteSpaceValue\n+ * @typedef {{next?: TextNode | undefined, previous?: TextNode | undefined}} AdjacentNodes\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {*} path path of given node\n+ * @param {WhiteSpaceValue} value value of given node (typically `\" \"` or `\"\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  return (\n+    // \"\n\" or \" \", of course \" \" always can be converted to Space\n+    value !== \"\n\" ||\n+    // no adjacent nodes\n+    typeof adjacentNodes !== \"object\" ||\n+    // \"\n\" between non-CJ (not han or kana) characters always can converted to Space\n+    (adjacentNodes.previous?.kind !== KIND_CJ_LETTER &&\n+      adjacentNodes.next?.kind !== KIND_CJ_LETTER) ||\n+    (!(\n+      // Do not convert it to Space when:\n+      // \"\n\" between CJ always SHALL NOT be converted to space\n+      (\n+        (adjacentNodes.previous?.kind === KIND_CJ_LETTER &&\n+          adjacentNodes.next?.kind === KIND_CJ_LETTER) ||\n+        // Shall not be converted to Space around CJK punctuation\n+        adjacentNodes.previous?.kind === KIND_CJK_PUNCTUATION ||\n+        adjacentNodes.next?.kind === KIND_CJK_PUNCTUATION\n+      )\n+    ) &&\n+      // The following rules do not precede the above rules.\n+      //\n+      // 1. \"\n\" between special signs and CJ characters\n+      // [corresponding sign][Space][any string][CJ][[\n]][target sign]\n+      // we wonder if there are other marks to be considered.\n+      ((adjacentNodes.next.value === \":::\" &&\n+        isCorrespondingMarkFollowedBySpaceBefore(\n+          path,\n+          adjacentNodes.next.value\n+        )) ||\n+        // 2. If sentence uses space between CJ and alphanumerics (including hangul because of backward-compatibility),\n+        //    \"\n\" can be converted to Space.\n+        // Note: Koran uses space to divide words, so it is difficult to determine if \"\n\" should be converted to Space.\n+        isSentenceUseCJDividingSpace(path)))\n+  );\n+}\n+\n+/**\n+ * @param {*} path\n+ * @param {WhiteSpaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ */\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n-    ? isBreakable\n-      ? line\n-      : \" \"\n-    : isBreakable\n-    ? softline\n-    : \"\";\n+\n+  // Space or empty\n+  if (value !== \"\n\") {\n+    return convertToLineIfBreakable(value);\n+  }\n+  // Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  return convertToLineIfBreakable(\n+    canBeConvertedToSpace(path, value, adjacentNodes) ? \" \" : \"\"\n+  );\n+\n+  /**\n+   * @param value {\" \" | \"\"}\n+   */\n+  function convertToLineIfBreakable(value) {\n+    if (!isBreakable) {\n+      return value;\n+    }\n+    return value === \" \" ? line : softline;\n+  }",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "962286975",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "962286975",
        "commented_code": "@@ -540,21 +549,173 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * Looks for 1st `:::` (MUST be followed by a Space) from 2nd `:::`.\n+ *\n+ * ```\n+ * ::: foo\n+ * bar\n+ * :::\n+ * ```\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @param {string} mark what to look for\n+ * @returns `true` if a `mark` followed by Space (U+0020) is found before `path`, `false` otherwise.\n+ */\n+function isCorrespondingMarkFollowedBySpaceBefore(path, mark) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (\n+    sentenceNode.children\n+      .slice(0, getPenultimate(path.stack))\n+      .some(\n+        (node, i, array) =>\n+          node.value === mark &&\n+          array[i + 1]?.type === \"whitespace\" &&\n+          array[i + 1]?.value === \" \"\n+      )\n+  ) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhiteSpaceValue} WhiteSpaceValue\n+ * @typedef {{next?: TextNode | undefined, previous?: TextNode | undefined}} AdjacentNodes\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {*} path path of given node\n+ * @param {WhiteSpaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  return (\n+    // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+    value !== \"\\n\" ||\n+    // no adjacent nodes\n+    typeof adjacentNodes !== \"object\" ||\n+    // \"\\n\" between non-CJ (not han or kana) characters always can converted to Space\n+    (adjacentNodes.previous?.kind !== KIND_CJ_LETTER &&\n+      adjacentNodes.next?.kind !== KIND_CJ_LETTER) ||\n+    (!(\n+      // Do not convert it to Space when:\n+      // \"\\n\" between CJ always SHALL NOT be converted to space\n+      (\n+        (adjacentNodes.previous?.kind === KIND_CJ_LETTER &&\n+          adjacentNodes.next?.kind === KIND_CJ_LETTER) ||\n+        // Shall not be converted to Space around CJK punctuation\n+        adjacentNodes.previous?.kind === KIND_CJK_PUNCTUATION ||\n+        adjacentNodes.next?.kind === KIND_CJK_PUNCTUATION\n+      )\n+    ) &&\n+      // The following rules do not precede the above rules.\n+      //\n+      // 1. \"\\n\" between special signs and CJ characters\n+      // [corresponding sign][Space][any string][CJ][[\\n]][target sign]\n+      // we wonder if there are other marks to be considered.\n+      ((adjacentNodes.next.value === \":::\" &&\n+        isCorrespondingMarkFollowedBySpaceBefore(\n+          path,\n+          adjacentNodes.next.value\n+        )) ||\n+        // 2. If sentence uses space between CJ and alphanumerics (including hangul because of backward-compatibility),\n+        //    \"\\n\" can be converted to Space.\n+        // Note: Koran uses space to divide words, so it is difficult to determine if \"\\n\" should be converted to Space.\n+        isSentenceUseCJDividingSpace(path)))\n+  );\n+}\n+\n+/**\n+ * @param {*} path\n+ * @param {WhiteSpaceValue} value\n+ * @param {*} options\n+ * @param {AdjacentNodes | undefined} [adjacentNodes]\n+ */\n+function printLine(path, value, options, adjacentNodes) {\n   if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n     return hardline;\n   }\n \n   const isBreakable =\n     options.proseWrap === \"always\" &&\n     !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n-  return value !== \"\"\n-    ? isBreakable\n-      ? line\n-      : \" \"\n-    : isBreakable\n-    ? softline\n-    : \"\";\n+\n+  // Space or empty\n+  if (value !== \"\\n\") {\n+    return convertToLineIfBreakable(value);\n+  }\n+  // Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\n+  // Behavior in other languages will not be changed because there are too much things to consider. (PR welcome)\n+  return convertToLineIfBreakable(\n+    canBeConvertedToSpace(path, value, adjacentNodes) ? \" \" : \"\"\n+  );\n+\n+  /**\n+   * @param value {\" \" | \"\"}\n+   */\n+  function convertToLineIfBreakable(value) {\n+    if (!isBreakable) {\n+      return value;\n+    }\n+    return value === \" \" ? line : softline;\n+  }",
        "comment_created_at": "2022-09-04T10:11:52+00:00",
        "comment_author": "tats-u",
        "comment_body": "@sosukesuzuki \r\n\r\nCould you tell me which is better this or the below?\r\n\r\n```js\r\nif (value !== \"\" && canLineBreakBeConvertedToSpace(path, value, adjacentNodes)) {\r\n  return isBreakable ? line : \" \";\r\n}\r\n// Space is not allowed, just \"\" or \"\\n\"\r\nreturn isBreakable ? softline : \"\";\r\n```\r\n\r\n(by https://github.com/prettier/prettier/pull/11597/files/5a84ae7efec6a087cf423719f9eab127c61cb061#r962280229)\r\n\r\nThis makes it possible to remove the last line of the below thanks to `if (value !== \"\\n\") {`.\r\n\r\n```js\r\nfunction canBeConvertedToSpace(path, value, adjacentNodes) {\r\n  return (\r\n    // \"\\n\" or \" \", of course \" \" always can be converted to Space\r\n    value !== \"\\n\" ||\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "989359740",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/printer-markdown.js",
    "created_at": "2022-10-06T18:24:40+00:00",
    "commented_code": "return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "989359740",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "989359740",
        "commented_code": "@@ -526,21 +567,249 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }",
        "comment_created_at": "2022-10-06T18:24:40+00:00",
        "comment_author": "thorn0",
        "comment_body": "Please refactor this part.\r\n- `switch` can be replaced with another condition in `if`\r\n- make `previousKind` and `nextKind` variables instead of `previous` and `next`\r\n- this pattern looks strange:\r\n\t```js\r\n\tif (!condition) {\r\n\t  continue;\r\n\t}\r\n\tdoSomething();\r\n\tcontinue;\r\n\t```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "990161499",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "989359740",
        "commented_code": "@@ -526,21 +567,249 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }",
        "comment_created_at": "2022-10-07T14:36:48+00:00",
        "comment_author": "tats-u",
        "comment_body": "Now that you mention it, you are right.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "468239069",
    "pr_number": 8926,
    "pr_file": "src/language-js/utils.js",
    "created_at": "2020-08-10T23:24:14+00:00",
    "commented_code": "prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "468239069",
        "repo_full_name": "prettier/prettier",
        "pr_number": 8926,
        "pr_file": "src/language-js/utils.js",
        "discussion_id": "468239069",
        "commented_code": "@@ -657,7 +657,8 @@ function hasJsxIgnoreComment(path) {\n     prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
        "comment_created_at": "2020-08-10T23:24:14+00:00",
        "comment_author": "fisker",
        "comment_body": "?? ",
        "pr_file_module": null
      },
      {
        "comment_id": "468322411",
        "repo_full_name": "prettier/prettier",
        "pr_number": 8926,
        "pr_file": "src/language-js/utils.js",
        "discussion_id": "468239069",
        "commented_code": "@@ -657,7 +657,8 @@ function hasJsxIgnoreComment(path) {\n     prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
        "comment_created_at": "2020-08-11T04:41:16+00:00",
        "comment_author": "chaitan94",
        "comment_body": "This is to return `\"next\"` instead of `true`. Which is again, because we changed the return type from `boolean` to `@return {false | \"next\" | \"start\" | \"end\"}`. This is in line with how range ignore was implemented before this in the codebase: refer https://github.com/prettier/prettier/pull/4202.",
        "pr_file_module": null
      },
      {
        "comment_id": "468324708",
        "repo_full_name": "prettier/prettier",
        "pr_number": 8926,
        "pr_file": "src/language-js/utils.js",
        "discussion_id": "468239069",
        "commented_code": "@@ -657,7 +657,8 @@ function hasJsxIgnoreComment(path) {\n     prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
        "comment_created_at": "2020-08-11T04:50:25+00:00",
        "comment_author": "fisker",
        "comment_body": "Sorry, I thought it's a `if`, but better rewrite to `if/else`\r\n\r\n```js\r\nreturn (foo && \"next\")\r\n```\r\n\r\nseems wired to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "468376126",
        "repo_full_name": "prettier/prettier",
        "pr_number": 8926,
        "pr_file": "src/language-js/utils.js",
        "discussion_id": "468239069",
        "commented_code": "@@ -657,7 +657,8 @@ function hasJsxIgnoreComment(path) {\n     prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
        "comment_created_at": "2020-08-11T07:20:05+00:00",
        "comment_author": "chaitan94",
        "comment_body": "Sure, should I do `return (foo ? \"next\" : false)` instead, if that is more readable?",
        "pr_file_module": null
      },
      {
        "comment_id": "468399275",
        "repo_full_name": "prettier/prettier",
        "pr_number": 8926,
        "pr_file": "src/language-js/utils.js",
        "discussion_id": "468239069",
        "commented_code": "@@ -657,7 +657,8 @@ function hasJsxIgnoreComment(path) {\n     prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
        "comment_created_at": "2020-08-11T08:04:28+00:00",
        "comment_author": "fisker",
        "comment_body": "```js\r\n  if (prevSibling &&\r\n    prevSibling.type === \"JSXExpressionContainer\" &&\r\n    prevSibling.expression.type === \"JSXEmptyExpression\" &&\r\n    prevSibling.expression.comments &&\r\n    prevSibling.expression.comments.some(\r\n      (comment) => comment.value.trim() === \"prettier-ignore\"\r\n    )) {\r\n    return \"next\";\r\n  }\r\n\r\n  return false;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "468507064",
        "repo_full_name": "prettier/prettier",
        "pr_number": 8926,
        "pr_file": "src/language-js/utils.js",
        "discussion_id": "468239069",
        "commented_code": "@@ -657,7 +657,8 @@ function hasJsxIgnoreComment(path) {\n     prevSibling.expression.comments &&\n     prevSibling.expression.comments.some(\n       (comment) => comment.value.trim() === \"prettier-ignore\"\n-    )\n+    ) &&\n+    \"next\"",
        "comment_created_at": "2020-08-11T11:22:04+00:00",
        "comment_author": "chaitan94",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1112732395",
    "pr_number": 14208,
    "pr_file": "src/language-css/printer-postcss.js",
    "created_at": "2023-02-21T08:42:33+00:00",
    "commented_code": "}\n \n       if (!node.open) {\n+        const parentParentParentNode = path.getParentNode(2);\n+        let forceHardLine =\n+          parentParentParentNode.type === \"css-decl\" ||\n+          (parentParentParentNode.type === \"css-atrule\" &&\n+            parentParentParentNode.variable);\n+        if (forceHardLine) {\n+          forceHardLine = false;\n+          for (let i = 0; i < node.groups.length; i++) {\n+            if (node.groups[i].type === \"value-comma_group\") {\n+              forceHardLine = true;\n+            }\n+          }\n+        }",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1112732395",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14208,
        "pr_file": "src/language-css/printer-postcss.js",
        "discussion_id": "1112732395",
        "commented_code": "@@ -924,12 +926,27 @@ function genericPrint(path, options, print) {\n       }\n \n       if (!node.open) {\n+        const parentParentParentNode = path.getParentNode(2);\n+        let forceHardLine =\n+          parentParentParentNode.type === \"css-decl\" ||\n+          (parentParentParentNode.type === \"css-atrule\" &&\n+            parentParentParentNode.variable);\n+        if (forceHardLine) {\n+          forceHardLine = false;\n+          for (let i = 0; i < node.groups.length; i++) {\n+            if (node.groups[i].type === \"value-comma_group\") {\n+              forceHardLine = true;\n+            }\n+          }\n+        }",
        "comment_created_at": "2023-02-21T08:42:33+00:00",
        "comment_author": "fisker",
        "comment_body": "```suggestion\r\n      const forceHardLine =\r\n        (parentParentParentNode.type === \"css-decl\" ||\r\n          (parentParentParentNode.type === \"css-atrule\" &&\r\n            parentParentParentNode.variable)) &&\r\n        node.groups.some((node) => node.type === \"value-comma_group\");\r\n```\r\n\r\nSame?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1148390749",
    "pr_number": 14587,
    "pr_file": "src/language-html/print-preprocess.js",
    "created_at": "2023-03-25T15:25:59+00:00",
    "commented_code": "function markTsScript(ast, options) {\n   if (options.parser === \"vue\") {\n-    const vueScriptTag = ast.children.find((child) =>\n+    const vueScriptTags = ast.children.filter((child) =>\n       isVueScriptTag(child, options)\n     );\n-    if (!vueScriptTag) {\n-      return;\n-    }\n-    const { lang } = vueScriptTag.attrMap;\n-    if (lang === \"ts\" || lang === \"typescript\") {\n+    const shouldMarkTs = vueScriptTags.some((vueScriptTag) =>\n+      [\"ts\", \"typescript\"].includes(vueScriptTag.attrMap.lang)\n+    );",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1148390749",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14587,
        "pr_file": "src/language-html/print-preprocess.js",
        "discussion_id": "1148390749",
        "commented_code": "@@ -412,14 +412,13 @@ function addIsSpaceSensitive(ast, options) {\n \n function markTsScript(ast, options) {\n   if (options.parser === \"vue\") {\n-    const vueScriptTag = ast.children.find((child) =>\n+    const vueScriptTags = ast.children.filter((child) =>\n       isVueScriptTag(child, options)\n     );\n-    if (!vueScriptTag) {\n-      return;\n-    }\n-    const { lang } = vueScriptTag.attrMap;\n-    if (lang === \"ts\" || lang === \"typescript\") {\n+    const shouldMarkTs = vueScriptTags.some((vueScriptTag) =>\n+      [\"ts\", \"typescript\"].includes(vueScriptTag.attrMap.lang)\n+    );",
        "comment_created_at": "2023-03-25T15:25:59+00:00",
        "comment_author": "fisker",
        "comment_body": "`filter` + `some` can reduce to one `.some`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1049293498",
    "pr_number": 13995,
    "pr_file": "src/language-css/parser-postcss.js",
    "created_at": "2022-12-15T07:23:46+00:00",
    "commented_code": "parenGroupStack.pop();\n       parenGroup = getLast(parenGroupStack);\n     } else if (node.type === \"comma\") {\n-      if (commaGroup.groups.length > 1) {\n-        for (const group of commaGroup.groups) {\n-          // if css interpolation\n-          if (\n-            group.value &&\n-            typeof group.value === \"string\" &&\n-            group.value.includes(\"#{\")\n-          ) {\n-            commaGroup.groups = [\n-              stringifyNode({\n-                groups: commaGroup.groups,\n-              }).trim(),\n-            ];\n-            break;\n-          }\n-        }\n+      // if SCSS interpolation\n+      if (\n+        commaGroup.groups.some(\n+          (group) =>\n+            typeof group.value === \"string\" && group.value.includes(\"#{\")\n+        )\n+      ) {\n+        commaGroup.groups = [\n+          stringifyNode({\n+            groups: commaGroup.groups,\n+          }).trim(),\n+        ];",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1049293498",
        "repo_full_name": "prettier/prettier",
        "pr_number": 13995,
        "pr_file": "src/language-css/parser-postcss.js",
        "discussion_id": "1049293498",
        "commented_code": "@@ -122,22 +122,18 @@ function parseValueNode(valueNode, options) {\n       parenGroupStack.pop();\n       parenGroup = getLast(parenGroupStack);\n     } else if (node.type === \"comma\") {\n-      if (commaGroup.groups.length > 1) {\n-        for (const group of commaGroup.groups) {\n-          // if css interpolation\n-          if (\n-            group.value &&\n-            typeof group.value === \"string\" &&\n-            group.value.includes(\"#{\")\n-          ) {\n-            commaGroup.groups = [\n-              stringifyNode({\n-                groups: commaGroup.groups,\n-              }).trim(),\n-            ];\n-            break;\n-          }\n-        }\n+      // if SCSS interpolation\n+      if (\n+        commaGroup.groups.some(\n+          (group) =>\n+            typeof group.value === \"string\" && group.value.includes(\"#{\")\n+        )\n+      ) {\n+        commaGroup.groups = [\n+          stringifyNode({\n+            groups: commaGroup.groups,\n+          }).trim(),\n+        ];",
        "comment_created_at": "2022-12-15T07:23:46+00:00",
        "comment_author": "fisker",
        "comment_body": "This change is not related, but the logic can be simplified to use `Array#some()`.",
        "pr_file_module": null
      }
    ]
  }
]