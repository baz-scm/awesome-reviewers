[
  {
    "discussion_id": "989379255",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/printer-markdown.js",
    "created_at": "2022-10-06T18:49:08+00:00",
    "commented_code": "return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhiteSpaceValue} WhiteSpaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhiteSpaceValue} value value of given node (typically `\" \"` or `\"\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  // Use `!` (no zero, NaN, or empty string)\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \nletter\"\n+  // Use `!` (no zero, NaN, or empty string)\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous?.kind;\n+  const nextKind = adjacentNodes.next?.kind;",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "989379255",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/printer-markdown.js",
        "discussion_id": "989379255",
        "commented_code": "@@ -526,21 +567,249 @@ function getAncestorNode(path, typeOrTypes) {\n   return counter === -1 ? null : path.getParentNode(counter);\n }\n \n-function printLine(path, value, options) {\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isSentenceUseCJDividingSpace(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.isCJSpacingUsing !== undefined) {\n+    return sentenceNode.isCJSpacingUsing;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (node.type === \"whitespace\") {\n+      switch (node.value) {\n+        case \" \":\n+        case \"\": {\n+          const previous = sentenceNode.children[i - 1];\n+          const next = sentenceNode.children[i + 1];\n+          if (\n+            !(\n+              (previous?.kind === \"cj-letter\" && next?.kind === \"non-cjk\") ||\n+              (previous?.kind === \"non-cjk\" && next?.kind === \"cj-letter\")\n+            )\n+          ) {\n+            continue;\n+          }\n+          ++cjNonCJKSpacingStatistics[node.value];\n+          continue;\n+        }\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.isCJSpacingUsing =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.isCJSpacingUsing;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhiteSpaceValue} WhiteSpaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+00A0 No-break space must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhiteSpaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  // Use `!` (no zero, NaN, or empty string)\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  // Use `!` (no zero, NaN, or empty string)\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous?.kind;\n+  const nextKind = adjacentNodes.next?.kind;",
        "comment_created_at": "2022-10-06T18:49:08+00:00",
        "comment_author": "thorn0",
        "comment_body": "No need for optional chaining here as you've just checked (in the `if` above) that these values are truthy.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "990753618",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/whitespace.js",
    "created_at": "2022-10-09T08:16:59+00:00",
    "commented_code": "+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\n\" between CJ always SHALL NOT be converted to space\n+    // \"\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "990753618",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/whitespace.js",
        "discussion_id": "990753618",
        "commented_code": "@@ -0,0 +1,265 @@\n+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be converted to space\n+    // \"\\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
        "comment_created_at": "2022-10-09T08:16:59+00:00",
        "comment_author": "thorn0",
        "comment_body": "Is it really possible that `value` can be undefined?",
        "pr_file_module": null
      },
      {
        "comment_id": "990757475",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/whitespace.js",
        "discussion_id": "990753618",
        "commented_code": "@@ -0,0 +1,265 @@\n+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be converted to space\n+    // \"\\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
        "comment_created_at": "2022-10-09T08:49:56+00:00",
        "comment_author": "tats-u",
        "comment_body": "Assumed a sequence of whitespace nodes (previous or next is whitespace).\r\nDoes it not happen?",
        "pr_file_module": null
      },
      {
        "comment_id": "990757854",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/whitespace.js",
        "discussion_id": "990753618",
        "commented_code": "@@ -0,0 +1,265 @@\n+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be converted to space\n+    // \"\\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
        "comment_created_at": "2022-10-09T08:52:59+00:00",
        "comment_author": "thorn0",
        "comment_body": "I'm asking to understand whether optional chaining is really needed here.",
        "pr_file_module": null
      },
      {
        "comment_id": "990761548",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/whitespace.js",
        "discussion_id": "990753618",
        "commented_code": "@@ -0,0 +1,265 @@\n+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be converted to space\n+    // \"\\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
        "comment_created_at": "2022-10-09T09:21:28+00:00",
        "comment_author": "tats-u",
        "comment_body": "@thorn0 I will remove optional chaining if you say both of previous and next are always word nodes (not whitespace, whose `.kind` is `undefined`) in this line.\r\nI am concerning about the case `<word 1><whitespace 1><whitespace 2><word 2>` where either of words is CJ and the other is non-CJK, and either of whitespaces is `\\n`, although it is a corner case and I am not sure that it happens.",
        "pr_file_module": null
      },
      {
        "comment_id": "990779152",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/whitespace.js",
        "discussion_id": "990753618",
        "commented_code": "@@ -0,0 +1,265 @@\n+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be converted to space\n+    // \"\\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
        "comment_created_at": "2022-10-09T11:57:40+00:00",
        "comment_author": "thorn0",
        "comment_body": "I checked the logic in `splitText`. It doesn't create consecutive whitespace nodes. However, to stay safe in the future, please enforce this constraint by adding the following check to `splitText` before returning `result`:\r\n\r\n```js\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    for (let i = 1; i < nodes.length; i++) {\r\n      if (\r\n        nodes[i].type === \"whitespace\" &&\r\n        nodes[i - 1].type === \"whitespace\"\r\n      ) {\r\n        throw new Error(\r\n          \"splitText should not create consecutive whitespace nodes\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "990792021",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/whitespace.js",
        "discussion_id": "990753618",
        "commented_code": "@@ -0,0 +1,265 @@\n+import { getAncestorNode } from \"./printer-markdown.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  punctuationRegex,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertToSpaceSymbolSet = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space is tend to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {*} path current position in nodes tree\n+ * @returns {boolean} `true` if Space is tend to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = getAncestorNode(path, \"sentence\");\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const cjNonCJKSpacingStatistics = {\n+    \" \": 0,\n+    \"\": 0,\n+  };\n+  for (let i = 0; i < sentenceNode.children.length; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1]?.kind;\n+      const nextKind = sentenceNode.children[i + 1]?.kind;\n+      if (\n+        (previousKind === \"cj-letter\" && nextKind === \"non-cjk\") ||\n+        (previousKind === \"non-cjk\" && nextKind === \"cj-letter\")\n+      ) {\n+        ++cjNonCJKSpacingStatistics[node.value];\n+      }\n+    }\n+  }\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces =\n+    cjNonCJKSpacingStatistics[\" \"] > cjNonCJKSpacingStatistics[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").TextNode} TextNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: TextNode | undefined | null, previous?: TextNode | undefined | null}} AdjacentNodes\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese does not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {WhitespaceValue} value value of given node (typically `\" \"` or `\"\\n\"`)\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be converted to space, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, value, adjacentNodes) {\n+  // \"\\n\" or \" \", of course \" \" always can be converted to Space\n+  if (value !== \"\\n\") {\n+    return true;\n+  }\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be converted to space\n+    // \"\\n\" between Korean and CJ is better not to be converted to space\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+  const previousLastChar = adjacentNodes.previous.value?.at(-1);\n+  const nextFirstChar = adjacentNodes.next.value?.[0];",
        "comment_created_at": "2022-10-09T13:53:43+00:00",
        "comment_author": "tats-u",
        "comment_body": "@thorn0 I also checked it and confirmed that a whitespace node is not adjacent to another one. I fixed this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "997257972",
    "pr_number": 11597,
    "pr_file": "src/language-markdown/print-whitespace.js",
    "created_at": "2022-10-17T16:10:04+00:00",
    "commented_code": "+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "997257972",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997257972",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);",
        "comment_created_at": "2022-10-17T16:10:04+00:00",
        "comment_author": "fisker",
        "comment_body": "Will this index access cause problems for emojis or other characters\r\n? https://mathiasbynens.be/notes/javascript-unicode",
        "pr_file_module": null
      },
      {
        "comment_id": "997324078",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997257972",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);",
        "comment_created_at": "2022-10-17T17:19:09+00:00",
        "comment_author": "thorn0",
        "comment_body": "Good question. I checked and all the characters in `lineBreakBetweenTheseAndCJKConvertsToSpace` have `.length === 1`. As long as it's the case that index access isn't a problem.",
        "pr_file_module": null
      },
      {
        "comment_id": "997689700",
        "repo_full_name": "prettier/prettier",
        "pr_number": 11597,
        "pr_file": "src/language-markdown/print-whitespace.js",
        "discussion_id": "997257972",
        "commented_code": "@@ -0,0 +1,310 @@\n+import { hardline, line, softline } from \"../document/builders.js\";\n+import {\n+  KIND_CJK_PUNCTUATION,\n+  KIND_CJ_LETTER,\n+  KIND_K_LETTER,\n+  KIND_NON_CJK,\n+  getAncestorNode,\n+} from \"./utils.js\";\n+\n+const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];\n+\n+// https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n+/**\n+ * The set of characters that must not immediately precede a line break\n+ *\n+ * e.g. `\"\uff08\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\\n\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\\n\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\"` or ``\"\u6a9c\u539f\u6751\uff08\u3072\\n\u306e\u306f\u3089\u3080\u3089\uff09\"`\n+ */\n+const noBreakAfter = new Set(\n+  \"$(\u00a3\u00a5\u00b7'\\\"\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u301d\ufe59\ufe5b\uff04\uff08\uff3b\uff5b\uffe1\uffe5[{\u2035\ufe34\ufe35\ufe37\ufe39\ufe3b\ufe3d\ufe3f\ufe41\ufe43\ufe4f\u3018\uff5f\u00ab\"\n+);\n+\n+/**\n+ * The set of characters that must not immediately follow a line break\n+ *\n+ * e.g. `\"\uff09\"`\n+ *\n+ * - Bad:  `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\\n\uff09\u4ee5\u5916\u306b\u306f\u3001\"`\n+ * - Good: `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\\n\u3089\uff09\u4ee5\u5916\u306b\u306f\u3001\"` or `\"\u6a9c\u539f\u6751\uff08\u3072\u306e\u306f\u3089\u3080\u3089\uff09\\n\u4ee5\u5916\u306b\u306f\u3001\"`\n+ */\n+const noBreakBefore = new Set(\n+  \"!%),.:;?]}\u00a2\u00b0\u00b7'\\\"\u2020\u2021\u203a\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301e\ufe5a\ufe5c\uff01\uff02\uff05\uff07\uff09\uff0c\uff0e\uff1a\uff1b\uff1f\uff3d\uff5d\uff5e\u2013\u2014\u2022\u3009\u300b\u300d\ufe30\ufe31\ufe32\ufe33\ufe50\ufe51\ufe52\ufe53\ufe54\ufe55\ufe56\ufe58\ufe36\ufe38\ufe3a\ufe3c\ufe3e\ufe40\ufe42\ufe57\uff5c\uff64\u300f\u3011\u3019\u301f\uff60\u00bb\u30fd\u30fe\u30fc\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096\u31f0\u31f1\u31f2\u31f3\u31f4\u31f5\u31f6\u31f7\u31f8\u31f9\u31fa\u31fb\u31fc\u31fd\u31fe\u31ff\u3005\u303b\u2010\u30a0\u301c\uff5e\u203c\u2047\u2048\u2049\u30fb\"\n+);\n+\n+/**\n+ * The set of characters whose surrounding newline may be converted to Space\n+ *\n+ * - ASCII punctuation marks\n+ */\n+const lineBreakBetweenTheseAndCJKConvertsToSpace = new Set(\n+  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n+);\n+\n+/**\n+ * Finds out if Space tends to be inserted between Chinese or Japanese characters\n+ * (including ideograph aka han or kanji e.g. `\u5b57`, hiragana e.g. `\u3042`, and katakana e.g. `\u30a2`)\n+ * and other letters (including alphanumerics; e.g. `A` or `1`) in the sentence.\n+ *\n+ * @param {AstPath} path current position in nodes tree\n+ * @returns {boolean} `true` if Space tends to be inserted between these types of letters, `false` otherwise.\n+ */\n+function isInSentenceWithCJSpaces(path) {\n+  const sentenceNode = path.parent;\n+  if (sentenceNode.usesCJSpaces !== undefined) {\n+    return sentenceNode.usesCJSpaces;\n+  }\n+\n+  const stats = { \" \": 0, \"\": 0 };\n+\n+  for (let i = 1; i < sentenceNode.children.length - 1; ++i) {\n+    const node = sentenceNode.children[i];\n+    if (\n+      node.type === \"whitespace\" &&\n+      (node.value === \" \" || node.value === \"\")\n+    ) {\n+      const previousKind = sentenceNode.children[i - 1].kind;\n+      const nextKind = sentenceNode.children[i + 1].kind;\n+      if (\n+        (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n+        (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n+      ) {\n+        ++stats[node.value];\n+      }\n+    }\n+  }\n+\n+  // Injects a property to cache the result.\n+  sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n+  return sentenceNode.usesCJSpaces;\n+}\n+\n+/**\n+ * @typedef {import(\"./utils.js\").WordNode} WordNode\n+ * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n+ * @typedef {{next?: WordNode | undefined | null, previous?: WordNode | undefined | null}} AdjacentNodes\n+ * Adjacent node to `WhitespaceNode`. the consecution of `WhitespaceNode` is a bug, so adjacent nodes must be `WordNode`.\n+ * @typedef {import(\"./utils.js\").WordKind} WordKind\n+ * @typedef {import(\"../common/ast-path.js\").default} AstPath\n+ */\n+\n+/**\n+ * Checks if given `\"\\n\"` node can be converted to Space\n+ *\n+ * For example, if you would like to squash the multi-line string `\"You might want\\nto use Prettier.\"` into a single line,\n+ * you would replace `\"\\n\"` with `\" \"`. (`\"You might want to use Prettier.\"`)\n+ *\n+ * However, you should note that Chinese and Japanese do not use U+0020 Space to divide words, so U+000A End of Line must not be replaced with it.\n+ * Behavior in other languages (e.g. Thai) will not be changed because there are too much things to consider. (PR welcome)\n+ *\n+ * @param {AstPath} path path of given node\n+ * @param {AdjacentNodes | undefined} adjacentNodes adjacent sibling nodes of given node\n+ * @returns {boolean} `true` if given node can be convertedToSpace, `false` if not (i.e. newline or empty character)\n+ */\n+function canBeConvertedToSpace(path, adjacentNodes) {\n+  // no adjacent nodes\n+  if (!adjacentNodes) {\n+    return true;\n+  }\n+\n+  // e.g. \" \\nletter\"\n+  if (!adjacentNodes.previous || !adjacentNodes.next) {\n+    return true;\n+  }\n+\n+  const previousKind = adjacentNodes.previous.kind;\n+  const nextKind = adjacentNodes.next.kind;\n+\n+  // \"\\n\" between not western or Korean (han, kana, CJK punctuations) characters always can be converted to Space\n+  // Korean hangul simulates latin words; see #6516 (https://github.com/prettier/prettier/issues/6516)\n+  if (\n+    isWesternOrKoreanLetter(previousKind) &&\n+    isWesternOrKoreanLetter(nextKind)\n+  ) {\n+    return true;\n+  }\n+\n+  // han & hangul: same way preferred\n+  if (\n+    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n+    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n+  ) {\n+    return true;\n+  }\n+\n+  // Do not convert it to Space when:\n+  if (\n+    // Shall not be converted to Space around CJK punctuation\n+    previousKind === KIND_CJK_PUNCTUATION ||\n+    nextKind === KIND_CJK_PUNCTUATION ||\n+    // \"\\n\" between CJ always SHALL NOT be convertedToSpace\n+    (isCJK(previousKind) && isCJK(nextKind))\n+  ) {\n+    return false;\n+  }\n+\n+  const characterBefore = adjacentNodes.previous.value.at(-1);",
        "comment_created_at": "2022-10-18T03:44:28+00:00",
        "comment_author": "tats-u",
        "comment_body": "@fisker As all punctuation marks we are concerned with are in BMP, no problems about this will happen at least for the time being.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1329229076",
    "pr_number": 15430,
    "pr_file": "src/language-css/utils/index.js",
    "created_at": "2023-09-18T20:16:58+00:00",
    "commented_code": "function insideURLFunctionInImportAtRuleNode(path) {\n   const { node } = path;\n   return (\n-    node.groups[0].value === \"url\" &&\n+    node.groups?.[0].value === \"url\" &&",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1329229076",
        "repo_full_name": "prettier/prettier",
        "pr_number": 15430,
        "pr_file": "src/language-css/utils/index.js",
        "discussion_id": "1329229076",
        "commented_code": "@@ -95,7 +95,7 @@ function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {\n function insideURLFunctionInImportAtRuleNode(path) {\n   const { node } = path;\n   return (\n-    node.groups[0].value === \"url\" &&\n+    node.groups?.[0].value === \"url\" &&",
        "comment_created_at": "2023-09-18T20:16:58+00:00",
        "comment_author": "romainmenke",
        "comment_body": "I don't know exactly which source code triggers the exception.\r\nI encountered this condition when running prettier through Stylelint with their VSCode extension during or shortly after a switch between branches.\r\n\r\nI mimicked the same code as found in `isKeyValuePairInParenGroupNode`.\r\nLogically this change should prevent exceptions and should still work as intended.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1148413485",
    "pr_number": 14590,
    "pr_file": "scripts/build/shims/at.js",
    "created_at": "2023-03-25T18:26:23+00:00",
    "commented_code": "return;\n   }\n \n-  return object.at\n-    ? object.at(index)\n-    : object[index < 0 ? object.length + index : index];\n+  if (Array.isArray(object)) {",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1148413485",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14590,
        "pr_file": "scripts/build/shims/at.js",
        "discussion_id": "1148413485",
        "commented_code": "@@ -10,9 +10,10 @@ const at = (isOptionalObject, object, index) => {\n     return;\n   }\n \n-  return object.at\n-    ? object.at(index)\n-    : object[index < 0 ? object.length + index : index];\n+  if (Array.isArray(object)) {",
        "comment_created_at": "2023-03-25T18:26:23+00:00",
        "comment_author": "sosukesuzuki",
        "comment_body": "I am wondering if we should include brand checking for safety...",
        "pr_file_module": null
      },
      {
        "comment_id": "1148413934",
        "repo_full_name": "prettier/prettier",
        "pr_number": 14590,
        "pr_file": "scripts/build/shims/at.js",
        "discussion_id": "1148413485",
        "commented_code": "@@ -10,9 +10,10 @@ const at = (isOptionalObject, object, index) => {\n     return;\n   }\n \n-  return object.at\n-    ? object.at(index)\n-    : object[index < 0 ? object.length + index : index];\n+  if (Array.isArray(object)) {",
        "comment_created_at": "2023-03-25T18:30:50+00:00",
        "comment_author": "fisker",
        "comment_body": ".at not only available on array, but we can check array and string only for now. We probably won't use TypedArray, and the transform only works for files (not packages) now. https://github.com/prettier/prettier/blob/4edb68ac50a847bef0d2968e1a1e4de643add7b0/scripts/build/transform/index.js#L13",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1039326992",
    "pr_number": 13919,
    "pr_file": "src/language-js/print/statement.js",
    "created_at": "2022-12-05T09:07:38+00:00",
    "commented_code": "type === \"ClassProperty\" ||\n   type === \"PropertyDefinition\" ||\n   type === \"ClassPrivateProperty\" ||\n-  type === \"ClassAccessorProperty\";\n+  type === \"ClassAccessorProperty\" ||\n+  type === \"AccessorProperty\" ||\n+  type === \"TSAbstractAccessorProperty\";\n /**\n  * @returns {boolean}\n  */\n function shouldPrintSemicolonAfterClassProperty(node, nextNode) {\n   const name = node.key && node.key.name;",
    "repo_full_name": "prettier/prettier",
    "discussion_comments": [
      {
        "comment_id": "1039326992",
        "repo_full_name": "prettier/prettier",
        "pr_number": 13919,
        "pr_file": "src/language-js/print/statement.js",
        "discussion_id": "1039326992",
        "commented_code": "@@ -168,14 +168,19 @@ const isClassProperty = ({ type }) =>\n   type === \"ClassProperty\" ||\n   type === \"PropertyDefinition\" ||\n   type === \"ClassPrivateProperty\" ||\n-  type === \"ClassAccessorProperty\";\n+  type === \"ClassAccessorProperty\" ||\n+  type === \"AccessorProperty\" ||\n+  type === \"TSAbstractAccessorProperty\";\n /**\n  * @returns {boolean}\n  */\n function shouldPrintSemicolonAfterClassProperty(node, nextNode) {\n   const name = node.key && node.key.name;",
        "comment_created_at": "2022-12-05T09:07:38+00:00",
        "comment_author": "fisker",
        "comment_body": "Since we are here. Let's remove this chaining, I don't think the `key` can be nullish here.\r\n\r\n```suggestion\r\n  const { name } = node.key;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]