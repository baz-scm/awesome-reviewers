[
  {
    "discussion_id": "879588112",
    "pr_number": 13100,
    "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
    "created_at": "2022-05-23T15:24:37+00:00",
    "commented_code": "sum: () => getDeprecationString('2.23.0', '_sum'),\n   min: () => getDeprecationString('2.23.0', '_min'),\n   max: () => getDeprecationString('2.23.0', '_max'),\n-  distinct: (singular, plural) => addLinkToDocs(`Filter by unique combinations of ${plural}.`, 'distinct'),\n-  orderBy: (singular, plural) => addLinkToDocs(`Determine the order of ${plural} to fetch.`, 'sorting'),\n+  distinct: (singular) => addLinkToDocs(`Filter by unique combinations of '${singular}'.`, 'distinct'),\n+  orderBy: (singular) => addLinkToDocs(`Determine the order of '${singular}' to fetch.`, 'sorting'),\n }\n export const JSDocs: JSDocsType = {\n   groupBy: {\n-    body: (ctx) => `Group by ${ctx.singular}.\n-${undefinedNote}\n-@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n-@example\n-// Group by city, order by createdAt, get count\n-const result = await prisma.user.groupBy({\n-  by: ['city', 'createdAt'],\n-  orderBy: {\n-    createdAt: true\n-  },\n-  _count: {\n-    _all: true\n-  },\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Group by '${ctx.singular}'.\n+      ${undefinedNote}\n+      @param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n+      @example\n+      // Group by city, order by createdAt, get count\n+      const result = await prisma.user.groupBy({\n+        by: ['city', 'createdAt'],\n+        orderBy: {\n+          createdAt: true\n+        },\n+        _count: {\n+          _all: true\n+        },\n+      })\n+    `,\n     fields: {},\n   },\n   create: {\n-    body: (ctx) => `Create a ${ctx.singular}.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n-@example\n-// Create one ${ctx.singular}\n-const ${ctx.singular} = await ${ctx.method}({\n-  data: {\n-    // ... data to create a ${ctx.singular}\n-  }\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Create a ${ctx.singular}.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n+      @example\n+      // Create one ${ctx.singular}\n+      const ${ctx.singular} = await ${ctx.method}({\n+        data: {\n+          // ... data to create a ${ctx.singular}\n+        }\n+      })\n+    `,\n     fields: {\n       data: (singular) => `The data needed to create a ${singular}.`,\n     },\n   },\n   createMany: {\n-    body: (ctx) => `Create many ${ctx.plural}.\n-    @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.\n-    @example\n-    // Create many ${ctx.plural}\n-    const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-      data: {\n-        // ... provide data here\n-      }\n-    })\n+    body: (ctx) => dedent`\n+      Create many '${ctx.singular}'.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many '${ctx.singular}'.\n+      @example\n+      // Create many '${ctx.singular}'\n+      const results = await ${ctx.method}({\n+        data: {\n+          // ... provide data here\n+        }\n+      })\n     `,\n     fields: {\n-      data: (singular, plural) => `The data used to create many ${plural}.`,\n+      data: (singular) => `The data used to create many '${singular}'.`,\n     },\n   },\n   findUnique: {\n-    body: (ctx) =>\n-      `Find zero or one ${ctx.singular} that matches the filter.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}\n-@example\n-// Get one ${ctx.singular}\n-const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-  where: {\n-    // ... provide filter here\n-  }\n-})`,\n+    body: (ctx) => dedent`\n+      Find one ${ctx.singular} that matches the filter.",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "879588112",
        "repo_full_name": "prisma/prisma",
        "pr_number": 13100,
        "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
        "discussion_id": "879588112",
        "commented_code": "@@ -54,89 +54,94 @@ const JSDocFields = {\n   sum: () => getDeprecationString('2.23.0', '_sum'),\n   min: () => getDeprecationString('2.23.0', '_min'),\n   max: () => getDeprecationString('2.23.0', '_max'),\n-  distinct: (singular, plural) => addLinkToDocs(`Filter by unique combinations of ${plural}.`, 'distinct'),\n-  orderBy: (singular, plural) => addLinkToDocs(`Determine the order of ${plural} to fetch.`, 'sorting'),\n+  distinct: (singular) => addLinkToDocs(`Filter by unique combinations of '${singular}'.`, 'distinct'),\n+  orderBy: (singular) => addLinkToDocs(`Determine the order of '${singular}' to fetch.`, 'sorting'),\n }\n export const JSDocs: JSDocsType = {\n   groupBy: {\n-    body: (ctx) => `Group by ${ctx.singular}.\n-${undefinedNote}\n-@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n-@example\n-// Group by city, order by createdAt, get count\n-const result = await prisma.user.groupBy({\n-  by: ['city', 'createdAt'],\n-  orderBy: {\n-    createdAt: true\n-  },\n-  _count: {\n-    _all: true\n-  },\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Group by '${ctx.singular}'.\n+      ${undefinedNote}\n+      @param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n+      @example\n+      // Group by city, order by createdAt, get count\n+      const result = await prisma.user.groupBy({\n+        by: ['city', 'createdAt'],\n+        orderBy: {\n+          createdAt: true\n+        },\n+        _count: {\n+          _all: true\n+        },\n+      })\n+    `,\n     fields: {},\n   },\n   create: {\n-    body: (ctx) => `Create a ${ctx.singular}.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n-@example\n-// Create one ${ctx.singular}\n-const ${ctx.singular} = await ${ctx.method}({\n-  data: {\n-    // ... data to create a ${ctx.singular}\n-  }\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Create a ${ctx.singular}.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n+      @example\n+      // Create one ${ctx.singular}\n+      const ${ctx.singular} = await ${ctx.method}({\n+        data: {\n+          // ... data to create a ${ctx.singular}\n+        }\n+      })\n+    `,\n     fields: {\n       data: (singular) => `The data needed to create a ${singular}.`,\n     },\n   },\n   createMany: {\n-    body: (ctx) => `Create many ${ctx.plural}.\n-    @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.\n-    @example\n-    // Create many ${ctx.plural}\n-    const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-      data: {\n-        // ... provide data here\n-      }\n-    })\n+    body: (ctx) => dedent`\n+      Create many '${ctx.singular}'.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many '${ctx.singular}'.\n+      @example\n+      // Create many '${ctx.singular}'\n+      const results = await ${ctx.method}({\n+        data: {\n+          // ... provide data here\n+        }\n+      })\n     `,\n     fields: {\n-      data: (singular, plural) => `The data used to create many ${plural}.`,\n+      data: (singular) => `The data used to create many '${singular}'.`,\n     },\n   },\n   findUnique: {\n-    body: (ctx) =>\n-      `Find zero or one ${ctx.singular} that matches the filter.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}\n-@example\n-// Get one ${ctx.singular}\n-const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-  where: {\n-    // ... provide filter here\n-  }\n-})`,\n+    body: (ctx) => dedent`\n+      Find one ${ctx.singular} that matches the filter.",
        "comment_created_at": "2022-05-23T15:24:37+00:00",
        "comment_author": "aqrln",
        "comment_body": "Why was the meaning of the comment changed? \"Zero or one\" sounds correct to me (i.e., the result can be `null`).",
        "pr_file_module": null
      },
      {
        "comment_id": "879589706",
        "repo_full_name": "prisma/prisma",
        "pr_number": 13100,
        "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
        "discussion_id": "879588112",
        "commented_code": "@@ -54,89 +54,94 @@ const JSDocFields = {\n   sum: () => getDeprecationString('2.23.0', '_sum'),\n   min: () => getDeprecationString('2.23.0', '_min'),\n   max: () => getDeprecationString('2.23.0', '_max'),\n-  distinct: (singular, plural) => addLinkToDocs(`Filter by unique combinations of ${plural}.`, 'distinct'),\n-  orderBy: (singular, plural) => addLinkToDocs(`Determine the order of ${plural} to fetch.`, 'sorting'),\n+  distinct: (singular) => addLinkToDocs(`Filter by unique combinations of '${singular}'.`, 'distinct'),\n+  orderBy: (singular) => addLinkToDocs(`Determine the order of '${singular}' to fetch.`, 'sorting'),\n }\n export const JSDocs: JSDocsType = {\n   groupBy: {\n-    body: (ctx) => `Group by ${ctx.singular}.\n-${undefinedNote}\n-@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n-@example\n-// Group by city, order by createdAt, get count\n-const result = await prisma.user.groupBy({\n-  by: ['city', 'createdAt'],\n-  orderBy: {\n-    createdAt: true\n-  },\n-  _count: {\n-    _all: true\n-  },\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Group by '${ctx.singular}'.\n+      ${undefinedNote}\n+      @param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n+      @example\n+      // Group by city, order by createdAt, get count\n+      const result = await prisma.user.groupBy({\n+        by: ['city', 'createdAt'],\n+        orderBy: {\n+          createdAt: true\n+        },\n+        _count: {\n+          _all: true\n+        },\n+      })\n+    `,\n     fields: {},\n   },\n   create: {\n-    body: (ctx) => `Create a ${ctx.singular}.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n-@example\n-// Create one ${ctx.singular}\n-const ${ctx.singular} = await ${ctx.method}({\n-  data: {\n-    // ... data to create a ${ctx.singular}\n-  }\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Create a ${ctx.singular}.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n+      @example\n+      // Create one ${ctx.singular}\n+      const ${ctx.singular} = await ${ctx.method}({\n+        data: {\n+          // ... data to create a ${ctx.singular}\n+        }\n+      })\n+    `,\n     fields: {\n       data: (singular) => `The data needed to create a ${singular}.`,\n     },\n   },\n   createMany: {\n-    body: (ctx) => `Create many ${ctx.plural}.\n-    @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.\n-    @example\n-    // Create many ${ctx.plural}\n-    const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-      data: {\n-        // ... provide data here\n-      }\n-    })\n+    body: (ctx) => dedent`\n+      Create many '${ctx.singular}'.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many '${ctx.singular}'.\n+      @example\n+      // Create many '${ctx.singular}'\n+      const results = await ${ctx.method}({\n+        data: {\n+          // ... provide data here\n+        }\n+      })\n     `,\n     fields: {\n-      data: (singular, plural) => `The data used to create many ${plural}.`,\n+      data: (singular) => `The data used to create many '${singular}'.`,\n     },\n   },\n   findUnique: {\n-    body: (ctx) =>\n-      `Find zero or one ${ctx.singular} that matches the filter.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}\n-@example\n-// Get one ${ctx.singular}\n-const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-  where: {\n-    // ... provide filter here\n-  }\n-})`,\n+    body: (ctx) => dedent`\n+      Find one ${ctx.singular} that matches the filter.",
        "comment_created_at": "2022-05-23T15:26:00+00:00",
        "comment_author": "aqrln",
        "comment_body": "although \"find one\" is probably fine too",
        "pr_file_module": null
      },
      {
        "comment_id": "879590175",
        "repo_full_name": "prisma/prisma",
        "pr_number": 13100,
        "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
        "discussion_id": "879588112",
        "commented_code": "@@ -54,89 +54,94 @@ const JSDocFields = {\n   sum: () => getDeprecationString('2.23.0', '_sum'),\n   min: () => getDeprecationString('2.23.0', '_min'),\n   max: () => getDeprecationString('2.23.0', '_max'),\n-  distinct: (singular, plural) => addLinkToDocs(`Filter by unique combinations of ${plural}.`, 'distinct'),\n-  orderBy: (singular, plural) => addLinkToDocs(`Determine the order of ${plural} to fetch.`, 'sorting'),\n+  distinct: (singular) => addLinkToDocs(`Filter by unique combinations of '${singular}'.`, 'distinct'),\n+  orderBy: (singular) => addLinkToDocs(`Determine the order of '${singular}' to fetch.`, 'sorting'),\n }\n export const JSDocs: JSDocsType = {\n   groupBy: {\n-    body: (ctx) => `Group by ${ctx.singular}.\n-${undefinedNote}\n-@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n-@example\n-// Group by city, order by createdAt, get count\n-const result = await prisma.user.groupBy({\n-  by: ['city', 'createdAt'],\n-  orderBy: {\n-    createdAt: true\n-  },\n-  _count: {\n-    _all: true\n-  },\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Group by '${ctx.singular}'.\n+      ${undefinedNote}\n+      @param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n+      @example\n+      // Group by city, order by createdAt, get count\n+      const result = await prisma.user.groupBy({\n+        by: ['city', 'createdAt'],\n+        orderBy: {\n+          createdAt: true\n+        },\n+        _count: {\n+          _all: true\n+        },\n+      })\n+    `,\n     fields: {},\n   },\n   create: {\n-    body: (ctx) => `Create a ${ctx.singular}.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n-@example\n-// Create one ${ctx.singular}\n-const ${ctx.singular} = await ${ctx.method}({\n-  data: {\n-    // ... data to create a ${ctx.singular}\n-  }\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Create a ${ctx.singular}.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n+      @example\n+      // Create one ${ctx.singular}\n+      const ${ctx.singular} = await ${ctx.method}({\n+        data: {\n+          // ... data to create a ${ctx.singular}\n+        }\n+      })\n+    `,\n     fields: {\n       data: (singular) => `The data needed to create a ${singular}.`,\n     },\n   },\n   createMany: {\n-    body: (ctx) => `Create many ${ctx.plural}.\n-    @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.\n-    @example\n-    // Create many ${ctx.plural}\n-    const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-      data: {\n-        // ... provide data here\n-      }\n-    })\n+    body: (ctx) => dedent`\n+      Create many '${ctx.singular}'.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many '${ctx.singular}'.\n+      @example\n+      // Create many '${ctx.singular}'\n+      const results = await ${ctx.method}({\n+        data: {\n+          // ... provide data here\n+        }\n+      })\n     `,\n     fields: {\n-      data: (singular, plural) => `The data used to create many ${plural}.`,\n+      data: (singular) => `The data used to create many '${singular}'.`,\n     },\n   },\n   findUnique: {\n-    body: (ctx) =>\n-      `Find zero or one ${ctx.singular} that matches the filter.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}\n-@example\n-// Get one ${ctx.singular}\n-const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-  where: {\n-    // ... provide filter here\n-  }\n-})`,\n+    body: (ctx) => dedent`\n+      Find one ${ctx.singular} that matches the filter.",
        "comment_created_at": "2022-05-23T15:26:25+00:00",
        "comment_author": "aqrln",
        "comment_body": "@millsp @SevInf what do you think about this one?",
        "pr_file_module": null
      },
      {
        "comment_id": "879635913",
        "repo_full_name": "prisma/prisma",
        "pr_number": 13100,
        "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
        "discussion_id": "879588112",
        "commented_code": "@@ -54,89 +54,94 @@ const JSDocFields = {\n   sum: () => getDeprecationString('2.23.0', '_sum'),\n   min: () => getDeprecationString('2.23.0', '_min'),\n   max: () => getDeprecationString('2.23.0', '_max'),\n-  distinct: (singular, plural) => addLinkToDocs(`Filter by unique combinations of ${plural}.`, 'distinct'),\n-  orderBy: (singular, plural) => addLinkToDocs(`Determine the order of ${plural} to fetch.`, 'sorting'),\n+  distinct: (singular) => addLinkToDocs(`Filter by unique combinations of '${singular}'.`, 'distinct'),\n+  orderBy: (singular) => addLinkToDocs(`Determine the order of '${singular}' to fetch.`, 'sorting'),\n }\n export const JSDocs: JSDocsType = {\n   groupBy: {\n-    body: (ctx) => `Group by ${ctx.singular}.\n-${undefinedNote}\n-@param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n-@example\n-// Group by city, order by createdAt, get count\n-const result = await prisma.user.groupBy({\n-  by: ['city', 'createdAt'],\n-  orderBy: {\n-    createdAt: true\n-  },\n-  _count: {\n-    _all: true\n-  },\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Group by '${ctx.singular}'.\n+      ${undefinedNote}\n+      @param {${getGroupByArgsName(ctx.model.name)}} args - Group by arguments.\n+      @example\n+      // Group by city, order by createdAt, get count\n+      const result = await prisma.user.groupBy({\n+        by: ['city', 'createdAt'],\n+        orderBy: {\n+          createdAt: true\n+        },\n+        _count: {\n+          _all: true\n+        },\n+      })\n+    `,\n     fields: {},\n   },\n   create: {\n-    body: (ctx) => `Create a ${ctx.singular}.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n-@example\n-// Create one ${ctx.singular}\n-const ${ctx.singular} = await ${ctx.method}({\n-  data: {\n-    // ... data to create a ${ctx.singular}\n-  }\n-})\n-`,\n+    body: (ctx) => dedent`\n+      Create a ${ctx.singular}.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create a ${ctx.singular}.\n+      @example\n+      // Create one ${ctx.singular}\n+      const ${ctx.singular} = await ${ctx.method}({\n+        data: {\n+          // ... data to create a ${ctx.singular}\n+        }\n+      })\n+    `,\n     fields: {\n       data: (singular) => `The data needed to create a ${singular}.`,\n     },\n   },\n   createMany: {\n-    body: (ctx) => `Create many ${ctx.plural}.\n-    @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many ${ctx.plural}.\n-    @example\n-    // Create many ${ctx.plural}\n-    const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-      data: {\n-        // ... provide data here\n-      }\n-    })\n+    body: (ctx) => dedent`\n+      Create many '${ctx.singular}'.\n+      @param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to create many '${ctx.singular}'.\n+      @example\n+      // Create many '${ctx.singular}'\n+      const results = await ${ctx.method}({\n+        data: {\n+          // ... provide data here\n+        }\n+      })\n     `,\n     fields: {\n-      data: (singular, plural) => `The data used to create many ${plural}.`,\n+      data: (singular) => `The data used to create many '${singular}'.`,\n     },\n   },\n   findUnique: {\n-    body: (ctx) =>\n-      `Find zero or one ${ctx.singular} that matches the filter.\n-@param {${getModelArgName(ctx.model.name, ctx.action)}} args - Arguments to find a ${ctx.singular}\n-@example\n-// Get one ${ctx.singular}\n-const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n-  where: {\n-    // ... provide filter here\n-  }\n-})`,\n+    body: (ctx) => dedent`\n+      Find one ${ctx.singular} that matches the filter.",
        "comment_created_at": "2022-05-23T16:03:51+00:00",
        "comment_author": "SevInf",
        "comment_body": "@aqrln @danstarns How about something like this:\r\n\r\n```\r\nReturns ${ctx.singular} that matches the filter or `null` if nothing is found\r\n```\r\n\r\nI am ignoring `rejectOnNotFound` here since it up for deprecation. Also, not enteriely sure if it is `null` or `undefined` in second case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "879596394",
    "pr_number": 13100,
    "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
    "created_at": "2022-05-23T15:31:42+00:00",
    "commented_code": "body: (ctx) => {\n       const onlySelect = ctx.firstScalar\n         ? `\n// Only select the \\`${ctx.firstScalar.name}\\`\n-const ${lowerCase(ctx.mapping.model)}With${capitalize(ctx.firstScalar.name)}Only = await ${ctx.method}({ select: { ${\n+const resultsWith${capitalize(ctx.firstScalar.name)}Only = await ${ctx.method}({ select: { ${\n             ctx.firstScalar.name\n           }: true } })`\n         : ''\n \n-      return `Find zero or more ${ctx.plural} that matches the filter.\n-${undefinedNote}\n-@param {${getModelArgName(ctx.model.name, ctx.action)}=} args - Arguments to filter and select certain fields only.\n-@example\n-// Get all ${ctx.plural}\n-const ${ctx.mapping.plural} = await ${ctx.method}()\n-\n-// Get first 10 ${ctx.plural}\n-const ${ctx.mapping.plural} = await ${ctx.method}({ take: 10 })\n-${onlySelect}\n-`\n+      return dedent`\n+        Find one or more '${ctx.singular}' that matches the filter.",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "879596394",
        "repo_full_name": "prisma/prisma",
        "pr_number": 13100,
        "pr_file": "packages/client/src/generation/TSClient/jsdoc.ts",
        "discussion_id": "879596394",
        "commented_code": "@@ -146,68 +151,73 @@ const ${lowerCase(ctx.mapping.model)} = await ${ctx.method}({\n     body: (ctx) => {\n       const onlySelect = ctx.firstScalar\n         ? `\\n// Only select the \\`${ctx.firstScalar.name}\\`\n-const ${lowerCase(ctx.mapping.model)}With${capitalize(ctx.firstScalar.name)}Only = await ${ctx.method}({ select: { ${\n+const resultsWith${capitalize(ctx.firstScalar.name)}Only = await ${ctx.method}({ select: { ${\n             ctx.firstScalar.name\n           }: true } })`\n         : ''\n \n-      return `Find zero or more ${ctx.plural} that matches the filter.\n-${undefinedNote}\n-@param {${getModelArgName(ctx.model.name, ctx.action)}=} args - Arguments to filter and select certain fields only.\n-@example\n-// Get all ${ctx.plural}\n-const ${ctx.mapping.plural} = await ${ctx.method}()\n-\n-// Get first 10 ${ctx.plural}\n-const ${ctx.mapping.plural} = await ${ctx.method}({ take: 10 })\n-${onlySelect}\n-`\n+      return dedent`\n+        Find one or more '${ctx.singular}' that matches the filter.",
        "comment_created_at": "2022-05-23T15:31:42+00:00",
        "comment_author": "aqrln",
        "comment_body": "The meaning of the comment was changed. I don't think \"one or more\" is correct for `findMany`, \"zero or more\" was correct.",
        "pr_file_module": null
      }
    ]
  }
]