[
  {
    "discussion_id": "2166514547",
    "pr_number": 27489,
    "pr_file": "packages/adapter-mariadb/src/conversion.ts",
    "created_at": "2025-06-25T11:44:38+00:00",
    "commented_code": "+import { ColumnType, ColumnTypeEnum } from '@prisma/driver-adapter-utils'\n+import * as mariadb from 'mariadb'\n+\n+const UNSIGNED_FLAG = 1 << 5\n+const BINARY_FLAG = 1 << 7\n+\n+const enum MariaDbColumnType {\n+  DECIMAL = 'DECIMAL',\n+  TINY = 'TINY',\n+  SHORT = 'SHORT',\n+  INT = 'INT',\n+  LONG = 'LONG',\n+  FLOAT = 'FLOAT',\n+  DOUBLE = 'DOUBLE',\n+  NULL = 'NULL',\n+  TIMESTAMP = 'TIMESTAMP',\n+  BIGINT = 'BIGINT',\n+  INT24 = 'INT24',\n+  DATE = 'DATE',\n+  TIME = 'TIME',\n+  DATETIME = 'DATETIME',\n+  YEAR = 'YEAR',\n+  NEWDATE = 'NEWDATE',\n+  VARCHAR = 'VARCHAR',\n+  BIT = 'BIT',\n+  TIMESTAMP2 = 'TIMESTAMP2',\n+  DATETIME2 = 'DATETIME2',\n+  TIME2 = 'TIME2',\n+  JSON = 'JSON',\n+  NEWDECIMAL = 'NEWDECIMAL',\n+  ENUM = 'ENUM',\n+  SET = 'SET',\n+  TINY_BLOB = 'TINY_BLOB',\n+  MEDIUM_BLOB = 'MEDIUM_BLOB',\n+  LONG_BLOB = 'LONG_BLOB',\n+  BLOB = 'BLOB',\n+  VAR_STRING = 'VAR_STRING',\n+  STRING = 'STRING',\n+  GEOMETRY = 'GEOMETRY',\n+}\n+\n+export function mapColumnType(field: mariadb.FieldInfo): ColumnType {\n+  switch (field.type as unknown as MariaDbColumnType) {\n+    case MariaDbColumnType.TINY:\n+    case MariaDbColumnType.SHORT:\n+    case MariaDbColumnType.INT24:\n+    case MariaDbColumnType.YEAR:\n+      return ColumnTypeEnum.Int32\n+    case MariaDbColumnType.INT:\n+      if (field.flags.valueOf() & UNSIGNED_FLAG) {\n+        return ColumnTypeEnum.Int64\n+      } else {\n+        return ColumnTypeEnum.Int32\n+      }\n+    case MariaDbColumnType.LONG:\n+    case MariaDbColumnType.BIGINT:\n+      return ColumnTypeEnum.Int64\n+    case MariaDbColumnType.FLOAT:\n+      return ColumnTypeEnum.Float\n+    case MariaDbColumnType.DOUBLE:\n+      return ColumnTypeEnum.Double\n+    case MariaDbColumnType.TIMESTAMP:\n+    case MariaDbColumnType.TIMESTAMP2:\n+    case MariaDbColumnType.DATETIME:\n+    case MariaDbColumnType.DATETIME2:\n+      return ColumnTypeEnum.DateTime\n+    case MariaDbColumnType.DATE:\n+    case MariaDbColumnType.NEWDATE:\n+      return ColumnTypeEnum.Date\n+    case MariaDbColumnType.TIME:\n+      return ColumnTypeEnum.Time\n+    case MariaDbColumnType.DECIMAL:\n+    case MariaDbColumnType.NEWDECIMAL:\n+      return ColumnTypeEnum.Numeric\n+    case MariaDbColumnType.VARCHAR:\n+    case MariaDbColumnType.VAR_STRING:\n+    case MariaDbColumnType.STRING:\n+      if (field.flags.valueOf() & BINARY_FLAG) {\n+        return ColumnTypeEnum.Bytes\n+      } else {\n+        return ColumnTypeEnum.Text\n+      }\n+    case MariaDbColumnType.ENUM:\n+      return ColumnTypeEnum.Enum\n+    case MariaDbColumnType.JSON:\n+      return ColumnTypeEnum.Json\n+    case MariaDbColumnType.BLOB:\n+    case MariaDbColumnType.TINY_BLOB:\n+    case MariaDbColumnType.MEDIUM_BLOB:\n+    case MariaDbColumnType.BIT:\n+    case MariaDbColumnType.GEOMETRY:\n+      return ColumnTypeEnum.Bytes\n+    case MariaDbColumnType.NULL:\n+      // Fall back to Int32 for consistency with quaint.\n+      return ColumnTypeEnum.Int32\n+    default:\n+      throw new Error(`Unsupported column type: ${field.type}`)\n+  }\n+}\n+\n+export function mapArg(arg: unknown): unknown {\n+  if (arg instanceof Uint8Array) {\n+    return Buffer.from(arg)",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2166514547",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27489,
        "pr_file": "packages/adapter-mariadb/src/conversion.ts",
        "discussion_id": "2166514547",
        "commented_code": "@@ -0,0 +1,140 @@\n+import { ColumnType, ColumnTypeEnum } from '@prisma/driver-adapter-utils'\n+import * as mariadb from 'mariadb'\n+\n+const UNSIGNED_FLAG = 1 << 5\n+const BINARY_FLAG = 1 << 7\n+\n+const enum MariaDbColumnType {\n+  DECIMAL = 'DECIMAL',\n+  TINY = 'TINY',\n+  SHORT = 'SHORT',\n+  INT = 'INT',\n+  LONG = 'LONG',\n+  FLOAT = 'FLOAT',\n+  DOUBLE = 'DOUBLE',\n+  NULL = 'NULL',\n+  TIMESTAMP = 'TIMESTAMP',\n+  BIGINT = 'BIGINT',\n+  INT24 = 'INT24',\n+  DATE = 'DATE',\n+  TIME = 'TIME',\n+  DATETIME = 'DATETIME',\n+  YEAR = 'YEAR',\n+  NEWDATE = 'NEWDATE',\n+  VARCHAR = 'VARCHAR',\n+  BIT = 'BIT',\n+  TIMESTAMP2 = 'TIMESTAMP2',\n+  DATETIME2 = 'DATETIME2',\n+  TIME2 = 'TIME2',\n+  JSON = 'JSON',\n+  NEWDECIMAL = 'NEWDECIMAL',\n+  ENUM = 'ENUM',\n+  SET = 'SET',\n+  TINY_BLOB = 'TINY_BLOB',\n+  MEDIUM_BLOB = 'MEDIUM_BLOB',\n+  LONG_BLOB = 'LONG_BLOB',\n+  BLOB = 'BLOB',\n+  VAR_STRING = 'VAR_STRING',\n+  STRING = 'STRING',\n+  GEOMETRY = 'GEOMETRY',\n+}\n+\n+export function mapColumnType(field: mariadb.FieldInfo): ColumnType {\n+  switch (field.type as unknown as MariaDbColumnType) {\n+    case MariaDbColumnType.TINY:\n+    case MariaDbColumnType.SHORT:\n+    case MariaDbColumnType.INT24:\n+    case MariaDbColumnType.YEAR:\n+      return ColumnTypeEnum.Int32\n+    case MariaDbColumnType.INT:\n+      if (field.flags.valueOf() & UNSIGNED_FLAG) {\n+        return ColumnTypeEnum.Int64\n+      } else {\n+        return ColumnTypeEnum.Int32\n+      }\n+    case MariaDbColumnType.LONG:\n+    case MariaDbColumnType.BIGINT:\n+      return ColumnTypeEnum.Int64\n+    case MariaDbColumnType.FLOAT:\n+      return ColumnTypeEnum.Float\n+    case MariaDbColumnType.DOUBLE:\n+      return ColumnTypeEnum.Double\n+    case MariaDbColumnType.TIMESTAMP:\n+    case MariaDbColumnType.TIMESTAMP2:\n+    case MariaDbColumnType.DATETIME:\n+    case MariaDbColumnType.DATETIME2:\n+      return ColumnTypeEnum.DateTime\n+    case MariaDbColumnType.DATE:\n+    case MariaDbColumnType.NEWDATE:\n+      return ColumnTypeEnum.Date\n+    case MariaDbColumnType.TIME:\n+      return ColumnTypeEnum.Time\n+    case MariaDbColumnType.DECIMAL:\n+    case MariaDbColumnType.NEWDECIMAL:\n+      return ColumnTypeEnum.Numeric\n+    case MariaDbColumnType.VARCHAR:\n+    case MariaDbColumnType.VAR_STRING:\n+    case MariaDbColumnType.STRING:\n+      if (field.flags.valueOf() & BINARY_FLAG) {\n+        return ColumnTypeEnum.Bytes\n+      } else {\n+        return ColumnTypeEnum.Text\n+      }\n+    case MariaDbColumnType.ENUM:\n+      return ColumnTypeEnum.Enum\n+    case MariaDbColumnType.JSON:\n+      return ColumnTypeEnum.Json\n+    case MariaDbColumnType.BLOB:\n+    case MariaDbColumnType.TINY_BLOB:\n+    case MariaDbColumnType.MEDIUM_BLOB:\n+    case MariaDbColumnType.BIT:\n+    case MariaDbColumnType.GEOMETRY:\n+      return ColumnTypeEnum.Bytes\n+    case MariaDbColumnType.NULL:\n+      // Fall back to Int32 for consistency with quaint.\n+      return ColumnTypeEnum.Int32\n+    default:\n+      throw new Error(`Unsupported column type: ${field.type}`)\n+  }\n+}\n+\n+export function mapArg(arg: unknown): unknown {\n+  if (arg instanceof Uint8Array) {\n+    return Buffer.from(arg)",
        "comment_created_at": "2025-06-25T11:44:38+00:00",
        "comment_author": "aqrln",
        "comment_body": "```suggestion\r\n    return Buffer.from(arg.buffer, arg.byteOffset, arg.byteLength)\r\n```\r\nto share the underlying `ArrayBuffer` instead of cloning the data",
        "pr_file_module": null
      },
      {
        "comment_id": "2166530905",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27489,
        "pr_file": "packages/adapter-mariadb/src/conversion.ts",
        "discussion_id": "2166514547",
        "commented_code": "@@ -0,0 +1,140 @@\n+import { ColumnType, ColumnTypeEnum } from '@prisma/driver-adapter-utils'\n+import * as mariadb from 'mariadb'\n+\n+const UNSIGNED_FLAG = 1 << 5\n+const BINARY_FLAG = 1 << 7\n+\n+const enum MariaDbColumnType {\n+  DECIMAL = 'DECIMAL',\n+  TINY = 'TINY',\n+  SHORT = 'SHORT',\n+  INT = 'INT',\n+  LONG = 'LONG',\n+  FLOAT = 'FLOAT',\n+  DOUBLE = 'DOUBLE',\n+  NULL = 'NULL',\n+  TIMESTAMP = 'TIMESTAMP',\n+  BIGINT = 'BIGINT',\n+  INT24 = 'INT24',\n+  DATE = 'DATE',\n+  TIME = 'TIME',\n+  DATETIME = 'DATETIME',\n+  YEAR = 'YEAR',\n+  NEWDATE = 'NEWDATE',\n+  VARCHAR = 'VARCHAR',\n+  BIT = 'BIT',\n+  TIMESTAMP2 = 'TIMESTAMP2',\n+  DATETIME2 = 'DATETIME2',\n+  TIME2 = 'TIME2',\n+  JSON = 'JSON',\n+  NEWDECIMAL = 'NEWDECIMAL',\n+  ENUM = 'ENUM',\n+  SET = 'SET',\n+  TINY_BLOB = 'TINY_BLOB',\n+  MEDIUM_BLOB = 'MEDIUM_BLOB',\n+  LONG_BLOB = 'LONG_BLOB',\n+  BLOB = 'BLOB',\n+  VAR_STRING = 'VAR_STRING',\n+  STRING = 'STRING',\n+  GEOMETRY = 'GEOMETRY',\n+}\n+\n+export function mapColumnType(field: mariadb.FieldInfo): ColumnType {\n+  switch (field.type as unknown as MariaDbColumnType) {\n+    case MariaDbColumnType.TINY:\n+    case MariaDbColumnType.SHORT:\n+    case MariaDbColumnType.INT24:\n+    case MariaDbColumnType.YEAR:\n+      return ColumnTypeEnum.Int32\n+    case MariaDbColumnType.INT:\n+      if (field.flags.valueOf() & UNSIGNED_FLAG) {\n+        return ColumnTypeEnum.Int64\n+      } else {\n+        return ColumnTypeEnum.Int32\n+      }\n+    case MariaDbColumnType.LONG:\n+    case MariaDbColumnType.BIGINT:\n+      return ColumnTypeEnum.Int64\n+    case MariaDbColumnType.FLOAT:\n+      return ColumnTypeEnum.Float\n+    case MariaDbColumnType.DOUBLE:\n+      return ColumnTypeEnum.Double\n+    case MariaDbColumnType.TIMESTAMP:\n+    case MariaDbColumnType.TIMESTAMP2:\n+    case MariaDbColumnType.DATETIME:\n+    case MariaDbColumnType.DATETIME2:\n+      return ColumnTypeEnum.DateTime\n+    case MariaDbColumnType.DATE:\n+    case MariaDbColumnType.NEWDATE:\n+      return ColumnTypeEnum.Date\n+    case MariaDbColumnType.TIME:\n+      return ColumnTypeEnum.Time\n+    case MariaDbColumnType.DECIMAL:\n+    case MariaDbColumnType.NEWDECIMAL:\n+      return ColumnTypeEnum.Numeric\n+    case MariaDbColumnType.VARCHAR:\n+    case MariaDbColumnType.VAR_STRING:\n+    case MariaDbColumnType.STRING:\n+      if (field.flags.valueOf() & BINARY_FLAG) {\n+        return ColumnTypeEnum.Bytes\n+      } else {\n+        return ColumnTypeEnum.Text\n+      }\n+    case MariaDbColumnType.ENUM:\n+      return ColumnTypeEnum.Enum\n+    case MariaDbColumnType.JSON:\n+      return ColumnTypeEnum.Json\n+    case MariaDbColumnType.BLOB:\n+    case MariaDbColumnType.TINY_BLOB:\n+    case MariaDbColumnType.MEDIUM_BLOB:\n+    case MariaDbColumnType.BIT:\n+    case MariaDbColumnType.GEOMETRY:\n+      return ColumnTypeEnum.Bytes\n+    case MariaDbColumnType.NULL:\n+      // Fall back to Int32 for consistency with quaint.\n+      return ColumnTypeEnum.Int32\n+    default:\n+      throw new Error(`Unsupported column type: ${field.type}`)\n+  }\n+}\n+\n+export function mapArg(arg: unknown): unknown {\n+  if (arg instanceof Uint8Array) {\n+    return Buffer.from(arg)",
        "comment_created_at": "2025-06-25T11:52:53+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2158544420",
    "pr_number": 27460,
    "pr_file": "packages/client-engine-runtime/src/interpreter/serializeSql.ts",
    "created_at": "2025-06-20T09:59:03+00:00",
    "commented_code": "import { assertNever } from '../utils'\n \n export function serializeSql(resultSet: SqlResultSet): Record<string, unknown>[] {\n-  return resultSet.rows.map((row) =>\n-    row.reduce<Record<string, unknown>>((acc, value, index) => {\n-      const splitByDot = resultSet.columnNames[index].split('.')\n+  const mappers = resultSet.columnTypes.map((type) => {\n+    switch (type) {\n+      case ColumnTypeEnum.Bytes:\n+        return (value: unknown) => (Array.isArray(value) ? new Uint8Array(value) : value)\n+      default:\n+        return (value: unknown) => value\n+    }\n+  })\n+\n+  return resultSet.rows\n+    .map((row) => row.map((value, index) => mappers[index](value)))\n+    .map((row) =>\n+      row.reduce<Record<string, unknown>>((acc, value, index) => {",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2158544420",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27460,
        "pr_file": "packages/client-engine-runtime/src/interpreter/serializeSql.ts",
        "discussion_id": "2158544420",
        "commented_code": "@@ -3,25 +3,36 @@ import { type ColumnType, ColumnTypeEnum, type SqlResultSet } from '@prisma/driv\n import { assertNever } from '../utils'\n \n export function serializeSql(resultSet: SqlResultSet): Record<string, unknown>[] {\n-  return resultSet.rows.map((row) =>\n-    row.reduce<Record<string, unknown>>((acc, value, index) => {\n-      const splitByDot = resultSet.columnNames[index].split('.')\n+  const mappers = resultSet.columnTypes.map((type) => {\n+    switch (type) {\n+      case ColumnTypeEnum.Bytes:\n+        return (value: unknown) => (Array.isArray(value) ? new Uint8Array(value) : value)\n+      default:\n+        return (value: unknown) => value\n+    }\n+  })\n+\n+  return resultSet.rows\n+    .map((row) => row.map((value, index) => mappers[index](value)))\n+    .map((row) =>\n+      row.reduce<Record<string, unknown>>((acc, value, index) => {",
        "comment_created_at": "2025-06-20T09:59:03+00:00",
        "comment_author": "aqrln",
        "comment_body": "Probably better to inline the first `map`:\r\n\r\n```suggestion\r\n    .map((row) =>\r\n      row\r\n        .map((value, index) => mappers[index](value)))\r\n        .reduce<Record<string, unknown>>((acc, value, index) => {\r\n```\r\n\r\nThe `rows` array could be large, and `map` is not lazy in JavaScript but will allocate a whole new array each time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2158553348",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27460,
        "pr_file": "packages/client-engine-runtime/src/interpreter/serializeSql.ts",
        "discussion_id": "2158544420",
        "commented_code": "@@ -3,25 +3,36 @@ import { type ColumnType, ColumnTypeEnum, type SqlResultSet } from '@prisma/driv\n import { assertNever } from '../utils'\n \n export function serializeSql(resultSet: SqlResultSet): Record<string, unknown>[] {\n-  return resultSet.rows.map((row) =>\n-    row.reduce<Record<string, unknown>>((acc, value, index) => {\n-      const splitByDot = resultSet.columnNames[index].split('.')\n+  const mappers = resultSet.columnTypes.map((type) => {\n+    switch (type) {\n+      case ColumnTypeEnum.Bytes:\n+        return (value: unknown) => (Array.isArray(value) ? new Uint8Array(value) : value)\n+      default:\n+        return (value: unknown) => value\n+    }\n+  })\n+\n+  return resultSet.rows\n+    .map((row) => row.map((value, index) => mappers[index](value)))\n+    .map((row) =>\n+      row.reduce<Record<string, unknown>>((acc, value, index) => {",
        "comment_created_at": "2025-06-20T10:03:54+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "makes sense, updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2096075995",
    "pr_number": 27211,
    "pr_file": "packages/client-engine-runtime/src/interpreter/QueryInterpreter.ts",
    "created_at": "2025-05-19T16:09:20+00:00",
    "commented_code": "): Promise<Value> {\n     switch (node.type) {\n       case 'seq': {\n-        const results = await Promise.all(node.args.map((arg) => this.interpretNode(arg, queryable, scope, generators)))\n+        const results: Value[] = []",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2096075995",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27211,
        "pr_file": "packages/client-engine-runtime/src/interpreter/QueryInterpreter.ts",
        "discussion_id": "2096075995",
        "commented_code": "@@ -69,7 +69,11 @@ export class QueryInterpreter {\n   ): Promise<Value> {\n     switch (node.type) {\n       case 'seq': {\n-        const results = await Promise.all(node.args.map((arg) => this.interpretNode(arg, queryable, scope, generators)))\n+        const results: Value[] = []",
        "comment_created_at": "2025-05-19T16:09:20+00:00",
        "comment_author": "aqrln",
        "comment_body": "We don't actually need to store the array, we only need to return the last value.",
        "pr_file_module": null
      },
      {
        "comment_id": "2096098661",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27211,
        "pr_file": "packages/client-engine-runtime/src/interpreter/QueryInterpreter.ts",
        "discussion_id": "2096075995",
        "commented_code": "@@ -69,7 +69,11 @@ export class QueryInterpreter {\n   ): Promise<Value> {\n     switch (node.type) {\n       case 'seq': {\n-        const results = await Promise.all(node.args.map((arg) => this.interpretNode(arg, queryable, scope, generators)))\n+        const results: Value[] = []",
        "comment_created_at": "2025-05-19T16:22:40+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "true, updated the code",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084299487",
    "pr_number": 27127,
    "pr_file": "packages/client-engine-runtime/src/interpreter/DataMapper.ts",
    "created_at": "2025-05-12T09:51:04+00:00",
    "commented_code": "case 'Boolean':\n       return typeof value === 'boolean' ? value : value !== '0'\n     case 'Decimal':\n-      return typeof value === 'number' ? value : parseFloat(`${value}`)\n+      return typeof value === 'number' ? new Decimal(value) : new Decimal(`${value}`)\n     case 'Date':\n       return value instanceof Date ? value : new Date(`${value}`)\n     case 'Array': {\n       const values = value as unknown[]\n-      return values.map((v) => {\n-        mapValue(v, resultType.inner)\n-      })\n+      return values.map((v) => mapValue(v, resultType.inner))\n     }\n     case 'Object':\n-      return typeof value === 'object' ? value : { value: value }\n-    case 'Bytes':\n-      if (typeof value !== 'string') {\n-        throw new Error(`DataMapper: Bytes data is not a string, got: ${typeof value}`)\n+      return typeof value === 'string' ? value : JSON.stringify(value)\n+    case 'Bytes': {\n+      if (!Array.isArray(value)) {\n+        throw new Error(`DataMapper: Bytes data is invalid, got: ${typeof value}`)\n       }\n-      return value\n+      const { buffer, byteOffset, byteLength } = Buffer.from(value)\n+      return new Uint8Array(buffer, byteOffset, byteLength)",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2084299487",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27127,
        "pr_file": "packages/client-engine-runtime/src/interpreter/DataMapper.ts",
        "discussion_id": "2084299487",
        "commented_code": "@@ -89,22 +91,22 @@ function mapValue(value: unknown, resultType: PrismaValueType): unknown {\n     case 'Boolean':\n       return typeof value === 'boolean' ? value : value !== '0'\n     case 'Decimal':\n-      return typeof value === 'number' ? value : parseFloat(`${value}`)\n+      return typeof value === 'number' ? new Decimal(value) : new Decimal(`${value}`)\n     case 'Date':\n       return value instanceof Date ? value : new Date(`${value}`)\n     case 'Array': {\n       const values = value as unknown[]\n-      return values.map((v) => {\n-        mapValue(v, resultType.inner)\n-      })\n+      return values.map((v) => mapValue(v, resultType.inner))\n     }\n     case 'Object':\n-      return typeof value === 'object' ? value : { value: value }\n-    case 'Bytes':\n-      if (typeof value !== 'string') {\n-        throw new Error(`DataMapper: Bytes data is not a string, got: ${typeof value}`)\n+      return typeof value === 'string' ? value : JSON.stringify(value)\n+    case 'Bytes': {\n+      if (!Array.isArray(value)) {\n+        throw new Error(`DataMapper: Bytes data is invalid, got: ${typeof value}`)\n       }\n-      return value\n+      const { buffer, byteOffset, byteLength } = Buffer.from(value)\n+      return new Uint8Array(buffer, byteOffset, byteLength)",
        "comment_created_at": "2025-05-12T09:51:04+00:00",
        "comment_author": "aqrln",
        "comment_body": "You should be able to construct the `Uint8Array` directly in this case, the intermediate `Buffer` is only necessary to deserialize from base64",
        "pr_file_module": null
      },
      {
        "comment_id": "2084315658",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27127,
        "pr_file": "packages/client-engine-runtime/src/interpreter/DataMapper.ts",
        "discussion_id": "2084299487",
        "commented_code": "@@ -89,22 +91,22 @@ function mapValue(value: unknown, resultType: PrismaValueType): unknown {\n     case 'Boolean':\n       return typeof value === 'boolean' ? value : value !== '0'\n     case 'Decimal':\n-      return typeof value === 'number' ? value : parseFloat(`${value}`)\n+      return typeof value === 'number' ? new Decimal(value) : new Decimal(`${value}`)\n     case 'Date':\n       return value instanceof Date ? value : new Date(`${value}`)\n     case 'Array': {\n       const values = value as unknown[]\n-      return values.map((v) => {\n-        mapValue(v, resultType.inner)\n-      })\n+      return values.map((v) => mapValue(v, resultType.inner))\n     }\n     case 'Object':\n-      return typeof value === 'object' ? value : { value: value }\n-    case 'Bytes':\n-      if (typeof value !== 'string') {\n-        throw new Error(`DataMapper: Bytes data is not a string, got: ${typeof value}`)\n+      return typeof value === 'string' ? value : JSON.stringify(value)\n+    case 'Bytes': {\n+      if (!Array.isArray(value)) {\n+        throw new Error(`DataMapper: Bytes data is invalid, got: ${typeof value}`)\n       }\n-      return value\n+      const { buffer, byteOffset, byteLength } = Buffer.from(value)\n+      return new Uint8Array(buffer, byteOffset, byteLength)",
        "comment_created_at": "2025-05-12T09:59:46+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1277715723",
    "pr_number": 20113,
    "pr_file": "packages/instrumentation/src/ActiveTracingHelper.ts",
    "created_at": "2023-07-28T15:44:39+00:00",
    "commented_code": "const tracer = trace.getTracer('prisma') as Tracer\n \n     engineSpanEvent.spans.forEach((engineSpan) => {\n+      if (this.ignoreLayersTypes.map((value) => value.toString()).includes(engineSpan.name)) {",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1277715723",
        "repo_full_name": "prisma/prisma",
        "pr_number": 20113,
        "pr_file": "packages/instrumentation/src/ActiveTracingHelper.ts",
        "discussion_id": "1277715723",
        "commented_code": "@@ -45,6 +50,10 @@ export class ActiveTracingHelper implements TracingHelper {\n     const tracer = trace.getTracer('prisma') as Tracer\n \n     engineSpanEvent.spans.forEach((engineSpan) => {\n+      if (this.ignoreLayersTypes.map((value) => value.toString()).includes(engineSpan.name)) {",
        "comment_created_at": "2023-07-28T15:44:39+00:00",
        "comment_author": "aqrln",
        "comment_body": "Should we maybe do the mapping in the constructor instead to avoid allocating a new array each time a new span arrives?",
        "pr_file_module": null
      },
      {
        "comment_id": "1279105940",
        "repo_full_name": "prisma/prisma",
        "pr_number": 20113,
        "pr_file": "packages/instrumentation/src/ActiveTracingHelper.ts",
        "discussion_id": "1277715723",
        "commented_code": "@@ -45,6 +50,10 @@ export class ActiveTracingHelper implements TracingHelper {\n     const tracer = trace.getTracer('prisma') as Tracer\n \n     engineSpanEvent.spans.forEach((engineSpan) => {\n+      if (this.ignoreLayersTypes.map((value) => value.toString()).includes(engineSpan.name)) {",
        "comment_created_at": "2023-07-31T10:31:48+00:00",
        "comment_author": "overbit",
        "comment_body": "Done @aqrln \r\n",
        "pr_file_module": null
      }
    ]
  }
]