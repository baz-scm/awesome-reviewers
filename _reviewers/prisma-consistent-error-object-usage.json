[
  {
    "discussion_id": "2066014349",
    "pr_number": 26983,
    "pr_file": "packages/driver-adapter-utils/src/binder.ts",
    "created_at": "2025-04-29T10:27:52+00:00",
    "commented_code": "const debug = Debug('driver-adapter-utils')\n \n+const DRIVER_ADAPTER_EXTERNAL_ERROR = 'P2036'\n+\n class ErrorRegistryInternal implements ErrorRegistry {\n   private registeredErrors: ErrorRecord[] = []\n \n-  consumeError(id: number): ErrorRecord | undefined {\n-    return this.registeredErrors[id]\n+  lookupError(\n+    error: number | { error_code: string; meta?: { id: number } } | { message: string },\n+  ): ErrorRecord | undefined {\n+    if (typeof error === 'number') {\n+      const errorRecord = this.registeredErrors[error]\n+      if (!errorRecord) throw `External error with reported id was not registered`\n+      return errorRecord\n+    } else if ('error_code' in error && error.error_code === DRIVER_ADAPTER_EXTERNAL_ERROR) {\n+      // Query Engine Runtime Errors will look like this\n+      const id = error.meta?.id\n+      if (typeof id !== 'number') throw 'Malformed external JS error received from the engine'\n+      const errorRecord = this.registeredErrors[id]\n+      if (!errorRecord) throw `External error with reported id was not registered`\n+      return errorRecord\n+    } else if ('message' in error && error.message.startsWith('External error id#')) {\n+      // Schema Engine CLI Runtime Errors will look like this\n+      const id = parseInt(error.message.split('id#')[1])\n+      const errorRecord = this.registeredErrors[id]",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2066014349",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26983,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "2066014349",
        "commented_code": "@@ -16,11 +16,34 @@ import type {\n \n const debug = Debug('driver-adapter-utils')\n \n+const DRIVER_ADAPTER_EXTERNAL_ERROR = 'P2036'\n+\n class ErrorRegistryInternal implements ErrorRegistry {\n   private registeredErrors: ErrorRecord[] = []\n \n-  consumeError(id: number): ErrorRecord | undefined {\n-    return this.registeredErrors[id]\n+  lookupError(\n+    error: number | { error_code: string; meta?: { id: number } } | { message: string },\n+  ): ErrorRecord | undefined {\n+    if (typeof error === 'number') {\n+      const errorRecord = this.registeredErrors[error]\n+      if (!errorRecord) throw `External error with reported id was not registered`\n+      return errorRecord\n+    } else if ('error_code' in error && error.error_code === DRIVER_ADAPTER_EXTERNAL_ERROR) {\n+      // Query Engine Runtime Errors will look like this\n+      const id = error.meta?.id\n+      if (typeof id !== 'number') throw 'Malformed external JS error received from the engine'\n+      const errorRecord = this.registeredErrors[id]\n+      if (!errorRecord) throw `External error with reported id was not registered`\n+      return errorRecord\n+    } else if ('message' in error && error.message.startsWith('External error id#')) {\n+      // Schema Engine CLI Runtime Errors will look like this\n+      const id = parseInt(error.message.split('id#')[1])\n+      const errorRecord = this.registeredErrors[id]",
        "comment_created_at": "2025-04-29T10:27:52+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "we should probably add some mapping to return a properly structured error here, but we can handle it like this in the interim (might be worth a TODO)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066028184",
    "pr_number": 26983,
    "pr_file": "packages/migrate/src/SchemaEngineWasm.ts",
    "created_at": "2025-04-29T10:38:33+00:00",
    "commented_code": "// Note: `datamodels` must be either `undefined` or a *non-empty* `LoadedFile[]`.\n     const datamodels = schemaContext?.schemaFiles\n-    const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n-      {\n-        datamodels,\n-      },\n-      debug,\n-      adapter,\n-    )\n-    return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    try {\n+      const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n+        {\n+          datamodels,\n+        },\n+        debug,\n+        adapter,\n+      )\n+      return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    } catch (e) {\n+      throw adapter.errorRegistry.lookupError(e as Error) || e",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2066028184",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26983,
        "pr_file": "packages/migrate/src/SchemaEngineWasm.ts",
        "discussion_id": "2066028184",
        "commented_code": "@@ -67,14 +67,18 @@ export class SchemaEngineWasm implements SchemaEngine {\n \n     // Note: `datamodels` must be either `undefined` or a *non-empty* `LoadedFile[]`.\n     const datamodels = schemaContext?.schemaFiles\n-    const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n-      {\n-        datamodels,\n-      },\n-      debug,\n-      adapter,\n-    )\n-    return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    try {\n+      const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n+        {\n+          datamodels,\n+        },\n+        debug,\n+        adapter,\n+      )\n+      return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    } catch (e) {\n+      throw adapter.errorRegistry.lookupError(e as Error) || e",
        "comment_created_at": "2025-04-29T10:38:33+00:00",
        "comment_author": "aqrln",
        "comment_body": "nit\r\n```suggestion\r\n      throw adapter.errorRegistry.lookupError(e as Error) ?? e\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2066041997",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26983,
        "pr_file": "packages/migrate/src/SchemaEngineWasm.ts",
        "discussion_id": "2066028184",
        "commented_code": "@@ -67,14 +67,18 @@ export class SchemaEngineWasm implements SchemaEngine {\n \n     // Note: `datamodels` must be either `undefined` or a *non-empty* `LoadedFile[]`.\n     const datamodels = schemaContext?.schemaFiles\n-    const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n-      {\n-        datamodels,\n-      },\n-      debug,\n-      adapter,\n-    )\n-    return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    try {\n+      const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n+        {\n+          datamodels,\n+        },\n+        debug,\n+        adapter,\n+      )\n+      return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    } catch (e) {\n+      throw adapter.errorRegistry.lookupError(e as Error) || e",
        "comment_created_at": "2025-04-29T10:48:59+00:00",
        "comment_author": "aqrln",
        "comment_body": "Aso `throw adapter.errorRegistry.lookupError(e as Error)` is probably wrong, because `errorRegistry.lookupError` doesn't return an `Error`, it returns an `ErrorRecord`, which is defined as `{ error: unknown }`.\r\n\r\n```suggestion\r\n      throw adapter.errorRegistry.lookupError(e as Error)?.error ?? e\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2066045984",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26983,
        "pr_file": "packages/migrate/src/SchemaEngineWasm.ts",
        "discussion_id": "2066028184",
        "commented_code": "@@ -67,14 +67,18 @@ export class SchemaEngineWasm implements SchemaEngine {\n \n     // Note: `datamodels` must be either `undefined` or a *non-empty* `LoadedFile[]`.\n     const datamodels = schemaContext?.schemaFiles\n-    const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n-      {\n-        datamodels,\n-      },\n-      debug,\n-      adapter,\n-    )\n-    return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    try {\n+      const engine = await wasmSchemaEngineLoader.loadSchemaEngine(\n+        {\n+          datamodels,\n+        },\n+        debug,\n+        adapter,\n+      )\n+      return new SchemaEngineWasm({ ...rest, engine, errorRegistry: adapter.errorRegistry })\n+    } catch (e) {\n+      throw adapter.errorRegistry.lookupError(e as Error) || e",
        "comment_created_at": "2025-04-29T10:51:35+00:00",
        "comment_author": "aqrln",
        "comment_body": "That said, it could also be seen as a defect in the API. It makes total sense why errors need to be wrapped into extra objects to be stored (an error can be any JS value including `undefined`), but I see no reason why `ErrorRecord` would need to be exposed outside of the `binder` module, it feels like it should be an implementation detail to me.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066035893",
    "pr_number": 26983,
    "pr_file": "packages/driver-adapter-utils/src/binder.ts",
    "created_at": "2025-04-29T10:44:34+00:00",
    "commented_code": "const debug = Debug('driver-adapter-utils')\n \n+const DRIVER_ADAPTER_EXTERNAL_ERROR = 'P2036'\n+\n class ErrorRegistryInternal implements ErrorRegistry {\n   private registeredErrors: ErrorRecord[] = []\n \n-  consumeError(id: number): ErrorRecord | undefined {\n-    return this.registeredErrors[id]\n+  lookupError(\n+    error: number | { error_code: string; meta?: { id: number } } | { message: string },\n+  ): ErrorRecord | undefined {\n+    if (typeof error === 'number') {\n+      const errorRecord = this.registeredErrors[error]\n+      if (!errorRecord) throw `External error with reported id was not registered`",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2066035893",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26983,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "2066035893",
        "commented_code": "@@ -16,11 +16,34 @@ import type {\n \n const debug = Debug('driver-adapter-utils')\n \n+const DRIVER_ADAPTER_EXTERNAL_ERROR = 'P2036'\n+\n class ErrorRegistryInternal implements ErrorRegistry {\n   private registeredErrors: ErrorRecord[] = []\n \n-  consumeError(id: number): ErrorRecord | undefined {\n-    return this.registeredErrors[id]\n+  lookupError(\n+    error: number | { error_code: string; meta?: { id: number } } | { message: string },\n+  ): ErrorRecord | undefined {\n+    if (typeof error === 'number') {\n+      const errorRecord = this.registeredErrors[error]\n+      if (!errorRecord) throw `External error with reported id was not registered`",
        "comment_created_at": "2025-04-29T10:44:34+00:00",
        "comment_author": "aqrln",
        "comment_body": "I feel like the logic is backwards compared to the function signature. We throw if the specified error is not found (although the signature suggests `undefined` would be returned in this case) and only return `undefined` in the final `else` branch if the shape of the input was completely wrong and we couldn't interpret it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2035599286",
    "pr_number": 26833,
    "pr_file": "packages/adapter-d1/src/errors.ts",
    "created_at": "2025-04-09T15:15:31+00:00",
    "commented_code": "+import { Error as DriverAdapterErrorObject } from '@prisma/driver-adapter-utils'\n+\n+// When we receive the result, we only get the error message, not the error code.\n+// Example:\n+// \"name\":\"Error\",\"message\":\"D1_ERROR: UNIQUE constraint failed: User.email\"\n+// So we try to match some errors and use the generic error code as a fallback.\n+// https://www.sqlite.org/rescode.html\n+export function convertDriverError(error: any): DriverAdapterErrorObject {\n+  if (!isDbError(error)) {\n+    throw error\n+  }",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2035599286",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26833,
        "pr_file": "packages/adapter-d1/src/errors.ts",
        "discussion_id": "2035599286",
        "commented_code": "@@ -0,0 +1,66 @@\n+import { Error as DriverAdapterErrorObject } from '@prisma/driver-adapter-utils'\n+\n+// When we receive the result, we only get the error message, not the error code.\n+// Example:\n+// \"name\":\"Error\",\"message\":\"D1_ERROR: UNIQUE constraint failed: User.email\"\n+// So we try to match some errors and use the generic error code as a fallback.\n+// https://www.sqlite.org/rescode.html\n+export function convertDriverError(error: any): DriverAdapterErrorObject {\n+  if (!isDbError(error)) {\n+    throw error\n+  }",
        "comment_created_at": "2025-04-09T15:15:31+00:00",
        "comment_author": "jkomyno",
        "comment_body": "We used to have `throw new DriverAdapterError(error.message)`, now we'd have `throw error` in this case.\r\nIs this something we actually want? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2035608918",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26833,
        "pr_file": "packages/adapter-d1/src/errors.ts",
        "discussion_id": "2035599286",
        "commented_code": "@@ -0,0 +1,66 @@\n+import { Error as DriverAdapterErrorObject } from '@prisma/driver-adapter-utils'\n+\n+// When we receive the result, we only get the error message, not the error code.\n+// Example:\n+// \"name\":\"Error\",\"message\":\"D1_ERROR: UNIQUE constraint failed: User.email\"\n+// So we try to match some errors and use the generic error code as a fallback.\n+// https://www.sqlite.org/rescode.html\n+export function convertDriverError(error: any): DriverAdapterErrorObject {\n+  if (!isDbError(error)) {\n+    throw error\n+  }",
        "comment_created_at": "2025-04-09T15:20:45+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "`DriverAdapterError` was meant to wrap a valid database error, in this case we don't have a valid database error payload, so we throw the error we received instead,\r\n\r\nThis case is basically unreachable in this adapter, but by convention I made all the `convertDriverError` accept `any` error type and do a runtime type check (this could be changed to just accept the javascript Error type)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967742205",
    "pr_number": 26321,
    "pr_file": "packages/adapter-d1/src/d1.ts",
    "created_at": "2025-02-24T14:24:49+00:00",
    "commented_code": "* returning the number of affected rows.\n    * Note: Queryable expects a u64, but napi.rs only supports u32.\n    */\n-  async executeRaw(query: Query): Promise<Result<number>> {\n+  async executeRaw(query: SqlQuery): Promise<number> {\n     const tag = '[js::execute_raw]'\n     debug(`${tag} %O`, query)\n \n-    const res = await this.performIO(query, true)\n-    return res.map((result) => (result as D1Response).meta.changes ?? 0)\n+    const result = await this.performIO(query, true)\n+    return (result as D1Response).meta.changes ?? 0\n   }\n \n-  private async performIO(query: Query, executeRaw = false): Promise<Result<PerformIOResult>> {\n+  private async performIO(query: SqlQuery, executeRaw = false): Promise<PerformIOResult> {\n     try {\n       query.args = query.args.map((arg, i) => cleanArg(arg, query.argTypes[i]))\n \n       const stmt = this.client.prepare(query.sql).bind(...query.args)\n \n       if (executeRaw) {\n-        return ok(await stmt.run())\n+        return await stmt.run()\n       } else {\n         const [columnNames, ...rows] = await stmt.raw({ columnNames: true })\n-        return ok([columnNames, rows])\n+        return [columnNames, rows]\n       }\n     } catch (e) {\n-      console.error('Error in performIO: %O', e)\n-      const { message } = e\n-\n-      return err({\n-        kind: 'sqlite',\n-        extendedCode: matchSQLiteErrorCode(message),\n-        message,\n-      })\n+      this.onError(e)\n     }\n   }\n+\n+  protected onError(error: any): never {\n+    console.error('Error in performIO: %O', error)\n+    const { message } = error\n+\n+    throw new PrismaAdapterError({\n+      kind: 'sqlite',\n+      extendedCode: matchSQLiteErrorCode(message),\n+      message,\n+    })\n+  }",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1967742205",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/adapter-d1/src/d1.ts",
        "discussion_id": "1967742205",
        "commented_code": "@@ -79,54 +75,54 @@ class D1Queryable<ClientT extends StdClient> implements Queryable {\n    * returning the number of affected rows.\n    * Note: Queryable expects a u64, but napi.rs only supports u32.\n    */\n-  async executeRaw(query: Query): Promise<Result<number>> {\n+  async executeRaw(query: SqlQuery): Promise<number> {\n     const tag = '[js::execute_raw]'\n     debug(`${tag} %O`, query)\n \n-    const res = await this.performIO(query, true)\n-    return res.map((result) => (result as D1Response).meta.changes ?? 0)\n+    const result = await this.performIO(query, true)\n+    return (result as D1Response).meta.changes ?? 0\n   }\n \n-  private async performIO(query: Query, executeRaw = false): Promise<Result<PerformIOResult>> {\n+  private async performIO(query: SqlQuery, executeRaw = false): Promise<PerformIOResult> {\n     try {\n       query.args = query.args.map((arg, i) => cleanArg(arg, query.argTypes[i]))\n \n       const stmt = this.client.prepare(query.sql).bind(...query.args)\n \n       if (executeRaw) {\n-        return ok(await stmt.run())\n+        return await stmt.run()\n       } else {\n         const [columnNames, ...rows] = await stmt.raw({ columnNames: true })\n-        return ok([columnNames, rows])\n+        return [columnNames, rows]\n       }\n     } catch (e) {\n-      console.error('Error in performIO: %O', e)\n-      const { message } = e\n-\n-      return err({\n-        kind: 'sqlite',\n-        extendedCode: matchSQLiteErrorCode(message),\n-        message,\n-      })\n+      this.onError(e)\n     }\n   }\n+\n+  protected onError(error: any): never {\n+    console.error('Error in performIO: %O', error)\n+    const { message } = error\n+\n+    throw new PrismaAdapterError({\n+      kind: 'sqlite',\n+      extendedCode: matchSQLiteErrorCode(message),\n+      message,\n+    })\n+  }",
        "comment_created_at": "2025-02-24T14:24:49+00:00",
        "comment_author": "jkomyno",
        "comment_body": "- [NIT] `onError` is not using any field/method via `this.`, so it could be a free function rather than a method, no?\r\n- destructuring fields from an `any` type is not type-safe. Errors caught by `catch(e) {}` are `e: unknown` and should be explicitly cast to type `Error`",
        "pr_file_module": null
      },
      {
        "comment_id": "1967759529",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/adapter-d1/src/d1.ts",
        "discussion_id": "1967742205",
        "commented_code": "@@ -79,54 +75,54 @@ class D1Queryable<ClientT extends StdClient> implements Queryable {\n    * returning the number of affected rows.\n    * Note: Queryable expects a u64, but napi.rs only supports u32.\n    */\n-  async executeRaw(query: Query): Promise<Result<number>> {\n+  async executeRaw(query: SqlQuery): Promise<number> {\n     const tag = '[js::execute_raw]'\n     debug(`${tag} %O`, query)\n \n-    const res = await this.performIO(query, true)\n-    return res.map((result) => (result as D1Response).meta.changes ?? 0)\n+    const result = await this.performIO(query, true)\n+    return (result as D1Response).meta.changes ?? 0\n   }\n \n-  private async performIO(query: Query, executeRaw = false): Promise<Result<PerformIOResult>> {\n+  private async performIO(query: SqlQuery, executeRaw = false): Promise<PerformIOResult> {\n     try {\n       query.args = query.args.map((arg, i) => cleanArg(arg, query.argTypes[i]))\n \n       const stmt = this.client.prepare(query.sql).bind(...query.args)\n \n       if (executeRaw) {\n-        return ok(await stmt.run())\n+        return await stmt.run()\n       } else {\n         const [columnNames, ...rows] = await stmt.raw({ columnNames: true })\n-        return ok([columnNames, rows])\n+        return [columnNames, rows]\n       }\n     } catch (e) {\n-      console.error('Error in performIO: %O', e)\n-      const { message } = e\n-\n-      return err({\n-        kind: 'sqlite',\n-        extendedCode: matchSQLiteErrorCode(message),\n-        message,\n-      })\n+      this.onError(e)\n     }\n   }\n+\n+  protected onError(error: any): never {\n+    console.error('Error in performIO: %O', error)\n+    const { message } = error\n+\n+    throw new PrismaAdapterError({\n+      kind: 'sqlite',\n+      extendedCode: matchSQLiteErrorCode(message),\n+      message,\n+    })\n+  }",
        "comment_created_at": "2025-02-24T14:33:08+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "> destructuring fields from an any type is not type-safe. Errors caught by catch(e) {} are e: unknown and should be explicitly cast to type Error\r\n\r\nyeah I don't like it, but it's just existing code that was extracted to a function",
        "pr_file_module": null
      },
      {
        "comment_id": "1968049583",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/adapter-d1/src/d1.ts",
        "discussion_id": "1967742205",
        "commented_code": "@@ -79,54 +75,54 @@ class D1Queryable<ClientT extends StdClient> implements Queryable {\n    * returning the number of affected rows.\n    * Note: Queryable expects a u64, but napi.rs only supports u32.\n    */\n-  async executeRaw(query: Query): Promise<Result<number>> {\n+  async executeRaw(query: SqlQuery): Promise<number> {\n     const tag = '[js::execute_raw]'\n     debug(`${tag} %O`, query)\n \n-    const res = await this.performIO(query, true)\n-    return res.map((result) => (result as D1Response).meta.changes ?? 0)\n+    const result = await this.performIO(query, true)\n+    return (result as D1Response).meta.changes ?? 0\n   }\n \n-  private async performIO(query: Query, executeRaw = false): Promise<Result<PerformIOResult>> {\n+  private async performIO(query: SqlQuery, executeRaw = false): Promise<PerformIOResult> {\n     try {\n       query.args = query.args.map((arg, i) => cleanArg(arg, query.argTypes[i]))\n \n       const stmt = this.client.prepare(query.sql).bind(...query.args)\n \n       if (executeRaw) {\n-        return ok(await stmt.run())\n+        return await stmt.run()\n       } else {\n         const [columnNames, ...rows] = await stmt.raw({ columnNames: true })\n-        return ok([columnNames, rows])\n+        return [columnNames, rows]\n       }\n     } catch (e) {\n-      console.error('Error in performIO: %O', e)\n-      const { message } = e\n-\n-      return err({\n-        kind: 'sqlite',\n-        extendedCode: matchSQLiteErrorCode(message),\n-        message,\n-      })\n+      this.onError(e)\n     }\n   }\n+\n+  protected onError(error: any): never {\n+    console.error('Error in performIO: %O', error)\n+    const { message } = error\n+\n+    throw new PrismaAdapterError({\n+      kind: 'sqlite',\n+      extendedCode: matchSQLiteErrorCode(message),\n+      message,\n+    })\n+  }",
        "comment_created_at": "2025-02-24T16:55:24+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967745333",
    "pr_number": 26321,
    "pr_file": "packages/driver-adapter-utils/src/binder.ts",
    "created_at": "2025-02-24T14:26:24+00:00",
    "commented_code": "function wrapAsync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Promise<Result<R>>,\n+  fn: (...args: A) => Promise<R>,\n ): (...args: A) => Promise<Result<R>> {\n   return async (...args) => {\n     try {\n-      return await fn(...args)\n+      return ok(await fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1967745333",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "1967745333",
        "commented_code": "@@ -84,12 +91,16 @@ const bindTransaction = (errorRegistry: ErrorRegistryInternal, transaction: Tran\n \n function wrapAsync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Promise<Result<R>>,\n+  fn: (...args: A) => Promise<R>,\n ): (...args: A) => Promise<Result<R>> {\n   return async (...args) => {\n     try {\n-      return await fn(...args)\n+      return ok(await fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
        "comment_created_at": "2025-02-24T14:26:24+00:00",
        "comment_author": "jkomyno",
        "comment_body": "```suggestion\r\n      if (error instanceof Error) {\r\n        return err(error.cause)\r\n      }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1967770399",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "1967745333",
        "commented_code": "@@ -84,12 +91,16 @@ const bindTransaction = (errorRegistry: ErrorRegistryInternal, transaction: Tran\n \n function wrapAsync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Promise<Result<R>>,\n+  fn: (...args: A) => Promise<R>,\n ): (...args: A) => Promise<Result<R>> {\n   return async (...args) => {\n     try {\n-      return await fn(...args)\n+      return ok(await fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
        "comment_created_at": "2025-02-24T14:38:45+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "do you mean `error.cause instanceof Error`? this is responsible for unwrapping the cause for the query engine to handle errors correctly",
        "pr_file_module": null
      },
      {
        "comment_id": "1967772854",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "1967745333",
        "commented_code": "@@ -84,12 +91,16 @@ const bindTransaction = (errorRegistry: ErrorRegistryInternal, transaction: Tran\n \n function wrapAsync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Promise<Result<R>>,\n+  fn: (...args: A) => Promise<R>,\n ): (...args: A) => Promise<Result<R>> {\n   return async (...args) => {\n     try {\n-      return await fn(...args)\n+      return ok(await fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
        "comment_created_at": "2025-02-24T14:39:25+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "I think the causes aren't even necessarily instances of js Error, it's just the error payload we pass back to Rust",
        "pr_file_module": null
      },
      {
        "comment_id": "1968049753",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "1967745333",
        "commented_code": "@@ -84,12 +91,16 @@ const bindTransaction = (errorRegistry: ErrorRegistryInternal, transaction: Tran\n \n function wrapAsync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Promise<Result<R>>,\n+  fn: (...args: A) => Promise<R>,\n ): (...args: A) => Promise<Result<R>> {\n   return async (...args) => {\n     try {\n-      return await fn(...args)\n+      return ok(await fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
        "comment_created_at": "2025-02-24T16:55:31+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967748407",
    "pr_number": 26321,
    "pr_file": "packages/driver-adapter-utils/src/binder.ts",
    "created_at": "2025-02-24T14:27:32+00:00",
    "commented_code": "function wrapSync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Result<R>,\n+  fn: (...args: A) => R,\n ): (...args: A) => Result<R> {\n   return (...args) => {\n     try {\n-      return fn(...args)\n+      return ok(fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1967748407",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "1967748407",
        "commented_code": "@@ -98,12 +109,16 @@ function wrapAsync<A extends unknown[], R>(\n \n function wrapSync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Result<R>,\n+  fn: (...args: A) => R,\n ): (...args: A) => Result<R> {\n   return (...args) => {\n     try {\n-      return fn(...args)\n+      return ok(fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
        "comment_created_at": "2025-02-24T14:27:32+00:00",
        "comment_author": "jkomyno",
        "comment_body": "```suggestion\r\n      if (error instanceof Error) {\r\n        return err(error.cause)\r\n      }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1968050280",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26321,
        "pr_file": "packages/driver-adapter-utils/src/binder.ts",
        "discussion_id": "1967748407",
        "commented_code": "@@ -98,12 +109,16 @@ function wrapAsync<A extends unknown[], R>(\n \n function wrapSync<A extends unknown[], R>(\n   registry: ErrorRegistryInternal,\n-  fn: (...args: A) => Result<R>,\n+  fn: (...args: A) => R,\n ): (...args: A) => Result<R> {\n   return (...args) => {\n     try {\n-      return fn(...args)\n+      return ok(fn(...args))\n     } catch (error) {\n+      // unwrap the cause of exceptions thrown by driver adapters if there is one\n+      if (error.cause && typeof error.cause === 'object') {\n+        return err(error.cause)\n+      }",
        "comment_created_at": "2025-02-24T16:55:52+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "updated",
        "pr_file_module": null
      }
    ]
  }
]