[
  {
    "discussion_id": "2092905147",
    "pr_number": 27197,
    "pr_file": "packages/credentials-store/src/index.ts",
    "created_at": "2025-05-16T11:55:00+00:00",
    "commented_code": "await writeFile(this.authFilePath, JSON.stringify(data, null, 2))\n   }\n \n+  async deleteCredentials(workspaceId: string): Promise<void> {\n+    await this.reloadCredentialsFromDisk()\n+    this.loadedCredentials = this.loadedCredentials?.filter((c) => c.workspaceId !== workspaceId) || []\n+    const data: AuthFile = { tokens: this.loadedCredentials }\n+    await mkdir(path.dirname(this.authFilePath), { recursive: true })\n+    await writeFile(this.authFilePath, JSON.stringify(data, null, 2))",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2092905147",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27197,
        "pr_file": "packages/credentials-store/src/index.ts",
        "discussion_id": "2092905147",
        "commented_code": "@@ -56,6 +56,14 @@ export class CredentialsStore {\n     await writeFile(this.authFilePath, JSON.stringify(data, null, 2))\n   }\n \n+  async deleteCredentials(workspaceId: string): Promise<void> {\n+    await this.reloadCredentialsFromDisk()\n+    this.loadedCredentials = this.loadedCredentials?.filter((c) => c.workspaceId !== workspaceId) || []\n+    const data: AuthFile = { tokens: this.loadedCredentials }\n+    await mkdir(path.dirname(this.authFilePath), { recursive: true })\n+    await writeFile(this.authFilePath, JSON.stringify(data, null, 2))",
        "comment_created_at": "2025-05-16T11:55:00+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "this is duplicated twice, might be worth putting in a function of its own",
        "pr_file_module": null
      },
      {
        "comment_id": "2093217670",
        "repo_full_name": "prisma/prisma",
        "pr_number": 27197,
        "pr_file": "packages/credentials-store/src/index.ts",
        "discussion_id": "2092905147",
        "commented_code": "@@ -56,6 +56,14 @@ export class CredentialsStore {\n     await writeFile(this.authFilePath, JSON.stringify(data, null, 2))\n   }\n \n+  async deleteCredentials(workspaceId: string): Promise<void> {\n+    await this.reloadCredentialsFromDisk()\n+    this.loadedCredentials = this.loadedCredentials?.filter((c) => c.workspaceId !== workspaceId) || []\n+    const data: AuthFile = { tokens: this.loadedCredentials }\n+    await mkdir(path.dirname(this.authFilePath), { recursive: true })\n+    await writeFile(this.authFilePath, JSON.stringify(data, null, 2))",
        "comment_created_at": "2025-05-16T14:58:11+00:00",
        "comment_author": "FGoessler",
        "comment_body": "Good call - done :+1:",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2037185741",
    "pr_number": 26727,
    "pr_file": "packages/client-generator-ts/src/TSClient/file-generators/CommonInputTypesFile.ts",
    "created_at": "2025-04-10T12:02:06+00:00",
    "commented_code": "+import * as ts from '@prisma/ts-builders'\n+\n+import { GenerateContext } from '../GenerateContext'\n+import { InputType } from '../Input'\n+\n+const jsDocHeader = `/**\n+ * This file exports various common sort, input & filter types that are not directly linked to a particular model.\n+ *\n+ * \ud83d\udfe2 You can import this file directly.\n+ */\n+`\n+\n+export function createCommonInputTypeFiles(context: GenerateContext) {\n+  const imports = [\n+    ts.moduleImport(context.runtimeImport).asNamespace('runtime'),\n+    ts.moduleImport(context.importFileName(`./enums`)).asNamespace('$Enums'),\n+    ts.moduleImport(context.importFileName(`./internal/prismaNamespace`)).asNamespace('Prisma').typeOnly(),\n+  ].map((i) => ts.stringify(i))\n+\n+  const genericInputTypes = context.dmmf.inputObjectTypes.prisma\n+    // Only contains generic input types that are not directly linked to a particular model\n+    .filter((i) => !i.meta?.grouping)\n+    .map((inputType) => {\n+      if (inputType.name.includes('Json') && inputType.name.includes('Filter')) {\n+        const needsGeneric = context.genericArgsInfo.typeNeedsGenericModelArg(inputType)\n+        const innerName = needsGeneric ? `${inputType.name}Base<$PrismaModel>` : `${inputType.name}Base`\n+        const typeName = needsGeneric ? `${inputType.name}<$PrismaModel = never>` : inputType.name\n+        // This generates types for JsonFilter to prevent the usage of 'path' without another parameter\n+        const baseName = `Required<${innerName}>`\n+        return `export type ${typeName} = \n+| Prisma.PatchUndefined<\n+    Prisma.Either<${baseName}, Exclude<keyof ${baseName}, 'path'>>,\n+    ${baseName}\n+  >\n+| Prisma.OptionalFlat<Omit<${baseName}, 'path'>>",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2037185741",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26727,
        "pr_file": "packages/client-generator-ts/src/TSClient/file-generators/CommonInputTypesFile.ts",
        "discussion_id": "2037185741",
        "commented_code": "@@ -0,0 +1,49 @@\n+import * as ts from '@prisma/ts-builders'\n+\n+import { GenerateContext } from '../GenerateContext'\n+import { InputType } from '../Input'\n+\n+const jsDocHeader = `/**\n+ * This file exports various common sort, input & filter types that are not directly linked to a particular model.\n+ *\n+ * \ud83d\udfe2 You can import this file directly.\n+ */\n+`\n+\n+export function createCommonInputTypeFiles(context: GenerateContext) {\n+  const imports = [\n+    ts.moduleImport(context.runtimeImport).asNamespace('runtime'),\n+    ts.moduleImport(context.importFileName(`./enums`)).asNamespace('$Enums'),\n+    ts.moduleImport(context.importFileName(`./internal/prismaNamespace`)).asNamespace('Prisma').typeOnly(),\n+  ].map((i) => ts.stringify(i))\n+\n+  const genericInputTypes = context.dmmf.inputObjectTypes.prisma\n+    // Only contains generic input types that are not directly linked to a particular model\n+    .filter((i) => !i.meta?.grouping)\n+    .map((inputType) => {\n+      if (inputType.name.includes('Json') && inputType.name.includes('Filter')) {\n+        const needsGeneric = context.genericArgsInfo.typeNeedsGenericModelArg(inputType)\n+        const innerName = needsGeneric ? `${inputType.name}Base<$PrismaModel>` : `${inputType.name}Base`\n+        const typeName = needsGeneric ? `${inputType.name}<$PrismaModel = never>` : inputType.name\n+        // This generates types for JsonFilter to prevent the usage of 'path' without another parameter\n+        const baseName = `Required<${innerName}>`\n+        return `export type ${typeName} = \n+| Prisma.PatchUndefined<\n+    Prisma.Either<${baseName}, Exclude<keyof ${baseName}, 'path'>>,\n+    ${baseName}\n+  >\n+| Prisma.OptionalFlat<Omit<${baseName}, 'path'>>",
        "comment_created_at": "2025-04-10T12:02:06+00:00",
        "comment_author": "aqrln",
        "comment_body": "This seems to be the same as in `ModelFile.ts`, should we extract this to a function?",
        "pr_file_module": null
      },
      {
        "comment_id": "2038916192",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26727,
        "pr_file": "packages/client-generator-ts/src/TSClient/file-generators/CommonInputTypesFile.ts",
        "discussion_id": "2037185741",
        "commented_code": "@@ -0,0 +1,49 @@\n+import * as ts from '@prisma/ts-builders'\n+\n+import { GenerateContext } from '../GenerateContext'\n+import { InputType } from '../Input'\n+\n+const jsDocHeader = `/**\n+ * This file exports various common sort, input & filter types that are not directly linked to a particular model.\n+ *\n+ * \ud83d\udfe2 You can import this file directly.\n+ */\n+`\n+\n+export function createCommonInputTypeFiles(context: GenerateContext) {\n+  const imports = [\n+    ts.moduleImport(context.runtimeImport).asNamespace('runtime'),\n+    ts.moduleImport(context.importFileName(`./enums`)).asNamespace('$Enums'),\n+    ts.moduleImport(context.importFileName(`./internal/prismaNamespace`)).asNamespace('Prisma').typeOnly(),\n+  ].map((i) => ts.stringify(i))\n+\n+  const genericInputTypes = context.dmmf.inputObjectTypes.prisma\n+    // Only contains generic input types that are not directly linked to a particular model\n+    .filter((i) => !i.meta?.grouping)\n+    .map((inputType) => {\n+      if (inputType.name.includes('Json') && inputType.name.includes('Filter')) {\n+        const needsGeneric = context.genericArgsInfo.typeNeedsGenericModelArg(inputType)\n+        const innerName = needsGeneric ? `${inputType.name}Base<$PrismaModel>` : `${inputType.name}Base`\n+        const typeName = needsGeneric ? `${inputType.name}<$PrismaModel = never>` : inputType.name\n+        // This generates types for JsonFilter to prevent the usage of 'path' without another parameter\n+        const baseName = `Required<${innerName}>`\n+        return `export type ${typeName} = \n+| Prisma.PatchUndefined<\n+    Prisma.Either<${baseName}, Exclude<keyof ${baseName}, 'path'>>,\n+    ${baseName}\n+  >\n+| Prisma.OptionalFlat<Omit<${baseName}, 'path'>>",
        "comment_created_at": "2025-04-11T06:53:58+00:00",
        "comment_author": "FGoessler",
        "comment_body": "Correct. Originally thought those two might evolve differently over my refactoring. Not the case though. Moved this logic into the `InputType` class. I checked other usages of this class and seems to be safe to have that codepath in there always.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2014026310",
    "pr_number": 26741,
    "pr_file": "packages/client/helpers/build.ts",
    "created_at": "2025-03-26T12:19:34+00:00",
    "commented_code": "fs.writeFileSync(path.join(runtimeDir, fileName), 'export * from \"./library\"\n')\n }\n \n+function allNodeRuntimeBuildConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const engineType of [ClientEngineType.Binary, ClientEngineType.Library, ClientEngineType.Client]) {\n+    for (const format of ['cjs', 'esm'] as const) {\n+      configs.push(nodeRuntimeBuildConfig(engineType, format))\n+    }\n+  }\n+\n+  return configs\n+}\n+\n+function allWasmRuntimeConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const component of ['engine', 'compiler'] as const) {\n+    for (const format of ['cjs', 'esm'] as const) {\n+      configs.push(wasmRuntimeBuildConfig(component, format))\n+    }\n+  }\n+\n+  return configs\n+}\n+\n+function allWasmBindgenRuntimeConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const component of ['engine', 'compiler'] as const) {\n+    for (const provider of ['postgresql', 'mysql', 'sqlite'] as const) {\n+      for (const format of ['cjs', 'esm'] as const) {\n+        configs.push(wasmBindgenRuntimeConfig(component, provider, format))\n+      }\n+    }\n+  }\n+\n+  return configs\n+}",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2014026310",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26741,
        "pr_file": "packages/client/helpers/build.ts",
        "discussion_id": "2014026310",
        "commented_code": "@@ -211,22 +230,52 @@ function writeDtsRexport(fileName: string) {\n   fs.writeFileSync(path.join(runtimeDir, fileName), 'export * from \"./library\"\\n')\n }\n \n+function allNodeRuntimeBuildConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const engineType of [ClientEngineType.Binary, ClientEngineType.Library, ClientEngineType.Client]) {\n+    for (const format of ['cjs', 'esm'] as const) {\n+      configs.push(nodeRuntimeBuildConfig(engineType, format))\n+    }\n+  }\n+\n+  return configs\n+}\n+\n+function allWasmRuntimeConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const component of ['engine', 'compiler'] as const) {\n+    for (const format of ['cjs', 'esm'] as const) {\n+      configs.push(wasmRuntimeBuildConfig(component, format))\n+    }\n+  }\n+\n+  return configs\n+}\n+\n+function allWasmBindgenRuntimeConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const component of ['engine', 'compiler'] as const) {\n+    for (const provider of ['postgresql', 'mysql', 'sqlite'] as const) {\n+      for (const format of ['cjs', 'esm'] as const) {\n+        configs.push(wasmBindgenRuntimeConfig(component, provider, format))\n+      }\n+    }\n+  }\n+\n+  return configs\n+}",
        "comment_created_at": "2025-03-26T12:19:34+00:00",
        "comment_author": "jacek-prisma",
        "comment_body": "might be worth extracting some constants, `allEngineTypes`, `wasmEngineTypes`, `allModuleFormats`",
        "pr_file_module": null
      },
      {
        "comment_id": "2014038266",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26741,
        "pr_file": "packages/client/helpers/build.ts",
        "discussion_id": "2014026310",
        "commented_code": "@@ -211,22 +230,52 @@ function writeDtsRexport(fileName: string) {\n   fs.writeFileSync(path.join(runtimeDir, fileName), 'export * from \"./library\"\\n')\n }\n \n+function allNodeRuntimeBuildConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const engineType of [ClientEngineType.Binary, ClientEngineType.Library, ClientEngineType.Client]) {\n+    for (const format of ['cjs', 'esm'] as const) {\n+      configs.push(nodeRuntimeBuildConfig(engineType, format))\n+    }\n+  }\n+\n+  return configs\n+}\n+\n+function allWasmRuntimeConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const component of ['engine', 'compiler'] as const) {\n+    for (const format of ['cjs', 'esm'] as const) {\n+      configs.push(wasmRuntimeBuildConfig(component, format))\n+    }\n+  }\n+\n+  return configs\n+}\n+\n+function allWasmBindgenRuntimeConfigs(): BuildOptions[] {\n+  const configs: BuildOptions[] = []\n+\n+  for (const component of ['engine', 'compiler'] as const) {\n+    for (const provider of ['postgresql', 'mysql', 'sqlite'] as const) {\n+      for (const format of ['cjs', 'esm'] as const) {\n+        configs.push(wasmBindgenRuntimeConfig(component, provider, format))\n+      }\n+    }\n+  }\n+\n+  return configs\n+}",
        "comment_created_at": "2025-03-26T12:26:49+00:00",
        "comment_author": "aqrln",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1629427511",
    "pr_number": 24448,
    "pr_file": "packages/driver-adapter-utils/src/underlying-drivers.ts",
    "created_at": "2024-06-06T12:21:14+00:00",
    "commented_code": "+/**\n+ * This module provides a map from the official Prisma Driver Adapter names to their underlying driver names.\n+ * E.g., `@prisma/adapter-planetscale` -> `@planetscale/database`\n+ */\n+\n+const officialDriverAdapters = [\n+  '@prisma/adapter-d1',\n+  '@prisma/adapter-libsql',\n+  '@prisma/adapter-neon',\n+  '@prisma/adapter-planetscale',\n+  '@prisma/adapter-pg',\n+  '@prisma/adapter-pg-worker',\n+] as const\n+\n+export function isOfficialDriverAdapter(key: string): key is OfficialDriverAdapters {\n+  return (officialDriverAdapters as readonly string[]).includes(key)\n+}\n+\n+export const underlyingDriverAdaptersMap = {\n+  '@prisma/adapter-d1': 'wrangler',\n+  '@prisma/adapter-libsql': '@libsql/client',\n+  '@prisma/adapter-neon': '@neondatabase/serverless',\n+  '@prisma/adapter-planetscale': '@planetscale/database',\n+  '@prisma/adapter-pg': 'pg',\n+  '@prisma/adapter-pg-worker': '@prisma/pg-worker',\n+} as const satisfies Record<OfficialDriverAdapters, string>",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1629427511",
        "repo_full_name": "prisma/prisma",
        "pr_number": 24448,
        "pr_file": "packages/driver-adapter-utils/src/underlying-drivers.ts",
        "discussion_id": "1629427511",
        "commented_code": "@@ -0,0 +1,29 @@\n+/**\n+ * This module provides a map from the official Prisma Driver Adapter names to their underlying driver names.\n+ * E.g., `@prisma/adapter-planetscale` -> `@planetscale/database`\n+ */\n+\n+const officialDriverAdapters = [\n+  '@prisma/adapter-d1',\n+  '@prisma/adapter-libsql',\n+  '@prisma/adapter-neon',\n+  '@prisma/adapter-planetscale',\n+  '@prisma/adapter-pg',\n+  '@prisma/adapter-pg-worker',\n+] as const\n+\n+export function isOfficialDriverAdapter(key: string): key is OfficialDriverAdapters {\n+  return (officialDriverAdapters as readonly string[]).includes(key)\n+}\n+\n+export const underlyingDriverAdaptersMap = {\n+  '@prisma/adapter-d1': 'wrangler',\n+  '@prisma/adapter-libsql': '@libsql/client',\n+  '@prisma/adapter-neon': '@neondatabase/serverless',\n+  '@prisma/adapter-planetscale': '@planetscale/database',\n+  '@prisma/adapter-pg': 'pg',\n+  '@prisma/adapter-pg-worker': '@prisma/pg-worker',\n+} as const satisfies Record<OfficialDriverAdapters, string>",
        "comment_created_at": "2024-06-06T12:21:14+00:00",
        "comment_author": "janpio",
        "comment_body": "Nit: Maybe combine these two lists to avoid the duplication?",
        "pr_file_module": null
      },
      {
        "comment_id": "1629436167",
        "repo_full_name": "prisma/prisma",
        "pr_number": 24448,
        "pr_file": "packages/driver-adapter-utils/src/underlying-drivers.ts",
        "discussion_id": "1629427511",
        "commented_code": "@@ -0,0 +1,29 @@\n+/**\n+ * This module provides a map from the official Prisma Driver Adapter names to their underlying driver names.\n+ * E.g., `@prisma/adapter-planetscale` -> `@planetscale/database`\n+ */\n+\n+const officialDriverAdapters = [\n+  '@prisma/adapter-d1',\n+  '@prisma/adapter-libsql',\n+  '@prisma/adapter-neon',\n+  '@prisma/adapter-planetscale',\n+  '@prisma/adapter-pg',\n+  '@prisma/adapter-pg-worker',\n+] as const\n+\n+export function isOfficialDriverAdapter(key: string): key is OfficialDriverAdapters {\n+  return (officialDriverAdapters as readonly string[]).includes(key)\n+}\n+\n+export const underlyingDriverAdaptersMap = {\n+  '@prisma/adapter-d1': 'wrangler',\n+  '@prisma/adapter-libsql': '@libsql/client',\n+  '@prisma/adapter-neon': '@neondatabase/serverless',\n+  '@prisma/adapter-planetscale': '@planetscale/database',\n+  '@prisma/adapter-pg': 'pg',\n+  '@prisma/adapter-pg-worker': '@prisma/pg-worker',\n+} as const satisfies Record<OfficialDriverAdapters, string>",
        "comment_created_at": "2024-06-06T12:25:53+00:00",
        "comment_author": "jkomyno",
        "comment_body": "Right, done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1862088216",
    "pr_number": 25740,
    "pr_file": "packages/client/src/generation/TSClient/TSClient.ts",
    "created_at": "2024-11-28T12:27:55+00:00",
    "commented_code": "const modelEnums: string[] = []\n     const modelEnumsAliases: string[] = []\n-    for (const enumType of this.dmmf.schema.enumTypes.model ?? []) {\n-      modelEnums.push(new Enum(enumType, false).toTS())\n+    for (const enumType of this.dmmf.datamodel.enums) {\n+      modelEnums.push(new Enum({ name: enumType.name, values: enumType.values.map(({ name }) => name) }, false).toTS())",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1862088216",
        "repo_full_name": "prisma/prisma",
        "pr_number": 25740,
        "pr_file": "packages/client/src/generation/TSClient/TSClient.ts",
        "discussion_id": "1862088216",
        "commented_code": "@@ -196,8 +198,8 @@ ${buildNFTAnnotations(edge || !copyEngine, clientEngineType, binaryTargets, rela\n \n     const modelEnums: string[] = []\n     const modelEnumsAliases: string[] = []\n-    for (const enumType of this.dmmf.schema.enumTypes.model ?? []) {\n-      modelEnums.push(new Enum(enumType, false).toTS())\n+    for (const enumType of this.dmmf.datamodel.enums) {\n+      modelEnums.push(new Enum({ name: enumType.name, values: enumType.values.map(({ name }) => name) }, false).toTS())",
        "comment_created_at": "2024-11-28T12:27:55+00:00",
        "comment_author": "aqrln",
        "comment_body": "let's maybe extract a small function to convert from `DatamodelEnum` to `SchemaEnum`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1605317546",
    "pr_number": 24231,
    "pr_file": "packages/client/src/generation/TSClient/Model.ts",
    "created_at": "2024-05-17T16:54:17+00:00",
    "commented_code": "export class Model implements Generable {\n   protected type: DMMF.OutputType\n+  protected createManyAndReturnType: undefined | DMMF.OutputType\n   protected mapping?: DMMF.ModelMapping\n   private dmmf: DMMFHelper\n   private genericsInfo: GenericArgsInfo\n   constructor(protected readonly model: DMMF.Model, protected readonly context: GenerateContext) {\n     this.dmmf = context.dmmf\n     this.genericsInfo = context.genericArgsInfo\n     this.type = this.context.dmmf.outputTypeMap.model[model.name]\n+\n+    this.createManyAndReturnType = this.context.dmmf.outputTypeMap.model[`CreateMany${model.name}AndReturnOutputType`]",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1605317546",
        "repo_full_name": "prisma/prisma",
        "pr_number": 24231,
        "pr_file": "packages/client/src/generation/TSClient/Model.ts",
        "discussion_id": "1605317546",
        "commented_code": "@@ -41,13 +43,16 @@ import { getModelActions } from './utils/getModelActions'\n \n export class Model implements Generable {\n   protected type: DMMF.OutputType\n+  protected createManyAndReturnType: undefined | DMMF.OutputType\n   protected mapping?: DMMF.ModelMapping\n   private dmmf: DMMFHelper\n   private genericsInfo: GenericArgsInfo\n   constructor(protected readonly model: DMMF.Model, protected readonly context: GenerateContext) {\n     this.dmmf = context.dmmf\n     this.genericsInfo = context.genericArgsInfo\n     this.type = this.context.dmmf.outputTypeMap.model[model.name]\n+\n+    this.createManyAndReturnType = this.context.dmmf.outputTypeMap.model[`CreateMany${model.name}AndReturnOutputType`]",
        "comment_created_at": "2024-05-17T16:54:17+00:00",
        "comment_author": "SevInf",
        "comment_body": "Afterthought: could we pull that dmmf type name creation into it's own `getCreateManyAndReturnOutputType` helper?",
        "pr_file_module": null
      },
      {
        "comment_id": "1605319076",
        "repo_full_name": "prisma/prisma",
        "pr_number": 24231,
        "pr_file": "packages/client/src/generation/TSClient/Model.ts",
        "discussion_id": "1605317546",
        "commented_code": "@@ -41,13 +43,16 @@ import { getModelActions } from './utils/getModelActions'\n \n export class Model implements Generable {\n   protected type: DMMF.OutputType\n+  protected createManyAndReturnType: undefined | DMMF.OutputType\n   protected mapping?: DMMF.ModelMapping\n   private dmmf: DMMFHelper\n   private genericsInfo: GenericArgsInfo\n   constructor(protected readonly model: DMMF.Model, protected readonly context: GenerateContext) {\n     this.dmmf = context.dmmf\n     this.genericsInfo = context.genericArgsInfo\n     this.type = this.context.dmmf.outputTypeMap.model[model.name]\n+\n+    this.createManyAndReturnType = this.context.dmmf.outputTypeMap.model[`CreateMany${model.name}AndReturnOutputType`]",
        "comment_created_at": "2024-05-17T16:55:47+00:00",
        "comment_author": "Jolg42",
        "comment_body": "I think that's a very good idea",
        "pr_file_module": null
      },
      {
        "comment_id": "1607923918",
        "repo_full_name": "prisma/prisma",
        "pr_number": 24231,
        "pr_file": "packages/client/src/generation/TSClient/Model.ts",
        "discussion_id": "1605317546",
        "commented_code": "@@ -41,13 +43,16 @@ import { getModelActions } from './utils/getModelActions'\n \n export class Model implements Generable {\n   protected type: DMMF.OutputType\n+  protected createManyAndReturnType: undefined | DMMF.OutputType\n   protected mapping?: DMMF.ModelMapping\n   private dmmf: DMMFHelper\n   private genericsInfo: GenericArgsInfo\n   constructor(protected readonly model: DMMF.Model, protected readonly context: GenerateContext) {\n     this.dmmf = context.dmmf\n     this.genericsInfo = context.genericArgsInfo\n     this.type = this.context.dmmf.outputTypeMap.model[model.name]\n+\n+    this.createManyAndReturnType = this.context.dmmf.outputTypeMap.model[`CreateMany${model.name}AndReturnOutputType`]",
        "comment_created_at": "2024-05-21T08:58:39+00:00",
        "comment_author": "Jolg42",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1334796811",
    "pr_number": 21195,
    "pr_file": "packages/cli/src/Init.ts",
    "created_at": "2023-09-22T20:36:55+00:00",
    "commented_code": "fs.mkdirSync(prismaFolder)\n     }\n \n-    fs.writeFileSync(path.join(prismaFolder, 'schema.prisma'), defaultSchema(provider))\n+    if (args['--with-model']) {\n+      fs.writeFileSync(path.join(prismaFolder, 'schema.prisma'), withModelSchema(provider))",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1334796811",
        "repo_full_name": "prisma/prisma",
        "pr_number": 21195,
        "pr_file": "packages/cli/src/Init.ts",
        "discussion_id": "1334796811",
        "commented_code": "@@ -236,7 +261,11 @@ export class Init implements Command {\n       fs.mkdirSync(prismaFolder)\n     }\n \n-    fs.writeFileSync(path.join(prismaFolder, 'schema.prisma'), defaultSchema(provider))\n+    if (args['--with-model']) {\n+      fs.writeFileSync(path.join(prismaFolder, 'schema.prisma'), withModelSchema(provider))",
        "comment_created_at": "2023-09-22T20:36:55+00:00",
        "comment_author": "janpio",
        "comment_body": "To avoid duplication of the `datasource` and `generator` blocks, could we re-use `defaultSchema` here and just add the model at the bottom?",
        "pr_file_module": null
      }
    ]
  }
]