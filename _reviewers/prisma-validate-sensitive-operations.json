[
  {
    "discussion_id": "2014412164",
    "pr_number": 26732,
    "pr_file": "packages/client-generator-ts/src/generateClient.ts",
    "created_at": "2025-03-26T15:17:16+00:00",
    "commented_code": "assertNever(engineType, 'Unknown engine type')\n }\n \n-/**\n- * Attempts to delete the output directory.\n- * @param outputDir\n- */\n async function deleteOutputDir(outputDir: string) {\n   try {\n-    debug(`attempting to delete ${outputDir} recursively`)\n-    // we want to make sure that if we delete, we delete the right directory\n-    if (require(`${outputDir}/package.json`).name?.startsWith(GENERATED_PACKAGE_NAME_PREFIX)) {\n-      await fs.rmdir(outputDir, { recursive: true }).catch(() => {\n-        debug(`failed to delete ${outputDir} recursively`)\n-      })\n+    const files = await fs.readdir(outputDir)\n+\n+    if (files.length === 0) {\n+      return\n     }\n-  } catch {\n-    debug(`failed to delete ${outputDir} recursively, not found`)\n-  }\n-}\n \n-/**\n- * This function ensures that each generated client has unique package name\n- * It appends sha256 of the schema to the fixed prefix. That ensures unique schemas\n- * produce unique generated packages while still keeping `generate` results reproducible.\n- *\n- * Without unique package name, if you have several TS clients in the project, TS Compiler\n- * might merge different `Prisma` namespace declarations together and produce unusable results.\n- *\n- * @param datamodel\n- * @returns\n- */\n-function getUniquePackageName(datamodel: string) {\n-  const hash = createHash('sha256')\n-  hash.write(datamodel)\n-  return `${GENERATED_PACKAGE_NAME_PREFIX}${hash.digest().toString('hex')}`\n-}\n+    // TODO: replace with `client.ts`\n+    if (!files.includes('client.d.ts')) {\n+      // Make sure users don't accidentally wipe their source code or home directory.\n+      throw new Error(\n+        `${outputDir} exists and is not empty but doesn't look like a generated Prisma Client. ` +\n+          'Please check your output path and remove the existing directory if you indeed want to generate the Prisma Client in that location.',\n+      )\n+    }\n \n-const GENERATED_PACKAGE_NAME_PREFIX = 'prisma-client-'\n+    await fs.rm(outputDir, { recursive: true, force: true })",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "2014412164",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26732,
        "pr_file": "packages/client-generator-ts/src/generateClient.ts",
        "discussion_id": "2014412164",
        "commented_code": "@@ -598,39 +481,27 @@ function getNodeRuntimeName(engineType: ClientEngineType) {\n   assertNever(engineType, 'Unknown engine type')\n }\n \n-/**\n- * Attempts to delete the output directory.\n- * @param outputDir\n- */\n async function deleteOutputDir(outputDir: string) {\n   try {\n-    debug(`attempting to delete ${outputDir} recursively`)\n-    // we want to make sure that if we delete, we delete the right directory\n-    if (require(`${outputDir}/package.json`).name?.startsWith(GENERATED_PACKAGE_NAME_PREFIX)) {\n-      await fs.rmdir(outputDir, { recursive: true }).catch(() => {\n-        debug(`failed to delete ${outputDir} recursively`)\n-      })\n+    const files = await fs.readdir(outputDir)\n+\n+    if (files.length === 0) {\n+      return\n     }\n-  } catch {\n-    debug(`failed to delete ${outputDir} recursively, not found`)\n-  }\n-}\n \n-/**\n- * This function ensures that each generated client has unique package name\n- * It appends sha256 of the schema to the fixed prefix. That ensures unique schemas\n- * produce unique generated packages while still keeping `generate` results reproducible.\n- *\n- * Without unique package name, if you have several TS clients in the project, TS Compiler\n- * might merge different `Prisma` namespace declarations together and produce unusable results.\n- *\n- * @param datamodel\n- * @returns\n- */\n-function getUniquePackageName(datamodel: string) {\n-  const hash = createHash('sha256')\n-  hash.write(datamodel)\n-  return `${GENERATED_PACKAGE_NAME_PREFIX}${hash.digest().toString('hex')}`\n-}\n+    // TODO: replace with `client.ts`\n+    if (!files.includes('client.d.ts')) {\n+      // Make sure users don't accidentally wipe their source code or home directory.\n+      throw new Error(\n+        `${outputDir} exists and is not empty but doesn't look like a generated Prisma Client. ` +\n+          'Please check your output path and remove the existing directory if you indeed want to generate the Prisma Client in that location.',\n+      )\n+    }\n \n-const GENERATED_PACKAGE_NAME_PREFIX = 'prisma-client-'\n+    await fs.rm(outputDir, { recursive: true, force: true })",
        "comment_created_at": "2025-03-26T15:17:16+00:00",
        "comment_author": "viktor-ferenczi",
        "comment_body": "I still don't like to have `rm -rf` executed by our code. It may backfire spectacularly in the future in unexpected ways.\r\n\r\nFor extra safety: Can we iterate on the files (and subdirs if we add such) and delete only the ones with a file name pattern matching what we generate? For example `*.d.ts` or so?",
        "pr_file_module": null
      },
      {
        "comment_id": "2018468690",
        "repo_full_name": "prisma/prisma",
        "pr_number": 26732,
        "pr_file": "packages/client-generator-ts/src/generateClient.ts",
        "discussion_id": "2014412164",
        "commented_code": "@@ -598,39 +481,27 @@ function getNodeRuntimeName(engineType: ClientEngineType) {\n   assertNever(engineType, 'Unknown engine type')\n }\n \n-/**\n- * Attempts to delete the output directory.\n- * @param outputDir\n- */\n async function deleteOutputDir(outputDir: string) {\n   try {\n-    debug(`attempting to delete ${outputDir} recursively`)\n-    // we want to make sure that if we delete, we delete the right directory\n-    if (require(`${outputDir}/package.json`).name?.startsWith(GENERATED_PACKAGE_NAME_PREFIX)) {\n-      await fs.rmdir(outputDir, { recursive: true }).catch(() => {\n-        debug(`failed to delete ${outputDir} recursively`)\n-      })\n+    const files = await fs.readdir(outputDir)\n+\n+    if (files.length === 0) {\n+      return\n     }\n-  } catch {\n-    debug(`failed to delete ${outputDir} recursively, not found`)\n-  }\n-}\n \n-/**\n- * This function ensures that each generated client has unique package name\n- * It appends sha256 of the schema to the fixed prefix. That ensures unique schemas\n- * produce unique generated packages while still keeping `generate` results reproducible.\n- *\n- * Without unique package name, if you have several TS clients in the project, TS Compiler\n- * might merge different `Prisma` namespace declarations together and produce unusable results.\n- *\n- * @param datamodel\n- * @returns\n- */\n-function getUniquePackageName(datamodel: string) {\n-  const hash = createHash('sha256')\n-  hash.write(datamodel)\n-  return `${GENERATED_PACKAGE_NAME_PREFIX}${hash.digest().toString('hex')}`\n-}\n+    // TODO: replace with `client.ts`\n+    if (!files.includes('client.d.ts')) {\n+      // Make sure users don't accidentally wipe their source code or home directory.\n+      throw new Error(\n+        `${outputDir} exists and is not empty but doesn't look like a generated Prisma Client. ` +\n+          'Please check your output path and remove the existing directory if you indeed want to generate the Prisma Client in that location.',\n+      )\n+    }\n \n-const GENERATED_PACKAGE_NAME_PREFIX = 'prisma-client-'\n+    await fs.rm(outputDir, { recursive: true, force: true })",
        "comment_created_at": "2025-03-28T11:18:32+00:00",
        "comment_author": "aqrln",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1116313630",
    "pr_number": 17893,
    "pr_file": "packages/internals/src/migrateEngineCommands.ts",
    "created_at": "2023-02-23T22:26:21+00:00",
    "commented_code": "return logs\n }\n \n+function getNextIdxIfFound(lines: string[], entry: string): number | undefined {\n+  const idx = lines.indexOf(entry)\n+  if (idx === -1) {\n+    return undefined\n+  }\n+  return idx + 1\n+}\n+\n+function redactFailedCommand(message: string) {\n+  // remove the unknown password that follows '--datasource' from message:",
    "repo_full_name": "prisma/prisma",
    "discussion_comments": [
      {
        "comment_id": "1116313630",
        "repo_full_name": "prisma/prisma",
        "pr_number": 17893,
        "pr_file": "packages/internals/src/migrateEngineCommands.ts",
        "discussion_id": "1116313630",
        "commented_code": "@@ -63,6 +64,24 @@ function parseJsonFromStderr(stderr: string): MigrateEngineLogLine[] {\n   return logs\n }\n \n+function getNextIdxIfFound(lines: string[], entry: string): number | undefined {\n+  const idx = lines.indexOf(entry)\n+  if (idx === -1) {\n+    return undefined\n+  }\n+  return idx + 1\n+}\n+\n+function redactFailedCommand(message: string) {\n+  // remove the unknown password that follows '--datasource' from message:",
        "comment_created_at": "2023-02-23T22:26:21+00:00",
        "comment_author": "jkomyno",
        "comment_body": "```suggestion\r\n  // remove the connection url that follows '--datasource' from the given `message`.\r\n  // Note: if the command isn't properly formed, i.e., no connection url follows `--datasource`, we risk redacting an irrelevant part of the command\r\n```",
        "pr_file_module": null
      }
    ]
  }
]