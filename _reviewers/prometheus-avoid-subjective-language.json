[
  {
    "discussion_id": "2169117491",
    "pr_number": 16777,
    "pr_file": "docs/feature_flags.md",
    "created_at": "2025-06-26T13:46:04+00:00",
    "commented_code": "parentheses. Without parentheses, only the first duration value will be used in\n the offset calculation.\n \n+An additinal keyword, `step()`, is available in duration expressions. In range\n+queries, this represents the resolution step width. It is `0s` for instant\n+queries.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2169117491",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16777,
        "pr_file": "docs/feature_flags.md",
        "discussion_id": "2169117491",
        "commented_code": "@@ -203,6 +205,10 @@ When using offset with duration expressions, you must wrap the expression in\n parentheses. Without parentheses, only the first duration value will be used in\n the offset calculation.\n \n+An additinal keyword, `step()`, is available in duration expressions. In range\n+queries, this represents the resolution step width. It is `0s` for instant\n+queries. ",
        "comment_created_at": "2025-06-26T13:46:04+00:00",
        "comment_author": "beorn7",
        "comment_body": "Typo `additinal`. And maybe let's avoid the word `keyword` which has many technical implementation. We avoided it when documenting `start()` and `end()`, too. Following the wording of the latter, maybe write the following:\r\n\r\n```suggestion\r\nAdditionally, `step()` can be used in duration expressions. For a range\r\nquery, it resolves to the step width of the range query. For an instant query, it resolves to `0s`. \r\n```\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2171089440",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16777,
        "pr_file": "docs/feature_flags.md",
        "discussion_id": "2169117491",
        "commented_code": "@@ -203,6 +205,10 @@ When using offset with duration expressions, you must wrap the expression in\n parentheses. Without parentheses, only the first duration value will be used in\n the offset calculation.\n \n+An additinal keyword, `step()`, is available in duration expressions. In range\n+queries, this represents the resolution step width. It is `0s` for instant\n+queries. ",
        "comment_created_at": "2025-06-27T07:49:20+00:00",
        "comment_author": "roidelapluie",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174900663",
    "pr_number": 16716,
    "pr_file": "docs/querying/operators.md",
    "created_at": "2025-06-30T11:56:15+00:00",
    "commented_code": "scalar that is the result of the operator applied to both scalar operands.\n \n **Between an instant vector and a scalar**, the operator is applied to the\n-value of every data sample in the vector. If the data sample is a float, the\n-operation performed on the data sample is again obvious, e.g. if an instant\n-vector of float samples is multiplied by 2, the result is another vector of\n-float samples in which every sample value of the original vector is multiplied\n-by 2. For vector elements that are histogram samples, the behavior is the\n-following: For `*`, all bucket populations and the count and the sum of\n-observations are multiplied by the scalar. For `/`, the histogram sample has to\n-be on the left hand side (LHS), followed by the scalar on the right hand side\n-(RHS). All bucket populations and the count and the sum of observations are\n-then divided by the scalar. A division by zero results in a histogram with no\n-regular buckets and the zero bucket population and the count and sum of\n-observations all set to +Inf, -Inf, or NaN, depending on their values in the\n-input histogram (positive, negative, or zero/NaN, respectively). For `/` with a\n-scalar on the LHS and a histogram sample on the RHS, and similarly for all\n-other arithmetic binary operators in any combination of a scalar and a\n-histogram sample, there is no result and the corresponding element is removed\n-from the resulting vector. Such a removal is flagged by an info-level\n-annotation.\n+value of every data sample in the vector. \n+\n+If the data sample is a float, the operation performed on the data sample is\n+again obvious, e.g. if an instant vector of float samples is multiplied by 2,\n+the result is another vector of float samples in which every sample value of\n+the original vector is multiplied by 2.\n+\n+For vector elements that are histogram samples, the behavior is the\n+following:\n+* For `*`, all bucket populations and the count and the sum of observations \n+  are multiplied by the scalar.\n+\n+* For `/`, the histogram sample has to be on the left hand side (LHS), followed \n+  by the scalar on the right hand side (RHS). All bucket populations and the count \n+  and the sum of observations are then divided by the scalar. A division by zero\n+  results in a histogram with no regular buckets and the zero bucket population \n+  and the count and sum of observations all set to +Inf, -Inf, or NaN, depending \n+  on their values in the input histogram (positive, negative, or zero/NaN, respectively). \n+\n+* For `/` with a scalar on the LHS and a histogram sample on the RHS, and similarly for all\n+  other arithmetic binary operators in any combination of a scalar and a\n+  histogram sample, there is no result and the corresponding element is removed\n+  from the resulting vector. Such a removal is flagged by an info-level\n+  annotation.\n \n **Between two instant vectors**, a binary arithmetic operator is applied to\n each entry in the LHS vector and its [matching element](#vector-matching) in\n the RHS vector. The result is propagated into the result vector with the\n grouping labels becoming the output label set. Entries for which no matching\n-entry in the right-hand vector can be found are not part of the result. If two\n-float samples are matched, the behavior is obvious. If a float sample is\n-matched with a histogram sample, the behavior follows the same logic as between\n-a scalar and a histogram sample (see above), i.e. `*` and `/` (the latter with\n-the histogram sample on the LHS) are valid operations, while all others lead to\n-the removal of the corresponding element from the resulting vector. If two\n-histogram samples are matched, only `+` and `-` are valid operations, each\n-adding or substracting all matching bucket populations and the count and the\n+entry in the right-hand vector can be found are not part of the result.\n+\n+If two float samples are matched, the behavior is obvious.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2174900663",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16716,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2174900663",
        "commented_code": "@@ -29,43 +29,52 @@ special values like `NaN`, `+Inf`, and `-Inf`.\n scalar that is the result of the operator applied to both scalar operands.\n \n **Between an instant vector and a scalar**, the operator is applied to the\n-value of every data sample in the vector. If the data sample is a float, the\n-operation performed on the data sample is again obvious, e.g. if an instant\n-vector of float samples is multiplied by 2, the result is another vector of\n-float samples in which every sample value of the original vector is multiplied\n-by 2. For vector elements that are histogram samples, the behavior is the\n-following: For `*`, all bucket populations and the count and the sum of\n-observations are multiplied by the scalar. For `/`, the histogram sample has to\n-be on the left hand side (LHS), followed by the scalar on the right hand side\n-(RHS). All bucket populations and the count and the sum of observations are\n-then divided by the scalar. A division by zero results in a histogram with no\n-regular buckets and the zero bucket population and the count and sum of\n-observations all set to +Inf, -Inf, or NaN, depending on their values in the\n-input histogram (positive, negative, or zero/NaN, respectively). For `/` with a\n-scalar on the LHS and a histogram sample on the RHS, and similarly for all\n-other arithmetic binary operators in any combination of a scalar and a\n-histogram sample, there is no result and the corresponding element is removed\n-from the resulting vector. Such a removal is flagged by an info-level\n-annotation.\n+value of every data sample in the vector. \n+\n+If the data sample is a float, the operation performed on the data sample is\n+again obvious, e.g. if an instant vector of float samples is multiplied by 2,\n+the result is another vector of float samples in which every sample value of\n+the original vector is multiplied by 2.\n+\n+For vector elements that are histogram samples, the behavior is the\n+following:\n+* For `*`, all bucket populations and the count and the sum of observations \n+  are multiplied by the scalar.\n+\n+* For `/`, the histogram sample has to be on the left hand side (LHS), followed \n+  by the scalar on the right hand side (RHS). All bucket populations and the count \n+  and the sum of observations are then divided by the scalar. A division by zero\n+  results in a histogram with no regular buckets and the zero bucket population \n+  and the count and sum of observations all set to +Inf, -Inf, or NaN, depending \n+  on their values in the input histogram (positive, negative, or zero/NaN, respectively). \n+\n+* For `/` with a scalar on the LHS and a histogram sample on the RHS, and similarly for all\n+  other arithmetic binary operators in any combination of a scalar and a\n+  histogram sample, there is no result and the corresponding element is removed\n+  from the resulting vector. Such a removal is flagged by an info-level\n+  annotation.\n \n **Between two instant vectors**, a binary arithmetic operator is applied to\n each entry in the LHS vector and its [matching element](#vector-matching) in\n the RHS vector. The result is propagated into the result vector with the\n grouping labels becoming the output label set. Entries for which no matching\n-entry in the right-hand vector can be found are not part of the result. If two\n-float samples are matched, the behavior is obvious. If a float sample is\n-matched with a histogram sample, the behavior follows the same logic as between\n-a scalar and a histogram sample (see above), i.e. `*` and `/` (the latter with\n-the histogram sample on the LHS) are valid operations, while all others lead to\n-the removal of the corresponding element from the resulting vector. If two\n-histogram samples are matched, only `+` and `-` are valid operations, each\n-adding or substracting all matching bucket populations and the count and the\n+entry in the right-hand vector can be found are not part of the result.\n+\n+If two float samples are matched, the behavior is obvious. ",
        "comment_created_at": "2025-06-30T11:56:15+00:00",
        "comment_author": "juliusv",
        "comment_body": "I would like to avoid too much use of the word \"obvious\" in documentation, especially for people who are already overwhelmed and don't feel that things are obvious (it's too subjective) :) How about something more like:\r\n\r\n```suggestion\r\nIf two float samples are matched, the result sample value is generated by applying the binary operator to the two input values in a straightforward way.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2177109473",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16716,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2174900663",
        "commented_code": "@@ -29,43 +29,52 @@ special values like `NaN`, `+Inf`, and `-Inf`.\n scalar that is the result of the operator applied to both scalar operands.\n \n **Between an instant vector and a scalar**, the operator is applied to the\n-value of every data sample in the vector. If the data sample is a float, the\n-operation performed on the data sample is again obvious, e.g. if an instant\n-vector of float samples is multiplied by 2, the result is another vector of\n-float samples in which every sample value of the original vector is multiplied\n-by 2. For vector elements that are histogram samples, the behavior is the\n-following: For `*`, all bucket populations and the count and the sum of\n-observations are multiplied by the scalar. For `/`, the histogram sample has to\n-be on the left hand side (LHS), followed by the scalar on the right hand side\n-(RHS). All bucket populations and the count and the sum of observations are\n-then divided by the scalar. A division by zero results in a histogram with no\n-regular buckets and the zero bucket population and the count and sum of\n-observations all set to +Inf, -Inf, or NaN, depending on their values in the\n-input histogram (positive, negative, or zero/NaN, respectively). For `/` with a\n-scalar on the LHS and a histogram sample on the RHS, and similarly for all\n-other arithmetic binary operators in any combination of a scalar and a\n-histogram sample, there is no result and the corresponding element is removed\n-from the resulting vector. Such a removal is flagged by an info-level\n-annotation.\n+value of every data sample in the vector. \n+\n+If the data sample is a float, the operation performed on the data sample is\n+again obvious, e.g. if an instant vector of float samples is multiplied by 2,\n+the result is another vector of float samples in which every sample value of\n+the original vector is multiplied by 2.\n+\n+For vector elements that are histogram samples, the behavior is the\n+following:\n+* For `*`, all bucket populations and the count and the sum of observations \n+  are multiplied by the scalar.\n+\n+* For `/`, the histogram sample has to be on the left hand side (LHS), followed \n+  by the scalar on the right hand side (RHS). All bucket populations and the count \n+  and the sum of observations are then divided by the scalar. A division by zero\n+  results in a histogram with no regular buckets and the zero bucket population \n+  and the count and sum of observations all set to +Inf, -Inf, or NaN, depending \n+  on their values in the input histogram (positive, negative, or zero/NaN, respectively). \n+\n+* For `/` with a scalar on the LHS and a histogram sample on the RHS, and similarly for all\n+  other arithmetic binary operators in any combination of a scalar and a\n+  histogram sample, there is no result and the corresponding element is removed\n+  from the resulting vector. Such a removal is flagged by an info-level\n+  annotation.\n \n **Between two instant vectors**, a binary arithmetic operator is applied to\n each entry in the LHS vector and its [matching element](#vector-matching) in\n the RHS vector. The result is propagated into the result vector with the\n grouping labels becoming the output label set. Entries for which no matching\n-entry in the right-hand vector can be found are not part of the result. If two\n-float samples are matched, the behavior is obvious. If a float sample is\n-matched with a histogram sample, the behavior follows the same logic as between\n-a scalar and a histogram sample (see above), i.e. `*` and `/` (the latter with\n-the histogram sample on the LHS) are valid operations, while all others lead to\n-the removal of the corresponding element from the resulting vector. If two\n-histogram samples are matched, only `+` and `-` are valid operations, each\n-adding or substracting all matching bucket populations and the count and the\n+entry in the right-hand vector can be found are not part of the result.\n+\n+If two float samples are matched, the behavior is obvious. ",
        "comment_created_at": "2025-07-01T10:12:19+00:00",
        "comment_author": "charleskorn",
        "comment_body": "Agree, I was avoiding changing too much as part of this PR. I've fixed this instance in 665eb3d, and I'll fix another instance shortly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1792245215",
    "pr_number": 15125,
    "pr_file": "docs/configuration/unit_testing_rules.md",
    "created_at": "2024-10-08T17:19:14+00:00",
    "commented_code": "summary: \"Instance {{ $labels.instance }} down\"\n         description: \"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.\"\n ```\n+\n+### Time within tests\n+\n+It should be noted that in all tests, either in `alert_test_case` or\n+`promql_test_case`, the output from all functions related to the current time,\n+for example the `time()` and `day_of_*()` functions, will output a consistent value\n+for tests.\n+\n+At the start of the test evaluation, `time()` returns 0 and therefore when under test\n+`time()` will return a value of `0 + eval_time`.\n+\n+If you need to write tests for alerts that use functions relating to the current\n+time, make sure that the values given to your `input_series` are placed far\n+enough in the past, relative to the evaluation time described above. The values\n+can for example be negative timestamps so that with a very small `eval_time` the\n+alert can be expected to trigger.\n+\n+Another method that's known to work is to instead bump `eval_time` in the future\n+so that the timestamp output by `time()` will be a higher value and the values\n+in `input_series` will be far enough apart from that point in time so that the\n+alerts will trigger. This method has the downside of making promtool generate a\n+timeseries database that contains a value for each `input_series` for each\n+`interval` for the given test. This can become very slow relatively easily and\n+can end up consuming a lot of RAM for running your test. By instead using values",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1792245215",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15125,
        "pr_file": "docs/configuration/unit_testing_rules.md",
        "discussion_id": "1792245215",
        "commented_code": "@@ -267,3 +267,30 @@ groups:\n         summary: \"Instance {{ $labels.instance }} down\"\n         description: \"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.\"\n ```\n+\n+### Time within tests\n+\n+It should be noted that in all tests, either in `alert_test_case` or\n+`promql_test_case`, the output from all functions related to the current time,\n+for example the `time()` and `day_of_*()` functions, will output a consistent value\n+for tests.\n+\n+At the start of the test evaluation, `time()` returns 0 and therefore when under test\n+`time()` will return a value of `0 + eval_time`.\n+\n+If you need to write tests for alerts that use functions relating to the current\n+time, make sure that the values given to your `input_series` are placed far\n+enough in the past, relative to the evaluation time described above. The values\n+can for example be negative timestamps so that with a very small `eval_time` the\n+alert can be expected to trigger.\n+\n+Another method that's known to work is to instead bump `eval_time` in the future\n+so that the timestamp output by `time()` will be a higher value and the values\n+in `input_series` will be far enough apart from that point in time so that the\n+alerts will trigger. This method has the downside of making promtool generate a\n+timeseries database that contains a value for each `input_series` for each\n+`interval` for the given test. This can become very slow relatively easily and\n+can end up consuming a lot of RAM for running your test. By instead using values",
        "comment_created_at": "2024-10-08T17:19:14+00:00",
        "comment_author": "bboreham",
        "comment_body": "Is it really \"known to work\" if these are the consequences?",
        "pr_file_module": null
      },
      {
        "comment_id": "1793524498",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15125,
        "pr_file": "docs/configuration/unit_testing_rules.md",
        "discussion_id": "1792245215",
        "commented_code": "@@ -267,3 +267,30 @@ groups:\n         summary: \"Instance {{ $labels.instance }} down\"\n         description: \"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.\"\n ```\n+\n+### Time within tests\n+\n+It should be noted that in all tests, either in `alert_test_case` or\n+`promql_test_case`, the output from all functions related to the current time,\n+for example the `time()` and `day_of_*()` functions, will output a consistent value\n+for tests.\n+\n+At the start of the test evaluation, `time()` returns 0 and therefore when under test\n+`time()` will return a value of `0 + eval_time`.\n+\n+If you need to write tests for alerts that use functions relating to the current\n+time, make sure that the values given to your `input_series` are placed far\n+enough in the past, relative to the evaluation time described above. The values\n+can for example be negative timestamps so that with a very small `eval_time` the\n+alert can be expected to trigger.\n+\n+Another method that's known to work is to instead bump `eval_time` in the future\n+so that the timestamp output by `time()` will be a higher value and the values\n+in `input_series` will be far enough apart from that point in time so that the\n+alerts will trigger. This method has the downside of making promtool generate a\n+timeseries database that contains a value for each `input_series` for each\n+`interval` for the given test. This can become very slow relatively easily and\n+can end up consuming a lot of RAM for running your test. By instead using values",
        "comment_created_at": "2024-10-09T13:24:45+00:00",
        "comment_author": "lelutin",
        "comment_body": "that's a fair question. I've used this technique first but pushing the eval_time 2 days and then 65 days and keeping the input_series values at 0, and it did work. but already with `eval_time = 65d` the test was taking around 10~15s to run, so I'd imagine that pushing much further would render promtool kinda useless.\r\n\r\nso we could play around with the wording in the document. it does but maybe only for relatevely small values",
        "pr_file_module": null
      },
      {
        "comment_id": "1829789631",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15125,
        "pr_file": "docs/configuration/unit_testing_rules.md",
        "discussion_id": "1792245215",
        "commented_code": "@@ -267,3 +267,30 @@ groups:\n         summary: \"Instance {{ $labels.instance }} down\"\n         description: \"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.\"\n ```\n+\n+### Time within tests\n+\n+It should be noted that in all tests, either in `alert_test_case` or\n+`promql_test_case`, the output from all functions related to the current time,\n+for example the `time()` and `day_of_*()` functions, will output a consistent value\n+for tests.\n+\n+At the start of the test evaluation, `time()` returns 0 and therefore when under test\n+`time()` will return a value of `0 + eval_time`.\n+\n+If you need to write tests for alerts that use functions relating to the current\n+time, make sure that the values given to your `input_series` are placed far\n+enough in the past, relative to the evaluation time described above. The values\n+can for example be negative timestamps so that with a very small `eval_time` the\n+alert can be expected to trigger.\n+\n+Another method that's known to work is to instead bump `eval_time` in the future\n+so that the timestamp output by `time()` will be a higher value and the values\n+in `input_series` will be far enough apart from that point in time so that the\n+alerts will trigger. This method has the downside of making promtool generate a\n+timeseries database that contains a value for each `input_series` for each\n+`interval` for the given test. This can become very slow relatively easily and\n+can end up consuming a lot of RAM for running your test. By instead using values",
        "comment_created_at": "2024-11-05T17:57:15+00:00",
        "comment_author": "lelutin",
        "comment_body": "@bboreham Maybe we could turn this first sentence upside down and rather say something like the following:\r\n\r\n> One's intuition could be to push `eval_time` into the future so that the timestamp returned by `time()` looks more like a realistic timestamp, but it is strongly recommended against since doing so quickly has some serious performance implications. [...rest of paragraphs]\r\n\r\nwhat do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "2177408849",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15125,
        "pr_file": "docs/configuration/unit_testing_rules.md",
        "discussion_id": "1792245215",
        "commented_code": "@@ -267,3 +267,30 @@ groups:\n         summary: \"Instance {{ $labels.instance }} down\"\n         description: \"{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.\"\n ```\n+\n+### Time within tests\n+\n+It should be noted that in all tests, either in `alert_test_case` or\n+`promql_test_case`, the output from all functions related to the current time,\n+for example the `time()` and `day_of_*()` functions, will output a consistent value\n+for tests.\n+\n+At the start of the test evaluation, `time()` returns 0 and therefore when under test\n+`time()` will return a value of `0 + eval_time`.\n+\n+If you need to write tests for alerts that use functions relating to the current\n+time, make sure that the values given to your `input_series` are placed far\n+enough in the past, relative to the evaluation time described above. The values\n+can for example be negative timestamps so that with a very small `eval_time` the\n+alert can be expected to trigger.\n+\n+Another method that's known to work is to instead bump `eval_time` in the future\n+so that the timestamp output by `time()` will be a higher value and the values\n+in `input_series` will be far enough apart from that point in time so that the\n+alerts will trigger. This method has the downside of making promtool generate a\n+timeseries database that contains a value for each `input_series` for each\n+`interval` for the given test. This can become very slow relatively easily and\n+can end up consuming a lot of RAM for running your test. By instead using values",
        "comment_created_at": "2025-07-01T11:56:18+00:00",
        "comment_author": "bboreham",
        "comment_body": "Yes that's better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154484114",
    "pr_number": 16724,
    "pr_file": "docs/querying/functions.md",
    "created_at": "2025-06-18T12:33:19+00:00",
    "commented_code": "is applied within that bucket. Otherwise, the upper bound of the lowest\n   bucket is returned for quantiles located in the lowest bucket.\n \n-Special cases for native histograms (relevant for the exact interpolation\n-happening within the zero bucket):\n+Special cases for native histograms:\n \n+* If the native histogram with standard exponential buckets has `NaN`\n+  observations and the quantile falls into one of the existing exponential\n+  buckets, an info level annotation is also returned warning about the result\n+  skewing higher then normally, due to `NaN` observations treated as `+Inf`.\n+* If the native histogram with standard exponential buckets has `NaN`\n+  observations and the quantile falls above all of the existing exponential\n+  buckets, `NaN` is returned and an info level annotation is also returned\n+  warning about the result being `NaN`.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2154484114",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16724,
        "pr_file": "docs/querying/functions.md",
        "discussion_id": "2154484114",
        "commented_code": "@@ -385,9 +390,16 @@ Special cases for classic histograms:\n   is applied within that bucket. Otherwise, the upper bound of the lowest\n   bucket is returned for quantiles located in the lowest bucket.\n \n-Special cases for native histograms (relevant for the exact interpolation\n-happening within the zero bucket):\n+Special cases for native histograms:\n \n+* If the native histogram with standard exponential buckets has `NaN`\n+  observations and the quantile falls into one of the existing exponential\n+  buckets, an info level annotation is also returned warning about the result\n+  skewing higher then normally, due to `NaN` observations treated as `+Inf`.\n+* If the native histogram with standard exponential buckets has `NaN`\n+  observations and the quantile falls above all of the existing exponential\n+  buckets, `NaN` is returned and an info level annotation is also returned\n+  warning about the result being `NaN`.",
        "comment_created_at": "2025-06-18T12:33:19+00:00",
        "comment_author": "beorn7",
        "comment_body": "Nit: It is confusing to say that an \"info level annotation\" is \"warning\" about something, as there is also a \"warning level annotation\".\r\n\r\n```suggestion\r\n* If a native histogram with standard exponential buckets has `NaN`\r\n  observations and the quantile falls into one of the existing exponential\r\n  buckets, the result is skewed towards higher values due to `NaN`\r\n  observations treated as `+Inf`. This is flagged with an info level\r\n  annotation.\r\n* If a native histogram with standard exponential buckets has `NaN`\r\n  observations and the quantile falls above all of the existing exponential\r\n  buckets, `NaN` is returned. This is flagged with an info level annotation.\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2158257603",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16724,
        "pr_file": "docs/querying/functions.md",
        "discussion_id": "2154484114",
        "commented_code": "@@ -385,9 +390,16 @@ Special cases for classic histograms:\n   is applied within that bucket. Otherwise, the upper bound of the lowest\n   bucket is returned for quantiles located in the lowest bucket.\n \n-Special cases for native histograms (relevant for the exact interpolation\n-happening within the zero bucket):\n+Special cases for native histograms:\n \n+* If the native histogram with standard exponential buckets has `NaN`\n+  observations and the quantile falls into one of the existing exponential\n+  buckets, an info level annotation is also returned warning about the result\n+  skewing higher then normally, due to `NaN` observations treated as `+Inf`.\n+* If the native histogram with standard exponential buckets has `NaN`\n+  observations and the quantile falls above all of the existing exponential\n+  buckets, `NaN` is returned and an info level annotation is also returned\n+  warning about the result being `NaN`.",
        "comment_created_at": "2025-06-20T07:37:55+00:00",
        "comment_author": "krajorama",
        "comment_body": "copied in 8006bcd160851f18c44708f639ea8a47ba7f5a46",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057935668",
    "pr_number": 15365,
    "pr_file": "docs/feature_flags.md",
    "created_at": "2025-04-24T09:16:16+00:00",
    "commented_code": "* `(2 ^ 3) * 1m` is the equivalent to `8m` or `480s`\n \n [d2c]: https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor\n+\n+## Use Uncached IO\n+\n+`--enable-feature=use-uncached-io`\n+\n+Only available on Linux.\n+\n+When enabled, it forces qualifying I/O operations to bypass the page cache. Its primary",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2057935668",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15365,
        "pr_file": "docs/feature_flags.md",
        "discussion_id": "2057935668",
        "commented_code": "@@ -218,3 +218,17 @@ Examples of equivalent durations:\n * `(2 ^ 3) * 1m` is the equivalent to `8m` or `480s`\n \n [d2c]: https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor\n+\n+## Use Uncached IO\n+\n+`--enable-feature=use-uncached-io`\n+\n+Only available on Linux.\n+\n+When enabled, it forces qualifying I/O operations to bypass the page cache. Its primary",
        "comment_created_at": "2025-04-24T09:16:16+00:00",
        "comment_author": "bboreham",
        "comment_body": "Can we find a better way to explain this?  \r\nI suspect most people reading this will not know what \"qualifying I/O operations\" are.\r\n\r\nWould it help to add the word \"experimental\" ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2068417229",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15365,
        "pr_file": "docs/feature_flags.md",
        "discussion_id": "2057935668",
        "commented_code": "@@ -218,3 +218,17 @@ Examples of equivalent durations:\n * `(2 ^ 3) * 1m` is the equivalent to `8m` or `480s`\n \n [d2c]: https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor\n+\n+## Use Uncached IO\n+\n+`--enable-feature=use-uncached-io`\n+\n+Only available on Linux.\n+\n+When enabled, it forces qualifying I/O operations to bypass the page cache. Its primary",
        "comment_created_at": "2025-04-30T10:46:01+00:00",
        "comment_author": "machine424",
        "comment_body": "pushed a new version",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2053990271",
    "pr_number": 16444,
    "pr_file": "docs/querying/functions.md",
    "created_at": "2025-04-22T12:15:29+00:00",
    "commented_code": "`histogram_stddev(v instant-vector)` returns the estimated standard deviation\n of observations for each histogram sample in `v`, based on the geometric mean\n-of the buckets where the observations lie. Float samples are ignored and do not\n-show up in the returned vector.\n+(or arithmetic mean for custom bucket histogram samples) of the buckets where\n+the observations lie. Float samples are ignored and do not show up in the returned\n+vector.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2053990271",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16444,
        "pr_file": "docs/querying/functions.md",
        "discussion_id": "2053990271",
        "commented_code": "@@ -416,8 +416,9 @@ annotation, you should find and remove the source of the invalid data.\n \n `histogram_stddev(v instant-vector)` returns the estimated standard deviation\n of observations for each histogram sample in `v`, based on the geometric mean\n-of the buckets where the observations lie. Float samples are ignored and do not\n-show up in the returned vector.\n+(or arithmetic mean for custom bucket histogram samples) of the buckets where\n+the observations lie. Float samples are ignored and do not show up in the returned\n+vector.",
        "comment_created_at": "2025-04-22T12:15:29+00:00",
        "comment_author": "beorn7",
        "comment_body": "I think we should word this a bit less compact for easier readability and also mention the zero bucket. How about:\r\n\r\n\"`histogram_stddev(v instant-vector)` returns the estimated standard deviation of observations for each histogram sample in `v`, assuming that each observation had a value equal to the mean value of the boundaries of its bucket. For the zero buckets and for buckets with custom boundaries, the arithmetic mean is used. For the usual exponential buckets, the geometric mean is used. Float samples are ignored and do not show up in the returned vector.\"",
        "pr_file_module": null
      },
      {
        "comment_id": "2054007642",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16444,
        "pr_file": "docs/querying/functions.md",
        "discussion_id": "2053990271",
        "commented_code": "@@ -416,8 +416,9 @@ annotation, you should find and remove the source of the invalid data.\n \n `histogram_stddev(v instant-vector)` returns the estimated standard deviation\n of observations for each histogram sample in `v`, based on the geometric mean\n-of the buckets where the observations lie. Float samples are ignored and do not\n-show up in the returned vector.\n+(or arithmetic mean for custom bucket histogram samples) of the buckets where\n+the observations lie. Float samples are ignored and do not show up in the returned\n+vector.",
        "comment_created_at": "2025-04-22T12:25:48+00:00",
        "comment_author": "beorn7",
        "comment_body": "Maybe even better:\r\n\r\n\"`histogram_stddev(v instant-vector)` returns the estimated standard deviation of observations for each histogram sample in `v`. For this estimation, all observations in a bucket are assumed to\r\nhave the value of the mean of the bucket boundaries. For the zero bucket and for buckets with custom boundaries, the arithmetic mean is used. For the usual exponential buckets, the geometric mean is used. Float samples are ignored and do not show up in the returned vector.\"",
        "pr_file_module": null
      }
    ]
  }
]