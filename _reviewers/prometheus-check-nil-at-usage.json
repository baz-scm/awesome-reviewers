[
  {
    "discussion_id": "1745874592",
    "pr_number": 14478,
    "pr_file": "rules/store.go",
    "created_at": "2024-09-05T16:50:15+00:00",
    "commented_code": "+package rules\n+\n+import (\n+\t\"encoding/json\"\n+\t\"os\"\n+\t\"sync\"\n+\n+\t\"github.com/go-kit/log\"\n+\t\"github.com/go-kit/log/level\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+)\n+\n+// FileStore implements the AlertStore interface.\n+type FileStore struct {\n+\tlogger       log.Logger\n+\talertsByRule map[uint64][]*Alert\n+\t// protects the `alertsByRule` map.\n+\tstateMtx         sync.RWMutex\n+\tpath             string\n+\tregisterer       prometheus.Registerer\n+\tstoreInitErrors  prometheus.Counter\n+\talertStoreErrors *prometheus.CounterVec\n+}\n+\n+func NewFileStore(l log.Logger, storagePath string, registerer prometheus.Registerer) *FileStore {\n+\ts := &FileStore{\n+\t\tlogger:       l,\n+\t\talertsByRule: make(map[uint64][]*Alert),\n+\t\tpath:         storagePath,\n+\t\tregisterer:   registerer,\n+\t}\n+\ts.storeInitErrors = prometheus.NewCounter(\n+\t\tprometheus.CounterOpts{\n+\t\t\tNamespace: namespace,\n+\t\t\tName:      \"alert_store_init_errors_total\",\n+\t\t\tHelp:      \"The total number of errors starting alert store.\",\n+\t\t},\n+\t)\n+\ts.alertStoreErrors = prometheus.NewCounterVec(\n+\t\tprometheus.CounterOpts{\n+\t\t\tNamespace: namespace,\n+\t\t\tName:      \"rule_group_alert_store_errors_total\",\n+\t\t\tHelp:      \"The total number of errors in alert store.\",\n+\t\t},\n+\t\t[]string{\"rule_group\"},\n+\t)\n+\ts.initState()\n+\treturn s\n+}\n+\n+// initState reads the state from file storage into the alertsByRule map.\n+func (s *FileStore) initState() {\n+\tif s.registerer != nil {\n+\t\ts.registerer.MustRegister(s.alertStoreErrors, s.storeInitErrors)\n+\t}\n+\tfile, err := os.OpenFile(s.path, os.O_RDWR|os.O_CREATE, 0o666)\n+\tif err != nil {\n+\t\ts.storeInitErrors.Inc()\n+\t\tlevel.Error(s.logger).Log(\"msg\", \"Failed reading alerts state from file\", \"err\", err)\n+\t\treturn\n+\t}\n+\tdefer file.Close()\n+\n+\tvar alertsByRule map[uint64][]*Alert\n+\terr = json.NewDecoder(file).Decode(&alertsByRule)\n+\tif err != nil {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1745874592",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 14478,
        "pr_file": "rules/store.go",
        "discussion_id": "1745874592",
        "commented_code": "@@ -0,0 +1,121 @@\n+package rules\n+\n+import (\n+\t\"encoding/json\"\n+\t\"os\"\n+\t\"sync\"\n+\n+\t\"github.com/go-kit/log\"\n+\t\"github.com/go-kit/log/level\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+)\n+\n+// FileStore implements the AlertStore interface.\n+type FileStore struct {\n+\tlogger       log.Logger\n+\talertsByRule map[uint64][]*Alert\n+\t// protects the `alertsByRule` map.\n+\tstateMtx         sync.RWMutex\n+\tpath             string\n+\tregisterer       prometheus.Registerer\n+\tstoreInitErrors  prometheus.Counter\n+\talertStoreErrors *prometheus.CounterVec\n+}\n+\n+func NewFileStore(l log.Logger, storagePath string, registerer prometheus.Registerer) *FileStore {\n+\ts := &FileStore{\n+\t\tlogger:       l,\n+\t\talertsByRule: make(map[uint64][]*Alert),\n+\t\tpath:         storagePath,\n+\t\tregisterer:   registerer,\n+\t}\n+\ts.storeInitErrors = prometheus.NewCounter(\n+\t\tprometheus.CounterOpts{\n+\t\t\tNamespace: namespace,\n+\t\t\tName:      \"alert_store_init_errors_total\",\n+\t\t\tHelp:      \"The total number of errors starting alert store.\",\n+\t\t},\n+\t)\n+\ts.alertStoreErrors = prometheus.NewCounterVec(\n+\t\tprometheus.CounterOpts{\n+\t\t\tNamespace: namespace,\n+\t\t\tName:      \"rule_group_alert_store_errors_total\",\n+\t\t\tHelp:      \"The total number of errors in alert store.\",\n+\t\t},\n+\t\t[]string{\"rule_group\"},\n+\t)\n+\ts.initState()\n+\treturn s\n+}\n+\n+// initState reads the state from file storage into the alertsByRule map.\n+func (s *FileStore) initState() {\n+\tif s.registerer != nil {\n+\t\ts.registerer.MustRegister(s.alertStoreErrors, s.storeInitErrors)\n+\t}\n+\tfile, err := os.OpenFile(s.path, os.O_RDWR|os.O_CREATE, 0o666)\n+\tif err != nil {\n+\t\ts.storeInitErrors.Inc()\n+\t\tlevel.Error(s.logger).Log(\"msg\", \"Failed reading alerts state from file\", \"err\", err)\n+\t\treturn\n+\t}\n+\tdefer file.Close()\n+\n+\tvar alertsByRule map[uint64][]*Alert\n+\terr = json.NewDecoder(file).Decode(&alertsByRule)\n+\tif err != nil {",
        "comment_created_at": "2024-09-05T16:50:15+00:00",
        "comment_author": "bboreham",
        "comment_body": "Can we rely on `alertsByRule` having something reasonable (such as nil) as its value in this error case?\r\nPerhaps set it to nil to be safe.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989071462",
    "pr_number": 16158,
    "pr_file": "tsdb/querier.go",
    "created_at": "2025-03-11T11:50:14+00:00",
    "commented_code": "return it, it.Err()\n }\n \n-func labelValuesWithMatchers(ctx context.Context, r IndexReader, name string, matchers ...*labels.Matcher) ([]string, error) {\n-\tallValues, err := r.LabelValues(ctx, name)\n+func labelValuesWithMatchers(ctx context.Context, r IndexReader, name string, hints *storage.LabelHints, matchers ...*labels.Matcher) ([]string, error) {\n+\tif hints == nil {\n+\t\thints = &storage.LabelHints{}\n+\t}",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1989071462",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16158,
        "pr_file": "tsdb/querier.go",
        "discussion_id": "1989071462",
        "commented_code": "@@ -390,8 +390,13 @@ func inversePostingsForMatcher(ctx context.Context, ix IndexReader, m *labels.Ma\n \treturn it, it.Err()\n }\n \n-func labelValuesWithMatchers(ctx context.Context, r IndexReader, name string, matchers ...*labels.Matcher) ([]string, error) {\n-\tallValues, err := r.LabelValues(ctx, name)\n+func labelValuesWithMatchers(ctx context.Context, r IndexReader, name string, hints *storage.LabelHints, matchers ...*labels.Matcher) ([]string, error) {\n+\tif hints == nil {\n+\t\thints = &storage.LabelHints{}\n+\t}",
        "comment_created_at": "2025-03-11T11:50:14+00:00",
        "comment_author": "bboreham",
        "comment_body": "Don't bother with this here, just check `hints != nil` at the point you need it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2151619182",
    "pr_number": 16725,
    "pr_file": "promql/engine.go",
    "created_at": "2025-06-17T08:12:29+00:00",
    "commented_code": "if params.Max() < 1 {\n \t\t\treturn nil, annos\n \t\t}\n+\t\tif !convertibleToInt64(params.Max()) {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2151619182",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16725,
        "pr_file": "promql/engine.go",
        "discussion_id": "2151619182",
        "commented_code": "@@ -1433,13 +1433,23 @@ func (ev *evaluator) rangeEvalAgg(ctx context.Context, aggExpr *parser.Aggregate\n \t\tif params.Max() < 1 {\n \t\t\treturn nil, annos\n \t\t}\n+\t\tif !convertibleToInt64(params.Max()) {",
        "comment_created_at": "2025-06-17T08:12:29+00:00",
        "comment_author": "machine424",
        "comment_body": "if `params.Max()` is `minInt64-1` we cannot really say it `overflows` int64.\r\n\r\nlet's have a generic message for both checks or let's use the `v <= maxInt64` and `v >= minInt64` directly for more control on what we check for.\r\n\r\nI'd also use `Parameter` or sth else instead of Scalar.",
        "pr_file_module": null
      },
      {
        "comment_id": "2160339104",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16725,
        "pr_file": "promql/engine.go",
        "discussion_id": "2151619182",
        "commented_code": "@@ -1433,13 +1433,23 @@ func (ev *evaluator) rangeEvalAgg(ctx context.Context, aggExpr *parser.Aggregate\n \t\tif params.Max() < 1 {\n \t\t\treturn nil, annos\n \t\t}\n+\t\tif !convertibleToInt64(params.Max()) {",
        "comment_created_at": "2025-06-22T12:58:15+00:00",
        "comment_author": "MichaHoffmann",
        "comment_body": "Because overflow and underflow read weird if its NaN; lets maybe write \"Parameter value is not convertible to int64\" and check in one condition?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1492695052",
    "pr_number": 13592,
    "pr_file": "model/histogram/generic.go",
    "created_at": "2024-02-16T16:11:48+00:00",
    "commented_code": "return nil\n }\n \n-func getBound(idx, schema int32) float64 {\n+func checkHistogramCustomBounds(bounds []float64, spans []Span) error {\n+\tprev := math.Inf(-1)\n+\tfor _, curr := range bounds {\n+\t\tif curr <= prev {\n+\t\t\treturn fmt.Errorf(\"previous bound is %f and current is %f: %w\", prev, curr, ErrHistogramCustomBucketsInvalid)\n+\t\t}\n+\t\tprev = curr\n+\t}\n+\n+\tvar totalSpanLength int\n+\tfor _, span := range spans {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1492695052",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 13592,
        "pr_file": "model/histogram/generic.go",
        "discussion_id": "1492695052",
        "commented_code": "@@ -393,7 +406,44 @@ func checkHistogramBuckets[BC BucketCount, IBC InternalBucketCount](buckets []IB\n \treturn nil\n }\n \n-func getBound(idx, schema int32) float64 {\n+func checkHistogramCustomBounds(bounds []float64, spans []Span) error {\n+\tprev := math.Inf(-1)\n+\tfor _, curr := range bounds {\n+\t\tif curr <= prev {\n+\t\t\treturn fmt.Errorf(\"previous bound is %f and current is %f: %w\", prev, curr, ErrHistogramCustomBucketsInvalid)\n+\t\t}\n+\t\tprev = curr\n+\t}\n+\n+\tvar totalSpanLength int\n+\tfor _, span := range spans {",
        "comment_created_at": "2024-02-16T16:11:48+00:00",
        "comment_author": "krajorama",
        "comment_body": "Add a check that the span.Offset cannot be negative. (The function `checkHistogramSpans` does not check this condition for the first span, but here we're indexing an array so we need the check.)",
        "pr_file_module": null
      }
    ]
  }
]