[
  {
    "discussion_id": "1918887797",
    "pr_number": 15809,
    "pr_file": "cmd/prometheus/main.go",
    "created_at": "2025-01-16T16:51:03+00:00",
    "commented_code": "agentOnlyFlags, serverOnlyFlags []string\n )\n \n+var DefaultRegistry = prometheus.NewRegistry()",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1918887797",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "cmd/prometheus/main.go",
        "discussion_id": "1918887797",
        "commented_code": "@@ -139,10 +139,12 @@ var (\n \tagentOnlyFlags, serverOnlyFlags []string\n )\n \n+var DefaultRegistry = prometheus.NewRegistry()",
        "comment_created_at": "2025-01-16T16:51:03+00:00",
        "comment_author": "beorn7",
        "comment_body": "I would just call it `registry`. No reason to export anything in `main.go`, and the word `default` seems out of place as it is the intent to _not_ use the default registry.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219231138",
    "pr_number": 16630,
    "pr_file": "storage/remote/write_test.go",
    "created_at": "2025-07-21T13:32:50+00:00",
    "commented_code": "\"actual  : %v\", expected, actual))\n }\n \n-func handleOTLP(t *testing.T, exportRequest pmetricotlp.ExportRequest, otlpCfg config.OTLPConfig) *mockAppendable {\n+func handleOTLP(t *testing.T, exportRequest pmetricotlp.ExportRequest, otlpCfg config.OTLPConfig, typeAndUnitLabels bool) *mockAppendable {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2219231138",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16630,
        "pr_file": "storage/remote/write_test.go",
        "discussion_id": "2219231138",
        "commented_code": "@@ -518,7 +606,7 @@ func requireContainsSample(t *testing.T, actual []mockSample, expected mockSampl\n \t\t\"actual  : %v\", expected, actual))\n }\n \n-func handleOTLP(t *testing.T, exportRequest pmetricotlp.ExportRequest, otlpCfg config.OTLPConfig) *mockAppendable {\n+func handleOTLP(t *testing.T, exportRequest pmetricotlp.ExportRequest, otlpCfg config.OTLPConfig, typeAndUnitLabels bool) *mockAppendable {",
        "comment_created_at": "2025-07-21T13:32:50+00:00",
        "comment_author": "aknuds1",
        "comment_body": "[Nit] For consistency:\n```suggestion\nfunc handleOTLP(t *testing.T, exportRequest pmetricotlp.ExportRequest, otlpCfg config.OTLPConfig, enableTypeAndUnitLabels bool) *mockAppendable {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219238202",
    "pr_number": 16630,
    "pr_file": "web/web.go",
    "created_at": "2025-07-21T13:35:31+00:00",
    "commented_code": "NativeOTLPDeltaIngestion   bool\n \tIsAgent                    bool\n \tCTZeroIngestionEnabled     bool\n+\tAddTypeAndUnitLabels       bool",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2219238202",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16630,
        "pr_file": "web/web.go",
        "discussion_id": "2219238202",
        "commented_code": "@@ -293,6 +293,7 @@ type Options struct {\n \tNativeOTLPDeltaIngestion   bool\n \tIsAgent                    bool\n \tCTZeroIngestionEnabled     bool\n+\tAddTypeAndUnitLabels       bool",
        "comment_created_at": "2025-07-21T13:35:31+00:00",
        "comment_author": "aknuds1",
        "comment_body": "To avoid confusion, I think we should be consistent with the scrape configuration parameter name:\n```suggestion\n\tEnableTypeAndUnitLabels       bool\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2192817501",
    "pr_number": 16841,
    "pr_file": "storage/annotating_storage.go",
    "created_at": "2025-07-08T15:19:37+00:00",
    "commented_code": "+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package storage\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/prometheus/prometheus/model/labels\"\n+\t\"github.com/prometheus/prometheus/util/annotations\"\n+)\n+\n+// AnnotatingStorage wraps given storage and tracks type and unit\n+// labels across series. It will produce an info annotation if there\n+// is a mismatch between type or unit in series with the same name.\n+func AnnotatingStorage(s Storage) Storage {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2192817501",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16841,
        "pr_file": "storage/annotating_storage.go",
        "discussion_id": "2192817501",
        "commented_code": "@@ -0,0 +1,119 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package storage\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/prometheus/prometheus/model/labels\"\n+\t\"github.com/prometheus/prometheus/util/annotations\"\n+)\n+\n+// AnnotatingStorage wraps given storage and tracks type and unit\n+// labels across series. It will produce an info annotation if there\n+// is a mismatch between type or unit in series with the same name.\n+func AnnotatingStorage(s Storage) Storage {",
        "comment_created_at": "2025-07-08T15:19:37+00:00",
        "comment_author": "bwplotka",
        "comment_body": "Hm, why generic name (\"annotating\"?); Would more specific name be a bit better e.g. the exact semantics for annotations (`SchemaMismatchStorage` or `MismatchStorage` `TypeAndUnitMismatchStorage`)?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126848420",
    "pr_number": 16619,
    "pr_file": "template/template.go",
    "created_at": "2025-06-04T15:09:15+00:00",
    "commented_code": "}\n \t\t\t\treturn float64(time.Duration(v)) / float64(time.Second), nil\n \t\t\t},\n+\t\t\t\"parseDurationTime\": func(d string) (time.Duration, error) {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2126848420",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16619,
        "pr_file": "template/template.go",
        "discussion_id": "2126848420",
        "commented_code": "@@ -276,6 +276,13 @@ func NewTemplateExpander(\n \t\t\t\t}\n \t\t\t\treturn float64(time.Duration(v)) / float64(time.Second), nil\n \t\t\t},\n+\t\t\t\"parseDurationTime\": func(d string) (time.Duration, error) {",
        "comment_created_at": "2025-06-04T15:09:15+00:00",
        "comment_author": "beorn7",
        "comment_body": "This isn't a good name. The function doesn't return a time, but a duration. The relevant difference to the existing `parseDuration` is that the Go `Duration` type is returned, not just the number of seconds since epoch.\r\n\r\nSo maybe `parseGoDuration` would be better?",
        "pr_file_module": null
      },
      {
        "comment_id": "2127061734",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16619,
        "pr_file": "template/template.go",
        "discussion_id": "2126848420",
        "commented_code": "@@ -276,6 +276,13 @@ func NewTemplateExpander(\n \t\t\t\t}\n \t\t\t\treturn float64(time.Duration(v)) / float64(time.Second), nil\n \t\t\t},\n+\t\t\t\"parseDurationTime\": func(d string) (time.Duration, error) {",
        "comment_created_at": "2025-06-04T17:03:46+00:00",
        "comment_author": "iamhalje",
        "comment_body": "yep, that name would definitely be more appropriate. it clearly indicates that the function uses Go's native duration parsing logic",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179419568",
    "pr_number": 16695,
    "pr_file": "tsdb/db.go",
    "created_at": "2025-07-02T08:13:36+00:00",
    "commented_code": "return db.dir\n }\n \n+func (db *DB) ListBlockMetas() []BlockMeta {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2179419568",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16695,
        "pr_file": "tsdb/db.go",
        "discussion_id": "2179419568",
        "commented_code": "@@ -1074,6 +1074,17 @@ func (db *DB) Dir() string {\n \treturn db.dir\n }\n \n+func (db *DB) ListBlockMetas() []BlockMeta {",
        "comment_created_at": "2025-07-02T08:13:36+00:00",
        "comment_author": "juliusv",
        "comment_body": "Both in Go and in Prometheus, the naming conventions for such list / getter functions is usually to omit the \"List...\" / \"Get...\" prefix, see also:\r\n\r\n* https://github.com/prometheus/prometheus/blob/bfbae39931a6ddeb5913a6ea8d48a34bbebc6d29/rules/manager.go#L378-L379\r\n* https://github.com/prometheus/prometheus/blob/bfbae39931a6ddeb5913a6ea8d48a34bbebc6d29/scrape/manager.go#L358-L359\r\n* https://github.com/prometheus/prometheus/blob/bfbae39931a6ddeb5913a6ea8d48a34bbebc6d29/scrape/manager.go#L370-L371\r\n* etc.\r\n\r\nSo I'd call this `BlockMetas()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135441808",
    "pr_number": 16355,
    "pr_file": "notifier/alertmanagerset.go",
    "created_at": "2025-06-09T10:05:22+00:00",
    "commented_code": "hash := md5.Sum(b)\n \treturn hex.EncodeToString(hash[:]), nil\n }\n+\n+func (s *alertmanagerSet) send(alerts ...*Alert) map[string]int {\n+\tdropped := make(map[string]int)\n+\n+\taa := alerts\n+\tif len(s.cfg.AlertRelabelConfigs) > 0 {\n+\t\taa = relabelAlerts(s.cfg.AlertRelabelConfigs, labels.Labels{}, alerts)\n+\t\tif len(aa) == 0 {\n+\t\t\treturn dropped\n+\t\t}\n+\t}\n+\n+\tfor am, q := range s.buffers {\n+\t\tif d := q.push(aa...); d > 0 {\n+\t\t\tdropped[am] = d\n+\t\t}\n+\t}\n+\n+\treturn dropped\n+}\n+\n+func (s *alertmanagerSet) sendLoop(am alertmanager, more chan struct{}) {\n+\turl := am.url().String()\n+\n+\t// allocate a buffer for alerts with length and capacity equal to max batch size.\n+\talerts := make([]*Alert, s.opts.MaxBatchSize)\n+\tfor {\n+\t\t_, ok := <-more\n+\t\tif !ok {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tb := s.getBuffer(url)\n+\t\tif b == nil {\n+\t\t\treturn\n+\t\t}\n+\t\tb.pop(&alerts)\n+\n+\t\tif !s.postNotifications(am, alerts) {\n+\t\t\ts.metrics.dropped.WithLabelValues(url).Add(float64(len(alerts)))\n+\t\t}\n+\n+\t\tif b.len() > 0 {\n+\t\t\tb.setMore()\n+\t\t}\n+\t}\n+}\n+\n+func (s *alertmanagerSet) postNotifications(am alertmanager, alerts []*Alert) bool {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2135441808",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16355,
        "pr_file": "notifier/alertmanagerset.go",
        "discussion_id": "2135441808",
        "commented_code": "@@ -126,3 +143,132 @@ func (s *alertmanagerSet) configHash() (string, error) {\n \thash := md5.Sum(b)\n \treturn hex.EncodeToString(hash[:]), nil\n }\n+\n+func (s *alertmanagerSet) send(alerts ...*Alert) map[string]int {\n+\tdropped := make(map[string]int)\n+\n+\taa := alerts\n+\tif len(s.cfg.AlertRelabelConfigs) > 0 {\n+\t\taa = relabelAlerts(s.cfg.AlertRelabelConfigs, labels.Labels{}, alerts)\n+\t\tif len(aa) == 0 {\n+\t\t\treturn dropped\n+\t\t}\n+\t}\n+\n+\tfor am, q := range s.buffers {\n+\t\tif d := q.push(aa...); d > 0 {\n+\t\t\tdropped[am] = d\n+\t\t}\n+\t}\n+\n+\treturn dropped\n+}\n+\n+func (s *alertmanagerSet) sendLoop(am alertmanager, more chan struct{}) {\n+\turl := am.url().String()\n+\n+\t// allocate a buffer for alerts with length and capacity equal to max batch size.\n+\talerts := make([]*Alert, s.opts.MaxBatchSize)\n+\tfor {\n+\t\t_, ok := <-more\n+\t\tif !ok {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tb := s.getBuffer(url)\n+\t\tif b == nil {\n+\t\t\treturn\n+\t\t}\n+\t\tb.pop(&alerts)\n+\n+\t\tif !s.postNotifications(am, alerts) {\n+\t\t\ts.metrics.dropped.WithLabelValues(url).Add(float64(len(alerts)))\n+\t\t}\n+\n+\t\tif b.len() > 0 {\n+\t\t\tb.setMore()\n+\t\t}\n+\t}\n+}\n+\n+func (s *alertmanagerSet) postNotifications(am alertmanager, alerts []*Alert) bool {",
        "comment_created_at": "2025-06-09T10:05:22+00:00",
        "comment_author": "machine424",
        "comment_body": "nit: maybe `sendAll` or something we used to have to keep the same naming?",
        "pr_file_module": null
      },
      {
        "comment_id": "2137462059",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16355,
        "pr_file": "notifier/alertmanagerset.go",
        "discussion_id": "2135441808",
        "commented_code": "@@ -126,3 +143,132 @@ func (s *alertmanagerSet) configHash() (string, error) {\n \thash := md5.Sum(b)\n \treturn hex.EncodeToString(hash[:]), nil\n }\n+\n+func (s *alertmanagerSet) send(alerts ...*Alert) map[string]int {\n+\tdropped := make(map[string]int)\n+\n+\taa := alerts\n+\tif len(s.cfg.AlertRelabelConfigs) > 0 {\n+\t\taa = relabelAlerts(s.cfg.AlertRelabelConfigs, labels.Labels{}, alerts)\n+\t\tif len(aa) == 0 {\n+\t\t\treturn dropped\n+\t\t}\n+\t}\n+\n+\tfor am, q := range s.buffers {\n+\t\tif d := q.push(aa...); d > 0 {\n+\t\t\tdropped[am] = d\n+\t\t}\n+\t}\n+\n+\treturn dropped\n+}\n+\n+func (s *alertmanagerSet) sendLoop(am alertmanager, more chan struct{}) {\n+\turl := am.url().String()\n+\n+\t// allocate a buffer for alerts with length and capacity equal to max batch size.\n+\talerts := make([]*Alert, s.opts.MaxBatchSize)\n+\tfor {\n+\t\t_, ok := <-more\n+\t\tif !ok {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tb := s.getBuffer(url)\n+\t\tif b == nil {\n+\t\t\treturn\n+\t\t}\n+\t\tb.pop(&alerts)\n+\n+\t\tif !s.postNotifications(am, alerts) {\n+\t\t\ts.metrics.dropped.WithLabelValues(url).Add(float64(len(alerts)))\n+\t\t}\n+\n+\t\tif b.len() > 0 {\n+\t\t\tb.setMore()\n+\t\t}\n+\t}\n+}\n+\n+func (s *alertmanagerSet) postNotifications(am alertmanager, alerts []*Alert) bool {",
        "comment_created_at": "2025-06-10T10:08:15+00:00",
        "comment_author": "siavashs",
        "comment_body": "I thought `postNotifications` is a better name for the method, since `sendAll` used to send to all alertmanagers but `postNotifications` sends to a single alertmanager.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2034946770",
    "pr_number": 16394,
    "pr_file": "rules/alerting.go",
    "created_at": "2025-04-09T09:36:10+00:00",
    "commented_code": "func NewAlertingRule(\n \tname string, vec parser.Expr, hold, keepFiringFor time.Duration,\n \tlabels, annotations, externalLabels labels.Labels, externalURL string,\n-\trestored bool, logger *slog.Logger,\n+\t_restored bool, logger *slog.Logger,",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2034946770",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16394,
        "pr_file": "rules/alerting.go",
        "discussion_id": "2034946770",
        "commented_code": "@@ -152,10 +152,24 @@ type AlertingRule struct {\n func NewAlertingRule(\n \tname string, vec parser.Expr, hold, keepFiringFor time.Duration,\n \tlabels, annotations, externalLabels labels.Labels, externalURL string,\n-\trestored bool, logger *slog.Logger,\n+\t_restored bool, logger *slog.Logger,",
        "comment_created_at": "2025-04-09T09:36:10+00:00",
        "comment_author": "bwplotka",
        "comment_body": "It's not idiomatic to start variable names with underscore only to avoid collisions. Let's use this opportunity to make it clear what all variable controls e.g. by renaming  `var restored atomic.Bool` to `restoredAtomic` or this variable to `nonAtomic...`\r\n\r\n```suggestion\r\n\tnonAtomicRestored bool, logger *slog.Logger,\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2075409107",
    "pr_number": 15836,
    "pr_file": "tsdb/index/index.go",
    "created_at": "2025-05-06T12:52:11+00:00",
    "commented_code": "symbols     *Symbols\n \tsymbolFile  *fileutil.MmapFile\n \tlastSymbol  string\n-\tsymbolCache map[string]uint32 // From symbol to index in table.\n+\tsymbolCache map[string]symbolCacheEntry\n+\tindexCache  map[string]uint32 // From symbol to index in table.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2075409107",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15836,
        "pr_file": "tsdb/index/index.go",
        "discussion_id": "2075409107",
        "commented_code": "@@ -140,7 +146,8 @@ type Writer struct {\n \tsymbols     *Symbols\n \tsymbolFile  *fileutil.MmapFile\n \tlastSymbol  string\n-\tsymbolCache map[string]uint32 // From symbol to index in table.\n+\tsymbolCache map[string]symbolCacheEntry\n+\tindexCache  map[string]uint32 // From symbol to index in table.",
        "comment_created_at": "2025-05-06T12:52:11+00:00",
        "comment_author": "bboreham",
        "comment_body": "Personally I don't find these two names very useful - I can't remember which is which so I have to keep looking back at the definition.  The comment on `indexCache` talks about both \"symbol\" and \"index\".\r\n\r\nI think in this PR `symbolCache` is only used for names, whereas `indexCache` is used for names and values, so I might suggest `nameCache` and `symbolToIndex`.\r\n\r\nCommenting which one is used when `cacheAllSymbols` is off and on would also be useful.",
        "pr_file_module": null
      },
      {
        "comment_id": "2106233315",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15836,
        "pr_file": "tsdb/index/index.go",
        "discussion_id": "2075409107",
        "commented_code": "@@ -140,7 +146,8 @@ type Writer struct {\n \tsymbols     *Symbols\n \tsymbolFile  *fileutil.MmapFile\n \tlastSymbol  string\n-\tsymbolCache map[string]uint32 // From symbol to index in table.\n+\tsymbolCache map[string]symbolCacheEntry\n+\tindexCache  map[string]uint32 // From symbol to index in table.",
        "comment_created_at": "2025-05-25T15:26:13+00:00",
        "comment_author": "aknuds1",
        "comment_body": "After inspecting the usage of the two different caches, I came to the conclusion that the current cache is used for mapping _all_ `Writer` symbols to indices, and that the cache I'm (re-)introducing is only used for series label symbols when adding a series to the `Writer`. With that in mind, I renamed them `symbolToIndex` and `seriesSymbolCache` respectively. What do you think @bboreham?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057834702",
    "pr_number": 16426,
    "pr_file": "config/config.go",
    "created_at": "2025-04-24T08:22:58+00:00",
    "commented_code": "return err\n \t}\n \n+\tif c.PromoteAllResourceAttributes && len(c.PromoteResourceAttributes) > 0 {\n+\t\treturn errors.New(\"'promote_all_resource_attributes' and 'promote_resource_attributes' cannot be configured simultaneously\")\n+\t}\n+\n+\tif err := validateAttributes(c.IgnoreResourceAttributes); err != nil {\n+\t\treturn fmt.Errorf(\"invalid 'ignore_resource_attributes': %w\", err)\n+\t}\n+\tif err := validateAttributes(c.PromoteResourceAttributes); err != nil {\n+\t\treturn fmt.Errorf(\"invalid 'promote_resource_attributes': %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func validateAttributes(attributes []string) error {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2057834702",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16426,
        "pr_file": "config/config.go",
        "discussion_id": "2057834702",
        "commented_code": "@@ -1527,21 +1529,35 @@ func (c *OTLPConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {\n \t\treturn err\n \t}\n \n+\tif c.PromoteAllResourceAttributes && len(c.PromoteResourceAttributes) > 0 {\n+\t\treturn errors.New(\"'promote_all_resource_attributes' and 'promote_resource_attributes' cannot be configured simultaneously\")\n+\t}\n+\n+\tif err := validateAttributes(c.IgnoreResourceAttributes); err != nil {\n+\t\treturn fmt.Errorf(\"invalid 'ignore_resource_attributes': %w\", err)\n+\t}\n+\tif err := validateAttributes(c.PromoteResourceAttributes); err != nil {\n+\t\treturn fmt.Errorf(\"invalid 'promote_resource_attributes': %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func validateAttributes(attributes []string) error {",
        "comment_created_at": "2025-04-24T08:22:58+00:00",
        "comment_author": "aknuds1",
        "comment_body": "It confused me that `validateAttributes` would modify the input. `sanitizeAttributes` is more descriptive of what the function actually does, and thus more readable:\r\n```suggestion\r\nfunc sanitizeAttributes(attributes []string) error {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2037112709",
    "pr_number": 16404,
    "pr_file": "promql/engine.go",
    "created_at": "2025-04-10T11:15:17+00:00",
    "commented_code": "// Grouping labels must be sorted (expected both by generateGroupingKey() and aggregation()).\n \t\tsortedGrouping := e.Grouping\n \t\tslices.Sort(sortedGrouping)\n+\t\tisDynamicParam := true",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2037112709",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16404,
        "pr_file": "promql/engine.go",
        "discussion_id": "2037112709",
        "commented_code": "@@ -1585,8 +1596,13 @@ func (ev *evaluator) eval(ctx context.Context, expr parser.Expr) (parser.Value,\n \t\t// Grouping labels must be sorted (expected both by generateGroupingKey() and aggregation()).\n \t\tsortedGrouping := e.Grouping\n \t\tslices.Sort(sortedGrouping)\n+\t\tisDynamicParam := true",
        "comment_created_at": "2025-04-10T11:15:17+00:00",
        "comment_author": "beorn7",
        "comment_body": "Maybe let's invert this and go with the more common term \"const\"? E.g. `constParam`. (The \"is\" in there sounds a bit Java-esque to me.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2037501641",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16404,
        "pr_file": "promql/engine.go",
        "discussion_id": "2037112709",
        "commented_code": "@@ -1585,8 +1596,13 @@ func (ev *evaluator) eval(ctx context.Context, expr parser.Expr) (parser.Value,\n \t\t// Grouping labels must be sorted (expected both by generateGroupingKey() and aggregation()).\n \t\tsortedGrouping := e.Grouping\n \t\tslices.Sort(sortedGrouping)\n+\t\tisDynamicParam := true",
        "comment_created_at": "2025-04-10T14:01:48+00:00",
        "comment_author": "NeerajGartia21",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2082418241",
    "pr_number": 16532,
    "pr_file": "promql/functions.go",
    "created_at": "2025-05-09T19:58:29+00:00",
    "commented_code": "return append(enh.Out, Sample{F: slope*duration + intercept}), nil\n }\n \n-// === histogram_count(Vector parser.ValueTypeVector) (Vector, Annotations) ===\n-func funcHistogramCount(vals []parser.Value, _ parser.Expressions, enh *EvalNodeHelper) (Vector, annotations.Annotations) {\n-\tinVec := vals[0].(Vector)\n-\n-\tfor _, sample := range inVec {\n-\t\t// Skip non-histogram samples.\n-\t\tif sample.H == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !enh.enableDelayedNameRemoval {\n-\t\t\tsample.Metric = sample.Metric.DropMetricName()\n+func simpleHistFunc(vals []parser.Value, enh *EvalNodeHelper, f func(h *histogram.FloatHistogram) float64) Vector {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2082418241",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16532,
        "pr_file": "promql/functions.go",
        "discussion_id": "2082418241",
        "commented_code": "@@ -1271,87 +1247,56 @@ func funcPredictLinear(vals []parser.Value, args parser.Expressions, enh *EvalNo\n \treturn append(enh.Out, Sample{F: slope*duration + intercept}), nil\n }\n \n-// === histogram_count(Vector parser.ValueTypeVector) (Vector, Annotations) ===\n-func funcHistogramCount(vals []parser.Value, _ parser.Expressions, enh *EvalNodeHelper) (Vector, annotations.Annotations) {\n-\tinVec := vals[0].(Vector)\n-\n-\tfor _, sample := range inVec {\n-\t\t// Skip non-histogram samples.\n-\t\tif sample.H == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !enh.enableDelayedNameRemoval {\n-\t\t\tsample.Metric = sample.Metric.DropMetricName()\n+func simpleHistFunc(vals []parser.Value, enh *EvalNodeHelper, f func(h *histogram.FloatHistogram) float64) Vector {",
        "comment_created_at": "2025-05-09T19:58:29+00:00",
        "comment_author": "beorn7",
        "comment_body": "I'm not a great fan of abbreviations that do not abbreviate much but still create ambiguity (has this to do with historic values?).\r\n\r\nLet's call this `simpleHistogramFunc` or if we want to be short, do `simpleHFunc`.\r\n\r\nMaybe we should also rename the existing `simpleFunc` to `simpleFloatFunc` or `simpleFFunc`.\r\n\r\nMy personal preference would be `simpleHistogramFunc` and `simpleFloatFunc`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2083107102",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16532,
        "pr_file": "promql/functions.go",
        "discussion_id": "2082418241",
        "commented_code": "@@ -1271,87 +1247,56 @@ func funcPredictLinear(vals []parser.Value, args parser.Expressions, enh *EvalNo\n \treturn append(enh.Out, Sample{F: slope*duration + intercept}), nil\n }\n \n-// === histogram_count(Vector parser.ValueTypeVector) (Vector, Annotations) ===\n-func funcHistogramCount(vals []parser.Value, _ parser.Expressions, enh *EvalNodeHelper) (Vector, annotations.Annotations) {\n-\tinVec := vals[0].(Vector)\n-\n-\tfor _, sample := range inVec {\n-\t\t// Skip non-histogram samples.\n-\t\tif sample.H == nil {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !enh.enableDelayedNameRemoval {\n-\t\t\tsample.Metric = sample.Metric.DropMetricName()\n+func simpleHistFunc(vals []parser.Value, enh *EvalNodeHelper, f func(h *histogram.FloatHistogram) float64) Vector {",
        "comment_created_at": "2025-05-10T10:51:13+00:00",
        "comment_author": "NeerajGartia21",
        "comment_body": "Yeah, `simpleHistogramFunc` and `simpleFloatFunc` sound better. I'll change it as soon as possible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2049172607",
    "pr_number": 16441,
    "pr_file": "storage/remote/write_test.go",
    "created_at": "2025-04-17T15:13:04+00:00",
    "commented_code": "func TestOTLPWriteHandler(t *testing.T) {\n \texportRequest := generateOTLPWriteRequest()\n+\ttimestamp := time.Now()\n+\tfor _, testCase := range []struct {\n+\t\tname            string\n+\t\totlpCfg         config.OTLPConfig\n+\t\texpectedSamples []mockSample\n+\t}{\n+\t\t{\n+\t\t\tname: \"NoTranslation\",\n+\t\t\totlpCfg: config.OTLPConfig{\n+\t\t\t\tTranslationStrategy: config.NoTranslation,\n+\t\t\t},\n+\t\t\texpectedSamples: []mockSample{\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(labels.Label{Name: \"__name__\", Value: \"test.counter\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"foo.bar\", Value: \"baz\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"}),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 10.0,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(\n+\t\t\t\t\t\tlabels.Label{Name: \"__name__\", Value: \"target_info\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"host.name\", Value: \"test-host\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"},\n+\t\t\t\t\t),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 1,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"UnderscoreEscapingWithSuffixes\",\n+\t\t\totlpCfg: config.OTLPConfig{\n+\t\t\t\tTranslationStrategy: config.UnderscoreEscapingWithSuffixes,\n+\t\t\t},\n+\t\t\texpectedSamples: []mockSample{\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(labels.Label{Name: \"__name__\", Value: \"test_counter_total\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"foo_bar\", Value: \"baz\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"}),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 10.0,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(\n+\t\t\t\t\t\tlabels.Label{Name: \"__name__\", Value: \"target_info\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"host_name\", Value: \"test-host\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"},\n+\t\t\t\t\t),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 1,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\n+\t\t{\n+\t\t\tname: \"NoUTF8EscapingWithSuffixes\",\n+\t\t\totlpCfg: config.OTLPConfig{\n+\t\t\t\tTranslationStrategy: config.NoUTF8EscapingWithSuffixes,\n+\t\t\t},\n+\t\t\texpectedSamples: []mockSample{\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(labels.Label{Name: \"__name__\", Value: \"test.counter_total\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"foo.bar\", Value: \"baz\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"}),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 10.0,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(\n+\t\t\t\t\t\tlabels.Label{Name: \"__name__\", Value: \"target_info\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"host.name\", Value: \"test-host\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"},\n+\t\t\t\t\t),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 1,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t} {\n+\t\tt.Run(testCase.name, func(t *testing.T) {\n+\t\t\tappendable := handleOtlp(t, exportRequest, testCase.otlpCfg)",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2049172607",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16441,
        "pr_file": "storage/remote/write_test.go",
        "discussion_id": "2049172607",
        "commented_code": "@@ -382,7 +382,105 @@ func TestWriteStorageApplyConfig_PartialUpdate(t *testing.T) {\n \n func TestOTLPWriteHandler(t *testing.T) {\n \texportRequest := generateOTLPWriteRequest()\n+\ttimestamp := time.Now()\n+\tfor _, testCase := range []struct {\n+\t\tname            string\n+\t\totlpCfg         config.OTLPConfig\n+\t\texpectedSamples []mockSample\n+\t}{\n+\t\t{\n+\t\t\tname: \"NoTranslation\",\n+\t\t\totlpCfg: config.OTLPConfig{\n+\t\t\t\tTranslationStrategy: config.NoTranslation,\n+\t\t\t},\n+\t\t\texpectedSamples: []mockSample{\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(labels.Label{Name: \"__name__\", Value: \"test.counter\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"foo.bar\", Value: \"baz\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"}),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 10.0,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(\n+\t\t\t\t\t\tlabels.Label{Name: \"__name__\", Value: \"target_info\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"host.name\", Value: \"test-host\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"},\n+\t\t\t\t\t),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 1,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"UnderscoreEscapingWithSuffixes\",\n+\t\t\totlpCfg: config.OTLPConfig{\n+\t\t\t\tTranslationStrategy: config.UnderscoreEscapingWithSuffixes,\n+\t\t\t},\n+\t\t\texpectedSamples: []mockSample{\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(labels.Label{Name: \"__name__\", Value: \"test_counter_total\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"foo_bar\", Value: \"baz\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"}),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 10.0,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(\n+\t\t\t\t\t\tlabels.Label{Name: \"__name__\", Value: \"target_info\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"host_name\", Value: \"test-host\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"},\n+\t\t\t\t\t),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 1,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\n+\t\t{\n+\t\t\tname: \"NoUTF8EscapingWithSuffixes\",\n+\t\t\totlpCfg: config.OTLPConfig{\n+\t\t\t\tTranslationStrategy: config.NoUTF8EscapingWithSuffixes,\n+\t\t\t},\n+\t\t\texpectedSamples: []mockSample{\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(labels.Label{Name: \"__name__\", Value: \"test.counter_total\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"foo.bar\", Value: \"baz\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"}),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 10.0,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tl: labels.New(\n+\t\t\t\t\t\tlabels.Label{Name: \"__name__\", Value: \"target_info\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"host.name\", Value: \"test-host\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"instance\", Value: \"test-instance\"},\n+\t\t\t\t\t\tlabels.Label{Name: \"job\", Value: \"test-service\"},\n+\t\t\t\t\t),\n+\t\t\t\t\tt: timestamp.UnixMilli(),\n+\t\t\t\t\tv: 1,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t} {\n+\t\tt.Run(testCase.name, func(t *testing.T) {\n+\t\t\tappendable := handleOtlp(t, exportRequest, testCase.otlpCfg)",
        "comment_created_at": "2025-04-17T15:13:04+00:00",
        "comment_author": "aknuds1",
        "comment_body": "[Nit] The Go idiom is consistent casing of [initialisms](https://go.dev/wiki/CodeReviewComments#initialisms). It's also how we case OTLP otherwise in this file.\r\n```suggestion\r\n\t\t\tappendable := handleOTLP(t, exportRequest, testCase.otlpCfg)\r\n```",
        "pr_file_module": null
      }
    ]
  }
]