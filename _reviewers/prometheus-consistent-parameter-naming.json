[
  {
    "discussion_id": "2194733438",
    "pr_number": 16837,
    "pr_file": "docs/querying/operators.md",
    "created_at": "2025-07-09T11:06:47+00:00",
    "commented_code": "labels that are not listed in the `by` clause, even if their label values are\n identical between all elements of the vector.\n \n-`parameter` is only required for `topk`, `bottomk`, `limitk`, `limit_ratio`,\n-`quantile`, and `count_values`. It is used as the value for _k_, _r_, φ, or the\n-name of the additional label, respectively.\n-\n ### Detailed explanations\n \n-`sum` sums up sample values in the same way as the `+` binary operator does\n-between two values. Similarly, `avg` divides the sum by the number of\n-aggregated samples in the same way as the `/` binary operator. Therefore, all\n-sample values aggregation into a single resulting vector element must either be\n+#### `sum`\n+\n+`sum(v)` sums up sample values in `v` in the same way as the `+` binary operator does\n+between two values. \n+\n+All sample values aggregation into a single resulting vector element must either be\n float samples or histogram samples. An aggregation of a mix of both is invalid,\n-resulting in the removeal of the corresponding vector element from the output\n+resulting in the removal of the corresponding vector element from the output\n vector, flagged by a warn-level annotation.\n \n-`min` and `max` only operate on float samples, following IEEE 754 floating\n+##### Examples\n+\n+If the metric `http_requests_total` had time series that fan out by\n+`application`, `instance`, and `group` labels, we could calculate the total\n+number of seen HTTP requests per application and group over all instances via:\n+\n+    sum without (instance) (http_requests_total)\n+\n+Which is equivalent to:\n+\n+     sum by (application, group) (http_requests_total)\n+\n+If we are just interested in the total of HTTP requests we have seen in **all**\n+applications, we could simply write:\n+\n+    sum(http_requests_total)\n+\n+#### `avg`\n+\n+`avg(v)` divides the sum of `v` by the number of aggregated samples in the same way\n+as the `/` binary operator.\n+\n+All sample values aggregation into a single resulting vector element must either be\n+float samples or histogram samples. An aggregation of a mix of both is invalid,\n+resulting in the removal of the corresponding vector element from the output\n+vector, flagged by a warn-level annotation.\n+\n+#### `min` and `max`\n+\n+`min(v)` and `max(v)` return the minimum or maximum value, respectively, in `v`. \n+\n+They only operate on float samples, following IEEE 754 floating\n point arithmetic, which in particular implies that `NaN` is only ever\n considered a minimum or maximum if all aggregated values are `NaN`. Histogram\n samples in the input vector are ignored, flagged by an info-level annotation.\n \n-`topk` and `bottomk` are different from other aggregators in that a subset of\n-the input samples, including the original labels, are returned in the result\n-vector. `by` and `without` are only used to bucket the input vector. Similar to\n-`min` and `max`, they only operate on float samples, considering `NaN` values\n+#### `topk` and `bottomk`\n+\n+`topk(k, v)` and `bottomk(k, v)` are different from other aggregators in that a subset of\n+`k` values from the input samples, including the original labels, are returned in the result vector. \n+\n+`by` and `without` are only used to bucket the input vector. \n+\n+Similar to `min` and `max`, they only operate on float samples, considering `NaN` values\n to be farthest from the top or bottom, respectively. Histogram samples in the\n input vector are ignored, flagged by an info-level annotation.\n \n If used in an instant query, `topk` and `bottomk` return series ordered by\n value in descending or ascending order, respectively. If used with `by` or\n `without`, then series within each bucket are sorted by value, and series in\n the same bucket are returned consecutively, but there is no guarantee that\n-buckets of series will be returned in any particular order. No sorting applies\n-to range queries.\n-\n-`limitk` and `limit_ratio` also return a subset of the input samples, including\n-the original labels in the result vector. The subset is selected in a\n-deterministic pseudo-random way. `limitk` picks _k_ samples, while\n-`limit_ratio` picks a ratio _r_ of samples (each determined by `parameter`).\n-This happens independent of the sample type. Therefore, it works for both float\n-samples and histogram samples. _r_ can be between +1 and -1. The absolute value\n-of _r_ is used as the selection ratio, but the selection order is inverted for\n-a negative _r_, which can be used to select complements. For example,\n-`limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n+buckets of series will be returned in any particular order. \n+\n+No sorting applies to range queries.\n+\n+##### Example\n+\n+To get the 5 largest HTTP requests counts across all instances we could write:\n+\n+    topk(5, http_requests_total)\n+\n+#### `limitk` and `limit_ratio`\n+\n+`limitk(k, v)` returns a subset of `k` input samples, including\n+the original labels in the result vector. \n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type. \n+Therefore, it works for both float samples and histogram samples. \n+\n+##### Example\n+\n+To sample 10 timeseries, for example to inspect labels and their values, we\n+could write:\n+\n+    limitk(10, http_requests_total)\n+\n+#### `limit_ratio`\n+\n+`limit_ratio(r, v)` returns a subset of the input samples, including\n+the original labels in the result vector.\n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type.\n+Therefore, it works for both float samples and histogram samples.\n+\n+`r` can be between +1 and -1. The absolute value of `r` is used as the selection ratio,\n+but the selection order is inverted for a negative `r`, which can be used to select complements.\n+For example, `limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n the input samples, while `limit_ratio(-0.9, ...)` returns precisely the\n-remaining approximately 90% of the input samples not returned by\n-`limit_ratio(0.1, ...)`.\n+remaining approximately 90% of the input samples not returned by `limit_ratio(0.1, ...)`.\n \n-`group` and `count` do not interact with the sample values,\n-they work in the same way for float samples and histogram samples.\n+#### `group`\n+\n+`group(v)` returns 1 for each group that contains any value at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count`\n+\n+`count(v)` returns the number of values at that timestamp, or no value at all\n+if no values are present at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count_values`\n+\n+`count_values(l, v)` outputs one time series per unique sample value in `v`. \n+Each series has an additional label, given by `l`, and the label value is the \n+unique sample value. The value of each time series is the number of times that sample value was present.\n \n-`count_values` outputs one time series per unique sample value. Each series has\n-an additional label. The name of that label is given by the aggregation\n-parameter, and the label value is the unique sample value. The value of each\n-time series is the number of times that sample value was present.\n `count_values` works with both float samples and histogram samples. For the\n latter, a compact string representation of the histogram sample value is used\n as the label value.\n \n-`stddev` and `stdvar` only work with float samples, following IEEE 754 floating\n-point arithmetic. Histogram samples in the input vector are ignored, flagged by\n-an info-level annotation.\n-\n-`quantile` calculates the φ-quantile, the value that ranks at number φ*N among\n-the N metric values of the dimensions aggregated over. φ is provided as the\n-aggregation parameter. For example, `quantile(0.5, ...)` calculates the median,\n-`quantile(0.95, ...)` the 95th percentile. For φ = `NaN`, `NaN` is returned.\n-For φ < 0, `-Inf` is returned. For φ > 1, `+Inf` is returned.\n+##### Example\n \n-### Examples\n+To count the number of binaries running each build version we could write:\n \n-If the metric `http_requests_total` had time series that fan out by\n-`application`, `instance`, and `group` labels, we could calculate the total\n-number of seen HTTP requests per application and group over all instances via:\n+    count_values(\"version\", build_version)\n \n-    sum without (instance) (http_requests_total)\n+#### `stddev`\n \n-Which is equivalent to:\n+`stddev(v)` returns the standard deviation of `v`. \n \n-     sum by (application, group) (http_requests_total)\n+`stddev` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-If we are just interested in the total of HTTP requests we have seen in **all**\n-applications, we could simply write:\n+#### `stdvar`\n \n-    sum(http_requests_total)\n+`stdvar(v)` returns the standard deviation of `v`. \n \n-To count the number of binaries running each build version we could write:\n+`stdvar` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-    count_values(\"version\", build_version)\n+#### `quantile`\n \n-To get the 5 largest HTTP requests counts across all instances we could write:\n+`quantile(phi, v)` calculates the φ-quantile, the value that ranks at number φ*N among",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2194733438",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16837,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2194733438",
        "commented_code": "@@ -318,102 +318,167 @@ all other labels are preserved in the output. `by` does the opposite and drops\n labels that are not listed in the `by` clause, even if their label values are\n identical between all elements of the vector.\n \n-`parameter` is only required for `topk`, `bottomk`, `limitk`, `limit_ratio`,\n-`quantile`, and `count_values`. It is used as the value for _k_, _r_, φ, or the\n-name of the additional label, respectively.\n-\n ### Detailed explanations\n \n-`sum` sums up sample values in the same way as the `+` binary operator does\n-between two values. Similarly, `avg` divides the sum by the number of\n-aggregated samples in the same way as the `/` binary operator. Therefore, all\n-sample values aggregation into a single resulting vector element must either be\n+#### `sum`\n+\n+`sum(v)` sums up sample values in `v` in the same way as the `+` binary operator does\n+between two values. \n+\n+All sample values aggregation into a single resulting vector element must either be\n float samples or histogram samples. An aggregation of a mix of both is invalid,\n-resulting in the removeal of the corresponding vector element from the output\n+resulting in the removal of the corresponding vector element from the output\n vector, flagged by a warn-level annotation.\n \n-`min` and `max` only operate on float samples, following IEEE 754 floating\n+##### Examples\n+\n+If the metric `http_requests_total` had time series that fan out by\n+`application`, `instance`, and `group` labels, we could calculate the total\n+number of seen HTTP requests per application and group over all instances via:\n+\n+    sum without (instance) (http_requests_total)\n+\n+Which is equivalent to:\n+\n+     sum by (application, group) (http_requests_total)\n+\n+If we are just interested in the total of HTTP requests we have seen in **all**\n+applications, we could simply write:\n+\n+    sum(http_requests_total)\n+\n+#### `avg`\n+\n+`avg(v)` divides the sum of `v` by the number of aggregated samples in the same way\n+as the `/` binary operator.\n+\n+All sample values aggregation into a single resulting vector element must either be\n+float samples or histogram samples. An aggregation of a mix of both is invalid,\n+resulting in the removal of the corresponding vector element from the output\n+vector, flagged by a warn-level annotation.\n+\n+#### `min` and `max`\n+\n+`min(v)` and `max(v)` return the minimum or maximum value, respectively, in `v`. \n+\n+They only operate on float samples, following IEEE 754 floating\n point arithmetic, which in particular implies that `NaN` is only ever\n considered a minimum or maximum if all aggregated values are `NaN`. Histogram\n samples in the input vector are ignored, flagged by an info-level annotation.\n \n-`topk` and `bottomk` are different from other aggregators in that a subset of\n-the input samples, including the original labels, are returned in the result\n-vector. `by` and `without` are only used to bucket the input vector. Similar to\n-`min` and `max`, they only operate on float samples, considering `NaN` values\n+#### `topk` and `bottomk`\n+\n+`topk(k, v)` and `bottomk(k, v)` are different from other aggregators in that a subset of\n+`k` values from the input samples, including the original labels, are returned in the result vector. \n+\n+`by` and `without` are only used to bucket the input vector. \n+\n+Similar to `min` and `max`, they only operate on float samples, considering `NaN` values\n to be farthest from the top or bottom, respectively. Histogram samples in the\n input vector are ignored, flagged by an info-level annotation.\n \n If used in an instant query, `topk` and `bottomk` return series ordered by\n value in descending or ascending order, respectively. If used with `by` or\n `without`, then series within each bucket are sorted by value, and series in\n the same bucket are returned consecutively, but there is no guarantee that\n-buckets of series will be returned in any particular order. No sorting applies\n-to range queries.\n-\n-`limitk` and `limit_ratio` also return a subset of the input samples, including\n-the original labels in the result vector. The subset is selected in a\n-deterministic pseudo-random way. `limitk` picks _k_ samples, while\n-`limit_ratio` picks a ratio _r_ of samples (each determined by `parameter`).\n-This happens independent of the sample type. Therefore, it works for both float\n-samples and histogram samples. _r_ can be between +1 and -1. The absolute value\n-of _r_ is used as the selection ratio, but the selection order is inverted for\n-a negative _r_, which can be used to select complements. For example,\n-`limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n+buckets of series will be returned in any particular order. \n+\n+No sorting applies to range queries.\n+\n+##### Example\n+\n+To get the 5 largest HTTP requests counts across all instances we could write:\n+\n+    topk(5, http_requests_total)\n+\n+#### `limitk` and `limit_ratio`\n+\n+`limitk(k, v)` returns a subset of `k` input samples, including\n+the original labels in the result vector. \n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type. \n+Therefore, it works for both float samples and histogram samples. \n+\n+##### Example\n+\n+To sample 10 timeseries, for example to inspect labels and their values, we\n+could write:\n+\n+    limitk(10, http_requests_total)\n+\n+#### `limit_ratio`\n+\n+`limit_ratio(r, v)` returns a subset of the input samples, including\n+the original labels in the result vector.\n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type.\n+Therefore, it works for both float samples and histogram samples.\n+\n+`r` can be between +1 and -1. The absolute value of `r` is used as the selection ratio,\n+but the selection order is inverted for a negative `r`, which can be used to select complements.\n+For example, `limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n the input samples, while `limit_ratio(-0.9, ...)` returns precisely the\n-remaining approximately 90% of the input samples not returned by\n-`limit_ratio(0.1, ...)`.\n+remaining approximately 90% of the input samples not returned by `limit_ratio(0.1, ...)`.\n \n-`group` and `count` do not interact with the sample values,\n-they work in the same way for float samples and histogram samples.\n+#### `group`\n+\n+`group(v)` returns 1 for each group that contains any value at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count`\n+\n+`count(v)` returns the number of values at that timestamp, or no value at all\n+if no values are present at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count_values`\n+\n+`count_values(l, v)` outputs one time series per unique sample value in `v`. \n+Each series has an additional label, given by `l`, and the label value is the \n+unique sample value. The value of each time series is the number of times that sample value was present.\n \n-`count_values` outputs one time series per unique sample value. Each series has\n-an additional label. The name of that label is given by the aggregation\n-parameter, and the label value is the unique sample value. The value of each\n-time series is the number of times that sample value was present.\n `count_values` works with both float samples and histogram samples. For the\n latter, a compact string representation of the histogram sample value is used\n as the label value.\n \n-`stddev` and `stdvar` only work with float samples, following IEEE 754 floating\n-point arithmetic. Histogram samples in the input vector are ignored, flagged by\n-an info-level annotation.\n-\n-`quantile` calculates the φ-quantile, the value that ranks at number φ*N among\n-the N metric values of the dimensions aggregated over. φ is provided as the\n-aggregation parameter. For example, `quantile(0.5, ...)` calculates the median,\n-`quantile(0.95, ...)` the 95th percentile. For φ = `NaN`, `NaN` is returned.\n-For φ < 0, `-Inf` is returned. For φ > 1, `+Inf` is returned.\n+##### Example\n \n-### Examples\n+To count the number of binaries running each build version we could write:\n \n-If the metric `http_requests_total` had time series that fan out by\n-`application`, `instance`, and `group` labels, we could calculate the total\n-number of seen HTTP requests per application and group over all instances via:\n+    count_values(\"version\", build_version)\n \n-    sum without (instance) (http_requests_total)\n+#### `stddev`\n \n-Which is equivalent to:\n+`stddev(v)` returns the standard deviation of `v`. \n \n-     sum by (application, group) (http_requests_total)\n+`stddev` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-If we are just interested in the total of HTTP requests we have seen in **all**\n-applications, we could simply write:\n+#### `stdvar`\n \n-    sum(http_requests_total)\n+`stdvar(v)` returns the standard deviation of `v`. \n \n-To count the number of binaries running each build version we could write:\n+`stdvar` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-    count_values(\"version\", build_version)\n+#### `quantile`\n \n-To get the 5 largest HTTP requests counts across all instances we could write:\n+`quantile(phi, v)` calculates the φ-quantile, the value that ranks at number φ*N among",
        "comment_created_at": "2025-07-09T11:06:47+00:00",
        "comment_author": "beorn7",
        "comment_body": "```suggestion\r\n`quantile(φ, v)` calculates the φ-quantile, the value that ranks at number φ*N among\r\n```\r\n\r\nIsn't it better to use the same character consistently? (Some readers might not even know how to read \"φ\", so they won't get the connection to \"phi\").",
        "pr_file_module": null
      },
      {
        "comment_id": "2196362119",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16837,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2194733438",
        "commented_code": "@@ -318,102 +318,167 @@ all other labels are preserved in the output. `by` does the opposite and drops\n labels that are not listed in the `by` clause, even if their label values are\n identical between all elements of the vector.\n \n-`parameter` is only required for `topk`, `bottomk`, `limitk`, `limit_ratio`,\n-`quantile`, and `count_values`. It is used as the value for _k_, _r_, φ, or the\n-name of the additional label, respectively.\n-\n ### Detailed explanations\n \n-`sum` sums up sample values in the same way as the `+` binary operator does\n-between two values. Similarly, `avg` divides the sum by the number of\n-aggregated samples in the same way as the `/` binary operator. Therefore, all\n-sample values aggregation into a single resulting vector element must either be\n+#### `sum`\n+\n+`sum(v)` sums up sample values in `v` in the same way as the `+` binary operator does\n+between two values. \n+\n+All sample values aggregation into a single resulting vector element must either be\n float samples or histogram samples. An aggregation of a mix of both is invalid,\n-resulting in the removeal of the corresponding vector element from the output\n+resulting in the removal of the corresponding vector element from the output\n vector, flagged by a warn-level annotation.\n \n-`min` and `max` only operate on float samples, following IEEE 754 floating\n+##### Examples\n+\n+If the metric `http_requests_total` had time series that fan out by\n+`application`, `instance`, and `group` labels, we could calculate the total\n+number of seen HTTP requests per application and group over all instances via:\n+\n+    sum without (instance) (http_requests_total)\n+\n+Which is equivalent to:\n+\n+     sum by (application, group) (http_requests_total)\n+\n+If we are just interested in the total of HTTP requests we have seen in **all**\n+applications, we could simply write:\n+\n+    sum(http_requests_total)\n+\n+#### `avg`\n+\n+`avg(v)` divides the sum of `v` by the number of aggregated samples in the same way\n+as the `/` binary operator.\n+\n+All sample values aggregation into a single resulting vector element must either be\n+float samples or histogram samples. An aggregation of a mix of both is invalid,\n+resulting in the removal of the corresponding vector element from the output\n+vector, flagged by a warn-level annotation.\n+\n+#### `min` and `max`\n+\n+`min(v)` and `max(v)` return the minimum or maximum value, respectively, in `v`. \n+\n+They only operate on float samples, following IEEE 754 floating\n point arithmetic, which in particular implies that `NaN` is only ever\n considered a minimum or maximum if all aggregated values are `NaN`. Histogram\n samples in the input vector are ignored, flagged by an info-level annotation.\n \n-`topk` and `bottomk` are different from other aggregators in that a subset of\n-the input samples, including the original labels, are returned in the result\n-vector. `by` and `without` are only used to bucket the input vector. Similar to\n-`min` and `max`, they only operate on float samples, considering `NaN` values\n+#### `topk` and `bottomk`\n+\n+`topk(k, v)` and `bottomk(k, v)` are different from other aggregators in that a subset of\n+`k` values from the input samples, including the original labels, are returned in the result vector. \n+\n+`by` and `without` are only used to bucket the input vector. \n+\n+Similar to `min` and `max`, they only operate on float samples, considering `NaN` values\n to be farthest from the top or bottom, respectively. Histogram samples in the\n input vector are ignored, flagged by an info-level annotation.\n \n If used in an instant query, `topk` and `bottomk` return series ordered by\n value in descending or ascending order, respectively. If used with `by` or\n `without`, then series within each bucket are sorted by value, and series in\n the same bucket are returned consecutively, but there is no guarantee that\n-buckets of series will be returned in any particular order. No sorting applies\n-to range queries.\n-\n-`limitk` and `limit_ratio` also return a subset of the input samples, including\n-the original labels in the result vector. The subset is selected in a\n-deterministic pseudo-random way. `limitk` picks _k_ samples, while\n-`limit_ratio` picks a ratio _r_ of samples (each determined by `parameter`).\n-This happens independent of the sample type. Therefore, it works for both float\n-samples and histogram samples. _r_ can be between +1 and -1. The absolute value\n-of _r_ is used as the selection ratio, but the selection order is inverted for\n-a negative _r_, which can be used to select complements. For example,\n-`limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n+buckets of series will be returned in any particular order. \n+\n+No sorting applies to range queries.\n+\n+##### Example\n+\n+To get the 5 largest HTTP requests counts across all instances we could write:\n+\n+    topk(5, http_requests_total)\n+\n+#### `limitk` and `limit_ratio`\n+\n+`limitk(k, v)` returns a subset of `k` input samples, including\n+the original labels in the result vector. \n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type. \n+Therefore, it works for both float samples and histogram samples. \n+\n+##### Example\n+\n+To sample 10 timeseries, for example to inspect labels and their values, we\n+could write:\n+\n+    limitk(10, http_requests_total)\n+\n+#### `limit_ratio`\n+\n+`limit_ratio(r, v)` returns a subset of the input samples, including\n+the original labels in the result vector.\n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type.\n+Therefore, it works for both float samples and histogram samples.\n+\n+`r` can be between +1 and -1. The absolute value of `r` is used as the selection ratio,\n+but the selection order is inverted for a negative `r`, which can be used to select complements.\n+For example, `limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n the input samples, while `limit_ratio(-0.9, ...)` returns precisely the\n-remaining approximately 90% of the input samples not returned by\n-`limit_ratio(0.1, ...)`.\n+remaining approximately 90% of the input samples not returned by `limit_ratio(0.1, ...)`.\n \n-`group` and `count` do not interact with the sample values,\n-they work in the same way for float samples and histogram samples.\n+#### `group`\n+\n+`group(v)` returns 1 for each group that contains any value at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count`\n+\n+`count(v)` returns the number of values at that timestamp, or no value at all\n+if no values are present at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count_values`\n+\n+`count_values(l, v)` outputs one time series per unique sample value in `v`. \n+Each series has an additional label, given by `l`, and the label value is the \n+unique sample value. The value of each time series is the number of times that sample value was present.\n \n-`count_values` outputs one time series per unique sample value. Each series has\n-an additional label. The name of that label is given by the aggregation\n-parameter, and the label value is the unique sample value. The value of each\n-time series is the number of times that sample value was present.\n `count_values` works with both float samples and histogram samples. For the\n latter, a compact string representation of the histogram sample value is used\n as the label value.\n \n-`stddev` and `stdvar` only work with float samples, following IEEE 754 floating\n-point arithmetic. Histogram samples in the input vector are ignored, flagged by\n-an info-level annotation.\n-\n-`quantile` calculates the φ-quantile, the value that ranks at number φ*N among\n-the N metric values of the dimensions aggregated over. φ is provided as the\n-aggregation parameter. For example, `quantile(0.5, ...)` calculates the median,\n-`quantile(0.95, ...)` the 95th percentile. For φ = `NaN`, `NaN` is returned.\n-For φ < 0, `-Inf` is returned. For φ > 1, `+Inf` is returned.\n+##### Example\n \n-### Examples\n+To count the number of binaries running each build version we could write:\n \n-If the metric `http_requests_total` had time series that fan out by\n-`application`, `instance`, and `group` labels, we could calculate the total\n-number of seen HTTP requests per application and group over all instances via:\n+    count_values(\"version\", build_version)\n \n-    sum without (instance) (http_requests_total)\n+#### `stddev`\n \n-Which is equivalent to:\n+`stddev(v)` returns the standard deviation of `v`. \n \n-     sum by (application, group) (http_requests_total)\n+`stddev` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-If we are just interested in the total of HTTP requests we have seen in **all**\n-applications, we could simply write:\n+#### `stdvar`\n \n-    sum(http_requests_total)\n+`stdvar(v)` returns the standard deviation of `v`. \n \n-To count the number of binaries running each build version we could write:\n+`stdvar` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-    count_values(\"version\", build_version)\n+#### `quantile`\n \n-To get the 5 largest HTTP requests counts across all instances we could write:\n+`quantile(phi, v)` calculates the φ-quantile, the value that ranks at number φ*N among",
        "comment_created_at": "2025-07-10T02:22:54+00:00",
        "comment_author": "charleskorn",
        "comment_body": "Good point, fixed in 95f7535.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2194735616",
    "pr_number": 16837,
    "pr_file": "docs/querying/operators.md",
    "created_at": "2025-07-09T11:08:00+00:00",
    "commented_code": "used to aggregate the elements of a single instant vector, resulting in a new\n vector of fewer elements with aggregated values:\n \n-* `sum` (calculate sum over dimensions)\n-* `avg` (calculate the arithmetic average over dimensions)\n-* `min` (select minimum over dimensions)\n-* `max` (select maximum over dimensions)\n-* `bottomk` (smallest _k_ elements by sample value)\n-* `topk` (largest _k_ elements by sample value)\n-* `limitk` (sample _k_ elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n-* `limit_ratio` (sample a pseudo-random ratio _r_ of elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n-* `group` (all values in the resulting vector are 1)\n-* `count` (count number of elements in the vector)\n-* `count_values` (count number of elements with the same value)\n-\n-* `stddev` (calculate population standard deviation over dimensions)\n-* `stdvar` (calculate population standard variance over dimensions)\n-* `quantile` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\n+* `sum(v)` (calculate sum over dimensions)\n+* `avg(v)` (calculate the arithmetic average over dimensions)\n+* `min(v)` (select minimum over dimensions)\n+* `max(v)` (select maximum over dimensions)\n+* `bottomk(k, v)` (smallest `k` elements by sample value)\n+* `topk(k, v)` (largest `k` elements by sample value)\n+* `limitk(k, v)` (sample `k` elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n+* `limit_ratio(r, v)` (sample a pseudo-random ratio `r` of elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n+* `group(v)` (all values in the resulting vector are 1)\n+* `count(v)` (count number of elements in the vector)\n+* `count_values(l, v)` (count number of elements with the same value)\n+\n+* `stddev(v)` (calculate population standard deviation over dimensions)\n+* `stdvar(v)` (calculate population standard variance over dimensions)\n+* `quantile(phi, v)` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2194735616",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16837,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2194735616",
        "commented_code": "@@ -284,21 +284,21 @@ Prometheus supports the following built-in aggregation operators that can be\n used to aggregate the elements of a single instant vector, resulting in a new\n vector of fewer elements with aggregated values:\n \n-* `sum` (calculate sum over dimensions)\n-* `avg` (calculate the arithmetic average over dimensions)\n-* `min` (select minimum over dimensions)\n-* `max` (select maximum over dimensions)\n-* `bottomk` (smallest _k_ elements by sample value)\n-* `topk` (largest _k_ elements by sample value)\n-* `limitk` (sample _k_ elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n-* `limit_ratio` (sample a pseudo-random ratio _r_ of elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n-* `group` (all values in the resulting vector are 1)\n-* `count` (count number of elements in the vector)\n-* `count_values` (count number of elements with the same value)\n-\n-* `stddev` (calculate population standard deviation over dimensions)\n-* `stdvar` (calculate population standard variance over dimensions)\n-* `quantile` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\n+* `sum(v)` (calculate sum over dimensions)\n+* `avg(v)` (calculate the arithmetic average over dimensions)\n+* `min(v)` (select minimum over dimensions)\n+* `max(v)` (select maximum over dimensions)\n+* `bottomk(k, v)` (smallest `k` elements by sample value)\n+* `topk(k, v)` (largest `k` elements by sample value)\n+* `limitk(k, v)` (sample `k` elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n+* `limit_ratio(r, v)` (sample a pseudo-random ratio `r` of elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n+* `group(v)` (all values in the resulting vector are 1)\n+* `count(v)` (count number of elements in the vector)\n+* `count_values(l, v)` (count number of elements with the same value)\n+\n+* `stddev(v)` (calculate population standard deviation over dimensions)\n+* `stdvar(v)` (calculate population standard variance over dimensions)\n+* `quantile(phi, v)` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)",
        "comment_created_at": "2025-07-09T11:08:00+00:00",
        "comment_author": "beorn7",
        "comment_body": "```suggestion\r\n* `quantile(φ, v)` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\r\n```\r\n\r\nIsn't it better to use the same character consistently? (Some readers might not even know how to read \"φ\", so they won't get the connection to \"phi\").",
        "pr_file_module": null
      },
      {
        "comment_id": "2196362056",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16837,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2194735616",
        "commented_code": "@@ -284,21 +284,21 @@ Prometheus supports the following built-in aggregation operators that can be\n used to aggregate the elements of a single instant vector, resulting in a new\n vector of fewer elements with aggregated values:\n \n-* `sum` (calculate sum over dimensions)\n-* `avg` (calculate the arithmetic average over dimensions)\n-* `min` (select minimum over dimensions)\n-* `max` (select maximum over dimensions)\n-* `bottomk` (smallest _k_ elements by sample value)\n-* `topk` (largest _k_ elements by sample value)\n-* `limitk` (sample _k_ elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n-* `limit_ratio` (sample a pseudo-random ratio _r_ of elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n-* `group` (all values in the resulting vector are 1)\n-* `count` (count number of elements in the vector)\n-* `count_values` (count number of elements with the same value)\n-\n-* `stddev` (calculate population standard deviation over dimensions)\n-* `stdvar` (calculate population standard variance over dimensions)\n-* `quantile` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\n+* `sum(v)` (calculate sum over dimensions)\n+* `avg(v)` (calculate the arithmetic average over dimensions)\n+* `min(v)` (select minimum over dimensions)\n+* `max(v)` (select maximum over dimensions)\n+* `bottomk(k, v)` (smallest `k` elements by sample value)\n+* `topk(k, v)` (largest `k` elements by sample value)\n+* `limitk(k, v)` (sample `k` elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n+* `limit_ratio(r, v)` (sample a pseudo-random ratio `r` of elements, **experimental**, must be enabled with `--enable-feature=promql-experimental-functions`)\n+* `group(v)` (all values in the resulting vector are 1)\n+* `count(v)` (count number of elements in the vector)\n+* `count_values(l, v)` (count number of elements with the same value)\n+\n+* `stddev(v)` (calculate population standard deviation over dimensions)\n+* `stdvar(v)` (calculate population standard variance over dimensions)\n+* `quantile(phi, v)` (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)",
        "comment_created_at": "2025-07-10T02:22:49+00:00",
        "comment_author": "charleskorn",
        "comment_body": "Good point, fixed in 95f7535.",
        "pr_file_module": null
      }
    ]
  }
]