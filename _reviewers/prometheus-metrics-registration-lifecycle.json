[
  {
    "discussion_id": "1924369889",
    "pr_number": 15809,
    "pr_file": "cmd/prometheus/main.go",
    "created_at": "2025-01-21T21:12:48+00:00",
    "commented_code": "}\n \n \t// Unregister the default GoCollector, and reregister with our defaults.\n-\tif prometheus.Unregister(collectors.NewGoCollector()) {\n-\t\tprometheus.MustRegister(\n+\tif registry.Unregister(collectors.NewGoCollector()) {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1924369889",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "cmd/prometheus/main.go",
        "discussion_id": "1924369889",
        "commented_code": "@@ -294,8 +296,8 @@ func main() {\n \t}\n \n \t// Unregister the default GoCollector, and reregister with our defaults.\n-\tif prometheus.Unregister(collectors.NewGoCollector()) {\n-\t\tprometheus.MustRegister(\n+\tif registry.Unregister(collectors.NewGoCollector()) {",
        "comment_created_at": "2025-01-21T21:12:48+00:00",
        "comment_author": "beorn7",
        "comment_body": "The good thing with the custom registry is that it doesn't even have a Go collector pre-registered, so you can remove the `if` altogether and register the custom Go collector unconditionally.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1924372865",
    "pr_number": 15809,
    "pr_file": "cmd/prometheus/main.go",
    "created_at": "2025-01-21T21:16:00+00:00",
    "commented_code": "}\n \n \t// Unregister the default GoCollector, and reregister with our defaults.\n-\tif prometheus.Unregister(collectors.NewGoCollector()) {\n-\t\tprometheus.MustRegister(\n+\tif registry.Unregister(collectors.NewGoCollector()) {\n+\t\tregistry.MustRegister(",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1924372865",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "cmd/prometheus/main.go",
        "discussion_id": "1924372865",
        "commented_code": "@@ -294,8 +296,8 @@ func main() {\n \t}\n \n \t// Unregister the default GoCollector, and reregister with our defaults.\n-\tif prometheus.Unregister(collectors.NewGoCollector()) {\n-\t\tprometheus.MustRegister(\n+\tif registry.Unregister(collectors.NewGoCollector()) {\n+\t\tregistry.MustRegister(",
        "comment_created_at": "2025-01-21T21:16:00+00:00",
        "comment_author": "beorn7",
        "comment_body": "You also need to register a `NewProcessCollector`. That's the other collector that is registered with the default registry, see https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#pkg-variables",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1981807354",
    "pr_number": 15809,
    "pr_file": "discovery/zookeeper/metrics.go",
    "created_at": "2025-03-05T16:52:35+00:00",
    "commented_code": "+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"sync\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+var registerMetricsOnce sync.Once\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// Register zookeeper metrics once for both ServerSet and Nerve SD.\n+\tregisterMetricsOnce.Do(func() {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1981807354",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "discovery/zookeeper/metrics.go",
        "discussion_id": "1981807354",
        "commented_code": "@@ -0,0 +1,69 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"sync\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+var registerMetricsOnce sync.Once\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// Register zookeeper metrics once for both ServerSet and Nerve SD.\n+\tregisterMetricsOnce.Do(func() {",
        "comment_created_at": "2025-03-05T16:52:35+00:00",
        "comment_author": "beorn7",
        "comment_body": "This will avoid registration errors, but it will also mean that the later created metrics will never get exposed (because they are not part of any registry).\r\n\r\nThe problem here is that two slightly different SD mechanisms want to share the same metrics. We would probably design this differently from scratch, but now that we have this situation, let's keep it for now.\r\n\r\nTo handle this problem, you have to use this pattern: https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#example-AlreadyRegisteredError\r\n\r\nIn this way, you can retrieve the already registered metric from the registry and return it as part of `zookeeperMetrics` instead of the newly created one.",
        "pr_file_module": null
      },
      {
        "comment_id": "1986110499",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "discovery/zookeeper/metrics.go",
        "discussion_id": "1981807354",
        "commented_code": "@@ -0,0 +1,69 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"sync\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+var registerMetricsOnce sync.Once\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// Register zookeeper metrics once for both ServerSet and Nerve SD.\n+\tregisterMetricsOnce.Do(func() {",
        "comment_created_at": "2025-03-08T16:16:48+00:00",
        "comment_author": "Vandit1604",
        "comment_body": "I'll take a look at the link and update the code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2012375708",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "discovery/zookeeper/metrics.go",
        "discussion_id": "1981807354",
        "commented_code": "@@ -0,0 +1,69 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"sync\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+var registerMetricsOnce sync.Once\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// Register zookeeper metrics once for both ServerSet and Nerve SD.\n+\tregisterMetricsOnce.Do(func() {",
        "comment_created_at": "2025-03-25T15:29:54+00:00",
        "comment_author": "beorn7",
        "comment_body": "The usage of the `AlreadyRegisteredError` pattern below looks good, but you still need to get rid of the `Once.Do`. Otherwise the old metrics won't be used.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012386509",
    "pr_number": 15809,
    "pr_file": "discovery/zookeeper/metrics.go",
    "created_at": "2025-03-25T15:34:37+00:00",
    "commented_code": "+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+var registerMetricsOnce sync.Once\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// Register zookeeper metrics once for both ServerSet and Nerve SD.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2012386509",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "discovery/zookeeper/metrics.go",
        "discussion_id": "2012386509",
        "commented_code": "@@ -0,0 +1,86 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+var registerMetricsOnce sync.Once\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// Register zookeeper metrics once for both ServerSet and Nerve SD.",
        "comment_created_at": "2025-03-25T15:34:37+00:00",
        "comment_author": "beorn7",
        "comment_body": "This needs a different comment now, see suggestion below.\r\n\r\n```suggestion\r\n\t// For historical reasons, both ServerSet and Nerve SD share the same zookeeper metrics.\r\n\t// To not cause double registration problems, if both SD mechanisms are instantiated with\r\n\t// the same registry, we are handling the AlreadyRegisteredError accordingly below.\r\n\t// TODO: Consider separate zookeeper metrics for both SD mechanisms in the future.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2063931326",
    "pr_number": 15809,
    "pr_file": "discovery/zookeeper/metrics.go",
    "created_at": "2025-04-28T15:30:20+00:00",
    "commented_code": "+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"errors\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// For historical reasons, both ServerSet and Nerve SD share the same zookeeper metrics.\n+\t// To not cause double registration problems, if both SD mechanisms are instantiated with\n+\t// the same registry, we are handling the AlreadyRegisteredError accordingly below.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2063931326",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "discovery/zookeeper/metrics.go",
        "discussion_id": "2063931326",
        "commented_code": "@@ -0,0 +1,82 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"errors\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// For historical reasons, both ServerSet and Nerve SD share the same zookeeper metrics.\n+\t// To not cause double registration problems, if both SD mechanisms are instantiated with\n+\t// the same registry, we are handling the AlreadyRegisteredError accordingly below.",
        "comment_created_at": "2025-04-28T15:30:20+00:00",
        "comment_author": "ptodev",
        "comment_body": "I suppose that the metrics should normally get unregistered if the config file is reloaded, but in this case it won't happen? It would be nice if the two SDs indeed use different metrics one day to make sure such edge cases are handled ok. But for now it should be ok to use `AlreadyRegisteredError`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2069505938",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "discovery/zookeeper/metrics.go",
        "discussion_id": "2063931326",
        "commented_code": "@@ -0,0 +1,82 @@\n+// Copyright 2025 The Prometheus Authors\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package zookeeper\n+\n+import (\n+\t\"errors\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\n+\t\"github.com/prometheus/prometheus/discovery\"\n+)\n+\n+type zookeeperMetrics struct {\n+\t// The total number of ZooKeeper failures.\n+\tfailureCounter prometheus.Counter\n+\t// The current number of Zookeeper watcher goroutines.\n+\tnumWatchers prometheus.Gauge\n+}\n+\n+// Create and register metrics.\n+func newDiscovererMetrics(reg prometheus.Registerer, _ discovery.RefreshMetricsInstantiator) discovery.DiscovererMetrics {\n+\tm := &zookeeperMetrics{\n+\t\tfailureCounter: prometheus.NewCounter(prometheus.CounterOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"zookeeper_failures_total\",\n+\t\t\tHelp:      \"The total number of ZooKeeper failures.\",\n+\t\t}),\n+\t\tnumWatchers: prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\t\tNamespace: \"prometheus\",\n+\t\t\tSubsystem: \"treecache\",\n+\t\t\tName:      \"watcher_goroutines\",\n+\t\t\tHelp:      \"The current number of watcher goroutines.\",\n+\t\t}),\n+\t}\n+\t// For historical reasons, both ServerSet and Nerve SD share the same zookeeper metrics.\n+\t// To not cause double registration problems, if both SD mechanisms are instantiated with\n+\t// the same registry, we are handling the AlreadyRegisteredError accordingly below.",
        "comment_created_at": "2025-04-30T21:50:39+00:00",
        "comment_author": "beorn7",
        "comment_body": "Yes, we should definitely aim for separating those metrics one day.\r\n\r\nUnregistering is a bit of a problem, I guess, once both ServerSet and Nerve SD are used at the same time. Maybe let's not do the unregistering in this case (but leave a comment why that is the case and that we should one day separate the metrics for both SDs).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2063940697",
    "pr_number": 15809,
    "pr_file": "storage/remote/client.go",
    "created_at": "2025-04-28T15:33:53+00:00",
    "commented_code": "Read(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func registerRemoteReadMetrics(registry prometheus.Registerer) {\n+\tregistry.MustRegister(remoteReadQueriesTotal, remoteReadQueries, remoteReadQueryDuration)",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2063940697",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/client.go",
        "discussion_id": "2063940697",
        "commented_code": "@@ -144,8 +140,16 @@ type ReadClient interface {\n \tRead(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func registerRemoteReadMetrics(registry prometheus.Registerer) {\n+\tregistry.MustRegister(remoteReadQueriesTotal, remoteReadQueries, remoteReadQueryDuration)",
        "comment_created_at": "2025-04-28T15:33:53+00:00",
        "comment_author": "ptodev",
        "comment_body": "Do these need to get unregistered? E.g. if the config file is reloaded? It might be good to have a way to unregister them if this code is used as a library by someone 🤔 Or to simply pass the already registered metrics in a struct to NewReadClient.",
        "pr_file_module": null
      },
      {
        "comment_id": "2076424203",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/client.go",
        "discussion_id": "2063940697",
        "commented_code": "@@ -144,8 +140,16 @@ type ReadClient interface {\n \tRead(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func registerRemoteReadMetrics(registry prometheus.Registerer) {\n+\tregistry.MustRegister(remoteReadQueriesTotal, remoteReadQueries, remoteReadQueryDuration)",
        "comment_created_at": "2025-05-06T22:18:39+00:00",
        "comment_author": "beorn7",
        "comment_body": "It's actually not just about the unregistering. `NewReadClient` is called once per RemoteReadConfig, se we'll get a panic here once we have more than one RemoteReadConfig.\r\n\r\nThe metrics are, however, curried with `remote_name` and `url` labels, so we can use this to distinguish them between the different clients. You could use something like `prometheus.WrapRegistererWith(prometheus.Labels{remoteName: name, endpoint: conf.URL.String()}, reg)` and then use local instances of the three metrics without the `remote_name` and `url` labels.\r\n\r\nOr you can do what @ptodev suggested and manage the registration of the three metrics outside of `NewReadClient` and pass in the already registered metrics (maybe in a struct) as a parameter of `NewReadClient`.\r\n\r\nI would think that the former is cleaner and more idiomatic, but it's also more refactoring work.",
        "pr_file_module": null
      },
      {
        "comment_id": "2083098589",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/client.go",
        "discussion_id": "2063940697",
        "commented_code": "@@ -144,8 +140,16 @@ type ReadClient interface {\n \tRead(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func registerRemoteReadMetrics(registry prometheus.Registerer) {\n+\tregistry.MustRegister(remoteReadQueriesTotal, remoteReadQueries, remoteReadQueryDuration)",
        "comment_created_at": "2025-05-10T10:13:26+00:00",
        "comment_author": "Vandit1604",
        "comment_body": "Thanks! I went with the `WrapRegistererWith(...)` approach — agreed it's cleaner and avoids leaking global metrics. I dropped `remote_name` and `endpoint` from the `*Vec` label sets and let the wrapped registerer inject those. Each `RemoteReadConfig` now gets its own set of metrics, registered safely, and exposed with per-client isolation.\r\n\r\nTested with configs, config reloads, and a stub /read endpoint — metrics are registering and emitting as expected without any duplication issues. Let me know if there's anything else I should validate.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2063951541",
    "pr_number": 15809,
    "pr_file": "storage/remote/intern.go",
    "created_at": "2025-04-28T15:38:26+00:00",
    "commented_code": "return &entry{s: s}\n }\n \n-func newPool() *pool {\n+func newPool(reg prometheus.Registerer) *pool {\n+\tif reg != nil {\n+\t\treg.MustRegister(noReferenceReleases)",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2063951541",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/intern.go",
        "discussion_id": "2063951541",
        "commented_code": "@@ -48,7 +47,11 @@ func newEntry(s string) *entry {\n \treturn &entry{s: s}\n }\n \n-func newPool() *pool {\n+func newPool(reg prometheus.Registerer) *pool {\n+\tif reg != nil {\n+\t\treg.MustRegister(noReferenceReleases)",
        "comment_created_at": "2025-04-28T15:38:26+00:00",
        "comment_author": "ptodev",
        "comment_body": "Does this need to also get unregistered at some point?",
        "pr_file_module": null
      },
      {
        "comment_id": "2076428194",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/intern.go",
        "discussion_id": "2063951541",
        "commented_code": "@@ -48,7 +47,11 @@ func newEntry(s string) *entry {\n \treturn &entry{s: s}\n }\n \n-func newPool() *pool {\n+func newPool(reg prometheus.Registerer) *pool {\n+\tif reg != nil {\n+\t\treg.MustRegister(noReferenceReleases)",
        "comment_created_at": "2025-05-06T22:23:32+00:00",
        "comment_author": "beorn7",
        "comment_body": "Maybe here we don't need to worry. We already have metrics being registered in `func NewWriteStorage` with the custom registry and do not bother about unregistering. We only have one storage, so this should be fine for now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084137648",
    "pr_number": 15809,
    "pr_file": "storage/remote/client.go",
    "created_at": "2025-05-12T08:35:51+00:00",
    "commented_code": "Read(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func newRemoteReadMetrics(\n+\tname string,\n+\turl string,\n+\treg prometheus.Registerer,\n+) (\n+\treadQueries prometheus.Gauge,\n+\treadQueriesTotal *prometheus.CounterVec,\n+\treadQueryDuration prometheus.ObserverVec,\n+) {\n+\twrappedReg := prometheus.WrapRegistererWith(prometheus.Labels{\n+\t\t\"remote_name\": name,\n+\t\t\"endpoint\":    url,\n+\t}, reg)\n+\n+\treadQueries = prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries\",\n+\t\tHelp:      \"The number of in-flight remote read queries.\",\n+\t})\n+\n+\treadQueriesTotalVec := prometheus.NewCounterVec(prometheus.CounterOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries_total\",\n+\t\tHelp:      \"The total number of remote read queries.\",\n+\t}, []string{\"response_type\", \"code\"})\n+\n+\treadQueryDurationVec := prometheus.NewHistogramVec(prometheus.HistogramOpts{\n+\t\tNamespace:                       namespace,\n+\t\tSubsystem:                       \"remote_read_client\",\n+\t\tName:                            \"request_duration_seconds\",\n+\t\tHelp:                            \"Histogram of the latency for remote read requests. For streamed responses, this is only the duration of the initial call.\",\n+\t\tBuckets:                         append(prometheus.DefBuckets, 25, 60),\n+\t\tNativeHistogramBucketFactor:     1.1,\n+\t\tNativeHistogramMaxBucketNumber:  100,\n+\t\tNativeHistogramMinResetDuration: time.Hour,\n+\t}, []string{\"response_type\"})\n+\n+\twrappedReg.MustRegister(readQueries, readQueriesTotalVec, readQueryDurationVec)",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2084137648",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/client.go",
        "discussion_id": "2084137648",
        "commented_code": "@@ -144,8 +108,52 @@ type ReadClient interface {\n \tRead(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func newRemoteReadMetrics(\n+\tname string,\n+\turl string,\n+\treg prometheus.Registerer,\n+) (\n+\treadQueries prometheus.Gauge,\n+\treadQueriesTotal *prometheus.CounterVec,\n+\treadQueryDuration prometheus.ObserverVec,\n+) {\n+\twrappedReg := prometheus.WrapRegistererWith(prometheus.Labels{\n+\t\t\"remote_name\": name,\n+\t\t\"endpoint\":    url,\n+\t}, reg)\n+\n+\treadQueries = prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries\",\n+\t\tHelp:      \"The number of in-flight remote read queries.\",\n+\t})\n+\n+\treadQueriesTotalVec := prometheus.NewCounterVec(prometheus.CounterOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries_total\",\n+\t\tHelp:      \"The total number of remote read queries.\",\n+\t}, []string{\"response_type\", \"code\"})\n+\n+\treadQueryDurationVec := prometheus.NewHistogramVec(prometheus.HistogramOpts{\n+\t\tNamespace:                       namespace,\n+\t\tSubsystem:                       \"remote_read_client\",\n+\t\tName:                            \"request_duration_seconds\",\n+\t\tHelp:                            \"Histogram of the latency for remote read requests. For streamed responses, this is only the duration of the initial call.\",\n+\t\tBuckets:                         append(prometheus.DefBuckets, 25, 60),\n+\t\tNativeHistogramBucketFactor:     1.1,\n+\t\tNativeHistogramMaxBucketNumber:  100,\n+\t\tNativeHistogramMinResetDuration: time.Hour,\n+\t}, []string{\"response_type\"})\n+\n+\twrappedReg.MustRegister(readQueries, readQueriesTotalVec, readQueryDurationVec)",
        "comment_created_at": "2025-05-12T08:35:51+00:00",
        "comment_author": "beorn7",
        "comment_body": "My suspicion is that this will panic if we reload the config. Check how `NewReadClient` is called in a loop in storage/remote/storage.go. This will work fine the first time, but whenever we reload the config, we will try to register the same metrics again.\r\n\r\nThis should be easy to test, just run a Prometheus server with a remote read config and send it a SIGHUP.\r\n\r\nThe remedy would be to un-register the metrics before creating new read clients. This will also help to get rid of metrics belonging to a remote read config that got removed from the config.",
        "pr_file_module": null
      },
      {
        "comment_id": "2087491391",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/client.go",
        "discussion_id": "2084137648",
        "commented_code": "@@ -144,8 +108,52 @@ type ReadClient interface {\n \tRead(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func newRemoteReadMetrics(\n+\tname string,\n+\turl string,\n+\treg prometheus.Registerer,\n+) (\n+\treadQueries prometheus.Gauge,\n+\treadQueriesTotal *prometheus.CounterVec,\n+\treadQueryDuration prometheus.ObserverVec,\n+) {\n+\twrappedReg := prometheus.WrapRegistererWith(prometheus.Labels{\n+\t\t\"remote_name\": name,\n+\t\t\"endpoint\":    url,\n+\t}, reg)\n+\n+\treadQueries = prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries\",\n+\t\tHelp:      \"The number of in-flight remote read queries.\",\n+\t})\n+\n+\treadQueriesTotalVec := prometheus.NewCounterVec(prometheus.CounterOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries_total\",\n+\t\tHelp:      \"The total number of remote read queries.\",\n+\t}, []string{\"response_type\", \"code\"})\n+\n+\treadQueryDurationVec := prometheus.NewHistogramVec(prometheus.HistogramOpts{\n+\t\tNamespace:                       namespace,\n+\t\tSubsystem:                       \"remote_read_client\",\n+\t\tName:                            \"request_duration_seconds\",\n+\t\tHelp:                            \"Histogram of the latency for remote read requests. For streamed responses, this is only the duration of the initial call.\",\n+\t\tBuckets:                         append(prometheus.DefBuckets, 25, 60),\n+\t\tNativeHistogramBucketFactor:     1.1,\n+\t\tNativeHistogramMaxBucketNumber:  100,\n+\t\tNativeHistogramMinResetDuration: time.Hour,\n+\t}, []string{\"response_type\"})\n+\n+\twrappedReg.MustRegister(readQueries, readQueriesTotalVec, readQueryDurationVec)",
        "comment_created_at": "2025-05-13T19:27:53+00:00",
        "comment_author": "Vandit1604",
        "comment_body": "\r\nYou're right — I added logic in `client.go` to unregister metrics before re-registering them in `newRemoteReadMetrics()`, which prevents the panic on config reloads:\r\n\r\n```go\r\nold.reg.Unregister(old.readQueries)\r\nold.reg.Unregister(old.readQueriesTotalVec)\r\nold.reg.Unregister(old.readQueryDurationVec)\r\n```\r\n\r\nThis handles re-registration cleanly. I also added tracking in `storage.go` to detect when a `remote_read` config is removed, and call `unregisterRemoteReadMetrics(key)` in that case. This ensures metrics are fully unregistered and don’t linger after a config reload.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2155559981",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/client.go",
        "discussion_id": "2084137648",
        "commented_code": "@@ -144,8 +108,52 @@ type ReadClient interface {\n \tRead(ctx context.Context, query *prompb.Query, sortSeries bool) (storage.SeriesSet, error)\n }\n \n+func newRemoteReadMetrics(\n+\tname string,\n+\turl string,\n+\treg prometheus.Registerer,\n+) (\n+\treadQueries prometheus.Gauge,\n+\treadQueriesTotal *prometheus.CounterVec,\n+\treadQueryDuration prometheus.ObserverVec,\n+) {\n+\twrappedReg := prometheus.WrapRegistererWith(prometheus.Labels{\n+\t\t\"remote_name\": name,\n+\t\t\"endpoint\":    url,\n+\t}, reg)\n+\n+\treadQueries = prometheus.NewGauge(prometheus.GaugeOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries\",\n+\t\tHelp:      \"The number of in-flight remote read queries.\",\n+\t})\n+\n+\treadQueriesTotalVec := prometheus.NewCounterVec(prometheus.CounterOpts{\n+\t\tNamespace: namespace,\n+\t\tSubsystem: \"remote_read_client\",\n+\t\tName:      \"queries_total\",\n+\t\tHelp:      \"The total number of remote read queries.\",\n+\t}, []string{\"response_type\", \"code\"})\n+\n+\treadQueryDurationVec := prometheus.NewHistogramVec(prometheus.HistogramOpts{\n+\t\tNamespace:                       namespace,\n+\t\tSubsystem:                       \"remote_read_client\",\n+\t\tName:                            \"request_duration_seconds\",\n+\t\tHelp:                            \"Histogram of the latency for remote read requests. For streamed responses, this is only the duration of the initial call.\",\n+\t\tBuckets:                         append(prometheus.DefBuckets, 25, 60),\n+\t\tNativeHistogramBucketFactor:     1.1,\n+\t\tNativeHistogramMaxBucketNumber:  100,\n+\t\tNativeHistogramMinResetDuration: time.Hour,\n+\t}, []string{\"response_type\"})\n+\n+\twrappedReg.MustRegister(readQueries, readQueriesTotalVec, readQueryDurationVec)",
        "comment_created_at": "2025-06-18T21:46:12+00:00",
        "comment_author": "beorn7",
        "comment_body": "Thanks for your efforts (and apologies again for the delay in reviewing).\r\n\r\nThe problem now is that the metrics are always recreated, so we get a counter reset on all counters each time we reload the config. (Which is a side effect of the current code always creating new remote clients when the config is reloaded. Other sub-systems use more logic around this to avoid that.)\r\n\r\nThe code is now tracking the configs (to unregister if a config goes away for good) and the metrics (while the metrics are also tracked in the registry anyway). This seems a lot of effort for limited effect, that even comes with the annoyance of counter resets on config reloads, even if there are no relevant changes.\r\n\r\nI'm currently not sure how to solve this better. I have to think about it and will come back to you with ideas once I find the time.",
        "pr_file_module": null
      }
    ]
  }
]