[
  {
    "discussion_id": "2111056328",
    "pr_number": 16257,
    "pr_file": "web/api/v1/api_test.go",
    "created_at": "2025-05-28T06:43:07+00:00",
    "commented_code": "}\n \n func TestRespondError(t *testing.T) {\n-\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n-\t\tapi := API{}\n-\t\tapi.respondError(w, &apiError{errorTimeout, errors.New(\"message\")}, \"test\")\n-\t}))\n-\tdefer s.Close()\n+\ttype test struct {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2111056328",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16257,
        "pr_file": "web/api/v1/api_test.go",
        "discussion_id": "2111056328",
        "commented_code": "@@ -4123,22 +4123,65 @@ func TestRespondSuccess_DefaultCodecCannotEncodeResponse(t *testing.T) {\n }\n \n func TestRespondError(t *testing.T) {\n-\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n-\t\tapi := API{}\n-\t\tapi.respondError(w, &apiError{errorTimeout, errors.New(\"message\")}, \"test\")\n-\t}))\n-\tdefer s.Close()\n+\ttype test struct {",
        "comment_created_at": "2025-05-28T06:43:07+00:00",
        "comment_author": "machine424",
        "comment_body": "thanks, I think we can simplify it a little bit\r\n```diff\r\ndiff --git a/web/api/v1/api_test.go b/web/api/v1/api_test.go\r\nindex 18305ff3d..8e926c9e6 100644\r\n--- a/web/api/v1/api_test.go\r\n+++ b/web/api/v1/api_test.go\r\n@@ -4125,48 +4125,37 @@ func TestRespondSuccess_DefaultCodecCannotEncodeResponse(t *testing.T) {\r\n func TestRespondError(t *testing.T) {\r\n        type test struct {\r\n                errType             errorType\r\n-               err                 error\r\n                resCode             int\r\n-               msg                 string\r\n                errTypeToStatusCode ErrorTypeToStatusCode\r\n        }\r\n \r\n        tests := map[string]test{\r\n                \"timeout should return 503 (ServiceUnavailable)\": {\r\n                        errType: ErrorTimeout,\r\n-                       err:     errors.New(\"message\"),\r\n                        resCode: http.StatusServiceUnavailable,\r\n-                       msg:     \"message\",\r\n                },\r\n                \"execution error without override should return 422 (UnprocessableEntity)\": {\r\n                        errType: ErrorExec,\r\n-                       err:     errors.New(\"message\"),\r\n                        resCode: http.StatusUnprocessableEntity,\r\n-                       msg:     \"message\",\r\n                },\r\n                \"errorTypeToStatusCode override works as expected\": {\r\n                        errType: ErrorExec,\r\n-                       err:     errors.New(\"message\"),\r\n                        errTypeToStatusCode: map[errorType]func(error) int{\r\n                                ErrorExec: func(_ error) int {\r\n                                        return http.StatusTooManyRequests\r\n                                },\r\n                        },\r\n                        resCode: http.StatusTooManyRequests,\r\n-                       msg:     \"message\",\r\n                },\r\n        }\r\n \r\n        for name, tc := range tests {\r\n                t.Run(name, func(t *testing.T) {\r\n                        s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\r\n-                               api := API{}\r\n-                               err := tc.err\r\n-                               api.errorTypeToStatusCode = map[errorType]func(error) int{}\r\n-                               for errType, handler := range tc.errTypeToStatusCode {\r\n-                                       api.errorTypeToStatusCode[errType] = handler\r\n+                               api := API{\r\n+                                       errorTypeToStatusCode: tc.errTypeToStatusCode,\r\n                                }\r\n-                               api.respondError(w, &apiError{tc.errType, err}, \"test\")\r\n+                               api.respondError(w, &apiError{tc.errType, errors.New(\"message\")}, \"test\")\r\n                        }))\r\n                        defer s.Close()\r\n \r\n@@ -4179,7 +4168,7 @@ func TestRespondError(t *testing.T) {\r\n                        require.Equal(t, want, have, \"Return code %d expected in error response but got %d\", want, have)\r\n                        h := resp.Header.Get(\"Content-Type\")\r\n                        require.Equal(t, \"application/json\", h, \"Expected Content-Type %q but got %q\", \"application/json\", h)\r\n-                       require.JSONEq(t, fmt.Sprintf(`{\"status\": \"error\", \"data\": \"test\", \"errorType\": \"%s\", \"error\": \"%s\"}`, tc.errType, tc.msg), string(body))\r\n+                       require.JSONEq(t, fmt.Sprintf(`{\"status\": \"error\", \"data\": \"test\", \"errorType\": \"%s\", \"error\": \"message\"}`, tc.errType), string(body))\r\n                })\r\n        }\r\n }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2112266178",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16257,
        "pr_file": "web/api/v1/api_test.go",
        "discussion_id": "2111056328",
        "commented_code": "@@ -4123,22 +4123,65 @@ func TestRespondSuccess_DefaultCodecCannotEncodeResponse(t *testing.T) {\n }\n \n func TestRespondError(t *testing.T) {\n-\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n-\t\tapi := API{}\n-\t\tapi.respondError(w, &apiError{errorTimeout, errors.New(\"message\")}, \"test\")\n-\t}))\n-\tdefer s.Close()\n+\ttype test struct {",
        "comment_created_at": "2025-05-28T16:05:23+00:00",
        "comment_author": "justinjung04",
        "comment_body": "Thanks for catching! Made the change.",
        "pr_file_module": null
      },
      {
        "comment_id": "2112290529",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16257,
        "pr_file": "web/api/v1/api_test.go",
        "discussion_id": "2111056328",
        "commented_code": "@@ -4123,22 +4123,65 @@ func TestRespondSuccess_DefaultCodecCannotEncodeResponse(t *testing.T) {\n }\n \n func TestRespondError(t *testing.T) {\n-\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n-\t\tapi := API{}\n-\t\tapi.respondError(w, &apiError{errorTimeout, errors.New(\"message\")}, \"test\")\n-\t}))\n-\tdefer s.Close()\n+\ttype test struct {",
        "comment_created_at": "2025-05-28T16:18:58+00:00",
        "comment_author": "machine424",
        "comment_body": "Looks like an LLM change ;) (I may be wrong)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989031292",
    "pr_number": 15864,
    "pr_file": "util/fmtutil/format_test.go",
    "created_at": "2025-03-11T11:27:58+00:00",
    "commented_code": "_, err := MetricTextToWriteRequest(input, labels)\n \trequire.Equal(t, \"text format parsing error in line 3: unknown metric type \\\"info\\\"\", err.Error())\n }\n+\n+func TestMakeTimeseries_HistogramInfBucket(t *testing.T) {\n+\ttests := map[string]*dto.Histogram{\n+\t\t\"Histogram missing +Inf bucket\": {\n+\t\t\tBucket: []*dto.Bucket{\n+\t\t\t\t{CumulativeCount: p[uint64](5), UpperBound: p(1.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](10), UpperBound: p(5.0)},\n+\t\t\t},\n+\t\t\tSampleCount: p[uint64](15),\n+\t\t},\n+\t\t\"Histogram already has +Inf bucket\": {\n+\t\t\tBucket: []*dto.Bucket{\n+\t\t\t\t{CumulativeCount: p[uint64](5), UpperBound: p(1.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](10), UpperBound: p(5.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](15), UpperBound: p(math.Inf(1))},\n+\t\t\t},\n+\t\t\tSampleCount: p[uint64](15),\n+\t\t},\n+\t}\n+\n+\tfor name, histogram := range tests {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\twr := &prompb.WriteRequest{}\n+\t\t\tlabels := map[string]string{\"__name__\": \"test_histogram\"}\n+\t\t\tmetric := &dto.Metric{\n+\t\t\t\tHistogram:   histogram,\n+\t\t\t\tTimestampMs: p(time.Now().UnixMilli()),\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, makeTimeseries(wr, labels, metric))\n+\n+\t\t\tvar hasInf bool",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1989031292",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15864,
        "pr_file": "util/fmtutil/format_test.go",
        "discussion_id": "1989031292",
        "commented_code": "@@ -231,3 +233,50 @@ func TestMetricTextToWriteRequestErrorParsingMetricType(t *testing.T) {\n \t_, err := MetricTextToWriteRequest(input, labels)\n \trequire.Equal(t, \"text format parsing error in line 3: unknown metric type \\\"info\\\"\", err.Error())\n }\n+\n+func TestMakeTimeseries_HistogramInfBucket(t *testing.T) {\n+\ttests := map[string]*dto.Histogram{\n+\t\t\"Histogram missing +Inf bucket\": {\n+\t\t\tBucket: []*dto.Bucket{\n+\t\t\t\t{CumulativeCount: p[uint64](5), UpperBound: p(1.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](10), UpperBound: p(5.0)},\n+\t\t\t},\n+\t\t\tSampleCount: p[uint64](15),\n+\t\t},\n+\t\t\"Histogram already has +Inf bucket\": {\n+\t\t\tBucket: []*dto.Bucket{\n+\t\t\t\t{CumulativeCount: p[uint64](5), UpperBound: p(1.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](10), UpperBound: p(5.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](15), UpperBound: p(math.Inf(1))},\n+\t\t\t},\n+\t\t\tSampleCount: p[uint64](15),\n+\t\t},\n+\t}\n+\n+\tfor name, histogram := range tests {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\twr := &prompb.WriteRequest{}\n+\t\t\tlabels := map[string]string{\"__name__\": \"test_histogram\"}\n+\t\t\tmetric := &dto.Metric{\n+\t\t\t\tHistogram:   histogram,\n+\t\t\t\tTimestampMs: p(time.Now().UnixMilli()),\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, makeTimeseries(wr, labels, metric))\n+\n+\t\t\tvar hasInf bool",
        "comment_created_at": "2025-03-11T11:27:58+00:00",
        "comment_author": "krajorama",
        "comment_body": "it would be more descriptive to just define the expected output in the test case and compare directly, let's not calculate here",
        "pr_file_module": null
      },
      {
        "comment_id": "2075875827",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15864,
        "pr_file": "util/fmtutil/format_test.go",
        "discussion_id": "1989031292",
        "commented_code": "@@ -231,3 +233,50 @@ func TestMetricTextToWriteRequestErrorParsingMetricType(t *testing.T) {\n \t_, err := MetricTextToWriteRequest(input, labels)\n \trequire.Equal(t, \"text format parsing error in line 3: unknown metric type \\\"info\\\"\", err.Error())\n }\n+\n+func TestMakeTimeseries_HistogramInfBucket(t *testing.T) {\n+\ttests := map[string]*dto.Histogram{\n+\t\t\"Histogram missing +Inf bucket\": {\n+\t\t\tBucket: []*dto.Bucket{\n+\t\t\t\t{CumulativeCount: p[uint64](5), UpperBound: p(1.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](10), UpperBound: p(5.0)},\n+\t\t\t},\n+\t\t\tSampleCount: p[uint64](15),\n+\t\t},\n+\t\t\"Histogram already has +Inf bucket\": {\n+\t\t\tBucket: []*dto.Bucket{\n+\t\t\t\t{CumulativeCount: p[uint64](5), UpperBound: p(1.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](10), UpperBound: p(5.0)},\n+\t\t\t\t{CumulativeCount: p[uint64](15), UpperBound: p(math.Inf(1))},\n+\t\t\t},\n+\t\t\tSampleCount: p[uint64](15),\n+\t\t},\n+\t}\n+\n+\tfor name, histogram := range tests {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\twr := &prompb.WriteRequest{}\n+\t\t\tlabels := map[string]string{\"__name__\": \"test_histogram\"}\n+\t\t\tmetric := &dto.Metric{\n+\t\t\t\tHistogram:   histogram,\n+\t\t\t\tTimestampMs: p(time.Now().UnixMilli()),\n+\t\t\t}\n+\n+\t\t\trequire.NoError(t, makeTimeseries(wr, labels, metric))\n+\n+\t\t\tvar hasInf bool",
        "comment_created_at": "2025-05-06T16:36:45+00:00",
        "comment_author": "clarkmcc",
        "comment_body": "I can't because `makeTimeseries` attaches the current time timestamps. I could use mock clocks, or come up with other ways to `require.Equal(...)` the output with expected output, but if the purpose of this test is just to make sure the `+Inf` value is present, the this is the fewest lines of code I can come up with to do that.\r\n\r\nThoughts?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060025574",
    "pr_number": 16462,
    "pr_file": "rules/manager_test.go",
    "created_at": "2025-04-25T11:01:37+00:00",
    "commented_code": "require.Equal(t, expected, mLabels, \"unexpected labelset\")\n }\n \n+func TestParseFile(t *testing.T) {\n+\t// Create a temporary directory for the test.\n+\ttmpDir := t.TempDir()\n+\n+\t// Define the test file path.\n+\ttestFile := filepath.Join(tmpDir, \"test_rules.yml\")\n+\n+\t// Define the content of the test YAML file.\n+\ttestContent := `\n+groups:\n+  - name: example\n+    rules:\n+      - alert: HighRequestLatency\n+        expr: job:request_latency_seconds:mean5m{job=\"myjob\"} > 0.5\n+        for: 10m\n+        labels:\n+          severity: warning\n+        annotations:\n+          summary: \"High request latency\"\n+`\n+\n+\t// Write the test content to the file.\n+\terr := os.WriteFile(testFile, []byte(testContent), 0o644)\n+\trequire.NoError(t, err)\n+\n+\t// Call the ParseFile function.\n+\tresult, err := ParseFile(testFile)\n+\trequire.NoError(t, err)\n+\n+\t// Assert that the result is not nil.\n+\trequire.NotNil(t, result, \"Expected parsed rules to be non-nil\")\n+\n+\t// Optionally, you can add more assertions to validate the structure of the parsed rules.\n+\t// For example, if you know the expected structure, you can cast `result` to the appropriate type\n+\t// and check its fields.\n+}",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2060025574",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16462,
        "pr_file": "rules/manager_test.go",
        "discussion_id": "2060025574",
        "commented_code": "@@ -2551,6 +2552,43 @@ func TestLabels_FromMaps(t *testing.T) {\n \trequire.Equal(t, expected, mLabels, \"unexpected labelset\")\n }\n \n+func TestParseFile(t *testing.T) {\n+\t// Create a temporary directory for the test.\n+\ttmpDir := t.TempDir()\n+\n+\t// Define the test file path.\n+\ttestFile := filepath.Join(tmpDir, \"test_rules.yml\")\n+\n+\t// Define the content of the test YAML file.\n+\ttestContent := `\n+groups:\n+  - name: example\n+    rules:\n+      - alert: HighRequestLatency\n+        expr: job:request_latency_seconds:mean5m{job=\"myjob\"} > 0.5\n+        for: 10m\n+        labels:\n+          severity: warning\n+        annotations:\n+          summary: \"High request latency\"\n+`\n+\n+\t// Write the test content to the file.\n+\terr := os.WriteFile(testFile, []byte(testContent), 0o644)\n+\trequire.NoError(t, err)\n+\n+\t// Call the ParseFile function.\n+\tresult, err := ParseFile(testFile)\n+\trequire.NoError(t, err)\n+\n+\t// Assert that the result is not nil.\n+\trequire.NotNil(t, result, \"Expected parsed rules to be non-nil\")\n+\n+\t// Optionally, you can add more assertions to validate the structure of the parsed rules.\n+\t// For example, if you know the expected structure, you can cast `result` to the appropriate type\n+\t// and check its fields.\n+}",
        "comment_created_at": "2025-04-25T11:01:37+00:00",
        "comment_author": "aknuds1",
        "comment_body": "This can be simplified as follows, even with an error case added. Note that the error case needs an extra file `invalid-rules.yaml` in rules/fixtures/.\r\n```suggestion\r\nfunc TestParseFiles(t *testing.T) {\r\n\tt.Run(\"good files\", func(t *testing.T) {\r\n\t\terr := ParseFiles([]string{filepath.Join(\"fixtures\", \"rules.y*ml\")})\r\n\t\trequire.NoError(t, err)\r\n\t})\r\n\r\n\tt.Run(\"bad files\", func(t *testing.T) {\r\n\t\terr := ParseFiles([]string{filepath.Join(\"fixtures\", \"invalid-rules.y*ml\")})\r\n\t\trequire.ErrorContains(t, err, \"field unexpected_field not found in type rulefmt.Rule\")\r\n\t})\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2183637896",
    "pr_number": 9589,
    "pr_file": "scrape/manager_test.go",
    "created_at": "2025-07-03T19:46:40+00:00",
    "commented_code": "}\n }\n \n+func TestManagerDuplicateAfterRelabellingWarning(t *testing.T) {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2183637896",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 9589,
        "pr_file": "scrape/manager_test.go",
        "discussion_id": "2183637896",
        "commented_code": "@@ -616,6 +617,75 @@ func TestManagerTargetsUpdates(t *testing.T) {\n \t}\n }\n \n+func TestManagerDuplicateAfterRelabellingWarning(t *testing.T) {",
        "comment_created_at": "2025-07-03T19:46:40+00:00",
        "comment_author": "machine424",
        "comment_body": "the test is still doing too many things/re-implementing some logic that we want to test.\r\n\r\n let's go with a higher level test like in https://github.com/machine424/prometheus/commit/678b94651fe8329b776443574295d524c96cd2ee, you can cherry-pick the whole commit.\r\n \r\n please double check as the test is mainly generated by an LLM (Claude Sonnet 4)\r\n \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2202516117",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 9589,
        "pr_file": "scrape/manager_test.go",
        "discussion_id": "2183637896",
        "commented_code": "@@ -616,6 +617,75 @@ func TestManagerTargetsUpdates(t *testing.T) {\n \t}\n }\n \n+func TestManagerDuplicateAfterRelabellingWarning(t *testing.T) {",
        "comment_created_at": "2025-07-12T11:10:23+00:00",
        "comment_author": "darshanime",
        "comment_body": "i cherry-picked the commit, but the test therein takes `~5s` to run, even after passing `\"--scrape.discovery-reload-interval=500ms\"` as an extra arg. on the other hand, in the test currently implemented, since we call `m.reload()` explicitly and get it finished in ~350ms reliably. \r\n\r\ni have refactored the test, can you check if it looks better now? else, i can cherry-pick 👍\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2215641244",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 9589,
        "pr_file": "scrape/manager_test.go",
        "discussion_id": "2183637896",
        "commented_code": "@@ -616,6 +617,75 @@ func TestManagerTargetsUpdates(t *testing.T) {\n \t}\n }\n \n+func TestManagerDuplicateAfterRelabellingWarning(t *testing.T) {",
        "comment_created_at": "2025-07-18T10:03:17+00:00",
        "comment_author": "machine424",
        "comment_body": "The test would probably run in parallel with others, so it's probably way shorter than 5s wall time.\r\n\r\nI think that for changes like this one it's simpler and safer to have high level tests when possible (we've been adding utils to make them easier to write.).\r\n\r\nLet's have that test and in another PR let's add a hidden `--discovery.update-interval` to allow customizing https://github.com/prometheus/prometheus/blob/46acc974c0ddaa16fd9fd092fed3dbc908caa94f/discovery/manager.go#L95 with both we can speed up the SD update loop.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1838577454",
    "pr_number": 15360,
    "pr_file": "scrape/manager_test.go",
    "created_at": "2024-11-12T18:24:38+00:00",
    "commented_code": "[]string{fmt.Sprintf(\"http://%s/metrics\", otherJobTargetURL)},\n \t)\n }\n+\n+func TestManagerStopAfterScrapeAttempt(t *testing.T) {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1838577454",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15360,
        "pr_file": "scrape/manager_test.go",
        "discussion_id": "1838577454",
        "commented_code": "@@ -1509,3 +1511,115 @@ scrape_configs:\n \t\t[]string{fmt.Sprintf(\"http://%s/metrics\", otherJobTargetURL)},\n \t)\n }\n+\n+func TestManagerStopAfterScrapeAttempt(t *testing.T) {",
        "comment_created_at": "2024-11-12T18:24:38+00:00",
        "comment_author": "ArthurSens",
        "comment_body": "Just a Nit, but would it make sense to split tests for initial scrape offset and scrape on shutdown?\r\n\r\nThey seem to be two separate features, not sure if it make sense to tie them together in a single test 🤔 ",
        "pr_file_module": null
      }
    ]
  }
]