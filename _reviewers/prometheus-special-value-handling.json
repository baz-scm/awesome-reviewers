[
  {
    "discussion_id": "2194758139",
    "pr_number": 16837,
    "pr_file": "docs/querying/operators.md",
    "created_at": "2025-07-09T11:19:35+00:00",
    "commented_code": "labels that are not listed in the `by` clause, even if their label values are\n identical between all elements of the vector.\n \n-`parameter` is only required for `topk`, `bottomk`, `limitk`, `limit_ratio`,\n-`quantile`, and `count_values`. It is used as the value for _k_, _r_, φ, or the\n-name of the additional label, respectively.\n-\n ### Detailed explanations\n \n-`sum` sums up sample values in the same way as the `+` binary operator does\n-between two values. Similarly, `avg` divides the sum by the number of\n-aggregated samples in the same way as the `/` binary operator. Therefore, all\n-sample values aggregation into a single resulting vector element must either be\n+#### `sum`\n+\n+`sum(v)` sums up sample values in `v` in the same way as the `+` binary operator does\n+between two values. \n+\n+All sample values aggregation into a single resulting vector element must either be\n float samples or histogram samples. An aggregation of a mix of both is invalid,\n-resulting in the removeal of the corresponding vector element from the output\n+resulting in the removal of the corresponding vector element from the output\n vector, flagged by a warn-level annotation.\n \n-`min` and `max` only operate on float samples, following IEEE 754 floating\n+##### Examples\n+\n+If the metric `http_requests_total` had time series that fan out by\n+`application`, `instance`, and `group` labels, we could calculate the total\n+number of seen HTTP requests per application and group over all instances via:\n+\n+    sum without (instance) (http_requests_total)\n+\n+Which is equivalent to:\n+\n+     sum by (application, group) (http_requests_total)\n+\n+If we are just interested in the total of HTTP requests we have seen in **all**\n+applications, we could simply write:\n+\n+    sum(http_requests_total)\n+\n+#### `avg`\n+\n+`avg(v)` divides the sum of `v` by the number of aggregated samples in the same way\n+as the `/` binary operator.\n+\n+All sample values aggregation into a single resulting vector element must either be\n+float samples or histogram samples. An aggregation of a mix of both is invalid,\n+resulting in the removal of the corresponding vector element from the output\n+vector, flagged by a warn-level annotation.\n+\n+#### `min` and `max`\n+\n+`min(v)` and `max(v)` return the minimum or maximum value, respectively, in `v`. \n+\n+They only operate on float samples, following IEEE 754 floating\n point arithmetic, which in particular implies that `NaN` is only ever\n considered a minimum or maximum if all aggregated values are `NaN`. Histogram\n samples in the input vector are ignored, flagged by an info-level annotation.\n \n-`topk` and `bottomk` are different from other aggregators in that a subset of\n-the input samples, including the original labels, are returned in the result\n-vector. `by` and `without` are only used to bucket the input vector. Similar to\n-`min` and `max`, they only operate on float samples, considering `NaN` values\n+#### `topk` and `bottomk`\n+\n+`topk(k, v)` and `bottomk(k, v)` are different from other aggregators in that a subset of\n+`k` values from the input samples, including the original labels, are returned in the result vector. \n+\n+`by` and `without` are only used to bucket the input vector. \n+\n+Similar to `min` and `max`, they only operate on float samples, considering `NaN` values\n to be farthest from the top or bottom, respectively. Histogram samples in the\n input vector are ignored, flagged by an info-level annotation.\n \n If used in an instant query, `topk` and `bottomk` return series ordered by\n value in descending or ascending order, respectively. If used with `by` or\n `without`, then series within each bucket are sorted by value, and series in\n the same bucket are returned consecutively, but there is no guarantee that\n-buckets of series will be returned in any particular order. No sorting applies\n-to range queries.\n-\n-`limitk` and `limit_ratio` also return a subset of the input samples, including\n-the original labels in the result vector. The subset is selected in a\n-deterministic pseudo-random way. `limitk` picks _k_ samples, while\n-`limit_ratio` picks a ratio _r_ of samples (each determined by `parameter`).\n-This happens independent of the sample type. Therefore, it works for both float\n-samples and histogram samples. _r_ can be between +1 and -1. The absolute value\n-of _r_ is used as the selection ratio, but the selection order is inverted for\n-a negative _r_, which can be used to select complements. For example,\n-`limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n+buckets of series will be returned in any particular order. \n+\n+No sorting applies to range queries.\n+\n+##### Example\n+\n+To get the 5 largest HTTP requests counts across all instances we could write:\n+\n+    topk(5, http_requests_total)\n+\n+#### `limitk` and `limit_ratio`\n+\n+`limitk(k, v)` returns a subset of `k` input samples, including\n+the original labels in the result vector. \n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type. \n+Therefore, it works for both float samples and histogram samples. \n+\n+##### Example\n+\n+To sample 10 timeseries, for example to inspect labels and their values, we\n+could write:\n+\n+    limitk(10, http_requests_total)\n+\n+#### `limit_ratio`\n+\n+`limit_ratio(r, v)` returns a subset of the input samples, including\n+the original labels in the result vector.\n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type.\n+Therefore, it works for both float samples and histogram samples.\n+\n+`r` can be between +1 and -1. The absolute value of `r` is used as the selection ratio,\n+but the selection order is inverted for a negative `r`, which can be used to select complements.\n+For example, `limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n the input samples, while `limit_ratio(-0.9, ...)` returns precisely the\n-remaining approximately 90% of the input samples not returned by\n-`limit_ratio(0.1, ...)`.\n+remaining approximately 90% of the input samples not returned by `limit_ratio(0.1, ...)`.\n \n-`group` and `count` do not interact with the sample values,\n-they work in the same way for float samples and histogram samples.\n+#### `group`\n+\n+`group(v)` returns 1 for each group that contains any value at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count`\n+\n+`count(v)` returns the number of values at that timestamp, or no value at all\n+if no values are present at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count_values`\n+\n+`count_values(l, v)` outputs one time series per unique sample value in `v`. \n+Each series has an additional label, given by `l`, and the label value is the \n+unique sample value. The value of each time series is the number of times that sample value was present.\n \n-`count_values` outputs one time series per unique sample value. Each series has\n-an additional label. The name of that label is given by the aggregation\n-parameter, and the label value is the unique sample value. The value of each\n-time series is the number of times that sample value was present.\n `count_values` works with both float samples and histogram samples. For the\n latter, a compact string representation of the histogram sample value is used\n as the label value.\n \n-`stddev` and `stdvar` only work with float samples, following IEEE 754 floating\n-point arithmetic. Histogram samples in the input vector are ignored, flagged by\n-an info-level annotation.\n-\n-`quantile` calculates the φ-quantile, the value that ranks at number φ*N among\n-the N metric values of the dimensions aggregated over. φ is provided as the\n-aggregation parameter. For example, `quantile(0.5, ...)` calculates the median,\n-`quantile(0.95, ...)` the 95th percentile. For φ = `NaN`, `NaN` is returned.\n-For φ < 0, `-Inf` is returned. For φ > 1, `+Inf` is returned.\n+##### Example\n \n-### Examples\n+To count the number of binaries running each build version we could write:\n \n-If the metric `http_requests_total` had time series that fan out by\n-`application`, `instance`, and `group` labels, we could calculate the total\n-number of seen HTTP requests per application and group over all instances via:\n+    count_values(\"version\", build_version)\n \n-    sum without (instance) (http_requests_total)\n+#### `stddev`\n \n-Which is equivalent to:\n+`stddev(v)` returns the standard deviation of `v`. \n \n-     sum by (application, group) (http_requests_total)\n+`stddev` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-If we are just interested in the total of HTTP requests we have seen in **all**\n-applications, we could simply write:\n+#### `stdvar`\n \n-    sum(http_requests_total)\n+`stdvar(v)` returns the standard deviation of `v`. \n \n-To count the number of binaries running each build version we could write:\n+`stdvar` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-    count_values(\"version\", build_version)\n+#### `quantile`\n \n-To get the 5 largest HTTP requests counts across all instances we could write:\n+`quantile(phi, v)` calculates the φ-quantile, the value that ranks at number φ*N among\n+the N metric values of the dimensions aggregated over.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2194758139",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16837,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2194758139",
        "commented_code": "@@ -318,102 +318,167 @@ all other labels are preserved in the output. `by` does the opposite and drops\n labels that are not listed in the `by` clause, even if their label values are\n identical between all elements of the vector.\n \n-`parameter` is only required for `topk`, `bottomk`, `limitk`, `limit_ratio`,\n-`quantile`, and `count_values`. It is used as the value for _k_, _r_, φ, or the\n-name of the additional label, respectively.\n-\n ### Detailed explanations\n \n-`sum` sums up sample values in the same way as the `+` binary operator does\n-between two values. Similarly, `avg` divides the sum by the number of\n-aggregated samples in the same way as the `/` binary operator. Therefore, all\n-sample values aggregation into a single resulting vector element must either be\n+#### `sum`\n+\n+`sum(v)` sums up sample values in `v` in the same way as the `+` binary operator does\n+between two values. \n+\n+All sample values aggregation into a single resulting vector element must either be\n float samples or histogram samples. An aggregation of a mix of both is invalid,\n-resulting in the removeal of the corresponding vector element from the output\n+resulting in the removal of the corresponding vector element from the output\n vector, flagged by a warn-level annotation.\n \n-`min` and `max` only operate on float samples, following IEEE 754 floating\n+##### Examples\n+\n+If the metric `http_requests_total` had time series that fan out by\n+`application`, `instance`, and `group` labels, we could calculate the total\n+number of seen HTTP requests per application and group over all instances via:\n+\n+    sum without (instance) (http_requests_total)\n+\n+Which is equivalent to:\n+\n+     sum by (application, group) (http_requests_total)\n+\n+If we are just interested in the total of HTTP requests we have seen in **all**\n+applications, we could simply write:\n+\n+    sum(http_requests_total)\n+\n+#### `avg`\n+\n+`avg(v)` divides the sum of `v` by the number of aggregated samples in the same way\n+as the `/` binary operator.\n+\n+All sample values aggregation into a single resulting vector element must either be\n+float samples or histogram samples. An aggregation of a mix of both is invalid,\n+resulting in the removal of the corresponding vector element from the output\n+vector, flagged by a warn-level annotation.\n+\n+#### `min` and `max`\n+\n+`min(v)` and `max(v)` return the minimum or maximum value, respectively, in `v`. \n+\n+They only operate on float samples, following IEEE 754 floating\n point arithmetic, which in particular implies that `NaN` is only ever\n considered a minimum or maximum if all aggregated values are `NaN`. Histogram\n samples in the input vector are ignored, flagged by an info-level annotation.\n \n-`topk` and `bottomk` are different from other aggregators in that a subset of\n-the input samples, including the original labels, are returned in the result\n-vector. `by` and `without` are only used to bucket the input vector. Similar to\n-`min` and `max`, they only operate on float samples, considering `NaN` values\n+#### `topk` and `bottomk`\n+\n+`topk(k, v)` and `bottomk(k, v)` are different from other aggregators in that a subset of\n+`k` values from the input samples, including the original labels, are returned in the result vector. \n+\n+`by` and `without` are only used to bucket the input vector. \n+\n+Similar to `min` and `max`, they only operate on float samples, considering `NaN` values\n to be farthest from the top or bottom, respectively. Histogram samples in the\n input vector are ignored, flagged by an info-level annotation.\n \n If used in an instant query, `topk` and `bottomk` return series ordered by\n value in descending or ascending order, respectively. If used with `by` or\n `without`, then series within each bucket are sorted by value, and series in\n the same bucket are returned consecutively, but there is no guarantee that\n-buckets of series will be returned in any particular order. No sorting applies\n-to range queries.\n-\n-`limitk` and `limit_ratio` also return a subset of the input samples, including\n-the original labels in the result vector. The subset is selected in a\n-deterministic pseudo-random way. `limitk` picks _k_ samples, while\n-`limit_ratio` picks a ratio _r_ of samples (each determined by `parameter`).\n-This happens independent of the sample type. Therefore, it works for both float\n-samples and histogram samples. _r_ can be between +1 and -1. The absolute value\n-of _r_ is used as the selection ratio, but the selection order is inverted for\n-a negative _r_, which can be used to select complements. For example,\n-`limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n+buckets of series will be returned in any particular order. \n+\n+No sorting applies to range queries.\n+\n+##### Example\n+\n+To get the 5 largest HTTP requests counts across all instances we could write:\n+\n+    topk(5, http_requests_total)\n+\n+#### `limitk` and `limit_ratio`\n+\n+`limitk(k, v)` returns a subset of `k` input samples, including\n+the original labels in the result vector. \n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type. \n+Therefore, it works for both float samples and histogram samples. \n+\n+##### Example\n+\n+To sample 10 timeseries, for example to inspect labels and their values, we\n+could write:\n+\n+    limitk(10, http_requests_total)\n+\n+#### `limit_ratio`\n+\n+`limit_ratio(r, v)` returns a subset of the input samples, including\n+the original labels in the result vector.\n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type.\n+Therefore, it works for both float samples and histogram samples.\n+\n+`r` can be between +1 and -1. The absolute value of `r` is used as the selection ratio,\n+but the selection order is inverted for a negative `r`, which can be used to select complements.\n+For example, `limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n the input samples, while `limit_ratio(-0.9, ...)` returns precisely the\n-remaining approximately 90% of the input samples not returned by\n-`limit_ratio(0.1, ...)`.\n+remaining approximately 90% of the input samples not returned by `limit_ratio(0.1, ...)`.\n \n-`group` and `count` do not interact with the sample values,\n-they work in the same way for float samples and histogram samples.\n+#### `group`\n+\n+`group(v)` returns 1 for each group that contains any value at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count`\n+\n+`count(v)` returns the number of values at that timestamp, or no value at all\n+if no values are present at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count_values`\n+\n+`count_values(l, v)` outputs one time series per unique sample value in `v`. \n+Each series has an additional label, given by `l`, and the label value is the \n+unique sample value. The value of each time series is the number of times that sample value was present.\n \n-`count_values` outputs one time series per unique sample value. Each series has\n-an additional label. The name of that label is given by the aggregation\n-parameter, and the label value is the unique sample value. The value of each\n-time series is the number of times that sample value was present.\n `count_values` works with both float samples and histogram samples. For the\n latter, a compact string representation of the histogram sample value is used\n as the label value.\n \n-`stddev` and `stdvar` only work with float samples, following IEEE 754 floating\n-point arithmetic. Histogram samples in the input vector are ignored, flagged by\n-an info-level annotation.\n-\n-`quantile` calculates the φ-quantile, the value that ranks at number φ*N among\n-the N metric values of the dimensions aggregated over. φ is provided as the\n-aggregation parameter. For example, `quantile(0.5, ...)` calculates the median,\n-`quantile(0.95, ...)` the 95th percentile. For φ = `NaN`, `NaN` is returned.\n-For φ < 0, `-Inf` is returned. For φ > 1, `+Inf` is returned.\n+##### Example\n \n-### Examples\n+To count the number of binaries running each build version we could write:\n \n-If the metric `http_requests_total` had time series that fan out by\n-`application`, `instance`, and `group` labels, we could calculate the total\n-number of seen HTTP requests per application and group over all instances via:\n+    count_values(\"version\", build_version)\n \n-    sum without (instance) (http_requests_total)\n+#### `stddev`\n \n-Which is equivalent to:\n+`stddev(v)` returns the standard deviation of `v`. \n \n-     sum by (application, group) (http_requests_total)\n+`stddev` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-If we are just interested in the total of HTTP requests we have seen in **all**\n-applications, we could simply write:\n+#### `stdvar`\n \n-    sum(http_requests_total)\n+`stdvar(v)` returns the standard deviation of `v`. \n \n-To count the number of binaries running each build version we could write:\n+`stdvar` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-    count_values(\"version\", build_version)\n+#### `quantile`\n \n-To get the 5 largest HTTP requests counts across all instances we could write:\n+`quantile(phi, v)` calculates the φ-quantile, the value that ranks at number φ*N among\n+the N metric values of the dimensions aggregated over.\n ",
        "comment_created_at": "2025-07-09T11:19:35+00:00",
        "comment_author": "beorn7",
        "comment_body": "```suggestion\r\n\r\n`quantile` only works with float samples. Histogram samples\r\nin the input vector are ignored, flagged by an info-level annotation.\r\n\r\n`NaN` is considered the smallest possible value.\r\n```\r\n\r\nThis was missing before, but needs to be added anyway. I realized that the `NaN` handling was not only undocumented, but also untested. See https://github.com/prometheus/prometheus/pull/16847 .",
        "pr_file_module": null
      },
      {
        "comment_id": "2196361682",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16837,
        "pr_file": "docs/querying/operators.md",
        "discussion_id": "2194758139",
        "commented_code": "@@ -318,102 +318,167 @@ all other labels are preserved in the output. `by` does the opposite and drops\n labels that are not listed in the `by` clause, even if their label values are\n identical between all elements of the vector.\n \n-`parameter` is only required for `topk`, `bottomk`, `limitk`, `limit_ratio`,\n-`quantile`, and `count_values`. It is used as the value for _k_, _r_, φ, or the\n-name of the additional label, respectively.\n-\n ### Detailed explanations\n \n-`sum` sums up sample values in the same way as the `+` binary operator does\n-between two values. Similarly, `avg` divides the sum by the number of\n-aggregated samples in the same way as the `/` binary operator. Therefore, all\n-sample values aggregation into a single resulting vector element must either be\n+#### `sum`\n+\n+`sum(v)` sums up sample values in `v` in the same way as the `+` binary operator does\n+between two values. \n+\n+All sample values aggregation into a single resulting vector element must either be\n float samples or histogram samples. An aggregation of a mix of both is invalid,\n-resulting in the removeal of the corresponding vector element from the output\n+resulting in the removal of the corresponding vector element from the output\n vector, flagged by a warn-level annotation.\n \n-`min` and `max` only operate on float samples, following IEEE 754 floating\n+##### Examples\n+\n+If the metric `http_requests_total` had time series that fan out by\n+`application`, `instance`, and `group` labels, we could calculate the total\n+number of seen HTTP requests per application and group over all instances via:\n+\n+    sum without (instance) (http_requests_total)\n+\n+Which is equivalent to:\n+\n+     sum by (application, group) (http_requests_total)\n+\n+If we are just interested in the total of HTTP requests we have seen in **all**\n+applications, we could simply write:\n+\n+    sum(http_requests_total)\n+\n+#### `avg`\n+\n+`avg(v)` divides the sum of `v` by the number of aggregated samples in the same way\n+as the `/` binary operator.\n+\n+All sample values aggregation into a single resulting vector element must either be\n+float samples or histogram samples. An aggregation of a mix of both is invalid,\n+resulting in the removal of the corresponding vector element from the output\n+vector, flagged by a warn-level annotation.\n+\n+#### `min` and `max`\n+\n+`min(v)` and `max(v)` return the minimum or maximum value, respectively, in `v`. \n+\n+They only operate on float samples, following IEEE 754 floating\n point arithmetic, which in particular implies that `NaN` is only ever\n considered a minimum or maximum if all aggregated values are `NaN`. Histogram\n samples in the input vector are ignored, flagged by an info-level annotation.\n \n-`topk` and `bottomk` are different from other aggregators in that a subset of\n-the input samples, including the original labels, are returned in the result\n-vector. `by` and `without` are only used to bucket the input vector. Similar to\n-`min` and `max`, they only operate on float samples, considering `NaN` values\n+#### `topk` and `bottomk`\n+\n+`topk(k, v)` and `bottomk(k, v)` are different from other aggregators in that a subset of\n+`k` values from the input samples, including the original labels, are returned in the result vector. \n+\n+`by` and `without` are only used to bucket the input vector. \n+\n+Similar to `min` and `max`, they only operate on float samples, considering `NaN` values\n to be farthest from the top or bottom, respectively. Histogram samples in the\n input vector are ignored, flagged by an info-level annotation.\n \n If used in an instant query, `topk` and `bottomk` return series ordered by\n value in descending or ascending order, respectively. If used with `by` or\n `without`, then series within each bucket are sorted by value, and series in\n the same bucket are returned consecutively, but there is no guarantee that\n-buckets of series will be returned in any particular order. No sorting applies\n-to range queries.\n-\n-`limitk` and `limit_ratio` also return a subset of the input samples, including\n-the original labels in the result vector. The subset is selected in a\n-deterministic pseudo-random way. `limitk` picks _k_ samples, while\n-`limit_ratio` picks a ratio _r_ of samples (each determined by `parameter`).\n-This happens independent of the sample type. Therefore, it works for both float\n-samples and histogram samples. _r_ can be between +1 and -1. The absolute value\n-of _r_ is used as the selection ratio, but the selection order is inverted for\n-a negative _r_, which can be used to select complements. For example,\n-`limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n+buckets of series will be returned in any particular order. \n+\n+No sorting applies to range queries.\n+\n+##### Example\n+\n+To get the 5 largest HTTP requests counts across all instances we could write:\n+\n+    topk(5, http_requests_total)\n+\n+#### `limitk` and `limit_ratio`\n+\n+`limitk(k, v)` returns a subset of `k` input samples, including\n+the original labels in the result vector. \n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type. \n+Therefore, it works for both float samples and histogram samples. \n+\n+##### Example\n+\n+To sample 10 timeseries, for example to inspect labels and their values, we\n+could write:\n+\n+    limitk(10, http_requests_total)\n+\n+#### `limit_ratio`\n+\n+`limit_ratio(r, v)` returns a subset of the input samples, including\n+the original labels in the result vector.\n+\n+The subset is selected in a deterministic pseudo-random way.\n+This happens independent of the sample type.\n+Therefore, it works for both float samples and histogram samples.\n+\n+`r` can be between +1 and -1. The absolute value of `r` is used as the selection ratio,\n+but the selection order is inverted for a negative `r`, which can be used to select complements.\n+For example, `limit_ratio(0.1, ...)` returns a deterministic set of approximatiely 10% of\n the input samples, while `limit_ratio(-0.9, ...)` returns precisely the\n-remaining approximately 90% of the input samples not returned by\n-`limit_ratio(0.1, ...)`.\n+remaining approximately 90% of the input samples not returned by `limit_ratio(0.1, ...)`.\n \n-`group` and `count` do not interact with the sample values,\n-they work in the same way for float samples and histogram samples.\n+#### `group`\n+\n+`group(v)` returns 1 for each group that contains any value at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count`\n+\n+`count(v)` returns the number of values at that timestamp, or no value at all\n+if no values are present at that timestamp.\n+\n+The value may be a float or histogram sample.\n+\n+#### `count_values`\n+\n+`count_values(l, v)` outputs one time series per unique sample value in `v`. \n+Each series has an additional label, given by `l`, and the label value is the \n+unique sample value. The value of each time series is the number of times that sample value was present.\n \n-`count_values` outputs one time series per unique sample value. Each series has\n-an additional label. The name of that label is given by the aggregation\n-parameter, and the label value is the unique sample value. The value of each\n-time series is the number of times that sample value was present.\n `count_values` works with both float samples and histogram samples. For the\n latter, a compact string representation of the histogram sample value is used\n as the label value.\n \n-`stddev` and `stdvar` only work with float samples, following IEEE 754 floating\n-point arithmetic. Histogram samples in the input vector are ignored, flagged by\n-an info-level annotation.\n-\n-`quantile` calculates the φ-quantile, the value that ranks at number φ*N among\n-the N metric values of the dimensions aggregated over. φ is provided as the\n-aggregation parameter. For example, `quantile(0.5, ...)` calculates the median,\n-`quantile(0.95, ...)` the 95th percentile. For φ = `NaN`, `NaN` is returned.\n-For φ < 0, `-Inf` is returned. For φ > 1, `+Inf` is returned.\n+##### Example\n \n-### Examples\n+To count the number of binaries running each build version we could write:\n \n-If the metric `http_requests_total` had time series that fan out by\n-`application`, `instance`, and `group` labels, we could calculate the total\n-number of seen HTTP requests per application and group over all instances via:\n+    count_values(\"version\", build_version)\n \n-    sum without (instance) (http_requests_total)\n+#### `stddev`\n \n-Which is equivalent to:\n+`stddev(v)` returns the standard deviation of `v`. \n \n-     sum by (application, group) (http_requests_total)\n+`stddev` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-If we are just interested in the total of HTTP requests we have seen in **all**\n-applications, we could simply write:\n+#### `stdvar`\n \n-    sum(http_requests_total)\n+`stdvar(v)` returns the standard deviation of `v`. \n \n-To count the number of binaries running each build version we could write:\n+`stdvar` only works with float samples, following IEEE 754 floating\n+point arithmetic. Histogram samples in the input vector are ignored, flagged by\n+an info-level annotation.\n \n-    count_values(\"version\", build_version)\n+#### `quantile`\n \n-To get the 5 largest HTTP requests counts across all instances we could write:\n+`quantile(phi, v)` calculates the φ-quantile, the value that ranks at number φ*N among\n+the N metric values of the dimensions aggregated over.\n ",
        "comment_created_at": "2025-07-10T02:22:21+00:00",
        "comment_author": "charleskorn",
        "comment_body": "Addressed in 95f7535.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154472572",
    "pr_number": 16724,
    "pr_file": "docs/querying/functions.md",
    "created_at": "2025-06-18T12:27:46+00:00",
    "commented_code": "resulting uncertainty, it becomes irrelevant if the boundaries are inclusive or\n exclusive.\n \n+Special case for native histograms:\n+\n+* If the native histogram with standard exponential buckets contains `NaN`\n+observations, these are considered outside any bucket. This means that\n+`histogram_fraction(-Inf, +Inf, b)` will be less than 1.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2154472572",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16724,
        "pr_file": "docs/querying/functions.md",
        "discussion_id": "2154472572",
        "commented_code": "@@ -293,6 +293,11 @@ boundaries, the function uses interpolation to estimate the fraction. With the\n resulting uncertainty, it becomes irrelevant if the boundaries are inclusive or\n exclusive.\n \n+Special case for native histograms:\n+\n+* If the native histogram with standard exponential buckets contains `NaN`\n+observations, these are considered outside any bucket. This means that\n+`histogram_fraction(-Inf, +Inf, b)` will be less than 1.",
        "comment_created_at": "2025-06-18T12:27:46+00:00",
        "comment_author": "beorn7",
        "comment_body": "Maybe don't give this special fringe case a whole itemized list (with just one item...). Idea to be more compact but add more explanation about the meaning of the returned value>\r\n\r\n```suggestion\r\nSpecial case for native histograms with standard exponential buckets:\r\n`NaN` observations are considered outside of any buckets in this case.  `histogram_fraction(-Inf, +Inf, b)` effectively\r\nreturns the fraction of non-`NaN` observations and may therefore be\r\nless than 1.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2158249646",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16724,
        "pr_file": "docs/querying/functions.md",
        "discussion_id": "2154472572",
        "commented_code": "@@ -293,6 +293,11 @@ boundaries, the function uses interpolation to estimate the fraction. With the\n resulting uncertainty, it becomes irrelevant if the boundaries are inclusive or\n exclusive.\n \n+Special case for native histograms:\n+\n+* If the native histogram with standard exponential buckets contains `NaN`\n+observations, these are considered outside any bucket. This means that\n+`histogram_fraction(-Inf, +Inf, b)` will be less than 1.",
        "comment_created_at": "2025-06-20T07:32:23+00:00",
        "comment_author": "krajorama",
        "comment_body": "copied in 82fb789c655ee0141a4ffaba5642b4c4b2d47efa",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066639787",
    "pr_number": 16517,
    "pr_file": "CHANGELOG.md",
    "created_at": "2025-04-29T14:13:57+00:00",
    "commented_code": "# Changelog\n \n-## unreleased\n+## 3.4.0-rc.0 / 2025-04-29\n \n * [CHANGE] Make setting out-of-order native histograms feature (`--enable-feature=ooo-native-histograms`) a no-op. Out-of-order native histograms are now always enabled when `out_of_order_time_window` is greater than zero and `--enable-feature=native-histograms` is set. #16207\n * [FEATURE] OTLP translate: Add feature flag for optionally translating OTel explicit bucket histograms into native histograms with custom buckets. #15850\n * [FEATURE] OTLP translate: Add option to receive OTLP metrics without translating names or attributes. #16441\n+* [FEATURE] Promltest: support to test expectation annotations. #15995\n+* [FEATURE] PromQL: allow arithmetic operations in durations in PromQL parser. #16249\n+* [FEATURE] OTLP: Add primitive support for ingesting OTLP delta metrics as-is. #16360\n+* [ENHANCEMENT] promql: histogram_fraction for bucket histograms. #16095\n * [ENHANCEMENT] TSDB: add `prometheus_tsdb_wal_replay_unknown_refs_total` and `prometheus_tsdb_wbl_replay_unknown_refs_total` metrics to track unknown series references during WAL/WBL replay. #16166\n-* [BUGFIX] TSDB: fix unknown series errors and possible lost data during WAL replay when series are removed from the head due to inactivity and reappear before the next WAL checkpoint. #16060\n+* [ENHANCEMENT] scrape: Add config option for escaping scheme request. #16066\n+* [ENHANCEMENT] nhcb: Add global config option for convert_classic_histograms_to_nhcb. #16226\n+* [ENHANCEMENT] ruler notifier: make batch size configurable (`--alertmanager.notification-batch-size`). #16254\n+* [PERF] Remote-write: re-use memory to read WAL data. #16197\n+* [PERF] discovery: make endpointSlice discovery more efficient. #16433\n+* [BUGFIX] Promqltest: Native histogram load expression with more than one incrementation. #16403\n+* [BUGFIX] failing to auto-reload on changes to rule and scrape config files. #16340\n+* [BUGFIX] skip native histogram series if ingestion is disabled. #16218\n+* [BUGFIX] Fix rules UI to display correct value for 'keepFiringFor'. #16211\n+* [BUGFIX] return NaN from `irate()` if second-last sample is NaN. #16199\n+* [BUGFIX] TSDB: Handle metadata/tombstones/exemplars for duplicate series during WAL replay. #16231\n+* [BUGFIX] TSDB: don't process exemplars older than minValidTime during WAL replay. #16242\n+* [BUGFIX] promtool: Add feature flags for promql features. #16443\n+* [BUGFIX] ruler: correct logging of alert name & template data. #15093\n+* [BUGFIX] promql: histogram_stddev and histogram_stdvar should use arithmetic mean. #16444",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2066639787",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16517,
        "pr_file": "CHANGELOG.md",
        "discussion_id": "2066639787",
        "commented_code": "@@ -1,12 +1,30 @@\n # Changelog\n \n-## unreleased\n+## 3.4.0-rc.0 / 2025-04-29\n \n * [CHANGE] Make setting out-of-order native histograms feature (`--enable-feature=ooo-native-histograms`) a no-op. Out-of-order native histograms are now always enabled when `out_of_order_time_window` is greater than zero and `--enable-feature=native-histograms` is set. #16207\n * [FEATURE] OTLP translate: Add feature flag for optionally translating OTel explicit bucket histograms into native histograms with custom buckets. #15850\n * [FEATURE] OTLP translate: Add option to receive OTLP metrics without translating names or attributes. #16441\n+* [FEATURE] Promltest: support to test expectation annotations. #15995\n+* [FEATURE] PromQL: allow arithmetic operations in durations in PromQL parser. #16249\n+* [FEATURE] OTLP: Add primitive support for ingesting OTLP delta metrics as-is. #16360\n+* [ENHANCEMENT] promql: histogram_fraction for bucket histograms. #16095\n * [ENHANCEMENT] TSDB: add `prometheus_tsdb_wal_replay_unknown_refs_total` and `prometheus_tsdb_wbl_replay_unknown_refs_total` metrics to track unknown series references during WAL/WBL replay. #16166\n-* [BUGFIX] TSDB: fix unknown series errors and possible lost data during WAL replay when series are removed from the head due to inactivity and reappear before the next WAL checkpoint. #16060\n+* [ENHANCEMENT] scrape: Add config option for escaping scheme request. #16066\n+* [ENHANCEMENT] nhcb: Add global config option for convert_classic_histograms_to_nhcb. #16226\n+* [ENHANCEMENT] ruler notifier: make batch size configurable (`--alertmanager.notification-batch-size`). #16254\n+* [PERF] Remote-write: re-use memory to read WAL data. #16197\n+* [PERF] discovery: make endpointSlice discovery more efficient. #16433\n+* [BUGFIX] Promqltest: Native histogram load expression with more than one incrementation. #16403\n+* [BUGFIX] failing to auto-reload on changes to rule and scrape config files. #16340\n+* [BUGFIX] skip native histogram series if ingestion is disabled. #16218\n+* [BUGFIX] Fix rules UI to display correct value for 'keepFiringFor'. #16211\n+* [BUGFIX] return NaN from `irate()` if second-last sample is NaN. #16199\n+* [BUGFIX] TSDB: Handle metadata/tombstones/exemplars for duplicate series during WAL replay. #16231\n+* [BUGFIX] TSDB: don't process exemplars older than minValidTime during WAL replay. #16242\n+* [BUGFIX] promtool: Add feature flags for promql features. #16443\n+* [BUGFIX] ruler: correct logging of alert name & template data. #15093\n+* [BUGFIX] promql: histogram_stddev and histogram_stdvar should use arithmetic mean. #16444",
        "comment_created_at": "2025-04-29T14:13:57+00:00",
        "comment_author": "machine424",
        "comment_body": "nit\r\n```suggestion\r\n* [BUGFIX] PromQL: histogram_stddev and histogram_stdvar should use arithmetic mean. #16444\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2068240201",
    "pr_number": 16517,
    "pr_file": "CHANGELOG.md",
    "created_at": "2025-04-30T09:16:51+00:00",
    "commented_code": "# Changelog\n \n-## unreleased\n+## 3.4.0-rc.0 / 2025-04-29\n \n-* [CHANGE] Make setting out-of-order native histograms feature (`--enable-feature=ooo-native-histograms`) a no-op. Out-of-order native histograms are now always enabled when `out_of_order_time_window` is greater than zero and `--enable-feature=native-histograms` is set. #16207\n+* [CHANGE] Config: Make setting out-of-order native histograms feature (`--enable-feature=ooo-native-histograms`) a no-op. Out-of-order native histograms are now always enabled when `out_of_order_time_window` is greater than zero and `--enable-feature=native-histograms` is set. #16207\n * [FEATURE] OTLP translate: Add feature flag for optionally translating OTel explicit bucket histograms into native histograms with custom buckets. #15850\n * [FEATURE] OTLP translate: Add option to receive OTLP metrics without translating names or attributes. #16441\n+* [FEATURE] PromQL: allow arithmetic operations in durations in PromQL parser. #16249\n+* [FEATURE] OTLP receiver: Add primitive support for ingesting OTLP delta metrics as-is. #16360\n+* [ENHANCEMENT] promql: histogram_fraction for bucket histograms. #16095\n * [ENHANCEMENT] TSDB: add `prometheus_tsdb_wal_replay_unknown_refs_total` and `prometheus_tsdb_wbl_replay_unknown_refs_total` metrics to track unknown series references during WAL/WBL replay. #16166\n-* [BUGFIX] TSDB: fix unknown series errors and possible lost data during WAL replay when series are removed from the head due to inactivity and reappear before the next WAL checkpoint. #16060\n+* [ENHANCEMENT] Scraping: Add config option for escaping scheme request. #16066\n+* [ENHANCEMENT] Config: Add global config option for convert_classic_histograms_to_nhcb. #16226\n+* [ENHANCEMENT] Alerting: make batch size configurable (`--alertmanager.notification-batch-size`). #16254\n+* [PERF] Kubernetes SD: make endpointSlice discovery more efficient. #16433\n+* [BUGFIX] Config: Fix auto-reload on changes to rule and scrape config files. #16340\n+* [BUGFIX] Scraping: Skip native histogram series if ingestion is disabled. #16218\n+* [BUGFIX] PromQL: return NaN from `irate()` if second-last sample is NaN. #16199\n+* [BUGFIX] TSDB: Handle metadata/tombstones/exemplars for duplicate series during WAL replay. #16231\n+* [BUGFIX] TSDB: don't process exemplars older than minValidTime during WAL replay. #16242\n+* [BUGFIX] promtool: Add feature flags for promql features. #16443\n+* [BUGFIX] Rules: correct logging of alert name & template data. #15093\n+* [BUGFIX] PromQL: histogram_stddev and histogram_stdvar should use arithmetic mean. #16444",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2068240201",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16517,
        "pr_file": "CHANGELOG.md",
        "discussion_id": "2068240201",
        "commented_code": "@@ -1,12 +1,26 @@\n # Changelog\n \n-## unreleased\n+## 3.4.0-rc.0 / 2025-04-29\n \n-* [CHANGE] Make setting out-of-order native histograms feature (`--enable-feature=ooo-native-histograms`) a no-op. Out-of-order native histograms are now always enabled when `out_of_order_time_window` is greater than zero and `--enable-feature=native-histograms` is set. #16207\n+* [CHANGE] Config: Make setting out-of-order native histograms feature (`--enable-feature=ooo-native-histograms`) a no-op. Out-of-order native histograms are now always enabled when `out_of_order_time_window` is greater than zero and `--enable-feature=native-histograms` is set. #16207\n * [FEATURE] OTLP translate: Add feature flag for optionally translating OTel explicit bucket histograms into native histograms with custom buckets. #15850\n * [FEATURE] OTLP translate: Add option to receive OTLP metrics without translating names or attributes. #16441\n+* [FEATURE] PromQL: allow arithmetic operations in durations in PromQL parser. #16249\n+* [FEATURE] OTLP receiver: Add primitive support for ingesting OTLP delta metrics as-is. #16360\n+* [ENHANCEMENT] promql: histogram_fraction for bucket histograms. #16095\n * [ENHANCEMENT] TSDB: add `prometheus_tsdb_wal_replay_unknown_refs_total` and `prometheus_tsdb_wbl_replay_unknown_refs_total` metrics to track unknown series references during WAL/WBL replay. #16166\n-* [BUGFIX] TSDB: fix unknown series errors and possible lost data during WAL replay when series are removed from the head due to inactivity and reappear before the next WAL checkpoint. #16060\n+* [ENHANCEMENT] Scraping: Add config option for escaping scheme request. #16066\n+* [ENHANCEMENT] Config: Add global config option for convert_classic_histograms_to_nhcb. #16226\n+* [ENHANCEMENT] Alerting: make batch size configurable (`--alertmanager.notification-batch-size`). #16254\n+* [PERF] Kubernetes SD: make endpointSlice discovery more efficient. #16433\n+* [BUGFIX] Config: Fix auto-reload on changes to rule and scrape config files. #16340\n+* [BUGFIX] Scraping: Skip native histogram series if ingestion is disabled. #16218\n+* [BUGFIX] PromQL: return NaN from `irate()` if second-last sample is NaN. #16199\n+* [BUGFIX] TSDB: Handle metadata/tombstones/exemplars for duplicate series during WAL replay. #16231\n+* [BUGFIX] TSDB: don't process exemplars older than minValidTime during WAL replay. #16242\n+* [BUGFIX] promtool: Add feature flags for promql features. #16443\n+* [BUGFIX] Rules: correct logging of alert name & template data. #15093\n+* [BUGFIX] PromQL: histogram_stddev and histogram_stdvar should use arithmetic mean. #16444",
        "comment_created_at": "2025-04-30T09:16:51+00:00",
        "comment_author": "machine424",
        "comment_body": "```suggestion\r\n* [BUGFIX] PromQL: Use arithmetic mean for `histogram_stddev()` and `histogram_stdvar()` . #16444\r\n```",
        "pr_file_module": null
      }
    ]
  }
]