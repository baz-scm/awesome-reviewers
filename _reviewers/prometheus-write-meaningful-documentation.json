[
  {
    "discussion_id": "2076429139",
    "pr_number": 15809,
    "pr_file": "storage/remote/storage.go",
    "created_at": "2025-05-06T22:24:24+00:00",
    "commented_code": "// NewStorage returns a remote.Storage.\n func NewStorage(l *slog.Logger, reg prometheus.Registerer, stCallback startTimeCallback, walDir string, flushDeadline time.Duration, sm ReadyScrapeManager) *Storage {\n+\t// register remote storage metrics in\tcustom registry",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2076429139",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/storage.go",
        "discussion_id": "2076429139",
        "commented_code": "@@ -65,12 +65,16 @@ type Storage struct {\n \n // NewStorage returns a remote.Storage.\n func NewStorage(l *slog.Logger, reg prometheus.Registerer, stCallback startTimeCallback, walDir string, flushDeadline time.Duration, sm ReadyScrapeManager) *Storage {\n+\t// register remote storage metrics in\tcustom registry",
        "comment_created_at": "2025-05-06T22:24:24+00:00",
        "comment_author": "beorn7",
        "comment_body": "```suggestion\r\n\t// Register remote storage metrics in custom registry.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2076429719",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 15809,
        "pr_file": "storage/remote/storage.go",
        "discussion_id": "2076429139",
        "commented_code": "@@ -65,12 +65,16 @@ type Storage struct {\n \n // NewStorage returns a remote.Storage.\n func NewStorage(l *slog.Logger, reg prometheus.Registerer, stCallback startTimeCallback, walDir string, flushDeadline time.Duration, sm ReadyScrapeManager) *Storage {\n+\t// register remote storage metrics in\tcustom registry",
        "comment_created_at": "2025-05-06T22:24:59+00:00",
        "comment_author": "beorn7",
        "comment_body": "But maybe this comment is not needed at all. It just spells out what the code is clearly doing. No reason to explain the code here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140415000",
    "pr_number": 16522,
    "pr_file": "cmd/promtool/main.go",
    "created_at": "2025-06-11T14:53:48+00:00",
    "commented_code": "lintConfigOptions = append(append([]string{}, lintRulesOptions...), lintOptionTooLongScrapeInterval)\n )\n \n+const httpConfigFileDescription = \"HTTP client configuration file for promtool to connect to Prometheus.\" + \" \" +\n+\t\"For more information, please visit the following page: https://prometheus.io/docs/prometheus/latest/configuration/promtool\"",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2140415000",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16522,
        "pr_file": "cmd/promtool/main.go",
        "discussion_id": "2140415000",
        "commented_code": "@@ -89,6 +89,9 @@ var (\n \tlintConfigOptions = append(append([]string{}, lintRulesOptions...), lintOptionTooLongScrapeInterval)\n )\n \n+const httpConfigFileDescription = \"HTTP client configuration file for promtool to connect to Prometheus.\" + \" \" +\n+\t\"For more information, please visit the following page: https://prometheus.io/docs/prometheus/latest/configuration/promtool\"",
        "comment_created_at": "2025-06-11T14:53:48+00:00",
        "comment_author": "beorn7",
        "comment_body": "I think this is the right approach in general, but let's be a bit more compact here. (We don't need to mention that this is for promtool, and neither that we are talking to Prometheus, and we don't have to say \"please\" here, this is supposed to be short command line help.) And no need for additional line breaks here. How about this:\r\n```suggestion\r\nconst httpConfigFileDescription = \"HTTP client configuration file, see details at https://prometheus.io/docs/prometheus/latest/configuration/promtool\"\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140628128",
    "pr_number": 16630,
    "pr_file": "storage/remote/otlptranslator/prometheusremotewrite/helper.go",
    "created_at": "2025-06-11T16:31:51+00:00",
    "commented_code": "return labels\n }\n \n+// addTypeAndUnitLabels appends type and unit labels to the given labels slice if the setting is enabled.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2140628128",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16630,
        "pr_file": "storage/remote/otlptranslator/prometheusremotewrite/helper.go",
        "discussion_id": "2140628128",
        "commented_code": "@@ -518,6 +527,14 @@ func createLabels(name string, baseLabels []prompb.Label, extras ...string) []pr\n \treturn labels\n }\n \n+// addTypeAndUnitLabels appends type and unit labels to the given labels slice if the setting is enabled.",
        "comment_created_at": "2025-06-11T16:31:51+00:00",
        "comment_author": "aknuds1",
        "comment_body": "\"if the setting is enabled\" isn't the case, because this function doesn't check the setting:\r\n```suggestion\r\n// addTypeAndUnitLabels appends type and unit labels to the given labels slice.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1506297926",
    "pr_number": 13506,
    "pr_file": "model/textparse/interface.go",
    "created_at": "2024-02-28T17:04:44+00:00",
    "commented_code": "//\n // This function always returns a valid parser, but might additionally\n // return an error if the content type cannot be parsed.\n-func New(b []byte, contentType string, parseClassicHistograms bool) (Parser, error) {\n+func New(b []byte, contentType string, parseClassicHistograms bool) (Parser, string, error) {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "1506297926",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 13506,
        "pr_file": "model/textparse/interface.go",
        "discussion_id": "1506297926",
        "commented_code": "@@ -80,22 +80,22 @@ type Parser interface {\n //\n // This function always returns a valid parser, but might additionally\n // return an error if the content type cannot be parsed.\n-func New(b []byte, contentType string, parseClassicHistograms bool) (Parser, error) {\n+func New(b []byte, contentType string, parseClassicHistograms bool) (Parser, string, error) {",
        "comment_created_at": "2024-02-28T17:04:44+00:00",
        "comment_author": "bboreham",
        "comment_body": "Mention new return value in documentation comment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077452834",
    "pr_number": 16562,
    "pr_file": "promql/promqltest/test.go",
    "created_at": "2025-05-07T11:51:06+00:00",
    "commented_code": "func durationMilliseconds(d time.Duration) int64 {\n \treturn int64(d / (time.Millisecond / time.Nanosecond))\n }\n+\n+func MigrateTestData(mode string) error {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2077452834",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16562,
        "pr_file": "promql/promqltest/test.go",
        "discussion_id": "2077452834",
        "commented_code": "@@ -1651,3 +1653,107 @@ func timeMilliseconds(t time.Time) int64 {\n func durationMilliseconds(d time.Duration) int64 {\n \treturn int64(d / (time.Millisecond / time.Nanosecond))\n }\n+\n+func MigrateTestData(mode string) error {",
        "comment_created_at": "2025-05-07T11:51:06+00:00",
        "comment_author": "beorn7",
        "comment_body": "This should have a doc comment, explaining what it is doing and what for it is needed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2077454800",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16562,
        "pr_file": "promql/promqltest/test.go",
        "discussion_id": "2077452834",
        "commented_code": "@@ -1651,3 +1653,107 @@ func timeMilliseconds(t time.Time) int64 {\n func durationMilliseconds(d time.Duration) int64 {\n \treturn int64(d / (time.Millisecond / time.Nanosecond))\n }\n+\n+func MigrateTestData(mode string) error {",
        "comment_created_at": "2025-05-07T11:52:17+00:00",
        "comment_author": "beorn7",
        "comment_body": "Nit: `mode` should be just a boolean, e.g. `strictConversion bool` (unless we introduce a third mode (see below) in which case this should be an enum (or whatever Go calls an enum\u2026)).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2130033891",
    "pr_number": 16686,
    "pr_file": "promql/histogram_stats_iterator.go",
    "created_at": "2025-06-05T19:35:40+00:00",
    "commented_code": "\"github.com/prometheus/prometheus/tsdb/chunkenc\"\n )\n \n-type histogramStatsIterator struct {\n+type HistogramStatsIterator struct {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2130033891",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16686,
        "pr_file": "promql/histogram_stats_iterator.go",
        "discussion_id": "2130033891",
        "commented_code": "@@ -19,32 +19,39 @@ import (\n \t\"github.com/prometheus/prometheus/tsdb/chunkenc\"\n )\n \n-type histogramStatsIterator struct {\n+type HistogramStatsIterator struct {",
        "comment_created_at": "2025-06-05T19:35:40+00:00",
        "comment_author": "beorn7",
        "comment_body": "Now that this is exported, better give it a meaningful doc comment. I would probably recycle most of the stuff that was used for `NewHistogramStatsIterator` below and make the latter much shorter.",
        "pr_file_module": null
      },
      {
        "comment_id": "2139107559",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16686,
        "pr_file": "promql/histogram_stats_iterator.go",
        "discussion_id": "2130033891",
        "commented_code": "@@ -19,32 +19,39 @@ import (\n \t\"github.com/prometheus/prometheus/tsdb/chunkenc\"\n )\n \n-type histogramStatsIterator struct {\n+type HistogramStatsIterator struct {",
        "comment_created_at": "2025-06-11T03:07:07+00:00",
        "comment_author": "charleskorn",
        "comment_body": "Done in 1141530.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066838153",
    "pr_number": 16462,
    "pr_file": "cmd/prometheus/main.go",
    "created_at": "2025-04-29T15:33:32+00:00",
    "commented_code": "logger.Error(fmt.Sprintf(\"Error loading dynamic scrape config files from config (--config.file=%q)\", cfg.configFile), \"file\", absPath, \"err\", err)\n \t\tos.Exit(2)\n \t}\n+\n+\t// This section of the code is responsible for validating and parsing rule files\n+\t// specified in the Prometheus configuration. It ensures that all rule files\n+\t// match the provided patterns and are syntactically correct before Prometheus\n+\t// starts processing them.\n+\t// 1. Iterate through the list of rule file patterns specified in the configuration (`cfgFile.RuleFiles`).\n+\t// 2. Use `filepath.Glob` to expand each pattern into a list of matching files.\n+\t// 3. If an error occurs during pattern expansion, log the error, resolve the absolute path of the pattern, and exit with an error code.\n+\t// 4. For each matching file, attempt to parse it using `rules.ParseFile`.\n+\t// 5. If parsing fails, log the error, resolve the absolute path of the file, and exit with an error code.\n+\t//\n+\t// Errors are logged with details such as the configuration file path, the rule file pattern, and the specific error encountered.",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2066838153",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16462,
        "pr_file": "cmd/prometheus/main.go",
        "discussion_id": "2066838153",
        "commented_code": "@@ -641,6 +641,43 @@ func main() {\n \t\tlogger.Error(fmt.Sprintf(\"Error loading dynamic scrape config files from config (--config.file=%q)\", cfg.configFile), \"file\", absPath, \"err\", err)\n \t\tos.Exit(2)\n \t}\n+\n+\t// This section of the code is responsible for validating and parsing rule files\n+\t// specified in the Prometheus configuration. It ensures that all rule files\n+\t// match the provided patterns and are syntactically correct before Prometheus\n+\t// starts processing them.\n+\t// 1. Iterate through the list of rule file patterns specified in the configuration (`cfgFile.RuleFiles`).\n+\t// 2. Use `filepath.Glob` to expand each pattern into a list of matching files.\n+\t// 3. If an error occurs during pattern expansion, log the error, resolve the absolute path of the pattern, and exit with an error code.\n+\t// 4. For each matching file, attempt to parse it using `rules.ParseFile`.\n+\t// 5. If parsing fails, log the error, resolve the absolute path of the file, and exit with an error code.\n+\t//\n+\t// Errors are logged with details such as the configuration file path, the rule file pattern, and the specific error encountered.",
        "comment_created_at": "2025-04-29T15:33:32+00:00",
        "comment_author": "beorn7",
        "comment_body": "While I like readable comments in proper English, this one is a bit too verbose.\r\n\r\nA general good advice is that code should not be an English version of the Go code. You can assume that the reader of your code knows Go well (maybe even better than English ;).\r\n\r\nIf you move the code below into a function `rules.ParseFiles`, your comment here can be its doc comment, but it should still focus more on _what_ the function does rather than _how_.",
        "pr_file_module": null
      },
      {
        "comment_id": "2067986490",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16462,
        "pr_file": "cmd/prometheus/main.go",
        "discussion_id": "2066838153",
        "commented_code": "@@ -641,6 +641,43 @@ func main() {\n \t\tlogger.Error(fmt.Sprintf(\"Error loading dynamic scrape config files from config (--config.file=%q)\", cfg.configFile), \"file\", absPath, \"err\", err)\n \t\tos.Exit(2)\n \t}\n+\n+\t// This section of the code is responsible for validating and parsing rule files\n+\t// specified in the Prometheus configuration. It ensures that all rule files\n+\t// match the provided patterns and are syntactically correct before Prometheus\n+\t// starts processing them.\n+\t// 1. Iterate through the list of rule file patterns specified in the configuration (`cfgFile.RuleFiles`).\n+\t// 2. Use `filepath.Glob` to expand each pattern into a list of matching files.\n+\t// 3. If an error occurs during pattern expansion, log the error, resolve the absolute path of the pattern, and exit with an error code.\n+\t// 4. For each matching file, attempt to parse it using `rules.ParseFile`.\n+\t// 5. If parsing fails, log the error, resolve the absolute path of the file, and exit with an error code.\n+\t//\n+\t// Errors are logged with details such as the configuration file path, the rule file pattern, and the specific error encountered.",
        "comment_created_at": "2025-04-30T07:03:56+00:00",
        "comment_author": "marcodebba",
        "comment_body": "Thanks for suggestions @beorn7  . I'll try to fix  everything today",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2082399373",
    "pr_number": 16404,
    "pr_file": "promql/value.go",
    "created_at": "2025-05-09T19:41:59+00:00",
    "commented_code": "func (ssi *storageSeriesIterator) Err() error {\n \treturn nil\n }\n+\n+type fParams struct {\n+\tseries     Series\n+\tconstValue float64\n+\tisConstant bool\n+\tminValue   float64\n+\tmaxValue   float64\n+\thasAnyNaN  bool\n+}\n+\n+// newFParams evaluates the expression and returns an fParams object,\n+// which holds the parameter values (constant or series) along with min, max, and NaN info.\n+func newFParams(ctx context.Context, ev *evaluator, expr parser.Expr) (*fParams, annotations.Annotations) {\n+\tif expr == nil {\n+\t\treturn &fParams{}, nil\n+\t}\n+\tvar constParam bool\n+\tif _, ok := expr.(*parser.NumberLiteral); ok {\n+\t\tconstParam = true\n+\t}\n+\tval, ws := ev.eval(ctx, expr)\n+\tmat, ok := val.(Matrix)\n+\tif !ok || len(mat) == 0 {\n+\t\treturn &fParams{}, ws\n+\t}\n+\tfp := &fParams{\n+\t\tseries:     mat[0],\n+\t\tisConstant: constParam,\n+\t\tminValue:   math.MaxFloat64,\n+\t\tmaxValue:   -math.MaxFloat64,\n+\t}\n+\n+\tif constParam {\n+\t\tfp.constValue = fp.series.Floats[0].F\n+\t\tfp.minValue, fp.maxValue = fp.constValue, fp.constValue\n+\t\tfp.hasAnyNaN = math.IsNaN(fp.constValue)\n+\t\treturn fp, ws\n+\t}\n+\n+\tfor _, v := range fp.series.Floats {\n+\t\tfp.maxValue = math.Max(fp.maxValue, v.F)\n+\t\tfp.minValue = math.Min(fp.minValue, v.F)\n+\t\tif math.IsNaN(v.F) {\n+\t\t\tfp.hasAnyNaN = true\n+\t\t}\n+\t}\n+\treturn fp, ws\n+}\n+\n+func (fp *fParams) Max() float64    { return fp.maxValue }\n+func (fp *fParams) Min() float64    { return fp.minValue }\n+func (fp *fParams) HasAnyNaN() bool { return fp.hasAnyNaN }\n+\n+func (fp *fParams) Next(ts int64) float64 {",
    "repo_full_name": "prometheus/prometheus",
    "discussion_comments": [
      {
        "comment_id": "2082399373",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16404,
        "pr_file": "promql/value.go",
        "discussion_id": "2082399373",
        "commented_code": "@@ -533,3 +534,67 @@ func (ssi *storageSeriesIterator) Next() chunkenc.ValueType {\n func (ssi *storageSeriesIterator) Err() error {\n \treturn nil\n }\n+\n+type fParams struct {\n+\tseries     Series\n+\tconstValue float64\n+\tisConstant bool\n+\tminValue   float64\n+\tmaxValue   float64\n+\thasAnyNaN  bool\n+}\n+\n+// newFParams evaluates the expression and returns an fParams object,\n+// which holds the parameter values (constant or series) along with min, max, and NaN info.\n+func newFParams(ctx context.Context, ev *evaluator, expr parser.Expr) (*fParams, annotations.Annotations) {\n+\tif expr == nil {\n+\t\treturn &fParams{}, nil\n+\t}\n+\tvar constParam bool\n+\tif _, ok := expr.(*parser.NumberLiteral); ok {\n+\t\tconstParam = true\n+\t}\n+\tval, ws := ev.eval(ctx, expr)\n+\tmat, ok := val.(Matrix)\n+\tif !ok || len(mat) == 0 {\n+\t\treturn &fParams{}, ws\n+\t}\n+\tfp := &fParams{\n+\t\tseries:     mat[0],\n+\t\tisConstant: constParam,\n+\t\tminValue:   math.MaxFloat64,\n+\t\tmaxValue:   -math.MaxFloat64,\n+\t}\n+\n+\tif constParam {\n+\t\tfp.constValue = fp.series.Floats[0].F\n+\t\tfp.minValue, fp.maxValue = fp.constValue, fp.constValue\n+\t\tfp.hasAnyNaN = math.IsNaN(fp.constValue)\n+\t\treturn fp, ws\n+\t}\n+\n+\tfor _, v := range fp.series.Floats {\n+\t\tfp.maxValue = math.Max(fp.maxValue, v.F)\n+\t\tfp.minValue = math.Min(fp.minValue, v.F)\n+\t\tif math.IsNaN(v.F) {\n+\t\t\tfp.hasAnyNaN = true\n+\t\t}\n+\t}\n+\treturn fp, ws\n+}\n+\n+func (fp *fParams) Max() float64    { return fp.maxValue }\n+func (fp *fParams) Min() float64    { return fp.minValue }\n+func (fp *fParams) HasAnyNaN() bool { return fp.hasAnyNaN }\n+\n+func (fp *fParams) Next(ts int64) float64 {",
        "comment_created_at": "2025-05-09T19:41:59+00:00",
        "comment_author": "beorn7",
        "comment_body": "I think this is obscure enough to deserve a doc comment.\r\n\r\nCurrently, I don't understand the logic that checks `ts`. If it doesn't match, the method returns 0, but how does that help me? 0 could as well be the actual value \u2013 how do I know that the `ts` did not match?",
        "pr_file_module": null
      },
      {
        "comment_id": "2083118341",
        "repo_full_name": "prometheus/prometheus",
        "pr_number": 16404,
        "pr_file": "promql/value.go",
        "discussion_id": "2082399373",
        "commented_code": "@@ -533,3 +534,67 @@ func (ssi *storageSeriesIterator) Next() chunkenc.ValueType {\n func (ssi *storageSeriesIterator) Err() error {\n \treturn nil\n }\n+\n+type fParams struct {\n+\tseries     Series\n+\tconstValue float64\n+\tisConstant bool\n+\tminValue   float64\n+\tmaxValue   float64\n+\thasAnyNaN  bool\n+}\n+\n+// newFParams evaluates the expression and returns an fParams object,\n+// which holds the parameter values (constant or series) along with min, max, and NaN info.\n+func newFParams(ctx context.Context, ev *evaluator, expr parser.Expr) (*fParams, annotations.Annotations) {\n+\tif expr == nil {\n+\t\treturn &fParams{}, nil\n+\t}\n+\tvar constParam bool\n+\tif _, ok := expr.(*parser.NumberLiteral); ok {\n+\t\tconstParam = true\n+\t}\n+\tval, ws := ev.eval(ctx, expr)\n+\tmat, ok := val.(Matrix)\n+\tif !ok || len(mat) == 0 {\n+\t\treturn &fParams{}, ws\n+\t}\n+\tfp := &fParams{\n+\t\tseries:     mat[0],\n+\t\tisConstant: constParam,\n+\t\tminValue:   math.MaxFloat64,\n+\t\tmaxValue:   -math.MaxFloat64,\n+\t}\n+\n+\tif constParam {\n+\t\tfp.constValue = fp.series.Floats[0].F\n+\t\tfp.minValue, fp.maxValue = fp.constValue, fp.constValue\n+\t\tfp.hasAnyNaN = math.IsNaN(fp.constValue)\n+\t\treturn fp, ws\n+\t}\n+\n+\tfor _, v := range fp.series.Floats {\n+\t\tfp.maxValue = math.Max(fp.maxValue, v.F)\n+\t\tfp.minValue = math.Min(fp.minValue, v.F)\n+\t\tif math.IsNaN(v.F) {\n+\t\t\tfp.hasAnyNaN = true\n+\t\t}\n+\t}\n+\treturn fp, ws\n+}\n+\n+func (fp *fParams) Max() float64    { return fp.maxValue }\n+func (fp *fParams) Min() float64    { return fp.minValue }\n+func (fp *fParams) HasAnyNaN() bool { return fp.hasAnyNaN }\n+\n+func (fp *fParams) Next(ts int64) float64 {",
        "comment_created_at": "2025-05-10T11:28:21+00:00",
        "comment_author": "NeerajGartia21",
        "comment_body": "No need to check `ts` here. I'll remove it. I initially added it for consistency with `ev.nextValues`, but there it's used differently (to distinguish between float and histogram as the next sample). I'll also add doc comments for clarity.\r\n",
        "pr_file_module": null
      }
    ]
  }
]