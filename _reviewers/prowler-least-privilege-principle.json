[
  {
    "discussion_id": "1954697561",
    "pr_number": 6906,
    "pr_file": "api/src/backend/config/settings/social_login.py",
    "created_at": "2025-02-13T15:09:43+00:00",
    "commented_code": "+from config.env import env\n+\n+# Google Oauth settings\n+GOOGLE_OAUTH_CLIENT_ID = env(\"DJANGO_GOOGLE_OAUTH_CLIENT_ID\", default=\"\")\n+GOOGLE_OAUTH_CLIENT_SECRET = env(\"DJANGO_GOOGLE_OAUTH_CLIENT_SECRET\", default=\"\")\n+GOOGLE_OAUTH_CALLBACK_URL = env(\"DJANGO_GOOGLE_OAUTH_CALLBACK_URL\", default=\"\")\n+\n+GITHUB_OAUTH_CLIENT_ID = env(\"DJANGO_GITHUB_OAUTH_CLIENT_ID\", default=\"\")\n+GITHUB_OAUTH_CLIENT_SECRET = env(\"DJANGO_GITHUB_OAUTH_CLIENT_SECRET\", default=\"\")\n+GITHUB_OAUTH_CALLBACK_URL = env(\"DJANGO_GITHUB_OAUTH_CALLBACK_URL\", default=\"\")\n+\n+# Allauth settings\n+ACCOUNT_LOGIN_METHODS = {\"email\"}  # Use Email / Password authentication\n+ACCOUNT_USERNAME_REQUIRED = False\n+ACCOUNT_EMAIL_REQUIRED = True\n+ACCOUNT_EMAIL_VERIFICATION = \"none\"  # Do not require email confirmation\n+ACCOUNT_USER_MODEL_USERNAME_FIELD = None\n+REST_AUTH = {\n+    \"TOKEN_MODEL\": None,\n+    \"REST_USE_JWT\": True,\n+}\n+# django-allauth (social)\n+# Authenticate if local account with this email address already exists\n+SOCIALACCOUNT_EMAIL_AUTHENTICATION = True\n+# Connect local account and social account if local account with that email address already exists\n+SOCIALACCOUNT_EMAIL_AUTHENTICATION_AUTO_CONNECT = True\n+SOCIALACCOUNT_ADAPTER = \"api.adapters.ProwlerSocialAccountAdapter\"\n+SOCIALACCOUNT_PROVIDERS = {\n+    \"google\": {\n+        \"APP\": {\n+            \"client_id\": GOOGLE_OAUTH_CLIENT_ID,\n+            \"secret\": GOOGLE_OAUTH_CLIENT_SECRET,\n+            \"key\": \"\",\n+        },\n+        \"SCOPE\": [\n+            \"email\",\n+            \"profile\",\n+        ],\n+        \"AUTH_PARAMS\": {\n+            \"access_type\": \"online\",\n+        },\n+    },\n+    \"github\": {\n+        \"APP\": {\n+            \"client_id\": GITHUB_OAUTH_CLIENT_ID,\n+            \"secret\": GITHUB_OAUTH_CLIENT_SECRET,\n+        },\n+        \"SCOPE\": [\n+            \"user\",\n+            \"repo\",",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "1954697561",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 6906,
        "pr_file": "api/src/backend/config/settings/social_login.py",
        "discussion_id": "1954697561",
        "commented_code": "@@ -0,0 +1,54 @@\n+from config.env import env\n+\n+# Google Oauth settings\n+GOOGLE_OAUTH_CLIENT_ID = env(\"DJANGO_GOOGLE_OAUTH_CLIENT_ID\", default=\"\")\n+GOOGLE_OAUTH_CLIENT_SECRET = env(\"DJANGO_GOOGLE_OAUTH_CLIENT_SECRET\", default=\"\")\n+GOOGLE_OAUTH_CALLBACK_URL = env(\"DJANGO_GOOGLE_OAUTH_CALLBACK_URL\", default=\"\")\n+\n+GITHUB_OAUTH_CLIENT_ID = env(\"DJANGO_GITHUB_OAUTH_CLIENT_ID\", default=\"\")\n+GITHUB_OAUTH_CLIENT_SECRET = env(\"DJANGO_GITHUB_OAUTH_CLIENT_SECRET\", default=\"\")\n+GITHUB_OAUTH_CALLBACK_URL = env(\"DJANGO_GITHUB_OAUTH_CALLBACK_URL\", default=\"\")\n+\n+# Allauth settings\n+ACCOUNT_LOGIN_METHODS = {\"email\"}  # Use Email / Password authentication\n+ACCOUNT_USERNAME_REQUIRED = False\n+ACCOUNT_EMAIL_REQUIRED = True\n+ACCOUNT_EMAIL_VERIFICATION = \"none\"  # Do not require email confirmation\n+ACCOUNT_USER_MODEL_USERNAME_FIELD = None\n+REST_AUTH = {\n+    \"TOKEN_MODEL\": None,\n+    \"REST_USE_JWT\": True,\n+}\n+# django-allauth (social)\n+# Authenticate if local account with this email address already exists\n+SOCIALACCOUNT_EMAIL_AUTHENTICATION = True\n+# Connect local account and social account if local account with that email address already exists\n+SOCIALACCOUNT_EMAIL_AUTHENTICATION_AUTO_CONNECT = True\n+SOCIALACCOUNT_ADAPTER = \"api.adapters.ProwlerSocialAccountAdapter\"\n+SOCIALACCOUNT_PROVIDERS = {\n+    \"google\": {\n+        \"APP\": {\n+            \"client_id\": GOOGLE_OAUTH_CLIENT_ID,\n+            \"secret\": GOOGLE_OAUTH_CLIENT_SECRET,\n+            \"key\": \"\",\n+        },\n+        \"SCOPE\": [\n+            \"email\",\n+            \"profile\",\n+        ],\n+        \"AUTH_PARAMS\": {\n+            \"access_type\": \"online\",\n+        },\n+    },\n+    \"github\": {\n+        \"APP\": {\n+            \"client_id\": GITHUB_OAUTH_CLIENT_ID,\n+            \"secret\": GITHUB_OAUTH_CLIENT_SECRET,\n+        },\n+        \"SCOPE\": [\n+            \"user\",\n+            \"repo\",",
        "comment_created_at": "2025-02-13T15:09:43+00:00",
        "comment_author": "drewkerrigan",
        "comment_body": "Do we need the `repo` scope? According to the docs:\r\n\r\n\"Grants full access to public and private repositories including read and write access to code, commit statuses, repository invitations, collaborators, deployment statuses, and repository webhooks.\" (https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps)",
        "pr_file_module": null
      },
      {
        "comment_id": "1954714734",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 6906,
        "pr_file": "api/src/backend/config/settings/social_login.py",
        "discussion_id": "1954697561",
        "commented_code": "@@ -0,0 +1,54 @@\n+from config.env import env\n+\n+# Google Oauth settings\n+GOOGLE_OAUTH_CLIENT_ID = env(\"DJANGO_GOOGLE_OAUTH_CLIENT_ID\", default=\"\")\n+GOOGLE_OAUTH_CLIENT_SECRET = env(\"DJANGO_GOOGLE_OAUTH_CLIENT_SECRET\", default=\"\")\n+GOOGLE_OAUTH_CALLBACK_URL = env(\"DJANGO_GOOGLE_OAUTH_CALLBACK_URL\", default=\"\")\n+\n+GITHUB_OAUTH_CLIENT_ID = env(\"DJANGO_GITHUB_OAUTH_CLIENT_ID\", default=\"\")\n+GITHUB_OAUTH_CLIENT_SECRET = env(\"DJANGO_GITHUB_OAUTH_CLIENT_SECRET\", default=\"\")\n+GITHUB_OAUTH_CALLBACK_URL = env(\"DJANGO_GITHUB_OAUTH_CALLBACK_URL\", default=\"\")\n+\n+# Allauth settings\n+ACCOUNT_LOGIN_METHODS = {\"email\"}  # Use Email / Password authentication\n+ACCOUNT_USERNAME_REQUIRED = False\n+ACCOUNT_EMAIL_REQUIRED = True\n+ACCOUNT_EMAIL_VERIFICATION = \"none\"  # Do not require email confirmation\n+ACCOUNT_USER_MODEL_USERNAME_FIELD = None\n+REST_AUTH = {\n+    \"TOKEN_MODEL\": None,\n+    \"REST_USE_JWT\": True,\n+}\n+# django-allauth (social)\n+# Authenticate if local account with this email address already exists\n+SOCIALACCOUNT_EMAIL_AUTHENTICATION = True\n+# Connect local account and social account if local account with that email address already exists\n+SOCIALACCOUNT_EMAIL_AUTHENTICATION_AUTO_CONNECT = True\n+SOCIALACCOUNT_ADAPTER = \"api.adapters.ProwlerSocialAccountAdapter\"\n+SOCIALACCOUNT_PROVIDERS = {\n+    \"google\": {\n+        \"APP\": {\n+            \"client_id\": GOOGLE_OAUTH_CLIENT_ID,\n+            \"secret\": GOOGLE_OAUTH_CLIENT_SECRET,\n+            \"key\": \"\",\n+        },\n+        \"SCOPE\": [\n+            \"email\",\n+            \"profile\",\n+        ],\n+        \"AUTH_PARAMS\": {\n+            \"access_type\": \"online\",\n+        },\n+    },\n+    \"github\": {\n+        \"APP\": {\n+            \"client_id\": GITHUB_OAUTH_CLIENT_ID,\n+            \"secret\": GITHUB_OAUTH_CLIENT_SECRET,\n+        },\n+        \"SCOPE\": [\n+            \"user\",\n+            \"repo\",",
        "comment_created_at": "2025-02-13T15:18:32+00:00",
        "comment_author": "vicferpoy",
        "comment_body": "We don't. Thank you for noticing.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071413884",
    "pr_number": 2655,
    "pr_file": "prowler/providers/aws/services/iam/iam_policy_allows_privilege_escalation/iam_policy_allows_privilege_escalation.py",
    "created_at": "2025-05-02T10:24:35+00:00",
    "commented_code": "# Does the tool handle Condition constraints? --> Not yet.\n # Does the tool handle service control policy (SCP) restrictions? --> No, SCP are within Organizations AWS API.\n \n+# Based on:\n+# - https://bishopfox.com/blog/privilege-escalation-in-aws\n+# - https://github.com/RhinoSecurityLabs/Security-Research/blob/master/tools/aws-pentest-tools/aws_escalate.py\n+# - https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/\n+\n \n class iam_policy_allows_privilege_escalation(Check):\n     def execute(self) -> Check_Report_AWS:\n-        # Is necessary to include the \"Action:*\" for\n-        # each service that has a policy that could\n-        # allow for privilege escalation\n-        privilege_escalation_iam_actions = {\n-            \"iam:AttachGroupPolicy\",\n-            \"iam:SetDefaultPolicyVersion2\",\n-            \"iam:AddUserToGroup\",\n-            \"iam:AttachRolePolicy\",\n-            \"iam:AttachUserPolicy\",\n-            \"iam:CreateAccessKey\",\n-            \"iam:CreatePolicyVersion\",\n-            \"iam:CreateLoginProfile\",\n-            \"iam:PassRole\",\n-            \"iam:PutGroupPolicy\",\n-            \"iam:PutRolePolicy\",\n-            \"iam:PutUserPolicy\",\n-            \"iam:SetDefaultPolicyVersion\",\n-            \"iam:UpdateAssumeRolePolicy\",\n-            \"iam:UpdateLoginProfile\",\n-            \"iam:*\",\n-            \"sts:AssumeRole\",\n-            \"sts:*\",\n-            \"ec2:RunInstances\",\n-            \"ec2:*\",\n-            \"lambda:CreateEventSourceMapping\",\n-            \"lambda:CreateFunction\",\n-            \"lambda:InvokeFunction\",\n-            \"lambda:UpdateFunctionCode\",\n-            \"lambda:*\",\n-            \"dynamodb:CreateTable\",\n-            \"dynamodb:PutItem\",\n-            \"dynamodb:*\",\n-            \"glue:CreateDevEndpoint\",\n-            \"glue:GetDevEndpoint\",\n-            \"glue:GetDevEndpoints\",\n-            \"glue:UpdateDevEndpoint\",\n-            \"glue:*\",\n-            \"cloudformation:CreateStack\",\n-            \"cloudformation:DescribeStacks\",\n-            \"cloudformation:*\",\n-            \"datapipeline:CreatePipeline\",\n-            \"datapipeline:PutPipelineDefinition\",\n-            \"datapipeline:ActivatePipeline\",\n-            \"datapipeline:*\",\n+        privilege_escalation_policies_combination = {\n+            \"CreatePolicyVersion\": {\"iam:CreatePolicyVersion\"},\n+            \"SetDefaultPolicyVersion\": {\"iam:SetDefaultPolicyVersion\"},\n+            \"iam:PassRole\": {\"iam:PassRole\"},",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "2071413884",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 2655,
        "pr_file": "prowler/providers/aws/services/iam/iam_policy_allows_privilege_escalation/iam_policy_allows_privilege_escalation.py",
        "discussion_id": "2071413884",
        "commented_code": "@@ -11,63 +13,94 @@\n # Does the tool handle Condition constraints? --> Not yet.\n # Does the tool handle service control policy (SCP) restrictions? --> No, SCP are within Organizations AWS API.\n \n+# Based on:\n+# - https://bishopfox.com/blog/privilege-escalation-in-aws\n+# - https://github.com/RhinoSecurityLabs/Security-Research/blob/master/tools/aws-pentest-tools/aws_escalate.py\n+# - https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/\n+\n \n class iam_policy_allows_privilege_escalation(Check):\n     def execute(self) -> Check_Report_AWS:\n-        # Is necessary to include the \"Action:*\" for\n-        # each service that has a policy that could\n-        # allow for privilege escalation\n-        privilege_escalation_iam_actions = {\n-            \"iam:AttachGroupPolicy\",\n-            \"iam:SetDefaultPolicyVersion2\",\n-            \"iam:AddUserToGroup\",\n-            \"iam:AttachRolePolicy\",\n-            \"iam:AttachUserPolicy\",\n-            \"iam:CreateAccessKey\",\n-            \"iam:CreatePolicyVersion\",\n-            \"iam:CreateLoginProfile\",\n-            \"iam:PassRole\",\n-            \"iam:PutGroupPolicy\",\n-            \"iam:PutRolePolicy\",\n-            \"iam:PutUserPolicy\",\n-            \"iam:SetDefaultPolicyVersion\",\n-            \"iam:UpdateAssumeRolePolicy\",\n-            \"iam:UpdateLoginProfile\",\n-            \"iam:*\",\n-            \"sts:AssumeRole\",\n-            \"sts:*\",\n-            \"ec2:RunInstances\",\n-            \"ec2:*\",\n-            \"lambda:CreateEventSourceMapping\",\n-            \"lambda:CreateFunction\",\n-            \"lambda:InvokeFunction\",\n-            \"lambda:UpdateFunctionCode\",\n-            \"lambda:*\",\n-            \"dynamodb:CreateTable\",\n-            \"dynamodb:PutItem\",\n-            \"dynamodb:*\",\n-            \"glue:CreateDevEndpoint\",\n-            \"glue:GetDevEndpoint\",\n-            \"glue:GetDevEndpoints\",\n-            \"glue:UpdateDevEndpoint\",\n-            \"glue:*\",\n-            \"cloudformation:CreateStack\",\n-            \"cloudformation:DescribeStacks\",\n-            \"cloudformation:*\",\n-            \"datapipeline:CreatePipeline\",\n-            \"datapipeline:PutPipelineDefinition\",\n-            \"datapipeline:ActivatePipeline\",\n-            \"datapipeline:*\",\n+        privilege_escalation_policies_combination = {\n+            \"CreatePolicyVersion\": {\"iam:CreatePolicyVersion\"},\n+            \"SetDefaultPolicyVersion\": {\"iam:SetDefaultPolicyVersion\"},\n+            \"iam:PassRole\": {\"iam:PassRole\"},",
        "comment_created_at": "2025-05-02T10:24:35+00:00",
        "comment_author": "maxi-bee",
        "comment_body": "Why does this is a valid PE Action by itself? The reference documentation does not state that anywhere. We are getting findings on policies only with this and I think these are all false positives because of this line",
        "pr_file_module": null
      },
      {
        "comment_id": "2073144699",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 2655,
        "pr_file": "prowler/providers/aws/services/iam/iam_policy_allows_privilege_escalation/iam_policy_allows_privilege_escalation.py",
        "discussion_id": "2071413884",
        "commented_code": "@@ -11,63 +13,94 @@\n # Does the tool handle Condition constraints? --> Not yet.\n # Does the tool handle service control policy (SCP) restrictions? --> No, SCP are within Organizations AWS API.\n \n+# Based on:\n+# - https://bishopfox.com/blog/privilege-escalation-in-aws\n+# - https://github.com/RhinoSecurityLabs/Security-Research/blob/master/tools/aws-pentest-tools/aws_escalate.py\n+# - https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/\n+\n \n class iam_policy_allows_privilege_escalation(Check):\n     def execute(self) -> Check_Report_AWS:\n-        # Is necessary to include the \"Action:*\" for\n-        # each service that has a policy that could\n-        # allow for privilege escalation\n-        privilege_escalation_iam_actions = {\n-            \"iam:AttachGroupPolicy\",\n-            \"iam:SetDefaultPolicyVersion2\",\n-            \"iam:AddUserToGroup\",\n-            \"iam:AttachRolePolicy\",\n-            \"iam:AttachUserPolicy\",\n-            \"iam:CreateAccessKey\",\n-            \"iam:CreatePolicyVersion\",\n-            \"iam:CreateLoginProfile\",\n-            \"iam:PassRole\",\n-            \"iam:PutGroupPolicy\",\n-            \"iam:PutRolePolicy\",\n-            \"iam:PutUserPolicy\",\n-            \"iam:SetDefaultPolicyVersion\",\n-            \"iam:UpdateAssumeRolePolicy\",\n-            \"iam:UpdateLoginProfile\",\n-            \"iam:*\",\n-            \"sts:AssumeRole\",\n-            \"sts:*\",\n-            \"ec2:RunInstances\",\n-            \"ec2:*\",\n-            \"lambda:CreateEventSourceMapping\",\n-            \"lambda:CreateFunction\",\n-            \"lambda:InvokeFunction\",\n-            \"lambda:UpdateFunctionCode\",\n-            \"lambda:*\",\n-            \"dynamodb:CreateTable\",\n-            \"dynamodb:PutItem\",\n-            \"dynamodb:*\",\n-            \"glue:CreateDevEndpoint\",\n-            \"glue:GetDevEndpoint\",\n-            \"glue:GetDevEndpoints\",\n-            \"glue:UpdateDevEndpoint\",\n-            \"glue:*\",\n-            \"cloudformation:CreateStack\",\n-            \"cloudformation:DescribeStacks\",\n-            \"cloudformation:*\",\n-            \"datapipeline:CreatePipeline\",\n-            \"datapipeline:PutPipelineDefinition\",\n-            \"datapipeline:ActivatePipeline\",\n-            \"datapipeline:*\",\n+        privilege_escalation_policies_combination = {\n+            \"CreatePolicyVersion\": {\"iam:CreatePolicyVersion\"},\n+            \"SetDefaultPolicyVersion\": {\"iam:SetDefaultPolicyVersion\"},\n+            \"iam:PassRole\": {\"iam:PassRole\"},",
        "comment_created_at": "2025-05-05T09:40:15+00:00",
        "comment_author": "jfagoagas",
        "comment_body": "Hello @maxi-bee, `iam:PassRole` action could lead into privilege escalation if the resource configured is `*` or list/single role with more privileges. In this case I recommend you to use the [Mutelist](https://docs.prowler.com/projects/prowler-open-source/en/latest/tutorials/mutelist/) if the affected IAM Policy is flagged as `FAIL` by Prowler because in your environment/context it is not.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2123433816",
    "pr_number": 7832,
    "pr_file": "prowler/providers/ionos/ionos_provider.py",
    "created_at": "2025-06-03T10:46:36+00:00",
    "commented_code": "+import sys\n+import json\n+import os\n+import subprocess\n+from typing import Any, Optional, Tuple\n+\n+import ionoscloud\n+from ionoscloud import ApiClient, Configuration\n+from ionoscloud.rest import ApiException\n+import ionoscloud_dataplatform\n+from ionoscloud.api.data_centers_api import DataCentersApi\n+from ionoscloud.api.user_management_api import UserManagementApi\n+\n+from prowler.config.config import get_default_mute_file_path, load_and_validate_config_file\n+from prowler.lib.logger import logger\n+from prowler.lib.mutelist.mutelist import Mutelist\n+from prowler.providers.ionos.lib.mutelist.mutelist import IonosMutelist\n+from prowler.providers.ionos.models import IonosIdentityInfo\n+from prowler.lib.utils.utils import open_file, parse_json_file, print_boxes\n+from colorama import Fore, Style\n+\n+from prowler.providers.common.provider import Provider\n+\n+class IonosProvider(Provider):\n+    _type: str = \"ionos\"\n+    _session: Optional[ApiClient] = None\n+    _identity: Optional[IonosIdentityInfo] = None\n+    _audit_config: dict = {}\n+    _output_options: Optional[Any] = None\n+    _mutelist: IonosMutelist\n+    audit_metadata: Optional[Any] = None\n+    _token = None\n+    _username = None\n+    _password = None\n+    _datacenter_id = None\n+\n+    def __init__(\n+        self,\n+        ionos_username: Optional[str] = None,\n+        ionos_password: Optional[str] = None,\n+        ionos_datacenter_name: Optional[str] = None,\n+        config_path: Optional[str] = None,\n+        mutelist_path: Optional[str] = None,\n+        mutelist_content: dict = None,\n+    ):\n+        \"\"\"\n+        Inicializa la clase IonosProvider y configura la sesión.\n+        Si no se proporcionan credenciales se intentará cargarlas desde variables de entorno o la configuración de ionosctl.\n+        \"\"\"\n+        logger.info(\"Initializing IONOS Provider...\")\n+        self._token = self.load_ionosctl_token()\n+                \n+        self._identity = self.set_identity(\n+            username=ionos_username,\n+            password=ionos_password,\n+            datacenter_id=\"\",\n+        )\n+\n+        self._session = self.setup_session(\n+            identity=self._identity,\n+        )\n+\n+        if not self.test_connection():\n+            logger.critical(\"Failed to establish connection with IONOS Cloud API, please check your credentials.\")\n+            sys.exit(1)\n+\n+        if not self._identity.username or not self._identity.password:\n+            self._identity.username = self.get_ionos_username()\n+\n+        self._identity.datacenter_id = self.get_datacenter_id(ionos_datacenter_name)\n+\n+        if config_path is None:\n+            self._audit_config = {}\n+        else:\n+            self._audit_config = load_and_validate_config_file(\"ionos\", config_path)\n+        \n+        # Mutelist\n+        if mutelist_content:\n+            self._mutelist = IonosMutelist(\n+                mutelist_content=mutelist_content,\n+            )\n+        else:\n+            if not mutelist_path:\n+                mutelist_path = get_default_mute_file_path(self.type)\n+                logger.info(f\"No mutelist path provided, using default: {mutelist_path}\")\n+            self._mutelist = IonosMutelist(\n+                mutelist_path=mutelist_path,\n+            )\n+            logger.info(f\"Loaded mutelist from {mutelist_path}\")\n+\n+        Provider.set_global_provider(self)\n+\n+    @staticmethod\n+    def load_env_credentials() -> Tuple[Optional[str], Optional[str], Optional[str]]:\n+        \"\"\"\n+        Lee las credenciales de IONOS desde las variables de entorno.\n+        Retorna una tupla con (username, password, token)\n+        \"\"\"\n+        username = os.getenv(\"IONOS_USERNAME\")\n+        password = os.getenv(\"IONOS_PASSWORD\")\n+        token = os.getenv(\"IONOS_TOKEN\")\n+        if username and password and token:\n+            logger.info(\"Loaded IONOS credentials from environment variables.\")\n+        else:\n+            logger.warning(\"No se encontraron todas las credenciales en las variables de entorno.\")\n+        return username, password, token\n+\n+    @staticmethod\n+    def load_ionosctl_token() -> Optional[str]:\n+        \"\"\"\n+        Reads the IONOS token from the ionosctl configuration file across different platforms.\n+        \"\"\"",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "2123433816",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7832,
        "pr_file": "prowler/providers/ionos/ionos_provider.py",
        "discussion_id": "2123433816",
        "commented_code": "@@ -0,0 +1,320 @@\n+import sys\n+import json\n+import os\n+import subprocess\n+from typing import Any, Optional, Tuple\n+\n+import ionoscloud\n+from ionoscloud import ApiClient, Configuration\n+from ionoscloud.rest import ApiException\n+import ionoscloud_dataplatform\n+from ionoscloud.api.data_centers_api import DataCentersApi\n+from ionoscloud.api.user_management_api import UserManagementApi\n+\n+from prowler.config.config import get_default_mute_file_path, load_and_validate_config_file\n+from prowler.lib.logger import logger\n+from prowler.lib.mutelist.mutelist import Mutelist\n+from prowler.providers.ionos.lib.mutelist.mutelist import IonosMutelist\n+from prowler.providers.ionos.models import IonosIdentityInfo\n+from prowler.lib.utils.utils import open_file, parse_json_file, print_boxes\n+from colorama import Fore, Style\n+\n+from prowler.providers.common.provider import Provider\n+\n+class IonosProvider(Provider):\n+    _type: str = \"ionos\"\n+    _session: Optional[ApiClient] = None\n+    _identity: Optional[IonosIdentityInfo] = None\n+    _audit_config: dict = {}\n+    _output_options: Optional[Any] = None\n+    _mutelist: IonosMutelist\n+    audit_metadata: Optional[Any] = None\n+    _token = None\n+    _username = None\n+    _password = None\n+    _datacenter_id = None\n+\n+    def __init__(\n+        self,\n+        ionos_username: Optional[str] = None,\n+        ionos_password: Optional[str] = None,\n+        ionos_datacenter_name: Optional[str] = None,\n+        config_path: Optional[str] = None,\n+        mutelist_path: Optional[str] = None,\n+        mutelist_content: dict = None,\n+    ):\n+        \"\"\"\n+        Inicializa la clase IonosProvider y configura la sesión.\n+        Si no se proporcionan credenciales se intentará cargarlas desde variables de entorno o la configuración de ionosctl.\n+        \"\"\"\n+        logger.info(\"Initializing IONOS Provider...\")\n+        self._token = self.load_ionosctl_token()\n+                \n+        self._identity = self.set_identity(\n+            username=ionos_username,\n+            password=ionos_password,\n+            datacenter_id=\"\",\n+        )\n+\n+        self._session = self.setup_session(\n+            identity=self._identity,\n+        )\n+\n+        if not self.test_connection():\n+            logger.critical(\"Failed to establish connection with IONOS Cloud API, please check your credentials.\")\n+            sys.exit(1)\n+\n+        if not self._identity.username or not self._identity.password:\n+            self._identity.username = self.get_ionos_username()\n+\n+        self._identity.datacenter_id = self.get_datacenter_id(ionos_datacenter_name)\n+\n+        if config_path is None:\n+            self._audit_config = {}\n+        else:\n+            self._audit_config = load_and_validate_config_file(\"ionos\", config_path)\n+        \n+        # Mutelist\n+        if mutelist_content:\n+            self._mutelist = IonosMutelist(\n+                mutelist_content=mutelist_content,\n+            )\n+        else:\n+            if not mutelist_path:\n+                mutelist_path = get_default_mute_file_path(self.type)\n+                logger.info(f\"No mutelist path provided, using default: {mutelist_path}\")\n+            self._mutelist = IonosMutelist(\n+                mutelist_path=mutelist_path,\n+            )\n+            logger.info(f\"Loaded mutelist from {mutelist_path}\")\n+\n+        Provider.set_global_provider(self)\n+\n+    @staticmethod\n+    def load_env_credentials() -> Tuple[Optional[str], Optional[str], Optional[str]]:\n+        \"\"\"\n+        Lee las credenciales de IONOS desde las variables de entorno.\n+        Retorna una tupla con (username, password, token)\n+        \"\"\"\n+        username = os.getenv(\"IONOS_USERNAME\")\n+        password = os.getenv(\"IONOS_PASSWORD\")\n+        token = os.getenv(\"IONOS_TOKEN\")\n+        if username and password and token:\n+            logger.info(\"Loaded IONOS credentials from environment variables.\")\n+        else:\n+            logger.warning(\"No se encontraron todas las credenciales en las variables de entorno.\")\n+        return username, password, token\n+\n+    @staticmethod\n+    def load_ionosctl_token() -> Optional[str]:\n+        \"\"\"\n+        Reads the IONOS token from the ionosctl configuration file across different platforms.\n+        \"\"\"",
        "comment_created_at": "2025-06-03T10:46:36+00:00",
        "comment_author": "HugoPBrito",
        "comment_body": "Could you explain in which situations these files contain the necessary token data?",
        "pr_file_module": null
      },
      {
        "comment_id": "2123520612",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7832,
        "pr_file": "prowler/providers/ionos/ionos_provider.py",
        "discussion_id": "2123433816",
        "commented_code": "@@ -0,0 +1,320 @@\n+import sys\n+import json\n+import os\n+import subprocess\n+from typing import Any, Optional, Tuple\n+\n+import ionoscloud\n+from ionoscloud import ApiClient, Configuration\n+from ionoscloud.rest import ApiException\n+import ionoscloud_dataplatform\n+from ionoscloud.api.data_centers_api import DataCentersApi\n+from ionoscloud.api.user_management_api import UserManagementApi\n+\n+from prowler.config.config import get_default_mute_file_path, load_and_validate_config_file\n+from prowler.lib.logger import logger\n+from prowler.lib.mutelist.mutelist import Mutelist\n+from prowler.providers.ionos.lib.mutelist.mutelist import IonosMutelist\n+from prowler.providers.ionos.models import IonosIdentityInfo\n+from prowler.lib.utils.utils import open_file, parse_json_file, print_boxes\n+from colorama import Fore, Style\n+\n+from prowler.providers.common.provider import Provider\n+\n+class IonosProvider(Provider):\n+    _type: str = \"ionos\"\n+    _session: Optional[ApiClient] = None\n+    _identity: Optional[IonosIdentityInfo] = None\n+    _audit_config: dict = {}\n+    _output_options: Optional[Any] = None\n+    _mutelist: IonosMutelist\n+    audit_metadata: Optional[Any] = None\n+    _token = None\n+    _username = None\n+    _password = None\n+    _datacenter_id = None\n+\n+    def __init__(\n+        self,\n+        ionos_username: Optional[str] = None,\n+        ionos_password: Optional[str] = None,\n+        ionos_datacenter_name: Optional[str] = None,\n+        config_path: Optional[str] = None,\n+        mutelist_path: Optional[str] = None,\n+        mutelist_content: dict = None,\n+    ):\n+        \"\"\"\n+        Inicializa la clase IonosProvider y configura la sesión.\n+        Si no se proporcionan credenciales se intentará cargarlas desde variables de entorno o la configuración de ionosctl.\n+        \"\"\"\n+        logger.info(\"Initializing IONOS Provider...\")\n+        self._token = self.load_ionosctl_token()\n+                \n+        self._identity = self.set_identity(\n+            username=ionos_username,\n+            password=ionos_password,\n+            datacenter_id=\"\",\n+        )\n+\n+        self._session = self.setup_session(\n+            identity=self._identity,\n+        )\n+\n+        if not self.test_connection():\n+            logger.critical(\"Failed to establish connection with IONOS Cloud API, please check your credentials.\")\n+            sys.exit(1)\n+\n+        if not self._identity.username or not self._identity.password:\n+            self._identity.username = self.get_ionos_username()\n+\n+        self._identity.datacenter_id = self.get_datacenter_id(ionos_datacenter_name)\n+\n+        if config_path is None:\n+            self._audit_config = {}\n+        else:\n+            self._audit_config = load_and_validate_config_file(\"ionos\", config_path)\n+        \n+        # Mutelist\n+        if mutelist_content:\n+            self._mutelist = IonosMutelist(\n+                mutelist_content=mutelist_content,\n+            )\n+        else:\n+            if not mutelist_path:\n+                mutelist_path = get_default_mute_file_path(self.type)\n+                logger.info(f\"No mutelist path provided, using default: {mutelist_path}\")\n+            self._mutelist = IonosMutelist(\n+                mutelist_path=mutelist_path,\n+            )\n+            logger.info(f\"Loaded mutelist from {mutelist_path}\")\n+\n+        Provider.set_global_provider(self)\n+\n+    @staticmethod\n+    def load_env_credentials() -> Tuple[Optional[str], Optional[str], Optional[str]]:\n+        \"\"\"\n+        Lee las credenciales de IONOS desde las variables de entorno.\n+        Retorna una tupla con (username, password, token)\n+        \"\"\"\n+        username = os.getenv(\"IONOS_USERNAME\")\n+        password = os.getenv(\"IONOS_PASSWORD\")\n+        token = os.getenv(\"IONOS_TOKEN\")\n+        if username and password and token:\n+            logger.info(\"Loaded IONOS credentials from environment variables.\")\n+        else:\n+            logger.warning(\"No se encontraron todas las credenciales en las variables de entorno.\")\n+        return username, password, token\n+\n+    @staticmethod\n+    def load_ionosctl_token() -> Optional[str]:\n+        \"\"\"\n+        Reads the IONOS token from the ionosctl configuration file across different platforms.\n+        \"\"\"",
        "comment_created_at": "2025-06-03T11:25:05+00:00",
        "comment_author": "afp91-ua",
        "comment_body": "There are two ways to get the IONOS session, with token or by specifying credentials user and password with the corresponding arguments when calling prowler in terminal. this function recovers the token stored in the config file generated by cli ionos client \"ionosctl\". When you log in with your IONOS Cloud account in ionosctl, a config file with the corresponing token is created to perform API calls, that's why load_ionosctl_token is a necessary function to obtain this token and perform the API calls. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2124210587",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7832,
        "pr_file": "prowler/providers/ionos/ionos_provider.py",
        "discussion_id": "2123433816",
        "commented_code": "@@ -0,0 +1,320 @@\n+import sys\n+import json\n+import os\n+import subprocess\n+from typing import Any, Optional, Tuple\n+\n+import ionoscloud\n+from ionoscloud import ApiClient, Configuration\n+from ionoscloud.rest import ApiException\n+import ionoscloud_dataplatform\n+from ionoscloud.api.data_centers_api import DataCentersApi\n+from ionoscloud.api.user_management_api import UserManagementApi\n+\n+from prowler.config.config import get_default_mute_file_path, load_and_validate_config_file\n+from prowler.lib.logger import logger\n+from prowler.lib.mutelist.mutelist import Mutelist\n+from prowler.providers.ionos.lib.mutelist.mutelist import IonosMutelist\n+from prowler.providers.ionos.models import IonosIdentityInfo\n+from prowler.lib.utils.utils import open_file, parse_json_file, print_boxes\n+from colorama import Fore, Style\n+\n+from prowler.providers.common.provider import Provider\n+\n+class IonosProvider(Provider):\n+    _type: str = \"ionos\"\n+    _session: Optional[ApiClient] = None\n+    _identity: Optional[IonosIdentityInfo] = None\n+    _audit_config: dict = {}\n+    _output_options: Optional[Any] = None\n+    _mutelist: IonosMutelist\n+    audit_metadata: Optional[Any] = None\n+    _token = None\n+    _username = None\n+    _password = None\n+    _datacenter_id = None\n+\n+    def __init__(\n+        self,\n+        ionos_username: Optional[str] = None,\n+        ionos_password: Optional[str] = None,\n+        ionos_datacenter_name: Optional[str] = None,\n+        config_path: Optional[str] = None,\n+        mutelist_path: Optional[str] = None,\n+        mutelist_content: dict = None,\n+    ):\n+        \"\"\"\n+        Inicializa la clase IonosProvider y configura la sesión.\n+        Si no se proporcionan credenciales se intentará cargarlas desde variables de entorno o la configuración de ionosctl.\n+        \"\"\"\n+        logger.info(\"Initializing IONOS Provider...\")\n+        self._token = self.load_ionosctl_token()\n+                \n+        self._identity = self.set_identity(\n+            username=ionos_username,\n+            password=ionos_password,\n+            datacenter_id=\"\",\n+        )\n+\n+        self._session = self.setup_session(\n+            identity=self._identity,\n+        )\n+\n+        if not self.test_connection():\n+            logger.critical(\"Failed to establish connection with IONOS Cloud API, please check your credentials.\")\n+            sys.exit(1)\n+\n+        if not self._identity.username or not self._identity.password:\n+            self._identity.username = self.get_ionos_username()\n+\n+        self._identity.datacenter_id = self.get_datacenter_id(ionos_datacenter_name)\n+\n+        if config_path is None:\n+            self._audit_config = {}\n+        else:\n+            self._audit_config = load_and_validate_config_file(\"ionos\", config_path)\n+        \n+        # Mutelist\n+        if mutelist_content:\n+            self._mutelist = IonosMutelist(\n+                mutelist_content=mutelist_content,\n+            )\n+        else:\n+            if not mutelist_path:\n+                mutelist_path = get_default_mute_file_path(self.type)\n+                logger.info(f\"No mutelist path provided, using default: {mutelist_path}\")\n+            self._mutelist = IonosMutelist(\n+                mutelist_path=mutelist_path,\n+            )\n+            logger.info(f\"Loaded mutelist from {mutelist_path}\")\n+\n+        Provider.set_global_provider(self)\n+\n+    @staticmethod\n+    def load_env_credentials() -> Tuple[Optional[str], Optional[str], Optional[str]]:\n+        \"\"\"\n+        Lee las credenciales de IONOS desde las variables de entorno.\n+        Retorna una tupla con (username, password, token)\n+        \"\"\"\n+        username = os.getenv(\"IONOS_USERNAME\")\n+        password = os.getenv(\"IONOS_PASSWORD\")\n+        token = os.getenv(\"IONOS_TOKEN\")\n+        if username and password and token:\n+            logger.info(\"Loaded IONOS credentials from environment variables.\")\n+        else:\n+            logger.warning(\"No se encontraron todas las credenciales en las variables de entorno.\")\n+        return username, password, token\n+\n+    @staticmethod\n+    def load_ionosctl_token() -> Optional[str]:\n+        \"\"\"\n+        Reads the IONOS token from the ionosctl configuration file across different platforms.\n+        \"\"\"",
        "comment_created_at": "2025-06-03T15:18:46+00:00",
        "comment_author": "HugoPBrito",
        "comment_body": "Could you add exceptions regarding auth flow?\r\n\r\nWe need to inform the about the auth process and exit prowler if not enough credentials are given, inside providers logic.\r\n\r\nIf you can have token auth or credentials auth, make something like:\r\n\r\n1. User env vars of user, with a flag like `--user-env-vars` (or something similar)\r\n2. Flag for `--user` and `--password` static credentials as you have. If one is not provided, raises exceptions saying that you need both flags.\r\n3. Flag for ionosctl token like `--ionosctl` to  use  `self._token = self.load_ionosctl_token()`. Not called otherwhise.\r\n4. If none of those 3 flags are provided, you raise an exception telling that you must select one of the auth methods. The idea is the user knowing what is doing and how. This is done for `Azure` and `M365` for example: https://github.com/prowler-cloud/prowler/blob/6e7a32cb516e813b441e0fe2f7766a9ce270a488/prowler/providers/m365/m365_provider.py#L319\r\nFinally, please, document this in the `README` so users can understand the auth modes and how to select one.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2075048658",
    "pr_number": 7614,
    "pr_file": "prowler/providers/m365/services/teams/teams_service.py",
    "created_at": "2025-05-06T09:07:33+00:00",
    "commented_code": "designated_presenter_role_mode=global_meeting_policy.get(\n                         \"DesignatedPresenterRoleMode\", \"EveryoneUserOverride\"\n                     ),\n+                    allow_security_end_user_reporting=global_meeting_policy.get(\n+                        \"AllowSecurityEndUserReporting\", True",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "2075048658",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7614,
        "pr_file": "prowler/providers/m365/services/teams/teams_service.py",
        "discussion_id": "2075048658",
        "commented_code": "@@ -75,6 +77,9 @@ def _get_global_meeting_policy(self):\n                     designated_presenter_role_mode=global_meeting_policy.get(\n                         \"DesignatedPresenterRoleMode\", \"EveryoneUserOverride\"\n                     ),\n+                    allow_security_end_user_reporting=global_meeting_policy.get(\n+                        \"AllowSecurityEndUserReporting\", True",
        "comment_created_at": "2025-05-06T09:07:33+00:00",
        "comment_author": "HugoPBrito",
        "comment_body": "```suggestion\r\n                        \"AllowSecurityEndUserReporting\", False\r\n```\r\nI would set the non compliant value if we couldn't retrieve the actual one.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075058734",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7614,
        "pr_file": "prowler/providers/m365/services/teams/teams_service.py",
        "discussion_id": "2075048658",
        "commented_code": "@@ -75,6 +77,9 @@ def _get_global_meeting_policy(self):\n                     designated_presenter_role_mode=global_meeting_policy.get(\n                         \"DesignatedPresenterRoleMode\", \"EveryoneUserOverride\"\n                     ),\n+                    allow_security_end_user_reporting=global_meeting_policy.get(\n+                        \"AllowSecurityEndUserReporting\", True",
        "comment_created_at": "2025-05-06T09:12:46+00:00",
        "comment_author": "HugoPBrito",
        "comment_body": "I say this because, from my point of view, it's better to create a false positive finding than a false negative.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075076571",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7614,
        "pr_file": "prowler/providers/m365/services/teams/teams_service.py",
        "discussion_id": "2075048658",
        "commented_code": "@@ -75,6 +77,9 @@ def _get_global_meeting_policy(self):\n                     designated_presenter_role_mode=global_meeting_policy.get(\n                         \"DesignatedPresenterRoleMode\", \"EveryoneUserOverride\"\n                     ),\n+                    allow_security_end_user_reporting=global_meeting_policy.get(\n+                        \"AllowSecurityEndUserReporting\", True",
        "comment_created_at": "2025-05-06T09:23:04+00:00",
        "comment_author": "andoniaf",
        "comment_body": "yes, agree 👍 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1876300749",
    "pr_number": 5911,
    "pr_file": "prowler/providers/aws/services/sqs/sqs_queues_not_publicly_accessible/sqs_queues_not_publicly_accessible_fixer.py",
    "created_at": "2024-12-09T16:32:23+00:00",
    "commented_code": "+import json\n+\n+from prowler.lib.logger import logger\n+from prowler.providers.aws.services.sqs.sqs_client import sqs_client\n+\n+\n+def fixer(resource_id: str, region: str) -> bool:\n+    \"\"\"\n+    Modify the SQS queue's resource-based policy to remove public access and replace with trusted account access.\n+    Specifically, this fixer checks if any statement has a public Principal (e.g., \"*\" or \"CanonicalUser\")\n+    and replaces it with the ARN of the trusted AWS account.\n+    Requires the sqs:SetQueueAttributes permission.\n+    Permissions:\n+    {\n+        \"Version\": \"2012-10-17\",\n+        \"Statement\": [\n+            {\n+                \"Effect\": \"Allow\",\n+                \"Action\": \"sqs:SetQueueAttributes\",\n+                \"Resource\": \"*\"\n+            }\n+        ]\n+    }\n+    Args:\n+        resource_id (str): The SQS queue name or ARN.\n+        region (str): AWS region where the SQS queue exists.\n+    Returns:\n+        bool: True if the operation is successful (policy updated), False otherwise.\n+    \"\"\"\n+    try:\n+        account_id = sqs_client.audited_account\n+        audited_partition = sqs_client.audited_partition\n+\n+        regional_client = sqs_client.regional_clients[region]\n+\n+        trusted_policy = {",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "1876300749",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 5911,
        "pr_file": "prowler/providers/aws/services/sqs/sqs_queues_not_publicly_accessible/sqs_queues_not_publicly_accessible_fixer.py",
        "discussion_id": "1876300749",
        "commented_code": "@@ -0,0 +1,61 @@\n+import json\n+\n+from prowler.lib.logger import logger\n+from prowler.providers.aws.services.sqs.sqs_client import sqs_client\n+\n+\n+def fixer(resource_id: str, region: str) -> bool:\n+    \"\"\"\n+    Modify the SQS queue's resource-based policy to remove public access and replace with trusted account access.\n+    Specifically, this fixer checks if any statement has a public Principal (e.g., \"*\" or \"CanonicalUser\")\n+    and replaces it with the ARN of the trusted AWS account.\n+    Requires the sqs:SetQueueAttributes permission.\n+    Permissions:\n+    {\n+        \"Version\": \"2012-10-17\",\n+        \"Statement\": [\n+            {\n+                \"Effect\": \"Allow\",\n+                \"Action\": \"sqs:SetQueueAttributes\",\n+                \"Resource\": \"*\"\n+            }\n+        ]\n+    }\n+    Args:\n+        resource_id (str): The SQS queue name or ARN.\n+        region (str): AWS region where the SQS queue exists.\n+    Returns:\n+        bool: True if the operation is successful (policy updated), False otherwise.\n+    \"\"\"\n+    try:\n+        account_id = sqs_client.audited_account\n+        audited_partition = sqs_client.audited_partition\n+\n+        regional_client = sqs_client.regional_clients[region]\n+\n+        trusted_policy = {",
        "comment_created_at": "2024-12-09T16:32:23+00:00",
        "comment_author": "MrCloudSec",
        "comment_body": "You have to also set the resource, look at this example https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-basic-examples-of-sqs-policies.html#grant-one-permission-to-one-account",
        "pr_file_module": null
      },
      {
        "comment_id": "1877868088",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 5911,
        "pr_file": "prowler/providers/aws/services/sqs/sqs_queues_not_publicly_accessible/sqs_queues_not_publicly_accessible_fixer.py",
        "discussion_id": "1876300749",
        "commented_code": "@@ -0,0 +1,61 @@\n+import json\n+\n+from prowler.lib.logger import logger\n+from prowler.providers.aws.services.sqs.sqs_client import sqs_client\n+\n+\n+def fixer(resource_id: str, region: str) -> bool:\n+    \"\"\"\n+    Modify the SQS queue's resource-based policy to remove public access and replace with trusted account access.\n+    Specifically, this fixer checks if any statement has a public Principal (e.g., \"*\" or \"CanonicalUser\")\n+    and replaces it with the ARN of the trusted AWS account.\n+    Requires the sqs:SetQueueAttributes permission.\n+    Permissions:\n+    {\n+        \"Version\": \"2012-10-17\",\n+        \"Statement\": [\n+            {\n+                \"Effect\": \"Allow\",\n+                \"Action\": \"sqs:SetQueueAttributes\",\n+                \"Resource\": \"*\"\n+            }\n+        ]\n+    }\n+    Args:\n+        resource_id (str): The SQS queue name or ARN.\n+        region (str): AWS region where the SQS queue exists.\n+    Returns:\n+        bool: True if the operation is successful (policy updated), False otherwise.\n+    \"\"\"\n+    try:\n+        account_id = sqs_client.audited_account\n+        audited_partition = sqs_client.audited_partition\n+\n+        regional_client = sqs_client.regional_clients[region]\n+\n+        trusted_policy = {",
        "comment_created_at": "2024-12-10T10:52:55+00:00",
        "comment_author": "danibarranqueroo",
        "comment_body": "Done! Also to follow that example I needed to use the name instead of the resource_id so take a look of how I've done it please 🚀 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1852469152",
    "pr_number": 5840,
    "pr_file": "prowler/providers/aws/services/awslambda/awslambda_function_not_publicly_accessible/awslambda_function_not_publicly_accessible_fixer.py",
    "created_at": "2024-11-21T16:27:34+00:00",
    "commented_code": null,
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "1852469152",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 5840,
        "pr_file": "prowler/providers/aws/services/awslambda/awslambda_function_not_publicly_accessible/awslambda_function_not_publicly_accessible_fixer.py",
        "discussion_id": "1852469152",
        "commented_code": null,
        "comment_created_at": "2024-11-21T16:27:34+00:00",
        "comment_author": "MrCloudSec",
        "comment_body": "@danibarranqueroo there are different ways to make a Lambda's policy public, not just the Principal being `*`. For simplicity, I think the best option is to remove the entire Lambda policy.",
        "pr_file_module": null
      },
      {
        "comment_id": "1856513277",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 5840,
        "pr_file": "prowler/providers/aws/services/awslambda/awslambda_function_not_publicly_accessible/awslambda_function_not_publicly_accessible_fixer.py",
        "discussion_id": "1852469152",
        "commented_code": null,
        "comment_created_at": "2024-11-25T12:13:38+00:00",
        "comment_author": "danibarranqueroo",
        "comment_body": "Okay, thanks for notifying that, as there is no way to remove the entire policy I've done it removing one by one all the Statements. ",
        "pr_file_module": null
      }
    ]
  }
]