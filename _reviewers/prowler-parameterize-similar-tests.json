[
  {
    "discussion_id": "2120859672",
    "pr_number": 7848,
    "pr_file": "api/src/backend/api/tests/test_views.py",
    "created_at": "2025-06-02T11:27:39+00:00",
    "commented_code": "{f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"OpenAI\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(reverse(\"lighthouseconfig-list\"))\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert (\n+            data[\"attributes\"][\"name\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"name\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"model\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"model\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"temperature\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"temperature\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"max_tokens\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"max_tokens\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"business_context\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"business_context\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"is_active\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"is_active\"]\n+        )\n+        # Check that API key is masked with asterisks only\n+        masked_api_key = data[\"attributes\"][\"api_key\"]\n+        assert all(\n+            c == \"*\" for c in masked_api_key\n+        ), \"API key should contain only asterisks\"\n+\n+    def test_lighthouse_config_create_invalid_name_too_short(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that name validation fails when too short\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"name\"] = \"T\"  # Too short\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_api_key_format(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that API key validation fails with invalid format\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"api_key\"] = \"invalid-key\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_model(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that model validation fails with invalid model name\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"model\"] = \"invalid-model\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"model\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_temperature_range(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that temperature validation fails when out of range\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"temperature\"] = 2.0  # Out of range\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"temperature\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_max_tokens(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that max_tokens validation fails with invalid value\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"max_tokens\"] = -1  # Invalid value\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"max_tokens\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_missing_required_fields(\n+        self, authenticated_client\n+    ):\n+        \"\"\"Test that validation fails when required fields are missing\"\"\"\n+        payload = {\"data\": {\"type\": \"lighthouse-config\", \"attributes\": {}}}\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        # Check for required fields\n+        required_fields = [\"name\", \"api_key\", \"model\"]\n+        for field in required_fields:\n+            assert any(field in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"Lighthouse configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        \"\"\"Test retrieving a lighthouse config\"\"\"\n+        response = authenticated_client.get(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            )\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == lighthouse_config_fixture.name\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            lighthouse_config_fixture.api_key\n+        )\n+\n+    def test_lighthouse_config_update(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        update_payload = {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"id\": str(lighthouse_config_fixture.id),\n+                \"attributes\": {\n+                    \"name\": \"Updated Config\",\n+                    \"model\": \"gpt-4o-mini\",\n+                    \"temperature\": 0.5,\n+                },\n+            }\n+        }\n+        response = authenticated_client.patch(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            ),\n+            data=update_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Updated Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o-mini\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.5\n+\n+    def test_lighthouse_config_delete(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        response = authenticated_client.delete(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_204_NO_CONTENT\n+        # Verify deletion\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_404_NOT_FOUND\n+\n+    @patch(\"api.v1.views.openai.OpenAI\")\n+    def test_lighthouse_config_check_connection(\n+        self, mock_openai, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        # Mock successful API call\n+        mock_client = Mock()\n+        mock_client.models.list.return_value = Mock(\n+            data=[Mock(id=\"gpt-4o\"), Mock(id=\"gpt-4o-mini\")]\n+        )\n+        mock_openai.return_value = mock_client\n+        # Check connection\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-check-connection\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"detail\"] == \"Connection successful!\"\n+        assert \"gpt-4o\" in response.json()[\"data\"][\"available_models\"]\n+        assert \"gpt-4o-mini\" in response.json()[\"data\"][\"available_models\"]\n+\n+    def test_lighthouse_config_get_key(\n+        self, authenticated_client, lighthouse_config_fixture, valid_config_payload\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        expected_api_key = valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+            + \"?fields[lighthouse-config]=api_key\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"attributes\"][\"api_key\"] == expected_api_key\n+\n+    def test_lighthouse_config_filters(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test name filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\")\n+            + \"?filter[name]=\"\n+            + lighthouse_config_fixture.name\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test model filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[model]=gpt-4o\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test is_active filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[is_active]=true\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "2120859672",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7848,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2120859672",
        "commented_code": "@@ -5458,3 +5458,331 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"OpenAI\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(reverse(\"lighthouseconfig-list\"))\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert (\n+            data[\"attributes\"][\"name\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"name\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"model\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"model\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"temperature\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"temperature\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"max_tokens\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"max_tokens\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"business_context\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"business_context\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"is_active\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"is_active\"]\n+        )\n+        # Check that API key is masked with asterisks only\n+        masked_api_key = data[\"attributes\"][\"api_key\"]\n+        assert all(\n+            c == \"*\" for c in masked_api_key\n+        ), \"API key should contain only asterisks\"\n+\n+    def test_lighthouse_config_create_invalid_name_too_short(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that name validation fails when too short\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"name\"] = \"T\"  # Too short\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_api_key_format(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that API key validation fails with invalid format\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"api_key\"] = \"invalid-key\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_model(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that model validation fails with invalid model name\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"model\"] = \"invalid-model\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"model\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_temperature_range(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that temperature validation fails when out of range\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"temperature\"] = 2.0  # Out of range\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"temperature\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_max_tokens(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that max_tokens validation fails with invalid value\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"max_tokens\"] = -1  # Invalid value\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"max_tokens\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_missing_required_fields(\n+        self, authenticated_client\n+    ):\n+        \"\"\"Test that validation fails when required fields are missing\"\"\"\n+        payload = {\"data\": {\"type\": \"lighthouse-config\", \"attributes\": {}}}\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        # Check for required fields\n+        required_fields = [\"name\", \"api_key\", \"model\"]\n+        for field in required_fields:\n+            assert any(field in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"Lighthouse configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        \"\"\"Test retrieving a lighthouse config\"\"\"\n+        response = authenticated_client.get(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            )\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == lighthouse_config_fixture.name\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            lighthouse_config_fixture.api_key\n+        )\n+\n+    def test_lighthouse_config_update(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        update_payload = {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"id\": str(lighthouse_config_fixture.id),\n+                \"attributes\": {\n+                    \"name\": \"Updated Config\",\n+                    \"model\": \"gpt-4o-mini\",\n+                    \"temperature\": 0.5,\n+                },\n+            }\n+        }\n+        response = authenticated_client.patch(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            ),\n+            data=update_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Updated Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o-mini\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.5\n+\n+    def test_lighthouse_config_delete(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        response = authenticated_client.delete(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_204_NO_CONTENT\n+        # Verify deletion\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_404_NOT_FOUND\n+\n+    @patch(\"api.v1.views.openai.OpenAI\")\n+    def test_lighthouse_config_check_connection(\n+        self, mock_openai, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        # Mock successful API call\n+        mock_client = Mock()\n+        mock_client.models.list.return_value = Mock(\n+            data=[Mock(id=\"gpt-4o\"), Mock(id=\"gpt-4o-mini\")]\n+        )\n+        mock_openai.return_value = mock_client\n+        # Check connection\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-check-connection\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"detail\"] == \"Connection successful!\"\n+        assert \"gpt-4o\" in response.json()[\"data\"][\"available_models\"]\n+        assert \"gpt-4o-mini\" in response.json()[\"data\"][\"available_models\"]\n+\n+    def test_lighthouse_config_get_key(\n+        self, authenticated_client, lighthouse_config_fixture, valid_config_payload\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        expected_api_key = valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+            + \"?fields[lighthouse-config]=api_key\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"attributes\"][\"api_key\"] == expected_api_key\n+\n+    def test_lighthouse_config_filters(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test name filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\")\n+            + \"?filter[name]=\"\n+            + lighthouse_config_fixture.name\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test model filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[model]=gpt-4o\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test is_active filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[is_active]=true\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1",
        "comment_created_at": "2025-06-02T11:27:39+00:00",
        "comment_author": "vicferpoy",
        "comment_body": "Use pytest parametrization here, please. Easier to read, maintain and add new tests if required.",
        "pr_file_module": null
      },
      {
        "comment_id": "2128620070",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7848,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2120859672",
        "commented_code": "@@ -5458,3 +5458,331 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"OpenAI\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(reverse(\"lighthouseconfig-list\"))\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert (\n+            data[\"attributes\"][\"name\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"name\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"model\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"model\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"temperature\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"temperature\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"max_tokens\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"max_tokens\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"business_context\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"business_context\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"is_active\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"is_active\"]\n+        )\n+        # Check that API key is masked with asterisks only\n+        masked_api_key = data[\"attributes\"][\"api_key\"]\n+        assert all(\n+            c == \"*\" for c in masked_api_key\n+        ), \"API key should contain only asterisks\"\n+\n+    def test_lighthouse_config_create_invalid_name_too_short(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that name validation fails when too short\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"name\"] = \"T\"  # Too short\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_api_key_format(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that API key validation fails with invalid format\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"api_key\"] = \"invalid-key\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_model(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that model validation fails with invalid model name\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"model\"] = \"invalid-model\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"model\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_temperature_range(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that temperature validation fails when out of range\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"temperature\"] = 2.0  # Out of range\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"temperature\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_max_tokens(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that max_tokens validation fails with invalid value\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"max_tokens\"] = -1  # Invalid value\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"max_tokens\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_missing_required_fields(\n+        self, authenticated_client\n+    ):\n+        \"\"\"Test that validation fails when required fields are missing\"\"\"\n+        payload = {\"data\": {\"type\": \"lighthouse-config\", \"attributes\": {}}}\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        # Check for required fields\n+        required_fields = [\"name\", \"api_key\", \"model\"]\n+        for field in required_fields:\n+            assert any(field in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"Lighthouse configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        \"\"\"Test retrieving a lighthouse config\"\"\"\n+        response = authenticated_client.get(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            )\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == lighthouse_config_fixture.name\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            lighthouse_config_fixture.api_key\n+        )\n+\n+    def test_lighthouse_config_update(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        update_payload = {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"id\": str(lighthouse_config_fixture.id),\n+                \"attributes\": {\n+                    \"name\": \"Updated Config\",\n+                    \"model\": \"gpt-4o-mini\",\n+                    \"temperature\": 0.5,\n+                },\n+            }\n+        }\n+        response = authenticated_client.patch(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            ),\n+            data=update_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Updated Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o-mini\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.5\n+\n+    def test_lighthouse_config_delete(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        response = authenticated_client.delete(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_204_NO_CONTENT\n+        # Verify deletion\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_404_NOT_FOUND\n+\n+    @patch(\"api.v1.views.openai.OpenAI\")\n+    def test_lighthouse_config_check_connection(\n+        self, mock_openai, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        # Mock successful API call\n+        mock_client = Mock()\n+        mock_client.models.list.return_value = Mock(\n+            data=[Mock(id=\"gpt-4o\"), Mock(id=\"gpt-4o-mini\")]\n+        )\n+        mock_openai.return_value = mock_client\n+        # Check connection\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-check-connection\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"detail\"] == \"Connection successful!\"\n+        assert \"gpt-4o\" in response.json()[\"data\"][\"available_models\"]\n+        assert \"gpt-4o-mini\" in response.json()[\"data\"][\"available_models\"]\n+\n+    def test_lighthouse_config_get_key(\n+        self, authenticated_client, lighthouse_config_fixture, valid_config_payload\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        expected_api_key = valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+            + \"?fields[lighthouse-config]=api_key\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"attributes\"][\"api_key\"] == expected_api_key\n+\n+    def test_lighthouse_config_filters(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test name filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\")\n+            + \"?filter[name]=\"\n+            + lighthouse_config_fixture.name\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test model filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[model]=gpt-4o\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test is_active filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[is_active]=true\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1",
        "comment_created_at": "2025-06-05T11:31:18+00:00",
        "comment_author": "Chan9390",
        "comment_body": "I have updated the tests to use parametrization wherever possible. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2120860135",
    "pr_number": 7848,
    "pr_file": "api/src/backend/api/tests/test_views.py",
    "created_at": "2025-06-02T11:27:51+00:00",
    "commented_code": "{f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"OpenAI\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(reverse(\"lighthouseconfig-list\"))\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert (\n+            data[\"attributes\"][\"name\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"name\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"model\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"model\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"temperature\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"temperature\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"max_tokens\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"max_tokens\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"business_context\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"business_context\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"is_active\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"is_active\"]\n+        )\n+        # Check that API key is masked with asterisks only\n+        masked_api_key = data[\"attributes\"][\"api_key\"]\n+        assert all(\n+            c == \"*\" for c in masked_api_key\n+        ), \"API key should contain only asterisks\"\n+\n+    def test_lighthouse_config_create_invalid_name_too_short(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that name validation fails when too short\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"name\"] = \"T\"  # Too short\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_api_key_format(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that API key validation fails with invalid format\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"api_key\"] = \"invalid-key\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_model(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that model validation fails with invalid model name\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"model\"] = \"invalid-model\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"model\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_temperature_range(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that temperature validation fails when out of range\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"temperature\"] = 2.0  # Out of range\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"temperature\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_max_tokens(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that max_tokens validation fails with invalid value\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"max_tokens\"] = -1  # Invalid value\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"max_tokens\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_missing_required_fields(\n+        self, authenticated_client\n+    ):\n+        \"\"\"Test that validation fails when required fields are missing\"\"\"\n+        payload = {\"data\": {\"type\": \"lighthouse-config\", \"attributes\": {}}}\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        # Check for required fields\n+        required_fields = [\"name\", \"api_key\", \"model\"]\n+        for field in required_fields:\n+            assert any(field in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"Lighthouse configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        \"\"\"Test retrieving a lighthouse config\"\"\"\n+        response = authenticated_client.get(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            )\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == lighthouse_config_fixture.name\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            lighthouse_config_fixture.api_key\n+        )\n+\n+    def test_lighthouse_config_update(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        update_payload = {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"id\": str(lighthouse_config_fixture.id),\n+                \"attributes\": {\n+                    \"name\": \"Updated Config\",\n+                    \"model\": \"gpt-4o-mini\",\n+                    \"temperature\": 0.5,\n+                },\n+            }\n+        }\n+        response = authenticated_client.patch(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            ),\n+            data=update_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Updated Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o-mini\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.5\n+\n+    def test_lighthouse_config_delete(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        response = authenticated_client.delete(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_204_NO_CONTENT\n+        # Verify deletion\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_404_NOT_FOUND\n+\n+    @patch(\"api.v1.views.openai.OpenAI\")\n+    def test_lighthouse_config_check_connection(\n+        self, mock_openai, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        # Mock successful API call\n+        mock_client = Mock()\n+        mock_client.models.list.return_value = Mock(\n+            data=[Mock(id=\"gpt-4o\"), Mock(id=\"gpt-4o-mini\")]\n+        )\n+        mock_openai.return_value = mock_client\n+        # Check connection\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-check-connection\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"detail\"] == \"Connection successful!\"\n+        assert \"gpt-4o\" in response.json()[\"data\"][\"available_models\"]\n+        assert \"gpt-4o-mini\" in response.json()[\"data\"][\"available_models\"]\n+\n+    def test_lighthouse_config_get_key(\n+        self, authenticated_client, lighthouse_config_fixture, valid_config_payload\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        expected_api_key = valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+            + \"?fields[lighthouse-config]=api_key\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"attributes\"][\"api_key\"] == expected_api_key\n+\n+    def test_lighthouse_config_filters(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test name filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\")\n+            + \"?filter[name]=\"\n+            + lighthouse_config_fixture.name\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test model filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[model]=gpt-4o\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test is_active filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[is_active]=true\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+\n+    def test_lighthouse_config_sorting(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test sorting by name\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?sort=name\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test sorting by inserted_at\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?sort=-inserted_at\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "2120860135",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7848,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2120860135",
        "commented_code": "@@ -5458,3 +5458,331 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"OpenAI\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(reverse(\"lighthouseconfig-list\"))\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert (\n+            data[\"attributes\"][\"name\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"name\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"model\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"model\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"temperature\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"temperature\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"max_tokens\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"max_tokens\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"business_context\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"business_context\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"is_active\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"is_active\"]\n+        )\n+        # Check that API key is masked with asterisks only\n+        masked_api_key = data[\"attributes\"][\"api_key\"]\n+        assert all(\n+            c == \"*\" for c in masked_api_key\n+        ), \"API key should contain only asterisks\"\n+\n+    def test_lighthouse_config_create_invalid_name_too_short(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that name validation fails when too short\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"name\"] = \"T\"  # Too short\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_api_key_format(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that API key validation fails with invalid format\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"api_key\"] = \"invalid-key\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_model(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that model validation fails with invalid model name\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"model\"] = \"invalid-model\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"model\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_temperature_range(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that temperature validation fails when out of range\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"temperature\"] = 2.0  # Out of range\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"temperature\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_max_tokens(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that max_tokens validation fails with invalid value\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"max_tokens\"] = -1  # Invalid value\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"max_tokens\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_missing_required_fields(\n+        self, authenticated_client\n+    ):\n+        \"\"\"Test that validation fails when required fields are missing\"\"\"\n+        payload = {\"data\": {\"type\": \"lighthouse-config\", \"attributes\": {}}}\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        # Check for required fields\n+        required_fields = [\"name\", \"api_key\", \"model\"]\n+        for field in required_fields:\n+            assert any(field in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"Lighthouse configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        \"\"\"Test retrieving a lighthouse config\"\"\"\n+        response = authenticated_client.get(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            )\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == lighthouse_config_fixture.name\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            lighthouse_config_fixture.api_key\n+        )\n+\n+    def test_lighthouse_config_update(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        update_payload = {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"id\": str(lighthouse_config_fixture.id),\n+                \"attributes\": {\n+                    \"name\": \"Updated Config\",\n+                    \"model\": \"gpt-4o-mini\",\n+                    \"temperature\": 0.5,\n+                },\n+            }\n+        }\n+        response = authenticated_client.patch(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            ),\n+            data=update_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Updated Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o-mini\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.5\n+\n+    def test_lighthouse_config_delete(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        response = authenticated_client.delete(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_204_NO_CONTENT\n+        # Verify deletion\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_404_NOT_FOUND\n+\n+    @patch(\"api.v1.views.openai.OpenAI\")\n+    def test_lighthouse_config_check_connection(\n+        self, mock_openai, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        # Mock successful API call\n+        mock_client = Mock()\n+        mock_client.models.list.return_value = Mock(\n+            data=[Mock(id=\"gpt-4o\"), Mock(id=\"gpt-4o-mini\")]\n+        )\n+        mock_openai.return_value = mock_client\n+        # Check connection\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-check-connection\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"detail\"] == \"Connection successful!\"\n+        assert \"gpt-4o\" in response.json()[\"data\"][\"available_models\"]\n+        assert \"gpt-4o-mini\" in response.json()[\"data\"][\"available_models\"]\n+\n+    def test_lighthouse_config_get_key(\n+        self, authenticated_client, lighthouse_config_fixture, valid_config_payload\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        expected_api_key = valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+            + \"?fields[lighthouse-config]=api_key\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"attributes\"][\"api_key\"] == expected_api_key\n+\n+    def test_lighthouse_config_filters(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test name filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\")\n+            + \"?filter[name]=\"\n+            + lighthouse_config_fixture.name\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test model filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[model]=gpt-4o\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test is_active filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[is_active]=true\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+\n+    def test_lighthouse_config_sorting(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test sorting by name\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?sort=name\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test sorting by inserted_at\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?sort=-inserted_at\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1",
        "comment_created_at": "2025-06-02T11:27:51+00:00",
        "comment_author": "vicferpoy",
        "comment_body": "Use pytest parametrization here, please. Easier to read, maintain and add new tests if required.",
        "pr_file_module": null
      },
      {
        "comment_id": "2128621008",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7848,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2120860135",
        "commented_code": "@@ -5458,3 +5458,331 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"OpenAI\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(reverse(\"lighthouseconfig-list\"))\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert (\n+            data[\"attributes\"][\"name\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"name\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"model\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"model\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"temperature\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"temperature\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"max_tokens\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"max_tokens\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"business_context\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"business_context\"]\n+        )\n+        assert (\n+            data[\"attributes\"][\"is_active\"]\n+            == valid_config_payload[\"data\"][\"attributes\"][\"is_active\"]\n+        )\n+        # Check that API key is masked with asterisks only\n+        masked_api_key = data[\"attributes\"][\"api_key\"]\n+        assert all(\n+            c == \"*\" for c in masked_api_key\n+        ), \"API key should contain only asterisks\"\n+\n+    def test_lighthouse_config_create_invalid_name_too_short(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that name validation fails when too short\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"name\"] = \"T\"  # Too short\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_api_key_format(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that API key validation fails with invalid format\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"api_key\"] = \"invalid-key\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_model(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that model validation fails with invalid model name\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"model\"] = \"invalid-model\"\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"model\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_temperature_range(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that temperature validation fails when out of range\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"temperature\"] = 2.0  # Out of range\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"temperature\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_invalid_max_tokens(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        \"\"\"Test that max_tokens validation fails with invalid value\"\"\"\n+        payload = valid_config_payload.copy()\n+        payload[\"data\"][\"attributes\"][\"max_tokens\"] = -1  # Invalid value\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"max_tokens\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_missing_required_fields(\n+        self, authenticated_client\n+    ):\n+        \"\"\"Test that validation fails when required fields are missing\"\"\"\n+        payload = {\"data\": {\"type\": \"lighthouse-config\", \"attributes\": {}}}\n+\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        # Check for required fields\n+        required_fields = [\"name\", \"api_key\", \"model\"]\n+        for field in required_fields:\n+            assert any(field in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            reverse(\"lighthouseconfig-list\"),\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"Lighthouse configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        \"\"\"Test retrieving a lighthouse config\"\"\"\n+        response = authenticated_client.get(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            )\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == lighthouse_config_fixture.name\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            lighthouse_config_fixture.api_key\n+        )\n+\n+    def test_lighthouse_config_update(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        update_payload = {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"id\": str(lighthouse_config_fixture.id),\n+                \"attributes\": {\n+                    \"name\": \"Updated Config\",\n+                    \"model\": \"gpt-4o-mini\",\n+                    \"temperature\": 0.5,\n+                },\n+            }\n+        }\n+        response = authenticated_client.patch(\n+            reverse(\n+                \"lighthouseconfig-detail\", kwargs={\"pk\": lighthouse_config_fixture.id}\n+            ),\n+            data=update_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Updated Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o-mini\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.5\n+\n+    def test_lighthouse_config_delete(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        response = authenticated_client.delete(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_204_NO_CONTENT\n+        # Verify deletion\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_404_NOT_FOUND\n+\n+    @patch(\"api.v1.views.openai.OpenAI\")\n+    def test_lighthouse_config_check_connection(\n+        self, mock_openai, authenticated_client, lighthouse_config_fixture\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        # Mock successful API call\n+        mock_client = Mock()\n+        mock_client.models.list.return_value = Mock(\n+            data=[Mock(id=\"gpt-4o\"), Mock(id=\"gpt-4o-mini\")]\n+        )\n+        mock_openai.return_value = mock_client\n+        # Check connection\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-check-connection\", kwargs={\"pk\": config_id})\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"detail\"] == \"Connection successful!\"\n+        assert \"gpt-4o\" in response.json()[\"data\"][\"available_models\"]\n+        assert \"gpt-4o-mini\" in response.json()[\"data\"][\"available_models\"]\n+\n+    def test_lighthouse_config_get_key(\n+        self, authenticated_client, lighthouse_config_fixture, valid_config_payload\n+    ):\n+        config_id = lighthouse_config_fixture.id\n+        expected_api_key = valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-detail\", kwargs={\"pk\": config_id})\n+            + \"?fields[lighthouse-config]=api_key\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"][\"attributes\"][\"api_key\"] == expected_api_key\n+\n+    def test_lighthouse_config_filters(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test name filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\")\n+            + \"?filter[name]=\"\n+            + lighthouse_config_fixture.name\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test model filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[model]=gpt-4o\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test is_active filter\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?filter[is_active]=true\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+\n+    def test_lighthouse_config_sorting(\n+        self, authenticated_client, lighthouse_config_fixture\n+    ):\n+        # Test sorting by name\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?sort=name\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1\n+        # Test sorting by inserted_at\n+        response = authenticated_client.get(\n+            reverse(\"lighthouseconfig-list\") + \"?sort=-inserted_at\"\n+        )\n+        assert response.status_code == status.HTTP_200_OK\n+        assert len(response.json()[\"data\"]) == 1",
        "comment_created_at": "2025-06-05T11:31:55+00:00",
        "comment_author": "Chan9390",
        "comment_body": "I have updated tests to use parametrization wherever possible. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058665036",
    "pr_number": 7508,
    "pr_file": "api/src/backend/api/tests/test_views.py",
    "created_at": "2025-04-24T15:04:01+00:00",
    "commented_code": "{f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"Test Config\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(\"/api/v1/lighthouse-config/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.7\n+        assert data[\"attributes\"][\"max_tokens\"] == 4000\n+        assert data[\"attributes\"][\"business_context\"] == \"Test business context\"\n+        assert data[\"attributes\"][\"is_active\"] is True\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"AI configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_create_invalid(\n+        self, authenticated_client, invalid_config_payload\n+    ):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=invalid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        config_id = response.json()[\"data\"][\"id\"]\n+\n+        # Retrieve config\n+        response = authenticated_client.get(f\"/api/v1/lighthouse-config/{config_id}/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )",
    "repo_full_name": "prowler-cloud/prowler",
    "discussion_comments": [
      {
        "comment_id": "2058665036",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7508,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2058665036",
        "commented_code": "@@ -5041,3 +5041,277 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"Test Config\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(\"/api/v1/lighthouse-config/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.7\n+        assert data[\"attributes\"][\"max_tokens\"] == 4000\n+        assert data[\"attributes\"][\"business_context\"] == \"Test business context\"\n+        assert data[\"attributes\"][\"is_active\"] is True\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"AI configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_create_invalid(\n+        self, authenticated_client, invalid_config_payload\n+    ):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=invalid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        config_id = response.json()[\"data\"][\"id\"]\n+\n+        # Retrieve config\n+        response = authenticated_client.get(f\"/api/v1/lighthouse-config/{config_id}/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )",
        "comment_created_at": "2025-04-24T15:04:01+00:00",
        "comment_author": "vicferpoy",
        "comment_body": "This is not a unit test if you depend on a POST for a retrieval. Use pytest fixtures instead so you already have items to work with in the database when the test begins.",
        "pr_file_module": null
      },
      {
        "comment_id": "2058667757",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7508,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2058665036",
        "commented_code": "@@ -5041,3 +5041,277 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"Test Config\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(\"/api/v1/lighthouse-config/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.7\n+        assert data[\"attributes\"][\"max_tokens\"] == 4000\n+        assert data[\"attributes\"][\"business_context\"] == \"Test business context\"\n+        assert data[\"attributes\"][\"is_active\"] is True\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"AI configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_create_invalid(\n+        self, authenticated_client, invalid_config_payload\n+    ):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=invalid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        config_id = response.json()[\"data\"][\"id\"]\n+\n+        # Retrieve config\n+        response = authenticated_client.get(f\"/api/v1/lighthouse-config/{config_id}/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )",
        "comment_created_at": "2025-04-24T15:05:26+00:00",
        "comment_author": "vicferpoy",
        "comment_body": "Apply this principle on every other test, please.",
        "pr_file_module": null
      },
      {
        "comment_id": "2066702547",
        "repo_full_name": "prowler-cloud/prowler",
        "pr_number": 7508,
        "pr_file": "api/src/backend/api/tests/test_views.py",
        "discussion_id": "2058665036",
        "commented_code": "@@ -5041,3 +5041,277 @@ def test_integrations_filters_invalid(self, authenticated_client, filter_name):\n             {f\"filter[{filter_name}]\": \"whatever\"},\n         )\n         assert response.status_code == status.HTTP_400_BAD_REQUEST\n+\n+\n+@pytest.mark.django_db\n+class TestLighthouseConfigViewSet:\n+    @pytest.fixture\n+    def valid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"Test Config\",\n+                    \"api_key\": \"sk-test1234567890T3BlbkFJtest1234567890\",\n+                    \"model\": \"gpt-4o\",\n+                    \"temperature\": 0.7,\n+                    \"max_tokens\": 4000,\n+                    \"business_context\": \"Test business context\",\n+                    \"is_active\": True,\n+                },\n+            }\n+        }\n+\n+    @pytest.fixture\n+    def invalid_config_payload(self):\n+        return {\n+            \"data\": {\n+                \"type\": \"lighthouse-config\",\n+                \"attributes\": {\n+                    \"name\": \"T\",  # Too short\n+                    \"api_key\": \"invalid-key\",  # Invalid format\n+                    \"model\": \"invalid-model\",\n+                    \"temperature\": 2.0,  # Invalid range\n+                    \"max_tokens\": -1,  # Invalid value\n+                },\n+            }\n+        }\n+\n+    def test_lighthouse_config_list(self, authenticated_client):\n+        response = authenticated_client.get(\"/api/v1/lighthouse-config/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        assert response.json()[\"data\"] == []\n+\n+    def test_lighthouse_config_create(self, authenticated_client, valid_config_payload):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"model\"] == \"gpt-4o\"\n+        assert data[\"attributes\"][\"temperature\"] == 0.7\n+        assert data[\"attributes\"][\"max_tokens\"] == 4000\n+        assert data[\"attributes\"][\"business_context\"] == \"Test business context\"\n+        assert data[\"attributes\"][\"is_active\"] is True\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )\n+\n+    def test_lighthouse_config_create_duplicate(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create first config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+\n+        # Try to create second config for same tenant\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        assert (\n+            \"AI configuration already exists for this tenant\"\n+            in response.json()[\"errors\"][0][\"detail\"]\n+        )\n+\n+    def test_lighthouse_config_create_invalid(\n+        self, authenticated_client, invalid_config_payload\n+    ):\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=invalid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_400_BAD_REQUEST\n+        errors = response.json()[\"errors\"]\n+        assert any(\"name\" in error[\"source\"][\"pointer\"] for error in errors)\n+        assert any(\"api_key\" in error[\"source\"][\"pointer\"] for error in errors)\n+\n+    def test_lighthouse_config_retrieve(\n+        self, authenticated_client, valid_config_payload\n+    ):\n+        # Create config\n+        response = authenticated_client.post(\n+            \"/api/v1/lighthouse-config/\",\n+            data=valid_config_payload,\n+            content_type=API_JSON_CONTENT_TYPE,\n+        )\n+        assert response.status_code == status.HTTP_201_CREATED\n+        config_id = response.json()[\"data\"][\"id\"]\n+\n+        # Retrieve config\n+        response = authenticated_client.get(f\"/api/v1/lighthouse-config/{config_id}/\")\n+        assert response.status_code == status.HTTP_200_OK\n+        data = response.json()[\"data\"]\n+        assert data[\"attributes\"][\"name\"] == \"Test Config\"\n+        assert data[\"attributes\"][\"api_key\"] == \"*\" * len(\n+            valid_config_payload[\"data\"][\"attributes\"][\"api_key\"]\n+        )",
        "comment_created_at": "2025-04-29T14:29:17+00:00",
        "comment_author": "Chan9390",
        "comment_body": "I've updated the tests, please check. Thanks!",
        "pr_file_module": null
      }
    ]
  }
]