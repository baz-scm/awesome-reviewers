[
  {
    "discussion_id": "1971468232",
    "pr_number": 11468,
    "pr_file": "docs/concepts/serialization.md",
    "created_at": "2025-02-26T12:04:48+00:00",
    "commented_code": "`if TYPE_CHECKING:` block:\n \n ```python\n+from __future__ import annotations",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1971468232",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/concepts/serialization.md",
        "discussion_id": "1971468232",
        "commented_code": "@@ -312,6 +312,8 @@ If you want to do this and still get proper type-checking for this method, you c\n `if TYPE_CHECKING:` block:\n \n ```python\n+from __future__ import annotations",
        "comment_created_at": "2025-02-26T12:04:48+00:00",
        "comment_author": "Viicos",
        "comment_body": "Probably for the serialization docs rewrite, but I don't think we should have this workaround documented. Having models serialized as something else than `dict` is uncommon, and the proposed solution isn't future proof (like in this case, where we make changes to the signature, this would break type checking for users using this workaround).",
        "pr_file_module": null
      },
      {
        "comment_id": "1971568180",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/concepts/serialization.md",
        "discussion_id": "1971468232",
        "commented_code": "@@ -312,6 +312,8 @@ If you want to do this and still get proper type-checking for this method, you c\n `if TYPE_CHECKING:` block:\n \n ```python\n+from __future__ import annotations",
        "comment_created_at": "2025-02-26T13:15:24+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "Agreed, good call.",
        "pr_file_module": null
      },
      {
        "comment_id": "1971581413",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/concepts/serialization.md",
        "discussion_id": "1971468232",
        "commented_code": "@@ -312,6 +312,8 @@ If you want to do this and still get proper type-checking for this method, you c\n `if TYPE_CHECKING:` block:\n \n ```python\n+from __future__ import annotations",
        "comment_created_at": "2025-02-26T13:24:07+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "I've opened an issue and linked this comment. See https://github.com/pydantic/pydantic/issues/11491",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1905587997",
    "pr_number": 11213,
    "pr_file": "docs/concepts/models.md",
    "created_at": "2025-01-07T15:02:03+00:00",
    "commented_code": "There are some situations where Pydantic does not copy attributes, such as when passing models &mdash; we use the\n     model as is. You can override this behaviour by setting\n     [`model_config['revalidate_instances'] = 'always'`](../api/config.md#pydantic.config.ConfigDict).\n-\n-## Extra fields\n-\n-By default, Pydantic models won't error when you provide data for unrecognized fields, they will just be ignored:\n-\n-```python\n-from pydantic import BaseModel\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-\n-m = Model(x=1, y='a')\n-assert m.model_dump() == {'x': 1}\n-```\n-\n-If you want this to raise an error, you can set the [`extra`][pydantic.ConfigDict.extra] configuration\n-value to `'forbid'`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='forbid')\n-\n-\n-try:\n-    Model(x=1, y='a')\n-except ValidationError as exc:\n-    print(exc)\n-    \"\"\"\n-    1 validation error for Model\n-    y\n-      Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]\n-    \"\"\"\n-```\n-\n-To instead preserve any extra data provided, you can set [`extra`][pydantic.ConfigDict.extra] to `'allow'`.\n-The extra fields will then be stored in `BaseModel.__pydantic_extra__`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='allow')\n-\n-\n-m = Model(x=1, y='a')\n-assert m.__pydantic_extra__ == {'y': 'a'}\n-```\n-\n-By default, no validation will be applied to these extra items, but you can set a type for the values by overriding\n-the type annotation for `__pydantic_extra__`:",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1905587997",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11213,
        "pr_file": "docs/concepts/models.md",
        "discussion_id": "1905587997",
        "commented_code": "@@ -1692,100 +1741,3 @@ print(f'{id(c1.arr) == id(c2.arr)=}')\n     There are some situations where Pydantic does not copy attributes, such as when passing models &mdash; we use the\n     model as is. You can override this behaviour by setting\n     [`model_config['revalidate_instances'] = 'always'`](../api/config.md#pydantic.config.ConfigDict).\n-\n-## Extra fields\n-\n-By default, Pydantic models won't error when you provide data for unrecognized fields, they will just be ignored:\n-\n-```python\n-from pydantic import BaseModel\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-\n-m = Model(x=1, y='a')\n-assert m.model_dump() == {'x': 1}\n-```\n-\n-If you want this to raise an error, you can set the [`extra`][pydantic.ConfigDict.extra] configuration\n-value to `'forbid'`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='forbid')\n-\n-\n-try:\n-    Model(x=1, y='a')\n-except ValidationError as exc:\n-    print(exc)\n-    \"\"\"\n-    1 validation error for Model\n-    y\n-      Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]\n-    \"\"\"\n-```\n-\n-To instead preserve any extra data provided, you can set [`extra`][pydantic.ConfigDict.extra] to `'allow'`.\n-The extra fields will then be stored in `BaseModel.__pydantic_extra__`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='allow')\n-\n-\n-m = Model(x=1, y='a')\n-assert m.__pydantic_extra__ == {'y': 'a'}\n-```\n-\n-By default, no validation will be applied to these extra items, but you can set a type for the values by overriding\n-the type annotation for `__pydantic_extra__`:",
        "comment_created_at": "2025-01-07T15:02:03+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "Isn't this something worth including in the conceptual docs?",
        "pr_file_module": null
      },
      {
        "comment_id": "1905605913",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11213,
        "pr_file": "docs/concepts/models.md",
        "discussion_id": "1905587997",
        "commented_code": "@@ -1692,100 +1741,3 @@ print(f'{id(c1.arr) == id(c2.arr)=}')\n     There are some situations where Pydantic does not copy attributes, such as when passing models &mdash; we use the\n     model as is. You can override this behaviour by setting\n     [`model_config['revalidate_instances'] = 'always'`](../api/config.md#pydantic.config.ConfigDict).\n-\n-## Extra fields\n-\n-By default, Pydantic models won't error when you provide data for unrecognized fields, they will just be ignored:\n-\n-```python\n-from pydantic import BaseModel\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-\n-m = Model(x=1, y='a')\n-assert m.model_dump() == {'x': 1}\n-```\n-\n-If you want this to raise an error, you can set the [`extra`][pydantic.ConfigDict.extra] configuration\n-value to `'forbid'`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='forbid')\n-\n-\n-try:\n-    Model(x=1, y='a')\n-except ValidationError as exc:\n-    print(exc)\n-    \"\"\"\n-    1 validation error for Model\n-    y\n-      Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]\n-    \"\"\"\n-```\n-\n-To instead preserve any extra data provided, you can set [`extra`][pydantic.ConfigDict.extra] to `'allow'`.\n-The extra fields will then be stored in `BaseModel.__pydantic_extra__`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='allow')\n-\n-\n-m = Model(x=1, y='a')\n-assert m.__pydantic_extra__ == {'y': 'a'}\n-```\n-\n-By default, no validation will be applied to these extra items, but you can set a type for the values by overriding\n-the type annotation for `__pydantic_extra__`:",
        "comment_created_at": "2025-01-07T15:14:28+00:00",
        "comment_author": "Viicos",
        "comment_body": "I mention it in:\r\n\r\n> - `'allow'`: Providing extra data is allowed and stored in the `__pydantic_extra__` dictionary attribute.\r\n  The `__pydantic_extra__` can explicitly be annotated to provide validation for extra fields.\r\n\r\nI was trying to avoid duplication of documentation, and so the `__pydantic_extra__` example is present in the API docs. Maybe a broader discussion could be _what should live in the concepts/API docs_",
        "pr_file_module": null
      },
      {
        "comment_id": "1905832901",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11213,
        "pr_file": "docs/concepts/models.md",
        "discussion_id": "1905587997",
        "commented_code": "@@ -1692,100 +1741,3 @@ print(f'{id(c1.arr) == id(c2.arr)=}')\n     There are some situations where Pydantic does not copy attributes, such as when passing models &mdash; we use the\n     model as is. You can override this behaviour by setting\n     [`model_config['revalidate_instances'] = 'always'`](../api/config.md#pydantic.config.ConfigDict).\n-\n-## Extra fields\n-\n-By default, Pydantic models won't error when you provide data for unrecognized fields, they will just be ignored:\n-\n-```python\n-from pydantic import BaseModel\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-\n-m = Model(x=1, y='a')\n-assert m.model_dump() == {'x': 1}\n-```\n-\n-If you want this to raise an error, you can set the [`extra`][pydantic.ConfigDict.extra] configuration\n-value to `'forbid'`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='forbid')\n-\n-\n-try:\n-    Model(x=1, y='a')\n-except ValidationError as exc:\n-    print(exc)\n-    \"\"\"\n-    1 validation error for Model\n-    y\n-      Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]\n-    \"\"\"\n-```\n-\n-To instead preserve any extra data provided, you can set [`extra`][pydantic.ConfigDict.extra] to `'allow'`.\n-The extra fields will then be stored in `BaseModel.__pydantic_extra__`:\n-\n-```python\n-from pydantic import BaseModel, ConfigDict\n-\n-\n-class Model(BaseModel):\n-    x: int\n-\n-    model_config = ConfigDict(extra='allow')\n-\n-\n-m = Model(x=1, y='a')\n-assert m.__pydantic_extra__ == {'y': 'a'}\n-```\n-\n-By default, no validation will be applied to these extra items, but you can set a type for the values by overriding\n-the type annotation for `__pydantic_extra__`:",
        "comment_created_at": "2025-01-07T17:38:38+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "Agreed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1811031658",
    "pr_number": 10686,
    "pr_file": "docs/concepts/dataclasses.md",
    "created_at": "2024-10-22T16:19:11+00:00",
    "commented_code": "\"\"\"\n ```\n \n-`pydantic.dataclasses.dataclass`'s arguments are the same as the standard decorator, except one extra\n-keyword argument `config` which has the same meaning as [model_config][pydantic.config.ConfigDict].\n-\n-!!! warning\n-    After v1.2, [The Mypy plugin](../integrations/mypy.md) must be installed to type check _pydantic_ dataclasses.\n-\n-For more information about combining validators with dataclasses, see\n-[dataclass validators](validators.md#dataclass-validators).\n+The Pydantic `@dataclass` decorator accepts the same arguments as the standard decorator, with the addition\n+of a `config` parameter.\n \n ## Dataclass config\n \n-If you want to modify the `config` like you would with a `BaseModel`, you have two options:\n+If you want to modify the configuration like you would with a [`BaseModel`][pydantic.BaseModel], you have two options:\n \n-* Apply config to the dataclass decorator as a dict\n-* Use `ConfigDict` as the config\n+* Use the `config` argument of the decorator.\n+* Define the configuration with the `__pydantic_config__` attribute.\n \n ```py\n from pydantic import ConfigDict\n from pydantic.dataclasses import dataclass\n \n \n-# Option 1 - use directly a dict\n-# Note: `mypy` will still raise typo error\n-@dataclass(config=dict(validate_assignment=True))  # (1)!\n+# Option 1 -- using the decorator argument:\n+@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\n class MyDataclass1:\n     a: int\n \n \n-# Option 2 - use `ConfigDict`\n-# (same as before at runtime since it's a `TypedDict` but with intellisense)\n-@dataclass(config=ConfigDict(validate_assignment=True))\n+# Option 2 -- using an attribute:\n+@dataclass\n class MyDataclass2:\n     a: int\n+\n+    __pydantic_config__ = ConfigDict(validate_assignment=True)\n ```\n \n-1. You can read more about `validate_assignment` in [API reference][pydantic.config.ConfigDict.validate_assignment].\n+1. You can read more about `validate_assignment` in the [API reference][pydantic.config.ConfigDict.validate_assignment].\n \n !!! note\n-    Pydantic dataclasses support [`extra`][pydantic.config.ConfigDict.extra] configuration to `ignore`, `forbid`, or\n-    `allow` extra fields passed to the initializer. However, some default behavior of stdlib dataclasses may prevail.\n-    For example, any extra fields present on a Pydantic dataclass using `extra='allow'` are omitted when the dataclass\n-    is `print`ed.\n+    While Pydantic dataclasses support the [`extra`][pydantic.config.ConfigDict.extra] configuration value, some default\n+    behavior of stdlib dataclasses may prevail. For example, any extra fields present on a Pydantic dataclass with\n+    [`extra`][pydantic.config.ConfigDict.extra] set to `'allow'` are omitted in the dataclass' string representation.\n \n ## Nested dataclasses",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1811031658",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10686,
        "pr_file": "docs/concepts/dataclasses.md",
        "discussion_id": "1811031658",
        "commented_code": "@@ -100,52 +100,45 @@ print(TypeAdapter(User).json_schema())\n \"\"\"\n ```\n \n-`pydantic.dataclasses.dataclass`'s arguments are the same as the standard decorator, except one extra\n-keyword argument `config` which has the same meaning as [model_config][pydantic.config.ConfigDict].\n-\n-!!! warning\n-    After v1.2, [The Mypy plugin](../integrations/mypy.md) must be installed to type check _pydantic_ dataclasses.\n-\n-For more information about combining validators with dataclasses, see\n-[dataclass validators](validators.md#dataclass-validators).\n+The Pydantic `@dataclass` decorator accepts the same arguments as the standard decorator, with the addition\n+of a `config` parameter.\n \n ## Dataclass config\n \n-If you want to modify the `config` like you would with a `BaseModel`, you have two options:\n+If you want to modify the configuration like you would with a [`BaseModel`][pydantic.BaseModel], you have two options:\n \n-* Apply config to the dataclass decorator as a dict\n-* Use `ConfigDict` as the config\n+* Use the `config` argument of the decorator.\n+* Define the configuration with the `__pydantic_config__` attribute.\n \n ```py\n from pydantic import ConfigDict\n from pydantic.dataclasses import dataclass\n \n \n-# Option 1 - use directly a dict\n-# Note: `mypy` will still raise typo error\n-@dataclass(config=dict(validate_assignment=True))  # (1)!\n+# Option 1 -- using the decorator argument:\n+@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\n class MyDataclass1:\n     a: int\n \n \n-# Option 2 - use `ConfigDict`\n-# (same as before at runtime since it's a `TypedDict` but with intellisense)\n-@dataclass(config=ConfigDict(validate_assignment=True))\n+# Option 2 -- using an attribute:\n+@dataclass\n class MyDataclass2:\n     a: int\n+\n+    __pydantic_config__ = ConfigDict(validate_assignment=True)\n ```\n \n-1. You can read more about `validate_assignment` in [API reference][pydantic.config.ConfigDict.validate_assignment].\n+1. You can read more about `validate_assignment` in the [API reference][pydantic.config.ConfigDict.validate_assignment].\n \n !!! note\n-    Pydantic dataclasses support [`extra`][pydantic.config.ConfigDict.extra] configuration to `ignore`, `forbid`, or\n-    `allow` extra fields passed to the initializer. However, some default behavior of stdlib dataclasses may prevail.\n-    For example, any extra fields present on a Pydantic dataclass using `extra='allow'` are omitted when the dataclass\n-    is `print`ed.\n+    While Pydantic dataclasses support the [`extra`][pydantic.config.ConfigDict.extra] configuration value, some default\n+    behavior of stdlib dataclasses may prevail. For example, any extra fields present on a Pydantic dataclass with\n+    [`extra`][pydantic.config.ConfigDict.extra] set to `'allow'` are omitted in the dataclass' string representation.\n \n ## Nested dataclasses",
        "comment_created_at": "2024-10-22T16:19:11+00:00",
        "comment_author": "Viicos",
        "comment_body": "Can we simplify this section and the following one with a single _Similarly to Pydantic models, nested dataclasses and generics are supported_ (and we refer to the relevant model documentation)? Imo the added value is quite low here, we would expect the examples to work anyway",
        "pr_file_module": null
      },
      {
        "comment_id": "1812468617",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10686,
        "pr_file": "docs/concepts/dataclasses.md",
        "discussion_id": "1811031658",
        "commented_code": "@@ -100,52 +100,45 @@ print(TypeAdapter(User).json_schema())\n \"\"\"\n ```\n \n-`pydantic.dataclasses.dataclass`'s arguments are the same as the standard decorator, except one extra\n-keyword argument `config` which has the same meaning as [model_config][pydantic.config.ConfigDict].\n-\n-!!! warning\n-    After v1.2, [The Mypy plugin](../integrations/mypy.md) must be installed to type check _pydantic_ dataclasses.\n-\n-For more information about combining validators with dataclasses, see\n-[dataclass validators](validators.md#dataclass-validators).\n+The Pydantic `@dataclass` decorator accepts the same arguments as the standard decorator, with the addition\n+of a `config` parameter.\n \n ## Dataclass config\n \n-If you want to modify the `config` like you would with a `BaseModel`, you have two options:\n+If you want to modify the configuration like you would with a [`BaseModel`][pydantic.BaseModel], you have two options:\n \n-* Apply config to the dataclass decorator as a dict\n-* Use `ConfigDict` as the config\n+* Use the `config` argument of the decorator.\n+* Define the configuration with the `__pydantic_config__` attribute.\n \n ```py\n from pydantic import ConfigDict\n from pydantic.dataclasses import dataclass\n \n \n-# Option 1 - use directly a dict\n-# Note: `mypy` will still raise typo error\n-@dataclass(config=dict(validate_assignment=True))  # (1)!\n+# Option 1 -- using the decorator argument:\n+@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\n class MyDataclass1:\n     a: int\n \n \n-# Option 2 - use `ConfigDict`\n-# (same as before at runtime since it's a `TypedDict` but with intellisense)\n-@dataclass(config=ConfigDict(validate_assignment=True))\n+# Option 2 -- using an attribute:\n+@dataclass\n class MyDataclass2:\n     a: int\n+\n+    __pydantic_config__ = ConfigDict(validate_assignment=True)\n ```\n \n-1. You can read more about `validate_assignment` in [API reference][pydantic.config.ConfigDict.validate_assignment].\n+1. You can read more about `validate_assignment` in the [API reference][pydantic.config.ConfigDict.validate_assignment].\n \n !!! note\n-    Pydantic dataclasses support [`extra`][pydantic.config.ConfigDict.extra] configuration to `ignore`, `forbid`, or\n-    `allow` extra fields passed to the initializer. However, some default behavior of stdlib dataclasses may prevail.\n-    For example, any extra fields present on a Pydantic dataclass using `extra='allow'` are omitted when the dataclass\n-    is `print`ed.\n+    While Pydantic dataclasses support the [`extra`][pydantic.config.ConfigDict.extra] configuration value, some default\n+    behavior of stdlib dataclasses may prevail. For example, any extra fields present on a Pydantic dataclass with\n+    [`extra`][pydantic.config.ConfigDict.extra] set to `'allow'` are omitted in the dataclass' string representation.\n \n ## Nested dataclasses",
        "comment_created_at": "2024-10-23T10:44:01+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "I'm fine with this as long as we link to model docs. Maybe we could add a few other notes as well like json schema, etc.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1805439962",
    "pr_number": 10650,
    "pr_file": "docs/integrations/mypy.md",
    "created_at": "2024-10-17T21:13:22+00:00",
    "commented_code": "With the pydantic mypy plugin, you can fearlessly refactor your models knowing mypy will catch any mistakes\n if your field names or types change.\n \n-There are other benefits too! See below for more details.\n+Note that mypy already supports some features without using the Pydantic plugin, such as synthesizing a `__init__`\n+method for Pydantic models and dataclasses. See the [mypy plugin capabilities](#mypy-plugin-capabilities) for a list\n+of additional features.\n \n-## Using mypy without the plugin\n+## Enabling the Plugin\n \n-You can run your code through mypy with:\n+To enable the plugin, just add `pydantic.mypy` to the list of plugins in your\n+[mypy config file](https://mypy.readthedocs.io/en/latest/config_file.html):\n \n-```bash\n-mypy \\\n-  --ignore-missing-imports \\\n-  --follow-imports=skip \\\n-  --strict-optional \\\n-  pydantic_mypy_test.py\n-```\n+=== \"`mypy.ini`\"\n+\n+    ```ini\n+    [mypy]\n+    plugins = pydantic.mypy\n+    ```\n+\n+=== \"`pyproject.toml`\"\n+\n+    ```toml\n+    [tool.mypy]\n+    plugins = ['pydantic.mypy']\n+    ```\n \n-### Strict Optional\n+!!! note\n+    If you're using `pydantic.v1` models, you'll need to add `pydantic.v1.mypy` to your list of plugins.\n+\n+See the [plugin configuration](#configuring-the-plugin) for more details.\n \n-For your code to pass with `--strict-optional`, you need to use `Optional[]` or an alias of `Optional[]`\n-for all fields with `None` as the default. (This is standard with mypy.)\n+## Supported mypy versions\n \n-### Other Pydantic interfaces\n+Pydantic supports the mypy versions released less than 6 months ago. Older versions may still work with the plugin\n+but won't be tested. The list of released mypy versions can be found [here](https://mypy-lang.org/news.html). Note\n+that the support policy is subject to changes if this becomes too much of an issue on our end.\n \n-Pydantic [dataclasses](../concepts/dataclasses.md) and the [`validate_call` decorator](../concepts/validation_decorator.md)\n-should also work well with mypy.\n+## Mypy plugin capabilities\n \n-## Mypy Plugin Capabilities\n+### Generate a `__init__` signature for Pydantic models\n \n-### Generate a signature for `Model.__init__`\n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If `Config.populate_by_name=True`, the generated signature will use the field names,\n-  rather than aliases.\n-* If `Config.extra='forbid'` and you don't make use of dynamically-determined aliases, the generated signature\n-  will not allow unexpected inputs.\n-* **Optional:** If the [`init_forbid_extra` **plugin setting**](#configuring-the-plugin) is set to `True`, unexpected inputs to\n-  `__init__` will raise errors even if `Config.extra` is not `'forbid'`.\n-* **Optional:** If the [`init_typed` **plugin setting**](#configuring-the-plugin) is set to `True`, the generated signature\n-  will use the types of the model fields (otherwise they will be annotated as `Any` to allow parsing).\n-\n-### Generate a typed signature for `Model.model_construct`\n-* The [`model_construct`](../concepts/models.md#creating-models-without-validation) method is an alternative to `__init__`\n-  when input data is known to be valid and should not be parsed. Because this method performs no runtime validation,\n-  static checking is important to detect errors.\n-\n-### Respect `Config.frozen`\n-* If `Config.frozen` is `True`, you'll get a mypy error if you try to change\n-  the value of a model field; cf. [faux immutability](../concepts/models.md#faux-immutability).\n-\n-### Generate a signature for `dataclasses`\n-* classes decorated with [`@pydantic.dataclasses.dataclass`](../concepts/dataclasses.md) are type checked the same as standard Python dataclasses\n-* The `@pydantic.dataclasses.dataclass` decorator accepts a `config` keyword argument which has the same meaning as [the `Config` sub-class](../concepts/config.md).\n+* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+  `True`, the generated signature will use the field names rather than aliases.\n+* The [`init_forbid_extra`](#init_forbid_extra) and [`init_typed`](#init_typed) plugin configuration\n+  values can further fine-tune the synthesized `__init__` method.",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1805439962",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10650,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1805439962",
        "commented_code": "@@ -46,162 +47,159 @@ But [with the plugin enabled](#enabling-the-plugin), it gives the correct error:\n With the pydantic mypy plugin, you can fearlessly refactor your models knowing mypy will catch any mistakes\n if your field names or types change.\n \n-There are other benefits too! See below for more details.\n+Note that mypy already supports some features without using the Pydantic plugin, such as synthesizing a `__init__`\n+method for Pydantic models and dataclasses. See the [mypy plugin capabilities](#mypy-plugin-capabilities) for a list\n+of additional features.\n \n-## Using mypy without the plugin\n+## Enabling the Plugin\n \n-You can run your code through mypy with:\n+To enable the plugin, just add `pydantic.mypy` to the list of plugins in your\n+[mypy config file](https://mypy.readthedocs.io/en/latest/config_file.html):\n \n-```bash\n-mypy \\\n-  --ignore-missing-imports \\\n-  --follow-imports=skip \\\n-  --strict-optional \\\n-  pydantic_mypy_test.py\n-```\n+=== \"`mypy.ini`\"\n+\n+    ```ini\n+    [mypy]\n+    plugins = pydantic.mypy\n+    ```\n+\n+=== \"`pyproject.toml`\"\n+\n+    ```toml\n+    [tool.mypy]\n+    plugins = ['pydantic.mypy']\n+    ```\n \n-### Strict Optional\n+!!! note\n+    If you're using `pydantic.v1` models, you'll need to add `pydantic.v1.mypy` to your list of plugins.\n+\n+See the [plugin configuration](#configuring-the-plugin) for more details.\n \n-For your code to pass with `--strict-optional`, you need to use `Optional[]` or an alias of `Optional[]`\n-for all fields with `None` as the default. (This is standard with mypy.)\n+## Supported mypy versions\n \n-### Other Pydantic interfaces\n+Pydantic supports the mypy versions released less than 6 months ago. Older versions may still work with the plugin\n+but won't be tested. The list of released mypy versions can be found [here](https://mypy-lang.org/news.html). Note\n+that the support policy is subject to changes if this becomes too much of an issue on our end.\n \n-Pydantic [dataclasses](../concepts/dataclasses.md) and the [`validate_call` decorator](../concepts/validation_decorator.md)\n-should also work well with mypy.\n+## Mypy plugin capabilities\n \n-## Mypy Plugin Capabilities\n+### Generate a `__init__` signature for Pydantic models\n \n-### Generate a signature for `Model.__init__`\n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If `Config.populate_by_name=True`, the generated signature will use the field names,\n-  rather than aliases.\n-* If `Config.extra='forbid'` and you don't make use of dynamically-determined aliases, the generated signature\n-  will not allow unexpected inputs.\n-* **Optional:** If the [`init_forbid_extra` **plugin setting**](#configuring-the-plugin) is set to `True`, unexpected inputs to\n-  `__init__` will raise errors even if `Config.extra` is not `'forbid'`.\n-* **Optional:** If the [`init_typed` **plugin setting**](#configuring-the-plugin) is set to `True`, the generated signature\n-  will use the types of the model fields (otherwise they will be annotated as `Any` to allow parsing).\n-\n-### Generate a typed signature for `Model.model_construct`\n-* The [`model_construct`](../concepts/models.md#creating-models-without-validation) method is an alternative to `__init__`\n-  when input data is known to be valid and should not be parsed. Because this method performs no runtime validation,\n-  static checking is important to detect errors.\n-\n-### Respect `Config.frozen`\n-* If `Config.frozen` is `True`, you'll get a mypy error if you try to change\n-  the value of a model field; cf. [faux immutability](../concepts/models.md#faux-immutability).\n-\n-### Generate a signature for `dataclasses`\n-* classes decorated with [`@pydantic.dataclasses.dataclass`](../concepts/dataclasses.md) are type checked the same as standard Python dataclasses\n-* The `@pydantic.dataclasses.dataclass` decorator accepts a `config` keyword argument which has the same meaning as [the `Config` sub-class](../concepts/config.md).\n+* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+  `True`, the generated signature will use the field names rather than aliases.\n+* The [`init_forbid_extra`](#init_forbid_extra) and [`init_typed`](#init_typed) plugin configuration\n+  values can further fine-tune the synthesized `__init__` method.",
        "comment_created_at": "2024-10-17T21:13:22+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "I feel like the explicit specifications here were helpful - people often ask about `init_typed`...",
        "pr_file_module": null
      },
      {
        "comment_id": "1806205709",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10650,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1805439962",
        "commented_code": "@@ -46,162 +47,159 @@ But [with the plugin enabled](#enabling-the-plugin), it gives the correct error:\n With the pydantic mypy plugin, you can fearlessly refactor your models knowing mypy will catch any mistakes\n if your field names or types change.\n \n-There are other benefits too! See below for more details.\n+Note that mypy already supports some features without using the Pydantic plugin, such as synthesizing a `__init__`\n+method for Pydantic models and dataclasses. See the [mypy plugin capabilities](#mypy-plugin-capabilities) for a list\n+of additional features.\n \n-## Using mypy without the plugin\n+## Enabling the Plugin\n \n-You can run your code through mypy with:\n+To enable the plugin, just add `pydantic.mypy` to the list of plugins in your\n+[mypy config file](https://mypy.readthedocs.io/en/latest/config_file.html):\n \n-```bash\n-mypy \\\n-  --ignore-missing-imports \\\n-  --follow-imports=skip \\\n-  --strict-optional \\\n-  pydantic_mypy_test.py\n-```\n+=== \"`mypy.ini`\"\n+\n+    ```ini\n+    [mypy]\n+    plugins = pydantic.mypy\n+    ```\n+\n+=== \"`pyproject.toml`\"\n+\n+    ```toml\n+    [tool.mypy]\n+    plugins = ['pydantic.mypy']\n+    ```\n \n-### Strict Optional\n+!!! note\n+    If you're using `pydantic.v1` models, you'll need to add `pydantic.v1.mypy` to your list of plugins.\n+\n+See the [plugin configuration](#configuring-the-plugin) for more details.\n \n-For your code to pass with `--strict-optional`, you need to use `Optional[]` or an alias of `Optional[]`\n-for all fields with `None` as the default. (This is standard with mypy.)\n+## Supported mypy versions\n \n-### Other Pydantic interfaces\n+Pydantic supports the mypy versions released less than 6 months ago. Older versions may still work with the plugin\n+but won't be tested. The list of released mypy versions can be found [here](https://mypy-lang.org/news.html). Note\n+that the support policy is subject to changes if this becomes too much of an issue on our end.\n \n-Pydantic [dataclasses](../concepts/dataclasses.md) and the [`validate_call` decorator](../concepts/validation_decorator.md)\n-should also work well with mypy.\n+## Mypy plugin capabilities\n \n-## Mypy Plugin Capabilities\n+### Generate a `__init__` signature for Pydantic models\n \n-### Generate a signature for `Model.__init__`\n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If `Config.populate_by_name=True`, the generated signature will use the field names,\n-  rather than aliases.\n-* If `Config.extra='forbid'` and you don't make use of dynamically-determined aliases, the generated signature\n-  will not allow unexpected inputs.\n-* **Optional:** If the [`init_forbid_extra` **plugin setting**](#configuring-the-plugin) is set to `True`, unexpected inputs to\n-  `__init__` will raise errors even if `Config.extra` is not `'forbid'`.\n-* **Optional:** If the [`init_typed` **plugin setting**](#configuring-the-plugin) is set to `True`, the generated signature\n-  will use the types of the model fields (otherwise they will be annotated as `Any` to allow parsing).\n-\n-### Generate a typed signature for `Model.model_construct`\n-* The [`model_construct`](../concepts/models.md#creating-models-without-validation) method is an alternative to `__init__`\n-  when input data is known to be valid and should not be parsed. Because this method performs no runtime validation,\n-  static checking is important to detect errors.\n-\n-### Respect `Config.frozen`\n-* If `Config.frozen` is `True`, you'll get a mypy error if you try to change\n-  the value of a model field; cf. [faux immutability](../concepts/models.md#faux-immutability).\n-\n-### Generate a signature for `dataclasses`\n-* classes decorated with [`@pydantic.dataclasses.dataclass`](../concepts/dataclasses.md) are type checked the same as standard Python dataclasses\n-* The `@pydantic.dataclasses.dataclass` decorator accepts a `config` keyword argument which has the same meaning as [the `Config` sub-class](../concepts/config.md).\n+* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+  `True`, the generated signature will use the field names rather than aliases.\n+* The [`init_forbid_extra`](#init_forbid_extra) and [`init_typed`](#init_typed) plugin configuration\n+  values can further fine-tune the synthesized `__init__` method.",
        "comment_created_at": "2024-10-18T09:41:37+00:00",
        "comment_author": "Viicos",
        "comment_body": "They can just click on the `[init_typed](#init_typed)` reference, where I added a description for the setting (and same for others). Having things centralized avoids duplication, and having a heading makes it easier to link to when responding on github issues/discussions etc\r\n\r\nTo be clear, the explanation is not removed, just centralized in the configuration options section",
        "pr_file_module": null
      }
    ]
  }
]