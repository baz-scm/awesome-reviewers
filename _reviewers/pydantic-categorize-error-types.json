[
  {
    "discussion_id": "1967574626",
    "pr_number": 11473,
    "pr_file": "docs/errors/errors.md",
    "created_at": "2025-02-24T12:43:51+00:00",
    "commented_code": "\"\"\"\n ```\n \n-### Custom Errors\n-\n-In your custom data types or validators you should use `ValueError` or `AssertionError` to raise errors.\n-\n-See [validators](../concepts/validators.md) for more details on use of the `@validator` decorator.\n-\n-```python\n-from pydantic import BaseModel, ValidationError, field_validator\n-\n-\n-class Model(BaseModel):\n-    foo: str\n-\n-    @field_validator('foo')\n-    def value_must_equal_bar(cls, v):\n-        if v != 'bar':\n-            raise ValueError('value must be \"bar\"')\n-\n-        return v\n-\n-\n-try:\n-    Model(foo='ber')\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    foo\n-      Value error, value must be \"bar\" [type=value_error, input_value='ber', input_type=str]\n-    \"\"\"\n-    print(e.errors())\n-    \"\"\"\n-    [\n-        {\n-            'type': 'value_error',\n-            'loc': ('foo',),\n-            'msg': 'Value error, value must be \"bar\"',\n-            'input': 'ber',\n-            'ctx': {'error': ValueError('value must be \"bar\"')},\n-            'url': 'https://errors.pydantic.dev/2/v/value_error',\n-        }\n-    ]\n-    \"\"\"\n-```\n-\n-You can also use [`PydanticCustomError`][pydantic_core.PydanticCustomError], to fully control the error structure:\n-\n-```python\n-from pydantic_core import PydanticCustomError\n-\n-from pydantic import BaseModel, ValidationError, field_validator\n-\n-\n-class Model(BaseModel):\n-    foo: str\n-\n-    @field_validator('foo')\n-    def value_must_equal_bar(cls, v):\n-        if v != 'bar':\n-            raise PydanticCustomError(\n-                'not_a_bar',\n-                'value is not \"bar\", got \"{wrong_value}\"',\n-                dict(wrong_value=v),\n-            )\n-        return v\n-\n-\n-try:\n-    Model(foo='ber')\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    foo\n-      value is not \"bar\", got \"ber\" [type=not_a_bar, input_value='ber', input_type=str]\n-    \"\"\"\n-```\n-\n ## Error messages\n \n-Pydantic attempts to provide useful default error messages for validation and usage errors.\n-\n-We've provided documentation for default error codes in the following sections:\n+Pydantic attempts to provide useful default error messages for validation and usage errors, which can be found here:\n \n-- [Validation Errors](validation_errors.md)\n-- [Usage Errors](usage_errors.md)\n+- [Validation Errors](validation_errors.md): Errors that happen during data validation.\n+- [Usage Errors](usage_errors.md): Errors that happen when using Pydantic.",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1967574626",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11473,
        "pr_file": "docs/errors/errors.md",
        "discussion_id": "1967574626",
        "commented_code": "@@ -127,92 +129,12 @@ except ValidationError as e:\n     \"\"\"\n ```\n \n-### Custom Errors\n-\n-In your custom data types or validators you should use `ValueError` or `AssertionError` to raise errors.\n-\n-See [validators](../concepts/validators.md) for more details on use of the `@validator` decorator.\n-\n-```python\n-from pydantic import BaseModel, ValidationError, field_validator\n-\n-\n-class Model(BaseModel):\n-    foo: str\n-\n-    @field_validator('foo')\n-    def value_must_equal_bar(cls, v):\n-        if v != 'bar':\n-            raise ValueError('value must be \"bar\"')\n-\n-        return v\n-\n-\n-try:\n-    Model(foo='ber')\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    foo\n-      Value error, value must be \"bar\" [type=value_error, input_value='ber', input_type=str]\n-    \"\"\"\n-    print(e.errors())\n-    \"\"\"\n-    [\n-        {\n-            'type': 'value_error',\n-            'loc': ('foo',),\n-            'msg': 'Value error, value must be \"bar\"',\n-            'input': 'ber',\n-            'ctx': {'error': ValueError('value must be \"bar\"')},\n-            'url': 'https://errors.pydantic.dev/2/v/value_error',\n-        }\n-    ]\n-    \"\"\"\n-```\n-\n-You can also use [`PydanticCustomError`][pydantic_core.PydanticCustomError], to fully control the error structure:\n-\n-```python\n-from pydantic_core import PydanticCustomError\n-\n-from pydantic import BaseModel, ValidationError, field_validator\n-\n-\n-class Model(BaseModel):\n-    foo: str\n-\n-    @field_validator('foo')\n-    def value_must_equal_bar(cls, v):\n-        if v != 'bar':\n-            raise PydanticCustomError(\n-                'not_a_bar',\n-                'value is not \"bar\", got \"{wrong_value}\"',\n-                dict(wrong_value=v),\n-            )\n-        return v\n-\n-\n-try:\n-    Model(foo='ber')\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    foo\n-      value is not \"bar\", got \"ber\" [type=not_a_bar, input_value='ber', input_type=str]\n-    \"\"\"\n-```\n-\n ## Error messages\n \n-Pydantic attempts to provide useful default error messages for validation and usage errors.\n-\n-We've provided documentation for default error codes in the following sections:\n+Pydantic attempts to provide useful default error messages for validation and usage errors, which can be found here:\n \n-- [Validation Errors](validation_errors.md)\n-- [Usage Errors](usage_errors.md)\n+- [Validation Errors](validation_errors.md): Errors that happen during data validation.\n+- [Usage Errors](usage_errors.md): Errors that happen when using Pydantic.",
        "comment_created_at": "2025-02-24T12:43:51+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "Maybe we could offer more clarity on usage errors, like providing an example or two",
        "pr_file_module": null
      },
      {
        "comment_id": "1967592493",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11473,
        "pr_file": "docs/errors/errors.md",
        "discussion_id": "1967574626",
        "commented_code": "@@ -127,92 +129,12 @@ except ValidationError as e:\n     \"\"\"\n ```\n \n-### Custom Errors\n-\n-In your custom data types or validators you should use `ValueError` or `AssertionError` to raise errors.\n-\n-See [validators](../concepts/validators.md) for more details on use of the `@validator` decorator.\n-\n-```python\n-from pydantic import BaseModel, ValidationError, field_validator\n-\n-\n-class Model(BaseModel):\n-    foo: str\n-\n-    @field_validator('foo')\n-    def value_must_equal_bar(cls, v):\n-        if v != 'bar':\n-            raise ValueError('value must be \"bar\"')\n-\n-        return v\n-\n-\n-try:\n-    Model(foo='ber')\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    foo\n-      Value error, value must be \"bar\" [type=value_error, input_value='ber', input_type=str]\n-    \"\"\"\n-    print(e.errors())\n-    \"\"\"\n-    [\n-        {\n-            'type': 'value_error',\n-            'loc': ('foo',),\n-            'msg': 'Value error, value must be \"bar\"',\n-            'input': 'ber',\n-            'ctx': {'error': ValueError('value must be \"bar\"')},\n-            'url': 'https://errors.pydantic.dev/2/v/value_error',\n-        }\n-    ]\n-    \"\"\"\n-```\n-\n-You can also use [`PydanticCustomError`][pydantic_core.PydanticCustomError], to fully control the error structure:\n-\n-```python\n-from pydantic_core import PydanticCustomError\n-\n-from pydantic import BaseModel, ValidationError, field_validator\n-\n-\n-class Model(BaseModel):\n-    foo: str\n-\n-    @field_validator('foo')\n-    def value_must_equal_bar(cls, v):\n-        if v != 'bar':\n-            raise PydanticCustomError(\n-                'not_a_bar',\n-                'value is not \"bar\", got \"{wrong_value}\"',\n-                dict(wrong_value=v),\n-            )\n-        return v\n-\n-\n-try:\n-    Model(foo='ber')\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    foo\n-      value is not \"bar\", got \"ber\" [type=not_a_bar, input_value='ber', input_type=str]\n-    \"\"\"\n-```\n-\n ## Error messages\n \n-Pydantic attempts to provide useful default error messages for validation and usage errors.\n-\n-We've provided documentation for default error codes in the following sections:\n+Pydantic attempts to provide useful default error messages for validation and usage errors, which can be found here:\n \n-- [Validation Errors](validation_errors.md)\n-- [Usage Errors](usage_errors.md)\n+- [Validation Errors](validation_errors.md): Errors that happen during data validation.\n+- [Usage Errors](usage_errors.md): Errors that happen when using Pydantic.",
        "comment_created_at": "2025-02-24T12:55:21+00:00",
        "comment_author": "Viicos",
        "comment_body": "It would make sense to do so if these kind of errors happen at runtime, _after_ initial module imports and application setup (like validation errors, where it makes sense to know how to handle them).\r\n\r\nPydantic errors are just usage exceptions and it doesn't really make sense to try..catch on these ones.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1786459766",
    "pr_number": 10484,
    "pr_file": "docs/errors/usage_errors.md",
    "created_at": "2024-10-03T15:43:59+00:00",
    "commented_code": "[related specification section]: https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments\n [PEP 692]: https://peps.python.org/pep-0692/\n+\n+\n+\n+## Unsupported type for `validate_call` {#validate-call-type}\n+\n+`validate_call` has some limitations on the types it can validate. This error is raised when you try to use it with an unsupported type. Currently the supported types are:\n+`LambdaType, FunctionType, MethodType, functools.partial`. For the case of `functools.partial`, the function being partially applied must be one of the supported types.\n+\n+\n+### `@classmethod`, `@staticmethod`, and `@property`\n+\n+These decorators cannot be put before `validate_call` because they return a class rather than one of the supported types. The correct way to use them is to put `validate_call` before the decorator.\n+\n+```py\n+from pydantic import PydanticUserError, validate_call\n+\n+# error\n+try:\n+\n+    class A:\n+        @validate_call\n+        @classmethod\n+        def f1(cls): ...\n+\n+except PydanticUserError as exc_info:\n+    assert exc_info.code == 'validate-call-type'\n+\n+\n+# correct\n+@classmethod\n+@validate_call\n+def f2(cls): ...\n+```\n+\n+\n+### Classes\n+\n+To avoid ambiguity, `validate_call` should be applied to methods, not classes. If you want to validate the constructor of a class, you should put `validate_call` on top of `__init__` or `__new__` instead.",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1786459766",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10484,
        "pr_file": "docs/errors/usage_errors.md",
        "discussion_id": "1786459766",
        "commented_code": "@@ -1238,3 +1238,105 @@ except PydanticUserError as exc_info:\n \n [related specification section]: https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments\n [PEP 692]: https://peps.python.org/pep-0692/\n+\n+\n+\n+## Unsupported type for `validate_call` {#validate-call-type}\n+\n+`validate_call` has some limitations on the types it can validate. This error is raised when you try to use it with an unsupported type. Currently the supported types are:\n+`LambdaType, FunctionType, MethodType, functools.partial`. For the case of `functools.partial`, the function being partially applied must be one of the supported types.\n+\n+\n+### `@classmethod`, `@staticmethod`, and `@property`\n+\n+These decorators cannot be put before `validate_call` because they return a class rather than one of the supported types. The correct way to use them is to put `validate_call` before the decorator.\n+\n+```py\n+from pydantic import PydanticUserError, validate_call\n+\n+# error\n+try:\n+\n+    class A:\n+        @validate_call\n+        @classmethod\n+        def f1(cls): ...\n+\n+except PydanticUserError as exc_info:\n+    assert exc_info.code == 'validate-call-type'\n+\n+\n+# correct\n+@classmethod\n+@validate_call\n+def f2(cls): ...\n+```\n+\n+\n+### Classes\n+\n+To avoid ambiguity, `validate_call` should be applied to methods, not classes. If you want to validate the constructor of a class, you should put `validate_call` on top of `__init__` or `__new__` instead.",
        "comment_created_at": "2024-10-03T15:43:59+00:00",
        "comment_author": "Viicos",
        "comment_body": "```suggestion\r\nWhile classes are callables themselves, `validate_call` can't be applied on them, as it needs to know about which method to use (`__init__` or `__new__`) to fetch type annotations. If you want to validate the constructor of a class, you should put `validate_call` on top of the appropriate method instead.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1786460664",
    "pr_number": 10484,
    "pr_file": "docs/errors/usage_errors.md",
    "created_at": "2024-10-03T15:44:42+00:00",
    "commented_code": "[related specification section]: https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments\n [PEP 692]: https://peps.python.org/pep-0692/\n+\n+\n+\n+## Unsupported type for `validate_call` {#validate-call-type}\n+\n+`validate_call` has some limitations on the types it can validate. This error is raised when you try to use it with an unsupported type. Currently the supported types are:\n+`LambdaType, FunctionType, MethodType, functools.partial`. For the case of `functools.partial`, the function being partially applied must be one of the supported types.\n+\n+\n+### `@classmethod`, `@staticmethod`, and `@property`\n+\n+These decorators cannot be put before `validate_call` because they return a class rather than one of the supported types. The correct way to use them is to put `validate_call` before the decorator.\n+\n+```py\n+from pydantic import PydanticUserError, validate_call\n+\n+# error\n+try:\n+\n+    class A:\n+        @validate_call\n+        @classmethod\n+        def f1(cls): ...\n+\n+except PydanticUserError as exc_info:\n+    assert exc_info.code == 'validate-call-type'\n+\n+\n+# correct\n+@classmethod\n+@validate_call\n+def f2(cls): ...\n+```\n+\n+\n+### Classes\n+\n+To avoid ambiguity, `validate_call` should be applied to methods, not classes. If you want to validate the constructor of a class, you should put `validate_call` on top of `__init__` or `__new__` instead.\n+\n+```py\n+from pydantic import PydanticUserError, validate_call\n+\n+# error\n+try:\n+\n+    @validate_call\n+    class A1: ...\n+\n+except PydanticUserError as exc_info:\n+    assert exc_info.code == 'validate-call-type'\n+\n+\n+# correct\n+class A2:\n+    @validate_call\n+    def __init__(self): ...\n+\n+    @validate_call\n+    def __new__(cls): ...\n+```\n+\n+### Custom callable\n+\n+Although you can create custom callable types in Python with `__call__`, currently the instance of these types cannot be validated with `validate_call`. This may change in the future, but for now, you should use `validate_call` explicitly on `__call__` instead.",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1786460664",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10484,
        "pr_file": "docs/errors/usage_errors.md",
        "discussion_id": "1786460664",
        "commented_code": "@@ -1238,3 +1238,105 @@ except PydanticUserError as exc_info:\n \n [related specification section]: https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments\n [PEP 692]: https://peps.python.org/pep-0692/\n+\n+\n+\n+## Unsupported type for `validate_call` {#validate-call-type}\n+\n+`validate_call` has some limitations on the types it can validate. This error is raised when you try to use it with an unsupported type. Currently the supported types are:\n+`LambdaType, FunctionType, MethodType, functools.partial`. For the case of `functools.partial`, the function being partially applied must be one of the supported types.\n+\n+\n+### `@classmethod`, `@staticmethod`, and `@property`\n+\n+These decorators cannot be put before `validate_call` because they return a class rather than one of the supported types. The correct way to use them is to put `validate_call` before the decorator.\n+\n+```py\n+from pydantic import PydanticUserError, validate_call\n+\n+# error\n+try:\n+\n+    class A:\n+        @validate_call\n+        @classmethod\n+        def f1(cls): ...\n+\n+except PydanticUserError as exc_info:\n+    assert exc_info.code == 'validate-call-type'\n+\n+\n+# correct\n+@classmethod\n+@validate_call\n+def f2(cls): ...\n+```\n+\n+\n+### Classes\n+\n+To avoid ambiguity, `validate_call` should be applied to methods, not classes. If you want to validate the constructor of a class, you should put `validate_call` on top of `__init__` or `__new__` instead.\n+\n+```py\n+from pydantic import PydanticUserError, validate_call\n+\n+# error\n+try:\n+\n+    @validate_call\n+    class A1: ...\n+\n+except PydanticUserError as exc_info:\n+    assert exc_info.code == 'validate-call-type'\n+\n+\n+# correct\n+class A2:\n+    @validate_call\n+    def __init__(self): ...\n+\n+    @validate_call\n+    def __new__(cls): ...\n+```\n+\n+### Custom callable\n+\n+Although you can create custom callable types in Python with `__call__`, currently the instance of these types cannot be validated with `validate_call`. This may change in the future, but for now, you should use `validate_call` explicitly on `__call__` instead.",
        "comment_created_at": "2024-10-03T15:44:42+00:00",
        "comment_author": "Viicos",
        "comment_body": "```suggestion\r\nAlthough you can create custom callable types in Python by implementing a `__call__` method, currently the instances of these types cannot be validated with `validate_call`. This may change in the future, but for now, you should use `validate_call` explicitly on `__call__` instead.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]