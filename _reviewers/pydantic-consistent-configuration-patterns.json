[
  {
    "discussion_id": "1946882000",
    "pr_number": 11394,
    "pr_file": "docs/concepts/models.md",
    "created_at": "2025-02-07T17:11:08+00:00",
    "commented_code": "class User(BaseModel):\n     id: int\n     name: str = 'Jane Doe'\n+\n+    model_config = {'str_max_length': 10}  # (1)!",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1946882000",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11394,
        "pr_file": "docs/concepts/models.md",
        "discussion_id": "1946882000",
        "commented_code": "@@ -67,8 +67,13 @@ from pydantic import BaseModel\n class User(BaseModel):\n     id: int\n     name: str = 'Jane Doe'\n+\n+    model_config = {'str_max_length': 10}  # (1)!",
        "comment_created_at": "2025-02-07T17:11:08+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "Should we use `ConfigDict(str_max_length=10)`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1946886196",
    "pr_number": 11394,
    "pr_file": "docs/concepts/config.md",
    "created_at": "2025-02-07T17:14:32+00:00",
    "commented_code": "-Behaviour of Pydantic can be controlled via the [`BaseModel.model_config`][pydantic.BaseModel.model_config],\n-and as an argument to [`TypeAdapter`][pydantic.TypeAdapter].\n+The behaviour of Pydantic can be controlled via a variety of configuration values, documented\n+on the [`ConfigDict`][pydantic.ConfigDict] class. This page will describe how configuration\n+can be specified on the supported types by Pydantic.\n \n-!!! note\n-    Before **v2.0**, the `Config` class was used. This is still supported, but **deprecated**.\n+## Configuration on Pydantic models\n \n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n+On Pydantic models, configuration can be specified in two ways:\n \n+- Using the [`model_config`][pydantic.BaseModel.model_config] class attribute:\n+  ```python\n+  from pydantic import BaseModel, ConfigDict, ValidationError\n \n-class Model(BaseModel):\n-    model_config = ConfigDict(str_max_length=10)\n \n-    v: str\n+  class Model(BaseModel):\n+      model_config = ConfigDict(str_max_length=5)  # (1)!\n \n+      v: str\n \n-try:\n-    m = Model(v='x' * 20)\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    v\n-      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n-    \"\"\"\n-```\n \n-Also, you can specify config options as model class kwargs:\n-```python\n-from pydantic import BaseModel, ValidationError\n+  try:\n+      m = Model(v='abcdef')\n+  except ValidationError as e:\n+      print(e)\n+      \"\"\"\n+      1 validation error for Model\n+      v\n+        String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n+      \"\"\"\n+  ```\n \n+    1. A plain dictionary (i.e. `{'str_max_length': 5}`) can also be used.\n \n-class Model(BaseModel, extra='forbid'):  # (1)!\n-    a: str\n+    !!! note\n+        In Pydantic V1, the `Config` class was used. This is still supported, but **deprecated**.\n \n+- Using class arguments:",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1946886196",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11394,
        "pr_file": "docs/concepts/config.md",
        "discussion_id": "1946886196",
        "commented_code": "@@ -1,70 +1,66 @@\n-Behaviour of Pydantic can be controlled via the [`BaseModel.model_config`][pydantic.BaseModel.model_config],\n-and as an argument to [`TypeAdapter`][pydantic.TypeAdapter].\n+The behaviour of Pydantic can be controlled via a variety of configuration values, documented\n+on the [`ConfigDict`][pydantic.ConfigDict] class. This page will describe how configuration\n+can be specified on the supported types by Pydantic.\n \n-!!! note\n-    Before **v2.0**, the `Config` class was used. This is still supported, but **deprecated**.\n+## Configuration on Pydantic models\n \n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n+On Pydantic models, configuration can be specified in two ways:\n \n+- Using the [`model_config`][pydantic.BaseModel.model_config] class attribute:\n+  ```python\n+  from pydantic import BaseModel, ConfigDict, ValidationError\n \n-class Model(BaseModel):\n-    model_config = ConfigDict(str_max_length=10)\n \n-    v: str\n+  class Model(BaseModel):\n+      model_config = ConfigDict(str_max_length=5)  # (1)!\n \n+      v: str\n \n-try:\n-    m = Model(v='x' * 20)\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    v\n-      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n-    \"\"\"\n-```\n \n-Also, you can specify config options as model class kwargs:\n-```python\n-from pydantic import BaseModel, ValidationError\n+  try:\n+      m = Model(v='abcdef')\n+  except ValidationError as e:\n+      print(e)\n+      \"\"\"\n+      1 validation error for Model\n+      v\n+        String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n+      \"\"\"\n+  ```\n \n+    1. A plain dictionary (i.e. `{'str_max_length': 5}`) can also be used.\n \n-class Model(BaseModel, extra='forbid'):  # (1)!\n-    a: str\n+    !!! note\n+        In Pydantic V1, the `Config` class was used. This is still supported, but **deprecated**.\n \n+- Using class arguments:",
        "comment_created_at": "2025-02-07T17:14:32+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "Should we recommend one over the other?",
        "pr_file_module": null
      },
      {
        "comment_id": "1946896057",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11394,
        "pr_file": "docs/concepts/config.md",
        "discussion_id": "1946886196",
        "commented_code": "@@ -1,70 +1,66 @@\n-Behaviour of Pydantic can be controlled via the [`BaseModel.model_config`][pydantic.BaseModel.model_config],\n-and as an argument to [`TypeAdapter`][pydantic.TypeAdapter].\n+The behaviour of Pydantic can be controlled via a variety of configuration values, documented\n+on the [`ConfigDict`][pydantic.ConfigDict] class. This page will describe how configuration\n+can be specified on the supported types by Pydantic.\n \n-!!! note\n-    Before **v2.0**, the `Config` class was used. This is still supported, but **deprecated**.\n+## Configuration on Pydantic models\n \n-```python\n-from pydantic import BaseModel, ConfigDict, ValidationError\n+On Pydantic models, configuration can be specified in two ways:\n \n+- Using the [`model_config`][pydantic.BaseModel.model_config] class attribute:\n+  ```python\n+  from pydantic import BaseModel, ConfigDict, ValidationError\n \n-class Model(BaseModel):\n-    model_config = ConfigDict(str_max_length=10)\n \n-    v: str\n+  class Model(BaseModel):\n+      model_config = ConfigDict(str_max_length=5)  # (1)!\n \n+      v: str\n \n-try:\n-    m = Model(v='x' * 20)\n-except ValidationError as e:\n-    print(e)\n-    \"\"\"\n-    1 validation error for Model\n-    v\n-      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n-    \"\"\"\n-```\n \n-Also, you can specify config options as model class kwargs:\n-```python\n-from pydantic import BaseModel, ValidationError\n+  try:\n+      m = Model(v='abcdef')\n+  except ValidationError as e:\n+      print(e)\n+      \"\"\"\n+      1 validation error for Model\n+      v\n+        String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n+      \"\"\"\n+  ```\n \n+    1. A plain dictionary (i.e. `{'str_max_length': 5}`) can also be used.\n \n-class Model(BaseModel, extra='forbid'):  # (1)!\n-    a: str\n+    !!! note\n+        In Pydantic V1, the `Config` class was used. This is still supported, but **deprecated**.\n \n+- Using class arguments:",
        "comment_created_at": "2025-02-07T17:22:11+00:00",
        "comment_author": "Viicos",
        "comment_body": "The benefit of using the class arguments is that it is recognized by type checkers. I think this is only relevant for `frozen`, so actually I'll change the example and add an annotation about it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1971224550",
    "pr_number": 11468,
    "pr_file": "docs/concepts/alias.md",
    "created_at": "2025-02-26T09:19:47+00:00",
    "commented_code": "The same precedence applies to `validation_alias` and `serialization_alias`.\n See more about the different field aliases under [field aliases](../concepts/fields.md#field-aliases).\n+\n+## Alias Use Configuration\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings or runtime validation / serialization\n+settings to control whether or not aliases are used.\n+\n+### `ConfigDict` Settings\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings to control, at the model level,\n+whether or not aliases are used for validation and serialization. If you would like to control\n+this behavior for nested models / surpassing the config-model boundary, use [runtime settings](#runtime-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n+\n+* [`ConfigDict.validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias]: `True` by default\n+* [`ConfigDict.validate_by_name`][pydantic.config.ConfigDict.validate_by_name]: `False` by default\n+\n+=== \"`validate_by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_field='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+\n+    print(repr(Model(my_field='foo')))  # (2)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias, which is disabled by default.\n+See the [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] API documentation\n+for an example.\n+\n+```python\n+from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+class Model(BaseModel):\n+    my_field: str = Field(serialization_alias='my_alias')\n+\n+    model_config = ConfigDict(serialize_by_alias=True)\n+\n+\n+m = Model(my_field='foo')\n+print(m.model_dump())  # (1)!\n+#> {'my_alias': 'foo'}\n+```\n+\n+1. The alias `my_alias` is used for serialization.\n+\n+!!! note\n+    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n+    validation (where aliases are used by default). We anticipate changing this default in V3.\n+\n+### Runtime Settings\n+\n+You can use runtime alias flags to control alias use for validation and serialization\n+on a per-call basis. If you would like to control this behavior on a model level, use\n+[`ConfigDict` settings](#configdict-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+\n+The `by_alias` and `by_name` flags are available on the [`model_validate`][pydantic.main.BaseModel.model_validate],\n+[`model_validate_json`][pydantic.main.BaseModel.model_validate_json], and [`model_validate_strings`][pydantic.main.BaseModel.model_validate_strings] methods.\n+\n+By default:\n+* `by_alias` is `True`\n+* `by_name` is `False`",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1971224550",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/concepts/alias.md",
        "discussion_id": "1971224550",
        "commented_code": "@@ -201,3 +201,229 @@ You may set `alias_priority` on a field to change this behavior:\n \n The same precedence applies to `validation_alias` and `serialization_alias`.\n See more about the different field aliases under [field aliases](../concepts/fields.md#field-aliases).\n+\n+## Alias Use Configuration\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings or runtime validation / serialization\n+settings to control whether or not aliases are used.\n+\n+### `ConfigDict` Settings\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings to control, at the model level,\n+whether or not aliases are used for validation and serialization. If you would like to control\n+this behavior for nested models / surpassing the config-model boundary, use [runtime settings](#runtime-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n+\n+* [`ConfigDict.validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias]: `True` by default\n+* [`ConfigDict.validate_by_name`][pydantic.config.ConfigDict.validate_by_name]: `False` by default\n+\n+=== \"`validate_by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_field='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+\n+    print(repr(Model(my_field='foo')))  # (2)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias, which is disabled by default.\n+See the [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] API documentation\n+for an example.\n+\n+```python\n+from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+class Model(BaseModel):\n+    my_field: str = Field(serialization_alias='my_alias')\n+\n+    model_config = ConfigDict(serialize_by_alias=True)\n+\n+\n+m = Model(my_field='foo')\n+print(m.model_dump())  # (1)!\n+#> {'my_alias': 'foo'}\n+```\n+\n+1. The alias `my_alias` is used for serialization.\n+\n+!!! note\n+    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n+    validation (where aliases are used by default). We anticipate changing this default in V3.\n+\n+### Runtime Settings\n+\n+You can use runtime alias flags to control alias use for validation and serialization\n+on a per-call basis. If you would like to control this behavior on a model level, use\n+[`ConfigDict` settings](#configdict-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+\n+The `by_alias` and `by_name` flags are available on the [`model_validate`][pydantic.main.BaseModel.model_validate],\n+[`model_validate_json`][pydantic.main.BaseModel.model_validate_json], and [`model_validate_strings`][pydantic.main.BaseModel.model_validate_strings] methods.\n+\n+By default:\n+* `by_alias` is `True`\n+* `by_name` is `False`",
        "comment_created_at": "2025-02-26T09:19:47+00:00",
        "comment_author": "stevapple",
        "comment_body": "Does the default override `ConfigDict`? If not, does it mean we can still not specify different defaults for `model_validate` and `__init__`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1971464148",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/concepts/alias.md",
        "discussion_id": "1971224550",
        "commented_code": "@@ -201,3 +201,229 @@ You may set `alias_priority` on a field to change this behavior:\n \n The same precedence applies to `validation_alias` and `serialization_alias`.\n See more about the different field aliases under [field aliases](../concepts/fields.md#field-aliases).\n+\n+## Alias Use Configuration\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings or runtime validation / serialization\n+settings to control whether or not aliases are used.\n+\n+### `ConfigDict` Settings\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings to control, at the model level,\n+whether or not aliases are used for validation and serialization. If you would like to control\n+this behavior for nested models / surpassing the config-model boundary, use [runtime settings](#runtime-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n+\n+* [`ConfigDict.validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias]: `True` by default\n+* [`ConfigDict.validate_by_name`][pydantic.config.ConfigDict.validate_by_name]: `False` by default\n+\n+=== \"`validate_by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_field='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+\n+    print(repr(Model(my_field='foo')))  # (2)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias, which is disabled by default.\n+See the [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] API documentation\n+for an example.\n+\n+```python\n+from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+class Model(BaseModel):\n+    my_field: str = Field(serialization_alias='my_alias')\n+\n+    model_config = ConfigDict(serialize_by_alias=True)\n+\n+\n+m = Model(my_field='foo')\n+print(m.model_dump())  # (1)!\n+#> {'my_alias': 'foo'}\n+```\n+\n+1. The alias `my_alias` is used for serialization.\n+\n+!!! note\n+    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n+    validation (where aliases are used by default). We anticipate changing this default in V3.\n+\n+### Runtime Settings\n+\n+You can use runtime alias flags to control alias use for validation and serialization\n+on a per-call basis. If you would like to control this behavior on a model level, use\n+[`ConfigDict` settings](#configdict-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+\n+The `by_alias` and `by_name` flags are available on the [`model_validate`][pydantic.main.BaseModel.model_validate],\n+[`model_validate_json`][pydantic.main.BaseModel.model_validate_json], and [`model_validate_strings`][pydantic.main.BaseModel.model_validate_strings] methods.\n+\n+By default:\n+* `by_alias` is `True`\n+* `by_name` is `False`",
        "comment_created_at": "2025-02-26T12:01:40+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "The default does not override the config, this only overrides config if set. Good question!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1946889346",
    "pr_number": 11394,
    "pr_file": "docs/concepts/config.md",
    "created_at": "2025-02-07T17:17:06+00:00",
    "commented_code": "#> {'x': 'foo', 'y': 'bar'}\n ```\n \n-If you add a `model_config` to the `Model` class, it will _merge_ with the `model_config` from `Parent`:\n+If you provide configuration to the subclasses, it will be _merged_ with the parent configuration:",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1946889346",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11394,
        "pr_file": "docs/concepts/config.md",
        "discussion_id": "1946889346",
        "commented_code": "@@ -131,7 +141,7 @@ print(m.model_dump())\n #> {'x': 'foo', 'y': 'bar'}\n ```\n \n-If you add a `model_config` to the `Model` class, it will _merge_ with the `model_config` from `Parent`:\n+If you provide configuration to the subclasses, it will be _merged_ with the parent configuration:",
        "comment_created_at": "2025-02-07T17:17:06+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "I believe in the migration guide we talk about priority here (sometimes it's not intuitive). Can we make a note on that here, and add a dupe key to the merged configs and show which one is preserved in the result?",
        "pr_file_module": null
      }
    ]
  }
]