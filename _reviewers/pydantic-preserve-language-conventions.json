[
  {
    "discussion_id": "1971235964",
    "pr_number": 11468,
    "pr_file": "docs/integrations/mypy.md",
    "created_at": "2025-02-26T09:26:30+00:00",
    "commented_code": "* Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1971235964",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1971235964",
        "commented_code": "@@ -88,7 +88,7 @@ that the version support policy is subject to change at discretion of contributo\n \n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
        "comment_created_at": "2025-02-26T09:26:30+00:00",
        "comment_author": "stevapple",
        "comment_body": "I'm thinking if we should have another pair of `ConfigDict` settings `instantiate_by_name` and `instantiate_by_alias` to distinguish it from `model_validate_X` (and we should allow them to coexist, resulting in an overloaded `__init__`).\r\n\r\nFor background see https://github.com/pydantic/pydantic/issues/8379#issuecomment-2629432388 and https://github.com/pydantic/pydantic/discussions/6762",
        "pr_file_module": null
      },
      {
        "comment_id": "1971330762",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1971235964",
        "commented_code": "@@ -88,7 +88,7 @@ that the version support policy is subject to change at discretion of contributo\n \n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
        "comment_created_at": "2025-02-26T10:24:17+00:00",
        "comment_author": "Viicos",
        "comment_body": "You mean `instanciate_by_*` only take effect on direct instantiation (i.e. `Model(...)`)?\r\n\r\nThis would really complicate the API. Using `__init__` directly is better suited when you provide the arguments directly (e.g. `Model(a=1, b='test')`). In that case, the user can simply provide the aliases (and this is what static type checkers will enforce, we have no control over it).\r\n\r\nIf you want to validate data where you don't control the provided keys, then `model_validate()` is better suited anyway: `Model.model_validate({'a': 1, 'b': 'test'})`, and you can provide `by_name=True` there.",
        "pr_file_module": null
      },
      {
        "comment_id": "1971407313",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1971235964",
        "commented_code": "@@ -88,7 +88,7 @@ that the version support policy is subject to change at discretion of contributo\n \n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
        "comment_created_at": "2025-02-26T11:16:35+00:00",
        "comment_author": "stevapple",
        "comment_body": "> Using `__init__` directly is better suited when you provide the arguments directly (e.g. `Model(a=1, b='test')`).\n\nThis is exactly why some (I would say most if we consider popular serialization frameworks in other languages) developers are reluctant to use alias in a direct instantiation. Field names are carefully chosen according to language conventions, e.g. `snake_case` for Python, while aliases are decided by business logic. We wouldn't like to see things like `Model(SomeRandomValue=147, Env_Global='test')` in a Python code review, and it would be unfortunate if we need to annotate every `model_validate_X` call for this reason.\n\nIf we don't want that complexity, I would suggest enforcing `validate_by_name` for `__init__` (keep the current behavior in v2 for compatibility). This is intuitive and aligned with `dataclass` and other frameworks in statically typed languages.",
        "pr_file_module": null
      },
      {
        "comment_id": "1971473096",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1971235964",
        "commented_code": "@@ -88,7 +88,7 @@ that the version support policy is subject to change at discretion of contributo\n \n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
        "comment_created_at": "2025-02-26T12:08:37+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "`validate_by_name` logic still applies to `__init__` :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1971477337",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1971235964",
        "commented_code": "@@ -88,7 +88,7 @@ that the version support policy is subject to change at discretion of contributo\n \n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
        "comment_created_at": "2025-02-26T12:11:46+00:00",
        "comment_author": "Viicos",
        "comment_body": "> This is intuitive and aligned with dataclass and other frameworks in statically typed languages.\r\n\r\nDataclasses don't make use of aliases, but this is something supported by the `@dataclass_transform` spec, and as per the [fields specifiers](https://typing.readthedocs.io/en/latest/spec/dataclasses.html#field-specifier-parameters) section:\r\n\r\n> `alias` is an optional str parameter that provides an alternative name for the field. This alternative name is used in the synthesized `__init__` method.\r\n\r\nBut I get your point, `Model(SomeRandomValue=147, Env_Global='test')` feels weird in Python code. The fact that type checkers will enforce aliases in `__init__` is unfortunate though.\r\n\r\nThis merits a broader discussion, currently we don't have a proper distinction between direct instantiation (`__init__`) and the `model_validate(_*)` methods when it comes to validation behavior. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1971570266",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/integrations/mypy.md",
        "discussion_id": "1971235964",
        "commented_code": "@@ -88,7 +88,7 @@ that the version support policy is subject to change at discretion of contributo\n \n * Any required fields that don't have dynamically-determined aliases will be included as required\n   keyword arguments.\n-* If the [`populate_by_name`][pydantic.ConfigDict.populate_by_name] model configuration value is set to\n+* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to",
        "comment_created_at": "2025-02-26T13:16:53+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "@stevapple, feel free to open an issue with a summary of this discussion!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1971431127",
    "pr_number": 11468,
    "pr_file": "docs/concepts/alias.md",
    "created_at": "2025-02-26T11:35:37+00:00",
    "commented_code": "The same precedence applies to `validation_alias` and `serialization_alias`.\n See more about the different field aliases under [field aliases](../concepts/fields.md#field-aliases).\n+\n+## Alias Use Configuration\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings or runtime validation / serialization\n+settings to control whether or not aliases are used.\n+\n+### `ConfigDict` Settings\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings to control, at the model level,\n+whether or not aliases are used for validation and serialization. If you would like to control\n+this behavior for nested models / surpassing the config-model boundary, use [runtime settings](#runtime-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n+\n+* [`ConfigDict.validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias]: `True` by default\n+* [`ConfigDict.validate_by_name`][pydantic.config.ConfigDict.validate_by_name]: `False` by default\n+\n+=== \"`validate_by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_field='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+\n+    print(repr(Model(my_field='foo')))  # (2)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias, which is disabled by default.\n+See the [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] API documentation\n+for an example.\n+\n+```python\n+from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+class Model(BaseModel):\n+    my_field: str = Field(serialization_alias='my_alias')\n+\n+    model_config = ConfigDict(serialize_by_alias=True)\n+\n+\n+m = Model(my_field='foo')\n+print(m.model_dump())  # (1)!\n+#> {'my_alias': 'foo'}\n+```\n+\n+1. The alias `my_alias` is used for serialization.\n+\n+!!! note\n+    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n+    validation (where aliases are used by default). We anticipate changing this default in V3.\n+\n+### Runtime Settings\n+\n+You can use runtime alias flags to control alias use for validation and serialization\n+on a per-call basis. If you would like to control this behavior on a model level, use\n+[`ConfigDict` settings](#configdict-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+\n+The `by_alias` and `by_name` flags are available on the [`model_validate`][pydantic.main.BaseModel.model_validate],\n+[`model_validate_json`][pydantic.main.BaseModel.model_validate_json], and [`model_validate_strings`][pydantic.main.BaseModel.model_validate_strings] methods.\n+\n+By default:\n+* `by_alias` is `True`\n+* `by_name` is `False`\n+\n+These settings are also available on [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] validation methods.\n+\n+=== \"`by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+\n+    m = Model.model_validate(\n+        {'my_alias': 'foo'},  # (1)!\n+        by_alias=True,\n+        by_name=False,\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+\n+    m = Model.model_validate(\n+        {'my_field': 'foo'}, by_alias=False, by_name=True  # (1)!\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+\n+    m = Model.model_validate(\n+        {'my_alias': 'foo'}, by_alias=True, by_name=True  # (1)!\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+\n+    m = Model.model_validate(\n+        {'my_field': 'foo'}, by_alias=True, by_name=True  # (2)!\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `by_alias` and `by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias via the `by_alias` flag\n+which is available on the [`model_dump`][pydantic.main.BaseModel.model_dump] and\n+[`model_dump_json`][pydantic.main.BaseModel.model_dump_json] methods.",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1971431127",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11468,
        "pr_file": "docs/concepts/alias.md",
        "discussion_id": "1971431127",
        "commented_code": "@@ -201,3 +201,229 @@ You may set `alias_priority` on a field to change this behavior:\n \n The same precedence applies to `validation_alias` and `serialization_alias`.\n See more about the different field aliases under [field aliases](../concepts/fields.md#field-aliases).\n+\n+## Alias Use Configuration\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings or runtime validation / serialization\n+settings to control whether or not aliases are used.\n+\n+### `ConfigDict` Settings\n+\n+You can use [`ConfigDict`][pydantic.config.ConfigDict] settings to control, at the model level,\n+whether or not aliases are used for validation and serialization. If you would like to control\n+this behavior for nested models / surpassing the config-model boundary, use [runtime settings](#runtime-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n+\n+* [`ConfigDict.validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias]: `True` by default\n+* [`ConfigDict.validate_by_name`][pydantic.config.ConfigDict.validate_by_name]: `False` by default\n+\n+=== \"`validate_by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_field='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+        model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n+\n+\n+    print(repr(Model(my_alias='foo')))  # (1)!\n+    #> Model(my_field='foo')\n+\n+    print(repr(Model(my_field='foo')))  # (2)!\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias, which is disabled by default.\n+See the [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] API documentation\n+for an example.\n+\n+```python\n+from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+class Model(BaseModel):\n+    my_field: str = Field(serialization_alias='my_alias')\n+\n+    model_config = ConfigDict(serialize_by_alias=True)\n+\n+\n+m = Model(my_field='foo')\n+print(m.model_dump())  # (1)!\n+#> {'my_alias': 'foo'}\n+```\n+\n+1. The alias `my_alias` is used for serialization.\n+\n+!!! note\n+    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n+    validation (where aliases are used by default). We anticipate changing this default in V3.\n+\n+### Runtime Settings\n+\n+You can use runtime alias flags to control alias use for validation and serialization\n+on a per-call basis. If you would like to control this behavior on a model level, use\n+[`ConfigDict` settings](#configdict-settings).\n+\n+#### Validation\n+\n+When validating data, you can enable population of attributes by attribute name, alias, or both.\n+\n+The `by_alias` and `by_name` flags are available on the [`model_validate`][pydantic.main.BaseModel.model_validate],\n+[`model_validate_json`][pydantic.main.BaseModel.model_validate_json], and [`model_validate_strings`][pydantic.main.BaseModel.model_validate_strings] methods.\n+\n+By default:\n+* `by_alias` is `True`\n+* `by_name` is `False`\n+\n+These settings are also available on [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] validation methods.\n+\n+=== \"`by_alias`\"\n+\n+    ```python\n+    from pydantic import BaseModel, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+\n+    m = Model.model_validate(\n+        {'my_alias': 'foo'},  # (1)!\n+        by_alias=True,\n+        by_name=False,\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+\n+=== \"`by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+\n+    m = Model.model_validate(\n+        {'my_field': 'foo'}, by_alias=False, by_name=True  # (1)!\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. the attribute identifier `my_field` is used for validation.\n+\n+=== \"`validate_by_alias` and `validate_by_name`\"\n+\n+    ```python\n+    from pydantic import BaseModel, Field\n+\n+\n+    class Model(BaseModel):\n+        my_field: str = Field(validation_alias='my_alias')\n+\n+\n+    m = Model.model_validate(\n+        {'my_alias': 'foo'}, by_alias=True, by_name=True  # (1)!\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+\n+    m = Model.model_validate(\n+        {'my_field': 'foo'}, by_alias=True, by_name=True  # (2)!\n+    )\n+    print(repr(m))\n+    #> Model(my_field='foo')\n+    ```\n+\n+    1. The alias `my_alias` is used for validation.\n+    2. the attribute identifier `my_field` is used for validation.\n+\n+!!! warning\n+    You cannot set both `by_alias` and `by_name` to `False`.\n+    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.\n+\n+#### Serialization\n+\n+When serializing data, you can enable serialization by alias via the `by_alias` flag\n+which is available on the [`model_dump`][pydantic.main.BaseModel.model_dump] and\n+[`model_dump_json`][pydantic.main.BaseModel.model_dump_json] methods.",
        "comment_created_at": "2025-02-26T11:35:37+00:00",
        "comment_author": "Viicos",
        "comment_body": "```suggestion\r\nwhich is available on the [`model_dump()`][pydantic.main.BaseModel.model_dump] and\r\n[`model_dump_json()`][pydantic.main.BaseModel.model_dump_json] methods, as well as\r\nthe [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] ones.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1831531677",
    "pr_number": 10782,
    "pr_file": "docs/concepts/fields.md",
    "created_at": "2024-11-06T18:34:47+00:00",
    "commented_code": "However, note that Pydantic will *not* perform any additional logic on the wrapped property\n     (validation, cache invalidation, etc.).\n \n-Here's an example:\n+Here's an example of the JSON schema (in serialization mode) generated for a model with a computed field:\n+\n+```py\n+from pydantic import BaseModel, computed_field\n+\n+\n+class Box(BaseModel):\n+    width: float\n+    height: float\n+    depth: float\n+\n+    @computed_field\n+    @property  # (1)!\n+    def volume(self) -> float:\n+        return self.width * self.height * self.depth\n+\n+\n+print(Box.model_json_schema(mode='serialization'))\n+#> {\n+#>     'properties': {\n+#>         'width': {\n+#>             'title': 'Width',\n+#>             'type': 'number'\n+#>         },\n+#>         'height': {\n+#>             'title': 'Height',\n+#>             'type': 'number'\n+#>         },\n+#>         'depth': {\n+#>             'title': 'Depth',\n+#>             'type': 'number'\n+#>         },\n+#>         'volume': {\n+#>             'readOnly': True,\n+#>             'title': 'Volume',\n+#>             'type': 'number'\n+#>         }\n+#>     },\n+#>     'required': [\n+#>         'width',\n+#>         'height',\n+#>         'depth',\n+#>         'volume'\n+#>     ],\n+#>     'title': 'Box',\n+#>     'type': 'object'\n+#> }",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1831531677",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10782,
        "pr_file": "docs/concepts/fields.md",
        "discussion_id": "1831531677",
        "commented_code": "@@ -831,7 +831,56 @@ The property will also be taken into account in the JSON Schema.\n     However, note that Pydantic will *not* perform any additional logic on the wrapped property\n     (validation, cache invalidation, etc.).\n \n-Here's an example:\n+Here's an example of the JSON schema (in serialization mode) generated for a model with a computed field:\n+\n+```py\n+from pydantic import BaseModel, computed_field\n+\n+\n+class Box(BaseModel):\n+    width: float\n+    height: float\n+    depth: float\n+\n+    @computed_field\n+    @property  # (1)!\n+    def volume(self) -> float:\n+        return self.width * self.height * self.depth\n+\n+\n+print(Box.model_json_schema(mode='serialization'))\n+#> {\n+#>     'properties': {\n+#>         'width': {\n+#>             'title': 'Width',\n+#>             'type': 'number'\n+#>         },\n+#>         'height': {\n+#>             'title': 'Height',\n+#>             'type': 'number'\n+#>         },\n+#>         'depth': {\n+#>             'title': 'Depth',\n+#>             'type': 'number'\n+#>         },\n+#>         'volume': {\n+#>             'readOnly': True,\n+#>             'title': 'Volume',\n+#>             'type': 'number'\n+#>         }\n+#>     },\n+#>     'required': [\n+#>         'width',\n+#>         'height',\n+#>         'depth',\n+#>         'volume'\n+#>     ],\n+#>     'title': 'Box',\n+#>     'type': 'object'\n+#> }",
        "comment_created_at": "2024-11-06T18:34:47+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "```suggestion\r\nimport json\r\nfrom pydantic import BaseModel, computed_field\r\n\r\n\r\nclass Box(BaseModel):\r\n    width: float\r\n    height: float\r\n    depth: float\r\n\r\n    @computed_field\r\n    @property  # (1)!\r\n    def volume(self) -> float:\r\n        return self.width * self.height * self.depth\r\n\r\n\r\nprint(json.dumps(Box.model_json_schema(mode='serialization'), indent=2))\r\n\"\"\"\r\n{\r\n  \"properties\": {\r\n    \"width\": {\r\n      \"title\": \"Width\",\r\n      \"type\": \"number\"\r\n    },\r\n    \"height\": {\r\n      \"title\": \"Height\",\r\n      \"type\": \"number\"\r\n    },\r\n    \"depth\": {\r\n      \"title\": \"Depth\",\r\n      \"type\": \"number\"\r\n    },\r\n    \"volume\": {\r\n      \"readOnly\": true,\r\n      \"title\": \"Volume\",\r\n      \"type\": \"number\"\r\n    }\r\n  },\r\n  \"required\": [\r\n    \"width\",\r\n    \"height\",\r\n    \"depth\",\r\n    \"volume\"\r\n  ],\r\n  \"title\": \"Box\",\r\n  \"type\": \"object\"\r\n}\r\n\"\"\"\r\n```\r\n\r\nLooking great, just a formatting fix here.",
        "pr_file_module": null
      }
    ]
  }
]