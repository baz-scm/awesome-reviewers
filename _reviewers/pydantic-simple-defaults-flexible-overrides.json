[
  {
    "discussion_id": "2175584535",
    "pr_number": 12028,
    "pr_file": "pydantic/_internal/_generate_schema.py",
    "created_at": "2025-06-30T17:39:21+00:00",
    "commented_code": "update_field_from_config(self._config_wrapper, name, field)\n \n         with self.field_name_stack.push(name):\n-            schema = self._apply_annotations(field.annotation, [field])\n+            schema = self._apply_annotations(\n+                field.annotation,\n+                [field],\n+                # Because we pass `field` as metadata above (required for attributes relevant for\n+                # JSON Scheme generation), we need to ignore the potential warnings about `FieldInfo`\n+                # attributes that will not be used:\n+                check_unsupported_field_info_attributes=False,",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "2175584535",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 12028,
        "pr_file": "pydantic/_internal/_generate_schema.py",
        "discussion_id": "2175584535",
        "commented_code": "@@ -1525,7 +1550,14 @@ def _generate_parameter_schema(\n         update_field_from_config(self._config_wrapper, name, field)\n \n         with self.field_name_stack.push(name):\n-            schema = self._apply_annotations(field.annotation, [field])\n+            schema = self._apply_annotations(\n+                field.annotation,\n+                [field],\n+                # Because we pass `field` as metadata above (required for attributes relevant for\n+                # JSON Scheme generation), we need to ignore the potential warnings about `FieldInfo`\n+                # attributes that will not be used:\n+                check_unsupported_field_info_attributes=False,",
        "comment_created_at": "2025-06-30T17:39:21+00:00",
        "comment_author": "Viicos",
        "comment_body": "This is for validated function calls (see `test_unsupported_field_attribute_nested_with_function()`). We don't want to raise a warning for:\n\n```python\n@validate_call\ndef func(a: Annotated[int, Field(alias='b')]): ...\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1856832980",
    "pr_number": 10949,
    "pr_file": "pydantic/_internal/_config.py",
    "created_at": "2024-11-25T15:37:43+00:00",
    "commented_code": "json_schema_extra=None,\n     strict=False,\n     revalidate_instances='never',\n+    val_date_or_time_unit='infer',\n+    ser_date_or_time_unit='infer',",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1856832980",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10949,
        "pr_file": "pydantic/_internal/_config.py",
        "discussion_id": "1856832980",
        "commented_code": "@@ -257,6 +263,9 @@ def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n     json_schema_extra=None,\n     strict=False,\n     revalidate_instances='never',\n+    val_date_or_time_unit='infer',\n+    ser_date_or_time_unit='infer',",
        "comment_created_at": "2024-11-25T15:37:43+00:00",
        "comment_author": "davidhewitt",
        "comment_body": "Opinion: users probably want to have both of these the same in 99% of cases. I would prefer we come up with a design where the obvious thing is easy and succinct, and in the rare case where these need to be different users have a complex override. So it makes me sad to have two configs here.\r\n\r\n... I know we have the same problem in `ser_json_bytes` and `val_json_bytes`, so maybe this is a V3 API refresh question.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1928494196",
    "pr_number": 11319,
    "pr_file": "pydantic/networks.py",
    "created_at": "2025-01-24T10:48:29+00:00",
    "commented_code": "\"\"\"\n \n     _constraints = UrlConstraints(\n-        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n+        allowed_schemes=['clickhouse+native', 'clickhouse+asynch', 'clickhouse', 'clickhouses', 'clickhousedb'],",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1928494196",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 11319,
        "pr_file": "pydantic/networks.py",
        "discussion_id": "1928494196",
        "commented_code": "@@ -886,7 +886,7 @@ class ClickHouseDsn(AnyUrl):\n     \"\"\"\n \n     _constraints = UrlConstraints(\n-        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n+        allowed_schemes=['clickhouse+native', 'clickhouse+asynch', 'clickhouse', 'clickhouses', 'clickhousedb'],",
        "comment_created_at": "2025-01-24T10:48:29+00:00",
        "comment_author": "Viicos",
        "comment_body": "```suggestion\r\n        allowed_schemes=['clickhouse+native', 'clickhouse+asynch', 'clickhouse+http', 'clickhouse', 'clickhouses', 'clickhousedb'],\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1829698945",
    "pr_number": 10766,
    "pr_file": "pydantic/networks.py",
    "created_at": "2024-11-05T16:54:23+00:00",
    "commented_code": "return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)\n+\n+    def __init__(self, url: str | _CoreMultiHostUrl) -> None:\n+        if isinstance(url, self.__class__):\n+            self._url = url._url\n+        elif isinstance(url, _CoreMultiHostUrl):\n+            self._url = self._validator.validate_python(str(url))\n+        else:\n+            self._url = self._validator.validate_python(url)\n+\n+    @property\n+    def scheme(self) -> str:\n+        \"\"\"The scheme part of the URL.\n+\n+        e.g. `https` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.scheme\n+\n+    @property\n+    def path(self) -> str | None:\n+        \"\"\"The path part of the URL, or `None`.\n+\n+        e.g. `/path` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.path\n+\n+    @property\n+    def query(self) -> str | None:\n+        \"\"\"The query part of the URL, or `None`.\n+\n+        e.g. `query` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query\n+\n+    def query_params(self) -> list[tuple[str, str]]:\n+        \"\"\"The query part of the URL as a list of key-value pairs.\n+\n+        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query_params()\n+\n+    @property\n+    def fragment(self) -> str | None:\n+        \"\"\"The fragment part of the URL, or `None`.\n+\n+        e.g. `fragment` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.fragment\n+\n+    def hosts(self) -> list[MultiHostHost]:\n+        '''The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n+\n+        ```py\n+        from pydantic_core import MultiHostUrl\n+\n+        mhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\n+        print(mhu.hosts())\n+        \"\"\"\n+        [\n+            {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n+            {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n+        ]\n+        ```\n+        Returns:\n+            A list of dicts, each representing a host.\n+        '''\n+        return self._url.hosts()\n+\n+    def unicode_string(self) -> str:\n+        \"\"\"The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.\"\"\"\n+        return self._url.unicode_string()\n+\n+    def __str__(self) -> str:\n+        \"\"\"The URL as a string, this will punycode encode the host if required.\"\"\"\n+        return str(self._url)\n+\n+    def __repr__(self) -> str:\n+        return f'{self.__class__.__name__}({str(self._url)!r})'\n+\n+    def __deepcopy__(self, memo: dict) -> Self:\n+        return self.__class__(self._url)\n \n     @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def build(\n+        cls,\n+        *,\n+        scheme: str,\n+        hosts: list[MultiHostHost] | None = None,\n+        username: str | None = None,\n+        password: str | None = None,\n+        host: str | None = None,\n+        port: int | None = None,\n+        path: str | None = None,\n+        query: str | None = None,\n+        fragment: str | None = None,\n+    ) -> Self:\n+        \"\"\"Build a new `MultiHostUrl` instance from its component parts.\n+\n+        This method takes either `hosts` - a list of `MultiHostHost` typed dicts, or the individual components\n+        `username`, `password`, `host` and `port`.\n+\n+        Args:\n+            scheme: The scheme part of the URL.\n+            hosts: Multiple hosts to build the URL from.\n+            username: The username part of the URL.\n+            password: The password part of the URL.\n+            host: The host part of the URL.\n+            port: The port part of the URL.\n+            path: The path part of the URL.\n+            query: The query part of the URL, or omit for no query.\n+            fragment: The fragment part of the URL, or omit for no fragment.\n+\n+        Returns:\n+            An instance of `MultiHostUrl`\n+        \"\"\"\n+        return cls(\n+            _CoreMultiHostUrl.build(\n+                scheme=scheme,\n+                hosts=hosts,\n+                username=username,\n+                password=password,\n+                host=host,\n+                port=port,\n+                path=path,\n+                query=query,\n+                fragment=fragment,\n+            )\n+        )\n+\n+    @classmethod\n+    def __get_pydantic_core_schema__(\n+        cls, source: type[_BaseMultiHostUrl], handler: GetCoreSchemaHandler\n+    ) -> core_schema.CoreSchema:\n         if issubclass(cls, source):\n-            return core_schema.multi_host_url_schema(**cls._constraints.defined_constraints)\n+\n+            def wrap_val(value, handler):\n+                if isinstance(value, source):\n+                    return value\n+                core_url = handler(value)\n+                instance = source.__new__(source)\n+                instance._url = core_url\n+                return instance",
    "repo_full_name": "pydantic/pydantic",
    "discussion_comments": [
      {
        "comment_id": "1829698945",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10766,
        "pr_file": "pydantic/networks.py",
        "discussion_id": "1829698945",
        "commented_code": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)\n+\n+    def __init__(self, url: str | _CoreMultiHostUrl) -> None:\n+        if isinstance(url, self.__class__):\n+            self._url = url._url\n+        elif isinstance(url, _CoreMultiHostUrl):\n+            self._url = self._validator.validate_python(str(url))\n+        else:\n+            self._url = self._validator.validate_python(url)\n+\n+    @property\n+    def scheme(self) -> str:\n+        \"\"\"The scheme part of the URL.\n+\n+        e.g. `https` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.scheme\n+\n+    @property\n+    def path(self) -> str | None:\n+        \"\"\"The path part of the URL, or `None`.\n+\n+        e.g. `/path` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.path\n+\n+    @property\n+    def query(self) -> str | None:\n+        \"\"\"The query part of the URL, or `None`.\n+\n+        e.g. `query` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query\n+\n+    def query_params(self) -> list[tuple[str, str]]:\n+        \"\"\"The query part of the URL as a list of key-value pairs.\n+\n+        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query_params()\n+\n+    @property\n+    def fragment(self) -> str | None:\n+        \"\"\"The fragment part of the URL, or `None`.\n+\n+        e.g. `fragment` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.fragment\n+\n+    def hosts(self) -> list[MultiHostHost]:\n+        '''The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n+\n+        ```py\n+        from pydantic_core import MultiHostUrl\n+\n+        mhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\n+        print(mhu.hosts())\n+        \"\"\"\n+        [\n+            {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n+            {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n+        ]\n+        ```\n+        Returns:\n+            A list of dicts, each representing a host.\n+        '''\n+        return self._url.hosts()\n+\n+    def unicode_string(self) -> str:\n+        \"\"\"The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.\"\"\"\n+        return self._url.unicode_string()\n+\n+    def __str__(self) -> str:\n+        \"\"\"The URL as a string, this will punycode encode the host if required.\"\"\"\n+        return str(self._url)\n+\n+    def __repr__(self) -> str:\n+        return f'{self.__class__.__name__}({str(self._url)!r})'\n+\n+    def __deepcopy__(self, memo: dict) -> Self:\n+        return self.__class__(self._url)\n \n     @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def build(\n+        cls,\n+        *,\n+        scheme: str,\n+        hosts: list[MultiHostHost] | None = None,\n+        username: str | None = None,\n+        password: str | None = None,\n+        host: str | None = None,\n+        port: int | None = None,\n+        path: str | None = None,\n+        query: str | None = None,\n+        fragment: str | None = None,\n+    ) -> Self:\n+        \"\"\"Build a new `MultiHostUrl` instance from its component parts.\n+\n+        This method takes either `hosts` - a list of `MultiHostHost` typed dicts, or the individual components\n+        `username`, `password`, `host` and `port`.\n+\n+        Args:\n+            scheme: The scheme part of the URL.\n+            hosts: Multiple hosts to build the URL from.\n+            username: The username part of the URL.\n+            password: The password part of the URL.\n+            host: The host part of the URL.\n+            port: The port part of the URL.\n+            path: The path part of the URL.\n+            query: The query part of the URL, or omit for no query.\n+            fragment: The fragment part of the URL, or omit for no fragment.\n+\n+        Returns:\n+            An instance of `MultiHostUrl`\n+        \"\"\"\n+        return cls(\n+            _CoreMultiHostUrl.build(\n+                scheme=scheme,\n+                hosts=hosts,\n+                username=username,\n+                password=password,\n+                host=host,\n+                port=port,\n+                path=path,\n+                query=query,\n+                fragment=fragment,\n+            )\n+        )\n+\n+    @classmethod\n+    def __get_pydantic_core_schema__(\n+        cls, source: type[_BaseMultiHostUrl], handler: GetCoreSchemaHandler\n+    ) -> core_schema.CoreSchema:\n         if issubclass(cls, source):\n-            return core_schema.multi_host_url_schema(**cls._constraints.defined_constraints)\n+\n+            def wrap_val(value, handler):\n+                if isinstance(value, source):\n+                    return value\n+                core_url = handler(value)\n+                instance = source.__new__(source)\n+                instance._url = core_url\n+                return instance",
        "comment_created_at": "2024-11-05T16:54:23+00:00",
        "comment_author": "davidhewitt",
        "comment_body": "I think if the `TypeAdapter` above just built the Rust URL, this wrap validator could be a lot simpler (and more like the form we drafted yesterday).",
        "pr_file_module": null
      },
      {
        "comment_id": "1829737945",
        "repo_full_name": "pydantic/pydantic",
        "pr_number": 10766,
        "pr_file": "pydantic/networks.py",
        "discussion_id": "1829698945",
        "commented_code": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)\n+\n+    def __init__(self, url: str | _CoreMultiHostUrl) -> None:\n+        if isinstance(url, self.__class__):\n+            self._url = url._url\n+        elif isinstance(url, _CoreMultiHostUrl):\n+            self._url = self._validator.validate_python(str(url))\n+        else:\n+            self._url = self._validator.validate_python(url)\n+\n+    @property\n+    def scheme(self) -> str:\n+        \"\"\"The scheme part of the URL.\n+\n+        e.g. `https` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.scheme\n+\n+    @property\n+    def path(self) -> str | None:\n+        \"\"\"The path part of the URL, or `None`.\n+\n+        e.g. `/path` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.path\n+\n+    @property\n+    def query(self) -> str | None:\n+        \"\"\"The query part of the URL, or `None`.\n+\n+        e.g. `query` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query\n+\n+    def query_params(self) -> list[tuple[str, str]]:\n+        \"\"\"The query part of the URL as a list of key-value pairs.\n+\n+        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query_params()\n+\n+    @property\n+    def fragment(self) -> str | None:\n+        \"\"\"The fragment part of the URL, or `None`.\n+\n+        e.g. `fragment` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.fragment\n+\n+    def hosts(self) -> list[MultiHostHost]:\n+        '''The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n+\n+        ```py\n+        from pydantic_core import MultiHostUrl\n+\n+        mhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\n+        print(mhu.hosts())\n+        \"\"\"\n+        [\n+            {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n+            {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n+        ]\n+        ```\n+        Returns:\n+            A list of dicts, each representing a host.\n+        '''\n+        return self._url.hosts()\n+\n+    def unicode_string(self) -> str:\n+        \"\"\"The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.\"\"\"\n+        return self._url.unicode_string()\n+\n+    def __str__(self) -> str:\n+        \"\"\"The URL as a string, this will punycode encode the host if required.\"\"\"\n+        return str(self._url)\n+\n+    def __repr__(self) -> str:\n+        return f'{self.__class__.__name__}({str(self._url)!r})'\n+\n+    def __deepcopy__(self, memo: dict) -> Self:\n+        return self.__class__(self._url)\n \n     @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def build(\n+        cls,\n+        *,\n+        scheme: str,\n+        hosts: list[MultiHostHost] | None = None,\n+        username: str | None = None,\n+        password: str | None = None,\n+        host: str | None = None,\n+        port: int | None = None,\n+        path: str | None = None,\n+        query: str | None = None,\n+        fragment: str | None = None,\n+    ) -> Self:\n+        \"\"\"Build a new `MultiHostUrl` instance from its component parts.\n+\n+        This method takes either `hosts` - a list of `MultiHostHost` typed dicts, or the individual components\n+        `username`, `password`, `host` and `port`.\n+\n+        Args:\n+            scheme: The scheme part of the URL.\n+            hosts: Multiple hosts to build the URL from.\n+            username: The username part of the URL.\n+            password: The password part of the URL.\n+            host: The host part of the URL.\n+            port: The port part of the URL.\n+            path: The path part of the URL.\n+            query: The query part of the URL, or omit for no query.\n+            fragment: The fragment part of the URL, or omit for no fragment.\n+\n+        Returns:\n+            An instance of `MultiHostUrl`\n+        \"\"\"\n+        return cls(\n+            _CoreMultiHostUrl.build(\n+                scheme=scheme,\n+                hosts=hosts,\n+                username=username,\n+                password=password,\n+                host=host,\n+                port=port,\n+                path=path,\n+                query=query,\n+                fragment=fragment,\n+            )\n+        )\n+\n+    @classmethod\n+    def __get_pydantic_core_schema__(\n+        cls, source: type[_BaseMultiHostUrl], handler: GetCoreSchemaHandler\n+    ) -> core_schema.CoreSchema:\n         if issubclass(cls, source):\n-            return core_schema.multi_host_url_schema(**cls._constraints.defined_constraints)\n+\n+            def wrap_val(value, handler):\n+                if isinstance(value, source):\n+                    return value\n+                core_url = handler(value)\n+                instance = source.__new__(source)\n+                instance._url = core_url\n+                return instance",
        "comment_created_at": "2024-11-05T17:18:29+00:00",
        "comment_author": "sydney-runkle",
        "comment_body": "See changes - I've sort of gone the other way here - wrap val is the same, but `__init__` is greatly simplified \ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  }
]