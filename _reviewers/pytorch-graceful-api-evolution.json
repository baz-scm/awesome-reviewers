[
  {
    "discussion_id": "2054079911",
    "pr_number": 151845,
    "pr_file": "torch/utils/hipify/hipify_python.py",
    "created_at": "2025-04-22T13:07:40+00:00",
    "commented_code": "return True\n \n \n-# Keep this synchronized with includes/ignores in build_amd.py\n+# deprecated",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2054079911",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 151845,
        "pr_file": "torch/utils/hipify/hipify_python.py",
        "discussion_id": "2054079911",
        "commented_code": "@@ -625,7 +618,7 @@ def is_out_of_place(rel_filepath):\n     return True\n \n \n-# Keep this synchronized with includes/ignores in build_amd.py\n+# deprecated",
        "comment_created_at": "2025-04-22T13:07:40+00:00",
        "comment_author": "albanD",
        "comment_body": "If this is to deprecate public APIs to be removed later, we should throw a warning for anyone using them",
        "pr_file_module": null
      },
      {
        "comment_id": "2061083420",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 151845,
        "pr_file": "torch/utils/hipify/hipify_python.py",
        "discussion_id": "2054079911",
        "commented_code": "@@ -625,7 +618,7 @@ def is_out_of_place(rel_filepath):\n     return True\n \n \n-# Keep this synchronized with includes/ignores in build_amd.py\n+# deprecated",
        "comment_created_at": "2025-04-26T00:48:58+00:00",
        "comment_author": "jeffdaily",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2091786482",
    "pr_number": 153596,
    "pr_file": "torch/_dynamo/callback.py",
    "created_at": "2025-05-15T18:51:49+00:00",
    "commented_code": "\"\"\"\n         self.start_callbacks.clear()\n         self.end_callbacks.clear()\n+        assert self.__pending_callbacks_counter == 0\n \n \n callback_handler = CompilationCallbackHandler()\n \n \n-def on_compile_start(callback: Callable[[], None]) -> Callable[[], None]:\n+def on_compile_start(\n+    callback: Callable[[CallbackArgs], None],\n+) -> Callable[[CallbackArgs], None]:\n     \"\"\"\n     Decorator to register a callback function for the start of the compilation.\n     \"\"\"\n     callback_handler.register_start_callback(callback)\n     return callback\n \n \n-def on_compile_end(callback: Callable[[], None]) -> Callable[[], None]:\n+def on_compile_end(\n+    callback: Callable[[CallbackArgs], None],\n+) -> Callable[[CallbackArgs], None]:",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2091786482",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153596,
        "pr_file": "torch/_dynamo/callback.py",
        "discussion_id": "2091786482",
        "commented_code": "@@ -122,20 +145,25 @@ def clear(self) -> None:\n         \"\"\"\n         self.start_callbacks.clear()\n         self.end_callbacks.clear()\n+        assert self.__pending_callbacks_counter == 0\n \n \n callback_handler = CompilationCallbackHandler()\n \n \n-def on_compile_start(callback: Callable[[], None]) -> Callable[[], None]:\n+def on_compile_start(\n+    callback: Callable[[CallbackArgs], None],\n+) -> Callable[[CallbackArgs], None]:\n     \"\"\"\n     Decorator to register a callback function for the start of the compilation.\n     \"\"\"\n     callback_handler.register_start_callback(callback)\n     return callback\n \n \n-def on_compile_end(callback: Callable[[], None]) -> Callable[[], None]:\n+def on_compile_end(\n+    callback: Callable[[CallbackArgs], None],\n+) -> Callable[[CallbackArgs], None]:",
        "comment_created_at": "2025-05-15T18:51:49+00:00",
        "comment_author": "burak-turk",
        "comment_body": "Would it make sense to introduce new APIs? I am guessing this change will cause type errors as the callback function being passed needs to have `CallbackArgs` argument.",
        "pr_file_module": null
      },
      {
        "comment_id": "2092082889",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153596,
        "pr_file": "torch/_dynamo/callback.py",
        "discussion_id": "2091786482",
        "commented_code": "@@ -122,20 +145,25 @@ def clear(self) -> None:\n         \"\"\"\n         self.start_callbacks.clear()\n         self.end_callbacks.clear()\n+        assert self.__pending_callbacks_counter == 0\n \n \n callback_handler = CompilationCallbackHandler()\n \n \n-def on_compile_start(callback: Callable[[], None]) -> Callable[[], None]:\n+def on_compile_start(\n+    callback: Callable[[CallbackArgs], None],\n+) -> Callable[[CallbackArgs], None]:\n     \"\"\"\n     Decorator to register a callback function for the start of the compilation.\n     \"\"\"\n     callback_handler.register_start_callback(callback)\n     return callback\n \n \n-def on_compile_end(callback: Callable[[], None]) -> Callable[[], None]:\n+def on_compile_end(\n+    callback: Callable[[CallbackArgs], None],\n+) -> Callable[[CallbackArgs], None]:",
        "comment_created_at": "2025-05-15T23:09:54+00:00",
        "comment_author": "xmfan",
        "comment_body": "Is the concern about backward compatibility? This is a private API and I didn't find any usage on github, we can address the internal type changes on the import diff. The \"new API\" offers a superset of the old, so I didn't see much value keeping it around.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1932905181",
    "pr_number": 138214,
    "pr_file": "torch/utils/_pytree.py",
    "created_at": "2025-01-28T21:47:47+00:00",
    "commented_code": "start = 0\n         end = 0\n         child_pytrees = []\n-        for child_spec in self.children_specs:\n+        for child_spec in self._children:\n             end += child_spec.num_leaves\n             child_pytrees.append(child_spec.unflatten(leaves[start:end]))\n             start = end\n \n-        return unflatten_fn(child_pytrees, self.context)\n+        return unflatten_fn(child_pytrees, self._context)\n \n \n+@deprecated(\n+    \"`isinstance(treespec, LeafSpec)` is deprecated, \"\n+    \"use `isinstance(treespec, TreeSpec)` and `treespec.is_leaf()` instead.\",\n+    category=FutureWarning,\n+)\n class LeafSpec(TreeSpec):\n     def __init__(self) -> None:\n         super().__init__(None, None, [])\n \n-    def __post_init__(self) -> None:\n-        object.__setattr__(self, \"num_nodes\", 1)\n-        object.__setattr__(self, \"num_leaves\", 1)\n-        object.__setattr__(self, \"num_children\", 0)\n-\n     def __repr__(self, indent: int = 0) -> str:\n         return \"*\"\n \n \n # All leaves are equivalent, so represent with a single object to save on\n # object construction time\n-_LEAF_SPEC = LeafSpec()\n+with warnings.catch_warnings():\n+    warnings.filterwarnings(\n+        \"ignore\", category=FutureWarning, module=__name__, append=False\n+    )\n+    _LEAF_SPEC = LeafSpec()\n+\n+\n+def treespec_leaf() -> LeafSpec:\n+    \"\"\"Make a treespec representing a leaf node.\"\"\"\n+    return _LEAF_SPEC",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "1932905181",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 138214,
        "pr_file": "torch/utils/_pytree.py",
        "discussion_id": "1932905181",
        "commented_code": "@@ -847,30 +873,59 @@ def unflatten(self, leaves: Iterable[Any]) -> PyTree:\n         start = 0\n         end = 0\n         child_pytrees = []\n-        for child_spec in self.children_specs:\n+        for child_spec in self._children:\n             end += child_spec.num_leaves\n             child_pytrees.append(child_spec.unflatten(leaves[start:end]))\n             start = end\n \n-        return unflatten_fn(child_pytrees, self.context)\n+        return unflatten_fn(child_pytrees, self._context)\n \n \n+@deprecated(\n+    \"`isinstance(treespec, LeafSpec)` is deprecated, \"\n+    \"use `isinstance(treespec, TreeSpec)` and `treespec.is_leaf()` instead.\",\n+    category=FutureWarning,\n+)\n class LeafSpec(TreeSpec):\n     def __init__(self) -> None:\n         super().__init__(None, None, [])\n \n-    def __post_init__(self) -> None:\n-        object.__setattr__(self, \"num_nodes\", 1)\n-        object.__setattr__(self, \"num_leaves\", 1)\n-        object.__setattr__(self, \"num_children\", 0)\n-\n     def __repr__(self, indent: int = 0) -> str:\n         return \"*\"\n \n \n # All leaves are equivalent, so represent with a single object to save on\n # object construction time\n-_LEAF_SPEC = LeafSpec()\n+with warnings.catch_warnings():\n+    warnings.filterwarnings(\n+        \"ignore\", category=FutureWarning, module=__name__, append=False\n+    )\n+    _LEAF_SPEC = LeafSpec()\n+\n+\n+def treespec_leaf() -> LeafSpec:\n+    \"\"\"Make a treespec representing a leaf node.\"\"\"\n+    return _LEAF_SPEC",
        "comment_created_at": "2025-01-28T21:47:47+00:00",
        "comment_author": "zou3519",
        "comment_body": "Is this supposed to be public API? What's the rationale behind this change?",
        "pr_file_module": null
      },
      {
        "comment_id": "1933338002",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 138214,
        "pr_file": "torch/utils/_pytree.py",
        "discussion_id": "1932905181",
        "commented_code": "@@ -847,30 +873,59 @@ def unflatten(self, leaves: Iterable[Any]) -> PyTree:\n         start = 0\n         end = 0\n         child_pytrees = []\n-        for child_spec in self.children_specs:\n+        for child_spec in self._children:\n             end += child_spec.num_leaves\n             child_pytrees.append(child_spec.unflatten(leaves[start:end]))\n             start = end\n \n-        return unflatten_fn(child_pytrees, self.context)\n+        return unflatten_fn(child_pytrees, self._context)\n \n \n+@deprecated(\n+    \"`isinstance(treespec, LeafSpec)` is deprecated, \"\n+    \"use `isinstance(treespec, TreeSpec)` and `treespec.is_leaf()` instead.\",\n+    category=FutureWarning,\n+)\n class LeafSpec(TreeSpec):\n     def __init__(self) -> None:\n         super().__init__(None, None, [])\n \n-    def __post_init__(self) -> None:\n-        object.__setattr__(self, \"num_nodes\", 1)\n-        object.__setattr__(self, \"num_leaves\", 1)\n-        object.__setattr__(self, \"num_children\", 0)\n-\n     def __repr__(self, indent: int = 0) -> str:\n         return \"*\"\n \n \n # All leaves are equivalent, so represent with a single object to save on\n # object construction time\n-_LEAF_SPEC = LeafSpec()\n+with warnings.catch_warnings():\n+    warnings.filterwarnings(\n+        \"ignore\", category=FutureWarning, module=__name__, append=False\n+    )\n+    _LEAF_SPEC = LeafSpec()\n+\n+\n+def treespec_leaf() -> LeafSpec:\n+    \"\"\"Make a treespec representing a leaf node.\"\"\"\n+    return _LEAF_SPEC",
        "comment_created_at": "2025-01-29T06:41:40+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "I think it could be public to provide a standard way to create `TreeSpec` instances without exposing the implementation details. `treespec_{leaf,tuple,dict}` are only used in `torch.export`, it could be private for now. But I think explicit public APIs are the better solution. See my comment below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1979926660",
    "pr_number": 148328,
    "pr_file": "torch/utils/_cxx_pytree.py",
    "created_at": "2025-03-04T17:40:26+00:00",
    "commented_code": "__all__ = [\n-    \"PyTree\",\n-    \"Context\",\n-    \"FlattenFunc\",\n-    \"UnflattenFunc\",\n-    \"DumpableContext\",\n-    \"ToDumpableContextFunc\",\n-    \"FromDumpableContextFunc\",\n-    \"PyTreeSpec\",\n-    \"TreeSpec\",\n-    \"LeafSpec\",",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "1979926660",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 148328,
        "pr_file": "torch/utils/_cxx_pytree.py",
        "discussion_id": "1979926660",
        "commented_code": "@@ -42,19 +41,10 @@\n \n \n __all__ = [\n-    \"PyTree\",\n-    \"Context\",\n-    \"FlattenFunc\",\n-    \"UnflattenFunc\",\n-    \"DumpableContext\",\n-    \"ToDumpableContextFunc\",\n-    \"FromDumpableContextFunc\",\n-    \"PyTreeSpec\",\n-    \"TreeSpec\",\n-    \"LeafSpec\",",
        "comment_created_at": "2025-03-04T17:40:26+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "`LeafSpec` is removed from `__all__`. Otherwise, the public API test will ask to add this to `test/allowlist_for_publicAPI.json`.\r\n\r\nThe `LeafSpec` functionality is deprecated and is going to be removed in the future. See also:\r\n\r\n- #138214\r\n\r\n```python\r\n# Previous code\r\nspec1 = LeafSpec()\r\nisinstance(spec2, LeafSpec)\r\n\r\n# New code\r\nspec1 = treespec_leaf()\r\nspec2.is_leaf()\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1978044581",
    "pr_number": 137400,
    "pr_file": "torch/utils/pytree/__init__.py",
    "created_at": "2025-03-03T19:11:51+00:00",
    "commented_code": "__all__ = [\n-    \"PyTree\",\n-    \"FlattenFunc\",\n-    \"UnflattenFunc\",\n-    \"FlattenWithKeysFunc\",\n-    \"ToDumpableContextFunc\",\n-    \"FromDumpableContextFunc\",",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "1978044581",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 137400,
        "pr_file": "torch/utils/pytree/__init__.py",
        "discussion_id": "1978044581",
        "commented_code": "@@ -33,12 +33,6 @@\n \n \n __all__ = [\n-    \"PyTree\",\n-    \"FlattenFunc\",\n-    \"UnflattenFunc\",\n-    \"FlattenWithKeysFunc\",\n-    \"ToDumpableContextFunc\",\n-    \"FromDumpableContextFunc\",",
        "comment_created_at": "2025-03-03T19:11:51+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "These type aliases are removed from `__all__`. Otherwise, the public API test will ask to add these to `test/allowlist_for_publicAPI.json`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070589459",
    "pr_number": 137400,
    "pr_file": "torch/utils/__init__.py",
    "created_at": "2025-05-01T17:59:15+00:00",
    "commented_code": "data as data,\n     deterministic as deterministic,\n     hooks as hooks,\n+    pytree as pytree,",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2070589459",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 137400,
        "pr_file": "torch/utils/__init__.py",
        "discussion_id": "2070589459",
        "commented_code": "@@ -11,6 +11,7 @@\n     data as data,\n     deterministic as deterministic,\n     hooks as hooks,\n+    pytree as pytree,",
        "comment_created_at": "2025-05-01T17:59:15+00:00",
        "comment_author": "zou3519",
        "comment_body": "Because we are offering an API to swap between python and C++ pytree in this PR, for this PR, I would like us to have finished making Python treespec and C++ treespec interoperable.\r\n\r\nThat is, one should be able to pass a treespec created from Python pytree to C++-pytree and vice versa. Otherwise there will be pain switching between the two APIs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2070626053",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 137400,
        "pr_file": "torch/utils/__init__.py",
        "discussion_id": "2070589459",
        "commented_code": "@@ -11,6 +11,7 @@\n     data as data,\n     deterministic as deterministic,\n     hooks as hooks,\n+    pytree as pytree,",
        "comment_created_at": "2025-05-01T18:27:10+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "Prepended a new PR in the stack to resolve this:\r\n\r\n- #152624",
        "pr_file_module": null
      }
    ]
  }
]