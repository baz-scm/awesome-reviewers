[
  {
    "discussion_id": "2106228684",
    "pr_number": 153150,
    "pr_file": "torch/_dynamo/utils.py",
    "created_at": "2025-05-25T15:08:17+00:00",
    "commented_code": "return next(itertools.islice(dict_class.keys(d), n, n + 1))\n\n\ndef set_getitem(s, n):\n    # Mimic set.__getitem__ by converting the set to a dict to have a partial\n    # ordering.\n    return list(dict.fromkeys(s))[n]",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2106228684",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2106228684",
        "commented_code": "@@ -2525,6 +2525,12 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by converting the set to a dict to have a partial\n+    # ordering.\n+    return list(dict.fromkeys(s))[n]",
        "comment_created_at": "2025-05-25T15:08:17+00:00",
        "comment_author": "Skylion007",
        "comment_body": "I wonder if itertools islice is better here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2106293442",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2106228684",
        "commented_code": "@@ -2525,6 +2525,12 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by converting the set to a dict to have a partial\n+    # ordering.\n+    return list(dict.fromkeys(s))[n]",
        "comment_created_at": "2025-05-25T19:58:51+00:00",
        "comment_author": "guilhermeleobas",
        "comment_body": "I guess this would only work if we sort the set first:\r\n\r\n```bash\r\n$ PYTHONHASHSEED=1 python -c 'import itertools; s = set(\"abc\"); print(list(itertools.islice(s, 0, None)))'\r\n['b', 'a', 'c']\r\n\r\n$ PYTHONHASHSEED=2 python -c 'import itertools; s = set(\"abc\"); print(list(itertools.islice(s, 0, None)))'\r\n['c', 'b', 'a']\r\n```\r\n\r\n```bash\r\n$ PYTHONHASHSEED=1 python -c 'import itertools; s = set(\"abc\"); print(list(itertools.islice(sorted(s), 0, None)))'\r\n['a', 'b', 'c']\r\n\r\n$ PYTHONHASHSEED=2 python -c 'import itertools; s = set(\"abc\"); print(list(itertools.islice(sorted(s), 0, None)))'\r\n['a', 'b', 'c']\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2109842371",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2106228684",
        "commented_code": "@@ -2525,6 +2525,12 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by converting the set to a dict to have a partial\n+    # ordering.\n+    return list(dict.fromkeys(s))[n]",
        "comment_created_at": "2025-05-27T18:07:15+00:00",
        "comment_author": "williamwen42",
        "comment_body": "Assuming here that `dict.fromkeys` will return the same order every time?",
        "pr_file_module": null
      },
      {
        "comment_id": "2110495363",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2106228684",
        "commented_code": "@@ -2525,6 +2525,12 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by converting the set to a dict to have a partial\n+    # ordering.\n+    return list(dict.fromkeys(s))[n]",
        "comment_created_at": "2025-05-27T23:20:13+00:00",
        "comment_author": "guilhermeleobas",
        "comment_body": "> Assuming here that dict.fromkeys will return the same order every time?\r\n\r\nYes! And I just realized that this is not guaranteed as well. I need to think if there's any alternative that we can use that gives a predictable ordering and does not depend on hash values.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2116629641",
    "pr_number": 153150,
    "pr_file": "torch/_dynamo/utils.py",
    "created_at": "2025-05-30T21:00:17+00:00",
    "commented_code": "return next(itertools.islice(dict_class.keys(d), n, n + 1))\n\n\ndef set_getitem(s, n):\n    # Mimic set.__getitem__ by sorting the set using the hash\n    return sorted(s, key=hash)[n]",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2116629641",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2116629641",
        "commented_code": "@@ -2530,6 +2530,11 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by sorting the set using the hash\n+    return sorted(s, key=hash)[n]",
        "comment_created_at": "2025-05-30T21:00:17+00:00",
        "comment_author": "williamwen42",
        "comment_body": "How will we deal with hash collisions? (What if the object has a custom hash that always returns 0?)",
        "pr_file_module": null
      },
      {
        "comment_id": "2122042749",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2116629641",
        "commented_code": "@@ -2530,6 +2530,11 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by sorting the set using the hash\n+    return sorted(s, key=hash)[n]",
        "comment_created_at": "2025-06-02T20:00:34+00:00",
        "comment_author": "zou3519",
        "comment_body": "Does this lead to anything worse than a recompile in the current PR?",
        "pr_file_module": null
      },
      {
        "comment_id": "2122108696",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2116629641",
        "commented_code": "@@ -2530,6 +2530,11 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by sorting the set using the hash\n+    return sorted(s, key=hash)[n]",
        "comment_created_at": "2025-06-02T20:37:57+00:00",
        "comment_author": "guilhermeleobas",
        "comment_body": "I don't think so. I couldn't actually create a test case for this because we don't support set of objects with custom hash functions:\r\nhttps://github.com/pytorch/pytorch/blob/48807d568ec5d4ad654fff27aaa1cec3b715c473/torch/_dynamo/variables/dicts.py#L101-L106",
        "pr_file_module": null
      },
      {
        "comment_id": "2122437629",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/utils.py",
        "discussion_id": "2116629641",
        "commented_code": "@@ -2530,6 +2530,11 @@ def dict_keys_getitem(d, n):\n     return next(itertools.islice(dict_class.keys(d), n, n + 1))\n \n \n+def set_getitem(s, n):\n+    # Mimic set.__getitem__ by sorting the set using the hash\n+    return sorted(s, key=hash)[n]",
        "comment_created_at": "2025-06-03T01:41:11+00:00",
        "comment_author": "guilhermeleobas",
        "comment_body": "If recompilation is the worst thing we can have, then one can just do `list(set_obj)[index]` instead. It will be faster than sorting the elements by the hash or calling `list(dict.fromkeys(set_object))[index]`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140304805",
    "pr_number": 153150,
    "pr_file": "torch/_dynamo/variables/builder.py",
    "created_at": "2025-06-11T14:11:47+00:00",
    "commented_code": "var = TorchFunctionModeVariable(value, source=self.source)\n            self.tx.output.side_effects.track_object_existing(value, var)\n            return var\n        elif istype(value, set):\n            self.install_guards(GuardBuilder.TYPE_MATCH)\n            self.install_guards(GuardBuilder.SEQUENCE_LENGTH)\n\n            # The dictionary gives a ordering for the set items\n            L = list(value)",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2140304805",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/variables/builder.py",
        "discussion_id": "2140304805",
        "commented_code": "@@ -755,6 +756,18 @@ def build_key_value(i, k, v):\n             var = TorchFunctionModeVariable(value, source=self.source)\n             self.tx.output.side_effects.track_object_existing(value, var)\n             return var\n+        elif istype(value, set):\n+            self.install_guards(GuardBuilder.TYPE_MATCH)\n+            self.install_guards(GuardBuilder.SEQUENCE_LENGTH)\n+\n+            # The dictionary gives a ordering for the set items\n+            L = list(value)",
        "comment_created_at": "2025-06-11T14:11:47+00:00",
        "comment_author": "zou3519",
        "comment_body": "Can you leave a comment here spifying:\r\n1) set ordering in cpython is based on hash value order\r\n2) the order being incorrect would just lead to a recompilation (no silent incorrectness)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140380541",
    "pr_number": 153150,
    "pr_file": "torch/_dynamo/guards.py",
    "created_at": "2025-06-11T14:39:31+00:00",
    "commented_code": "example_value=example_value,\n                guard_manager_enum=guard_manager_enum,\n            )\n        elif istype(source, SetGetItemSource):",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2140380541",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/guards.py",
        "discussion_id": "2140380541",
        "commented_code": "@@ -1284,6 +1290,14 @@ def get_guard_manager_from_source(self, source):\n                 example_value=example_value,\n                 guard_manager_enum=guard_manager_enum,\n             )\n+        elif istype(source, SetGetItemSource):",
        "comment_created_at": "2025-06-11T14:39:31+00:00",
        "comment_author": "zou3519",
        "comment_body": "One interesting thing I learned was that the hash of a set is not deterministic across interpreter runs. For example. try hash(\"a\") in different pythons. This means that this source isn't serializable (and precompile should not try to serialize it! cc @zhxchen17)\r\n\r\nWe should add a comment about this somewhere.",
        "pr_file_module": null
      },
      {
        "comment_id": "2140403574",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/guards.py",
        "discussion_id": "2140380541",
        "commented_code": "@@ -1284,6 +1290,14 @@ def get_guard_manager_from_source(self, source):\n                 example_value=example_value,\n                 guard_manager_enum=guard_manager_enum,\n             )\n+        elif istype(source, SetGetItemSource):",
        "comment_created_at": "2025-06-11T14:49:13+00:00",
        "comment_author": "zou3519",
        "comment_body": "Maybe rename it NonSerializableSetGetItemSource",
        "pr_file_module": null
      },
      {
        "comment_id": "2141162550",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/guards.py",
        "discussion_id": "2140380541",
        "commented_code": "@@ -1284,6 +1290,14 @@ def get_guard_manager_from_source(self, source):\n                 example_value=example_value,\n                 guard_manager_enum=guard_manager_enum,\n             )\n+        elif istype(source, SetGetItemSource):",
        "comment_created_at": "2025-06-11T21:41:44+00:00",
        "comment_author": "guilhermeleobas",
        "comment_body": "> One interesting thing I learned was that the hash of a set is not deterministic across interpreter runs. \r\n\r\nYou mean the set getitem, right? Because sets are non-hashable.",
        "pr_file_module": null
      },
      {
        "comment_id": "2141168033",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 153150,
        "pr_file": "torch/_dynamo/guards.py",
        "discussion_id": "2140380541",
        "commented_code": "@@ -1284,6 +1290,14 @@ def get_guard_manager_from_source(self, source):\n                 example_value=example_value,\n                 guard_manager_enum=guard_manager_enum,\n             )\n+        elif istype(source, SetGetItemSource):",
        "comment_created_at": "2025-06-11T21:46:49+00:00",
        "comment_author": "zou3519",
        "comment_body": "Sorry, what I meant was \"was that the hash of a string is not deterministic\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1386767400",
    "pr_number": 113258,
    "pr_file": "torch/utils/_pytree/api/python.py",
    "created_at": "2023-11-08T15:03:27+00:00",
    "commented_code": "_deque_unflatten,\n    serialized_type_name=\"collections.deque\",\n)\n_private_register_pytree_node(\n    structseq,\n    _structseq_flatten,\n    _structseq_unflatten,\n    serialized_type_name=\"structseq\",\n    to_dumpable_context=_structseq_serialize,\n    from_dumpable_context=_structseq_deserialize,\n)\n\n\ndef _get_node_type(tree: Any) -> Any:\n    node_type = type(tree)\n    if node_type not in SUPPORTED_NODES and is_namedtuple_class(node_type):\n        return namedtuple\n    node_type = tree.__class__  # Dynamo complains about using `type(tree)`",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "1386767400",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 113258,
        "pr_file": "torch/utils/_pytree/api/python.py",
        "discussion_id": "1386767400",
        "commented_code": "@@ -465,12 +491,23 @@ def _deque_unflatten(values: Iterable[Any], context: Context) -> Deque[Any]:\n     _deque_unflatten,\n     serialized_type_name=\"collections.deque\",\n )\n+_private_register_pytree_node(\n+    structseq,\n+    _structseq_flatten,\n+    _structseq_unflatten,\n+    serialized_type_name=\"structseq\",\n+    to_dumpable_context=_structseq_serialize,\n+    from_dumpable_context=_structseq_deserialize,\n+)\n \n \n def _get_node_type(tree: Any) -> Any:\n-    node_type = type(tree)\n-    if node_type not in SUPPORTED_NODES and is_namedtuple_class(node_type):\n-        return namedtuple\n+    node_type = tree.__class__  # Dynamo complains about using `type(tree)`",
        "comment_created_at": "2023-11-08T15:03:27+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "I'm a bit confused about this. The previous commit uses `node_type = type(tree)`. It works fine and passes all CI tests. But Dynamo asks for changing it to `node_type = tree.__class__` in the CI test in this PR.\r\n\r\n```\r\n[2023-11-08 23:04:51,484] [0/0] torch._dynamo.variables.higher_order_ops: [WARNING] speculate_subgraph: while introspecting wrap, we were unable to trace function `NestedUserFunctionVariable` into a single graph. This means that Dynamo was unable to prove safety for this API and will fall back to eager-mode PyTorch, which could lead to a slowdown.\r\n[2023-11-08 23:04:51,484] [0/0] torch._dynamo.variables.higher_order_ops: [ERROR] Can't access members of type(obj) for a generated custom object. Please use __class__ instead\r\n[2023-11-08 23:04:51,484] [0/0] torch._dynamo.variables.higher_order_ops: [ERROR] For more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\r\nEinline_call [(\"Can't access members of type(obj) for a generated custom object. Please use __class__ instead\\nFor more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\", 1)]\r\nunimplemented [(\"speculate_subgraph: while introspecting wrap, we were unable to trace function `NestedUserFunctionVariable` into a single graph. This means that Dynamo was unable to prove safety for this API and will fall back to eager-mode PyTorch, which could lead to a slowdown. Scroll up for the stack trace of the initial exception. The reason was: Can't access members of type(obj) for a generated custom object. Please use __class__ instead\\nFor more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\", 1)]\r\n```\r\n\r\nShould we change all `type(obj)` to `obj.__class__` in the pytree utilities?",
        "pr_file_module": null
      },
      {
        "comment_id": "1386815594",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 113258,
        "pr_file": "torch/utils/_pytree/api/python.py",
        "discussion_id": "1386767400",
        "commented_code": "@@ -465,12 +491,23 @@ def _deque_unflatten(values: Iterable[Any], context: Context) -> Deque[Any]:\n     _deque_unflatten,\n     serialized_type_name=\"collections.deque\",\n )\n+_private_register_pytree_node(\n+    structseq,\n+    _structseq_flatten,\n+    _structseq_unflatten,\n+    serialized_type_name=\"structseq\",\n+    to_dumpable_context=_structseq_serialize,\n+    from_dumpable_context=_structseq_deserialize,\n+)\n \n \n def _get_node_type(tree: Any) -> Any:\n-    node_type = type(tree)\n-    if node_type not in SUPPORTED_NODES and is_namedtuple_class(node_type):\n-        return namedtuple\n+    node_type = tree.__class__  # Dynamo complains about using `type(tree)`",
        "comment_created_at": "2023-11-08T15:35:09+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "Now the new CI test errors ask to change back to `node_type = type(tree)`.\r\n\r\nUse `node_type = type(tree)`, will get error:\r\n\r\n<details>\r\n<summary>Error outputs</summary>\r\n\r\n```console\r\n$ python test/dynamo/test_higher_order_ops.py -k test_access_module_attr\r\n[2023-11-08 23:32:18,089] [0/0] torch._dynamo.variables.higher_order_ops: [WARNING] speculate_subgraph: while introspecting wrap, we were unable to trace function `NestedUserFunctionVariable` into a single graph. This means that Dynamo was unable to prove safety for this API and will fall back to eager-mode PyTorch, which could lead to a slowdown.\r\n[2023-11-08 23:32:18,089] [0/0] torch._dynamo.variables.higher_order_ops: [ERROR] Can't access members of type(obj) for a generated custom object. Please use __class__ instead\r\n[2023-11-08 23:32:18,089] [0/0] torch._dynamo.variables.higher_order_ops: [ERROR] For more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\r\nEinline_call [(\"Can't access members of type(obj) for a generated custom object. Please use __class__ instead\\nFor more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\", 1)]\r\nunimplemented [(\"speculate_subgraph: while introspecting wrap, we were unable to trace function `NestedUserFunctionVariable` into a single graph. This means that Dynamo was unable to prove safety for this API and will fall back to eager-mode PyTorch, which could lead to a slowdown. Scroll up for the stack trace of the initial exception. The reason was: Can't access members of type(obj) for a generated custom object. Please use __class__ instead\\nFor more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\", 1)]\r\n\r\n======================================================================\r\nERROR: test_access_module_attr (__main__.HigherOrderOpTests.test_access_module_attr)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/higher_order_ops.py\", line 229, in speculate_subgraph\r\n    tree_flatten_output = tree_flatten.call_function(tx, [output], {})\r\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1298, in LOAD_ATTR\r\n    result = BuiltinVariable(getattr).call_function(\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/builtin.py\", line 614, in call_function\r\n    result = handler(tx, *args, **kwargs)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/builtin.py\", line 1151, in call_getattr\r\n    return obj.var_getattr(tx, name).clone(source=source)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/base.py\", line 262, in var_getattr\r\n    value = self.const_getattr(tx, name)\r\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/constant.py\", line 122, in const_getattr\r\n    raise UserError(\r\ntorch._dynamo.exc.UserError: Can't access members of type(obj) for a generated custom object. Please use __class__ instead\r\nFor more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/testing/_internal/common_utils.py\", line 2536, in wrapper\r\n    method(*args, **kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/test/dynamo/test_higher_order_ops.py\", line 1830, in test_access_module_attr\r\n    result = f(x)\r\n             ^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/eval_frame.py\", line 409, in _fn\r\n    return fn(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/eval_frame.py\", line 570, in catch_errors\r\n    return callback(frame, cache_entry, hooks, frame_state)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 377, in _convert_frame_assert\r\n    return _compile(\r\n           ^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 594, in _compile\r\n    guarded_code = compile_inner(code, one_graph, hooks, transform)\r\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/utils.py\", line 222, in time_wrapper\r\n    r = func(*args, **kwargs)\r\n        ^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 511, in compile_inner\r\n    out_code = transform_code_object(code, transform)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/bytecode_transformation.py\", line 1033, in transform_code_object\r\n    transformations(instructions, code_options)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 150, in _fn\r\n    return fn(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 476, in transform\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2120, in run\r\n    super().run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/higher_order_ops.py\", line 1227, in call_function\r\n    p_args, p_kwargs, example_value, treespec = self.create_wrapped_node(\r\n                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/higher_order_ops.py\", line 1186, in create_wrapped_node\r\n    ) = speculate_subgraph(\r\n        ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/higher_order_ops.py\", line 288, in speculate_subgraph\r\n    raise Unsupported(\r\ntorch._dynamo.exc.Unsupported: speculate_subgraph: while introspecting wrap, we were unable to trace function `NestedUserFunctionVariable` into a single graph. This means that Dynamo was unable to prove safety for this API and will fall back to eager-mode PyTorch, which could lead to a slowdown. Scroll up for the stack trace of the initial exception. The reason was: Can't access members of type(obj) for a generated custom object. Please use __class__ instead\r\nFor more information about this error, see: https://pytorch.org/docs/main/generated/exportdb/index.html#type-reflection-method\r\n\r\nfrom user code:\r\n   File \"/Users/PanXuehai/Projects/pytorch/test/dynamo/test_higher_order_ops.py\", line 1828, in f\r\n    return wrap(lambda y: y - mod.bias, y)\r\n\r\nSet TORCH_LOGS=\"+dynamo\" and TORCHDYNAMO_VERBOSE=1 for more information\r\n\r\n\r\nYou can suppress this exception and fall back to eager by setting:\r\n    import torch._dynamo\r\n    torch._dynamo.config.suppress_errors = True\r\n\r\n\r\nTo execute this test, run the following from the base repo dir:\r\n     python test/dynamo/test_higher_order_ops.py -k test_access_module_attr\r\n\r\nThis message can be suppressed by setting PYTORCH_PRINT_REPRO_ON_FAILURE=0\r\n\r\n----------------------------------------------------------------------\r\nRan 1 test in 0.089s\r\n\r\nFAILED (errors=1)\r\n```\r\n\r\n</details>\r\n\r\n------\r\n\r\nUse `node_type = tree.__class__`, will get error:\r\n\r\n<details>\r\n<summary>Error outputs</summary>\r\n\r\n```console\r\n$ python test/dynamo/test_misc.py -k test_tracing_tree_map_only\r\nEinline_call [('call_method ConstDictVariable() __contains__ [GetAttrVariable(ConstDictVariable(), __class__)] {}', 1)]\r\n\r\n======================================================================\r\nERROR: test_tracing_tree_map_only (__main__.MiscTests.test_tracing_tree_map_only)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/testing/_internal/common_utils.py\", line 2536, in wrapper\r\n    method(*args, **kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/test/dynamo/test_misc.py\", line 7174, in test_tracing_tree_map_only\r\n    comp_out = torch._dynamo.optimize(counter, nopython=True)(fn)(xsb)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/eval_frame.py\", line 409, in _fn\r\n    return fn(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/eval_frame.py\", line 570, in catch_errors\r\n    return callback(frame, cache_entry, hooks, frame_state)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 377, in _convert_frame_assert\r\n    return _compile(\r\n           ^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 594, in _compile\r\n    guarded_code = compile_inner(code, one_graph, hooks, transform)\r\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/utils.py\", line 222, in time_wrapper\r\n    r = func(*args, **kwargs)\r\n        ^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 511, in compile_inner\r\n    out_code = transform_code_object(code, transform)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/bytecode_transformation.py\", line 1033, in transform_code_object\r\n    transformations(instructions, code_options)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 150, in _fn\r\n    return fn(*args, **kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/convert_frame.py\", line 476, in transform\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2120, in run\r\n    super().run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 469, in wrapper\r\n    return inner_fn(self, inst)\r\n           ^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1799, in CALL\r\n    self.call_function(fn, args, kwargs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 650, in call_function\r\n    self.push(fn.call_function(self, args, kwargs))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 248, in call_function\r\n    return super().call_function(tx, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/functions.py\", line 81, in call_function\r\n    return tx.inline_user_function_return(\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 685, in inline_user_function_return\r\n    return InliningInstructionTranslator.inline_call(self, fn, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2252, in inline_call\r\n    return cls.inline_call_(parent, func, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 2384, in inline_call_\r\n    tracer.run()\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 815, in run\r\n    and self.step()\r\n        ^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 778, in step\r\n    getattr(self, inst.opname)(inst)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/symbolic_convert.py\", line 1639, in CONTAINS_OP\r\n    self.push(right.call_method(self, \"__contains__\", [left], {}))\r\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/dicts.py\", line 183, in call_method\r\n    return super().call_method(tx, name, args, kwargs)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/variables/base.py\", line 321, in call_method\r\n    raise unimplemented(f\"call_method {self} {name} {args} {kwargs}\")\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/_dynamo/exc.py\", line 192, in unimplemented\r\n    raise Unsupported(msg)\r\ntorch._dynamo.exc.Unsupported: call_method ConstDictVariable() __contains__ [GetAttrVariable(ConstDictVariable(), __class__)] {}\r\n\r\nfrom user code:\r\n   File \"/Users/PanXuehai/Projects/pytorch/test/dynamo/test_misc.py\", line 7166, in fn\r\n    y = pytree.tree_map_only(torch.Tensor, mapper, xs)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/utils/_pytree/api/python.py\", line 761, in tree_map_only\r\n    return tree_map(map_only(__type_or_types)(func), tree)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/utils/_pytree/api/python.py\", line 652, in tree_map\r\n    flat_args, spec = tree_flatten(tree)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/utils/_pytree/api/python.py\", line 587, in tree_flatten\r\n    spec = _tree_flatten_helper(tree, leaves)\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/utils/_pytree/api/python.py\", line 568, in _tree_flatten_helper\r\n    if _is_leaf(tree):\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/utils/_pytree/api/python.py\", line 516, in _is_leaf\r\n    return _get_node_type(tree) not in SUPPORTED_NODES\r\n  File \"/Users/PanXuehai/Projects/pytorch/torch/utils/_pytree/api/python.py\", line 506, in _get_node_type\r\n    if node_type not in SUPPORTED_NODES:\r\n\r\nSet TORCH_LOGS=\"+dynamo\" and TORCHDYNAMO_VERBOSE=1 for more information\r\n\r\n\r\nYou can suppress this exception and fall back to eager by setting:\r\n    import torch._dynamo\r\n    torch._dynamo.config.suppress_errors = True\r\n\r\n\r\nTo execute this test, run the following from the base repo dir:\r\n     python test/dynamo/test_misc.py -k test_tracing_tree_map_only\r\n\r\nThis message can be suppressed by setting PYTORCH_PRINT_REPRO_ON_FAILURE=0\r\n\r\n----------------------------------------------------------------------\r\nRan 1 test in 0.447s\r\n\r\nFAILED (errors=1)\r\n```\r\n\r\n</details>",
        "pr_file_module": null
      },
      {
        "comment_id": "1386923960",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 113258,
        "pr_file": "torch/utils/_pytree/api/python.py",
        "discussion_id": "1386767400",
        "commented_code": "@@ -465,12 +491,23 @@ def _deque_unflatten(values: Iterable[Any], context: Context) -> Deque[Any]:\n     _deque_unflatten,\n     serialized_type_name=\"collections.deque\",\n )\n+_private_register_pytree_node(\n+    structseq,\n+    _structseq_flatten,\n+    _structseq_unflatten,\n+    serialized_type_name=\"structseq\",\n+    to_dumpable_context=_structseq_serialize,\n+    from_dumpable_context=_structseq_deserialize,\n+)\n \n \n def _get_node_type(tree: Any) -> Any:\n-    node_type = type(tree)\n-    if node_type not in SUPPORTED_NODES and is_namedtuple_class(node_type):\n-        return namedtuple\n+    node_type = tree.__class__  # Dynamo complains about using `type(tree)`",
        "comment_created_at": "2023-11-08T16:47:26+00:00",
        "comment_author": "XuehaiPan",
        "comment_body": "I found that this error was caused by Dynamo not yet implementing `cls.__base__`.",
        "pr_file_module": null
      }
    ]
  }
]