[
  {
    "discussion_id": "2151442688",
    "pr_number": 156161,
    "pr_file": "aten/src/ATen/native/cpu/ScatterGatherKernel.cpp",
    "created_at": "2025-06-17T06:39:09+00:00",
    "commented_code": "TORCH_INTERNAL_ASSERT(false, \"radix_sort_parallel: ATen not compiled with FBGEMM support\");\n   return std::make_pair(nullptr, nullptr);\n }\n-\n }\n #endif\n \n+// implementation taken from FBGEMM/src/Utils.cc\n+namespace {\n+\n+// implementation taken from pytorch/c10/util/llvmMathExtras.h\n+template <typename T>\n+size_t count_leading_zeros(T val) {",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2151442688",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 156161,
        "pr_file": "aten/src/ATen/native/cpu/ScatterGatherKernel.cpp",
        "discussion_id": "2151442688",
        "commented_code": "@@ -661,10 +660,231 @@ std::pair<K*, V*> radix_sort_parallel(\n   TORCH_INTERNAL_ASSERT(false, \"radix_sort_parallel: ATen not compiled with FBGEMM support\");\n   return std::make_pair(nullptr, nullptr);\n }\n-\n }\n #endif\n \n+// implementation taken from FBGEMM/src/Utils.cc\n+namespace {\n+\n+// implementation taken from pytorch/c10/util/llvmMathExtras.h\n+template <typename T>\n+size_t count_leading_zeros(T val) {",
        "comment_created_at": "2025-06-17T06:39:09+00:00",
        "comment_author": "fadara01",
        "comment_body": "why not include `c10/util/llvmMathExtras.h` and use [LeadingZerosCounter](https://github.com/pytorch/pytorch/blob/main/c10/util/llvmMathExtras.h#L149)?",
        "pr_file_module": null
      },
      {
        "comment_id": "2163032428",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 156161,
        "pr_file": "aten/src/ATen/native/cpu/ScatterGatherKernel.cpp",
        "discussion_id": "2151442688",
        "commented_code": "@@ -661,10 +660,231 @@ std::pair<K*, V*> radix_sort_parallel(\n   TORCH_INTERNAL_ASSERT(false, \"radix_sort_parallel: ATen not compiled with FBGEMM support\");\n   return std::make_pair(nullptr, nullptr);\n }\n-\n }\n #endif\n \n+// implementation taken from FBGEMM/src/Utils.cc\n+namespace {\n+\n+// implementation taken from pytorch/c10/util/llvmMathExtras.h\n+template <typename T>\n+size_t count_leading_zeros(T val) {",
        "comment_created_at": "2025-06-24T06:03:16+00:00",
        "comment_author": "maajidkhann",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2052151055",
    "pr_number": 151218,
    "pr_file": "aten/src/ATen/mklrng/MKLGeneratorImpl.cpp",
    "created_at": "2025-04-21T08:53:56+00:00",
    "commented_code": "+#include <ATen/mklrng/MKLGeneratorImpl.h>\n+#include <ATen/Utils.h>\n+#include <cstdint>\n+\n+namespace at {\n+namespace detail {\n+\n+/**\n+ * PyTorch maintains a collection of default generators that get\n+ * initialized once. The purpose of these default generators is to\n+ * maintain a global running state of the pseudo random number generation,\n+ * when a user does not explicitly mention any generator.\n+ * getDefaultMKLGenerator gets the default generator for a particular\n+ * device.\n+ */\n+const Generator& getDefaultMKLGenerator() {\n+  static auto gen = createMKLGenerator(c10::detail::getNonDeterministicRandom());\n+  return gen;\n+}\n+\n+/**\n+ * Utility to create an MKLGeneratorImpl. Returns a shared_ptr\n+ */\n+Generator createMKLGenerator(uint64_t seed_val) {\n+  return make_generator<MKLGeneratorImpl>(seed_val);\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * MKLGeneratorImpl class implementation\n+ */\n+MKLGeneratorImpl::MKLGeneratorImpl(uint64_t seed_in)\n+  : c10::GeneratorImpl{Device(DeviceType::CPU), DispatchKeySet(c10::DispatchKey::CPU)},\n+    seed_(seed_in),\n+    offset_(0) {\n+    vslNewStream(&stream_, VSL_BRNG_MCG59, seed_);",
    "repo_full_name": "pytorch/pytorch",
    "discussion_comments": [
      {
        "comment_id": "2052151055",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 151218,
        "pr_file": "aten/src/ATen/mklrng/MKLGeneratorImpl.cpp",
        "discussion_id": "2052151055",
        "commented_code": "@@ -0,0 +1,155 @@\n+#include <ATen/mklrng/MKLGeneratorImpl.h>\n+#include <ATen/Utils.h>\n+#include <cstdint>\n+\n+namespace at {\n+namespace detail {\n+\n+/**\n+ * PyTorch maintains a collection of default generators that get\n+ * initialized once. The purpose of these default generators is to\n+ * maintain a global running state of the pseudo random number generation,\n+ * when a user does not explicitly mention any generator.\n+ * getDefaultMKLGenerator gets the default generator for a particular\n+ * device.\n+ */\n+const Generator& getDefaultMKLGenerator() {\n+  static auto gen = createMKLGenerator(c10::detail::getNonDeterministicRandom());\n+  return gen;\n+}\n+\n+/**\n+ * Utility to create an MKLGeneratorImpl. Returns a shared_ptr\n+ */\n+Generator createMKLGenerator(uint64_t seed_val) {\n+  return make_generator<MKLGeneratorImpl>(seed_val);\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * MKLGeneratorImpl class implementation\n+ */\n+MKLGeneratorImpl::MKLGeneratorImpl(uint64_t seed_in)\n+  : c10::GeneratorImpl{Device(DeviceType::CPU), DispatchKeySet(c10::DispatchKey::CPU)},\n+    seed_(seed_in),\n+    offset_(0) {\n+    vslNewStream(&stream_, VSL_BRNG_MCG59, seed_);",
        "comment_created_at": "2025-04-21T08:53:56+00:00",
        "comment_author": "CaoE",
        "comment_body": "Is the period of `VSL_BRNG_MCG59` long enough? Can we consider `VSL_BRNG_PHILOX4X32X10`, `VSL_BRNG_MT19937` ... ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2053732535",
        "repo_full_name": "pytorch/pytorch",
        "pr_number": 151218,
        "pr_file": "aten/src/ATen/mklrng/MKLGeneratorImpl.cpp",
        "discussion_id": "2052151055",
        "commented_code": "@@ -0,0 +1,155 @@\n+#include <ATen/mklrng/MKLGeneratorImpl.h>\n+#include <ATen/Utils.h>\n+#include <cstdint>\n+\n+namespace at {\n+namespace detail {\n+\n+/**\n+ * PyTorch maintains a collection of default generators that get\n+ * initialized once. The purpose of these default generators is to\n+ * maintain a global running state of the pseudo random number generation,\n+ * when a user does not explicitly mention any generator.\n+ * getDefaultMKLGenerator gets the default generator for a particular\n+ * device.\n+ */\n+const Generator& getDefaultMKLGenerator() {\n+  static auto gen = createMKLGenerator(c10::detail::getNonDeterministicRandom());\n+  return gen;\n+}\n+\n+/**\n+ * Utility to create an MKLGeneratorImpl. Returns a shared_ptr\n+ */\n+Generator createMKLGenerator(uint64_t seed_val) {\n+  return make_generator<MKLGeneratorImpl>(seed_val);\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * MKLGeneratorImpl class implementation\n+ */\n+MKLGeneratorImpl::MKLGeneratorImpl(uint64_t seed_in)\n+  : c10::GeneratorImpl{Device(DeviceType::CPU), DispatchKeySet(c10::DispatchKey::CPU)},\n+    seed_(seed_in),\n+    offset_(0) {\n+    vslNewStream(&stream_, VSL_BRNG_MCG59, seed_);",
        "comment_created_at": "2025-04-22T09:29:26+00:00",
        "comment_author": "michalowski-arm",
        "comment_body": "Sure, do you have a preference between the two? `VSL_BRNG_PHILOX4X32X10` appears to be faster from my brief testing.",
        "pr_file_module": null
      }
    ]
  }
]