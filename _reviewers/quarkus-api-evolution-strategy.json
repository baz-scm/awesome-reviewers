[
  {
    "discussion_id": "1171239396",
    "pr_number": 32691,
    "pr_file": "extensions/cache/runtime-spi/src/main/java/io/quarkus/cache/Cache.java",
    "created_at": "2023-04-19T12:04:49+00:00",
    "commented_code": "*/\n     <K, V> Uni<V> get(K key, Function<K, V> valueLoader);\n \n+    <K, V> Uni<V> get(K key, Function<K, V> valueLoader, Duration expiresIn);",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1171239396",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 32691,
        "pr_file": "extensions/cache/runtime-spi/src/main/java/io/quarkus/cache/Cache.java",
        "discussion_id": "1171239396",
        "commented_code": "@@ -42,6 +43,8 @@ public interface Cache {\n      */\n     <K, V> Uni<V> get(K key, Function<K, V> valueLoader);\n \n+    <K, V> Uni<V> get(K key, Function<K, V> valueLoader, Duration expiresIn);",
        "comment_created_at": "2023-04-19T12:04:49+00:00",
        "comment_author": "mkouba",
        "comment_body": "We'll need a proper javadoc here. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1171240767",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 32691,
        "pr_file": "extensions/cache/runtime-spi/src/main/java/io/quarkus/cache/Cache.java",
        "discussion_id": "1171239396",
        "commented_code": "@@ -42,6 +43,8 @@ public interface Cache {\n      */\n     <K, V> Uni<V> get(K key, Function<K, V> valueLoader);\n \n+    <K, V> Uni<V> get(K key, Function<K, V> valueLoader, Duration expiresIn);",
        "comment_created_at": "2023-04-19T12:06:07+00:00",
        "comment_author": "mkouba",
        "comment_body": "Also it might make sense to rename the `expiresIn` param to `expiresAfter` in order to align with the Caffeine API.",
        "pr_file_module": null
      },
      {
        "comment_id": "1171242513",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 32691,
        "pr_file": "extensions/cache/runtime-spi/src/main/java/io/quarkus/cache/Cache.java",
        "discussion_id": "1171239396",
        "commented_code": "@@ -42,6 +43,8 @@ public interface Cache {\n      */\n     <K, V> Uni<V> get(K key, Function<K, V> valueLoader);\n \n+    <K, V> Uni<V> get(K key, Function<K, V> valueLoader, Duration expiresIn);",
        "comment_created_at": "2023-04-19T12:07:52+00:00",
        "comment_author": "mkouba",
        "comment_body": "And in terms of the API evolution it might be reasonable to introduce a Quarkus-specific `Expiry` object/interface instead...",
        "pr_file_module": null
      },
      {
        "comment_id": "1171258727",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 32691,
        "pr_file": "extensions/cache/runtime-spi/src/main/java/io/quarkus/cache/Cache.java",
        "discussion_id": "1171239396",
        "commented_code": "@@ -42,6 +43,8 @@ public interface Cache {\n      */\n     <K, V> Uni<V> get(K key, Function<K, V> valueLoader);\n \n+    <K, V> Uni<V> get(K key, Function<K, V> valueLoader, Duration expiresIn);",
        "comment_created_at": "2023-04-19T12:22:47+00:00",
        "comment_author": "rmanibus",
        "comment_body": "what signature do you imagine with this expiry object ? \r\nsomething like \r\n\r\n`<K, V> Uni<V> get(K key, Function<K, V> valueLoader, Expiry expiry);` ?\r\n\r\nI think it has the benefit of allowing a more fine grained control (expire after create, expire after update)\r\n\r\nHowever the expiration must still be computed every time for a read, we could avoid that by returning it from the value loader but I am not sure how to do it since it would have the same erasure. maybe with a new method name ?\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2083857903",
    "pr_number": 47756,
    "pr_file": "extensions/assistant/deployment-spi/src/main/java/io/quarkus/assistant/deployment/spi/Assistant.java",
    "created_at": "2025-05-12T05:44:24+00:00",
    "commented_code": "+package io.quarkus.assistant.deployment.spi;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+\n+/**",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2083857903",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47756,
        "pr_file": "extensions/assistant/deployment-spi/src/main/java/io/quarkus/assistant/deployment/spi/Assistant.java",
        "discussion_id": "2083857903",
        "commented_code": "@@ -0,0 +1,54 @@\n+package io.quarkus.assistant.deployment.spi;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+\n+/**",
        "comment_created_at": "2025-05-12T05:44:24+00:00",
        "comment_author": "cescoffier",
        "comment_body": "Regarding API, @geoand and @mariofusco use \"records\" to encapsulate the parameters. At some point, we will likely add more parameters (typically, output schema, maybe guardrails...). I wonder if we should do the same to avoid having methods with many parameters and overloading.",
        "pr_file_module": null
      },
      {
        "comment_id": "2083866760",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47756,
        "pr_file": "extensions/assistant/deployment-spi/src/main/java/io/quarkus/assistant/deployment/spi/Assistant.java",
        "discussion_id": "2083857903",
        "commented_code": "@@ -0,0 +1,54 @@\n+package io.quarkus.assistant.deployment.spi;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+\n+/**",
        "comment_created_at": "2025-05-12T05:52:24+00:00",
        "comment_author": "geoand",
        "comment_body": "+1.\r\n\r\nThis is done because like @cescoffier alluded to, it's very hard to know at the SPI creation time what exact options will be neede, so by introducing an \"object\" to encapsulate all params, we can add new ones in the future without breaking existing SPI implementations.\r\nFurthermore, for maximum flexibility, using a interface instead of a record is best for these parameters, but as they are meant to be only be consumed (and are created by the caller of the SPI, hence under our complete control), it should't make a difference.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2088101329",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47756,
        "pr_file": "extensions/assistant/deployment-spi/src/main/java/io/quarkus/assistant/deployment/spi/Assistant.java",
        "discussion_id": "2083857903",
        "commented_code": "@@ -0,0 +1,54 @@\n+package io.quarkus.assistant.deployment.spi;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+\n+/**",
        "comment_created_at": "2025-05-14T05:57:01+00:00",
        "comment_author": "phillip-kruger",
        "comment_body": "@cescoffier let's discuss this, I think the way I have done it allows for the same",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1827816273",
    "pr_number": 44105,
    "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
    "created_at": "2024-11-04T14:23:01+00:00",
    "commented_code": "package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1827816273",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-04T14:23:01+00:00",
        "comment_author": "ynojima",
        "comment_body": "With the current implementation of the \"webauthn/login-challenge\" endpoint, a new challenge value is generated every time the endpoint is called. \r\n\r\nFor this reason, the \"webauthn/login-challenge\" endpoint is implemented using a POST method, and its name focuses on \"challenge\" to highlight its side effects.\r\nHowever, generating a new challenge value on each call is inappropriate. The challenge should use the value stored in the session if it exists, and only generate a new one if no value is present in the session.\r\n\r\nIn the current implementation, if the \"webauthn/login-challenge\" endpoint is called multiple times, only the challenge value from the last call is valid.\r\nHowever, there are cases where only the last challenge being valid is problematic \u2014 for example, in passkeys autofill. \r\nWith passkey autofill, `navigator.credentials.get` must be called on page load, which also requires fetching the challenge on page load.\r\nhttps://passkeys.dev/docs/use-cases/bootstrapping/#authenticating-the-user\r\n\r\nBut what happens if multiple tabs with the autofill-enabled page are open? The autofill will work only on the last opened tab, while the others encounter an error due to a mismatch in the challenge. \r\nTherefore, instead of generating a new challenge value each time the endpoint is called, same challenge value should be kept in a session.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1827824813",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-04T14:28:20+00:00",
        "comment_author": "FroMage",
        "comment_body": "I see\u2026 but the challenge is stored in the session. It's just re-created every time. I could make it re-use the challenge if it already exists, but the challenge is tied to the user name. How does passkeys autofill know which uesrname to invoke on page load?",
        "pr_file_module": null
      },
      {
        "comment_id": "1827912588",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-04T15:21:44+00:00",
        "comment_author": "ynojima",
        "comment_body": "The session should not be tied to the user name.\r\nIn the current implementation, `getLoginChallenge` requires `userName` as a required parameter, but it shouldn't be mandatory. \r\nWith [discoverable credentials](https://www.w3.org/TR/webauthn-3/#discoverable-credential), login is possible without specifying a list of credential IDs in [`allowCredentials`](https://www.w3.org/TR/webauthn-3/#dom-publickeycredentialrequestoptions-allowcredentials), so userName input is not required.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1827969575",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-04T15:55:17+00:00",
        "comment_author": "FroMage",
        "comment_body": "Ah.\r\nI'm not sure I fully understand. I find this spec fairly confusing, and I'm unsure about how user names or display names are related to webauthn.\r\nSo, you're saying a user name is not required for login. I suppose in terms of implementation we'll look up the credentials by credential ID, so fine. In terms of UI, though, are we supposed to make the user name even optional or there's no point in asking for a user name for logins?\r\nAnd, we still require a user name for registration, correct?",
        "pr_file_module": null
      },
      {
        "comment_id": "1828027102",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-04T16:31:24+00:00",
        "comment_author": "ynojima",
        "comment_body": "> So, you're saying a user name is not required for login. \r\n\r\nNo, user name is not required for login.\r\n\r\nFor example, when you try to login GitHub with passkeys, you will see login page like this:\r\n![image](https://github.com/user-attachments/assets/3b616a31-7d7d-4bd4-a4ae-1a0bb752713a)\r\n\r\nYou can login with passkeys without filling the username field.\r\n\r\n> we still require a user name for registration, correct?\r\n\r\nyes, user name or display name is used as a label for the credential in the account selector dialog.\r\nWhen you click \"Sign in with passkey\" button, it will show dialog like this.\r\n![image](https://github.com/user-attachments/assets/358e97c4-0542-4b3b-aa8c-0074452b3738)\r\n\r\nThe \"ynojima\" is a value specified as a \"display name\" at the point of registration.\r\n\r\nWhen you create a webauthn credential with `requireResidentKey` true, a discoverable credential data is created in the security key (if you are using security key) or in the passkey manager (if you are using synced passkey manager like Google Password Manager), and the discoverable credential data is consisted from its credential id, private key, user name, display name, counter value and etc.\r\nThe user name and display name of the credential data is only used for the account selector dialog.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1828061579",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-04T16:55:03+00:00",
        "comment_author": "FroMage",
        "comment_body": "OK thanks a lot for the explanation. I suppose I need to update the code then.",
        "pr_file_module": null
      },
      {
        "comment_id": "1829736881",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-05T17:17:43+00:00",
        "comment_author": "FroMage",
        "comment_body": "If I do that, though, then I can't support my yubikey because it's not a passkey one, whereas requiring a username made it usable :-/\r\nNot sure how to properly handle the UI for that case :-/",
        "pr_file_module": null
      },
      {
        "comment_id": "1830498800",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T07:17:35+00:00",
        "comment_author": "ynojima",
        "comment_body": "Does \"my YubiKey is not a passkey one\" mean the a Yubikey that does not support [\"Discoverable Credentials\"](https://www.w3.org/TR/webauthn-3/#client-side-discoverable-public-key-credential-source)?\r\nFor versions of Yubikey that lack \"Discoverable Credential\" support, known as [\"Non-Discoverable Credentials\"](https://www.w3.org/TR/webauthn-3/#non-discoverable-credential), the `allowCredentials` option must be specified when calling `navigator.credentials.get`.\r\n\r\nThus, to accommodate Yubikeys that lack \"Discoverable Credentials\" support, the login form should begin by asking users to input their username and password as a first step to avoid the account enumeration issue.\r\nThen, `navigator.credentials.get` need to be called with the `allowCredentials` option in a second step for two-factor authentication. \r\nConsequently, the endpoint that returns the \"options\" should include `allowCredentials` option for authenticated requests but omit it for unauthenticated requests.\r\n`AttestationOptionsProviderImpl` of webauthn4j-spring-security can be an example:\r\nhttps://github.com/webauthn4j/webauthn4j-spring-security/blob/master/webauthn4j-spring-security-core/src/main/java/com/webauthn4j/springframework/security/options/AttestationOptionsProviderImpl.java\r\n\r\nOr, do you concern that users of Yubikeys without Discoverable Credential support might mistakenly attempt to use a \"Sign in with Passkeys\" button, which only supports Discoverable Credentials causing errors and a less satisfactory user experience? \r\nIf so, instead of providing a \"Sign in with Passkeys\" button on the login screen, you could implement [Passkey Autofill](https://passkeys.dev/docs/use-cases/bootstrapping/) to display a dropdown only when passkeys are available. This approach can introduce passkeys smoothly without confusing users who lack passkey support.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1830704216",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T09:55:24+00:00",
        "comment_author": "FroMage",
        "comment_body": "OK, well, yes. I have a Yubikey that does not support Discoverable Credentials.\r\n\r\nI've always been able to use it to login, by providing a username and not any password. Requiring that I type a password before I use it defeats the purpose I think.\r\n\r\nBut I can't use it as a passkey.\r\n\r\nSo, on my browser, which supports passkeys, I have both options available: passkeys or non-discoverable credentials.\r\n\r\nDuring account creation, it's the same flow: enter username, create credentials and the browser will ask me whether to create a passkeys or use my yubikey and get a non-discoverable credential. So no UI problem.\r\n\r\nOn login though, it looks like I need two flows: one with username -> yubikey, and another for passkeys (no username). That seems a bit confusing.",
        "pr_file_module": null
      },
      {
        "comment_id": "1830885361",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T11:49:00+00:00",
        "comment_author": "ynojima",
        "comment_body": "When authenticating with only a username and a security key supporting \"non-discoverable credentials,\" the \"webauthn/login-challenge\" endpoint needs to return `allowCredentials` data based on the username for unauthenticated requests. \r\nThis could lead to account enumeration issue; however, prioritizing user-experience, it could be reasonable to return `allowCredentials` to unauthenticated requests. \r\nFor Quarkus, how about offering a configuration option that allows framework users to choose whether to return `allowCredentials` for unauthenticated requests?\r\n\r\n> On login though, it looks like I need two flows: one with username -> yubikey, and another for passkeys (no username). That seems a bit confusing.\r\n\r\nMaybe to avoid this confusion, Google has designed its login form to request the username even for \"Discoverable Credentials\" (passkeys). \r\nIt seems like everyone is still figuring out the best approach.",
        "pr_file_module": null
      },
      {
        "comment_id": "1830940588",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T12:29:54+00:00",
        "comment_author": "FroMage",
        "comment_body": "> For Quarkus, how about offering a configuration option that allows framework users to choose whether to return `allowCredentials` for unauthenticated requests?\r\n\r\nThat makes a lot of sense.\r\n\r\n> It seems like everyone is still figuring out the best approach.\r\n\r\nYes, every time it looks like the paint is still fresh \ud83d\ude05",
        "pr_file_module": null
      },
      {
        "comment_id": "1831134596",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T14:40:06+00:00",
        "comment_author": "FroMage",
        "comment_body": "Actually, Google requests the username but won't let me use my yubikey without typing a password first. They're listed separately from passkeys, as \"2FA keys\" and they require a password first.",
        "pr_file_module": null
      },
      {
        "comment_id": "1831153654",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T14:51:18+00:00",
        "comment_author": "FroMage",
        "comment_body": "GitHub has a fairly complex UI which also ATM denies using my yubikey as a login method, only allowing passkeys.\r\nBUT there's a UI to \"Upgrade your security key registration to a passkey\", which asks me to register a PIN code with it because I can use it as a passkey.\r\nPasskeys are listed differently to \"security keys\".\r\nI assume the difference is that these sorts of keys are not 2FA alone, so they need to be paired with either a password or a PIN code \ud83e\udd37",
        "pr_file_module": null
      },
      {
        "comment_id": "1831193695",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-06T15:07:42+00:00",
        "comment_author": "FroMage",
        "comment_body": "So, turns out once I set a PIN on this security key, I can store up to 25 passkeys on it. This works on github, but not on my Quarkus app, so I must be missing some setting. I'll try to find the difference.",
        "pr_file_module": null
      },
      {
        "comment_id": "1831917991",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-07T01:07:20+00:00",
        "comment_author": "ynojima",
        "comment_body": "WebAuthn was initially introduced as a non-discoverable credential on various sites, because Chrome had not supported discoverable credentials for a long time. At that time, it was labeled as \"Security Key\" or \"2FA Keys\".\r\nLater, when Chrome began supporting discoverable credentials, these sites added support for discoverable credential as well, distinguishing them with the label \"passkeys\".\r\n\r\nIf you added your YubiKey to GitHub a few years ago, it was probably registered as a \"2FA key\" because \"discoverable credentials\" (passkeys) were not supported at the time.\r\n\r\n> This works on github, but not on my Quarkus app, so I must be missing some setting. I'll try to find the difference.\r\n\r\nAs current Quarkus WebAuthn implementation requests WebAuthn credential with `ResidentKey.DISCOURAGED` option by default, Yubikey and other FIDO2 compliant security keys return non-discoverable credential (non-resident key is equal to non-discoverable credential). \r\nhttps://github.com/quarkusio/quarkus/blob/370c50829579f7409a9e91bb0a3cb6a94cc7110c/extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java#L234\r\nIf you specify `quarkus.webauthn.resident-key=required` or `quarkus.webauthn.resident-key=preferred`, I think you can create discoverable credential (resident key) in your Yubikey with your Quarkus app.\r\nOn a related note, Passkeys by Google Password Manager returns discoverable credential even if `ResidentKey.DISCOURAGED` is specified.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1832653297",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-07T13:08:45+00:00",
        "comment_author": "FroMage",
        "comment_body": "> If you added your YubiKey to GitHub a few years ago, it was probably registered as a \"2FA key\" because \"discoverable credentials\" (passkeys) were not supported at the time.\r\n\r\nAh, that explains it.\r\n\r\n> As current Quarkus WebAuthn implementation requests WebAuthn credential with ResidentKey.DISCOURAGED option by default, Yubikey and other FIDO2 compliant security keys return non-discoverable credential (non-resident key is equal to non-discoverable credential).\r\n\r\nShould I change that default, then?\r\n\r\nI was able to fix my problem indeed by changing it. I don't understand why, before to changing that setting, it let me use it for registration but not login. That option only appears to come into play for registration.",
        "pr_file_module": null
      },
      {
        "comment_id": "1832854470",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-07T15:13:01+00:00",
        "comment_author": "ynojima",
        "comment_body": "With the default `ResidentKey.DISCOURAGED` option, a non-discoverable credential will be created at registration.\r\nI assume in your local environment, the `login-challenge` endpoint currently does not return `allowCredentials` option.\r\nIf the `allowCredentials` option is not provided, non-discoverable credentials cannot be found, leading to the login failure.\r\n\r\nYou might wonder why authentication with a non-discoverable credential is not possible without the `allowCredentials` option.\r\nThe answer lies in the tricky implementation of non-discoverable credentials. Due to storage limitation of security keys, the authentication key is encrypted and stored within the credential ID, making it essential to provide the credential ID through the `allowCredentials` option. \r\nWith this technique, hardware security keys like Yubikey can support unlimited number of non-discoverable credentials.\r\nFor more information, please refer to the page below: \r\nhttps://crypto.stackexchange.com/questions/105942/how-do-non-resident-keys-work-in-webauthn\r\n\r\n\r\n> Should I change that default, then?\r\n\r\nIf you expect the created WebAuthn credential to function only as a second factor, `ResidentKey.DISCOURAGED` would be appropriate.\r\nIf you need a Discoverable Credential(passkey) that allows login without even requiring username input, then `ResidentKey.REQUIRED` is suitable.\r\nAs for the default value in Quarkus, it depends on which use case you want to prioritize, but if you choose `ResidentKey.REQUIRED`, please note that this would be a breaking change, as the previous Quarkus Security WebAuthn defaulted `quarkus.webauthn.require-resident-key` to false.",
        "pr_file_module": null
      },
      {
        "comment_id": "1832895196",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-07T15:37:04+00:00",
        "comment_author": "FroMage",
        "comment_body": "Well, this PR is full of lots of breaking changes. I suppose the main use-case nowadays would be passkeys\u2026",
        "pr_file_module": null
      },
      {
        "comment_id": "1832911771",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-07T15:47:17+00:00",
        "comment_author": "ynojima",
        "comment_body": "Yes, if breaking change is allowed, I prefer `ResidentKey.REQUIRED` too :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1832939999",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-07T16:03:01+00:00",
        "comment_author": "ynojima",
        "comment_body": "For passkey use cases, it is preferable for the default value of `quarkus.webauthn.user-verification` to be set to `REQUIRED` too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1838416400",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1827816273",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),\n+                            new FIDOU2FAttestationStatementAsyncVerifier(),\n+                            new PackedAttestationStatementAsyncVerifier(),\n+                            new TPMAttestationStatementAsyncVerifier(),\n+                            new AndroidKeyAttestationStatementAsyncVerifier(),\n+                            new AndroidSafetyNetAttestationStatementAsyncVerifier(),\n+                            new AppleAnonymousAttestationStatementAsyncVerifier()),\n+                    new DefaultCertPathTrustworthinessAsyncVerifier(something),\n+                    new DefaultSelfAttestationTrustworthinessAsyncVerifier(),\n+                    objectConverter);\n+\n+        } else {\n+            return WebAuthnAsyncManager.createNonStrictWebAuthnAsyncManager(objectConverter);\n         }\n-        if (config.transports().isPresent()) {\n-            options.setTransports(config.transports().get());\n+    }\n+\n+    private void addCert(KeyStore keyStore, String pemCertificate) throws CertificateException, KeyStoreException {\n+        X509Certificate cert = JWS.parseX5c(pemCertificate);\n+        CertInfo info = CertificateHelper.getCertInfo(cert);\n+        keyStore.setCertificateEntry(info.subject(\"CN\"), cert);\n+    }\n+\n+    private static byte[] uUIDBytes(UUID uuid) {\n+        Buffer buffer = Buffer.buffer(16);\n+        buffer.setLong(0, uuid.getMostSignificantBits());\n+        buffer.setLong(8, uuid.getLeastSignificantBits());\n+        return buffer.getBytes();\n+    }\n+\n+    public Uni<PublicKeyCredentialCreationOptions> getRegisterChallenge(String userName, String displayName,\n+            RoutingContext ctx) {\n+        if (userName == null || userName.isEmpty()) {\n+            return Uni.createFrom().failure(new IllegalArgumentException(\"Username is required\"));\n         }\n-        if (config.userVerification().isPresent()) {\n-            options.setUserVerification(config.userVerification().get());\n+        // default displayName to userName, but it's required really\n+        if (displayName == null || displayName.isEmpty()) {\n+            displayName = userName;\n         }\n-        webAuthn = WebAuthn.create(vertx, options)\n-                // where to load/update authenticators data\n-                .authenticatorFetcher(database::fetcher)\n-                .authenticatorUpdater(database::updater);\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n+        String finalDisplayName = displayName;\n+        String challenge = randomBase64URLBuffer();",
        "comment_created_at": "2024-11-12T16:30:42+00:00",
        "comment_author": "FroMage",
        "comment_body": "I can do that.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070158206",
    "pr_number": 47650,
    "pr_file": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/OidcTenantConfigBuilder.java",
    "created_at": "2025-05-01T11:06:31+00:00",
    "commented_code": "public Logout getLogout() {\n         return logout;\n     }\n+\n+    /**\n+     * Merge the current tenant (represented by this builder) and well-known OpenId Connect provider configurations.\n+     * Initialized properties take priority over uninitialized properties.\n+     *\n+     * Initialized properties in the current tenant configuration take priority\n+     * over the same initialized properties in the well-known OpenId Connect provider configuration.\n+     *\n+     * @param tenant well-known OpenId Connect provider configuration\n+     */\n+    public OidcTenantConfigBuilder mergeTenant(io.quarkus.oidc.OidcTenantConfig tenant) {",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2070158206",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47650,
        "pr_file": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/OidcTenantConfigBuilder.java",
        "discussion_id": "2070158206",
        "commented_code": "@@ -1239,4 +1253,101 @@ public Token getToken() {\n     public Logout getLogout() {\n         return logout;\n     }\n+\n+    /**\n+     * Merge the current tenant (represented by this builder) and well-known OpenId Connect provider configurations.\n+     * Initialized properties take priority over uninitialized properties.\n+     *\n+     * Initialized properties in the current tenant configuration take priority\n+     * over the same initialized properties in the well-known OpenId Connect provider configuration.\n+     *\n+     * @param tenant well-known OpenId Connect provider configuration\n+     */\n+    public OidcTenantConfigBuilder mergeTenant(io.quarkus.oidc.OidcTenantConfig tenant) {",
        "comment_created_at": "2025-05-01T11:06:31+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik Michal, I'm still not sure this one belongs here. It is a `utility` method, and not part of the `OidcTenantConfigBuilder` API.  The reason it is not part of this API is that users who build `OidcTenantConfig` with this builder won't be able to use this method for building this config instance, and therefore it does not belong in this builder API.",
        "pr_file_module": null
      },
      {
        "comment_id": "2070167082",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47650,
        "pr_file": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/OidcTenantConfigBuilder.java",
        "discussion_id": "2070158206",
        "commented_code": "@@ -1239,4 +1253,101 @@ public Token getToken() {\n     public Logout getLogout() {\n         return logout;\n     }\n+\n+    /**\n+     * Merge the current tenant (represented by this builder) and well-known OpenId Connect provider configurations.\n+     * Initialized properties take priority over uninitialized properties.\n+     *\n+     * Initialized properties in the current tenant configuration take priority\n+     * over the same initialized properties in the well-known OpenId Connect provider configuration.\n+     *\n+     * @param tenant well-known OpenId Connect provider configuration\n+     */\n+    public OidcTenantConfigBuilder mergeTenant(io.quarkus.oidc.OidcTenantConfig tenant) {",
        "comment_created_at": "2025-05-01T11:21:49+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "ok, it will bring extra processing to move it, but I'll move it, not a problem (I expected it :-) )",
        "pr_file_module": null
      },
      {
        "comment_id": "2070185926",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47650,
        "pr_file": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/OidcTenantConfigBuilder.java",
        "discussion_id": "2070158206",
        "commented_code": "@@ -1239,4 +1253,101 @@ public Token getToken() {\n     public Logout getLogout() {\n         return logout;\n     }\n+\n+    /**\n+     * Merge the current tenant (represented by this builder) and well-known OpenId Connect provider configurations.\n+     * Initialized properties take priority over uninitialized properties.\n+     *\n+     * Initialized properties in the current tenant configuration take priority\n+     * over the same initialized properties in the well-known OpenId Connect provider configuration.\n+     *\n+     * @param tenant well-known OpenId Connect provider configuration\n+     */\n+    public OidcTenantConfigBuilder mergeTenant(io.quarkus.oidc.OidcTenantConfig tenant) {",
        "comment_created_at": "2025-05-01T11:50:44+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2053026285",
    "pr_number": 47445,
    "pr_file": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java",
    "created_at": "2025-04-21T21:37:58+00:00",
    "commented_code": "};\n     }\n \n+    public Function<String, Consumer<RoutingContext>> authCtxInterceptorCreator() {",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2053026285",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java",
        "discussion_id": "2053026285",
        "commented_code": "@@ -134,6 +135,39 @@ public TenantIdentityProvider get() {\n         };\n     }\n \n+    public Function<String, Consumer<RoutingContext>> authCtxInterceptorCreator() {",
        "comment_created_at": "2025-04-21T21:37:58+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\n    public Function<String, Consumer<RoutingContext>> authenticationContextInterceptorCreator() {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1963676653",
    "pr_number": 46174,
    "pr_file": "extensions/smallrye-reactive-messaging/runtime/src/main/java/io/quarkus/smallrye/reactivemessaging/runtime/ContextualEmitter.java",
    "created_at": "2025-02-20T14:31:51+00:00",
    "commented_code": "+package io.quarkus.smallrye.reactivemessaging.runtime;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.EmitterType;\n+\n+/**\n+ * Emitter implementation that plays better with context propagation, especially with the request scoped context.\n+ * The message emit of this emitter makes sure that\n+ * <p>\n+ * <ul>\n+ * <li>the message context is captured when active thread context plan is applied</li>\n+ * <li>the message is emitted only after the context propagation ends the context switch, destroying the intermediate state for\n+ * cleared contexts.</li>\n+ * </ul>\n+ *\n+ * @param <T> the payload type\n+ */\n+public interface ContextualEmitter<T> extends EmitterType {\n+\n+    /**\n+     * Send a payload\n+     *\n+     * @param payload the payload\n+     * @return a Uni that completes when the message is sent\n+     */\n+    Uni<Void> send(T payload);\n+\n+    /**\n+     * Send a payload and wait for the message to be sent\n+     *\n+     * @param payload the payload\n+     */\n+    void sendAndAwait(T payload);",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1963676653",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46174,
        "pr_file": "extensions/smallrye-reactive-messaging/runtime/src/main/java/io/quarkus/smallrye/reactivemessaging/runtime/ContextualEmitter.java",
        "discussion_id": "1963676653",
        "commented_code": "@@ -0,0 +1,53 @@\n+package io.quarkus.smallrye.reactivemessaging.runtime;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.EmitterType;\n+\n+/**\n+ * Emitter implementation that plays better with context propagation, especially with the request scoped context.\n+ * The message emit of this emitter makes sure that\n+ * <p>\n+ * <ul>\n+ * <li>the message context is captured when active thread context plan is applied</li>\n+ * <li>the message is emitted only after the context propagation ends the context switch, destroying the intermediate state for\n+ * cleared contexts.</li>\n+ * </ul>\n+ *\n+ * @param <T> the payload type\n+ */\n+public interface ContextualEmitter<T> extends EmitterType {\n+\n+    /**\n+     * Send a payload\n+     *\n+     * @param payload the payload\n+     * @return a Uni that completes when the message is sent\n+     */\n+    Uni<Void> send(T payload);\n+\n+    /**\n+     * Send a payload and wait for the message to be sent\n+     *\n+     * @param payload the payload\n+     */\n+    void sendAndAwait(T payload);",
        "comment_created_at": "2025-02-20T14:31:51+00:00",
        "comment_author": "cescoffier",
        "comment_body": "Don't we also have the `andForget` method?",
        "pr_file_module": null
      },
      {
        "comment_id": "1963790538",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46174,
        "pr_file": "extensions/smallrye-reactive-messaging/runtime/src/main/java/io/quarkus/smallrye/reactivemessaging/runtime/ContextualEmitter.java",
        "discussion_id": "1963676653",
        "commented_code": "@@ -0,0 +1,53 @@\n+package io.quarkus.smallrye.reactivemessaging.runtime;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.EmitterType;\n+\n+/**\n+ * Emitter implementation that plays better with context propagation, especially with the request scoped context.\n+ * The message emit of this emitter makes sure that\n+ * <p>\n+ * <ul>\n+ * <li>the message context is captured when active thread context plan is applied</li>\n+ * <li>the message is emitted only after the context propagation ends the context switch, destroying the intermediate state for\n+ * cleared contexts.</li>\n+ * </ul>\n+ *\n+ * @param <T> the payload type\n+ */\n+public interface ContextualEmitter<T> extends EmitterType {\n+\n+    /**\n+     * Send a payload\n+     *\n+     * @param payload the payload\n+     * @return a Uni that completes when the message is sent\n+     */\n+    Uni<Void> send(T payload);\n+\n+    /**\n+     * Send a payload and wait for the message to be sent\n+     *\n+     * @param payload the payload\n+     */\n+    void sendAndAwait(T payload);",
        "comment_created_at": "2025-02-20T15:23:41+00:00",
        "comment_author": "ozangunalp",
        "comment_body": "In the first iteration, I thought the `andForget` wouldn't make sense. But now it does. I'll add it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1827078235",
    "pr_number": 44272,
    "pr_file": "extensions/smallrye-jwt/deployment/src/test/java/io/quarkus/jwt/test/devmode/KeyPairOutOfTheBoxDevModeTest.java",
    "created_at": "2024-11-03T22:15:20+00:00",
    "commented_code": "+package io.quarkus.jwt.test.devmode;\n+\n+import io.quarkus.jwt.test.GreetingResource;\n+import io.quarkus.test.QuarkusDevModeTest;\n+import io.restassured.RestAssured;\n+import io.restassured.http.Header;\n+import io.smallrye.jwt.build.Jwt;\n+import jakarta.annotation.security.PermitAll;\n+import jakarta.annotation.security.RolesAllowed;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.Produces;\n+import jakarta.ws.rs.core.MediaType;\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.hamcrest.Matchers;\n+import org.jboss.shrinkwrap.api.asset.StringAsset;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class KeyPairOutOfTheBoxDevModeTest {\n+\n+    @RegisterExtension\n+    static QuarkusDevModeTest devMode = new QuarkusDevModeTest()\n+            .withApplicationRoot((jar) -> jar.addClasses(\n+                    TokenResource.class,\n+                    GreetingResource.class).addAsResource(\n+                            new StringAsset(\"\"), \"application.properties\"));\n+\n+    @Test\n+    void shouldNotBeNecessaryToAddSignKeysOnApplicationProperties() {\n+        String token = RestAssured.given()\n+                .header(new Header(\"Accept\", \"text/plain\"))\n+                .get(\"/token\")\n+                .andReturn()\n+                .body()\n+                .asString();\n+\n+        RestAssured.given()\n+                .header(new Header(\"Authorization\", \"Bearer \" + token))\n+                .get(\"/only-user\")\n+                .then().assertThat().statusCode(200);\n+    }\n+\n+    @Test\n+    void shouldUseTheSameKeyPairOnLiveReload() {\n+        String token = RestAssured.given()\n+                .header(new Header(\"Accept\", \"text/plain\"))\n+                .get(\"/token\")\n+                .andReturn()\n+                .body()\n+                .asString();\n+\n+        devMode.modifySourceFile(\"GreetingResource.java\", s -> s.replace(\"Hello from Quarkus\", \"Hello from JWT\"));\n+\n+        // there is no need to get another token\n+        RestAssured.given()\n+                .header(new Header(\"Authorization\", \"Bearer \" + token))\n+                .get(\"/only-user\")\n+                .then().assertThat().statusCode(200)\n+                .body(Matchers.containsString(\"Hello from JWT\"));\n+    }\n+\n+    @Path(\"/token\")\n+    static class TokenResource {\n+\n+        @GET\n+        @Produces(MediaType.TEXT_PLAIN)\n+        @PermitAll\n+        public String hello() {\n+            return Jwt.issuer(\"https://example.com/issuer\")\n+                    .upn(\"jdoe@quarkus.io\")\n+                    .expiresIn(Duration.ofDays(30))\n+                    .groups(new HashSet<>(List.of(\"USER\")))",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1827078235",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44272,
        "pr_file": "extensions/smallrye-jwt/deployment/src/test/java/io/quarkus/jwt/test/devmode/KeyPairOutOfTheBoxDevModeTest.java",
        "discussion_id": "1827078235",
        "commented_code": "@@ -0,0 +1,83 @@\n+package io.quarkus.jwt.test.devmode;\n+\n+import io.quarkus.jwt.test.GreetingResource;\n+import io.quarkus.test.QuarkusDevModeTest;\n+import io.restassured.RestAssured;\n+import io.restassured.http.Header;\n+import io.smallrye.jwt.build.Jwt;\n+import jakarta.annotation.security.PermitAll;\n+import jakarta.annotation.security.RolesAllowed;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.Produces;\n+import jakarta.ws.rs.core.MediaType;\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.hamcrest.Matchers;\n+import org.jboss.shrinkwrap.api.asset.StringAsset;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class KeyPairOutOfTheBoxDevModeTest {\n+\n+    @RegisterExtension\n+    static QuarkusDevModeTest devMode = new QuarkusDevModeTest()\n+            .withApplicationRoot((jar) -> jar.addClasses(\n+                    TokenResource.class,\n+                    GreetingResource.class).addAsResource(\n+                            new StringAsset(\"\"), \"application.properties\"));\n+\n+    @Test\n+    void shouldNotBeNecessaryToAddSignKeysOnApplicationProperties() {\n+        String token = RestAssured.given()\n+                .header(new Header(\"Accept\", \"text/plain\"))\n+                .get(\"/token\")\n+                .andReturn()\n+                .body()\n+                .asString();\n+\n+        RestAssured.given()\n+                .header(new Header(\"Authorization\", \"Bearer \" + token))\n+                .get(\"/only-user\")\n+                .then().assertThat().statusCode(200);\n+    }\n+\n+    @Test\n+    void shouldUseTheSameKeyPairOnLiveReload() {\n+        String token = RestAssured.given()\n+                .header(new Header(\"Accept\", \"text/plain\"))\n+                .get(\"/token\")\n+                .andReturn()\n+                .body()\n+                .asString();\n+\n+        devMode.modifySourceFile(\"GreetingResource.java\", s -> s.replace(\"Hello from Quarkus\", \"Hello from JWT\"));\n+\n+        // there is no need to get another token\n+        RestAssured.given()\n+                .header(new Header(\"Authorization\", \"Bearer \" + token))\n+                .get(\"/only-user\")\n+                .then().assertThat().statusCode(200)\n+                .body(Matchers.containsString(\"Hello from JWT\"));\n+    }\n+\n+    @Path(\"/token\")\n+    static class TokenResource {\n+\n+        @GET\n+        @Produces(MediaType.TEXT_PLAIN)\n+        @PermitAll\n+        public String hello() {\n+            return Jwt.issuer(\"https://example.com/issuer\")\n+                    .upn(\"jdoe@quarkus.io\")\n+                    .expiresIn(Duration.ofDays(30))\n+                    .groups(new HashSet<>(List.of(\"USER\")))",
        "comment_created_at": "2024-11-03T22:15:20+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "It does not really matter, but I suppose the simpler the code is, the better, I think you should be able to type `.groups(\"User\")` as well",
        "pr_file_module": null
      }
    ]
  }
]