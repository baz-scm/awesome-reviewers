[
  {
    "discussion_id": "2157494739",
    "pr_number": 48482,
    "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
    "created_at": "2025-06-19T18:26:10+00:00",
    "commented_code": "<2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").httpMethods(\"GET\").authorization().permit()\n+                .path(\"/forbidden\").authorization().deny()\n+                .path(\"/roles-secured/*\", \"/other/*\", \"/api/*\").authorization().roles(\"admin\", \"user\");\n+    }\n+\n+}\n+----\n+\n+Additionally, the `io.quarkus.vertx.http.security.HttpSecurity` CDI event can be used to configure specific authentication mechanisms and policies:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+import jakarta.enterprise.event.Observes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity, CustomHttpSecurityPolicy customHttpSecurityPolicy,\n+                        @ConfigProperty(name = \"secured-path\") String securedPath) {\n+\n+        httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())\n+                .authorization().authenticated();   <1>",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2157494739",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2157494739",
        "commented_code": "@@ -488,6 +506,95 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").httpMethods(\"GET\").authorization().permit()\n+                .path(\"/forbidden\").authorization().deny()\n+                .path(\"/roles-secured/*\", \"/other/*\", \"/api/*\").authorization().roles(\"admin\", \"user\");\n+    }\n+\n+}\n+----\n+\n+Additionally, the `io.quarkus.vertx.http.security.HttpSecurity` CDI event can be used to configure specific authentication mechanisms and policies:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+import jakarta.enterprise.event.Observes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity, CustomHttpSecurityPolicy customHttpSecurityPolicy,\n+                        @ConfigProperty(name = \"secured-path\") String securedPath) {\n+\n+        httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())\n+                .authorization().authenticated();   <1>",
        "comment_created_at": "2025-06-19T18:26:10+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "Here. for the authenticated policy, it should not be available after `authorization` but as a sibling to `authorization`, otherwise it reads strange when it is in the code, less problematic when done in the config",
        "pr_file_module": null
      },
      {
        "comment_id": "2157496990",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2157494739",
        "commented_code": "@@ -488,6 +506,95 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").httpMethods(\"GET\").authorization().permit()\n+                .path(\"/forbidden\").authorization().deny()\n+                .path(\"/roles-secured/*\", \"/other/*\", \"/api/*\").authorization().roles(\"admin\", \"user\");\n+    }\n+\n+}\n+----\n+\n+Additionally, the `io.quarkus.vertx.http.security.HttpSecurity` CDI event can be used to configure specific authentication mechanisms and policies:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+import jakarta.enterprise.event.Observes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity, CustomHttpSecurityPolicy customHttpSecurityPolicy,\n+                        @ConfigProperty(name = \"secured-path\") String securedPath) {\n+\n+        httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())\n+                .authorization().authenticated();   <1>",
        "comment_created_at": "2025-06-19T18:28:06+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "Perhaps, if the user says `authenticationMechanism` after the the path, then it should also become a shortcut, `httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())` is enough to say it is an authenticated path, and uses can apply the authorization polices if they want",
        "pr_file_module": null
      },
      {
        "comment_id": "2157498931",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2157494739",
        "commented_code": "@@ -488,6 +506,95 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").httpMethods(\"GET\").authorization().permit()\n+                .path(\"/forbidden\").authorization().deny()\n+                .path(\"/roles-secured/*\", \"/other/*\", \"/api/*\").authorization().roles(\"admin\", \"user\");\n+    }\n+\n+}\n+----\n+\n+Additionally, the `io.quarkus.vertx.http.security.HttpSecurity` CDI event can be used to configure specific authentication mechanisms and policies:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+import jakarta.enterprise.event.Observes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity, CustomHttpSecurityPolicy customHttpSecurityPolicy,\n+                        @ConfigProperty(name = \"secured-path\") String securedPath) {\n+\n+        httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())\n+                .authorization().authenticated();   <1>",
        "comment_created_at": "2025-06-19T18:30:17+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "Instead of `authenticationMechanism`, I propose `.authenticated(new CustomAuthenticationMechanism())`, so it is either `httpSecurity.path(\"/api/*\").authenticated()` or `httpSecurity.path(\"/api/*\").authenticated(new CustomAuthenticationMechanism()) `, perhaps in the latter case it can be `authenticatedWith(...)`",
        "pr_file_module": null
      },
      {
        "comment_id": "2157502010",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2157494739",
        "commented_code": "@@ -488,6 +506,95 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").httpMethods(\"GET\").authorization().permit()\n+                .path(\"/forbidden\").authorization().deny()\n+                .path(\"/roles-secured/*\", \"/other/*\", \"/api/*\").authorization().roles(\"admin\", \"user\");\n+    }\n+\n+}\n+----\n+\n+Additionally, the `io.quarkus.vertx.http.security.HttpSecurity` CDI event can be used to configure specific authentication mechanisms and policies:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+import jakarta.enterprise.event.Observes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity, CustomHttpSecurityPolicy customHttpSecurityPolicy,\n+                        @ConfigProperty(name = \"secured-path\") String securedPath) {\n+\n+        httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())\n+                .authorization().authenticated();   <1>",
        "comment_created_at": "2025-06-19T18:33:50+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> Instead of `authenticationMechanism`, I propose `.authenticated(new CustomAuthenticationMechanism())`, so it is either `httpSecurity.path(\"/api/*\").authenticated()` or `httpSecurity.path(\"/api/*\").authenticated(new CustomAuthenticationMechanism()) `, perhaps in the latter case it can be `authenticatedWith(...)`\r\n\r\nthat I like, good idea.",
        "pr_file_module": null
      },
      {
        "comment_id": "2157699382",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2157494739",
        "commented_code": "@@ -488,6 +506,95 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").httpMethods(\"GET\").authorization().permit()\n+                .path(\"/forbidden\").authorization().deny()\n+                .path(\"/roles-secured/*\", \"/other/*\", \"/api/*\").authorization().roles(\"admin\", \"user\");\n+    }\n+\n+}\n+----\n+\n+Additionally, the `io.quarkus.vertx.http.security.HttpSecurity` CDI event can be used to configure specific authentication mechanisms and policies:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;\n+import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+import jakarta.enterprise.event.Observes;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity, CustomHttpSecurityPolicy customHttpSecurityPolicy,\n+                        @ConfigProperty(name = \"secured-path\") String securedPath) {\n+\n+        httpSecurity.path(\"/api/*\").authenticationMechanism(new CustomAuthenticationMechanism())\n+                .authorization().authenticated();   <1>",
        "comment_created_at": "2025-06-19T21:56:34+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "Done, I think it looks better with this suggestion. Thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159319953",
    "pr_number": 48482,
    "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
    "created_at": "2025-06-20T16:12:15+00:00",
    "commented_code": "<2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").methods(\"GET\").permit()",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2159319953",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2159319953",
        "commented_code": "@@ -488,6 +506,94 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").methods(\"GET\").permit()",
        "comment_created_at": "2025-06-20T16:12:15+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "Perhaps we should have shortcuts for 4 main methods, `get()` as an alternative to `methods(\"GET\")`, and the  same for `POST`, `PUT` and `DELETE`",
        "pr_file_module": null
      },
      {
        "comment_id": "2160095532",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2159319953",
        "commented_code": "@@ -488,6 +506,94 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").methods(\"GET\").permit()",
        "comment_created_at": "2025-06-21T17:28:07+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "Perhaps both `httpSecurity.path(\"/public/*\").get().permit()` and vert.x web client style, `httpSecurity\r\n                .get(\"/public/*\").permit()` work",
        "pr_file_module": null
      },
      {
        "comment_id": "2160376646",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48482,
        "pr_file": "docs/src/main/asciidoc/security-authorize-web-endpoints-reference.adoc",
        "discussion_id": "2159319953",
        "commented_code": "@@ -488,6 +506,94 @@ quarkus.http.auth.permission.roles3.policy=role-policy3\n <2> The `/secured/*` path can only be accessed by authenticated users. This way, you have secured the `/secured/all` path and so on.\n <3> Shared permissions are always applied before unshared ones, therefore a `SecurityIdentity` with the `root` role will have the `user` role as well.\n \n+=== Set up path-specific authorization programmatically\n+\n+You can also configure the authorization policies presented by this guide so far programmatically.\n+Consider the example mentioned earlier:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.permission.permit1.paths=/public/*\n+quarkus.http.auth.permission.permit1.policy=permit\n+quarkus.http.auth.permission.permit1.methods=GET\n+\n+quarkus.http.auth.permission.deny1.paths=/forbidden\n+quarkus.http.auth.permission.deny1.policy=deny\n+\n+quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*\n+quarkus.http.auth.permission.roles1.policy=role-policy1\n+quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin\n+----\n+\n+The same authorization policies can be configured programmatically:\n+\n+[source,java]\n+----\n+package org.acme.http.security;\n+\n+import jakarta.enterprise.event.Observes;\n+\n+import io.quarkus.vertx.http.security.HttpSecurity;\n+\n+public class HttpSecurityConfiguration {\n+\n+    void configure(@Observes HttpSecurity httpSecurity) {\n+        httpSecurity\n+                .path(\"/public/*\").methods(\"GET\").permit()",
        "comment_created_at": "2025-06-22T15:10:02+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "I went with `httpSecurity.get(\"/public/*\")`. (and post, delete, put).",
        "pr_file_module": null
      }
    ]
  }
]