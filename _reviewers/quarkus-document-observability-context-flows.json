[
  {
    "discussion_id": "2178070762",
    "pr_number": 48580,
    "pr_file": "docs/src/main/asciidoc/opentelemetry.adoc",
    "created_at": "2025-07-01T16:44:08+00:00",
    "commented_code": "== Exporters\n \n-=== Default\n+=== The Default\n \n-The Quarkus OpenTelemetry extension uses its own signal exporters built on top of Vert.x for optimal performance and maintainability.\n+The Quarkus OpenTelemetry extension uses its own signal exporters built on top of Vert.x for optimal performance and maintainability. All *Quarkus built in exporters use the OTLP protocol* through a couple of data senders, using `grpc` (the default) and `http/protobuf`.\n \n-The exporter is automatically wired with CDI, that's why the `quarkus.otel.traces.exporter` and `quarkus.otel.metrics.exporter` properties default to `cdi`.\n+The active exporter is automatically wired by CDI, that's why the `quarkus.otel.traces.exporter`, `quarkus.otel.metrics.exporter` and `quarkus.otel.logs.exporter` properties default value is `cdi`. This is not because of the protocol being used in the data transfer but because of how the exporters are wired.\n \n-The `quarkus.otel.exporter.otlp.protocol` defaults to `grpc` but `http/protobuf` can also be used.\n+CDI (Context Dependency Injection) will manage the exporters to use, according to the selected protocol or when applications implement their own CDI exporter, like in tests.\n+\n+The `quarkus.otel.exporter.otlp.protocol` property instructs Quarkus to switch the senders and defaults to `grpc` but `http/protobuf` can also be used.\n \n NOTE: If you change the protocol, you also need to change the port in the endpoint. The default port for `grpc` is `4317` and for `http/protobuf` is `4318`.\n \n+=== Using CDI to produce a test exporter\n+\n+Leaving the default as CDI is particularly useful for tests. In the following example a Span exporter class is wired with CDI and then the telemetry can be used in test code.\n+\n+Creating a custom `SpanExporter` bean:\n+\n+[source,java]\n+----\n+    @ApplicationScoped\n+    static class InMemorySpanExporterProducer {\n+        @Produces\n+        @Singleton\n+        InMemorySpanExporter inMemorySpanExporter() {\n+            return InMemorySpanExporter.create();\n+        }\n+    }\n+----\n+\n+Where `InMemorySpanExporter` is a class from the OpenTelemetry test utilities dependency:\n+\n+[source,xml,role=\"primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven\"]\n+.pom.xml\n+----\n+    <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-sdk-testing</artifactId>\n+        <scope>test</scope>\n+    </dependency>\n+----\n+\n+[source,gradle,role=\"secondary asciidoc-tabs-target-sync-gradle\"]\n+.build.gradle\n+----\n+implementation(\"io.opentelemetry:opentelemetry-sdk-testing\")\n+----\n+\n+The bean of that class can be injected to access the telemetry data. This is an example to obtain the spans:\n+\n+[source, java]\n+----\n+    @Inject\n+    InMemorySpanExporter inMemorySpanExporter;\n+\n+    //...\n+\n+    List<SpanData> finishedSpanItems = inMemorySpanExporter.getFinishedSpanItems();\n+----\n+\n+If this is used on an integration test project, you should access the class from inside the running process and not from the test class.\n+A viable option could be to expose that data through a rest endpoint method:\n+\n+[source,java]\n+----\n+    @GET\n+    @Path(\"/export\")\n+    public List<SpanData> exportTraces() {\n+        return inMemorySpanExporter.getFinishedSpanItems()\n+                .stream()\n+                .filter(sd -> !sd.getName().contains(\"export\")) <1>\n+                .collect(Collectors.toList());\n+    }\n+----\n+<1> This excludes calls to the export endpoint itself.\n+\n+For more details please take a look to the https://github.com/quarkusio/quarkus/blob/main/integration-tests/opentelemetry/src/main/java/io/quarkus/it/opentelemetry/ExporterResource.java[ExporterResource] in the Quarkus integration tests.\n+\n+=== The OpenTelemetry OTLP exporter\n+\n+This is currently not supported in quarkus. Configuration example for traces: `quarkus.otel.tracing.exporter=otlp`.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2178070762",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48580,
        "pr_file": "docs/src/main/asciidoc/opentelemetry.adoc",
        "discussion_id": "2178070762",
        "commented_code": "@@ -251,16 +251,90 @@ When creating manual instrumentation, while naming metrics or attributes you sho\n \n == Exporters\n \n-=== Default\n+=== The Default\n \n-The Quarkus OpenTelemetry extension uses its own signal exporters built on top of Vert.x for optimal performance and maintainability.\n+The Quarkus OpenTelemetry extension uses its own signal exporters built on top of Vert.x for optimal performance and maintainability. All *Quarkus built in exporters use the OTLP protocol* through a couple of data senders, using `grpc` (the default) and `http/protobuf`.\n \n-The exporter is automatically wired with CDI, that's why the `quarkus.otel.traces.exporter` and `quarkus.otel.metrics.exporter` properties default to `cdi`.\n+The active exporter is automatically wired by CDI, that's why the `quarkus.otel.traces.exporter`, `quarkus.otel.metrics.exporter` and `quarkus.otel.logs.exporter` properties default value is `cdi`. This is not because of the protocol being used in the data transfer but because of how the exporters are wired.\n \n-The `quarkus.otel.exporter.otlp.protocol` defaults to `grpc` but `http/protobuf` can also be used.\n+CDI (Context Dependency Injection) will manage the exporters to use, according to the selected protocol or when applications implement their own CDI exporter, like in tests.\n+\n+The `quarkus.otel.exporter.otlp.protocol` property instructs Quarkus to switch the senders and defaults to `grpc` but `http/protobuf` can also be used.\n \n NOTE: If you change the protocol, you also need to change the port in the endpoint. The default port for `grpc` is `4317` and for `http/protobuf` is `4318`.\n \n+=== Using CDI to produce a test exporter\n+\n+Leaving the default as CDI is particularly useful for tests. In the following example a Span exporter class is wired with CDI and then the telemetry can be used in test code.\n+\n+Creating a custom `SpanExporter` bean:\n+\n+[source,java]\n+----\n+    @ApplicationScoped\n+    static class InMemorySpanExporterProducer {\n+        @Produces\n+        @Singleton\n+        InMemorySpanExporter inMemorySpanExporter() {\n+            return InMemorySpanExporter.create();\n+        }\n+    }\n+----\n+\n+Where `InMemorySpanExporter` is a class from the OpenTelemetry test utilities dependency:\n+\n+[source,xml,role=\"primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven\"]\n+.pom.xml\n+----\n+    <dependency>\n+        <groupId>io.opentelemetry</groupId>\n+        <artifactId>opentelemetry-sdk-testing</artifactId>\n+        <scope>test</scope>\n+    </dependency>\n+----\n+\n+[source,gradle,role=\"secondary asciidoc-tabs-target-sync-gradle\"]\n+.build.gradle\n+----\n+implementation(\"io.opentelemetry:opentelemetry-sdk-testing\")\n+----\n+\n+The bean of that class can be injected to access the telemetry data. This is an example to obtain the spans:\n+\n+[source, java]\n+----\n+    @Inject\n+    InMemorySpanExporter inMemorySpanExporter;\n+\n+    //...\n+\n+    List<SpanData> finishedSpanItems = inMemorySpanExporter.getFinishedSpanItems();\n+----\n+\n+If this is used on an integration test project, you should access the class from inside the running process and not from the test class.\n+A viable option could be to expose that data through a rest endpoint method:\n+\n+[source,java]\n+----\n+    @GET\n+    @Path(\"/export\")\n+    public List<SpanData> exportTraces() {\n+        return inMemorySpanExporter.getFinishedSpanItems()\n+                .stream()\n+                .filter(sd -> !sd.getName().contains(\"export\")) <1>\n+                .collect(Collectors.toList());\n+    }\n+----\n+<1> This excludes calls to the export endpoint itself.\n+\n+For more details please take a look to the https://github.com/quarkusio/quarkus/blob/main/integration-tests/opentelemetry/src/main/java/io/quarkus/it/opentelemetry/ExporterResource.java[ExporterResource] in the Quarkus integration tests.\n+\n+=== The OpenTelemetry OTLP exporter\n+\n+This is currently not supported in quarkus. Configuration example for traces: `quarkus.otel.tracing.exporter=otlp`.",
        "comment_created_at": "2025-07-01T16:44:08+00:00",
        "comment_author": "gsmet",
        "comment_body": "```suggestion\r\nThis is currently not supported in Quarkus. Configuration example for traces: `quarkus.otel.tracing.exporter=otlp`.\r\n```\r\n\r\nI don't understand:\r\n\r\n> Configuration example for traces\r\n\r\n?\r\n\r\nAnd I think I agree with @geoand that throwing a proper error in Quarkus for unsupported values would be better? Either with a fixed list of values if we know all of them or excluding the usual suspects people could be tempted to use?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1956424591",
    "pr_number": 46174,
    "pr_file": "docs/src/main/asciidoc/messaging.adoc",
    "created_at": "2025-02-14T16:32:35+00:00",
    "commented_code": "while still preserving the partial order of messages received in different copies.\n This is the case, for example, for Kafka, where multiple consumers can consume different topic partitions.\n \n+== Context Propagation\n+\n+In Quarkus Messaging, the default mechanism for propagating context between different processing stages is the\n+link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/message-context[message context].\n+This provides a consistent way to pass context information along with the message as it flows through different stages.\n+\n+When integrating with other extensions, notably using Emitters, it relies on the Mutiny context propagation:\n+\n+=== Interaction with Mutiny and MicroProfile Context Propagation\n+\n+Mutiny, which is the foundation of reactive programming in Quarkus, is integrated with the MicroProfile Context Propagation.\n+This integration enables automatic capturing and restoring of context across asynchronous boundaries.\n+To learn more about context propagation in Quarkus and Mutiny, refer to the xref:context-propagation.adoc[Context Propagation] guide.\n+\n+To ensure consistent behavior, Quarkus Messaging disables the propagation of any context during message dispatching through inbound or outbound connectors.\n+This means that context captured through Emitters won't be propagated to the outgoing channel, and incoming channels won't dispatch messages by activating a context (e.g. the request context).\n+This behaviour can be configured using `quarkus.messaging.connector-context-propagation` configuration property, by listing the context types to propagate.\n+For example `quarkus.messaging.connector-context-propagation=CDI` will only propagate the CDI context.\n+\n+Internal channels however do propagate the context, as they are part of the same application and the context is not lost.\n+\n+For example, you might want to propagate the caller context from an incoming HTTP request to the message processing stage.\n+For emitters, it is recommended to use the `MutinyEmitter`, as it exposes methods such as `sendAndAwait` that makes sure to wait until a message processing is terminated.\n+\n+[WARNING]\n+====\n+The execution context to which the RequestScoped context is bound, in the previous example the REST call, controls the lifecycle of the context.\n+This means that when the REST call is completed the RequestScoped context is destroyed.\n+Therefore, you need to make sure that your processing or message dispatch is completed before the REST call completes.\n+\n+For more information check the xref:context-propagation.adoc#context-propagation-for-cdi[Context Propagation] guide.\n+====\n+\n+For example, let `RequestScopedBean` a request-scoped bean, `MutinyEmitter` can be used to dispatch messages locally through the internal channel `app`:\n+\n+[source, java]\n+----\n+import jakarta.inject.Inject;\n+import jakarta.ws.rs.Consumes;\n+import jakarta.ws.rs.POST;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.core.MediaType;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+import io.smallrye.reactive.messaging.MutinyEmitter;\n+\n+import io.quarkus.logging.Log;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+\n+@Path(\"/\")\n+public class Resource {\n+\n+    @Channel(\"app\")\n+    MutinyEmitter<String> emitter;\n+\n+    @Inject\n+    RequestScopedBean requestScopedBean;\n+\n+    @POST\n+    @Path(\"/send\")\n+    public void send(String message) {\n+        requestScopedBean.setValue(\"Hello\");\n+        emitter.sendAndAwait(message);\n+    }\n+\n+}\n+----\n+\n+Then the request-scoped bean can be accessed in the message processing stage, regardless of the <<execution_model>>:\n+\n+[source, java]\n+----\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+\n+import io.quarkus.logging.Log;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+\n+@ApplicationScoped\n+public class Processor {\n+\n+    @Inject\n+    RequestScopedBean requestScopedBean;\n+\n+    @Incoming(\"app\")\n+    @Blocking\n+    public void process(String message) {\n+        Log.infof(\"Message %s from request %s\", message, requestScopedBean.getValue());\n+    }\n+\n+}\n+----\n+\n+[TIP]\n+====\n+You can use the context propagation annotation `@CurrentThreadContext` to configure the context propagation for a specific method.\n+Using an emitter this annotation needs to be present on the propagator method, i.e. the caller, not the processing method.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1956424591",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46174,
        "pr_file": "docs/src/main/asciidoc/messaging.adoc",
        "discussion_id": "1956424591",
        "commented_code": "@@ -634,6 +636,162 @@ Depending on the broker technology, this can be useful to increase the applicati\n while still preserving the partial order of messages received in different copies.\n This is the case, for example, for Kafka, where multiple consumers can consume different topic partitions.\n \n+== Context Propagation\n+\n+In Quarkus Messaging, the default mechanism for propagating context between different processing stages is the\n+link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/message-context[message context].\n+This provides a consistent way to pass context information along with the message as it flows through different stages.\n+\n+When integrating with other extensions, notably using Emitters, it relies on the Mutiny context propagation:\n+\n+=== Interaction with Mutiny and MicroProfile Context Propagation\n+\n+Mutiny, which is the foundation of reactive programming in Quarkus, is integrated with the MicroProfile Context Propagation.\n+This integration enables automatic capturing and restoring of context across asynchronous boundaries.\n+To learn more about context propagation in Quarkus and Mutiny, refer to the xref:context-propagation.adoc[Context Propagation] guide.\n+\n+To ensure consistent behavior, Quarkus Messaging disables the propagation of any context during message dispatching through inbound or outbound connectors.\n+This means that context captured through Emitters won't be propagated to the outgoing channel, and incoming channels won't dispatch messages by activating a context (e.g. the request context).\n+This behaviour can be configured using `quarkus.messaging.connector-context-propagation` configuration property, by listing the context types to propagate.\n+For example `quarkus.messaging.connector-context-propagation=CDI` will only propagate the CDI context.\n+\n+Internal channels however do propagate the context, as they are part of the same application and the context is not lost.\n+\n+For example, you might want to propagate the caller context from an incoming HTTP request to the message processing stage.\n+For emitters, it is recommended to use the `MutinyEmitter`, as it exposes methods such as `sendAndAwait` that makes sure to wait until a message processing is terminated.\n+\n+[WARNING]\n+====\n+The execution context to which the RequestScoped context is bound, in the previous example the REST call, controls the lifecycle of the context.\n+This means that when the REST call is completed the RequestScoped context is destroyed.\n+Therefore, you need to make sure that your processing or message dispatch is completed before the REST call completes.\n+\n+For more information check the xref:context-propagation.adoc#context-propagation-for-cdi[Context Propagation] guide.\n+====\n+\n+For example, let `RequestScopedBean` a request-scoped bean, `MutinyEmitter` can be used to dispatch messages locally through the internal channel `app`:\n+\n+[source, java]\n+----\n+import jakarta.inject.Inject;\n+import jakarta.ws.rs.Consumes;\n+import jakarta.ws.rs.POST;\n+import jakarta.ws.rs.Path;\n+import jakarta.ws.rs.core.MediaType;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+import io.smallrye.reactive.messaging.MutinyEmitter;\n+\n+import io.quarkus.logging.Log;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+\n+@Path(\"/\")\n+public class Resource {\n+\n+    @Channel(\"app\")\n+    MutinyEmitter<String> emitter;\n+\n+    @Inject\n+    RequestScopedBean requestScopedBean;\n+\n+    @POST\n+    @Path(\"/send\")\n+    public void send(String message) {\n+        requestScopedBean.setValue(\"Hello\");\n+        emitter.sendAndAwait(message);\n+    }\n+\n+}\n+----\n+\n+Then the request-scoped bean can be accessed in the message processing stage, regardless of the <<execution_model>>:\n+\n+[source, java]\n+----\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+\n+import io.quarkus.logging.Log;\n+import io.smallrye.reactive.messaging.annotations.Blocking;\n+\n+\n+@ApplicationScoped\n+public class Processor {\n+\n+    @Inject\n+    RequestScopedBean requestScopedBean;\n+\n+    @Incoming(\"app\")\n+    @Blocking\n+    public void process(String message) {\n+        Log.infof(\"Message %s from request %s\", message, requestScopedBean.getValue());\n+    }\n+\n+}\n+----\n+\n+[TIP]\n+====\n+You can use the context propagation annotation `@CurrentThreadContext` to configure the context propagation for a specific method.\n+Using an emitter this annotation needs to be present on the propagator method, i.e. the caller, not the processing method.",
        "comment_created_at": "2025-02-14T16:32:35+00:00",
        "comment_author": "FroMage",
        "comment_body": "I don't think this is a very clear sentence. I suppose what you're trying to explain is that this configures the contexts that will be propagated \"from\" an emitter method, and as such, the annotation needs to be put on the emitter/emitting method, and configures the contexts that will be captured and propagated from that method.",
        "pr_file_module": null
      }
    ]
  }
]