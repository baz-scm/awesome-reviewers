[
  {
    "discussion_id": "2182593407",
    "pr_number": 47338,
    "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/SchemaToolingUtil.java",
    "created_at": "2025-07-03T11:52:27+00:00",
    "commented_code": "+package io.quarkus.hibernate.orm.runtime;\n+\n+import java.net.URL;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.fs.util.ZipUtils;\n+\n+public class SchemaToolingUtil {\n+    private static final Logger log = Logger.getLogger(SchemaToolingUtil.class);\n+    private static final String COMMA = \",\";\n+    private static final String ZIP_FILE_EXTENSION = \".zip\";\n+    private static final String SQL_LOAD_SCRIPT_UNZIPPED_DIR_PREFIX = \"import-sql-unzip-\";\n+\n+    public static String unzipZipFilesAndReplaceZips(String commaSeparatedFileNames) {\n+        List<String> unzippedFilesNames = new LinkedList<>();\n+        if (commaSeparatedFileNames != null) {\n+            String[] fileNames = commaSeparatedFileNames.split(COMMA);\n+            for (String fileName : fileNames) {\n+                if (fileName.endsWith(ZIP_FILE_EXTENSION)) {\n+                    try {\n+                        Path unzipDir = Files.createTempDirectory(SQL_LOAD_SCRIPT_UNZIPPED_DIR_PREFIX);\n+                        URL resource = Thread.currentThread()\n+                                .getContextClassLoader()\n+                                .getResource(fileName);\n+                        Path zipFile = Paths.get(resource.toURI());\n+                        ZipUtils.unzip(zipFile, unzipDir);\n+                        try (DirectoryStream<Path> paths = Files.newDirectoryStream(unzipDir)) {\n+                            for (Path path : paths) {\n+                                unzippedFilesNames.add(path.toAbsolutePath().toString());\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.errorf(\"Error unzipping import file %s: %s\", fileName, e.getMessage());\n+                        throw new IllegalStateException(String.format(\"Error unzipping import file %s: %s\",\n+                          fileName, e.getMessage()), e);                    }",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2182593407",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47338,
        "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/SchemaToolingUtil.java",
        "discussion_id": "2182593407",
        "commented_code": "@@ -0,0 +1,52 @@\n+package io.quarkus.hibernate.orm.runtime;\n+\n+import java.net.URL;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.fs.util.ZipUtils;\n+\n+public class SchemaToolingUtil {\n+    private static final Logger log = Logger.getLogger(SchemaToolingUtil.class);\n+    private static final String COMMA = \",\";\n+    private static final String ZIP_FILE_EXTENSION = \".zip\";\n+    private static final String SQL_LOAD_SCRIPT_UNZIPPED_DIR_PREFIX = \"import-sql-unzip-\";\n+\n+    public static String unzipZipFilesAndReplaceZips(String commaSeparatedFileNames) {\n+        List<String> unzippedFilesNames = new LinkedList<>();\n+        if (commaSeparatedFileNames != null) {\n+            String[] fileNames = commaSeparatedFileNames.split(COMMA);\n+            for (String fileName : fileNames) {\n+                if (fileName.endsWith(ZIP_FILE_EXTENSION)) {\n+                    try {\n+                        Path unzipDir = Files.createTempDirectory(SQL_LOAD_SCRIPT_UNZIPPED_DIR_PREFIX);\n+                        URL resource = Thread.currentThread()\n+                                .getContextClassLoader()\n+                                .getResource(fileName);\n+                        Path zipFile = Paths.get(resource.toURI());\n+                        ZipUtils.unzip(zipFile, unzipDir);\n+                        try (DirectoryStream<Path> paths = Files.newDirectoryStream(unzipDir)) {\n+                            for (Path path : paths) {\n+                                unzippedFilesNames.add(path.toAbsolutePath().toString());\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.errorf(\"Error unzipping import file %s: %s\", fileName, e.getMessage());\n+                        throw new IllegalStateException(String.format(\"Error unzipping import file %s: %s\",\n+                          fileName, e.getMessage()), e);                    }",
        "comment_created_at": "2025-07-03T11:52:27+00:00",
        "comment_author": "yrodiere",
        "comment_body": "It's not useful to log an error if you're already throwing an exception about it, IMO.\r\n\r\n```suggestion\r\n                        throw new IllegalStateException(String.format(\"Error unzipping import file %s: %s\",\r\n                          fileName, e.getMessage()), e);                    }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2002762887",
    "pr_number": 46728,
    "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/dev/HibernateOrmDevJsonRpcService.java",
    "created_at": "2025-03-19T08:46:35+00:00",
    "commented_code": "return getInfo().getNumberOfNamedQueries();\n     }\n \n+    private Optional<HibernateOrmDevInfo.PersistenceUnit> findPersistenceUnit(String persistenceUnitName) {\n+        return getInfo().getPersistenceUnits().stream().filter(pu -> pu.getName().equals(persistenceUnitName)).findFirst();\n+    }\n+\n+    /**\n+     * Execute an arbitrary {@code hql} query in the given {@code persistence unit}. The query might be both a selection or a\n+     * mutation statement. For selection queries, the result count is retrieved though a count query and the results, paginated\n+     * based on pageNumber and pageSize are returned. For mutation statements, a custom message including the number of affected\n+     * records is returned.\n+     * <p>\n+     * This method handles result serialization (to JSON) internally, and returns a {@link JsonRpcMessage<String>} to avoid\n+     * further processing by the {@link JsonRpcRouter}.\n+     *\n+     * @param persistenceUnit The name of the persistence unit within which the query will be executed\n+     * @param hql The Hibernate Query Language (HQL) statement to execute\n+     * @param pageNumber The page number, used for selection query results pagination\n+     * @param pageSize The page size, used for selection query results pagination\n+     * @return a {@link JsonRpcMessage<String>} containing the resulting {@link DataSet} serialized to JSON.\n+     */\n+    public JsonRpcMessage<Object> executeHQL(String persistenceUnit, String hql, Integer pageNumber, Integer pageSize) {\n+        if (!isDev) {\n+            return errorDataSet(\"This method is only allowed in dev mode\");\n+        }\n+\n+        if (!hqlIsValid(hql)) {\n+            return errorDataSet(\"The provided HQL was not valid\");\n+        }\n+\n+        Optional<HibernateOrmDevInfo.PersistenceUnit> pu = findPersistenceUnit(persistenceUnit);\n+        if (pu.isEmpty()) {\n+            return errorDataSet(\"No such persistence unit: \" + persistenceUnit);\n+        }\n+\n+        //noinspection resource\n+        SessionFactoryImplementor sf = pu.get().sessionFactory();\n+\n+        // Check the connection for this persistence unit points to an allowed datasource\n+        ConnectionProvider connectionProvider = sf.getServiceRegistry().requireService(ConnectionProvider.class);\n+        if (connectionProvider instanceof QuarkusConnectionProvider quarkusConnectionProvider) {\n+            if (!isAllowedDatabase(quarkusConnectionProvider.getDataSource())) {\n+                return errorDataSet(\"The persistence unit's datasource points to a non-allowed datasource. \"\n+                        + \"By default only local databases are enabled; you can use the 'quarkus.datasource.dev-ui.allowed-db-host'\"\n+                        + \" configuration property to configure allowed hosts ('*' to allow all).\");\n+            }\n+        } else {\n+            return errorDataSet(\"Unsupported Connection Provider type for specified persistence unit.\");\n+        }\n+\n+        return sf.fromSession(session -> {\n+            try {\n+                Query<Object> query = session.createQuery(hql, null);\n+                if (isMutation(((SqmQuery) query).getSqmStatement())) {\n+                    // DML query, execute update within transaction and return custom message with affected rows\n+                    Transaction transaction = session.beginTransaction();\n+                    try {\n+                        int updateCount = query.executeUpdate();\n+                        transaction.commit();\n+\n+                        String message = \"Query executed correctly. Rows affected: \" + updateCount;\n+                        return new JsonRpcMessage<>(new DataSet(null, -1, message, null), MessageType.Response);\n+                    } catch (Exception e) {\n+                        // an error happened in executeUpdate() or during commit\n+                        transaction.rollback();\n+                        throw e;\n+                    }\n+                } else {\n+                    // selection query, execute count query and return paged results\n+\n+                    // This executes a separate count query\n+                    long resultCount = query.getResultCount();\n+\n+                    try (ScrollableResults<Object> scroll = query.scroll(ScrollMode.SCROLL_INSENSITIVE)) {\n+                        boolean hasNext = scroll.scroll((pageNumber - 1) * pageSize + 1);\n+                        List<Object> results = new ArrayList<>();\n+                        int i = 0;\n+                        while (hasNext && i++ < pageSize) {\n+                            results.add(scroll.get());\n+                            hasNext = scroll.next();\n+                        }\n+\n+                        // manually serialize data within the transaction to ensure lazy-loading can function\n+                        String result = writeValueAsString(new DataSet(results, resultCount, null, null));\n+                        JsonRpcMessage<Object> message = new JsonRpcMessage<>(result, MessageType.Response);\n+                        message.setAlreadySerialized(true);\n+                        return message;",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2002762887",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46728,
        "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/dev/HibernateOrmDevJsonRpcService.java",
        "discussion_id": "2002762887",
        "commented_code": "@@ -18,4 +55,146 @@ public int getNumberOfNamedQueries() {\n         return getInfo().getNumberOfNamedQueries();\n     }\n \n+    private Optional<HibernateOrmDevInfo.PersistenceUnit> findPersistenceUnit(String persistenceUnitName) {\n+        return getInfo().getPersistenceUnits().stream().filter(pu -> pu.getName().equals(persistenceUnitName)).findFirst();\n+    }\n+\n+    /**\n+     * Execute an arbitrary {@code hql} query in the given {@code persistence unit}. The query might be both a selection or a\n+     * mutation statement. For selection queries, the result count is retrieved though a count query and the results, paginated\n+     * based on pageNumber and pageSize are returned. For mutation statements, a custom message including the number of affected\n+     * records is returned.\n+     * <p>\n+     * This method handles result serialization (to JSON) internally, and returns a {@link JsonRpcMessage<String>} to avoid\n+     * further processing by the {@link JsonRpcRouter}.\n+     *\n+     * @param persistenceUnit The name of the persistence unit within which the query will be executed\n+     * @param hql The Hibernate Query Language (HQL) statement to execute\n+     * @param pageNumber The page number, used for selection query results pagination\n+     * @param pageSize The page size, used for selection query results pagination\n+     * @return a {@link JsonRpcMessage<String>} containing the resulting {@link DataSet} serialized to JSON.\n+     */\n+    public JsonRpcMessage<Object> executeHQL(String persistenceUnit, String hql, Integer pageNumber, Integer pageSize) {\n+        if (!isDev) {\n+            return errorDataSet(\"This method is only allowed in dev mode\");\n+        }\n+\n+        if (!hqlIsValid(hql)) {\n+            return errorDataSet(\"The provided HQL was not valid\");\n+        }\n+\n+        Optional<HibernateOrmDevInfo.PersistenceUnit> pu = findPersistenceUnit(persistenceUnit);\n+        if (pu.isEmpty()) {\n+            return errorDataSet(\"No such persistence unit: \" + persistenceUnit);\n+        }\n+\n+        //noinspection resource\n+        SessionFactoryImplementor sf = pu.get().sessionFactory();\n+\n+        // Check the connection for this persistence unit points to an allowed datasource\n+        ConnectionProvider connectionProvider = sf.getServiceRegistry().requireService(ConnectionProvider.class);\n+        if (connectionProvider instanceof QuarkusConnectionProvider quarkusConnectionProvider) {\n+            if (!isAllowedDatabase(quarkusConnectionProvider.getDataSource())) {\n+                return errorDataSet(\"The persistence unit's datasource points to a non-allowed datasource. \"\n+                        + \"By default only local databases are enabled; you can use the 'quarkus.datasource.dev-ui.allowed-db-host'\"\n+                        + \" configuration property to configure allowed hosts ('*' to allow all).\");\n+            }\n+        } else {\n+            return errorDataSet(\"Unsupported Connection Provider type for specified persistence unit.\");\n+        }\n+\n+        return sf.fromSession(session -> {\n+            try {\n+                Query<Object> query = session.createQuery(hql, null);\n+                if (isMutation(((SqmQuery) query).getSqmStatement())) {\n+                    // DML query, execute update within transaction and return custom message with affected rows\n+                    Transaction transaction = session.beginTransaction();\n+                    try {\n+                        int updateCount = query.executeUpdate();\n+                        transaction.commit();\n+\n+                        String message = \"Query executed correctly. Rows affected: \" + updateCount;\n+                        return new JsonRpcMessage<>(new DataSet(null, -1, message, null), MessageType.Response);\n+                    } catch (Exception e) {\n+                        // an error happened in executeUpdate() or during commit\n+                        transaction.rollback();\n+                        throw e;\n+                    }\n+                } else {\n+                    // selection query, execute count query and return paged results\n+\n+                    // This executes a separate count query\n+                    long resultCount = query.getResultCount();\n+\n+                    try (ScrollableResults<Object> scroll = query.scroll(ScrollMode.SCROLL_INSENSITIVE)) {\n+                        boolean hasNext = scroll.scroll((pageNumber - 1) * pageSize + 1);\n+                        List<Object> results = new ArrayList<>();\n+                        int i = 0;\n+                        while (hasNext && i++ < pageSize) {\n+                            results.add(scroll.get());\n+                            hasNext = scroll.next();\n+                        }\n+\n+                        // manually serialize data within the transaction to ensure lazy-loading can function\n+                        String result = writeValueAsString(new DataSet(results, resultCount, null, null));\n+                        JsonRpcMessage<Object> message = new JsonRpcMessage<>(result, MessageType.Response);\n+                        message.setAlreadySerialized(true);\n+                        return message;",
        "comment_created_at": "2025-03-19T08:46:35+00:00",
        "comment_author": "yrodiere",
        "comment_body": "So we still have a limitation: circular associations will result in a serialization error:\r\n\r\n```\r\nio.vertx.core.json.EncodeException: Failed to encode as JSON: Document nesting depth (1002) exceeds the maximum allowed (1000, from `StreamWriteConstraints.getMaxNestingDepth()`) (through reference chain: java.util.ArrayList[0]->org.acme.hibernate.orm.Color[\"fruits\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Fruit[\"colors\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Color[\"fruits\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Fruit[\"colors\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Color[\"fruits\"]->org.hibernate.collection.spi.PersistentBag[0]-\r\n[...]\r\n```\r\n\r\nI understand that's something you intend to solve by switching to a different form of serialization, later.\r\n\r\nI would have suggested to serialize row-by-row, so that an error serializing one row won't prevent us from displaying the whole thing, especially since your future serialization method will require serializing row-by-row anyway. But... I suspect handling of \"errored-out\" rows will be challenging. So okay, let's give up on this.\r\n\r\nBut could you at least catch such exception and provide a better error message, such as:\r\n\r\n```\r\nUnable to encode results as JSON. Note circular associations are not supported at the moment, use `@JsonIgnore` to break circles.\r\nException:\r\nio.vertx.core.json.EncodeException: Failed to encode as JSON: Document nesting depth (1002) exceeds the maximum allowed (1000, from `StreamWriteConstraints.getMaxNestingDepth()`) (through reference chain: java.util.ArrayList[0]->org.acme.hibernate.orm.Color[\"fruits\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Fruit[\"colors\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Color[\"fruits\"]->org.hibernate.collection.spi.PersistentBag[0]->org.acme.hibernate.orm.Fruit[\"colors\"]->org.hibernate.collection.spi.PersistentBag[0]-\r\n[...]\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2002801995",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46728,
        "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/dev/HibernateOrmDevJsonRpcService.java",
        "discussion_id": "2002762887",
        "commented_code": "@@ -18,4 +55,146 @@ public int getNumberOfNamedQueries() {\n         return getInfo().getNumberOfNamedQueries();\n     }\n \n+    private Optional<HibernateOrmDevInfo.PersistenceUnit> findPersistenceUnit(String persistenceUnitName) {\n+        return getInfo().getPersistenceUnits().stream().filter(pu -> pu.getName().equals(persistenceUnitName)).findFirst();\n+    }\n+\n+    /**\n+     * Execute an arbitrary {@code hql} query in the given {@code persistence unit}. The query might be both a selection or a\n+     * mutation statement. For selection queries, the result count is retrieved though a count query and the results, paginated\n+     * based on pageNumber and pageSize are returned. For mutation statements, a custom message including the number of affected\n+     * records is returned.\n+     * <p>\n+     * This method handles result serialization (to JSON) internally, and returns a {@link JsonRpcMessage<String>} to avoid\n+     * further processing by the {@link JsonRpcRouter}.\n+     *\n+     * @param persistenceUnit The name of the persistence unit within which the query will be executed\n+     * @param hql The Hibernate Query Language (HQL) statement to execute\n+     * @param pageNumber The page number, used for selection query results pagination\n+     * @param pageSize The page size, used for selection query results pagination\n+     * @return a {@link JsonRpcMessage<String>} containing the resulting {@link DataSet} serialized to JSON.\n+     */\n+    public JsonRpcMessage<Object> executeHQL(String persistenceUnit, String hql, Integer pageNumber, Integer pageSize) {\n+        if (!isDev) {\n+            return errorDataSet(\"This method is only allowed in dev mode\");\n+        }\n+\n+        if (!hqlIsValid(hql)) {\n+            return errorDataSet(\"The provided HQL was not valid\");\n+        }\n+\n+        Optional<HibernateOrmDevInfo.PersistenceUnit> pu = findPersistenceUnit(persistenceUnit);\n+        if (pu.isEmpty()) {\n+            return errorDataSet(\"No such persistence unit: \" + persistenceUnit);\n+        }\n+\n+        //noinspection resource\n+        SessionFactoryImplementor sf = pu.get().sessionFactory();\n+\n+        // Check the connection for this persistence unit points to an allowed datasource\n+        ConnectionProvider connectionProvider = sf.getServiceRegistry().requireService(ConnectionProvider.class);\n+        if (connectionProvider instanceof QuarkusConnectionProvider quarkusConnectionProvider) {\n+            if (!isAllowedDatabase(quarkusConnectionProvider.getDataSource())) {\n+                return errorDataSet(\"The persistence unit's datasource points to a non-allowed datasource. \"\n+                        + \"By default only local databases are enabled; you can use the 'quarkus.datasource.dev-ui.allowed-db-host'\"\n+                        + \" configuration property to configure allowed hosts ('*' to allow all).\");\n+            }\n+        } else {\n+            return errorDataSet(\"Unsupported Connection Provider type for specified persistence unit.\");\n+        }\n+\n+        return sf.fromSession(session -> {\n+            try {\n+                Query<Object> query = session.createQuery(hql, null);\n+                if (isMutation(((SqmQuery) query).getSqmStatement())) {\n+                    // DML query, execute update within transaction and return custom message with affected rows\n+                    Transaction transaction = session.beginTransaction();\n+                    try {\n+                        int updateCount = query.executeUpdate();\n+                        transaction.commit();\n+\n+                        String message = \"Query executed correctly. Rows affected: \" + updateCount;\n+                        return new JsonRpcMessage<>(new DataSet(null, -1, message, null), MessageType.Response);\n+                    } catch (Exception e) {\n+                        // an error happened in executeUpdate() or during commit\n+                        transaction.rollback();\n+                        throw e;\n+                    }\n+                } else {\n+                    // selection query, execute count query and return paged results\n+\n+                    // This executes a separate count query\n+                    long resultCount = query.getResultCount();\n+\n+                    try (ScrollableResults<Object> scroll = query.scroll(ScrollMode.SCROLL_INSENSITIVE)) {\n+                        boolean hasNext = scroll.scroll((pageNumber - 1) * pageSize + 1);\n+                        List<Object> results = new ArrayList<>();\n+                        int i = 0;\n+                        while (hasNext && i++ < pageSize) {\n+                            results.add(scroll.get());\n+                            hasNext = scroll.next();\n+                        }\n+\n+                        // manually serialize data within the transaction to ensure lazy-loading can function\n+                        String result = writeValueAsString(new DataSet(results, resultCount, null, null));\n+                        JsonRpcMessage<Object> message = new JsonRpcMessage<>(result, MessageType.Response);\n+                        message.setAlreadySerialized(true);\n+                        return message;",
        "comment_created_at": "2025-03-19T08:59:54+00:00",
        "comment_author": "mbellade",
        "comment_body": "Yeah, that is a known limitation indeed. The custom error message is a very good idea while we wait for the better serialization, I've handled that in `writeValueAsString`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071568343",
    "pr_number": 46728,
    "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/dev/HibernateOrmDevJsonRpcService.java",
    "created_at": "2025-05-02T12:51:35+00:00",
    "commented_code": "return getInfo().getNumberOfNamedQueries();\n     }\n \n+    private Optional<HibernateOrmDevInfo.PersistenceUnit> findPersistenceUnit(String persistenceUnitName) {\n+        return getInfo().getPersistenceUnits().stream().filter(pu -> pu.getName().equals(persistenceUnitName)).findFirst();\n+    }\n+\n+    /**\n+     * Execute an arbitrary {@code hql} query in the given {@code persistence unit}. The query might be both a selection or a\n+     * mutation statement. For selection queries, the result count is retrieved though a count query and the results, paginated\n+     * based on pageNumber and pageSize are returned. For mutation statements, a custom message including the number of affected\n+     * records is returned.\n+     * <p>\n+     * This method handles result serialization (to JSON) internally, and returns a {@link JsonRpcMessage<String>} to avoid\n+     * further processing by the {@link JsonRpcRouter}.\n+     *\n+     * @param persistenceUnit The name of the persistence unit within which the query will be executed\n+     * @param hql The Hibernate Query Language (HQL) statement to execute\n+     * @param pageNumber The page number, used for selection query results pagination\n+     * @param pageSize The page size, used for selection query results pagination\n+     * @return a {@link JsonRpcMessage<String>} containing the resulting {@link DataSet} serialized to JSON.\n+     */\n+    public JsonRpcMessage<Object> executeHQL(String persistenceUnit, String hql, Integer pageNumber, Integer pageSize) {\n+        if (!isDev) {\n+            return errorDataSet(\"This method is only allowed in dev mode\");\n+        }\n+\n+        if (!hqlIsValid(hql)) {\n+            return errorDataSet(\"The provided HQL was not valid\");\n+        }\n+\n+        Optional<HibernateOrmDevInfo.PersistenceUnit> pu = findPersistenceUnit(persistenceUnit);\n+        if (pu.isEmpty()) {\n+            return errorDataSet(\"No such persistence unit: \" + persistenceUnit);\n+        }\n+\n+        //noinspection resource\n+        SessionFactoryImplementor sf = pu.get().sessionFactory();\n+\n+        // Check the connection for this persistence unit points to an allowed datasource\n+        ConnectionProvider connectionProvider = sf.getServiceRegistry().requireService(ConnectionProvider.class);\n+        if (connectionProvider instanceof QuarkusConnectionProvider quarkusConnectionProvider) {\n+            if (!isAllowedDatabase(quarkusConnectionProvider.getDataSource())) {\n+                return errorDataSet(\"The persistence unit's datasource points to a non-allowed datasource. \"\n+                        + \"By default only local databases are enabled; you can use the 'quarkus.datasource.dev-ui.allowed-db-host'\"\n+                        + \" configuration property to configure allowed hosts ('*' to allow all).\");\n+            }\n+        } else {\n+            return errorDataSet(\"Unsupported Connection Provider type for specified persistence unit.\");\n+        }\n+\n+        return sf.fromSession(session -> {\n+            try {\n+                Query<Object> query = session.createQuery(hql, null);\n+                if (isMutation(((SqmQuery) query).getSqmStatement())) {\n+                    // DML query, execute update within transaction and return custom message with affected rows\n+                    Transaction transaction = session.beginTransaction();\n+                    try {\n+                        int updateCount = query.executeUpdate();\n+                        transaction.commit();\n+\n+                        String message = \"Query executed correctly. Rows affected: \" + updateCount;\n+                        return new JsonRpcMessage<>(new DataSet(null, -1, message, null), MessageType.Response);\n+                    } catch (Exception e) {\n+                        // an error happened in executeUpdate() or during commit\n+                        transaction.rollback();\n+                        throw e;\n+                    }\n+                } else {\n+                    // selection query, execute count query and return paged results\n+\n+                    // This executes a separate count query\n+                    long resultCount = query.getResultCount();\n+\n+                    try (ScrollableResults<Object> scroll = query.scroll(ScrollMode.SCROLL_INSENSITIVE)) {\n+                        boolean hasNext = scroll.scroll((pageNumber - 1) * pageSize + 1);\n+                        List<Object> results = new ArrayList<>();\n+                        int i = 0;\n+                        while (hasNext && i++ < pageSize) {\n+                            results.add(scroll.get());\n+                            hasNext = scroll.next();\n+                        }\n+\n+                        // manually serialize data within the transaction to ensure lazy-loading can function\n+                        String result = writeValueAsString(new DataSet(results, resultCount, null, null));\n+                        JsonRpcMessage<Object> message = new JsonRpcMessage<>(result, MessageType.Response);\n+                        message.setAlreadySerialized(true);\n+                        return message;\n+                    }\n+                }\n+            } catch (Exception ex) {\n+                return new JsonRpcMessage<>(new DataSet(null, -1, null, ex.getMessage()), MessageType.Response);\n+            }\n+        });\n+    }\n+\n+    private static JsonRpcMessage<Object> errorDataSet(String errorMessage) {\n+        return new JsonRpcMessage<>(new DataSet(null, -1, null, errorMessage), MessageType.Response);\n+    }\n+\n+    private static String writeValueAsString(DataSet value) {\n+        try {\n+            JsonRpcRouter jsonRpcRouter = CDI.current().select(JsonRpcRouter.class).get();\n+            return jsonRpcRouter.getJsonMapper().toString(value, true);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\n+                    \"Unable to encode results as JSON. Note circular associations are not supported at the moment, use `@JsonIgnore` to break circles.\",",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2071568343",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46728,
        "pr_file": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/dev/HibernateOrmDevJsonRpcService.java",
        "discussion_id": "2071568343",
        "commented_code": "@@ -18,4 +55,152 @@ public int getNumberOfNamedQueries() {\n         return getInfo().getNumberOfNamedQueries();\n     }\n \n+    private Optional<HibernateOrmDevInfo.PersistenceUnit> findPersistenceUnit(String persistenceUnitName) {\n+        return getInfo().getPersistenceUnits().stream().filter(pu -> pu.getName().equals(persistenceUnitName)).findFirst();\n+    }\n+\n+    /**\n+     * Execute an arbitrary {@code hql} query in the given {@code persistence unit}. The query might be both a selection or a\n+     * mutation statement. For selection queries, the result count is retrieved though a count query and the results, paginated\n+     * based on pageNumber and pageSize are returned. For mutation statements, a custom message including the number of affected\n+     * records is returned.\n+     * <p>\n+     * This method handles result serialization (to JSON) internally, and returns a {@link JsonRpcMessage<String>} to avoid\n+     * further processing by the {@link JsonRpcRouter}.\n+     *\n+     * @param persistenceUnit The name of the persistence unit within which the query will be executed\n+     * @param hql The Hibernate Query Language (HQL) statement to execute\n+     * @param pageNumber The page number, used for selection query results pagination\n+     * @param pageSize The page size, used for selection query results pagination\n+     * @return a {@link JsonRpcMessage<String>} containing the resulting {@link DataSet} serialized to JSON.\n+     */\n+    public JsonRpcMessage<Object> executeHQL(String persistenceUnit, String hql, Integer pageNumber, Integer pageSize) {\n+        if (!isDev) {\n+            return errorDataSet(\"This method is only allowed in dev mode\");\n+        }\n+\n+        if (!hqlIsValid(hql)) {\n+            return errorDataSet(\"The provided HQL was not valid\");\n+        }\n+\n+        Optional<HibernateOrmDevInfo.PersistenceUnit> pu = findPersistenceUnit(persistenceUnit);\n+        if (pu.isEmpty()) {\n+            return errorDataSet(\"No such persistence unit: \" + persistenceUnit);\n+        }\n+\n+        //noinspection resource\n+        SessionFactoryImplementor sf = pu.get().sessionFactory();\n+\n+        // Check the connection for this persistence unit points to an allowed datasource\n+        ConnectionProvider connectionProvider = sf.getServiceRegistry().requireService(ConnectionProvider.class);\n+        if (connectionProvider instanceof QuarkusConnectionProvider quarkusConnectionProvider) {\n+            if (!isAllowedDatabase(quarkusConnectionProvider.getDataSource())) {\n+                return errorDataSet(\"The persistence unit's datasource points to a non-allowed datasource. \"\n+                        + \"By default only local databases are enabled; you can use the 'quarkus.datasource.dev-ui.allowed-db-host'\"\n+                        + \" configuration property to configure allowed hosts ('*' to allow all).\");\n+            }\n+        } else {\n+            return errorDataSet(\"Unsupported Connection Provider type for specified persistence unit.\");\n+        }\n+\n+        return sf.fromSession(session -> {\n+            try {\n+                Query<Object> query = session.createQuery(hql, null);\n+                if (isMutation(((SqmQuery) query).getSqmStatement())) {\n+                    // DML query, execute update within transaction and return custom message with affected rows\n+                    Transaction transaction = session.beginTransaction();\n+                    try {\n+                        int updateCount = query.executeUpdate();\n+                        transaction.commit();\n+\n+                        String message = \"Query executed correctly. Rows affected: \" + updateCount;\n+                        return new JsonRpcMessage<>(new DataSet(null, -1, message, null), MessageType.Response);\n+                    } catch (Exception e) {\n+                        // an error happened in executeUpdate() or during commit\n+                        transaction.rollback();\n+                        throw e;\n+                    }\n+                } else {\n+                    // selection query, execute count query and return paged results\n+\n+                    // This executes a separate count query\n+                    long resultCount = query.getResultCount();\n+\n+                    try (ScrollableResults<Object> scroll = query.scroll(ScrollMode.SCROLL_INSENSITIVE)) {\n+                        boolean hasNext = scroll.scroll((pageNumber - 1) * pageSize + 1);\n+                        List<Object> results = new ArrayList<>();\n+                        int i = 0;\n+                        while (hasNext && i++ < pageSize) {\n+                            results.add(scroll.get());\n+                            hasNext = scroll.next();\n+                        }\n+\n+                        // manually serialize data within the transaction to ensure lazy-loading can function\n+                        String result = writeValueAsString(new DataSet(results, resultCount, null, null));\n+                        JsonRpcMessage<Object> message = new JsonRpcMessage<>(result, MessageType.Response);\n+                        message.setAlreadySerialized(true);\n+                        return message;\n+                    }\n+                }\n+            } catch (Exception ex) {\n+                return new JsonRpcMessage<>(new DataSet(null, -1, null, ex.getMessage()), MessageType.Response);\n+            }\n+        });\n+    }\n+\n+    private static JsonRpcMessage<Object> errorDataSet(String errorMessage) {\n+        return new JsonRpcMessage<>(new DataSet(null, -1, null, errorMessage), MessageType.Response);\n+    }\n+\n+    private static String writeValueAsString(DataSet value) {\n+        try {\n+            JsonRpcRouter jsonRpcRouter = CDI.current().select(JsonRpcRouter.class).get();\n+            return jsonRpcRouter.getJsonMapper().toString(value, true);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\n+                    \"Unable to encode results as JSON. Note circular associations are not supported at the moment, use `@JsonIgnore` to break circles.\",",
        "comment_created_at": "2025-05-02T12:51:35+00:00",
        "comment_author": "omasseau",
        "comment_body": "This error message is misleading. It let people think that the cause of the exception is always a circular association, while it may not always be the case.\r\n\r\nThis error message is also only displayed in the dev UI (very briefly) and not logged at all in the application logs.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2004923834",
    "pr_number": 46900,
    "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
    "created_at": "2025-03-20T06:45:00+00:00",
    "commented_code": "options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2004923834",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T06:45:00+00:00",
        "comment_author": "cescoffier",
        "comment_body": "I'm not sure. The difference with the previous code is that it won't configure ALPN if sslOption.isUseAlpn is set to `false`, meaning that the options will use its default value.\r\nIt should be `false` too, so, that change does not bring much. What am I missing?",
        "pr_file_module": null
      },
      {
        "comment_id": "2004936274",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T06:55:51+00:00",
        "comment_author": "amusarra",
        "comment_body": "Hi @cescoffier If you read the issue linked to this PR, you will see that with the current code, even setting the ALPN property to false, you get the blocking exception object of the PR, exception thrown by the AMQP client. In this case, how would you solve the problem that is blocking? Do you have any better ideas? \r\nThanks.",
        "pr_file_module": null
      },
      {
        "comment_id": "2004937020",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T06:56:45+00:00",
        "comment_author": "cescoffier",
        "comment_body": "ProtonOptions need to be fixed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2004944786",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T07:04:45+00:00",
        "comment_author": "amusarra",
        "comment_body": "I'll try to check.",
        "pr_file_module": null
      },
      {
        "comment_id": "2004977792",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T07:28:46+00:00",
        "comment_author": "amusarra",
        "comment_body": "> ProtonOptions need to be fixed.\n\nBut if the Proton client does not actually support setting ALPN it is correct that it throws the exception that the operation is not supported. In my opinion it should be the one who uses the property setting method to handle the exception correctly if agreed?",
        "pr_file_module": null
      },
      {
        "comment_id": "2004993013",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T07:43:29+00:00",
        "comment_author": "cescoffier",
        "comment_body": "No, because the day we have an option implementation using \"true\" as default value (which may already exist), the new logic is not correct.\r\n\r\nWe could wrap the current code with the try/catch explaining the issue - but it's ugly. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2004997590",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T07:47:46+00:00",
        "comment_author": "amusarra",
        "comment_body": "so, in your opinion, what would be the solution to modify the Proton client's set method so that it doesn't throw any exceptions?",
        "pr_file_module": null
      },
      {
        "comment_id": "2005422519",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T11:36:20+00:00",
        "comment_author": "amusarra",
        "comment_body": "@cescoffier How would you make the change?\r\n\r\n<img width=\"616\" alt=\"image\" src=\"https://github.com/user-attachments/assets/63a1cbed-3eaa-4447-8904-e3ceb4b17cb2\" />\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2005533705",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T12:30:52+00:00",
        "comment_author": "amusarra",
        "comment_body": "ALPN is an extension to TLS that allows you to negotiate the application protocol to use during the TLS handshake. This is particularly useful when a server supports multiple protocols on the same port, such as HTTP/2, MQTT, or AMQP. In the context of AMQP over TLS (AMQPS), the use of ALPN is rare but possible,\r\n\r\nYes, it is correct that the `setUseAlpn(boolean useAlpn)` method in `ProtonClientOptions` throws an `UnsupportedOperationException()`, as this clearly indicates that ALPN is not supported in this implementation.\r\n\r\nProton (AMQP Library), does not have native integration with ALPN.\r\n\r\nGiven these assumptions I think it is correct to enclose the code in a try/catch block. Another possibility, if you do not like this solution, give the possibility to override `TlsConfigUtils` so that then anyone, in situations like this, can override the default behavior.\r\n\r\nBy opening the issue to ProtonClient, they might reply that the exception returned is correct because ALPN is not supported. So, what strategy do you propose? Consider that this situation is absolutely blocking for those who want to use AMQP over TLS.\r\n\r\nThanks.",
        "pr_file_module": null
      },
      {
        "comment_id": "2005613265",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T13:12:29+00:00",
        "comment_author": "amusarra",
        "comment_body": "This could be the piece of code with the try/catch that on exception reports in the log that ALPN is not supported.\r\n\r\n```java\r\n      // Try to set ALPN configuration, but handle UnsupportedOperationException\r\n      // for example, if the underlying implementation does not support it (es. AMQP)\r\n      try {\r\n        options.setUseAlpn(sslOptions.isUseAlpn());\r\n      } catch (UnsupportedOperationException e) {\r\n        log.warn(\r\n            \"ALPN configuration not supported by implementation: %s. ALPN setting will be ignored.\".formatted(\r\n                options.getClass().getName()));\r\n      }\r\n```\r\n\r\nFollowing is the result on the log.\r\n\r\n```\r\n2025-03-20 14:04:01,374 INFO  [io.sma.rea.mes.amqp] (Quarkus Main Thread) SRMSG16201: AMQP broker configured to localhost:5671 for channel requests\r\n2025-03-20 14:04:01,379 WARN  [org.acm.amq.tls.run.con.TlsConfigUtils] (Quarkus Main Thread) ALPN configuration not supported by implementation: io.vertx.amqp.AmqpClientOptions. ALPN setting will be ignored.\r\n```\r\n\r\nLet me know which path you want to follow.\r\n\r\nThanks.",
        "pr_file_module": null
      },
      {
        "comment_id": "2006244860",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-20T18:42:20+00:00",
        "comment_author": "cescoffier",
        "comment_body": "The proton options should not throw an exception but log a message. Otherwise, any implementation could decide what they like or not, making interfaces totally useless. In some cases it makes sense, but here, it's just plain annoying. I'm actually surprised they do not support ALPN. \n\nThe TlsConfigUtils cannot be overridden, it's mostly static and it's used in the TLS registry - it won't distinguish one case or another.\n\nThe try/catch solution is ugly, but I think it's the best we can have (but please raise an issue in Vertx-proton). ",
        "pr_file_module": null
      },
      {
        "comment_id": "2007081432",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46900,
        "pr_file": "extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/config/TlsConfigUtils.java",
        "discussion_id": "2004923834",
        "commented_code": "@@ -78,7 +78,9 @@ public static void configure(TCPSSLOptions options, TlsConfiguration configurati\n                 options.addCrlValue(buffer);\n             }\n             options.setEnabledSecureTransportProtocols(sslOptions.getEnabledSecureTransportProtocols());\n-            options.setUseAlpn(sslOptions.isUseAlpn());\n+            if (sslOptions.isUseAlpn()) {",
        "comment_created_at": "2025-03-21T08:30:41+00:00",
        "comment_author": "amusarra",
        "comment_body": "Hi @cescoffier  \r\nThanks for the feedback. I'll change the PR to include a try/catch block and then open an issue to Vert.x Proton hoping they'll accept.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1930712256",
    "pr_number": 45688,
    "pr_file": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java",
    "created_at": "2025-01-27T15:24:56+00:00",
    "commented_code": "return builder.build();\n     }\n+\n+    public enum EsAuth {\n+        NONE {\n+            @Override\n+            public void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config) {\n+                // No authentication needed\n+            }\n+        },\n+\n+        BASIC {\n+            @Override\n+            public void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config) {\n+                if (config.username().isPresent()) {\n+                    if (!\"https\".equalsIgnoreCase(config.protocol())) {\n+                        LOG.warn(\"Using Basic authentication in HTTP implies sending plain text passwords over the wire, \"\n+                                + \"use the HTTPS protocol instead.\");\n+                    }\n+\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username().get(),\n+                                    config.password().orElse(null)));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+            }\n+        },\n+\n+        API_KEY {\n+            @Override\n+            public void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config) {\n+                if (config.esApiKeyAuth().isPresent()) {\n+                    ElasticsearchConfig.EsApiKeyAuth auth = config.esApiKeyAuth().get();\n+                    Header apiKeyHeader = new BasicHeader(HttpHeaders.AUTHORIZATION,\n+                            \"ApiKey \" + auth.apiKey());\n+                    httpClientBuilder.setDefaultHeaders(Collections.singleton(apiKeyHeader));\n+                    LOG.info(\"API Key authentication is enabled.\");\n+                }\n+            }\n+        };\n+\n+        public abstract void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config);\n+    }\n+\n+    private static EsAuth checkAuthMethod(ElasticsearchConfig config) {\n+        boolean hasBasic = config.username().isPresent();\n+        boolean hasApiKey = config.esApiKeyAuth().isPresent();\n+\n+        if (hasBasic && hasApiKey) {\n+            LOG.warn(\"Multiple authentication methods configured. Defaulting to Basic Authentication.\");\n+            return EsAuth.BASIC;\n+        }",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1930712256",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 45688,
        "pr_file": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java",
        "discussion_id": "1930712256",
        "commented_code": "@@ -112,4 +110,58 @@ public static Sniffer createSniffer(RestClient client, ElasticsearchConfig confi\n \n         return builder.build();\n     }\n+\n+    public enum EsAuth {\n+        NONE {\n+            @Override\n+            public void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config) {\n+                // No authentication needed\n+            }\n+        },\n+\n+        BASIC {\n+            @Override\n+            public void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config) {\n+                if (config.username().isPresent()) {\n+                    if (!\"https\".equalsIgnoreCase(config.protocol())) {\n+                        LOG.warn(\"Using Basic authentication in HTTP implies sending plain text passwords over the wire, \"\n+                                + \"use the HTTPS protocol instead.\");\n+                    }\n+\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username().get(),\n+                                    config.password().orElse(null)));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+            }\n+        },\n+\n+        API_KEY {\n+            @Override\n+            public void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config) {\n+                if (config.esApiKeyAuth().isPresent()) {\n+                    ElasticsearchConfig.EsApiKeyAuth auth = config.esApiKeyAuth().get();\n+                    Header apiKeyHeader = new BasicHeader(HttpHeaders.AUTHORIZATION,\n+                            \"ApiKey \" + auth.apiKey());\n+                    httpClientBuilder.setDefaultHeaders(Collections.singleton(apiKeyHeader));\n+                    LOG.info(\"API Key authentication is enabled.\");\n+                }\n+            }\n+        };\n+\n+        public abstract void apply(HttpAsyncClientBuilder httpClientBuilder, ElasticsearchConfig config);\n+    }\n+\n+    private static EsAuth checkAuthMethod(ElasticsearchConfig config) {\n+        boolean hasBasic = config.username().isPresent();\n+        boolean hasApiKey = config.esApiKeyAuth().isPresent();\n+\n+        if (hasBasic && hasApiKey) {\n+            LOG.warn(\"Multiple authentication methods configured. Defaulting to Basic Authentication.\");\n+            return EsAuth.BASIC;\n+        }",
        "comment_created_at": "2025-01-27T15:24:56+00:00",
        "comment_author": "marko-bekhta",
        "comment_body": "I'd still say it's better to throw an exception here instead of logging a warning since this is a \"misconfiguration\", and a user would want to be precise about the auth methods.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "995528231",
    "pr_number": 28595,
    "pr_file": "independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ResteasyReactiveRequestContext.java",
    "created_at": "2022-10-14T09:02:13+00:00",
    "commented_code": "this.path = requestURI.getPath();\n         this.authority = requestURI.getRawAuthority();\n         this.scheme = requestURI.getScheme();\n-        // FIXME: it's possible we may have to also update the query part\n+        setQueryParamsFrom(requestURI.toString());\n         // invalidate those\n         this.uriInfo = null;\n         this.absoluteUri = null;\n         return this;\n     }\n \n+    protected void setQueryParamsFrom(String uri) {\n+        throw new NotImplementedYet();",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "995528231",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 28595,
        "pr_file": "independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ResteasyReactiveRequestContext.java",
        "discussion_id": "995528231",
        "commented_code": "@@ -470,13 +471,17 @@ public ResteasyReactiveRequestContext setRequestUri(URI requestURI) {\n         this.path = requestURI.getPath();\n         this.authority = requestURI.getRawAuthority();\n         this.scheme = requestURI.getScheme();\n-        // FIXME: it's possible we may have to also update the query part\n+        setQueryParamsFrom(requestURI.toString());\n         // invalidate those\n         this.uriInfo = null;\n         this.absoluteUri = null;\n         return this;\n     }\n \n+    protected void setQueryParamsFrom(String uri) {\n+        throw new NotImplementedYet();",
        "comment_created_at": "2022-10-14T09:02:13+00:00",
        "comment_author": "Sgitario",
        "comment_body": "I think this is very dangerous (new implementations of this class won't realize that this method needs to be implemented until they create a new instance of it). I would make this method abstract. ",
        "pr_file_module": null
      },
      {
        "comment_id": "995529531",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 28595,
        "pr_file": "independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ResteasyReactiveRequestContext.java",
        "discussion_id": "995528231",
        "commented_code": "@@ -470,13 +471,17 @@ public ResteasyReactiveRequestContext setRequestUri(URI requestURI) {\n         this.path = requestURI.getPath();\n         this.authority = requestURI.getRawAuthority();\n         this.scheme = requestURI.getScheme();\n-        // FIXME: it's possible we may have to also update the query part\n+        setQueryParamsFrom(requestURI.toString());\n         // invalidate those\n         this.uriInfo = null;\n         this.absoluteUri = null;\n         return this;\n     }\n \n+    protected void setQueryParamsFrom(String uri) {\n+        throw new NotImplementedYet();",
        "comment_created_at": "2022-10-14T09:03:33+00:00",
        "comment_author": "geoand",
        "comment_body": "Ideally yes, but I don't want to change this important class at this point",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066504634",
    "pr_number": 47592,
    "pr_file": "independent-projects/resteasy-reactive/server/processor/src/main/java/org/jboss/resteasy/reactive/server/processor/ServerEndpointIndexer.java",
    "created_at": "2025-04-29T13:45:12+00:00",
    "commented_code": "actualEndpointInfo,\n                 existingConverters, additionalReaders, injectableBeans, hasRuntimeConverters);\n         if ((injectableBean.getFieldExtractorsCount() == 0) && !injectableBean.isInjectionRequired()) {\n-            throw new DeploymentException(String.format(\"No annotations found on fields at '%s'. \"\n-                    + \"Annotations like `@QueryParam` should be used in fields, not in methods.\",\n-                    beanParamClassInfo.name()));\n+            long declaredMethodsCount = beanParamClassInfo.methods().stream()\n+                    .filter(m -> !m.name().equals(\"<init>\") && !m.name().equals(\"<clinit>\")).count();\n+            if (declaredMethodsCount == 0) {\n+                throw new DeploymentException(String.format(\"Class %s has no fields.\", beanParamClassInfo.name()));",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2066504634",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47592,
        "pr_file": "independent-projects/resteasy-reactive/server/processor/src/main/java/org/jboss/resteasy/reactive/server/processor/ServerEndpointIndexer.java",
        "discussion_id": "2066504634",
        "commented_code": "@@ -300,9 +300,16 @@ protected boolean handleBeanParam(ClassInfo actualEndpointInfo, Type paramType,\n                 actualEndpointInfo,\n                 existingConverters, additionalReaders, injectableBeans, hasRuntimeConverters);\n         if ((injectableBean.getFieldExtractorsCount() == 0) && !injectableBean.isInjectionRequired()) {\n-            throw new DeploymentException(String.format(\"No annotations found on fields at '%s'. \"\n-                    + \"Annotations like `@QueryParam` should be used in fields, not in methods.\",\n-                    beanParamClassInfo.name()));\n+            long declaredMethodsCount = beanParamClassInfo.methods().stream()\n+                    .filter(m -> !m.name().equals(\"<init>\") && !m.name().equals(\"<clinit>\")).count();\n+            if (declaredMethodsCount == 0) {\n+                throw new DeploymentException(String.format(\"Class %s has no fields.\", beanParamClassInfo.name()));",
        "comment_created_at": "2025-04-29T13:45:12+00:00",
        "comment_author": "FroMage",
        "comment_body": "```suggestion\r\n                throw new DeploymentException(String.format(\"Class %s has no fields. Parameters containers are only supported if they have at least one annotated field.\", beanParamClassInfo.name()));\r\n```",
        "pr_file_module": null
      }
    ]
  }
]