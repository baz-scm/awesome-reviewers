[
  {
    "discussion_id": "2169091979",
    "pr_number": 48427,
    "pr_file": "adr/0009-native-class-initialization.adoc",
    "created_at": "2025-06-26T13:34:29+00:00",
    "commented_code": "+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2169091979",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48427,
        "pr_file": "adr/0009-native-class-initialization.adoc",
        "discussion_id": "2169091979",
        "commented_code": "@@ -0,0 +1,330 @@\n+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.",
        "comment_created_at": "2025-06-26T13:34:29+00:00",
        "comment_author": "Sanne",
        "comment_body": "In my experience the worst drawback is in the transitivity of things: you might be initializing \"at build time\" something which requires running some portion of code that should really not be run at build time.\r\n\r\nSure substitutions are also something we should avoid, but it seems to me being the lesser complexity, perhaps even just a means to address the real issues.\r\n\r\nI'd highlight this here in the problem statement, as there are consequences in the decisions one can take below that need to bear this in mind.",
        "pr_file_module": null
      },
      {
        "comment_id": "2171731805",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48427,
        "pr_file": "adr/0009-native-class-initialization.adoc",
        "discussion_id": "2169091979",
        "commented_code": "@@ -0,0 +1,330 @@\n+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.",
        "comment_created_at": "2025-06-27T11:40:38+00:00",
        "comment_author": "zakkak",
        "comment_body": "Hopefully covered by https://github.com/quarkusio/quarkus/pull/48427/files#diff-2944ca1fe0897d5a84f747bfccb3241b19c2fe18ccc7c966c2db8cb180cb53aaR126 and https://github.com/quarkusio/quarkus/pull/48427/commits/4e4ca08400c82314b47a2605142de06f8f58cfae",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169125367",
    "pr_number": 48427,
    "pr_file": "adr/0009-native-class-initialization.adoc",
    "created_at": "2025-06-26T13:49:39+00:00",
    "commented_code": "+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.\n+This complicates the development process and discourages developers from using Quarkus' native mode due to increased complexity if they rely on libraries not handled by Quarkus or some of its extensions.\n+\n+Quarkus applications may depend at run time on:\n+\n+* Quarkus core and core extensions, which are distributed under the `io.quarkus` group ID.\n+* Quarkiverse extensions, which may be distributed under the `io.quarkiverse` or another group ID.\n+* User provided extensions not listed above\n+* Third-party libraries\n+\n+The goal of this ADR is to define:\n+1. which of the above should be initialized at build time and which should be initialized at run time by default in native mode.\n+2. how developers can opt in or out of build time initialization.\n+\n+== Decision Drivers\n+\n+* Reduce entry barrier for developers that want to use Quarkus native mode\n+* Benefit from build time initialization when possible\n+* Allow developers to opt-in to build time initialization of parts that are run time initialized by default\n+\n+== Considered options for default class initialization policy\n+\n+[source, mermaid]\n+....\n+---\n+title: Legend\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph TD\n+  BT[Build-time initialized]\n+  RT[Run-time initialized]\n+\n+classDef buildtime fill:#bbf;\n+class B,C,BT buildtime\n+....\n+\n+=== Initialize all classes at build time\n+\n+In this scenario, all classes in the Quarkus application are build time initialized, unless explicitly configured otherwise.\n+This option has been the default behavior in Quarkus for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,Camel,R1,R2,R3,R4,R5,UserExtension,UserExtensionBT,RestAssured,jboss buildtime\n+....\n+\n+\n+*Pros*:\n+\n+- It allows Quarkus to take advantage of build time initialization as much as possible.\n+\n+*Cons*:\n+\n+- It requires developers to deal with issues that arise from build time initialization that are often non-trivial.\n+- There is no easy way to exclude specific dependencies and possibly their transitive dependencies as well from build time initialization.\n+\n+=== Initialize all classes at runtime\n+\n+In this scenario, all classes in the Quarkus application are run time initialized (except for JDK classes footnote:[That's expected to change at some point after GraalVM for JDK 25]), unless explicitly configured otherwise.\n+This option has been the default behavior in GraalVM for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class UserExtensionBT buildtime\n+....\n+\n+*Pros*:\n+\n+- It makes running code in native mode easier and more predictable as it behaves closer to how it would behave in JVM mode.\n+\n+*Cons*:\n+\n+- It does not allow Quarkus to take advantage of build time initialization, which can lead to slower startup times and higher memory usage.\n+- It requires developers to explicitly configure classes to be initialized at build time, which can be cumbersome.\n+- Is expected to result in bigger native executables.\n+\n+=== Initialize some classes at build time and the rest at runtime\n+\n+Since Quarkus already defaults to initializing classes at build time, it is possible to configure it to keep initializing some classes at build time while initializing the rest at runtime.\n+In this approach there are multiple scenarios between the two extremes of initializing all classes at build time or at runtime.\n+The more classes we initialize at build time, the more we can take advantage of build time initialization, but the more we risk running into issues that require additional configuration or code substitutions and vice versa.\n+\n+==== Proposal 1: Initialize Quarkus core and all extensions along with their transitive dependencies at build time\n+\n+In this scenario Quarkus core and all Quarkus extensions, including Quarkiverse extensions as well as user provided extensions along with their transitive closure of dependencies, are initialized at build time.\n+This scenario reduces the entry barrier for most Quarkus users, as creating custom Quarkus extensions is considered an advanced use case.\n+Advanced users creating custom extensions are expected to be able to configure their extensions to initialize classes at build time or run time as needed.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R3,R4,UserExtension,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users.\n+\n+*Cons*:\n+\n+- Keeps the entry barrier for extension developers high.\n+\n+==== Proposal 2: Initialize Quarkus core and a vetted list of Quarkus extensions along with their transitive dependencies at build time\n+\n+In this scenario, Quarkus core and core extensions, as well as a vetted list of extensions along with the transitive closure of their dependencies, are initialized at build time, while user provided extensions and third-party libraries are initialized at runtime.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R4,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+\n+*Cons*:\n+\n+- Maintaining a vetted list of extensions will be cumbersome in the long run.\n+\n+==== Proposal 3: Initialize a vetted list of packages at build time\n+\n+In this scenario, a vetted list of packages, are initialized at build time, while anything else is initialized at runtime unless explicitly configured otherwise.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,UserExtensionBT,R1 buildtime\n+....\n+\n+*Pros*:\n+\n+- Offers great flexibility to what is initialized at build time. Meaning that the Quarkus team as well as the users can evaluate on a per package basis what should be initialized at build time.\n+\n+*Cons*:\n+\n+- Maintaining the vetted list of packages is expected to be pretty hard in the long run, especially as new dependencies are brought in through updates. Which comes with the risk of gradually shifting towards run-time initialization.\n+\n+==== Proposal 4: Initialize Quarkus core and its transitive dependencies at build time and everything else at runtime\n+\n+In this scenario, only Quarkus core and its transitive dependencies get initialized at build time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,R1,R2,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+- Reduce maintenance burden as only a small set of dependencies is initialized at build time.\n+\n+*Cons*:\n+\n+- Expected to result in slower startup times and higher memory usage.\n+- Expected to result in bigger native executables.\n+- Expected to result in some behavior differences.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2169125367",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48427,
        "pr_file": "adr/0009-native-class-initialization.adoc",
        "discussion_id": "2169125367",
        "commented_code": "@@ -0,0 +1,330 @@\n+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.\n+This complicates the development process and discourages developers from using Quarkus' native mode due to increased complexity if they rely on libraries not handled by Quarkus or some of its extensions.\n+\n+Quarkus applications may depend at run time on:\n+\n+* Quarkus core and core extensions, which are distributed under the `io.quarkus` group ID.\n+* Quarkiverse extensions, which may be distributed under the `io.quarkiverse` or another group ID.\n+* User provided extensions not listed above\n+* Third-party libraries\n+\n+The goal of this ADR is to define:\n+1. which of the above should be initialized at build time and which should be initialized at run time by default in native mode.\n+2. how developers can opt in or out of build time initialization.\n+\n+== Decision Drivers\n+\n+* Reduce entry barrier for developers that want to use Quarkus native mode\n+* Benefit from build time initialization when possible\n+* Allow developers to opt-in to build time initialization of parts that are run time initialized by default\n+\n+== Considered options for default class initialization policy\n+\n+[source, mermaid]\n+....\n+---\n+title: Legend\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph TD\n+  BT[Build-time initialized]\n+  RT[Run-time initialized]\n+\n+classDef buildtime fill:#bbf;\n+class B,C,BT buildtime\n+....\n+\n+=== Initialize all classes at build time\n+\n+In this scenario, all classes in the Quarkus application are build time initialized, unless explicitly configured otherwise.\n+This option has been the default behavior in Quarkus for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,Camel,R1,R2,R3,R4,R5,UserExtension,UserExtensionBT,RestAssured,jboss buildtime\n+....\n+\n+\n+*Pros*:\n+\n+- It allows Quarkus to take advantage of build time initialization as much as possible.\n+\n+*Cons*:\n+\n+- It requires developers to deal with issues that arise from build time initialization that are often non-trivial.\n+- There is no easy way to exclude specific dependencies and possibly their transitive dependencies as well from build time initialization.\n+\n+=== Initialize all classes at runtime\n+\n+In this scenario, all classes in the Quarkus application are run time initialized (except for JDK classes footnote:[That's expected to change at some point after GraalVM for JDK 25]), unless explicitly configured otherwise.\n+This option has been the default behavior in GraalVM for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class UserExtensionBT buildtime\n+....\n+\n+*Pros*:\n+\n+- It makes running code in native mode easier and more predictable as it behaves closer to how it would behave in JVM mode.\n+\n+*Cons*:\n+\n+- It does not allow Quarkus to take advantage of build time initialization, which can lead to slower startup times and higher memory usage.\n+- It requires developers to explicitly configure classes to be initialized at build time, which can be cumbersome.\n+- Is expected to result in bigger native executables.\n+\n+=== Initialize some classes at build time and the rest at runtime\n+\n+Since Quarkus already defaults to initializing classes at build time, it is possible to configure it to keep initializing some classes at build time while initializing the rest at runtime.\n+In this approach there are multiple scenarios between the two extremes of initializing all classes at build time or at runtime.\n+The more classes we initialize at build time, the more we can take advantage of build time initialization, but the more we risk running into issues that require additional configuration or code substitutions and vice versa.\n+\n+==== Proposal 1: Initialize Quarkus core and all extensions along with their transitive dependencies at build time\n+\n+In this scenario Quarkus core and all Quarkus extensions, including Quarkiverse extensions as well as user provided extensions along with their transitive closure of dependencies, are initialized at build time.\n+This scenario reduces the entry barrier for most Quarkus users, as creating custom Quarkus extensions is considered an advanced use case.\n+Advanced users creating custom extensions are expected to be able to configure their extensions to initialize classes at build time or run time as needed.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R3,R4,UserExtension,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users.\n+\n+*Cons*:\n+\n+- Keeps the entry barrier for extension developers high.\n+\n+==== Proposal 2: Initialize Quarkus core and a vetted list of Quarkus extensions along with their transitive dependencies at build time\n+\n+In this scenario, Quarkus core and core extensions, as well as a vetted list of extensions along with the transitive closure of their dependencies, are initialized at build time, while user provided extensions and third-party libraries are initialized at runtime.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R4,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+\n+*Cons*:\n+\n+- Maintaining a vetted list of extensions will be cumbersome in the long run.\n+\n+==== Proposal 3: Initialize a vetted list of packages at build time\n+\n+In this scenario, a vetted list of packages, are initialized at build time, while anything else is initialized at runtime unless explicitly configured otherwise.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,UserExtensionBT,R1 buildtime\n+....\n+\n+*Pros*:\n+\n+- Offers great flexibility to what is initialized at build time. Meaning that the Quarkus team as well as the users can evaluate on a per package basis what should be initialized at build time.\n+\n+*Cons*:\n+\n+- Maintaining the vetted list of packages is expected to be pretty hard in the long run, especially as new dependencies are brought in through updates. Which comes with the risk of gradually shifting towards run-time initialization.\n+\n+==== Proposal 4: Initialize Quarkus core and its transitive dependencies at build time and everything else at runtime\n+\n+In this scenario, only Quarkus core and its transitive dependencies get initialized at build time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,R1,R2,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+- Reduce maintenance burden as only a small set of dependencies is initialized at build time.\n+\n+*Cons*:\n+\n+- Expected to result in slower startup times and higher memory usage.\n+- Expected to result in bigger native executables.\n+- Expected to result in some behavior differences.",
        "comment_created_at": "2025-06-26T13:49:39+00:00",
        "comment_author": "Sanne",
        "comment_body": "I also expect lower runtime performance, not just bootstrap times. We'll miss out on significant DCE opportunities, and that has wild combinatorial consequences.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169716149",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48427,
        "pr_file": "adr/0009-native-class-initialization.adoc",
        "discussion_id": "2169125367",
        "commented_code": "@@ -0,0 +1,330 @@\n+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.\n+This complicates the development process and discourages developers from using Quarkus' native mode due to increased complexity if they rely on libraries not handled by Quarkus or some of its extensions.\n+\n+Quarkus applications may depend at run time on:\n+\n+* Quarkus core and core extensions, which are distributed under the `io.quarkus` group ID.\n+* Quarkiverse extensions, which may be distributed under the `io.quarkiverse` or another group ID.\n+* User provided extensions not listed above\n+* Third-party libraries\n+\n+The goal of this ADR is to define:\n+1. which of the above should be initialized at build time and which should be initialized at run time by default in native mode.\n+2. how developers can opt in or out of build time initialization.\n+\n+== Decision Drivers\n+\n+* Reduce entry barrier for developers that want to use Quarkus native mode\n+* Benefit from build time initialization when possible\n+* Allow developers to opt-in to build time initialization of parts that are run time initialized by default\n+\n+== Considered options for default class initialization policy\n+\n+[source, mermaid]\n+....\n+---\n+title: Legend\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph TD\n+  BT[Build-time initialized]\n+  RT[Run-time initialized]\n+\n+classDef buildtime fill:#bbf;\n+class B,C,BT buildtime\n+....\n+\n+=== Initialize all classes at build time\n+\n+In this scenario, all classes in the Quarkus application are build time initialized, unless explicitly configured otherwise.\n+This option has been the default behavior in Quarkus for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,Camel,R1,R2,R3,R4,R5,UserExtension,UserExtensionBT,RestAssured,jboss buildtime\n+....\n+\n+\n+*Pros*:\n+\n+- It allows Quarkus to take advantage of build time initialization as much as possible.\n+\n+*Cons*:\n+\n+- It requires developers to deal with issues that arise from build time initialization that are often non-trivial.\n+- There is no easy way to exclude specific dependencies and possibly their transitive dependencies as well from build time initialization.\n+\n+=== Initialize all classes at runtime\n+\n+In this scenario, all classes in the Quarkus application are run time initialized (except for JDK classes footnote:[That's expected to change at some point after GraalVM for JDK 25]), unless explicitly configured otherwise.\n+This option has been the default behavior in GraalVM for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class UserExtensionBT buildtime\n+....\n+\n+*Pros*:\n+\n+- It makes running code in native mode easier and more predictable as it behaves closer to how it would behave in JVM mode.\n+\n+*Cons*:\n+\n+- It does not allow Quarkus to take advantage of build time initialization, which can lead to slower startup times and higher memory usage.\n+- It requires developers to explicitly configure classes to be initialized at build time, which can be cumbersome.\n+- Is expected to result in bigger native executables.\n+\n+=== Initialize some classes at build time and the rest at runtime\n+\n+Since Quarkus already defaults to initializing classes at build time, it is possible to configure it to keep initializing some classes at build time while initializing the rest at runtime.\n+In this approach there are multiple scenarios between the two extremes of initializing all classes at build time or at runtime.\n+The more classes we initialize at build time, the more we can take advantage of build time initialization, but the more we risk running into issues that require additional configuration or code substitutions and vice versa.\n+\n+==== Proposal 1: Initialize Quarkus core and all extensions along with their transitive dependencies at build time\n+\n+In this scenario Quarkus core and all Quarkus extensions, including Quarkiverse extensions as well as user provided extensions along with their transitive closure of dependencies, are initialized at build time.\n+This scenario reduces the entry barrier for most Quarkus users, as creating custom Quarkus extensions is considered an advanced use case.\n+Advanced users creating custom extensions are expected to be able to configure their extensions to initialize classes at build time or run time as needed.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R3,R4,UserExtension,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users.\n+\n+*Cons*:\n+\n+- Keeps the entry barrier for extension developers high.\n+\n+==== Proposal 2: Initialize Quarkus core and a vetted list of Quarkus extensions along with their transitive dependencies at build time\n+\n+In this scenario, Quarkus core and core extensions, as well as a vetted list of extensions along with the transitive closure of their dependencies, are initialized at build time, while user provided extensions and third-party libraries are initialized at runtime.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R4,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+\n+*Cons*:\n+\n+- Maintaining a vetted list of extensions will be cumbersome in the long run.\n+\n+==== Proposal 3: Initialize a vetted list of packages at build time\n+\n+In this scenario, a vetted list of packages, are initialized at build time, while anything else is initialized at runtime unless explicitly configured otherwise.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,UserExtensionBT,R1 buildtime\n+....\n+\n+*Pros*:\n+\n+- Offers great flexibility to what is initialized at build time. Meaning that the Quarkus team as well as the users can evaluate on a per package basis what should be initialized at build time.\n+\n+*Cons*:\n+\n+- Maintaining the vetted list of packages is expected to be pretty hard in the long run, especially as new dependencies are brought in through updates. Which comes with the risk of gradually shifting towards run-time initialization.\n+\n+==== Proposal 4: Initialize Quarkus core and its transitive dependencies at build time and everything else at runtime\n+\n+In this scenario, only Quarkus core and its transitive dependencies get initialized at build time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,R1,R2,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+- Reduce maintenance burden as only a small set of dependencies is initialized at build time.\n+\n+*Cons*:\n+\n+- Expected to result in slower startup times and higher memory usage.\n+- Expected to result in bigger native executables.\n+- Expected to result in some behavior differences.",
        "comment_created_at": "2025-06-26T18:44:00+00:00",
        "comment_author": "zakkak",
        "comment_body": "> I also expect lower runtime performance, not just bootstrap times. \r\n\r\nCorrect.\r\n\r\n> We'll miss out on significant DCE opportunities, and that has wild combinatorial consequences.\r\n\r\nWell that's our feeling but we don't actually have numbers to back this up do we?",
        "pr_file_module": null
      },
      {
        "comment_id": "2171084611",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48427,
        "pr_file": "adr/0009-native-class-initialization.adoc",
        "discussion_id": "2169125367",
        "commented_code": "@@ -0,0 +1,330 @@\n+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.\n+This complicates the development process and discourages developers from using Quarkus' native mode due to increased complexity if they rely on libraries not handled by Quarkus or some of its extensions.\n+\n+Quarkus applications may depend at run time on:\n+\n+* Quarkus core and core extensions, which are distributed under the `io.quarkus` group ID.\n+* Quarkiverse extensions, which may be distributed under the `io.quarkiverse` or another group ID.\n+* User provided extensions not listed above\n+* Third-party libraries\n+\n+The goal of this ADR is to define:\n+1. which of the above should be initialized at build time and which should be initialized at run time by default in native mode.\n+2. how developers can opt in or out of build time initialization.\n+\n+== Decision Drivers\n+\n+* Reduce entry barrier for developers that want to use Quarkus native mode\n+* Benefit from build time initialization when possible\n+* Allow developers to opt-in to build time initialization of parts that are run time initialized by default\n+\n+== Considered options for default class initialization policy\n+\n+[source, mermaid]\n+....\n+---\n+title: Legend\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph TD\n+  BT[Build-time initialized]\n+  RT[Run-time initialized]\n+\n+classDef buildtime fill:#bbf;\n+class B,C,BT buildtime\n+....\n+\n+=== Initialize all classes at build time\n+\n+In this scenario, all classes in the Quarkus application are build time initialized, unless explicitly configured otherwise.\n+This option has been the default behavior in Quarkus for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,Camel,R1,R2,R3,R4,R5,UserExtension,UserExtensionBT,RestAssured,jboss buildtime\n+....\n+\n+\n+*Pros*:\n+\n+- It allows Quarkus to take advantage of build time initialization as much as possible.\n+\n+*Cons*:\n+\n+- It requires developers to deal with issues that arise from build time initialization that are often non-trivial.\n+- There is no easy way to exclude specific dependencies and possibly their transitive dependencies as well from build time initialization.\n+\n+=== Initialize all classes at runtime\n+\n+In this scenario, all classes in the Quarkus application are run time initialized (except for JDK classes footnote:[That's expected to change at some point after GraalVM for JDK 25]), unless explicitly configured otherwise.\n+This option has been the default behavior in GraalVM for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class UserExtensionBT buildtime\n+....\n+\n+*Pros*:\n+\n+- It makes running code in native mode easier and more predictable as it behaves closer to how it would behave in JVM mode.\n+\n+*Cons*:\n+\n+- It does not allow Quarkus to take advantage of build time initialization, which can lead to slower startup times and higher memory usage.\n+- It requires developers to explicitly configure classes to be initialized at build time, which can be cumbersome.\n+- Is expected to result in bigger native executables.\n+\n+=== Initialize some classes at build time and the rest at runtime\n+\n+Since Quarkus already defaults to initializing classes at build time, it is possible to configure it to keep initializing some classes at build time while initializing the rest at runtime.\n+In this approach there are multiple scenarios between the two extremes of initializing all classes at build time or at runtime.\n+The more classes we initialize at build time, the more we can take advantage of build time initialization, but the more we risk running into issues that require additional configuration or code substitutions and vice versa.\n+\n+==== Proposal 1: Initialize Quarkus core and all extensions along with their transitive dependencies at build time\n+\n+In this scenario Quarkus core and all Quarkus extensions, including Quarkiverse extensions as well as user provided extensions along with their transitive closure of dependencies, are initialized at build time.\n+This scenario reduces the entry barrier for most Quarkus users, as creating custom Quarkus extensions is considered an advanced use case.\n+Advanced users creating custom extensions are expected to be able to configure their extensions to initialize classes at build time or run time as needed.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R3,R4,UserExtension,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users.\n+\n+*Cons*:\n+\n+- Keeps the entry barrier for extension developers high.\n+\n+==== Proposal 2: Initialize Quarkus core and a vetted list of Quarkus extensions along with their transitive dependencies at build time\n+\n+In this scenario, Quarkus core and core extensions, as well as a vetted list of extensions along with the transitive closure of their dependencies, are initialized at build time, while user provided extensions and third-party libraries are initialized at runtime.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R4,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+\n+*Cons*:\n+\n+- Maintaining a vetted list of extensions will be cumbersome in the long run.\n+\n+==== Proposal 3: Initialize a vetted list of packages at build time\n+\n+In this scenario, a vetted list of packages, are initialized at build time, while anything else is initialized at runtime unless explicitly configured otherwise.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,UserExtensionBT,R1 buildtime\n+....\n+\n+*Pros*:\n+\n+- Offers great flexibility to what is initialized at build time. Meaning that the Quarkus team as well as the users can evaluate on a per package basis what should be initialized at build time.\n+\n+*Cons*:\n+\n+- Maintaining the vetted list of packages is expected to be pretty hard in the long run, especially as new dependencies are brought in through updates. Which comes with the risk of gradually shifting towards run-time initialization.\n+\n+==== Proposal 4: Initialize Quarkus core and its transitive dependencies at build time and everything else at runtime\n+\n+In this scenario, only Quarkus core and its transitive dependencies get initialized at build time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,R1,R2,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+- Reduce maintenance burden as only a small set of dependencies is initialized at build time.\n+\n+*Cons*:\n+\n+- Expected to result in slower startup times and higher memory usage.\n+- Expected to result in bigger native executables.\n+- Expected to result in some behavior differences.",
        "comment_created_at": "2025-06-27T07:47:56+00:00",
        "comment_author": "Sanne",
        "comment_body": "> Well that's our feeling but we don't actually have numbers to back this up do we?\r\n\r\nYou're right, we don't. Perhaps we should work on this, aiming for the GraalVM workshop as a target date to backup some discussions?\r\n\r\nBut thinking about this, it reminds me of another strong drawback which we should document here: I do clearly remember having situations in which the lack of DCO would lead to inclusion of code branches which would in turn lead to total compilation failures.   These were in the early days (things might have changed) and would involve typically codepaths in overriden methods, and having these DCO's properly then suggests an invocation path that would have been megamorphic can be simplified into a direct invocation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2171197900",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48427,
        "pr_file": "adr/0009-native-class-initialization.adoc",
        "discussion_id": "2169125367",
        "commented_code": "@@ -0,0 +1,330 @@\n+= When to initialize classes in native mode\n+\n+* Status: _proposed_\n+* Date: 2025-06-17\n+* Authors: @zakkak, @gsmet, @cescoffier, @aloubyansky\n+\n+== Context and Problem Statement\n+\n+Build time initialization of classes in native mode aligns with Quarkus' philosophy of doing as much as possible at build time to optimize run time performance and reduce startup time.\n+However, build time initialization often leads to issues that require additional configuration or even code substitutions to be worked around.\n+This complicates the development process and discourages developers from using Quarkus' native mode due to increased complexity if they rely on libraries not handled by Quarkus or some of its extensions.\n+\n+Quarkus applications may depend at run time on:\n+\n+* Quarkus core and core extensions, which are distributed under the `io.quarkus` group ID.\n+* Quarkiverse extensions, which may be distributed under the `io.quarkiverse` or another group ID.\n+* User provided extensions not listed above\n+* Third-party libraries\n+\n+The goal of this ADR is to define:\n+1. which of the above should be initialized at build time and which should be initialized at run time by default in native mode.\n+2. how developers can opt in or out of build time initialization.\n+\n+== Decision Drivers\n+\n+* Reduce entry barrier for developers that want to use Quarkus native mode\n+* Benefit from build time initialization when possible\n+* Allow developers to opt-in to build time initialization of parts that are run time initialized by default\n+\n+== Considered options for default class initialization policy\n+\n+[source, mermaid]\n+....\n+---\n+title: Legend\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph TD\n+  BT[Build-time initialized]\n+  RT[Run-time initialized]\n+\n+classDef buildtime fill:#bbf;\n+class B,C,BT buildtime\n+....\n+\n+=== Initialize all classes at build time\n+\n+In this scenario, all classes in the Quarkus application are build time initialized, unless explicitly configured otherwise.\n+This option has been the default behavior in Quarkus for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,Camel,R1,R2,R3,R4,R5,UserExtension,UserExtensionBT,RestAssured,jboss buildtime\n+....\n+\n+\n+*Pros*:\n+\n+- It allows Quarkus to take advantage of build time initialization as much as possible.\n+\n+*Cons*:\n+\n+- It requires developers to deal with issues that arise from build time initialization that are often non-trivial.\n+- There is no easy way to exclude specific dependencies and possibly their transitive dependencies as well from build time initialization.\n+\n+=== Initialize all classes at runtime\n+\n+In this scenario, all classes in the Quarkus application are run time initialized (except for JDK classes footnote:[That's expected to change at some point after GraalVM for JDK 25]), unless explicitly configured otherwise.\n+This option has been the default behavior in GraalVM for a long time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class UserExtensionBT buildtime\n+....\n+\n+*Pros*:\n+\n+- It makes running code in native mode easier and more predictable as it behaves closer to how it would behave in JVM mode.\n+\n+*Cons*:\n+\n+- It does not allow Quarkus to take advantage of build time initialization, which can lead to slower startup times and higher memory usage.\n+- It requires developers to explicitly configure classes to be initialized at build time, which can be cumbersome.\n+- Is expected to result in bigger native executables.\n+\n+=== Initialize some classes at build time and the rest at runtime\n+\n+Since Quarkus already defaults to initializing classes at build time, it is possible to configure it to keep initializing some classes at build time while initializing the rest at runtime.\n+In this approach there are multiple scenarios between the two extremes of initializing all classes at build time or at runtime.\n+The more classes we initialize at build time, the more we can take advantage of build time initialization, but the more we risk running into issues that require additional configuration or code substitutions and vice versa.\n+\n+==== Proposal 1: Initialize Quarkus core and all extensions along with their transitive dependencies at build time\n+\n+In this scenario Quarkus core and all Quarkus extensions, including Quarkiverse extensions as well as user provided extensions along with their transitive closure of dependencies, are initialized at build time.\n+This scenario reduces the entry barrier for most Quarkus users, as creating custom Quarkus extensions is considered an advanced use case.\n+Advanced users creating custom extensions are expected to be able to configure their extensions to initialize classes at build time or run time as needed.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R3,R4,UserExtension,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users.\n+\n+*Cons*:\n+\n+- Keeps the entry barrier for extension developers high.\n+\n+==== Proposal 2: Initialize Quarkus core and a vetted list of Quarkus extensions along with their transitive dependencies at build time\n+\n+In this scenario, Quarkus core and core extensions, as well as a vetted list of extensions along with the transitive closure of their dependencies, are initialized at build time, while user provided extensions and third-party libraries are initialized at runtime.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,R1,R2,R4,UserExtensionBT,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Changes the current behavior as little as possible.\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+\n+*Cons*:\n+\n+- Maintaining a vetted list of extensions will be cumbersome in the long run.\n+\n+==== Proposal 3: Initialize a vetted list of packages at build time\n+\n+In this scenario, a vetted list of packages, are initialized at build time, while anything else is initialized at runtime unless explicitly configured otherwise.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,BT,Camel,UserExtensionBT,R1 buildtime\n+....\n+\n+*Pros*:\n+\n+- Offers great flexibility to what is initialized at build time. Meaning that the Quarkus team as well as the users can evaluate on a per package basis what should be initialized at build time.\n+\n+*Cons*:\n+\n+- Maintaining the vetted list of packages is expected to be pretty hard in the long run, especially as new dependencies are brought in through updates. Which comes with the risk of gradually shifting towards run-time initialization.\n+\n+==== Proposal 4: Initialize Quarkus core and its transitive dependencies at build time and everything else at runtime\n+\n+In this scenario, only Quarkus core and its transitive dependencies get initialized at build time.\n+\n+[source, mermaid]\n+....\n+---\n+config:\n+  look: handDrawn\n+  theme: default\n+---\n+graph LR\n+  A[Quarkus Application] --> QA[io.quarkus:quarkus-arc]\n+  arc --> jboss[org.jboss.logging:jboss-logging]\n+  QA --> arc[io.quarkus.arc:arc] --> R1[...]\n+  QA --> core[io.quarkus:quarkus-core] --> R2[...]\n+  A --> UserExtension[com.example:my-extension] --> R3[...]\n+  UserExtension --> core\n+  UserExtension --> jboss\n+  A --> UserExtensionBT[com.example:build-time-initialized-extension] --> UserExtension\n+  A --> Camel[org.apache.camel.quarkus:camel-quarkus-core]  --> R4[...]\n+  A --> RestAssured[io.rest-assured:rest-assured:jar] --> R5[...]\n+\n+classDef white fill:#fff;\n+class A white\n+classDef buildtime fill:#bbf;\n+class QA,arc,core,R1,R2,jboss buildtime\n+....\n+\n+*Pros*:\n+\n+- Reduces the entry barrier for most Quarkus users as well as extension developers.\n+- Reduce maintenance burden as only a small set of dependencies is initialized at build time.\n+\n+*Cons*:\n+\n+- Expected to result in slower startup times and higher memory usage.\n+- Expected to result in bigger native executables.\n+- Expected to result in some behavior differences.",
        "comment_created_at": "2025-06-27T08:24:57+00:00",
        "comment_author": "zakkak",
        "comment_body": "> You're right, we don't. Perhaps we should work on this, aiming for the GraalVM workshop as a target date to backup some discussions?\r\n\r\nI agree it's worth exploring, but it's not trivial to do it in a realistic/representative manner with the current tooling. I tried building and running `picocli-native` which is pretty minimal in \"runtime-initialize everything\" mode and I managed to get it to build but then it fails at runtime which indicates that it will take some more effort to have a Quarkus build-time init vs Quarkus run-time init demo, especially for more complex apps/tests. I believe having the \"opt-in\", \"opt-out\" mechanisms in place that would allow us to easily switch big parts of code from build time init to runtime init might make such demos easier to conduct.\r\n\r\nFWIW the changes I applied to Quarkus to enable it to build `picocli-native` with runtime-initialization are here  https://github.com/zakkak/quarkus/commit/502569a67fcb51c05acaf0e24251571ebada0bfa",
        "pr_file_module": null
      }
    ]
  }
]