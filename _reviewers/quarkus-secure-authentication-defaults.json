[
  {
    "discussion_id": "1821938933",
    "pr_number": 44105,
    "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
    "created_at": "2024-10-30T06:05:51+00:00",
    "commented_code": "package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1821938933",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1821938933",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),",
        "comment_created_at": "2024-10-30T06:05:51+00:00",
        "comment_author": "ynojima",
        "comment_body": "`NoneAttestationStatementAsyncVerifier` should not be included here as none attestation statement doesn't attestates authenticator. This causes attestation check bypass.",
        "pr_file_module": null
      },
      {
        "comment_id": "1827463257",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1821938933",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));\n         if (config.pubKeyCredParams().isPresent()) {\n-            options.setPubKeyCredParams(config.pubKeyCredParams().get());\n+            this.pubKeyCredParams = new ArrayList<>(config.pubKeyCredParams().get().size());\n+            for (PublicKeyCredential publicKeyCredential : config.pubKeyCredParams().get()) {\n+                this.pubKeyCredParams.add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY,\n+                        COSEAlgorithmIdentifier.create(publicKeyCredential.coseId())));\n+            }\n+        } else {\n+            this.pubKeyCredParams = new ArrayList<>(2);\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.ES256));\n+            this.pubKeyCredParams\n+                    .add(new PublicKeyCredentialParameters(PublicKeyCredentialType.PUBLIC_KEY, COSEAlgorithmIdentifier.RS256));\n         }\n-        if (config.requireResidentKey().isPresent()) {\n-            options.setRequireResidentKey(config.requireResidentKey().get());\n-        }\n-        if (config.timeout().isPresent()) {\n-            options.setTimeoutInMilliseconds(config.timeout().get().toMillis());\n+        this.authenticatorAttachment = config.authenticatorAttachment().orElse(null);\n+        this.userVerification = config.userVerification().orElse(UserVerification.DISCOURAGED);\n+        this.residentKey = config.residentKey().orElse(ResidentKey.DISCOURAGED);\n+        this.attestation = config.attestation().orElse(Attestation.NONE);\n+        // create the webauthn4j manager\n+        this.webAuthn = makeWebAuthn(vertx, config);\n+        this.random = VertxContextPRNG.current(vertx);\n+    }\n+\n+    private String randomBase64URLBuffer() {\n+        final byte[] buff = new byte[challengeLength];\n+        random.nextBytes(buff);\n+        return Base64UrlUtil.encodeToString(buff);\n+    }\n+\n+    private WebAuthnAsyncManager makeWebAuthn(Vertx vertx, WebAuthnRunTimeConfig config) {\n+        if (config.attestation().isPresent()\n+                && config.attestation().get() == WebAuthnRunTimeConfig.Attestation.ENTERPRISE) {\n+            TrustAnchorAsyncRepository something;\n+            // FIXME: make config name configurable?\n+            Optional<TlsConfiguration> webauthnTlsConfiguration = certificates.get(\"webauthn\");\n+            KeyStore trustStore;\n+            if (webauthnTlsConfiguration.isPresent()) {\n+                trustStore = webauthnTlsConfiguration.get().getTrustStore();\n+            } else {\n+                try {\n+                    trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+                    trustStore.load(null, null);\n+                    addCert(trustStore, ANDROID_KEYSTORE_ROOT);\n+                    addCert(trustStore, APPLE_WEBAUTHN_ROOT_CA);\n+                    addCert(trustStore, FIDO_MDS3_ROOT_CERTIFICATE);\n+                    addCert(trustStore, GSR1);\n+                } catch (CertificateException | KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                    throw new RuntimeException(\"Failed to configure default WebAuthn certificates\", e);\n+                }\n+            }\n+            Set<TrustAnchor> trustAnchors = new HashSet<>();\n+            try {\n+                Enumeration<String> aliases = trustStore.aliases();\n+                while (aliases.hasMoreElements()) {\n+                    trustAnchors.add(new TrustAnchor((X509Certificate) trustStore.getCertificate(aliases.nextElement()), null));\n+                }\n+            } catch (KeyStoreException e) {\n+                throw new RuntimeException(\"Failed to configure WebAuthn trust store\", e);\n+            }\n+            // FIXME CLRs are not supported yet\n+            something = new KeyStoreTrustAnchorAsyncRepository(trustStore);\n+            if (config.loadMetadata().orElse(false)) {\n+                HttpAsyncClient httpClient = new VertxHttpAsyncClient(vertx);\n+                FidoMDS3MetadataBLOBAsyncProvider blobAsyncProvider = new FidoMDS3MetadataBLOBAsyncProvider(objectConverter,\n+                        FidoMDS3MetadataBLOBAsyncProvider.DEFAULT_BLOB_ENDPOINT, httpClient, trustAnchors);\n+                something = new MetadataBLOBBasedTrustAnchorAsyncRepository(blobAsyncProvider);\n+            }\n+\n+            return new WebAuthnAsyncManager(\n+                    Arrays.asList(\n+                            new NoneAttestationStatementAsyncVerifier(),",
        "comment_created_at": "2024-11-04T09:54:10+00:00",
        "comment_author": "FroMage",
        "comment_body": "Ah, good catch!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1822068444",
    "pr_number": 44105,
    "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
    "created_at": "2024-10-30T08:03:59+00:00",
    "commented_code": "package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1822068444",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1822068444",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));",
        "comment_created_at": "2024-10-30T08:03:59+00:00",
        "comment_author": "ynojima",
        "comment_body": "default timeout value is recommended to be 5 minutes:\r\nhttps://w3c.github.io/webauthn/#recommended-range-and-default-for-a-webauthn-ceremony-timeout",
        "pr_file_module": null
      },
      {
        "comment_id": "1827467461",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1822068444",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);\n+        this.timeout = config.timeout().orElse(Duration.ofSeconds(60));",
        "comment_created_at": "2024-11-04T09:57:16+00:00",
        "comment_author": "FroMage",
        "comment_body": "Ah, I didn't know, thanks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1823830804",
    "pr_number": 44105,
    "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
    "created_at": "2024-10-31T06:41:03+00:00",
    "commented_code": "package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1823830804",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1823830804",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);",
        "comment_created_at": "2024-10-31T06:41:03+00:00",
        "comment_author": "ynojima",
        "comment_body": "The default value of `userPresenceRequired` should be `true`.\r\nThe specification says \"If options.[mediation](https://w3c.github.io/webappsec-credential-management/#dom-credentialcreationoptions-mediation) is not set to [conditional](https://w3c.github.io/webappsec-credential-management/#dom-credentialmediationrequirement-conditional), verify that the [UP](https://w3c.github.io/webauthn/#authdata-flags-up) bit of the [flags](https://w3c.github.io/webauthn/#authdata-flags) in authData is set.\"\r\nhttps://w3c.github.io/webauthn/#sctn-registering-a-new-credential",
        "pr_file_module": null
      },
      {
        "comment_id": "1827756742",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1823830804",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);",
        "comment_created_at": "2024-11-04T13:44:36+00:00",
        "comment_author": "FroMage",
        "comment_body": "I'm not sure I understand what the relation with `options.mediation` but I'll change it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1827851141",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java",
        "discussion_id": "1823830804",
        "commented_code": "@@ -1,84 +1,418 @@\n package io.quarkus.security.webauthn;\n \n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.Principal;\n+import java.security.cert.CertificateException;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n \n import jakarta.enterprise.context.ApplicationScoped;\n import jakarta.inject.Inject;\n \n+import com.webauthn4j.async.WebAuthnAsyncManager;\n+import com.webauthn4j.async.anchor.KeyStoreTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.anchor.TrustAnchorAsyncRepository;\n+import com.webauthn4j.async.metadata.FidoMDS3MetadataBLOBAsyncProvider;\n+import com.webauthn4j.async.metadata.HttpAsyncClient;\n+import com.webauthn4j.async.metadata.anchor.MetadataBLOBBasedTrustAnchorAsyncRepository;\n+import com.webauthn4j.async.verifier.attestation.statement.androidkey.AndroidKeyAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.androidsafetynet.AndroidSafetyNetAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.apple.AppleAnonymousAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.none.NoneAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.packed.PackedAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.tpm.TPMAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.statement.u2f.FIDOU2FAttestationStatementAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.certpath.DefaultCertPathTrustworthinessAsyncVerifier;\n+import com.webauthn4j.async.verifier.attestation.trustworthiness.self.DefaultSelfAttestationTrustworthinessAsyncVerifier;\n+import com.webauthn4j.converter.util.ObjectConverter;\n+import com.webauthn4j.data.AuthenticationParameters;\n+import com.webauthn4j.data.AuthenticatorSelectionCriteria;\n+import com.webauthn4j.data.PublicKeyCredentialCreationOptions;\n+import com.webauthn4j.data.PublicKeyCredentialDescriptor;\n+import com.webauthn4j.data.PublicKeyCredentialParameters;\n+import com.webauthn4j.data.PublicKeyCredentialRequestOptions;\n+import com.webauthn4j.data.PublicKeyCredentialRpEntity;\n+import com.webauthn4j.data.PublicKeyCredentialType;\n+import com.webauthn4j.data.PublicKeyCredentialUserEntity;\n+import com.webauthn4j.data.RegistrationParameters;\n+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;\n+import com.webauthn4j.data.client.Origin;\n+import com.webauthn4j.data.client.challenge.DefaultChallenge;\n+import com.webauthn4j.data.extension.client.AuthenticationExtensionsClientInputs;\n+import com.webauthn4j.server.ServerProperty;\n+import com.webauthn4j.util.Base64UrlUtil;\n+\n import io.quarkus.security.runtime.QuarkusPrincipal;\n import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.Attestation;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.AuthenticatorAttachment;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.PublicKeyCredential;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.ResidentKey;\n+import io.quarkus.security.webauthn.WebAuthnRunTimeConfig.UserVerification;\n+import io.quarkus.security.webauthn.impl.VertxHttpAsyncClient;\n+import io.quarkus.tls.TlsConfiguration;\n+import io.quarkus.tls.TlsConfigurationRegistry;\n import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n import io.smallrye.mutiny.Uni;\n import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.Cookie;\n-import io.vertx.ext.auth.webauthn.Authenticator;\n-import io.vertx.ext.auth.webauthn.RelyingParty;\n-import io.vertx.ext.auth.webauthn.WebAuthn;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.WebAuthnOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.impl.CertificateHelper;\n+import io.vertx.ext.auth.impl.CertificateHelper.CertInfo;\n+import io.vertx.ext.auth.impl.jose.JWS;\n+import io.vertx.ext.auth.prng.VertxContextPRNG;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Utility class that allows users to manually login or register users using WebAuthn\n  */\n @ApplicationScoped\n public class WebAuthnSecurity {\n \n-    private WebAuthn webAuthn;\n-    private String origin;\n-    private String domain;\n+    /*\n+     * Android Keystore Root is not published anywhere.\n+     * This certificate was extracted from one of the attestations\n+     * The last certificate in x5c must match this certificate\n+     * This needs to be checked to ensure that malicious party won't generate fake attestations\n+     */\n+    private static final String ANDROID_KEYSTORE_ROOT = \"MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG\" +\n+            \"EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll\" +\n+            \"dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD\" +\n+            \"VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw\" +\n+            \"HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx\" +\n+            \"EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT\" +\n+            \"BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq\" +\n+            \"QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH\" +\n+            \"KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59\" +\n+            \"dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O\" +\n+            \"BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W\" +\n+            \"EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG\" +\n+            \"SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN\" +\n+            \"C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==\";\n+\n+    // https://aboutssl.org/globalsign-root-certificates-licensing-and-use/\n+    //  Name \tgsr1\n+    // Thumbprint: b1:bc:96:8b:d4:f4:9d:62:2a:a8:9a:81:f2:15:01:52:a4:1d:82:9c\n+    //  Valid Until \t28 January 2028\n+    private static final String GSR1 = \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n+            \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n+            \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n+            \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n+            \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n+            \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n+            \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n+            \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n+            \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n+            \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n+            \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n+            \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n+            \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n+            \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n+            \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n+            \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n+            \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n+            \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n+            \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\";\n+\n+    /**\n+     * Apple WebAuthn Root CA PEM\n+     * <p>\n+     * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n+     * <p>\n+     * Valid until 03/14/2045 @ 5:00 PM PST\n+     */\n+    private static final String APPLE_WEBAUTHN_ROOT_CA = \"MIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\" +\n+            \"HQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\" +\n+            \"bmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\" +\n+            \"NTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\" +\n+            \"A1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\" +\n+            \"AgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\" +\n+            \"xu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\" +\n+            \"pcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\" +\n+            \"2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\" +\n+            \"MGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\" +\n+            \"jAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\" +\n+            \"1bWeT0vT\";\n+\n+    /**\n+     * Default FIDO2 MDS3 ROOT Certificate\n+     * <p>\n+     * Downloaded from https://valid.r3.roots.globalsign.com/\n+     * <p>\n+     * Valid until 18 March 2029\n+     */\n+    private static final String FIDO_MDS3_ROOT_CERTIFICATE = \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\"\n+            +\n+            \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\" +\n+            \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\" +\n+            \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\" +\n+            \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\" +\n+            \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\" +\n+            \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\" +\n+            \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\" +\n+            \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\" +\n+            \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\" +\n+            \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\" +\n+            \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\" +\n+            \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\" +\n+            \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\" +\n+            \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\" +\n+            \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\" +\n+            \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\" +\n+            \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\" +\n+            \"WD9f\";\n+\n+    @Inject\n+    TlsConfigurationRegistry certificates;\n \n     @Inject\n     WebAuthnAuthenticationMechanism authMech;\n+\n+    @Inject\n+    WebAuthnAuthenticatorStorage storage;\n+\n+    private ObjectConverter objectConverter = new ObjectConverter();\n+    private WebAuthnAsyncManager webAuthn;\n+    private VertxContextPRNG random;\n+\n     private String challengeCookie;\n     private String challengeUsernameCookie;\n \n+    private String origin;\n+    private String rpId;\n+    private String rpName;\n+\n+    private UserVerification userVerification;\n+    private Boolean userPresenceRequired;\n+    private List<PublicKeyCredentialParameters> pubKeyCredParams;\n+    private ResidentKey residentKey;\n+\n+    private Duration timeout;\n+    private int challengeLength;\n+    private AuthenticatorAttachment authenticatorAttachment;\n+\n+    private Attestation attestation;\n+\n     public WebAuthnSecurity(WebAuthnRunTimeConfig config, Vertx vertx, WebAuthnAuthenticatorStorage database) {\n-        // create the webauthn security object\n-        WebAuthnOptions options = new WebAuthnOptions();\n-        RelyingParty relyingParty = new RelyingParty();\n-        if (config.relyingParty().id().isPresent()) {\n-            relyingParty.setId(config.relyingParty().id().get());\n-        }\n-        // this is required\n-        relyingParty.setName(config.relyingParty().name());\n-        options.setRelyingParty(relyingParty);\n-        if (config.attestation().isPresent()) {\n-            options.setAttestation(config.attestation().get());\n-        }\n-        if (config.authenticatorAttachment().isPresent()) {\n-            options.setAuthenticatorAttachment(config.authenticatorAttachment().get());\n-        }\n-        if (config.challengeLength().isPresent()) {\n-            options.setChallengeLength(config.challengeLength().getAsInt());\n-        }\n+        // apply config defaults\n+        this.rpId = config.relyingParty().id().orElse(null);\n+        this.rpName = config.relyingParty().name();\n+        this.origin = config.origin().orElse(null);\n+        this.challengeCookie = config.challengeCookieName();\n+        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n+        this.challengeLength = config.challengeLength().orElse(64);\n+        this.userPresenceRequired = config.userPresenceRequired().orElse(false);",
        "comment_created_at": "2024-11-04T14:44:50+00:00",
        "comment_author": "ynojima",
        "comment_body": "To automatically replace a password with a passkey when an end-user has already registered a password in their password manager, a new rule has been added to the WebAuthn spec.\r\nwhen `navigator.credentials.create` is called with `options.mediation` set to `conditional`, a passkey will be automatically created and the `UP` flag will be set to `false` for that passkey.\r\nApart from this special case, the `UP` flag is expected to always be `true`.\r\n\r\nRelated Apple WWDC video:\r\nhttps://developer.apple.com/videos/play/wwdc2024/10125/\r\nWebAuthn spec change:\r\nhttps://github.com/w3c/webauthn/pull/1951",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1824040277",
    "pr_number": 44105,
    "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnController.java",
    "created_at": "2024-10-31T08:05:39+00:00",
    "commented_code": "package io.quarkus.security.webauthn;\n \n-import java.util.function.Consumer;\n-\n-import org.jboss.logging.Logger;\n+import java.util.function.Supplier;\n \n import io.quarkus.arc.Arc;\n import io.quarkus.arc.InjectableContext.ContextState;\n import io.quarkus.arc.ManagedContext;\n-import io.quarkus.security.identity.IdentityProviderManager;\n-import io.quarkus.security.identity.SecurityIdentity;\n-import io.quarkus.vertx.http.runtime.security.HttpSecurityUtils;\n-import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.http.HttpHeaders;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.impl.attestation.AttestationException;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Endpoints for login/register/callback\n  */\n public class WebAuthnController {\n \n-    private static final Logger log = Logger.getLogger(WebAuthnController.class);\n-\n-    private String challengeUsernameCookie;\n-    private String challengeCookie;\n-\n     private WebAuthnSecurity security;\n \n-    private String origin;\n-\n-    private String domain;\n-\n-    private IdentityProviderManager identityProviderManager;\n-\n-    private WebAuthnAuthenticationMechanism authMech;\n-\n-    public WebAuthnController(WebAuthnSecurity security, WebAuthnRunTimeConfig config,\n-            IdentityProviderManager identityProviderManager,\n-            WebAuthnAuthenticationMechanism authMech) {\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n-        }\n+    public WebAuthnController(WebAuthnSecurity security) {\n         this.security = security;\n-        this.identityProviderManager = identityProviderManager;\n-        this.authMech = authMech;\n-        this.challengeCookie = config.challengeCookieName();\n-        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n-    }\n-\n-    private static boolean containsRequiredString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String) && !\"\".equals(s);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsOptionalString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return true;\n-            }\n-            if (!json.containsKey(key)) {\n-                return true;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsRequiredObject(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            JsonObject s = json.getJsonObject(key);\n-            return s != null;\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n     }\n \n     /**\n      * Endpoint for getting a register challenge\n      *\n      * @param ctx the current request\n      */\n-    public void register(RoutingContext ctx) {\n+    public void registerChallenge(RoutingContext ctx) {\n         try {\n             // might throw runtime exception if there's no json or is bad formed\n             final JsonObject webauthnRegister = ctx.getBodyAsJson();\n \n-            // the register object should match a Webauthn user.\n-            // A user has only a required field: name\n-            // And optional fields: displayName and icon\n-            if (webauthnRegister == null || !containsRequiredString(webauthnRegister, \"name\")) {\n-                ctx.fail(400, new IllegalArgumentException(\"missing 'name' field from request json\"));\n-            } else {\n-                // input basic validation is OK\n-\n-                ManagedContext requestContext = Arc.container().requestContext();\n-                requestContext.activate();\n-                ContextState contextState = requestContext.getState();\n-                security.getWebAuthn().createCredentialsOptions(webauthnRegister, createCredentialsOptions -> {\n-                    requestContext.destroy(contextState);\n-                    if (createCredentialsOptions.failed()) {\n-                        ctx.fail(createCredentialsOptions.cause());\n-                        return;\n-                    }\n-\n-                    final JsonObject credentialsOptions = createCredentialsOptions.result();\n+            String name = webauthnRegister.getString(\"name\");\n+            String displayName = webauthnRegister.getString(\"displayName\");\n+            withContext(() -> security.getRegisterChallenge(name, displayName, ctx))\n+                    .map(challenge -> security.toJsonString(challenge))\n+                    .subscribe().with(challenge -> ok(ctx, challenge), ctx::fail);\n \n-                    // save challenge to the session\n-                    authMech.getLoginManager().save(credentialsOptions.getString(\"challenge\"), ctx, challengeCookie, null,\n-                            ctx.request().isSSL());\n-                    authMech.getLoginManager().save(webauthnRegister.getString(\"name\"), ctx, challengeUsernameCookie, null,\n-                            ctx.request().isSSL());\n-\n-                    ok(ctx, credentialsOptions);\n-                });\n-            }\n         } catch (IllegalArgumentException e) {\n             ctx.fail(400, e);\n         } catch (RuntimeException e) {\n             ctx.fail(e);\n         }\n     }",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1824040277",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnController.java",
        "discussion_id": "1824040277",
        "commented_code": "@@ -1,187 +1,94 @@\n package io.quarkus.security.webauthn;\n \n-import java.util.function.Consumer;\n-\n-import org.jboss.logging.Logger;\n+import java.util.function.Supplier;\n \n import io.quarkus.arc.Arc;\n import io.quarkus.arc.InjectableContext.ContextState;\n import io.quarkus.arc.ManagedContext;\n-import io.quarkus.security.identity.IdentityProviderManager;\n-import io.quarkus.security.identity.SecurityIdentity;\n-import io.quarkus.vertx.http.runtime.security.HttpSecurityUtils;\n-import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.http.HttpHeaders;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.impl.attestation.AttestationException;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Endpoints for login/register/callback\n  */\n public class WebAuthnController {\n \n-    private static final Logger log = Logger.getLogger(WebAuthnController.class);\n-\n-    private String challengeUsernameCookie;\n-    private String challengeCookie;\n-\n     private WebAuthnSecurity security;\n \n-    private String origin;\n-\n-    private String domain;\n-\n-    private IdentityProviderManager identityProviderManager;\n-\n-    private WebAuthnAuthenticationMechanism authMech;\n-\n-    public WebAuthnController(WebAuthnSecurity security, WebAuthnRunTimeConfig config,\n-            IdentityProviderManager identityProviderManager,\n-            WebAuthnAuthenticationMechanism authMech) {\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n-        }\n+    public WebAuthnController(WebAuthnSecurity security) {\n         this.security = security;\n-        this.identityProviderManager = identityProviderManager;\n-        this.authMech = authMech;\n-        this.challengeCookie = config.challengeCookieName();\n-        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n-    }\n-\n-    private static boolean containsRequiredString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String) && !\"\".equals(s);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsOptionalString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return true;\n-            }\n-            if (!json.containsKey(key)) {\n-                return true;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsRequiredObject(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            JsonObject s = json.getJsonObject(key);\n-            return s != null;\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n     }\n \n     /**\n      * Endpoint for getting a register challenge\n      *\n      * @param ctx the current request\n      */\n-    public void register(RoutingContext ctx) {\n+    public void registerChallenge(RoutingContext ctx) {\n         try {\n             // might throw runtime exception if there's no json or is bad formed\n             final JsonObject webauthnRegister = ctx.getBodyAsJson();\n \n-            // the register object should match a Webauthn user.\n-            // A user has only a required field: name\n-            // And optional fields: displayName and icon\n-            if (webauthnRegister == null || !containsRequiredString(webauthnRegister, \"name\")) {\n-                ctx.fail(400, new IllegalArgumentException(\"missing 'name' field from request json\"));\n-            } else {\n-                // input basic validation is OK\n-\n-                ManagedContext requestContext = Arc.container().requestContext();\n-                requestContext.activate();\n-                ContextState contextState = requestContext.getState();\n-                security.getWebAuthn().createCredentialsOptions(webauthnRegister, createCredentialsOptions -> {\n-                    requestContext.destroy(contextState);\n-                    if (createCredentialsOptions.failed()) {\n-                        ctx.fail(createCredentialsOptions.cause());\n-                        return;\n-                    }\n-\n-                    final JsonObject credentialsOptions = createCredentialsOptions.result();\n+            String name = webauthnRegister.getString(\"name\");\n+            String displayName = webauthnRegister.getString(\"displayName\");\n+            withContext(() -> security.getRegisterChallenge(name, displayName, ctx))\n+                    .map(challenge -> security.toJsonString(challenge))\n+                    .subscribe().with(challenge -> ok(ctx, challenge), ctx::fail);\n \n-                    // save challenge to the session\n-                    authMech.getLoginManager().save(credentialsOptions.getString(\"challenge\"), ctx, challengeCookie, null,\n-                            ctx.request().isSSL());\n-                    authMech.getLoginManager().save(webauthnRegister.getString(\"name\"), ctx, challengeUsernameCookie, null,\n-                            ctx.request().isSSL());\n-\n-                    ok(ctx, credentialsOptions);\n-                });\n-            }\n         } catch (IllegalArgumentException e) {\n             ctx.fail(400, e);\n         } catch (RuntimeException e) {\n             ctx.fail(e);\n         }\n     }",
        "comment_created_at": "2024-10-31T08:05:39+00:00",
        "comment_author": "ynojima",
        "comment_body": "`registerChalleng` and `loginChallenge` endpoints may lead to the \"Testing for Account Enumeration\" issue as it returns information associated with an account by accepting the username as a parameter in response to unauthenticated requests.\r\nhttps://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/03-Identity_Management_Testing/04-Testing_for_Account_Enumeration_and_Guessable_User_Account\r\n\r\nSince account enumeration can also occur on self-service signup forms, some sites do not give it much importance and opt not to implement specific countermeasures. \r\nHowever, as Quarkus Security is a framework that must accommodate various use cases, implementing preventive measures might be necessary.\r\nOne approach is to return `allowedCredentials` and `excludeCredentials` only for requests that have already been authenticated using an alternative method, such as password.",
        "pr_file_module": null
      },
      {
        "comment_id": "1827784873",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnController.java",
        "discussion_id": "1824040277",
        "commented_code": "@@ -1,187 +1,94 @@\n package io.quarkus.security.webauthn;\n \n-import java.util.function.Consumer;\n-\n-import org.jboss.logging.Logger;\n+import java.util.function.Supplier;\n \n import io.quarkus.arc.Arc;\n import io.quarkus.arc.InjectableContext.ContextState;\n import io.quarkus.arc.ManagedContext;\n-import io.quarkus.security.identity.IdentityProviderManager;\n-import io.quarkus.security.identity.SecurityIdentity;\n-import io.quarkus.vertx.http.runtime.security.HttpSecurityUtils;\n-import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.http.HttpHeaders;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.impl.attestation.AttestationException;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Endpoints for login/register/callback\n  */\n public class WebAuthnController {\n \n-    private static final Logger log = Logger.getLogger(WebAuthnController.class);\n-\n-    private String challengeUsernameCookie;\n-    private String challengeCookie;\n-\n     private WebAuthnSecurity security;\n \n-    private String origin;\n-\n-    private String domain;\n-\n-    private IdentityProviderManager identityProviderManager;\n-\n-    private WebAuthnAuthenticationMechanism authMech;\n-\n-    public WebAuthnController(WebAuthnSecurity security, WebAuthnRunTimeConfig config,\n-            IdentityProviderManager identityProviderManager,\n-            WebAuthnAuthenticationMechanism authMech) {\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n-        }\n+    public WebAuthnController(WebAuthnSecurity security) {\n         this.security = security;\n-        this.identityProviderManager = identityProviderManager;\n-        this.authMech = authMech;\n-        this.challengeCookie = config.challengeCookieName();\n-        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n-    }\n-\n-    private static boolean containsRequiredString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String) && !\"\".equals(s);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsOptionalString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return true;\n-            }\n-            if (!json.containsKey(key)) {\n-                return true;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsRequiredObject(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            JsonObject s = json.getJsonObject(key);\n-            return s != null;\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n     }\n \n     /**\n      * Endpoint for getting a register challenge\n      *\n      * @param ctx the current request\n      */\n-    public void register(RoutingContext ctx) {\n+    public void registerChallenge(RoutingContext ctx) {\n         try {\n             // might throw runtime exception if there's no json or is bad formed\n             final JsonObject webauthnRegister = ctx.getBodyAsJson();\n \n-            // the register object should match a Webauthn user.\n-            // A user has only a required field: name\n-            // And optional fields: displayName and icon\n-            if (webauthnRegister == null || !containsRequiredString(webauthnRegister, \"name\")) {\n-                ctx.fail(400, new IllegalArgumentException(\"missing 'name' field from request json\"));\n-            } else {\n-                // input basic validation is OK\n-\n-                ManagedContext requestContext = Arc.container().requestContext();\n-                requestContext.activate();\n-                ContextState contextState = requestContext.getState();\n-                security.getWebAuthn().createCredentialsOptions(webauthnRegister, createCredentialsOptions -> {\n-                    requestContext.destroy(contextState);\n-                    if (createCredentialsOptions.failed()) {\n-                        ctx.fail(createCredentialsOptions.cause());\n-                        return;\n-                    }\n-\n-                    final JsonObject credentialsOptions = createCredentialsOptions.result();\n+            String name = webauthnRegister.getString(\"name\");\n+            String displayName = webauthnRegister.getString(\"displayName\");\n+            withContext(() -> security.getRegisterChallenge(name, displayName, ctx))\n+                    .map(challenge -> security.toJsonString(challenge))\n+                    .subscribe().with(challenge -> ok(ctx, challenge), ctx::fail);\n \n-                    // save challenge to the session\n-                    authMech.getLoginManager().save(credentialsOptions.getString(\"challenge\"), ctx, challengeCookie, null,\n-                            ctx.request().isSSL());\n-                    authMech.getLoginManager().save(webauthnRegister.getString(\"name\"), ctx, challengeUsernameCookie, null,\n-                            ctx.request().isSSL());\n-\n-                    ok(ctx, credentialsOptions);\n-                });\n-            }\n         } catch (IllegalArgumentException e) {\n             ctx.fail(400, e);\n         } catch (RuntimeException e) {\n             ctx.fail(e);\n         }\n     }",
        "comment_created_at": "2024-11-04T14:03:33+00:00",
        "comment_author": "FroMage",
        "comment_body": "Ah, I see.\r\n\r\nThe problem though is that I've never tested the use-case of allowing register/login when already logged in. So I'd say it's not supported, ATM.\r\n\r\nI suppose the best thing to do if I don't support this use-case is to remove them for now.\r\n\r\nI'll open an issue to support the already-logged-in use-case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1827820670",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnController.java",
        "discussion_id": "1824040277",
        "commented_code": "@@ -1,187 +1,94 @@\n package io.quarkus.security.webauthn;\n \n-import java.util.function.Consumer;\n-\n-import org.jboss.logging.Logger;\n+import java.util.function.Supplier;\n \n import io.quarkus.arc.Arc;\n import io.quarkus.arc.InjectableContext.ContextState;\n import io.quarkus.arc.ManagedContext;\n-import io.quarkus.security.identity.IdentityProviderManager;\n-import io.quarkus.security.identity.SecurityIdentity;\n-import io.quarkus.vertx.http.runtime.security.HttpSecurityUtils;\n-import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.http.HttpHeaders;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.impl.attestation.AttestationException;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Endpoints for login/register/callback\n  */\n public class WebAuthnController {\n \n-    private static final Logger log = Logger.getLogger(WebAuthnController.class);\n-\n-    private String challengeUsernameCookie;\n-    private String challengeCookie;\n-\n     private WebAuthnSecurity security;\n \n-    private String origin;\n-\n-    private String domain;\n-\n-    private IdentityProviderManager identityProviderManager;\n-\n-    private WebAuthnAuthenticationMechanism authMech;\n-\n-    public WebAuthnController(WebAuthnSecurity security, WebAuthnRunTimeConfig config,\n-            IdentityProviderManager identityProviderManager,\n-            WebAuthnAuthenticationMechanism authMech) {\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n-        }\n+    public WebAuthnController(WebAuthnSecurity security) {\n         this.security = security;\n-        this.identityProviderManager = identityProviderManager;\n-        this.authMech = authMech;\n-        this.challengeCookie = config.challengeCookieName();\n-        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n-    }\n-\n-    private static boolean containsRequiredString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String) && !\"\".equals(s);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsOptionalString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return true;\n-            }\n-            if (!json.containsKey(key)) {\n-                return true;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsRequiredObject(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            JsonObject s = json.getJsonObject(key);\n-            return s != null;\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n     }\n \n     /**\n      * Endpoint for getting a register challenge\n      *\n      * @param ctx the current request\n      */\n-    public void register(RoutingContext ctx) {\n+    public void registerChallenge(RoutingContext ctx) {\n         try {\n             // might throw runtime exception if there's no json or is bad formed\n             final JsonObject webauthnRegister = ctx.getBodyAsJson();\n \n-            // the register object should match a Webauthn user.\n-            // A user has only a required field: name\n-            // And optional fields: displayName and icon\n-            if (webauthnRegister == null || !containsRequiredString(webauthnRegister, \"name\")) {\n-                ctx.fail(400, new IllegalArgumentException(\"missing 'name' field from request json\"));\n-            } else {\n-                // input basic validation is OK\n-\n-                ManagedContext requestContext = Arc.container().requestContext();\n-                requestContext.activate();\n-                ContextState contextState = requestContext.getState();\n-                security.getWebAuthn().createCredentialsOptions(webauthnRegister, createCredentialsOptions -> {\n-                    requestContext.destroy(contextState);\n-                    if (createCredentialsOptions.failed()) {\n-                        ctx.fail(createCredentialsOptions.cause());\n-                        return;\n-                    }\n-\n-                    final JsonObject credentialsOptions = createCredentialsOptions.result();\n+            String name = webauthnRegister.getString(\"name\");\n+            String displayName = webauthnRegister.getString(\"displayName\");\n+            withContext(() -> security.getRegisterChallenge(name, displayName, ctx))\n+                    .map(challenge -> security.toJsonString(challenge))\n+                    .subscribe().with(challenge -> ok(ctx, challenge), ctx::fail);\n \n-                    // save challenge to the session\n-                    authMech.getLoginManager().save(credentialsOptions.getString(\"challenge\"), ctx, challengeCookie, null,\n-                            ctx.request().isSSL());\n-                    authMech.getLoginManager().save(webauthnRegister.getString(\"name\"), ctx, challengeUsernameCookie, null,\n-                            ctx.request().isSSL());\n-\n-                    ok(ctx, credentialsOptions);\n-                });\n-            }\n         } catch (IllegalArgumentException e) {\n             ctx.fail(400, e);\n         } catch (RuntimeException e) {\n             ctx.fail(e);\n         }\n     }",
        "comment_created_at": "2024-11-04T14:25:42+00:00",
        "comment_author": "FroMage",
        "comment_body": "Note that I've just tried it and suddenly, for login I'm getting prompted by my browser to select between several credentials for `localhost`, from previous tests, whereas when this was enabled, I could get my browser to only show the one that was actually in my server.\r\nI suppose this is mostly annoying for tests and `localhost` though.\r\n\r\nAnyway, I've filed https://github.com/quarkusio/quarkus/issues/44292 to re-enable this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2080212282",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnController.java",
        "discussion_id": "1824040277",
        "commented_code": "@@ -1,187 +1,94 @@\n package io.quarkus.security.webauthn;\n \n-import java.util.function.Consumer;\n-\n-import org.jboss.logging.Logger;\n+import java.util.function.Supplier;\n \n import io.quarkus.arc.Arc;\n import io.quarkus.arc.InjectableContext.ContextState;\n import io.quarkus.arc.ManagedContext;\n-import io.quarkus.security.identity.IdentityProviderManager;\n-import io.quarkus.security.identity.SecurityIdentity;\n-import io.quarkus.vertx.http.runtime.security.HttpSecurityUtils;\n-import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.http.HttpHeaders;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.impl.attestation.AttestationException;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Endpoints for login/register/callback\n  */\n public class WebAuthnController {\n \n-    private static final Logger log = Logger.getLogger(WebAuthnController.class);\n-\n-    private String challengeUsernameCookie;\n-    private String challengeCookie;\n-\n     private WebAuthnSecurity security;\n \n-    private String origin;\n-\n-    private String domain;\n-\n-    private IdentityProviderManager identityProviderManager;\n-\n-    private WebAuthnAuthenticationMechanism authMech;\n-\n-    public WebAuthnController(WebAuthnSecurity security, WebAuthnRunTimeConfig config,\n-            IdentityProviderManager identityProviderManager,\n-            WebAuthnAuthenticationMechanism authMech) {\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n-        }\n+    public WebAuthnController(WebAuthnSecurity security) {\n         this.security = security;\n-        this.identityProviderManager = identityProviderManager;\n-        this.authMech = authMech;\n-        this.challengeCookie = config.challengeCookieName();\n-        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n-    }\n-\n-    private static boolean containsRequiredString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String) && !\"\".equals(s);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsOptionalString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return true;\n-            }\n-            if (!json.containsKey(key)) {\n-                return true;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsRequiredObject(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            JsonObject s = json.getJsonObject(key);\n-            return s != null;\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n     }\n \n     /**\n      * Endpoint for getting a register challenge\n      *\n      * @param ctx the current request\n      */\n-    public void register(RoutingContext ctx) {\n+    public void registerChallenge(RoutingContext ctx) {\n         try {\n             // might throw runtime exception if there's no json or is bad formed\n             final JsonObject webauthnRegister = ctx.getBodyAsJson();\n \n-            // the register object should match a Webauthn user.\n-            // A user has only a required field: name\n-            // And optional fields: displayName and icon\n-            if (webauthnRegister == null || !containsRequiredString(webauthnRegister, \"name\")) {\n-                ctx.fail(400, new IllegalArgumentException(\"missing 'name' field from request json\"));\n-            } else {\n-                // input basic validation is OK\n-\n-                ManagedContext requestContext = Arc.container().requestContext();\n-                requestContext.activate();\n-                ContextState contextState = requestContext.getState();\n-                security.getWebAuthn().createCredentialsOptions(webauthnRegister, createCredentialsOptions -> {\n-                    requestContext.destroy(contextState);\n-                    if (createCredentialsOptions.failed()) {\n-                        ctx.fail(createCredentialsOptions.cause());\n-                        return;\n-                    }\n-\n-                    final JsonObject credentialsOptions = createCredentialsOptions.result();\n+            String name = webauthnRegister.getString(\"name\");\n+            String displayName = webauthnRegister.getString(\"displayName\");\n+            withContext(() -> security.getRegisterChallenge(name, displayName, ctx))\n+                    .map(challenge -> security.toJsonString(challenge))\n+                    .subscribe().with(challenge -> ok(ctx, challenge), ctx::fail);\n \n-                    // save challenge to the session\n-                    authMech.getLoginManager().save(credentialsOptions.getString(\"challenge\"), ctx, challengeCookie, null,\n-                            ctx.request().isSSL());\n-                    authMech.getLoginManager().save(webauthnRegister.getString(\"name\"), ctx, challengeUsernameCookie, null,\n-                            ctx.request().isSSL());\n-\n-                    ok(ctx, credentialsOptions);\n-                });\n-            }\n         } catch (IllegalArgumentException e) {\n             ctx.fail(400, e);\n         } catch (RuntimeException e) {\n             ctx.fail(e);\n         }\n     }",
        "comment_created_at": "2025-05-08T18:09:41+00:00",
        "comment_author": "rjsoph",
        "comment_body": "I allow only authenticated users (email/otp) to created passkey credentials and this is a problem for me as my users may be using different devices for the same email and each device has its own credential.  The issue comes when the Server revokes a credential for any number of reasons.  The clients will have no way to know their existing credential is revoked.... so they continue to try it and it is denied.  They then create a second credential which works, but the bad credential is still in their keychain and causes intermittent failures.\r\n\r\nthis could be addressed two different ways.... allowedCredentials would immediately tell them their credential is no longer valid or they could implement some logic to purge denied credentials and attempt to recreate them.  By far the most straight-forward way is allowedCredentials.... it is part of the standard and should be implemented somehow.  \r\n\r\nMaybe you generate pseudo-random fake allowedCredentials for usernames that are not recognized?",
        "pr_file_module": null
      },
      {
        "comment_id": "2081733283",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 44105,
        "pr_file": "extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnController.java",
        "discussion_id": "1824040277",
        "commented_code": "@@ -1,187 +1,94 @@\n package io.quarkus.security.webauthn;\n \n-import java.util.function.Consumer;\n-\n-import org.jboss.logging.Logger;\n+import java.util.function.Supplier;\n \n import io.quarkus.arc.Arc;\n import io.quarkus.arc.InjectableContext.ContextState;\n import io.quarkus.arc.ManagedContext;\n-import io.quarkus.security.identity.IdentityProviderManager;\n-import io.quarkus.security.identity.SecurityIdentity;\n-import io.quarkus.vertx.http.runtime.security.HttpSecurityUtils;\n-import io.quarkus.vertx.http.runtime.security.PersistentLoginManager.RestoreResult;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.http.HttpHeaders;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.ext.auth.webauthn.WebAuthnCredentials;\n-import io.vertx.ext.auth.webauthn.impl.attestation.AttestationException;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.impl.Origin;\n \n /**\n  * Endpoints for login/register/callback\n  */\n public class WebAuthnController {\n \n-    private static final Logger log = Logger.getLogger(WebAuthnController.class);\n-\n-    private String challengeUsernameCookie;\n-    private String challengeCookie;\n-\n     private WebAuthnSecurity security;\n \n-    private String origin;\n-\n-    private String domain;\n-\n-    private IdentityProviderManager identityProviderManager;\n-\n-    private WebAuthnAuthenticationMechanism authMech;\n-\n-    public WebAuthnController(WebAuthnSecurity security, WebAuthnRunTimeConfig config,\n-            IdentityProviderManager identityProviderManager,\n-            WebAuthnAuthenticationMechanism authMech) {\n-        origin = config.origin().orElse(null);\n-        if (origin != null) {\n-            Origin o = Origin.parse(origin);\n-            domain = o.host();\n-        }\n+    public WebAuthnController(WebAuthnSecurity security) {\n         this.security = security;\n-        this.identityProviderManager = identityProviderManager;\n-        this.authMech = authMech;\n-        this.challengeCookie = config.challengeCookieName();\n-        this.challengeUsernameCookie = config.challengeUsernameCookieName();\n-    }\n-\n-    private static boolean containsRequiredString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String) && !\"\".equals(s);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsOptionalString(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return true;\n-            }\n-            if (!json.containsKey(key)) {\n-                return true;\n-            }\n-            Object s = json.getValue(key);\n-            return (s instanceof String);\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n-    }\n-\n-    private static boolean containsRequiredObject(JsonObject json, String key) {\n-        try {\n-            if (json == null) {\n-                return false;\n-            }\n-            if (!json.containsKey(key)) {\n-                return false;\n-            }\n-            JsonObject s = json.getJsonObject(key);\n-            return s != null;\n-        } catch (ClassCastException e) {\n-            return false;\n-        }\n     }\n \n     /**\n      * Endpoint for getting a register challenge\n      *\n      * @param ctx the current request\n      */\n-    public void register(RoutingContext ctx) {\n+    public void registerChallenge(RoutingContext ctx) {\n         try {\n             // might throw runtime exception if there's no json or is bad formed\n             final JsonObject webauthnRegister = ctx.getBodyAsJson();\n \n-            // the register object should match a Webauthn user.\n-            // A user has only a required field: name\n-            // And optional fields: displayName and icon\n-            if (webauthnRegister == null || !containsRequiredString(webauthnRegister, \"name\")) {\n-                ctx.fail(400, new IllegalArgumentException(\"missing 'name' field from request json\"));\n-            } else {\n-                // input basic validation is OK\n-\n-                ManagedContext requestContext = Arc.container().requestContext();\n-                requestContext.activate();\n-                ContextState contextState = requestContext.getState();\n-                security.getWebAuthn().createCredentialsOptions(webauthnRegister, createCredentialsOptions -> {\n-                    requestContext.destroy(contextState);\n-                    if (createCredentialsOptions.failed()) {\n-                        ctx.fail(createCredentialsOptions.cause());\n-                        return;\n-                    }\n-\n-                    final JsonObject credentialsOptions = createCredentialsOptions.result();\n+            String name = webauthnRegister.getString(\"name\");\n+            String displayName = webauthnRegister.getString(\"displayName\");\n+            withContext(() -> security.getRegisterChallenge(name, displayName, ctx))\n+                    .map(challenge -> security.toJsonString(challenge))\n+                    .subscribe().with(challenge -> ok(ctx, challenge), ctx::fail);\n \n-                    // save challenge to the session\n-                    authMech.getLoginManager().save(credentialsOptions.getString(\"challenge\"), ctx, challengeCookie, null,\n-                            ctx.request().isSSL());\n-                    authMech.getLoginManager().save(webauthnRegister.getString(\"name\"), ctx, challengeUsernameCookie, null,\n-                            ctx.request().isSSL());\n-\n-                    ok(ctx, credentialsOptions);\n-                });\n-            }\n         } catch (IllegalArgumentException e) {\n             ctx.fail(400, e);\n         } catch (RuntimeException e) {\n             ctx.fail(e);\n         }\n     }",
        "comment_created_at": "2025-05-09T13:46:26+00:00",
        "comment_author": "ynojima",
        "comment_body": "Currently, allowedCredentials always returns an empty list regardless of the user's authentication status.\r\nhttps://github.com/quarkusio/quarkus/blob/main/extensions/security-webauthn/runtime/src/main/java/io/quarkus/security/webauthn/WebAuthnSecurity.java#L409-L424\r\n\r\nTo help synchronize the client-side passkey keychain with server-side credentials, the WebAuthn specification introduces the Signal API.\r\nhttps://w3c.github.io/webauthn/#sctn-signal-methods\r\nhttps://developer.chrome.com/docs/identity/webauthn-signal-api\r\n\r\nSupport is still a work in progressSafari, for example, doesnt support it yetbut we can expect improvements over time.\r\n",
        "pr_file_module": null
      }
    ]
  }
]