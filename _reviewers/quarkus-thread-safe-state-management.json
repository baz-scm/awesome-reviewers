[
  {
    "discussion_id": "2177538994",
    "pr_number": 48693,
    "pr_file": "independent-projects/qute/core/src/main/java/io/quarkus/qute/EngineImpl.java",
    "created_at": "2025-07-01T12:56:32+00:00",
    "commented_code": "reader);\n     }\n \n+    @Override\n+    public boolean hasTraceListeners() {\n+        return traceManager != null && traceManager.hasTraceListeners();\n+    }\n+\n+    @Override\n+    public TraceManager getTraceManager() {\n+        if (traceManager == null) {\n+            traceManager = new TraceManager();",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2177538994",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48693,
        "pr_file": "independent-projects/qute/core/src/main/java/io/quarkus/qute/EngineImpl.java",
        "discussion_id": "2177538994",
        "commented_code": "@@ -236,4 +238,30 @@ private Reader ensureBufferedReader(Reader reader) {\n                         reader);\n     }\n \n+    @Override\n+    public boolean hasTraceListeners() {\n+        return traceManager != null && traceManager.hasTraceListeners();\n+    }\n+\n+    @Override\n+    public TraceManager getTraceManager() {\n+        if (traceManager == null) {\n+            traceManager = new TraceManager();",
        "comment_created_at": "2025-07-01T12:56:32+00:00",
        "comment_author": "mkouba",
        "comment_body": "Why the lazy loading here? Also you would need use the `volatile` modifier + synchronize, or the `io.quarkus.qute.LazyValue` abstraction to make it thread-safe.",
        "pr_file_module": null
      },
      {
        "comment_id": "2177727928",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48693,
        "pr_file": "independent-projects/qute/core/src/main/java/io/quarkus/qute/EngineImpl.java",
        "discussion_id": "2177538994",
        "commented_code": "@@ -236,4 +238,30 @@ private Reader ensureBufferedReader(Reader reader) {\n                         reader);\n     }\n \n+    @Override\n+    public boolean hasTraceListeners() {\n+        return traceManager != null && traceManager.hasTraceListeners();\n+    }\n+\n+    @Override\n+    public TraceManager getTraceManager() {\n+        if (traceManager == null) {\n+            traceManager = new TraceManager();",
        "comment_created_at": "2025-07-01T14:16:53+00:00",
        "comment_author": "angelozerr",
        "comment_body": "I wanted to create a trace manager if nobody regsiters a listener, but I agree with you, I can create it every time and set it as final, since it exists hasTraceListeners.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177547007",
    "pr_number": 48693,
    "pr_file": "independent-projects/qute/core/src/main/java/io/quarkus/qute/TraceManager.java",
    "created_at": "2025-07-01T13:00:24+00:00",
    "commented_code": "+package io.quarkus.qute;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.quarkus.qute.trace.ResolveEvent;\n+import io.quarkus.qute.trace.TemplateEvent;\n+import io.quarkus.qute.trace.TraceListener;\n+\n+/**\n+ * Manager that holds and dispatches events to registered\n+ * {@link TraceListener}s.\n+ * <p>\n+ * Each {@link Engine} instance has its own {@code TraceManager} to coordinate\n+ * tracing callbacks during template rendering.\n+ */\n+public class TraceManager {\n+\n+    private List<TraceListener> listeners;",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2177547007",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48693,
        "pr_file": "independent-projects/qute/core/src/main/java/io/quarkus/qute/TraceManager.java",
        "discussion_id": "2177547007",
        "commented_code": "@@ -0,0 +1,110 @@\n+package io.quarkus.qute;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.quarkus.qute.trace.ResolveEvent;\n+import io.quarkus.qute.trace.TemplateEvent;\n+import io.quarkus.qute.trace.TraceListener;\n+\n+/**\n+ * Manager that holds and dispatches events to registered\n+ * {@link TraceListener}s.\n+ * <p>\n+ * Each {@link Engine} instance has its own {@code TraceManager} to coordinate\n+ * tracing callbacks during template rendering.\n+ */\n+public class TraceManager {\n+\n+    private List<TraceListener> listeners;",
        "comment_created_at": "2025-07-01T13:00:24+00:00",
        "comment_author": "mkouba",
        "comment_body": "You should use a thread-safe `List` variant (such as `CopyOnWriteArrayList`). And ideally, the reference should be `final`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2177713848",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48693,
        "pr_file": "independent-projects/qute/core/src/main/java/io/quarkus/qute/TraceManager.java",
        "discussion_id": "2177547007",
        "commented_code": "@@ -0,0 +1,110 @@\n+package io.quarkus.qute;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import io.quarkus.qute.trace.ResolveEvent;\n+import io.quarkus.qute.trace.TemplateEvent;\n+import io.quarkus.qute.trace.TraceListener;\n+\n+/**\n+ * Manager that holds and dispatches events to registered\n+ * {@link TraceListener}s.\n+ * <p>\n+ * Each {@link Engine} instance has its own {@code TraceManager} to coordinate\n+ * tracing callbacks during template rendering.\n+ */\n+public class TraceManager {\n+\n+    private List<TraceListener> listeners;",
        "comment_created_at": "2025-07-01T14:12:23+00:00",
        "comment_author": "angelozerr",
        "comment_body": "Indeed it is very basic, I need to improve that but for the moment I have not seen some trouble.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2156675417",
    "pr_number": 48406,
    "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
    "created_at": "2025-06-19T10:27:28+00:00",
    "commented_code": "* @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2156675417",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156675417",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;",
        "comment_created_at": "2025-06-19T10:27:28+00:00",
        "comment_author": "mkouba",
        "comment_body": "Maybe a stupid question but what happens if there are three threads where each attempts to set a specific flag at the same time? The last one wins?",
        "pr_file_module": null
      },
      {
        "comment_id": "2156685869",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156675417",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;",
        "comment_created_at": "2025-06-19T10:33:15+00:00",
        "comment_author": "franz1981",
        "comment_body": "When multiple threads attempt to set the same flag concurrently, only one will succeed in setting it (the first to win the compare-and-exchange). The others will see that the flag is already set and return false. So, the \"first\" thread wins, and subsequent attempts do not overwrite or reset the flag. This ensures each flag is set only once, even under heavy concurrency.\r\n\r\nThis is since the original code was returning `true` only for the thread which win the race to modify a specific flag's value from `FALSE` to `TRUE`.\r\n\r\nHere, the retry can happen too because of threads which modify a different flag still contained in `state` - but the logic is preserved by checking the value in the right bit (via `(state & bitMask) != 0` i.e. `isSet(state, bitMask)`).\r\nUsually this code is not highly contended but requires to have an atomic behaviour, so the memory saving come with a trade-off of worse contention behaviour (since `state` is shared by all the flags which contains).",
        "pr_file_module": null
      },
      {
        "comment_id": "2156691836",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156675417",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;",
        "comment_created_at": "2025-06-19T10:37:03+00:00",
        "comment_author": "mkouba",
        "comment_body": "> When multiple threads attempt to set the same flag concurrently, ...\r\n\r\nSorry, I mean each thread attempts to set a different flag, but modify the same state...\r\n\r\n> Usually this code is not highly contended but requires to have an atomic behaviour, so the memory saving come with a trade-off of worse contention behaviour (since state is shared by all the flags which contains).\r\n\r\nI see",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2156812179",
    "pr_number": 48406,
    "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
    "created_at": "2025-06-19T11:48:26+00:00",
    "commented_code": "* @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2156812179",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156812179",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {",
        "comment_created_at": "2025-06-19T11:48:26+00:00",
        "comment_author": "Pankraz76",
        "comment_body": "is this recursion?",
        "pr_file_module": null
      },
      {
        "comment_id": "2156830603",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156812179",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {",
        "comment_created_at": "2025-06-19T11:53:54+00:00",
        "comment_author": "geoand",
        "comment_body": "\u039d\u03bf",
        "pr_file_module": null
      },
      {
        "comment_id": "2156856132",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156812179",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {",
        "comment_created_at": "2025-06-19T12:07:08+00:00",
        "comment_author": "Pankraz76",
        "comment_body": "what is it then? never seen before.\r\nassuming the block is executed only once then.",
        "pr_file_module": null
      },
      {
        "comment_id": "2156907382",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156812179",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {",
        "comment_created_at": "2025-06-19T12:31:39+00:00",
        "comment_author": "franz1981",
        "comment_body": "It's a fairly common pattern in concurrent code: see https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java#L1508; it's the same of a while (true); I know is not very readable but concurrent code is not really....ehm great to read, let's say .-.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2156818425",
    "pr_number": 48406,
    "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
    "created_at": "2025-06-19T11:50:06+00:00",
    "commented_code": "* @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {\n+                if ((state & bitMask) != 0) {\n+                    return false;\n+                }\n+                final byte newState = (byte) (state | bitMask);\n+                state = (byte) STATE_UPDATER.compareAndExchange(this, state, newState);\n+                if (state == newState) {",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2156818425",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156818425",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {\n+                if ((state & bitMask) != 0) {\n+                    return false;\n+                }\n+                final byte newState = (byte) (state | bitMask);\n+                state = (byte) STATE_UPDATER.compareAndExchange(this, state, newState);\n+                if (state == newState) {",
        "comment_created_at": "2025-06-19T11:50:06+00:00",
        "comment_author": "Pankraz76",
        "comment_body": "```suggestion\r\n                if (STATE_UPDATER.compareAndExchange(this, state, newState) == newState) {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2156911959",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48406,
        "pr_file": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/CurrentManagedContext.java",
        "discussion_id": "2156818425",
        "commented_code": "@@ -280,23 +272,39 @@ public Map<InjectableBean<?>, Object> getContextualInstances() {\n          * @return {@code true} if the state was successfully invalidated, {@code false} otherwise\n          */\n         boolean invalidate() {\n-            // Atomically sets the value just like AtomicBoolean.compareAndSet(boolean, boolean)\n-            return IS_VALID.compareAndSet(this, VALID, INVALID);\n+            return set(INVALID_MASK);\n         }\n \n         @Override\n         public boolean isValid() {\n-            return isValid == VALID;\n+            return isNotSet(INVALID_MASK);\n         }\n \n         boolean shouldFireInitializedEvent() {\n-            return INITIALIZED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(INITIALIZED_FIRED_MASK);\n         }\n \n         boolean shouldFireBeforeDestroyedEvent() {\n-            return BEFORE_DESTROYED_FIRED.compareAndSet(this, FALSE, TRUE);\n+            return set(BEFORE_DESTROYED_FIRED_MASK);\n         }\n \n-    }\n+        private boolean isNotSet(byte bitMask) {\n+            return (state & bitMask) == 0;\n+        }\n+\n+        private boolean set(byte bitMask) {\n+            byte state = this.state;\n+            for (;;) {\n+                if ((state & bitMask) != 0) {\n+                    return false;\n+                }\n+                final byte newState = (byte) (state | bitMask);\n+                state = (byte) STATE_UPDATER.compareAndExchange(this, state, newState);\n+                if (state == newState) {",
        "comment_created_at": "2025-06-19T12:33:40+00:00",
        "comment_author": "franz1981",
        "comment_body": "As @geoand said; we want to reuse snapshot(s) if the read state, to avoid keep on reading it - unless necessary.\r\nIf you're curious about it, it's related the semantic of volatile operations: every volatile load *has* to load the value, which is not free from a CPU architecture pov. (can be cheap, but not free).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1808461327",
    "pr_number": 37303,
    "pr_file": "extensions/vertx-http/deployment/src/main/java/io/quarkus/devui/deployment/menu/AuthProcessor.java",
    "created_at": "2024-10-21T09:56:30+00:00",
    "commented_code": "+package io.quarkus.devui.deployment.menu;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jakarta.inject.Singleton;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import io.quarkus.arc.deployment.SyntheticBeanBuildItem;\n+import io.quarkus.deployment.IsDevelopment;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+import io.quarkus.deployment.builditem.DevServicesLauncherConfigResultBuildItem;\n+import io.quarkus.dev.console.DevConsoleManager;\n+import io.quarkus.devui.deployment.InternalPageBuildItem;\n+import io.quarkus.devui.runtime.config.*;\n+import io.quarkus.devui.spi.JsonRPCProvidersBuildItem;\n+import io.quarkus.devui.spi.page.Page;\n+import io.smallrye.config.SmallRyeConfig;\n+\n+/**\n+ * This creates Extensions Page\n+ */\n+public class AuthProcessor {\n+\n+    private static final String NAME_SPACE = \"devui-auth\";\n+    private static List<ConfigDescriptionBuildItem> configDescriptionBuildItems;\n+    private static Optional<DevServicesLauncherConfigResultBuildItem> devServicesLauncherConfig;\n+    private static AuthDevUIRecorder recorder;\n+    private static SmallRyeConfig current;\n+\n+    @BuildStep(onlyIf = IsDevelopment.class)\n+    InternalPageBuildItem createAuthPages() {\n+\n+        InternalPageBuildItem configurationPages = new InternalPageBuildItem(\"Auth\", 21);\n+\n+        configurationPages.addPage(Page.webComponentPageBuilder()\n+                .namespace(NAME_SPACE)\n+                .title(\"Permissions\")\n+                .icon(\"font-awesome-solid:shield\")\n+                .componentLink(\"qwc-auth.js\"));\n+\n+        return configurationPages;\n+    }\n+\n+    private Optional<ConfigDescriptionBuildItem> findByName(String propertyKey,\n+            List<ConfigDescriptionBuildItem> configDescriptionBuildItems) {\n+        Pattern pattern = PermissionDescription.getPattern(propertyKey);\n+\n+        for (ConfigDescriptionBuildItem configDescriptionBuildItem : configDescriptionBuildItems) {\n+            boolean matches = configDescriptionBuildItem.getPropertyName().matches(pattern.pattern());\n+            if (matches) {\n+                return Optional.of(configDescriptionBuildItem);\n+            }\n+\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @BuildStep(onlyIf = IsDevelopment.class)\n+    @Record(ExecutionTime.RUNTIME_INIT)\n+    void registerConfigs(List<ConfigDescriptionBuildItem> configDescriptionBuildItems,\n+            Optional<DevServicesLauncherConfigResultBuildItem> devServicesLauncherConfig,\n+            AuthDevUIRecorder recorder) {\n+\n+        AuthProcessor.configDescriptionBuildItems = configDescriptionBuildItems;\n+        AuthProcessor.devServicesLauncherConfig = devServicesLauncherConfig;\n+        AuthProcessor.recorder = recorder;\n+        AuthProcessor.current = (SmallRyeConfig) ConfigProvider.getConfig();\n+\n+        register(configDescriptionBuildItems, devServicesLauncherConfig, recorder);\n+    }\n+\n+    private void register(List<ConfigDescriptionBuildItem> configDescriptionBuildItems,\n+            Optional<DevServicesLauncherConfigResultBuildItem> devServicesLauncherConfig, AuthDevUIRecorder recorder) {\n+        List<PermissionDescription> configDescriptions = new ArrayList<>();\n+\n+        for (ConfigDescriptionBuildItem configDescriptionBuildItem : configDescriptionBuildItems) {\n+            if (configDescriptionBuildItem.getPropertyName().contains(\"permission.new123\"))\n+                System.out.println(\"configDescriptionBuildItem = \" + configDescriptionBuildItem.getPropertyName() + \" default: \"\n+                        + configDescriptionBuildItem.getDefaultValue());\n+        }\n+\n+        for (ConfigSource configSource : current.getConfigSources()) {\n+\n+            for (String propertyKey : configSource.getPropertyNames()) {\n+                var isPermission = propertyKey.startsWith(\"quarkus.http.auth.permission\");\n+                var isPolicy = propertyKey.startsWith(\"quarkus.http.auth.policy\");\n+\n+                if (!(isPermission || isPolicy))\n+                    continue;\n+\n+                Optional<ConfigDescriptionBuildItem> optionalConfigDescriptionBuildItem = this.findByName(propertyKey,\n+                        configDescriptionBuildItems);\n+\n+                if (optionalConfigDescriptionBuildItem.isPresent()) {\n+                    var item = optionalConfigDescriptionBuildItem.get();\n+                    PermissionDescription permissionDescription = new PermissionDescription(\n+                            propertyKey,\n+                            configSource.getValue(propertyKey),\n+                            new ConfigDescription(item.getPropertyName(),\n+                                    formatJavadoc(cleanUpAsciiDocIfNecessary(item.getDocs())),\n+                                    item.getDefaultValue(),\n+                                    isSetByDevServices(devServicesLauncherConfig, item.getPropertyName()),\n+                                    item.getValueTypeName(),\n+                                    item.getAllowedValues(),\n+                                    item.getConfigPhase().name()));\n+                    configDescriptions.add(permissionDescription);\n+                }\n+            }\n+        }\n+\n+        Map<AuthFieldType.AuthConfigType, List<PermissionSet>> result = configDescriptions.stream()\n+                .collect(Collectors.groupingBy(\n+                        PermissionDescription::getConfigType,\n+                        Collectors.collectingAndThen(\n+                                Collectors.groupingBy(PermissionDescription::getConfigId,\n+                                        Collectors.mapping(d -> d, Collectors.toList())),\n+                                configMap -> configMap.values().stream()\n+                                        .map(PermissionSet::new)\n+                                        .sorted()\n+                                        .collect(Collectors.toList()))));\n+\n+        List<PermissionSet> permissionSets = result.get(AuthFieldType.AuthConfigType.PERMISSION);\n+        List<PermissionSet> policyGroups = result.get(AuthFieldType.AuthConfigType.POLICY);\n+\n+        recorder.registerPermissionGroups(permissionSets, policyGroups);\n+    }\n+\n+    @BuildStep(onlyIf = IsDevelopment.class)\n+    @Record(ExecutionTime.RUNTIME_INIT)\n+    void registerJsonRpcService(\n+            List<ConfigDescriptionBuildItem> configDescriptionBuildItems,\n+            BuildProducer<JsonRPCProvidersBuildItem> jsonRPCProvidersProducer,\n+            BuildProducer<SyntheticBeanBuildItem> syntheticBeanProducer,\n+            AuthDevUIRecorder recorder) {\n+\n+        DevConsoleManager.register(\"update-permission-set\", map -> {\n+            updateConfig(map);\n+            register(AuthProcessor.configDescriptionBuildItems, AuthProcessor.devServicesLauncherConfig,\n+                    AuthProcessor.recorder);",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "1808461327",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 37303,
        "pr_file": "extensions/vertx-http/deployment/src/main/java/io/quarkus/devui/deployment/menu/AuthProcessor.java",
        "discussion_id": "1808461327",
        "commented_code": "@@ -0,0 +1,274 @@\n+package io.quarkus.devui.deployment.menu;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jakarta.inject.Singleton;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import io.quarkus.arc.deployment.SyntheticBeanBuildItem;\n+import io.quarkus.deployment.IsDevelopment;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+import io.quarkus.deployment.builditem.DevServicesLauncherConfigResultBuildItem;\n+import io.quarkus.dev.console.DevConsoleManager;\n+import io.quarkus.devui.deployment.InternalPageBuildItem;\n+import io.quarkus.devui.runtime.config.*;\n+import io.quarkus.devui.spi.JsonRPCProvidersBuildItem;\n+import io.quarkus.devui.spi.page.Page;\n+import io.smallrye.config.SmallRyeConfig;\n+\n+/**\n+ * This creates Extensions Page\n+ */\n+public class AuthProcessor {\n+\n+    private static final String NAME_SPACE = \"devui-auth\";\n+    private static List<ConfigDescriptionBuildItem> configDescriptionBuildItems;\n+    private static Optional<DevServicesLauncherConfigResultBuildItem> devServicesLauncherConfig;\n+    private static AuthDevUIRecorder recorder;\n+    private static SmallRyeConfig current;\n+\n+    @BuildStep(onlyIf = IsDevelopment.class)\n+    InternalPageBuildItem createAuthPages() {\n+\n+        InternalPageBuildItem configurationPages = new InternalPageBuildItem(\"Auth\", 21);\n+\n+        configurationPages.addPage(Page.webComponentPageBuilder()\n+                .namespace(NAME_SPACE)\n+                .title(\"Permissions\")\n+                .icon(\"font-awesome-solid:shield\")\n+                .componentLink(\"qwc-auth.js\"));\n+\n+        return configurationPages;\n+    }\n+\n+    private Optional<ConfigDescriptionBuildItem> findByName(String propertyKey,\n+            List<ConfigDescriptionBuildItem> configDescriptionBuildItems) {\n+        Pattern pattern = PermissionDescription.getPattern(propertyKey);\n+\n+        for (ConfigDescriptionBuildItem configDescriptionBuildItem : configDescriptionBuildItems) {\n+            boolean matches = configDescriptionBuildItem.getPropertyName().matches(pattern.pattern());\n+            if (matches) {\n+                return Optional.of(configDescriptionBuildItem);\n+            }\n+\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @BuildStep(onlyIf = IsDevelopment.class)\n+    @Record(ExecutionTime.RUNTIME_INIT)\n+    void registerConfigs(List<ConfigDescriptionBuildItem> configDescriptionBuildItems,\n+            Optional<DevServicesLauncherConfigResultBuildItem> devServicesLauncherConfig,\n+            AuthDevUIRecorder recorder) {\n+\n+        AuthProcessor.configDescriptionBuildItems = configDescriptionBuildItems;\n+        AuthProcessor.devServicesLauncherConfig = devServicesLauncherConfig;\n+        AuthProcessor.recorder = recorder;\n+        AuthProcessor.current = (SmallRyeConfig) ConfigProvider.getConfig();\n+\n+        register(configDescriptionBuildItems, devServicesLauncherConfig, recorder);\n+    }\n+\n+    private void register(List<ConfigDescriptionBuildItem> configDescriptionBuildItems,\n+            Optional<DevServicesLauncherConfigResultBuildItem> devServicesLauncherConfig, AuthDevUIRecorder recorder) {\n+        List<PermissionDescription> configDescriptions = new ArrayList<>();\n+\n+        for (ConfigDescriptionBuildItem configDescriptionBuildItem : configDescriptionBuildItems) {\n+            if (configDescriptionBuildItem.getPropertyName().contains(\"permission.new123\"))\n+                System.out.println(\"configDescriptionBuildItem = \" + configDescriptionBuildItem.getPropertyName() + \" default: \"\n+                        + configDescriptionBuildItem.getDefaultValue());\n+        }\n+\n+        for (ConfigSource configSource : current.getConfigSources()) {\n+\n+            for (String propertyKey : configSource.getPropertyNames()) {\n+                var isPermission = propertyKey.startsWith(\"quarkus.http.auth.permission\");\n+                var isPolicy = propertyKey.startsWith(\"quarkus.http.auth.policy\");\n+\n+                if (!(isPermission || isPolicy))\n+                    continue;\n+\n+                Optional<ConfigDescriptionBuildItem> optionalConfigDescriptionBuildItem = this.findByName(propertyKey,\n+                        configDescriptionBuildItems);\n+\n+                if (optionalConfigDescriptionBuildItem.isPresent()) {\n+                    var item = optionalConfigDescriptionBuildItem.get();\n+                    PermissionDescription permissionDescription = new PermissionDescription(\n+                            propertyKey,\n+                            configSource.getValue(propertyKey),\n+                            new ConfigDescription(item.getPropertyName(),\n+                                    formatJavadoc(cleanUpAsciiDocIfNecessary(item.getDocs())),\n+                                    item.getDefaultValue(),\n+                                    isSetByDevServices(devServicesLauncherConfig, item.getPropertyName()),\n+                                    item.getValueTypeName(),\n+                                    item.getAllowedValues(),\n+                                    item.getConfigPhase().name()));\n+                    configDescriptions.add(permissionDescription);\n+                }\n+            }\n+        }\n+\n+        Map<AuthFieldType.AuthConfigType, List<PermissionSet>> result = configDescriptions.stream()\n+                .collect(Collectors.groupingBy(\n+                        PermissionDescription::getConfigType,\n+                        Collectors.collectingAndThen(\n+                                Collectors.groupingBy(PermissionDescription::getConfigId,\n+                                        Collectors.mapping(d -> d, Collectors.toList())),\n+                                configMap -> configMap.values().stream()\n+                                        .map(PermissionSet::new)\n+                                        .sorted()\n+                                        .collect(Collectors.toList()))));\n+\n+        List<PermissionSet> permissionSets = result.get(AuthFieldType.AuthConfigType.PERMISSION);\n+        List<PermissionSet> policyGroups = result.get(AuthFieldType.AuthConfigType.POLICY);\n+\n+        recorder.registerPermissionGroups(permissionSets, policyGroups);\n+    }\n+\n+    @BuildStep(onlyIf = IsDevelopment.class)\n+    @Record(ExecutionTime.RUNTIME_INIT)\n+    void registerJsonRpcService(\n+            List<ConfigDescriptionBuildItem> configDescriptionBuildItems,\n+            BuildProducer<JsonRPCProvidersBuildItem> jsonRPCProvidersProducer,\n+            BuildProducer<SyntheticBeanBuildItem> syntheticBeanProducer,\n+            AuthDevUIRecorder recorder) {\n+\n+        DevConsoleManager.register(\"update-permission-set\", map -> {\n+            updateConfig(map);\n+            register(AuthProcessor.configDescriptionBuildItems, AuthProcessor.devServicesLauncherConfig,\n+                    AuthProcessor.recorder);",
        "comment_created_at": "2024-10-21T09:56:30+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "you have recorder as a build step parameter and but you pass down the one stored on processor; these build steps can run in parallel. there can be race, please don't store the recorder on the processor",
        "pr_file_module": null
      }
    ]
  }
]