[
  {
    "discussion_id": "2072682597",
    "pr_number": 47675,
    "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
    "created_at": "2025-05-04T18:45:58+00:00",
    "commented_code": "* Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2072682597",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-04T18:45:58+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "How is this new token can be obtained ? The current one is bound to the connection at the upgrade time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072707465",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-04T20:45:17+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "How did you obtained original token used at the upgrade time? Obtain it the same way. You pass it in a DTO that contains message and optionally metadata. You can pass it into the endpoint or hide that in the decoder (but I prefer the endpoint, hence the example). Tests speak for itself",
        "pr_file_module": null
      },
      {
        "comment_id": "2072708831",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-04T20:52:42+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "Can front end client use refresh token stored in a session storage and obtain access token?",
        "pr_file_module": null
      },
      {
        "comment_id": "2073353332",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T12:31:45+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik \r\n\r\n>How did you obtained original token used at the upgrade time?\r\n\r\nI'm assuming SPA used the authorization code flow\r\n\r\n>Obtain it the same way.\r\n\r\nI don't think it works the same way for the token refresh.\r\n\r\nSo the proposal is for SPA to run a background task and check the current access token expiry time and refresh ?\r\nWhat I don't know if OIDC scripts allow SPA access the access token expiry time - as some of these tokens are binary tokens.\r\nThe other thing I don't know, can one do HTTP calls while working with WS API ?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2073444552",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T13:24:43+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> I'm assuming SPA used the authorization code flow\r\n\r\nI don't know how to make WS work with authorization code flow on the Backend. I have looked into it before and I also raised it in the linked issue comments. Even if authorization code flow started before the WebSocket was opened, you still don't have a have to link session cookie with opened WebSocket. Anyway, I opened this PR for a bearer token authentication only.\r\n\r\n> Obtain it the same way.\r\n> I don't think it works the same way for the token refresh.\r\n\r\n[1]\r\nI need more information to understand why not, I can trust you, but then there is no point continue because this PR just won't do. No point wasting time on a review. My thinking was that:\r\n\r\n- For client credentials (like server to server websocket communication) you can use client id and secret to obtain token in the background.\r\n- For implicit grant flow (if there is still someone using it) SPA can send in the background and gets a token based on valid browser session\r\n- For code flow on the SPA side, you store session tokens in the browser session store, you keep refreshing token and you have direct access to the access token. I have personal experience with it, because I was maintaining Angular SPA in production for 2 years that communicated with multiple backends and we wrote interceptor to generated front-end clients that always set authorization header for tokens retrieved from the browser storage. we used https://github.com/manfredsteyer/angular-oauth2-oidc, it was hell to get it right, but then it worked\r\n\r\n> So the proposal is for SPA to run a background task and check the current access token expiry time and refresh ?\r\n\r\nproposal is for SPA to get access token itself in a ways described  right above, please see `[1]` of this comment.\r\n\r\n> What I don't know if OIDC scripts allow SPA access the access token expiry time - as some of these tokens are binary tokens.\r\n\r\nI have no idea about that, but I remember that in our SPA we got tokens from Keycloak and we knew token expiration time (I want to say 30 minutes for access token and 18 hours for the refresh token, but honestly, I am not sure if I am not imaging it). It didn't change for us, maybe they can just check it out before? E.g. they don't exactly need to automate it, just add timed task.\r\n\r\n> The other thing I don't know, can one do HTTP calls while working with WS API ?\r\n\r\nTypescript has multithreading, I think having background tasks like updating feeds on your SPA is a standard (e.g. on the newspage you have breaking news and that can by done by polling and HTTP requests). But I do speak about frameworks like Angular and React, no idea what you do with vanilla JS or node.js etc.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2073608910",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T14:52:05+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik Look, I simply ask questions to have a better understanding,  so please,  let's avoid looking at these questions as the signs PR won't make it, we both need to understand how it works end to end.\r\n\r\nSo, my point is, we need to have a clear picture how it can work with an actual SPA which uses WS API because,  as discussed before,  users won't be able to use WS Java client there.\r\n\r\nBefore SPA could send bearer token, it must've used authorization code flow, code flow can not be used later.\r\n\r\nSo the question is, is the need for the token refresh can be determined after refresh, an if  making an HTTP call to refresh token is practically possible after HTTP upgrade?\r\n\r\nWe can't claim we support this option without knowing for sure if it can actually be achieved practically. \r\n\r\nWould you like to give a sample SPA a try, for example the one using Keycloak.js, with SPA logging in users, sending the access token to HTTP upgrade,  and later refreshing it after the upgrade?",
        "pr_file_module": null
      },
      {
        "comment_id": "2073623484",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T14:59:59+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik the authorization code flow only happens before the upgrade, entirely within SPA, fot this SPA be able to forward the code flow token as bearer access token to Quarkus. \r\nAfter the upgrade,  it can only be token refresh using refresh token grant,  where SPA makes HTTP call to  the OIDC token endpoint,  sending client id, refresh token. Can it work after the upgrade ? And in order to determine if this refresh should be done, SPA needs access to the code flow access token expiry time",
        "pr_file_module": null
      },
      {
        "comment_id": "2073634666",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T15:07:01+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "So, I see you saying token expiry time is available to SPA.\r\nSo the main question,  can the token refresh call be successful after the upgrade",
        "pr_file_module": null
      },
      {
        "comment_id": "2073726976",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T16:01:58+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> if making an HTTP call to refresh token is practically possible after HTTP upgrade?\r\n\r\nI already mentioned it is possible, SPA makes hundreds of HTTP calls while lazily loading content. I wrote and maintained such application. For example, this library silently refreshes token at 75 % of the token lifetime https://manfredsteyer.github.io/angular-oauth2-oidc/docs/additional-documentation/token-refresh.html. \r\n\r\n> We can't claim we support this option without knowing for sure if it can actually be achieved practically.\r\n> So the main question, can the token refresh call be successful after the upgrade\r\n\r\nIn my eyes this is the standard way how SPA works when it needs to talk to multiple backends, when you don't go thought one gateway that requests individual requests on your behalf (hundreds). Just imagine how impractical would it be to have communicate with 5 Quarkus independent backends, all running as a `web-app` application type, wouldn't you have to login 5 times?\r\n\r\nIf you are still doubts, I will make a time by the end of this week and write example application for you. I don't think we will show it in documentation or in quickstarts to users because it's like impractical so show FE sides, it's verbose and users know how they should write front end. FE FW keeps evolving and I don't think we should keep some old version for a standard stuff we can't automatically test.",
        "pr_file_module": null
      },
      {
        "comment_id": "2073743610",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T16:10:09+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "I was looking how it works for REACT and found this TS (more low-level) client that has also visualized how it works https://github.com/authts/oidc-client-ts/blob/main/docs/protocols/silent-refresh-token-in-iframe-flow.md",
        "pr_file_module": null
      },
      {
        "comment_id": "2073748336",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T16:13:10+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> Would you like to give a sample SPA a try, for example the one using Keycloak.js, with SPA logging in users, sending the access token to HTTP upgrade, and later refreshing it after the upgrade?\r\n\r\nSorry, didn't mention this question until now. I think it's unnecessary, front end developers that use these libraries know how to obtain access token or they can figure it from their library documentation. I don't know `Keycloak.js`, but I am capable to write such an example if required, probably using differently library.",
        "pr_file_module": null
      },
      {
        "comment_id": "2073757530",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T16:19:41+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik Sure, SPA can do token refreshes \r\n\r\nCan it really work though such that the script that works with the current WS connection can accept a refreshed token and forward this token to Quarkus ?\r\n\r\nIf we could confirm it then it would be great,  IMHO there is no rush with the fix being merged",
        "pr_file_module": null
      },
      {
        "comment_id": "2073763857",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T16:24:08+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "I'll write an example by the end of the week.",
        "pr_file_module": null
      },
      {
        "comment_id": "2073771158",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T16:28:31+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> If we could confirm it then it would be great, IMHO there is no rush with the fix being merged\r\n\r\nI have more plans for WS Next and while I didn't mention it (no reason to mention it), what I have added to this PR will allow me to easily fix https://github.com/quarkiverse/quarkus-langchain4j/issues/1418 in the follow up. I don't want to keep this PR on hold, but let's wait until I have the example front end application. I'll inform you when I am done.",
        "pr_file_module": null
      },
      {
        "comment_id": "2073891357",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T17:40:38+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik Thanks, IMHO it will be worth it because this sample SPA can be used as a base for Step-Up authentication demos.\r\n\r\nWe can also add some simple example, similar to https://quarkus.io/guides/security-oidc-bearer-token-authentication#single-page-applications, without expecting it to be complete, to give users an idea how a token can be passed over to the existing WS connection",
        "pr_file_module": null
      },
      {
        "comment_id": "2073908794",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-05T17:53:06+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> We can also add some simple example, similar to https://quarkus.io/guides/security-oidc-bearer-token-authentication#single-page-applications, without expecting it to be complete, to give users an idea how a token can be passed over to the existing WS connection\r\n\r\nok, I'll look into it, but no promises on the https://quarkus.io/guides/security-oidc-bearer-token-authentication#single-page-applications part because it may require complex stuff, I don't know until I do it",
        "pr_file_module": null
      },
      {
        "comment_id": "2105998407",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2072682597",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:",
        "comment_created_at": "2025-05-24T22:50:25+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "Done https://github.com/quarkusio/quarkus-quickstarts/pull/1534.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2074160925",
    "pr_number": 47675,
    "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
    "created_at": "2025-05-05T20:44:09+00:00",
    "commented_code": "* Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2074160925",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-05T20:44:09+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik \r\n\r\nI think this method will have to match the security level of the HTTP upgrade.\r\n\r\nFor example, if HTTP Upgrade happened at `@RolesAllowed(\"Admin\")`, then only verifying the validity of the token  which would only match `@Authenticated` level, would raise a risk of decreasing the original security identity strength, for example, the new token which is about to replace an `admin`  level identity may only have a `user` role.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2074229447",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-05T21:31:36+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "OK, that's easy to do.",
        "pr_file_module": null
      },
      {
        "comment_id": "2074276173",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-05T22:16:13+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik Sounds good,  we do it indirectly in the code flow too  when refreshing tokens, since it is done in scope of the request.\r\nIn case of this PR, the new token is coming via the front channel so the extra care is needed. \r\nWe might end up doing extra checks as well...",
        "pr_file_module": null
      },
      {
        "comment_id": "2074815640",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-06T06:37:59+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "I am not sure if I understand what you mean, but my plan is: there is a check that assures principal name is same (so they can't change alice for bob), but for roles and permissions, we just need to reapply standard security annotations (HTTP policies sounds like out of scope to me), which I _think is easy_. There is a code that prevents repeated security checks, I'll just disable the code when the identity refresh is enabled.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075093050",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-06T09:32:47+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik I was actually thinking about it too, how do you prevent an identity swap, so having the principal name check is good, but a few more checks may be necessary, such as a `sub` claim - `sub` is a unique number associated with a given user that did an original login, or even a more thorough identity comparison, but we can think about it later.\r\n\r\nIMHO, whatever the security constraints were applied to HTTP upgrade should be reapplied at the token injection time because this is how we do in the code flow refresh. For example, when the ID and access token are refreshed, the refreshed ID token goes through the complete authentication and authorization cycle before the method can be called.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075101849",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-06T09:37:55+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "If the token is binary then we can update OidcIdentityProvider to record `sub` value from the introspection response as an identity attribute, something like that, so that you can easily access this `sub`",
        "pr_file_module": null
      },
      {
        "comment_id": "2106005055",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47675,
        "pr_file": "docs/src/main/asciidoc/websockets-next-reference.adoc",
        "discussion_id": "2074160925",
        "commented_code": "@@ -1073,6 +1073,51 @@ When you plan to use bearer access tokens during the opening WebSocket handshake\n * Use a custom WebSocket ticket system which supplies a random token with the HTML page which hosts the JavaScript WebSockets client which must provide this token during the initial handshake request as a query parameter.\n ====\n \n+Before the bearer access token sent on the initial HTTP request expires, you can send a new bearer access token as part of a message and update current `SecurityIdentity` attached to the WebSocket server connection:\n+\n+[source, java]\n+----\n+package io.quarkus.websockets.next.test.security;\n+\n+import io.quarkus.security.Authenticated;\n+import io.quarkus.security.identity.SecurityIdentity;\n+import io.quarkus.websockets.next.OnTextMessage;\n+import io.quarkus.websockets.next.WebSocket;\n+import io.quarkus.websockets.next.WebSocketSecurity;\n+import jakarta.inject.Inject;\n+\n+@Authenticated\n+@WebSocket(path = \"/end\")\n+public class Endpoint {\n+\n+    record RequestDto(String accessToken, String message) {}\n+\n+    @Inject\n+    SecurityIdentity securityIdentity;\n+\n+    @Inject\n+    WebSocketSecurity webSocketSecurity;\n+\n+    @OnTextMessage\n+    String echo(RequestDto request) {",
        "comment_created_at": "2025-05-24T23:00:50+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "I have added `sub` check on the introspection result, but the documented QS test and the tests I wrote have `null` introspection attribute. Aren't:\r\n\r\n1. check principal\r\n3. re-apply security checks\r\n\r\ngood proves? Both tested.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2137562089",
    "pr_number": 48296,
    "pr_file": "docs/src/main/asciidoc/security-openid-connect-client-reference.adoc",
    "created_at": "2025-06-10T10:52:31+00:00",
    "commented_code": "`OidcClientRequestReactiveFilter`, `OidcClientRequestFilter` and `Tokens` producers will refresh the current expired access token if the refresh token is available.\n Additionally, the `quarkus.oidc-client.refresh-token-time-skew` property can be used for a preemptive access token refreshment to avoid sending nearly expired access tokens that might cause HTTP 401 errors. For example, if this property is set to `3S` and the access token will expire in less than 3 seconds, then this token will be auto-refreshed.\n \n+By default, Quarkus will refresh the current expired token when you request tokens.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2137562089",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 48296,
        "pr_file": "docs/src/main/asciidoc/security-openid-connect-client-reference.adoc",
        "discussion_id": "2137562089",
        "commented_code": "@@ -713,6 +713,15 @@ You can also inject named `Tokens`, see <<named-oidc-clients,Inject named OidcCl\n `OidcClientRequestReactiveFilter`, `OidcClientRequestFilter` and `Tokens` producers will refresh the current expired access token if the refresh token is available.\n Additionally, the `quarkus.oidc-client.refresh-token-time-skew` property can be used for a preemptive access token refreshment to avoid sending nearly expired access tokens that might cause HTTP 401 errors. For example, if this property is set to `3S` and the access token will expire in less than 3 seconds, then this token will be auto-refreshed.\n \n+By default, Quarkus will refresh the current expired token when you request tokens.",
        "comment_created_at": "2025-06-10T10:52:31+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\nBy default, OIDC client refreshes the token during the current request, when it detects that it has expired, or nearly expired if the [refresh token time skew](https://quarkus.io/guides/security-openid-connect-client-reference#quarkus-oidc-client_quarkus-oidc-client-refresh-token-time-skew) is configured. \r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012600960",
    "pr_number": 46974,
    "pr_file": "docs/src/main/asciidoc/security-authentication-mechanisms.adoc",
    "created_at": "2025-03-25T17:33:22+00:00",
    "commented_code": "include::{generated-dir}/config/quarkus-vertx-http_quarkus.http.auth.adoc[opts=optional, leveloffset=+1]\n \n+[[two-factor-auth]]\n+==== Two-factor authentication\n+\n+The form-based authentication mechanism supports two-factor authentication (2FA), with the second-factor being a one-time authorization code.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2012600960",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 46974,
        "pr_file": "docs/src/main/asciidoc/security-authentication-mechanisms.adoc",
        "discussion_id": "2012600960",
        "commented_code": "@@ -217,6 +217,111 @@ The following properties can be used to configure form-based authentication:\n \n include::{generated-dir}/config/quarkus-vertx-http_quarkus.http.auth.adoc[opts=optional, leveloffset=+1]\n \n+[[two-factor-auth]]\n+==== Two-factor authentication\n+\n+The form-based authentication mechanism supports two-factor authentication (2FA), with the second-factor being a one-time authorization code.",
        "comment_created_at": "2025-03-25T17:33:22+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\nThe form-based authentication mechanism supports two-factor authentication (2FA) with a one-time authorization code second-factor option.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2052981404",
    "pr_number": 47445,
    "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
    "created_at": "2025-04-21T20:50:26+00:00",
    "commented_code": "For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2052981404",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2052981404",
        "commented_code": "@@ -1604,6 +1604,67 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.",
        "comment_created_at": "2025-04-21T20:50:26+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\nThe https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger authentication methods when the token does not have expected Authentication Context Class Reference (ACR) values.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2052990559",
    "pr_number": 47445,
    "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
    "created_at": "2025-04-21T20:59:31+00:00",
    "commented_code": "For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\n+Consider the following example:\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import io.quarkus.oidc.BearerTokenAuthentication;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@BearerTokenAuthentication\n+@Path(\"/\")\n+public class GreetingsResource {\n+\n+    @Path(\"hello\")\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @Path(\"hi\")\n+    @AuthenticationContext(value = \"myACR\", maxAge = 120) <2>\n+    @GET\n+    public String hi() {\n+        return \"hi\";\n+    }\n+}\n+----\n+<1> Bearer access token's `acr` claim must include the `myACR` authentication context class.\n+<2> Bearer access token's expiration time is the `max_age` annotation attribute value added to the `auth_time` token claim value.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2052990559",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2052990559",
        "commented_code": "@@ -1604,6 +1604,67 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\n+Consider the following example:\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import io.quarkus.oidc.BearerTokenAuthentication;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@BearerTokenAuthentication\n+@Path(\"/\")\n+public class GreetingsResource {\n+\n+    @Path(\"hello\")\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @Path(\"hi\")\n+    @AuthenticationContext(value = \"myACR\", maxAge = 120) <2>\n+    @GET\n+    public String hi() {\n+        return \"hi\";\n+    }\n+}\n+----\n+<1> Bearer access token's `acr` claim must include the `myACR` authentication context class.\n+<2> Bearer access token's expiration time is the `max_age` annotation attribute value added to the `auth_time` token claim value.",
        "comment_created_at": "2025-04-21T20:59:31+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\n<2> Bearer access token must have an `acr` claim with the `myACR` ACR value and be in use for no longer than 120 minutes since the authentication time represented by the `auth_time` token claim value.\r\n```\r\nThe token age limits how long an otherwise valid token can be used for in a specific context, the token's expiry is a different value. You are right it is kind of similar, but it can be a bit confusing talking about the expiry.\r\n\r\nI'd consider dropping a reference to the `auth_time` if the spec offers a fallback to the `issued at` (iat) claim, if no `auth_time` is present.\r\n\r\nAlso, I suggested indirectly to use minutes as seconds is too small a unit for the access tokens and it can be harder to calculate longer token ages \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2054026193",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2052990559",
        "commented_code": "@@ -1604,6 +1604,67 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\n+Consider the following example:\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import io.quarkus.oidc.BearerTokenAuthentication;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@BearerTokenAuthentication\n+@Path(\"/\")\n+public class GreetingsResource {\n+\n+    @Path(\"hello\")\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @Path(\"hi\")\n+    @AuthenticationContext(value = \"myACR\", maxAge = 120) <2>\n+    @GET\n+    public String hi() {\n+        return \"hi\";\n+    }\n+}\n+----\n+<1> Bearer access token's `acr` claim must include the `myACR` authentication context class.\n+<2> Bearer access token's expiration time is the `max_age` annotation attribute value added to the `auth_time` token claim value.",
        "comment_created_at": "2025-04-22T12:36:52+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "> The token age limits how long an otherwise valid token can be used for in a specific context, the token's expiry is a different value. You are right it is kind of similar, but it can be a bit confusing talking about the expiry.\r\n\r\nI didn't realize that, thanks Sergey\r\n\r\n> I'd consider dropping a reference to the auth_time if the spec offers a fallback to the issued at (iat) claim, if no auth_time is present.\r\n\r\nSpecs says `auth_time` must be there if authorization request contained `max_time`. Maybe I don't understand what you mean. Your docs change suggestion is alright. So far _issued at (iat)_ cannot be used until specs changes.\r\n\r\n> Also, I suggested indirectly to use minutes as seconds is too small a unit for the access tokens and it can be harder to calculate longer token ages\r\n\r\nI'll change that together with switch to the duration.",
        "pr_file_module": null
      },
      {
        "comment_id": "2054050101",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2052990559",
        "commented_code": "@@ -1604,6 +1604,67 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\n+Consider the following example:\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import io.quarkus.oidc.BearerTokenAuthentication;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@BearerTokenAuthentication\n+@Path(\"/\")\n+public class GreetingsResource {\n+\n+    @Path(\"hello\")\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @Path(\"hi\")\n+    @AuthenticationContext(value = \"myACR\", maxAge = 120) <2>\n+    @GET\n+    public String hi() {\n+        return \"hi\";\n+    }\n+}\n+----\n+<1> Bearer access token's `acr` claim must include the `myACR` authentication context class.\n+<2> Bearer access token's expiration time is the `max_age` annotation attribute value added to the `auth_time` token claim value.",
        "comment_created_at": "2025-04-22T12:50:48+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "@michalvavrik Hi Michal, thanks. In general, we do not have to follow specs the latter to latter.\r\nWhat happens if the user says `maxAge=...` and the token has no `auth_time` ? Spec is one thing but if SPA works with a provider which simply does not set this claim on the token, then SPA can't do Step-Up authentication around the max age property.\r\n\r\nWell, in this case, we can log a warning and say, we can't check it, `maxAge` is ignored. Or we can log an info or debug message - the `auth_time` is not available, using `issued at` claim value. `Issued at` is likely going to be nearly the same as `auth_time` and is always going to stay a few milliseconds or a few seconds max earlier than `auth_time`. And if both claims are absent - we fail the request. \r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2054074988",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2052990559",
        "commented_code": "@@ -1604,6 +1604,67 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\n+Consider the following example:\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import io.quarkus.oidc.BearerTokenAuthentication;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@BearerTokenAuthentication\n+@Path(\"/\")\n+public class GreetingsResource {\n+\n+    @Path(\"hello\")\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @Path(\"hi\")\n+    @AuthenticationContext(value = \"myACR\", maxAge = 120) <2>\n+    @GET\n+    public String hi() {\n+        return \"hi\";\n+    }\n+}\n+----\n+<1> Bearer access token's `acr` claim must include the `myACR` authentication context class.\n+<2> Bearer access token's expiration time is the `max_age` annotation attribute value added to the `auth_time` token claim value.",
        "comment_created_at": "2025-04-22T13:05:01+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "Alright, I'll add `iat` support.",
        "pr_file_module": null
      },
      {
        "comment_id": "2054980709",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47445,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2052990559",
        "commented_code": "@@ -1604,6 +1604,67 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\n+Consider the following example:\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import io.quarkus.oidc.BearerTokenAuthentication;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@BearerTokenAuthentication\n+@Path(\"/\")\n+public class GreetingsResource {\n+\n+    @Path(\"hello\")\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @Path(\"hi\")\n+    @AuthenticationContext(value = \"myACR\", maxAge = 120) <2>\n+    @GET\n+    public String hi() {\n+        return \"hi\";\n+    }\n+}\n+----\n+<1> Bearer access token's `acr` claim must include the `myACR` authentication context class.\n+<2> Bearer access token's expiration time is the `max_age` annotation attribute value added to the `auth_time` token claim value.",
        "comment_created_at": "2025-04-22T22:32:44+00:00",
        "comment_author": "michalvavrik",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2041856178",
    "pr_number": 47339,
    "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
    "created_at": "2025-04-14T10:21:04+00:00",
    "commented_code": "For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== OAuth 2.0 Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduced a mechanism for resource servers like Quarkus to challenge authentication requirements.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2041856178",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47339,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2041856178",
        "commented_code": "@@ -1604,6 +1604,57 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== OAuth 2.0 Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduced a mechanism for resource servers like Quarkus to challenge authentication requirements.",
        "comment_created_at": "2025-04-14T10:21:04+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\nThe https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduces a mechanism for resource servers to request stronger token authentication methods.\r\n```\r\nMay be something like that...\r\nAnd change the sentence order, this one goes first and an info about the annotation - second",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2041866362",
    "pr_number": 47339,
    "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
    "created_at": "2025-04-14T10:28:20+00:00",
    "commented_code": "For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== OAuth 2.0 Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduced a mechanism for resource servers like Quarkus to challenge authentication requirements.\n+Consider following example:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.proactive=false <1>\n+----\n+<1> Disable proactive authentication so that the `@AuthenticationContext` annotation can be matched with the endpoint before Quarkus authenticates incoming requests.\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class HelloResource {\n+\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+}\n+----\n+<1> Only HTTP requests with valid Bearer access token with `acr` claim value that contains `myACR` can access this endpoint.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2041866362",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47339,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2041866362",
        "commented_code": "@@ -1604,6 +1604,57 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== OAuth 2.0 Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduced a mechanism for resource servers like Quarkus to challenge authentication requirements.\n+Consider following example:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.proactive=false <1>\n+----\n+<1> Disable proactive authentication so that the `@AuthenticationContext` annotation can be matched with the endpoint before Quarkus authenticates incoming requests.\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class HelloResource {\n+\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+}\n+----\n+<1> Only HTTP requests with valid Bearer access token with `acr` claim value that contains `myACR` can access this endpoint.",
        "comment_created_at": "2025-04-14T10:28:20+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\n<1> Bearer access token's  `acr` claim must include the `myACR`  authentication context class.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2041882691",
    "pr_number": 47339,
    "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
    "created_at": "2025-04-14T10:40:01+00:00",
    "commented_code": "For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== OAuth 2.0 Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduced a mechanism for resource servers like Quarkus to challenge authentication requirements.\n+Consider following example:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.proactive=false <1>\n+----\n+<1> Disable proactive authentication so that the `@AuthenticationContext` annotation can be matched with the endpoint before Quarkus authenticates incoming requests.\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class HelloResource {\n+\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+}\n+----\n+<1> Only HTTP requests with valid Bearer access token with `acr` claim value that contains `myACR` can access this endpoint.\n+\n+If the Bearer token claim `acr` does not contain `myACR`, Quarkus returns the Authentication Requirements Challenge indicating required `acr_values`:\n+\n+----\n+HTTP/1.1 401 Unauthorized\n+WWW-Authenticate: Bearer error=\"insufficient_user_authentication\",\n+ error_description=\"A different authentication level is required\",\n+ acr_values=\"myACR\"\n+----\n+\n+A client receiving the challenge from the Quarkus server carrying the `insufficient_user_authentication` error code should parse `acr_values` from the `WWW-Authenticate` header and use them when constructing new authorization request.",
    "repo_full_name": "quarkusio/quarkus",
    "discussion_comments": [
      {
        "comment_id": "2041882691",
        "repo_full_name": "quarkusio/quarkus",
        "pr_number": 47339,
        "pr_file": "docs/src/main/asciidoc/security-oidc-bearer-token-authentication.adoc",
        "discussion_id": "2041882691",
        "commented_code": "@@ -1604,6 +1604,57 @@ public class OidcStartup {\n For more complex setup involving multiple tenants please see the xref:security-openid-connect-multitenancy.adoc#programmatic-startup[Programmatic OIDC start-up for multitenant application]\n section of the OpenID Connect Multi-Tenancy guide.\n \n+== OAuth 2.0 Step Up Authentication\n+\n+The `io.quarkus.oidc.AuthenticationContext` annotation can be used to enforce required authentication level for the Jakarta REST resource classes and methods.\n+The https://datatracker.ietf.org/doc/rfc9470/[OAuth 2.0 Step Up Authentication Challenge Protocol] introduced a mechanism for resource servers like Quarkus to challenge authentication requirements.\n+Consider following example:\n+\n+[source,properties]\n+----\n+quarkus.http.auth.proactive=false <1>\n+----\n+<1> Disable proactive authentication so that the `@AuthenticationContext` annotation can be matched with the endpoint before Quarkus authenticates incoming requests.\n+\n+[source,java]\n+----\n+package io.quarkus.it.oidc;\n+\n+import io.quarkus.oidc.AuthenticationContext;\n+import jakarta.ws.rs.GET;\n+import jakarta.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class HelloResource {\n+\n+    @AuthenticationContext(\"myACR\") <1>\n+    @GET\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+}\n+----\n+<1> Only HTTP requests with valid Bearer access token with `acr` claim value that contains `myACR` can access this endpoint.\n+\n+If the Bearer token claim `acr` does not contain `myACR`, Quarkus returns the Authentication Requirements Challenge indicating required `acr_values`:\n+\n+----\n+HTTP/1.1 401 Unauthorized\n+WWW-Authenticate: Bearer error=\"insufficient_user_authentication\",\n+ error_description=\"A different authentication level is required\",\n+ acr_values=\"myACR\"\n+----\n+\n+A client receiving the challenge from the Quarkus server carrying the `insufficient_user_authentication` error code should parse `acr_values` from the `WWW-Authenticate` header and use them when constructing new authorization request.",
        "comment_created_at": "2025-04-14T10:40:01+00:00",
        "comment_author": "sberyozkin",
        "comment_body": "```suggestion\r\nWhen a client such as Single-page application (SPA) receives a challenge with the `insufficient_user_authentication` error code, it must parse `acr_values`, request a new user login which must meet the `act_values` constraints, and use a new access token to access Quarkus.\r\n```\r\n\r\nNot sure, but may be it can be more informative ?\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]