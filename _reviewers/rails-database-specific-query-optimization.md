---
title: Database-specific query optimization
description: Leverage database-specific features to optimize queries and improve performance.
  Different database engines have unique capabilities that can significantly enhance
  query efficiency when used appropriately.
repository: rails/rails
label: Database
language: Ruby
comments_count: 7
repository_stars: 57027
---

Leverage database-specific features to optimize queries and improve performance. Different database engines have unique capabilities that can significantly enhance query efficiency when used appropriately.

For PostgreSQL:
- Use `ANY` operator instead of `IN` for queries with large arrays of values to improve query plan caching
- Handle joins in UPDATE statements properly to avoid unnecessary subqueries
- Consider PostgreSQL-specific data types (arrays, JSONB) for more efficient storage and querying

For example, with PostgreSQL:

```ruby
# Rails can optimize this to use PostgreSQL's more efficient ANY operator:
User.where(id: large_array_of_ids)
# SQL: user.id = ANY('{1,2,3}') instead of user.id IN (1,2,3)
```

When updating with joins, be aware of database-specific limitations:

```ruby
# PostgreSQL supports UPDATE with FROM for inner joins
Post.joins(:author).where(authors: {active: true}).update_all(featured: true)

# But for left joins or complex conditions, Rails may need to use subqueries
# Be mindful of how these are translated to SQL for your specific database
```

Examine the SQL generated by your ORM and understand how database-specific optimizations are applied. This helps you write ActiveRecord queries that translate to efficient SQL for your database engine.


[
  {
    "discussion_id": "2104227071",
    "pr_number": 55086,
    "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb",
    "created_at": "2025-05-23T09:42:38+00:00",
    "commented_code": "def foreign_key_for(from_table, **options)\n          return unless use_foreign_keys?\n          foreign_keys(from_table).detect { |fk| fk.defined_for?(**options) }\n\n          if options[:_skip_column_match]\n            return foreign_keys(from_table).detect { |fk| fk.defined_for?(**options) }\n          end\n\n          keys = foreign_keys(from_table)\n\n          if options[:column]\n            expected_columns = Array(options[:column]).map(&:to_s)\n            keys.select! { |fk| Array(fk.options[:column]).map(&:to_s) == expected_columns }\n          elsif options[:to_table] && !options.key?(:primary_key) && keys.size > 1\n            default_column = foreign_key_column_for(options[:to_table], \"id\").to_s\n            match = keys.find { |fk| Array(fk.options[:column]).map(&:to_s) == [default_column] }\n            keys = [match].compact if match\n          end\n\n          keys.detect { |fk| fk.defined_for?(**options) }",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2104227071",
        "repo_full_name": "rails/rails",
        "pr_number": 55086,
        "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb",
        "discussion_id": "2104227071",
        "commented_code": "@@ -1815,7 +1815,23 @@ def foreign_key_name(table_name, options)\n \n         def foreign_key_for(from_table, **options)\n           return unless use_foreign_keys?\n-          foreign_keys(from_table).detect { |fk| fk.defined_for?(**options) }\n+\n+          if options[:_skip_column_match]\n+            return foreign_keys(from_table).detect { |fk| fk.defined_for?(**options) }\n+          end\n+\n+          keys = foreign_keys(from_table)\n+\n+          if options[:column]\n+            expected_columns = Array(options[:column]).map(&:to_s)\n+            keys.select! { |fk| Array(fk.options[:column]).map(&:to_s) == expected_columns }\n+          elsif options[:to_table] && !options.key?(:primary_key) && keys.size > 1\n+            default_column = foreign_key_column_for(options[:to_table], \"id\").to_s\n+            match = keys.find { |fk| Array(fk.options[:column]).map(&:to_s) == [default_column] }\n+            keys = [match].compact if match\n+          end\n+\n+          keys.detect { |fk| fk.defined_for?(**options) }",
        "comment_created_at": "2025-05-23T09:42:38+00:00",
        "comment_author": "fatkodima",
        "comment_body": "Haven't tested, but something like this is shorter and should work too\r\n```suggestion\r\n          keys = foreign_keys(from_table)\r\n          \r\n          if keys.size == 1 || options[:_skip_column_match]\r\n            keys.find { |fk| fk.defined_for?(**options) }\r\n          elsif options[:column]\r\n            expected_columns = Array(options[:column]).map(&:to_s)\r\n            keys = keys.select { |fk| Array(fk.column) == expected_columns }\r\n            keys.find { |fk| fk.defined_for?(**options) }\r\n          else\r\n            default_column = foreign_key_column_for(options[:to_table], \"id\")\r\n            keys.find { |fk| fk.column == default_column }\r\n          end\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2104474505",
        "repo_full_name": "rails/rails",
        "pr_number": 55086,
        "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb",
        "discussion_id": "2104227071",
        "commented_code": "@@ -1815,7 +1815,23 @@ def foreign_key_name(table_name, options)\n \n         def foreign_key_for(from_table, **options)\n           return unless use_foreign_keys?\n-          foreign_keys(from_table).detect { |fk| fk.defined_for?(**options) }\n+\n+          if options[:_skip_column_match]\n+            return foreign_keys(from_table).detect { |fk| fk.defined_for?(**options) }\n+          end\n+\n+          keys = foreign_keys(from_table)\n+\n+          if options[:column]\n+            expected_columns = Array(options[:column]).map(&:to_s)\n+            keys.select! { |fk| Array(fk.options[:column]).map(&:to_s) == expected_columns }\n+          elsif options[:to_table] && !options.key?(:primary_key) && keys.size > 1\n+            default_column = foreign_key_column_for(options[:to_table], \"id\").to_s\n+            match = keys.find { |fk| Array(fk.options[:column]).map(&:to_s) == [default_column] }\n+            keys = [match].compact if match\n+          end\n+\n+          keys.detect { |fk| fk.defined_for?(**options) }",
        "comment_created_at": "2025-05-23T12:20:36+00:00",
        "comment_author": "zzak",
        "comment_body": "That works, thanks for tidying it up!\r\nFixed in 02bcd2e",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1762154065",
    "pr_number": 48628,
    "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb",
    "created_at": "2024-09-17T01:30:10+00:00",
    "commented_code": "end\n        private :sql_for_insert\n\n        def sql_for_update(sql, binds, returning_columns) # :nodoc:\n          return super unless returning_columns&.any?\n\n          returning_columns_statement = returning_columns.map { |c| quote_column_name(c) }.join(\", \")\n          sql = \"#{sql} RETURNING #{returning_columns_statement}\"",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "1762154065",
        "repo_full_name": "rails/rails",
        "pr_number": 48628,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb",
        "discussion_id": "1762154065",
        "commented_code": "@@ -91,6 +96,16 @@ def sql_for_insert(sql, pk, binds, returning) # :nodoc:\n         end\n         private :sql_for_insert\n \n+        def sql_for_update(sql, binds, returning_columns) # :nodoc:\n+          return super unless returning_columns&.any?\n+\n+          returning_columns_statement = returning_columns.map { |c| quote_column_name(c) }.join(\", \")\n+          sql = \"#{sql} RETURNING #{returning_columns_statement}\"",
        "comment_created_at": "2024-09-17T01:30:10+00:00",
        "comment_author": "rafaelfranca",
        "comment_body": "Instead of concat sqls, can we just build the right AST in the right place? We probably need to build the AST before passing to `exec_update` in the `update` method.",
        "pr_file_module": null
      },
      {
        "comment_id": "1818110035",
        "repo_full_name": "rails/rails",
        "pr_number": 48628,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb",
        "discussion_id": "1762154065",
        "commented_code": "@@ -91,6 +96,16 @@ def sql_for_insert(sql, pk, binds, returning) # :nodoc:\n         end\n         private :sql_for_insert\n \n+        def sql_for_update(sql, binds, returning_columns) # :nodoc:\n+          return super unless returning_columns&.any?\n+\n+          returning_columns_statement = returning_columns.map { |c| quote_column_name(c) }.join(\", \")\n+          sql = \"#{sql} RETURNING #{returning_columns_statement}\"",
        "comment_created_at": "2024-10-27T14:18:09+00:00",
        "comment_author": "abaldwin88",
        "comment_body": "Sorry I'm not entirely clear on the ask here. Is there something different here than `sql_for_insert` which uses the same code pattern?\r\n\r\nI'm planning to move this method from being postgres specific and instead put it under the abstract class. Does that help address your concerns?",
        "pr_file_module": null
      },
      {
        "comment_id": "1890734559",
        "repo_full_name": "rails/rails",
        "pr_number": 48628,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb",
        "discussion_id": "1762154065",
        "commented_code": "@@ -91,6 +96,16 @@ def sql_for_insert(sql, pk, binds, returning) # :nodoc:\n         end\n         private :sql_for_insert\n \n+        def sql_for_update(sql, binds, returning_columns) # :nodoc:\n+          return super unless returning_columns&.any?\n+\n+          returning_columns_statement = returning_columns.map { |c| quote_column_name(c) }.join(\", \")\n+          sql = \"#{sql} RETURNING #{returning_columns_statement}\"",
        "comment_created_at": "2024-12-18T19:26:26+00:00",
        "comment_author": "abaldwin88",
        "comment_body": "My two cents is any further changes around this would be better handled as a separate follow-up PR? A refactor really ought to also include changes to `sql_for_insert`. However, including changes to that method here would be too broad and make this PR unfocused.",
        "pr_file_module": null
      },
      {
        "comment_id": "1942064135",
        "repo_full_name": "rails/rails",
        "pr_number": 48628,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb",
        "discussion_id": "1762154065",
        "commented_code": "@@ -91,6 +96,16 @@ def sql_for_insert(sql, pk, binds, returning) # :nodoc:\n         end\n         private :sql_for_insert\n \n+        def sql_for_update(sql, binds, returning_columns) # :nodoc:\n+          return super unless returning_columns&.any?\n+\n+          returning_columns_statement = returning_columns.map { |c| quote_column_name(c) }.join(\", \")\n+          sql = \"#{sql} RETURNING #{returning_columns_statement}\"",
        "comment_created_at": "2025-02-04T23:59:25+00:00",
        "comment_author": "quentindemetz",
        "comment_body": "@rafaelfranca I don't think Arel supports `Returning` nodes yet (implemented in https://github.com/rails/rails/pull/47161 \ud83d\ude4f\ud83c\udffb), also https://github.com/rails/rails/pull/48241 was merged in 2023 with the same strategy \ud83d\udca1 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1498130204",
    "pr_number": 51116,
    "pr_file": "activerecord/test/cases/relation/where_test.rb",
    "created_at": "2024-02-21T18:52:35+00:00",
    "commented_code": "assert_equal [first_topic, third_topic].sort, Topic.where(key => conditions).sort\n    end\n\n    def test_where_with_tuple_syntax_and_empty_array",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "1498130204",
        "repo_full_name": "rails/rails",
        "pr_number": 51116,
        "pr_file": "activerecord/test/cases/relation/where_test.rb",
        "discussion_id": "1498130204",
        "commented_code": "@@ -107,6 +107,10 @@ def test_where_with_tuple_syntax\n       assert_equal [first_topic, third_topic].sort, Topic.where(key => conditions).sort\n     end\n \n+    def test_where_with_tuple_syntax_and_empty_array",
        "comment_created_at": "2024-02-21T18:52:35+00:00",
        "comment_author": "nvasilevski",
        "comment_body": "It's a little out of the scope of this PR but I think we will benefit from adding one more test and ensuring that \r\n`Topic.where([:id] => []).to_a` performs no queries similarly how `Topic.where(id: []).to_a` doesn't go to the db",
        "pr_file_module": null
      },
      {
        "comment_id": "1499906879",
        "repo_full_name": "rails/rails",
        "pr_number": 51116,
        "pr_file": "activerecord/test/cases/relation/where_test.rb",
        "discussion_id": "1498130204",
        "commented_code": "@@ -107,6 +107,10 @@ def test_where_with_tuple_syntax\n       assert_equal [first_topic, third_topic].sort, Topic.where(key => conditions).sort\n     end\n \n+    def test_where_with_tuple_syntax_and_empty_array",
        "comment_created_at": "2024-02-22T20:37:32+00:00",
        "comment_author": "Slotos",
        "comment_body": "This one keeps me running in circles.\r\n\r\nThe whole thing hinges on a `WhereClause#contardiction?` returning true. I see three primary ways to achieve that:\r\n\r\n- Add an extra case recognising `\"1=0\"` to `#contardiction?`\r\n\r\n    It's way too specific. What about \"1=2\"?\r\n\r\n- Construct an arel node that satisfies existing case, translates to contradictory sql with `to_sql`, and use it in place of \"1=0\".\r\n\r\n    `Arel::Node::In` would lie on its left side.\r\n    `Arel::Node::Equality`, e.g. `Arel::Nodes::Equality.new(1, ActiveRecord::Relation::QueryAttribute.new(\"unboundable\", -1, ActiveModel::Type::Integer.new(limit: 0)))` kinda works, but relies on something fairly unrelated.\r\n\r\n- Implement a new arel node that's always contradictory, make `#contradiction?` aware of it, and use it as an initial value for reduction in predicate builder.\r\n\r\n    `Arel::Nodes::Contradiction` that doesn't accepts any values during initialisation, gets discarded by visitors when it's a part of `Or` node, forces discard of the other side when it's a part of `And` node, turns into `IS TRUE` or `1=1` when negated, and so on.\r\n\r\n    - As a shortcut, arel could provide an unboundable singleton for use in `Equality`, which would achieve all of the above, except for the ability to use it in `Or` and `And` nodes without polluting generated sql with unnecessary clauses.\r\n\r\nI kinda lean towards the latter, as it implements an alluring identity...\r\n\r\nWhich one makes sense from outside of my head?",
        "pr_file_module": null
      },
      {
        "comment_id": "1500195377",
        "repo_full_name": "rails/rails",
        "pr_number": 51116,
        "pr_file": "activerecord/test/cases/relation/where_test.rb",
        "discussion_id": "1498130204",
        "commented_code": "@@ -107,6 +107,10 @@ def test_where_with_tuple_syntax\n       assert_equal [first_topic, third_topic].sort, Topic.where(key => conditions).sort\n     end\n \n+    def test_where_with_tuple_syntax_and_empty_array",
        "comment_created_at": "2024-02-23T04:16:07+00:00",
        "comment_author": "matthewd",
        "comment_body": "I previously contemplated, but didn't merge, something maybe related: https://github.com/matthewd/rails/commit/792eb0442438698c49b98a9ab91e1d88217e321c",
        "pr_file_module": null
      },
      {
        "comment_id": "1500197923",
        "repo_full_name": "rails/rails",
        "pr_number": 51116,
        "pr_file": "activerecord/test/cases/relation/where_test.rb",
        "discussion_id": "1498130204",
        "commented_code": "@@ -107,6 +107,10 @@ def test_where_with_tuple_syntax\n       assert_equal [first_topic, third_topic].sort, Topic.where(key => conditions).sort\n     end\n \n+    def test_where_with_tuple_syntax_and_empty_array",
        "comment_created_at": "2024-02-23T04:23:51+00:00",
        "comment_author": "Slotos",
        "comment_body": "That\u2019s exactly it! And the names actually make sense, unlike my attempt.\r\n\r\nWas there a blocker preventing merge?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1342191760",
    "pr_number": 49388,
    "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
    "created_at": "2023-10-01T21:41:17+00:00",
    "commented_code": "visit o.right, collector\n        end\n\n        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n        # to avoid pg_stat_statements churn\n        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n          case o.attribute.type_caster\n          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n            return super",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "1342191760",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-01T21:41:17+00:00",
        "comment_author": "seanlinsley",
        "comment_body": "These data types don't currently work. Maybe because they get encoded twice? (see #49050)\r\n\r\nThe main risk of this PR is that there are other data types that are broken, but don't have test coverage right now.\r\n\r\nA less risky option would be to only use the new logic for types known to work (number, string, boolean).",
        "pr_file_module": null
      },
      {
        "comment_id": "1342211256",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-02T00:35:58+00:00",
        "comment_author": "ghiculescu",
        "comment_body": "Rails test coverage is usually pretty good. But if you\u2019re concerned enough to mention it, then explicitly opting in the types is probably a good idea. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1342707772",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-02T13:38:56+00:00",
        "comment_author": "seanlinsley",
        "comment_body": "Just trying to make review easier. The test suite didn't catch the fact that JSONB doesn't work.\r\n\r\nIt would be good to review all of the Postgres data types someone would expect this sort of query to work for, to see if any others are broken.",
        "pr_file_module": null
      },
      {
        "comment_id": "1345272946",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-04T06:41:33+00:00",
        "comment_author": "simi",
        "comment_body": "Wouldn't be possible to only opt-in types known to be working properly (and tested) for now and fallback to `super` for rest and iterate over this list if needed later? Using `ANY` for list of numbers or \"strings\" should cover majority of the problems already if I understand it well.",
        "pr_file_module": null
      },
      {
        "comment_id": "1345891006",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-04T14:26:35+00:00",
        "comment_author": "seanlinsley",
        "comment_body": "While it's possible to opt-in to only the types known to work, that would mean opting into almost every type available. I don't think it's enough to only support strings and numbers, because there are so many unique Postgres data types that deserve the optimization this PR adds (e.g. inet, uuid, money, enum).\r\n\r\nI wonder if we should focus on getting #49050 merged -- that may remove the need to have a branching path here.\r\n\r\nCC @JohnAnon9771, the author of that PR",
        "pr_file_module": null
      },
      {
        "comment_id": "1349377643",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-06T22:53:10+00:00",
        "comment_author": "seanlinsley",
        "comment_body": "I've added #49050 to this branch locally, with some additions to this custom `HomogeneousIn` implementation:\r\n```rb\r\ntype_caster = oid::Array.new(o.attribute.type_caster, \",\")\r\ncasted_values = o.values.map do |raw_value|\r\n  o.attribute.type_caster.serialize(raw_value) if o.attribute.type_caster.serializable?(raw_value)\r\nend\r\ncasted_values.compact!\r\npg_encoder = PG::TextEncoder::Array.new name: \"#{type_caster.type}[]\", delimiter: \",\"\r\nvalues = [oid::Array::Data.new(pg_encoder, casted_values)]\r\nproc_for_binds = -> value { Arel::Nodes::HomogeneousIn::BindAttribute.new(o.attribute.name, value) }\r\n```\r\nThat fixes queries for encrypted columns, but unfortunately doesn't fix binary or JSONB columns.\r\n\r\nI think I'll need to write a set of tests that covers all Postgres data types that Rails supports, so we can know for sure which types need to fall back to `IN`.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1349575818",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-07T21:21:18+00:00",
        "comment_author": "JohnAnon9771",
        "comment_body": "> I've added #49050 to this branch locally, with some additions to this custom `HomogeneousIn` implementation:\r\n> \r\n> ```ruby\r\n> type_caster = oid::Array.new(o.attribute.type_caster, \",\")\r\n> casted_values = o.values.map do |raw_value|\r\n>   o.attribute.type_caster.serialize(raw_value) if o.attribute.type_caster.serializable?(raw_value)\r\n> end\r\n> casted_values.compact!\r\n> pg_encoder = PG::TextEncoder::Array.new name: \"#{type_caster.type}[]\", delimiter: \",\"\r\n> values = [oid::Array::Data.new(pg_encoder, casted_values)]\r\n> proc_for_binds = -> value { Arel::Nodes::HomogeneousIn::BindAttribute.new(o.attribute.name, value) }\r\n> ```\r\n> \r\n> That fixes queries for encrypted columns, but unfortunately doesn't fix binary or JSONB columns.\r\n> \r\n> I think I'll need to write a set of tests that covers all Postgres data types that Rails supports, so we can know for sure which types need to fall back to `IN`.\r\n\r\nThank you for testing my PR to look at this, could you tell me how the searches for jsonb and binary turned out?",
        "pr_file_module": null
      },
      {
        "comment_id": "1349752220",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-08T17:46:27+00:00",
        "comment_author": "seanlinsley",
        "comment_body": "I haven't looked into the issue with binary, but it looks like JSONB does technically work, but I was confused because the test only checks the bind params; it doesn't actually perform a query to see if the expected rows are found. @JohnAnon9771 you may want to update that test to be more comprehensive.\r\n\r\nThe code is generating string-encoded JSON inside the array, which I would expect Postgres to treat as a JSON string instead of a JSON object.\r\n```sql\r\njson_options\" = any('{\"{\\\"a\\\":1}\",\"{\\\"b\\\":2}\"}')\r\n```\r\n\r\nHowever, it turns out that Postgres accepts two different formats for JSONB arrays:\r\n\r\n```sql\r\n-- string-encoded\r\nselect a->>'a' from unnest('{\"{\\\"a\\\":2}\",\"{\\\"a\\\":3}\"}'::jsonb[]) _(a);\r\n ?column? \r\n----------\r\n 2\r\n 3\r\n\r\n-- JSON literal, with { and } escaped\r\nselect a->>'a' from unnest('{\\{\\\"a\\\":2\\},\\{\\\"a\\\":3\\}}'::jsonb[]) _(a);\r\n ?column? \r\n----------\r\n 2\r\n 3\r\n```\r\n\r\nWhile a non-array JSONB value is correctly treated as a string:\r\n```sql\r\nselect '\"{\\\"a\\\":2}\"'::jsonb ->> 'a';\r\n ?column? \r\n----------\r\n \r\n```\r\n\r\nI'm not sure what's happening here. @msakrejda any ideas?",
        "pr_file_module": null
      },
      {
        "comment_id": "1350474632",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1342191760",
        "commented_code": "@@ -78,6 +78,26 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = any('{1,2}')` instead of `col IN (1,2)`\n+        # to avoid pg_stat_statements churn\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          oid = ActiveRecord::ConnectionAdapters::PostgreSQL::OID\n+          case o.attribute.type_caster\n+          when ActiveRecord::Encryption::EncryptedAttributeType, oid::Bytea, oid::Jsonb\n+            return super",
        "comment_created_at": "2023-10-09T15:44:10+00:00",
        "comment_author": "msakrejda",
        "comment_body": "@seanlinsley I think this is due to the Postgres array input syntax: https://www.postgresql.org/docs/current/arrays.html#ARRAYS-INPUT -- an array value starts with curly brackets, and then individual elements can either be quoted (as in the first example, requiring you to escape any nested double quotes inside the array element values) or not quoted (requiring you to escape any curly brackets and commas inside the array element values).\r\n\r\nSo you're actually dealing with arrays of JSON objects in both cases, due to how the array input syntax works.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1571372351",
    "pr_number": 49388,
    "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
    "created_at": "2024-04-18T20:58:41+00:00",
    "commented_code": "visit o.right, collector\n        end\n\n        # Postgres-specific implementation that uses `col = ANY ('{1,2}')` instead of `col IN (1,2)`\n        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n          visit o.left, collector\n          collector << (o.type == :in ? \" = ANY (\" : \" != ALL (\")\n          type_caster = ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array.new(o.attribute.type_caster, \",\")",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "1571372351",
        "repo_full_name": "rails/rails",
        "pr_number": 49388,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1571372351",
        "commented_code": "@@ -78,6 +78,22 @@ def visit_Arel_Nodes_IsDistinctFrom(o, collector)\n           visit o.right, collector\n         end\n \n+        # Postgres-specific implementation that uses `col = ANY ('{1,2}')` instead of `col IN (1,2)`\n+        def visit_Arel_Nodes_HomogeneousIn(o, collector)\n+          visit o.left, collector\n+          collector << (o.type == :in ? \" = ANY (\" : \" != ALL (\")\n+          type_caster = ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array.new(o.attribute.type_caster, \",\")",
        "comment_created_at": "2024-04-18T20:58:41+00:00",
        "comment_author": "rafaelfranca",
        "comment_body": "This is coupling the arel visitor with the active record database adapter. We can't do this. Maybe we should store the type in the attribute like we do with the type caster?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1987489967",
    "pr_number": 54722,
    "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
    "created_at": "2025-03-10T15:06:35+00:00",
    "commented_code": "grouping_parentheses o.expr, collector\n        end\n\n        def visit_Arel_Nodes_InnerJoin(o, collector)",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "1987489967",
        "repo_full_name": "rails/rails",
        "pr_number": 54722,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1987489967",
        "commented_code": "@@ -133,6 +134,12 @@ def visit_Arel_Nodes_Lateral(o, collector)\n           grouping_parentheses o.expr, collector\n         end\n \n+        def visit_Arel_Nodes_InnerJoin(o, collector)",
        "comment_created_at": "2025-03-10T15:06:35+00:00",
        "comment_author": "Edouard-chin",
        "comment_body": "Would it make sense to create a new `CrossJoin` node instead of modifying the join type dynamically?\r\n\r\n----\r\n\r\nAlso, I suppose this isn't necessary on sqlite as it creates the correct join based on whether there is a ON condition ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1988244743",
        "repo_full_name": "rails/rails",
        "pr_number": 54722,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1987489967",
        "commented_code": "@@ -133,6 +134,12 @@ def visit_Arel_Nodes_Lateral(o, collector)\n           grouping_parentheses o.expr, collector\n         end\n \n+        def visit_Arel_Nodes_InnerJoin(o, collector)",
        "comment_created_at": "2025-03-11T01:56:19+00:00",
        "comment_author": "brunodccarvalho",
        "comment_body": "From the docs only postgresql rejects the INNER JOIN without ON, and sqlite adds [some extra semantics on top](https://www.sqlite.org/lang_select.html#special_handling_of_cross_join_) so \"CROSS JOIN\" there should actually be avoided.\r\n\r\nAbout a new class I don't know what is better",
        "pr_file_module": null
      },
      {
        "comment_id": "1988620361",
        "repo_full_name": "rails/rails",
        "pr_number": 54722,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1987489967",
        "commented_code": "@@ -133,6 +134,12 @@ def visit_Arel_Nodes_Lateral(o, collector)\n           grouping_parentheses o.expr, collector\n         end\n \n+        def visit_Arel_Nodes_InnerJoin(o, collector)",
        "comment_created_at": "2025-03-11T07:56:33+00:00",
        "comment_author": "byroot",
        "comment_body": "> About a new class I don't know what is better\r\n\r\nMutating the AST prior to calling the visitor is how it's supposed to work. Now sometimes it's a bit inconvenient and it turns out simpler to do what you've done.\r\n\r\nI'd say give it a try, but feel free to push back if that sounds too messy to you.",
        "pr_file_module": null
      },
      {
        "comment_id": "2006603432",
        "repo_full_name": "rails/rails",
        "pr_number": 54722,
        "pr_file": "activerecord/lib/arel/visitors/postgresql.rb",
        "discussion_id": "1987489967",
        "commented_code": "@@ -133,6 +134,12 @@ def visit_Arel_Nodes_Lateral(o, collector)\n           grouping_parentheses o.expr, collector\n         end\n \n+        def visit_Arel_Nodes_InnerJoin(o, collector)",
        "comment_created_at": "2025-03-20T23:30:32+00:00",
        "comment_author": "brunodccarvalho",
        "comment_body": "This doesn't matter much anymore with the special case for inner joins removed. But it seems like a cross join node would not do much: it sounds correct for `join.is_a?(InnerJoin)` to match cross joins, implying the `o.right` dummy nil shouldn't go away. And in sqlite3 we'd want to output `INNER JOIN` anyway, as explained in the docs, so the sql visitors would just trade on special case for another.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959508252",
    "pr_number": 54561,
    "pr_file": "activerecord/lib/arel/visitors/sqlite.rb",
    "created_at": "2025-02-18T10:54:09+00:00",
    "commented_code": "# The SQLite3 dialect isn't flexible enough to allow anything other than a inner join\n            # for the first join:\n            #   UPDATE table SET .. FROM joined_table WHERE ...\n            (o.relation.right.first.is_a?(Arel::Nodes::InnerJoin))\n            (o.relation.right.all? { |join| join.is_a?(Arel::Nodes::InnerJoin) || join.right.expr.right.relation != o.relation.left })",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "1959508252",
        "repo_full_name": "rails/rails",
        "pr_number": 54561,
        "pr_file": "activerecord/lib/arel/visitors/sqlite.rb",
        "discussion_id": "1959508252",
        "commented_code": "@@ -58,7 +64,7 @@ def prepare_update_statement(o)\n             # The SQLite3 dialect isn't flexible enough to allow anything other than a inner join\n             # for the first join:\n             #   UPDATE table SET .. FROM joined_table WHERE ...\n-            (o.relation.right.first.is_a?(Arel::Nodes::InnerJoin))\n+            (o.relation.right.all? { |join| join.is_a?(Arel::Nodes::InnerJoin) || join.right.expr.right.relation != o.relation.left })",
        "comment_created_at": "2025-02-18T10:54:09+00:00",
        "comment_author": "byroot",
        "comment_body": "I'm not sure I understand that `||` condition, could you explain what this is trying to match for?",
        "pr_file_module": null
      },
      {
        "comment_id": "1960541741",
        "repo_full_name": "rails/rails",
        "pr_number": 54561,
        "pr_file": "activerecord/lib/arel/visitors/sqlite.rb",
        "discussion_id": "1959508252",
        "commented_code": "@@ -58,7 +64,7 @@ def prepare_update_statement(o)\n             # The SQLite3 dialect isn't flexible enough to allow anything other than a inner join\n             # for the first join:\n             #   UPDATE table SET .. FROM joined_table WHERE ...\n-            (o.relation.right.first.is_a?(Arel::Nodes::InnerJoin))\n+            (o.relation.right.all? { |join| join.is_a?(Arel::Nodes::InnerJoin) || join.right.expr.right.relation != o.relation.left })",
        "comment_created_at": "2025-02-18T20:23:40+00:00",
        "comment_author": "Edouard-chin",
        "comment_body": "When we have a join on the target (the table we are updating), the joined table has to be in the `FROM` clause for the query to be valid. This is what the first commit in this PR fixes.\r\n\r\nBy introducing this fix, we now hit the flexibility issue you previously mentioned when a left outer join is used. \r\nWhat this `||` checks, is whether there is any left joins on the target which we have to workaround and resort to making a subselect query instead.\r\n\r\nThis check is only required on left joins on the target (as we have to translate that join into a FROM and we hit the flexibility issue). Issuing a left outer join on another table is fine since we don't have to translate it for the query to be syntax valid.\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1961202855",
        "repo_full_name": "rails/rails",
        "pr_number": 54561,
        "pr_file": "activerecord/lib/arel/visitors/sqlite.rb",
        "discussion_id": "1959508252",
        "commented_code": "@@ -58,7 +64,7 @@ def prepare_update_statement(o)\n             # The SQLite3 dialect isn't flexible enough to allow anything other than a inner join\n             # for the first join:\n             #   UPDATE table SET .. FROM joined_table WHERE ...\n-            (o.relation.right.first.is_a?(Arel::Nodes::InnerJoin))\n+            (o.relation.right.all? { |join| join.is_a?(Arel::Nodes::InnerJoin) || join.right.expr.right.relation != o.relation.left })",
        "comment_created_at": "2025-02-19T08:34:13+00:00",
        "comment_author": "byroot",
        "comment_body": "> What this `||` checks, is whether there is any left joins on the target which we have to workaround and resort to making a subselect query instead.\r\n\r\nThat is where I'm confused, this `if` condition is for case where we don't have to fallback to a a subquery. So why `||`, wasn't this meant to be `&&`? (Sorry, I'm not the best with Arel API)",
        "pr_file_module": null
      },
      {
        "comment_id": "1961456591",
        "repo_full_name": "rails/rails",
        "pr_number": 54561,
        "pr_file": "activerecord/lib/arel/visitors/sqlite.rb",
        "discussion_id": "1959508252",
        "commented_code": "@@ -58,7 +64,7 @@ def prepare_update_statement(o)\n             # The SQLite3 dialect isn't flexible enough to allow anything other than a inner join\n             # for the first join:\n             #   UPDATE table SET .. FROM joined_table WHERE ...\n-            (o.relation.right.first.is_a?(Arel::Nodes::InnerJoin))\n+            (o.relation.right.all? { |join| join.is_a?(Arel::Nodes::InnerJoin) || join.right.expr.right.relation != o.relation.left })",
        "comment_created_at": "2025-02-19T10:53:13+00:00",
        "comment_author": "Edouard-chin",
        "comment_body": "Agreed that it's a bit of a brain gymnastic. \r\n\r\n> So why ||, wasn't this meant to be &&? \r\n\r\nAdding a `&&` would mean that we'd fallback to a subselect when we detect a inner join on the target. We only want to fallback when there is a left join on the target.\r\n\r\nMaybe to make it more comprehensible, this is the equivalent of:\r\n\r\n```diff\r\ndiff --git a/activerecord/lib/arel/visitors/sqlite.rb b/activerecord/lib/arel/visitors/sqlite.rb\r\nindex 535df8b73b..7ccaa83696 100644\r\n--- a/activerecord/lib/arel/visitors/sqlite.rb\r\n+++ b/activerecord/lib/arel/visitors/sqlite.rb\r\n@@ -57,6 +57,11 @@ def visit_Arel_Nodes_UpdateStatement(o, collector)\r\n           maybe_visit o.limit, collector\r\n         end\r\n\r\n         def prepare_update_statement(o)\r\n           # Sqlite need to be built with the SQLITE_ENABLE_UPDATE_DELETE_LIMIT compile-time option\r\n           # to support LIMIT/OFFSET/ORDER in UPDATE and DELETE statements.\r\n@@ -64,7 +69,7 @@ def prepare_update_statement(o)\r\n             # The SQLite3 dialect isn't flexible enough to allow anything other than a inner join\r\n             # for the first join:\r\n             #   UPDATE table SET .. FROM joined_table WHERE ...\r\n-            (o.relation.right.all? { |join| join.is_a?(Arel::Nodes::InnerJoin) || join.right.expr.right.relation != o.relation.left })\r\n+            (o.relation.right.none? { |join| join.is_a?(Arel::Nodes::OuterJoin) && join.right.expr.right.relation == o.relation.left })\r\n             o\r\n           else\r\n             super\r\n\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  }
]
