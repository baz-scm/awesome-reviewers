---
title: Database-specific query optimization
description: Leverage database-specific features to optimize queries and improve performance.
  Different database engines have unique capabilities that can significantly enhance
  query efficiency when used appropriately.
repository: rails/rails
label: Database
language: Ruby
comments_count: 7
repository_stars: 57027
---

Leverage database-specific features to optimize queries and improve performance. Different database engines have unique capabilities that can significantly enhance query efficiency when used appropriately.

For PostgreSQL:
- Use `ANY` operator instead of `IN` for queries with large arrays of values to improve query plan caching
- Handle joins in UPDATE statements properly to avoid unnecessary subqueries
- Consider PostgreSQL-specific data types (arrays, JSONB) for more efficient storage and querying

For example, with PostgreSQL:

```ruby
# Rails can optimize this to use PostgreSQL's more efficient ANY operator:
User.where(id: large_array_of_ids)
# SQL: user.id = ANY('{1,2,3}') instead of user.id IN (1,2,3)
```

When updating with joins, be aware of database-specific limitations:

```ruby
# PostgreSQL supports UPDATE with FROM for inner joins
Post.joins(:author).where(authors: {active: true}).update_all(featured: true)

# But for left joins or complex conditions, Rails may need to use subqueries
# Be mindful of how these are translated to SQL for your specific database
```

Examine the SQL generated by your ORM and understand how database-specific optimizations are applied. This helps you write ActiveRecord queries that translate to efficient SQL for your database engine.
