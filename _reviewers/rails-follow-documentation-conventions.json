[
  {
    "discussion_id": "2167177297",
    "pr_number": 55188,
    "pr_file": "guides/source/configuring.md",
    "created_at": "2025-06-25T16:47:48+00:00",
    "commented_code": "default, foreign key names starting with `fk_rails_` are not exported to the\ndatabase schema dump. Defaults to `/^fk_rails_[0-9a-f]{10}$/`.\n\n#### `config.active_record.encryption.support_unencrypted_data`\n\nWhen true, unencrypted data can be read normally. When false, it will raise errors. Default: `false`.",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2167177297",
        "repo_full_name": "rails/rails",
        "pr_number": 55188,
        "pr_file": "guides/source/configuring.md",
        "discussion_id": "2167177297",
        "commented_code": "@@ -1747,40 +1747,63 @@ whether a foreign key's name should be dumped to db/schema.rb or not. By\n default, foreign key names starting with `fk_rails_` are not exported to the\n database schema dump. Defaults to `/^fk_rails_[0-9a-f]{10}$/`.\n \n+#### `config.active_record.encryption.support_unencrypted_data`\n+\n+When true, unencrypted data can be read normally. When false, it will raise errors. Default: `false`.",
        "comment_created_at": "2025-06-25T16:47:48+00:00",
        "comment_author": "p8",
        "comment_body": "I think it's common to use backticks for all boolean values in this guide:\r\n```suggestion\r\nWhen `true`, unencrypted data can be read normally. When `false`, it will raise errors. Default: `false`.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173783190",
    "pr_number": 55254,
    "pr_file": "guides/source/sign_up_and_settings.md",
    "created_at": "2025-06-29T14:42:31+00:00",
    "commented_code": "**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n\nSign Up and Settings\n========================\n\nThis guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n\nAfter reading this guide, you will know how to:\n\n* Add user Sign Up\n* Rate limit controller actions\n* Create a nested layout\n* Separate controllers by role (users and admins)\n* Write tests for users with different roles\n\n--------------------------------------------------------------------------------\n\nIntroduction\n------------\n\nOne of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n\nThis feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n\nLet's get started!\n\nAdding Sign Up\n--------------\n\nWe've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.\n\n### Adding Names To Users\n\nIt's also a good idea to collect the user's name at sign up. This allows us to personalize their experience and address them directly in the application. Let's start by adding `first_name` and `last_name` columns to the database.\n\nIn the terminal, create a migration with these columns:\n\n```bash\n$ rails g migration AddNamesToUsers first_name:string last_name:string\n```\n\nThen migrate the database:\n\n```bash\n$ rails db:migrate\n```\n\nLet's also add a method to combine `first_name` and `last_name`, so that we can display the user's full name.\n\nOpen `app/models/user.rb` and add the following:\n\n```ruby#7-11\nclass User < ApplicationRecord\n  has_secure_password\n  has_many :sessions, dependent: :destroy\n\n  normalizes :email_address, with: ->(e) { e.strip.downcase }\n\n  validates :first_name, :last_name, presence: true\n\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\n```\n\nNext, let's add sign up so we can register new users.\n\n### Sign Up Routes & Controller\n\nNow that our database has all the necessary columns to register new users, the next step is to create a route for sign up and its matching controller.\n\nIn `config/routes.rb`, let's add a resource for sign up:\n\n```ruby#3\nresource :session\nresources :passwords, param: :token\nresource :sign_up\n```\n\nWe're using a singular resource here because we want a singular route for `/sign_up`.\n\nThis route directs requests to `app/controllers/sign_ups_controller.rb` so let's create that controller file now.\n\n```ruby\nclass SignUpsController < ApplicationController\n  def show\n    @user = User.new\n  end\nend\n```\n\nWe're using the `show` action to create a new `User` instance, which will be used to display the sign up form.\n\nLet's create the form next. Create `app/views/sign_ups/show.html.erb` with the following code:\n\n```erb\n<h1>Sign Up</h1>\n\n<%= form_with model: @user, url: sign_up_path do |form| %>\n  <% if form.object.errors.any? %>\n    <div>Error: <%= form.object.errors.full_messages.first %></div>\n  <% end %>\n\n  <div>\n    <%= form.label :first_name %>\n    <%= form.text_field :first_name, required: true, autofocus: true, autocomplete: \"given-name\" %>\n  </div>\n\n  <div>\n    <%= form.label :last_name %>\n    <%= form.text_field :last_name, required: true, autocomplete: \"family-name\" %>\n  </div>\n\n  <div>\n    <%= form.label :email_address %>\n    <%= form.email_field :email_address, required: true, autocomplete: \"email\" %>\n  </div>\n\n  <div>\n    <%= form.label :password %>\n    <%= form.password_field :password, required: true, autocomplete: \"new-password\" %>\n  </div>\n\n  <div>\n    <%= form.label :password_confirmation %>\n    <%= form.password_field :password_confirmation, required: true, autocomplete: \"new-password\" %>\n  </div>\n\n  <div>\n    <%= form.submit \"Sign up\" %>\n  </div>\n<% end %>\n```\n\nThis form collects the user's name, email, and password. We're using the `autocomplete` attribute to help the browser suggest the values for these fields based on the user's saved information.\n\nYou'll also notice we set `url: sign_up_path` in the form alongside `model: @user`. Without this `url:` argument, `form_with` would see we have a `User` and send the form to `/users` by default. Since we want the form to submit to `/sign_up`, we set the `url:` to override the default route.\n\nBack in `app/controllers/sign_ups_controller.rb` we can handle the form submission by adding the `create` action.\n\n```ruby#6-19\nclass SignUpsController < ApplicationController\n  def show\n    @user = User.new\n  end\n\n  def create\n    @user = User.new(sign_up_params)\n    if @user.save\n      start_new_session_for(@user)\n      redirect_to root_path\n    else\n      render :show, status: :unprocessable_entity\n    end\n  end\n\n  private\n    def sign_up_params\n      params.expect(user: [ :first_name, :last_name, :email_address, :password, :password_confirmation ])\n    end\nend\n```\n\nThe `create` action assigns parameters and attempts to save the user to the database. If successful, it logs the user in and redirects to `root_path`, otherwise it re-renders the form with errors.\n\nAuthenticated users can still access `SignUpsController` and create another account while they're logged in which can be confusing.\n\nLet's fix this by adding a helper to the `Authentication` module in `app/controllers/concerns/authentication.rb`.\n\n```ruby#14-17\nmodule Authentication\n  extend ActiveSupport::Concern\n\n  included do\n    before_action :require_authentication\n    helper_method :authenticated?\n  end\n\n  class_methods do\n    def allow_unauthenticated_access(**options)\n      skip_before_action :require_authentication, **options\n    end\n\n    def unauthenticated_access_only(**options)\n      allow_unauthenticated_access **options\n      before_action -> { redirect_to root_path if authenticated? }, **options\n    end\n\n    # ...\n```\n\nThe `unauthenticated_only_access` class method can be used in any controller where we want to restrict actions to unauthenticated users only.\n\nWe can then use this method at the top of `SignUpsController`.\n\n```ruby#2\nclass SignUpsController < ApplicationController\n  unauthenticated_access_only\n\n  # ...\nend\n```\n\n### Rate Limiting Sign Up\n\nOur application will be accessible on the internet so we're bound to have malicious bots and users trying to spam our application. We can add rate limiting to sign up to slow down anyone submitting too many requests.\n\nRails makes this easy with the [`rate_limit`](https://api.rubyonrails.org/classes/ActionController/RateLimiting/ClassMethods.html) method in controllers.\n\n```ruby#3\nclass SignUpsController < ApplicationController\n  unauthenticated_only_access\n  rate_limit to: 10, within: 3.minutes, only: :create, with: -> { redirect_to sign_up_path, alert: \"Try again later.\" }\n\n  # ...\nend\n```\n\nThis will block any form submissions that happen more than 10 times within 3 minutes.\n\nEditing Passwords\n-----------------\n\nNow that users can login, let's create all the usual places that users would expect to update their profile, password, email address, and other settings.\n\n### Using Namespaces\n\nThe Rails authentication generator already created at `app/controllers/passwords_controller.rb` is the controller for password resets. This means we need to use a different controller for editing passwords of authenticated users.\n\nTo prevent conflicts, we can use a feature called **namespaces**. A namespace organizes routes, controllers, and views into folders and helps prevent conflicts like our two passwords controllers.\n\nWe'll create a namespace called \"Settings\" to separate out the user and store settings from the rest of our application.\n\nIn `config/routes.rb` we can add the Settings namespace along with a resource for editing passwords:\n\n```ruby\nnamespace :settings do\n  resource :password, only: [:show, :update]\nend\n```\n\nThis will generate a route for `/settings/password` for editing the current user's password which is separate from the password resets routes at `/password`.\n\n### Adding the Namespaced Passwords Controller & View\n\nNamespaces also move controllers into a matching module in Ruby. This controller will be in a `settings` folder to match the namespace.\n\nLet's create the folder and controller at `app/controllers/settings/passwords_controller.rb` and start with the `show` action.\n\n```ruby\nclass Settings::PasswordsController < ApplicationController\n  def show\n  end\nend\n```\n\nViews also move to a `settings` folder so let's create the folder and view at `app/views/settings/passwords/show.html.erb` for this action.\n\n```erb\n<h1>Password</h1>\n\n<%= form_with model: Current.user, url: settings_password_path do |form| %>",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2173783190",
        "repo_full_name": "rails/rails",
        "pr_number": 55254,
        "pr_file": "guides/source/sign_up_and_settings.md",
        "discussion_id": "2173783190",
        "commented_code": "@@ -0,0 +1,1658 @@\n+**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n+\n+Sign Up and Settings\n+========================\n+\n+This guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n+\n+After reading this guide, you will know how to:\n+\n+* Add user Sign Up\n+* Rate limit controller actions\n+* Create a nested layout\n+* Separate controllers by role (users and admins)\n+* Write tests for users with different roles\n+\n+--------------------------------------------------------------------------------\n+\n+Introduction\n+------------\n+\n+One of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n+\n+This feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n+\n+Let's get started!\n+\n+Adding Sign Up\n+--------------\n+\n+We've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.\n+\n+### Adding Names To Users\n+\n+It's also a good idea to collect the user's name at sign up. This allows us to personalize their experience and address them directly in the application. Let's start by adding `first_name` and `last_name` columns to the database.\n+\n+In the terminal, create a migration with these columns:\n+\n+```bash\n+$ rails g migration AddNamesToUsers first_name:string last_name:string\n+```\n+\n+Then migrate the database:\n+\n+```bash\n+$ rails db:migrate\n+```\n+\n+Let's also add a method to combine `first_name` and `last_name`, so that we can display the user's full name.\n+\n+Open `app/models/user.rb` and add the following:\n+\n+```ruby#7-11\n+class User < ApplicationRecord\n+  has_secure_password\n+  has_many :sessions, dependent: :destroy\n+\n+  normalizes :email_address, with: ->(e) { e.strip.downcase }\n+\n+  validates :first_name, :last_name, presence: true\n+\n+  def full_name\n+    \"#{first_name} #{last_name}\"\n+  end\n+end\n+```\n+\n+Next, let's add sign up so we can register new users.\n+\n+### Sign Up Routes & Controller\n+\n+Now that our database has all the necessary columns to register new users, the next step is to create a route for sign up and its matching controller.\n+\n+In `config/routes.rb`, let's add a resource for sign up:\n+\n+```ruby#3\n+resource :session\n+resources :passwords, param: :token\n+resource :sign_up\n+```\n+\n+We're using a singular resource here because we want a singular route for `/sign_up`.\n+\n+This route directs requests to `app/controllers/sign_ups_controller.rb` so let's create that controller file now.\n+\n+```ruby\n+class SignUpsController < ApplicationController\n+  def show\n+    @user = User.new\n+  end\n+end\n+```\n+\n+We're using the `show` action to create a new `User` instance, which will be used to display the sign up form.\n+\n+Let's create the form next. Create `app/views/sign_ups/show.html.erb` with the following code:\n+\n+```erb\n+<h1>Sign Up</h1>\n+\n+<%= form_with model: @user, url: sign_up_path do |form| %>\n+  <% if form.object.errors.any? %>\n+    <div>Error: <%= form.object.errors.full_messages.first %></div>\n+  <% end %>\n+\n+  <div>\n+    <%= form.label :first_name %>\n+    <%= form.text_field :first_name, required: true, autofocus: true, autocomplete: \"given-name\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :last_name %>\n+    <%= form.text_field :last_name, required: true, autocomplete: \"family-name\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :email_address %>\n+    <%= form.email_field :email_address, required: true, autocomplete: \"email\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password %>\n+    <%= form.password_field :password, required: true, autocomplete: \"new-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password_confirmation %>\n+    <%= form.password_field :password_confirmation, required: true, autocomplete: \"new-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.submit \"Sign up\" %>\n+  </div>\n+<% end %>\n+```\n+\n+This form collects the user's name, email, and password. We're using the `autocomplete` attribute to help the browser suggest the values for these fields based on the user's saved information.\n+\n+You'll also notice we set `url: sign_up_path` in the form alongside `model: @user`. Without this `url:` argument, `form_with` would see we have a `User` and send the form to `/users` by default. Since we want the form to submit to `/sign_up`, we set the `url:` to override the default route.\n+\n+Back in `app/controllers/sign_ups_controller.rb` we can handle the form submission by adding the `create` action.\n+\n+```ruby#6-19\n+class SignUpsController < ApplicationController\n+  def show\n+    @user = User.new\n+  end\n+\n+  def create\n+    @user = User.new(sign_up_params)\n+    if @user.save\n+      start_new_session_for(@user)\n+      redirect_to root_path\n+    else\n+      render :show, status: :unprocessable_entity\n+    end\n+  end\n+\n+  private\n+    def sign_up_params\n+      params.expect(user: [ :first_name, :last_name, :email_address, :password, :password_confirmation ])\n+    end\n+end\n+```\n+\n+The `create` action assigns parameters and attempts to save the user to the database. If successful, it logs the user in and redirects to `root_path`, otherwise it re-renders the form with errors.\n+\n+Authenticated users can still access `SignUpsController` and create another account while they're logged in which can be confusing.\n+\n+Let's fix this by adding a helper to the `Authentication` module in `app/controllers/concerns/authentication.rb`.\n+\n+```ruby#14-17\n+module Authentication\n+  extend ActiveSupport::Concern\n+\n+  included do\n+    before_action :require_authentication\n+    helper_method :authenticated?\n+  end\n+\n+  class_methods do\n+    def allow_unauthenticated_access(**options)\n+      skip_before_action :require_authentication, **options\n+    end\n+\n+    def unauthenticated_access_only(**options)\n+      allow_unauthenticated_access **options\n+      before_action -> { redirect_to root_path if authenticated? }, **options\n+    end\n+\n+    # ...\n+```\n+\n+The `unauthenticated_only_access` class method can be used in any controller where we want to restrict actions to unauthenticated users only.\n+\n+We can then use this method at the top of `SignUpsController`.\n+\n+```ruby#2\n+class SignUpsController < ApplicationController\n+  unauthenticated_access_only\n+\n+  # ...\n+end\n+```\n+\n+### Rate Limiting Sign Up\n+\n+Our application will be accessible on the internet so we're bound to have malicious bots and users trying to spam our application. We can add rate limiting to sign up to slow down anyone submitting too many requests.\n+\n+Rails makes this easy with the [`rate_limit`](https://api.rubyonrails.org/classes/ActionController/RateLimiting/ClassMethods.html) method in controllers.\n+\n+```ruby#3\n+class SignUpsController < ApplicationController\n+  unauthenticated_only_access\n+  rate_limit to: 10, within: 3.minutes, only: :create, with: -> { redirect_to sign_up_path, alert: \"Try again later.\" }\n+\n+  # ...\n+end\n+```\n+\n+This will block any form submissions that happen more than 10 times within 3 minutes.\n+\n+Editing Passwords\n+-----------------\n+\n+Now that users can login, let's create all the usual places that users would expect to update their profile, password, email address, and other settings.\n+\n+### Using Namespaces\n+\n+The Rails authentication generator already created at `app/controllers/passwords_controller.rb` is the controller for password resets. This means we need to use a different controller for editing passwords of authenticated users.\n+\n+To prevent conflicts, we can use a feature called **namespaces**. A namespace organizes routes, controllers, and views into folders and helps prevent conflicts like our two passwords controllers.\n+\n+We'll create a namespace called \"Settings\" to separate out the user and store settings from the rest of our application.\n+\n+In `config/routes.rb` we can add the Settings namespace along with a resource for editing passwords:\n+\n+```ruby\n+namespace :settings do\n+  resource :password, only: [:show, :update]\n+end\n+```\n+\n+This will generate a route for `/settings/password` for editing the current user's password which is separate from the password resets routes at `/password`.\n+\n+### Adding the Namespaced Passwords Controller & View\n+\n+Namespaces also move controllers into a matching module in Ruby. This controller will be in a `settings` folder to match the namespace.\n+\n+Let's create the folder and controller at `app/controllers/settings/passwords_controller.rb` and start with the `show` action.\n+\n+```ruby\n+class Settings::PasswordsController < ApplicationController\n+  def show\n+  end\n+end\n+```\n+\n+Views also move to a `settings` folder so let's create the folder and view at `app/views/settings/passwords/show.html.erb` for this action.\n+\n+```erb\n+<h1>Password</h1>\n+\n+<%= form_with model: Current.user, url: settings_password_path do |form| %>",
        "comment_created_at": "2025-06-29T14:42:31+00:00",
        "comment_author": "skipkayhil",
        "comment_body": "Feedback from reddit: https://old.reddit.com/r/rails/comments/1lmo4ud/learning_to_learn_rails_the_rails_secret_handshake/\r\n\r\nI kind of agree that `Current.user` needs more explanation. I think its setup by the authentication generator in the Getting Started guide, but neither Getting Started nor this guide really explain what it is/how it works.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173783614",
    "pr_number": 55254,
    "pr_file": "guides/source/sign_up_and_settings.md",
    "created_at": "2025-06-29T14:44:05+00:00",
    "commented_code": "**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n\nSign Up and Settings\n========================\n\nThis guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n\nAfter reading this guide, you will know how to:\n\n* Add user Sign Up\n* Rate limit controller actions\n* Create a nested layout\n* Separate controllers by role (users and admins)\n* Write tests for users with different roles\n\n--------------------------------------------------------------------------------\n\nIntroduction\n------------\n\nOne of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n\nThis feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n\nLet's get started!\n\nAdding Sign Up\n--------------\n\nWe've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2173783614",
        "repo_full_name": "rails/rails",
        "pr_number": 55254,
        "pr_file": "guides/source/sign_up_and_settings.md",
        "discussion_id": "2173783614",
        "commented_code": "@@ -0,0 +1,1658 @@\n+**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n+\n+Sign Up and Settings\n+========================\n+\n+This guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n+\n+After reading this guide, you will know how to:\n+\n+* Add user Sign Up\n+* Rate limit controller actions\n+* Create a nested layout\n+* Separate controllers by role (users and admins)\n+* Write tests for users with different roles\n+\n+--------------------------------------------------------------------------------\n+\n+Introduction\n+------------\n+\n+One of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n+\n+This feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n+\n+Let's get started!\n+\n+Adding Sign Up\n+--------------\n+\n+We've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.",
        "comment_created_at": "2025-06-29T14:44:05+00:00",
        "comment_author": "skipkayhil",
        "comment_body": "What do you think about a link to `/getting_started#adding-authentication` here so that someone can quickly jump back to that section for context?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167009239",
    "pr_number": 55179,
    "pr_file": "guides/source/threading_and_code_execution.md",
    "created_at": "2025-06-25T15:26:31+00:00",
    "commented_code": "end\n```\n\n### Concurrency\nNOTE: The Rails Executor is safely re-entrant; it can be called again if it is\nalready running. In this case, the `wrap` method has no effect.\n\n#### Running Mode\n\nWhen called, the Rails Executor will put the current thread into `running` mode\nin the [Load Interlock](#load-interlock).\n\nThe Executor will put the current thread into `running` mode in the [Load\nInterlock](#load-interlock). This operation will block temporarily if another\nthread is currently either autoloading a constant or unloading/reloading\nthe application.\nThis operation will block temporarily if another thread is currently either\nautoloading a constant or unloading/reloading the application.\n\nReloader\n--------\n#### Examples of Wrapped Application Code\n\nLike the Executor, the Reloader also wraps application code. If the Executor is\nnot already active on the current thread, the Reloader will invoke it for you,\nso you only need to call one. This also guarantees that everything the Reloader\ndoes, including all its callback invocations, occurs wrapped inside the\nExecutor.\nAny time your library or component needs to invoke code that will run in the\napplication, the code should be wrapped to ensure thread safety and a consistent\nand clean runtime state.\n\nFor example, you may be setting a `Current` user (using\n[`ActiveSupport::CurrentAttributes`](https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html)).",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2167009239",
        "repo_full_name": "rails/rails",
        "pr_number": 55179,
        "pr_file": "guides/source/threading_and_code_execution.md",
        "discussion_id": "2167009239",
        "commented_code": "@@ -106,60 +183,113 @@ ensure\n end\n ```\n \n-### Concurrency\n+NOTE: The Rails Executor is safely re-entrant; it can be called again if it is\n+already running. In this case, the `wrap` method has no effect.\n+\n+#### Running Mode\n+\n+When called, the Rails Executor will put the current thread into `running` mode\n+in the [Load Interlock](#load-interlock).\n \n-The Executor will put the current thread into `running` mode in the [Load\n-Interlock](#load-interlock). This operation will block temporarily if another\n-thread is currently either autoloading a constant or unloading/reloading\n-the application.\n+This operation will block temporarily if another thread is currently either\n+autoloading a constant or unloading/reloading the application.\n \n-Reloader\n---------\n+#### Examples of Wrapped Application Code\n \n-Like the Executor, the Reloader also wraps application code. If the Executor is\n-not already active on the current thread, the Reloader will invoke it for you,\n-so you only need to call one. This also guarantees that everything the Reloader\n-does, including all its callback invocations, occurs wrapped inside the\n-Executor.\n+Any time your library or component needs to invoke code that will run in the\n+application, the code should be wrapped to ensure thread safety and a consistent\n+and clean runtime state.\n+\n+For example, you may be setting a `Current` user (using\n+[`ActiveSupport::CurrentAttributes`](https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html)).",
        "comment_created_at": "2025-06-25T15:26:31+00:00",
        "comment_author": "p8",
        "comment_body": "Maybe link to the CurrentAttributes section in this guide instead, so the reader doesn't need to navigate away?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149163867",
    "pr_number": 55193,
    "pr_file": "guides/source/active_job_basics.md",
    "created_at": "2025-06-16T06:45:05+00:00",
    "commented_code": "[`queue_with_priority`]:\n    https://api.rubyonrails.org/classes/ActiveJob/QueuePriority/ClassMethods.html#method-i-queue_with_priority\n\nJob Continuations\n-----------------\n\nJobs can be split into resumable steps using continuations. This is useful when\na job may be interrupted - for example, during queue shutdown. When using\ncontinuations, the job can resume from the last completed step, avoiding the\nneed to restart from the beginning.\n\nTo use continuations, include the `ActiveJob::Continuable` module. You can then\ndefine each step using the `step` method inside the `perform` method. Each step can\nbe declared with a block or by referencing a method name.\n\n```ruby\nclass ProcessImportJob < ApplicationJob\n  include ActiveJob::Continuable\n\n  def perform(import_id)\n    # Always runs on job start, even when resuming from an interrupted step.\n    @import = Import.find(import_id)\n\n    # Step defined using a block\n    step :initialize do\n      @import.initialize\n    end\n\n    # Step with a cursor — progress is saved and resumed if the job is interrupted\n    step :process do |step|\n      @import.records.find_each(start: step.cursor) do |record|\n        record.process\n        step.advance! from: record.id\n      end\n    end\n\n    # Step defined by referencing a method\n    step :finalize\n  end\n\n  private\n    def finalize\n      @import.finalize\n    end\nend\n```\n\nEach step runs sequentially. If the job is interrupted between steps, or within a\nstep that uses a cursor, the job resumes from the last recorded position. This\nmakes it easier to build long-running or multi-phase jobs that can safely pause\nand resume without losing progress.\nFor more details, see [ActiveJob::Continuable](https://edgeapi.rubyonrails.org/classes/ActiveJob/Continuation.html).",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2149163867",
        "repo_full_name": "rails/rails",
        "pr_number": 55193,
        "pr_file": "guides/source/active_job_basics.md",
        "discussion_id": "2149163867",
        "commented_code": "@@ -671,6 +671,56 @@ number as more important.\n [`queue_with_priority`]:\n     https://api.rubyonrails.org/classes/ActiveJob/QueuePriority/ClassMethods.html#method-i-queue_with_priority\n \n+Job Continuations\n+-----------------\n+\n+Jobs can be split into resumable steps using continuations. This is useful when\n+a job may be interrupted - for example, during queue shutdown. When using\n+continuations, the job can resume from the last completed step, avoiding the\n+need to restart from the beginning.\n+\n+To use continuations, include the `ActiveJob::Continuable` module. You can then\n+define each step using the `step` method inside the `perform` method. Each step can\n+be declared with a block or by referencing a method name.\n+\n+```ruby\n+class ProcessImportJob < ApplicationJob\n+  include ActiveJob::Continuable\n+\n+  def perform(import_id)\n+    # Always runs on job start, even when resuming from an interrupted step.\n+    @import = Import.find(import_id)\n+\n+    # Step defined using a block\n+    step :initialize do\n+      @import.initialize\n+    end\n+\n+    # Step with a cursor — progress is saved and resumed if the job is interrupted\n+    step :process do |step|\n+      @import.records.find_each(start: step.cursor) do |record|\n+        record.process\n+        step.advance! from: record.id\n+      end\n+    end\n+\n+    # Step defined by referencing a method\n+    step :finalize\n+  end\n+\n+  private\n+    def finalize\n+      @import.finalize\n+    end\n+end\n+```\n+\n+Each step runs sequentially. If the job is interrupted between steps, or within a\n+step that uses a cursor, the job resumes from the last recorded position. This\n+makes it easier to build long-running or multi-phase jobs that can safely pause\n+and resume without losing progress.\n+For more details, see [ActiveJob::Continuable](https://edgeapi.rubyonrails.org/classes/ActiveJob/Continuation.html).",
        "comment_created_at": "2025-06-16T06:45:05+00:00",
        "comment_author": "zzak",
        "comment_body": "```suggestion\r\nFor more details, see [ActiveJob::Continuable](https://api.rubyonrails.org/classes/ActiveJob/Continuation.html).\r\n```\r\n\r\nKnit: we only link to `api.` in the guides source, there is a method for converting to `edge` when building the edge docs automatically.",
        "pr_file_module": null
      },
      {
        "comment_id": "2149177069",
        "repo_full_name": "rails/rails",
        "pr_number": 55193,
        "pr_file": "guides/source/active_job_basics.md",
        "discussion_id": "2149163867",
        "commented_code": "@@ -671,6 +671,56 @@ number as more important.\n [`queue_with_priority`]:\n     https://api.rubyonrails.org/classes/ActiveJob/QueuePriority/ClassMethods.html#method-i-queue_with_priority\n \n+Job Continuations\n+-----------------\n+\n+Jobs can be split into resumable steps using continuations. This is useful when\n+a job may be interrupted - for example, during queue shutdown. When using\n+continuations, the job can resume from the last completed step, avoiding the\n+need to restart from the beginning.\n+\n+To use continuations, include the `ActiveJob::Continuable` module. You can then\n+define each step using the `step` method inside the `perform` method. Each step can\n+be declared with a block or by referencing a method name.\n+\n+```ruby\n+class ProcessImportJob < ApplicationJob\n+  include ActiveJob::Continuable\n+\n+  def perform(import_id)\n+    # Always runs on job start, even when resuming from an interrupted step.\n+    @import = Import.find(import_id)\n+\n+    # Step defined using a block\n+    step :initialize do\n+      @import.initialize\n+    end\n+\n+    # Step with a cursor — progress is saved and resumed if the job is interrupted\n+    step :process do |step|\n+      @import.records.find_each(start: step.cursor) do |record|\n+        record.process\n+        step.advance! from: record.id\n+      end\n+    end\n+\n+    # Step defined by referencing a method\n+    step :finalize\n+  end\n+\n+  private\n+    def finalize\n+      @import.finalize\n+    end\n+end\n+```\n+\n+Each step runs sequentially. If the job is interrupted between steps, or within a\n+step that uses a cursor, the job resumes from the last recorded position. This\n+makes it easier to build long-running or multi-phase jobs that can safely pause\n+and resume without losing progress.\n+For more details, see [ActiveJob::Continuable](https://edgeapi.rubyonrails.org/classes/ActiveJob/Continuation.html).",
        "comment_created_at": "2025-06-16T06:54:15+00:00",
        "comment_author": "satyakampandya",
        "comment_body": "@zzak Thanks for the clarification! I've updated the link accordingly to api.rubyonrails.org. 🙌",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2064309760",
    "pr_number": 54982,
    "pr_file": "guides/source/asset_pipeline.md",
    "created_at": "2025-04-28T18:46:08+00:00",
    "commented_code": "### Setup\n\nFollow these steps for setup Propshaft in your Rails application:\nFollow these steps for setting up Propshaft in your Rails application:\n\n1. Create a new Rails application:\n\n    ```bash\n    $ rails new app_name\n    rails new app_name",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2064309760",
        "repo_full_name": "rails/rails",
        "pr_number": 54982,
        "pr_file": "guides/source/asset_pipeline.md",
        "discussion_id": "2064309760",
        "commented_code": "@@ -359,12 +359,12 @@ serve them efficiently.\n \n ### Setup\n \n-Follow these steps for setup Propshaft in your Rails application:\n+Follow these steps for setting up Propshaft in your Rails application:\n \n 1. Create a new Rails application:\n \n     ```bash\n-    $ rails new app_name\n+    rails new app_name",
        "comment_created_at": "2025-04-28T18:46:08+00:00",
        "comment_author": "skipkayhil",
        "comment_body": "```suggestion\r\n    $ rails new app_name\r\n```\r\n\r\nThe prompt symbol is consistently present in all of the guides, so it should not be removed here (and should be added to the newly added snippets)",
        "pr_file_module": null
      },
      {
        "comment_id": "2064324685",
        "repo_full_name": "rails/rails",
        "pr_number": 54982,
        "pr_file": "guides/source/asset_pipeline.md",
        "discussion_id": "2064309760",
        "commented_code": "@@ -359,12 +359,12 @@ serve them efficiently.\n \n ### Setup\n \n-Follow these steps for setup Propshaft in your Rails application:\n+Follow these steps for setting up Propshaft in your Rails application:\n \n 1. Create a new Rails application:\n \n     ```bash\n-    $ rails new app_name\n+    rails new app_name",
        "comment_created_at": "2025-04-28T18:53:27+00:00",
        "comment_author": "letsEstel",
        "comment_body": "Gotcha",
        "pr_file_module": null
      }
    ]
  }
]