---
title: Layer security defenses
description: Implement multiple layers of security throughout your application rather
  than relying on a single protection mechanism. This defense-in-depth approach significantly
  improves your application's security posture.
repository: rails/rails
label: Security
language: Markdown
comments_count: 9
repository_stars: 57027
---

Implement multiple layers of security throughout your application rather than relying on a single protection mechanism. This defense-in-depth approach significantly improves your application's security posture.

1. Encrypt sensitive data appropriately:
```ruby
class User < ApplicationRecord
  # Use non-deterministic encryption for maximum security
  encrypts :social_security_number
  
  # Only use deterministic encryption when queries are needed
  encrypts :email, deterministic: true, downcase: true
  
  # Ensure password security beyond has_secure_password
  validates :password, length: { minimum: 12 }
end
```

2. Separate authentication (identity verification) from authorization (permissions):
```ruby
# Don't mix in Authentication module
module Authorization
  extend ActiveSupport::Concern
  
  def require_admin
    redirect_to root_path unless Current.user&.admin?
  end
end
```

3. Use environment-specific security controls:
```yaml
# config/storage.yml
production:
  service: S3
  environment: production
  # additional settings
```

4. Apply modern cryptographic standards (SHA256 instead of SHA1)
5. Use HTTPS for all remote resources
6. Add Content Security Policies to all responses including APIs
7. Implement rate limiting for authentication endpoints

Always document security trade-offs when making implementation decisions and regularly update security measures as standards evolve.


[
  {
    "discussion_id": "2169806449",
    "pr_number": 55188,
    "pr_file": "guides/source/active_record_encryption.md",
    "created_at": "2025-06-26T19:23:56+00:00",
    "commented_code": "Active Record Encryption\n========================\n\nThis guide covers encrypting your database information using Active Record.\nThis guide covers how to encrypt data in your database using Active Record.\n\nAfter reading this guide, you will know:\n\n* How to set up database encryption with Active Record.\n* How to migrate unencrypted data.\n* How to make different encryption schemes coexist.\n* How to use the API.\n* How to configure the library and how to extend it.\n* More about advanced concepts like Encryption Contexts and Key Providers.\n\n--------------------------------------------------------------------------------\n\nActive Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\nActive Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2169806449",
        "repo_full_name": "rails/rails",
        "pr_number": 55188,
        "pr_file": "guides/source/active_record_encryption.md",
        "discussion_id": "2169806449",
        "commented_code": "@@ -3,151 +3,174 @@\n Active Record Encryption\n ========================\n \n-This guide covers encrypting your database information using Active Record.\n+This guide covers how to encrypt data in your database using Active Record.\n \n After reading this guide, you will know:\n \n * How to set up database encryption with Active Record.\n * How to migrate unencrypted data.\n * How to make different encryption schemes coexist.\n-* How to use the API.\n-* How to configure the library and how to extend it.\n+* More about advanced concepts like Encryption Contexts and Key Providers.\n \n --------------------------------------------------------------------------------\n \n-Active Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\n+Active Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.",
        "comment_created_at": "2025-06-26T19:23:56+00:00",
        "comment_author": "p8",
        "comment_body": "If the next section states that encryption sits at the application level, the last line of this paragraph should probably do the same?\r\n```suggestion\r\nActive Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits at the application level.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2178382708",
        "repo_full_name": "rails/rails",
        "pr_number": 55188,
        "pr_file": "guides/source/active_record_encryption.md",
        "discussion_id": "2169806449",
        "commented_code": "@@ -3,151 +3,174 @@\n Active Record Encryption\n ========================\n \n-This guide covers encrypting your database information using Active Record.\n+This guide covers how to encrypt data in your database using Active Record.\n \n After reading this guide, you will know:\n \n * How to set up database encryption with Active Record.\n * How to migrate unencrypted data.\n * How to make different encryption schemes coexist.\n-* How to use the API.\n-* How to configure the library and how to extend it.\n+* More about advanced concepts like Encryption Contexts and Key Providers.\n \n --------------------------------------------------------------------------------\n \n-Active Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\n+Active Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.",
        "comment_created_at": "2025-07-01T19:30:46+00:00",
        "comment_author": "bhumi1102",
        "comment_body": "Yeah I guess so. OR I'm thinking about just deleting that last sentence, it doesn't add anything new (we already mention application-level earlier in this paragraph)",
        "pr_file_module": null
      },
      {
        "comment_id": "2178405868",
        "repo_full_name": "rails/rails",
        "pr_number": 55188,
        "pr_file": "guides/source/active_record_encryption.md",
        "discussion_id": "2169806449",
        "commented_code": "@@ -3,151 +3,174 @@\n Active Record Encryption\n ========================\n \n-This guide covers encrypting your database information using Active Record.\n+This guide covers how to encrypt data in your database using Active Record.\n \n After reading this guide, you will know:\n \n * How to set up database encryption with Active Record.\n * How to migrate unencrypted data.\n * How to make different encryption schemes coexist.\n-* How to use the API.\n-* How to configure the library and how to extend it.\n+* More about advanced concepts like Encryption Contexts and Key Providers.\n \n --------------------------------------------------------------------------------\n \n-Active Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\n+Active Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.",
        "comment_created_at": "2025-07-01T19:45:51+00:00",
        "comment_author": "bhumi1102",
        "comment_body": "Removed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169865628",
    "pr_number": 55188,
    "pr_file": "guides/source/active_record_encryption.md",
    "created_at": "2025-06-26T19:54:32+00:00",
    "commented_code": "Active Record Encryption\n========================\n\nThis guide covers encrypting your database information using Active Record.\nThis guide covers how to encrypt data in your database using Active Record.\n\nAfter reading this guide, you will know:\n\n* How to set up database encryption with Active Record.\n* How to migrate unencrypted data.\n* How to make different encryption schemes coexist.\n* How to use the API.\n* How to configure the library and how to extend it.\n* More about advanced concepts like Encryption Contexts and Key Providers.\n\n--------------------------------------------------------------------------------\n\nActive Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\nActive Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.\n\n## Why Encrypt Data at the Application Level?\n\nActive Record Encryption exists to protect sensitive information in your application. A typical example is personally identifiable information from users. But why would you want application-level encryption if you are already encrypting your database at rest?\nEncrypting specific attributes at the application-level adds an additional security layer. For example, if someone gains access to your application logs or database backup, the encrypted data remains unreadable. It also helps avoid accidental exposure of sensitive information in your application console or logs.\n\nAs an immediate practical benefit, encrypting sensitive attributes adds an additional security layer. For example, if an attacker gained access to your database, a snapshot of it, or your application logs, they wouldn't be able to make sense of the encrypted information. Additionally, encryption can prevent developers from unintentionally exposing users' sensitive data in application logs.\nMost importantly, this feature lets you explicitly define what data is sensitive in your code. This enables precise access control throughout your application and any connected services. For example, you can use tools like [console1984](https://github.com/basecamp/console1984) to restrict decrypted data access in the Rails console. You can also take advantage of automatic [parameter filtering](#filtering-params-named-as-encrypted-columns) for encrypted fields.\n\nBut more importantly, by using Active Record Encryption, you define what constitutes sensitive information in your application at the code level. Active Record Encryption enables granular control of data access in your application and services consuming data from your application. For example, consider [auditable Rails consoles that protect encrypted data](https://github.com/basecamp/console1984) or check the built-in system to [filter controller params automatically](#filtering-params-named-as-encrypted-columns).\nNOTE: Encryption requires extra storage space because the encrypted value will\nbe larger than the original value. This overhead is negligible at larger sizes.\nActive Record Encryption also uses compression by default, which can offer up to\n30% storage savings over the unencrypted version for larger payloads.\n\n## Basic Usage\n## Setup\n\nTo start using Active Record Encryption, you need to generate keys and declare attributes you want to encrypt in the Model.\n\n### Setup\n### Generate Encryption Key\n\nRun `bin/rails db:encryption:init` to generate a random key set:\nYou can generate a random key set by running `bin/rails db:encryption:init`:\n\n```bash\n$ bin/rails db:encryption:init\nAdd this entry to the credentials of the target environment:\n```\n\nThen, add the keys to the credentials file of the target environment:\n\n```yml\n# config/credentials.yml\nactive_record_encryption:\n  primary_key: EGY8WhulUOXixybod7ZWwMIL68R9o5kC\n  deterministic_key: aPA5XyALhf75NNnMzaspW7akTfZp0lPY\n  key_derivation_salt: xEY0dt6TZcAMg52K7O84wYzkjvbA62Hz\n```\n\nThese values can be stored by copying and pasting the generated values into your existing [Rails credentials](/security.html#custom-credentials). Alternatively, these values can be configured from other sources, such as environment variables:\nThese values can be stored by copying and pasting the generated values into your existing [Rails credentials](/security.html#custom-credentials). Then, you can set the credentials in a config file:\n\n```ruby\n# config/appication.rb\nconfig.active_record.encryption.primary_key = Rails.application.credentials.dig(:active_record_encryption, :primary_key)\nconfig.active_record.encryption.deterministic_key = Rails.application.credentials.dig(:active_record_encryption, :deterministic_key)\nconfig.active_record.encryption.key_derivation_salt = Rails.application.credentials.dig(:active_record_encryption, :key_derivation_salt)\n```\n\nAlternatively, these values can be configured from other sources, such as environment variables:\n\n```ruby\n# config/application.rb\nconfig.active_record.encryption.primary_key = ENV[\"ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY\"]\nconfig.active_record.encryption.deterministic_key = ENV[\"ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY\"]\nconfig.active_record.encryption.key_derivation_salt = ENV[\"ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT\"]\n```\n\nNOTE: These generated values are 32 bytes in length. If you generate these yourself, the minimum lengths you should use are 12 bytes for the primary key (this will be used to derive the AES 32 bytes key) and 20 bytes for the salt.\nWARNING: It's recommended to use Rails built-in credentials support to store keys. If you set them manually via configuration properties, make sure you don't commit them with your code (e.g. use environment variables).\n\nNOTE: The generated values are 32 bytes in length. If you generate these\nyourself, the recommended minimum length is 12 bytes for the primary key\nand 20 bytes for the [salt](https://en.wikipedia.org/wiki/Salt_(cryptography)).\n\n### Declaration of Encrypted Attributes\nOnce the keys are generated and stored, you can start using Active Record Encryption by declaring attributes to be encrypted.\n\nEncryptable attributes are defined at the model level. These are regular Active Record attributes backed by a column with the same name.\n### Declare Encrypted Attributes\n\nThe [`encrypts` method](https://api.rubyonrails.org/classes/ActiveRecord/Encryption/EncryptableRecord.html#method-i-encrypts) defines the attributes to be encrypted at the model level. These are regular Active Record attributes backed by a column with the same name.\n\n```ruby\nclass Article < ApplicationRecord\n  encrypts :title\nend\n````\n```\n\nThe library will transparently encrypt these attributes before saving them in the database and will decrypt them upon retrieval:\nActive Record Encryption will transparently encrypt these attributes before saving them to the database and will decrypt them upon retrieval. For example,\n\n```ruby\narticle = Article.create title: \"Encrypt it all!\"\narticle.title # => \"Encrypt it all!\"\n```\n\nBut, under the hood, the executed SQL looks like this:\nHowever, in the Rails console, the executed SQL looks like this:\n\n```sql\nINSERT INTO `articles` (`title`) VALUES ('{\\\"p\\\":\\\"n7J0/ol+a7DRMeaE\\\",\\\"h\\\":{\\\"iv\\\":\\\"DXZMDWUKfp3bg/Yu\\\",\\\"at\\\":\\\"X1/YjMHbHD4talgF9dt61A==\\\"}}')\n```\n\n#### Important: About Storage and Column Size\n\nEncryption requires extra space because of Base64 encoding and the metadata stored along with the encrypted payloads. When using the built-in envelope encryption key provider, you can estimate the worst-case overhead at around 255 bytes. This overhead is negligible at larger sizes. Not only because it gets diluted but because the library uses compression by default, which can offer up to 30% storage savings over the unencrypted version for larger payloads.\n\nThere is an important concern about string column sizes: in modern databases the column size determines the *number of characters* it can allocate, not the number of bytes. For example, with UTF-8, each character can take up to four bytes, so, potentially, a column in a database using UTF-8 can store up to four times its size in terms of *number of bytes*. Now, encrypted payloads are binary strings serialized as Base64, so they can be stored in regular `string` columns. Because they are a sequence of ASCII bytes, an encrypted column can take up to four times its clear version size. So, even if the bytes stored in the database are the same, the column must be four times bigger.\n\nIn practice, this means:\nThe value inserted is the encrypted value for the `title` attribute.\n\n* When encrypting short texts written in Western alphabets (mostly ASCII characters), you should account for that 255 additional overhead when defining the column size.\n* When encrypting short texts written in non-Western alphabets, such as Cyrillic, you should multiply the column size by 4. Notice that the storage overhead is 255 bytes at most.\n* When encrypting long texts, you can ignore column size concerns.\n### Querying Encrypted Data: Deterministic vs. Non-deterministic Encryption\n\nSome examples:\nBy default, Active Record Encryption is non-deterministic, which means that encrypting the same value with the same key twice will result in *different* encrypted values (aka ciphertexts). The non-deterministic approach improves security by making crypto-analysis of ciphertexts harder. However, it also means that queries (such as `WHERE title = \"Encrypt it all!\"`) on encrypted values are not possible, since the same value can result in a different encrypted value that does not match the previously stored ciphertext.\n\n| Content to encrypt                                | Original column size | Recommended encrypted column size | Storage overhead (worst case) |\n| ------------------------------------------------- | -------------------- | --------------------------------- | ----------------------------- |\n| Email addresses                                   | string(255)          | string(510)                       | 255 bytes                     |\n| Short sequence of emojis                          | string(255)          | string(1020)                      | 255 bytes                     |\n| Summary of texts written in non-western alphabets | string(500)          | string(2000)                      | 255 bytes                     |\n| Arbitrary long text                               | text                 | text                              | negligible                    |\n\n### Deterministic and Non-deterministic Encryption\n\nBy default, Active Record Encryption uses a non-deterministic approach to encryption. Non-deterministic, in this context, means that encrypting the same content with the same password twice will result in different ciphertexts. This approach improves security by making crypto-analysis of ciphertexts harder, and querying the database impossible.\n\nYou can use the `deterministic:`  option to generate initialization vectors in a deterministic way, effectively enabling querying encrypted data.\nIf you need to query the encrypted `email` field on the `Author` model below, you can use deterministic encryption:\n\n```ruby\nclass Author < ApplicationRecord\n  encrypts :email, deterministic: true\nend\n\nAuthor.find_by_email(\"some@email.com\") # You can query the model normally\n# You can only query by email if using deterministic encryption.\nAuthor.find_by_email(\"tolkien@email.com\")\n```\n\nThe non-deterministic approach is recommended unless you need to query the data.\nThe `deterministic:` option generates initialization vectors in a deterministic\nway, meaning it will produce the same encrypted output given the same input\nvalue. This makes querying encrypted attributes possible, like the `email`\nabove.\n\nNOTE: In non-deterministic mode, Active Record uses AES-GCM with a 256-bits key and a random initialization vector. In deterministic mode, it also uses AES-GCM, but the initialization vector is generated as an HMAC-SHA-256 digest of the key and contents to encrypt.\nThe `:deterministic` option allows for querying by trading off lesser security.\nThe data is still encrypted but the determinism makes crypto-analysis easier.\nFor this reason, non-deterministic encryption is recommended for all data unless\nyou need to query by an attribute.\n\nNOTE: You can disable deterministic encryption by omitting a `deterministic_key`.\nNOTE: In non-deterministic mode, Active Record uses\n[AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)-[GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)\nwith a 256-bits key and a random initialization vector. In deterministic mode,\nit also uses AES-GCM, but the initialization vector is not random. It is generated as an a function of the key and the plaintext content ([HMAC](https://en.wikipedia.org/wiki/HMAC)-SHA-256 digest of the two).\n\n## Features\nNOTE: If you do not define a `deterministic_key`, then you have effectively disabled deterministic encryption.\n\n### Action Text\n## Basic Usage\n\nYou can encrypt Action Text attributes by passing `encrypted: true` in their declaration.\n### Ignoring Case\n\nYou might need to ignore the case when querying deterministically encrypted data. Two approaches make accomplishing this easier:\n\nYou can use the `:downcase` option when declaring the encrypted attribute to downcase the content before encryption occurs.\n\n```ruby\nclass Message < ApplicationRecord\n  has_rich_text :content, encrypted: true\nclass Person\n  encrypts :email_address, deterministic: true, downcase: true\nend\n```\n\nNOTE: Passing individual encryption options to Action Text attributes is not supported yet. It will use non-deterministic encryption with the global encryption options configured.\n\n### Fixtures\n\nYou can get Rails fixtures encrypted automatically by adding this option to your `test.rb`:\nWhen using `:downcase`, the original case is lost. In some situations, you might\nwant to ignore the case only when querying while also storing the original case.\nFor those situations, you can use the `:ignore_case` option. This requires you\nto add a new column named `original_<column_name>` to store the content with the\ncase unchanged:\n\n```ruby\nconfig.active_record.encryption.encrypt_fixtures = true\nclass Label\n  encrypts :name, deterministic: true, ignore_case: true # the content with the original case will be stored in the column `original_name`",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2169865628",
        "repo_full_name": "rails/rails",
        "pr_number": 55188,
        "pr_file": "guides/source/active_record_encryption.md",
        "discussion_id": "2169865628",
        "commented_code": "@@ -3,151 +3,174 @@\n Active Record Encryption\n ========================\n \n-This guide covers encrypting your database information using Active Record.\n+This guide covers how to encrypt data in your database using Active Record.\n \n After reading this guide, you will know:\n \n * How to set up database encryption with Active Record.\n * How to migrate unencrypted data.\n * How to make different encryption schemes coexist.\n-* How to use the API.\n-* How to configure the library and how to extend it.\n+* More about advanced concepts like Encryption Contexts and Key Providers.\n \n --------------------------------------------------------------------------------\n \n-Active Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\n+Active Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.\n \n ## Why Encrypt Data at the Application Level?\n \n-Active Record Encryption exists to protect sensitive information in your application. A typical example is personally identifiable information from users. But why would you want application-level encryption if you are already encrypting your database at rest?\n+Encrypting specific attributes at the application-level adds an additional security layer. For example, if someone gains access to your application logs or database backup, the encrypted data remains unreadable. It also helps avoid accidental exposure of sensitive information in your application console or logs.\n \n-As an immediate practical benefit, encrypting sensitive attributes adds an additional security layer. For example, if an attacker gained access to your database, a snapshot of it, or your application logs, they wouldn't be able to make sense of the encrypted information. Additionally, encryption can prevent developers from unintentionally exposing users' sensitive data in application logs.\n+Most importantly, this feature lets you explicitly define what data is sensitive in your code. This enables precise access control throughout your application and any connected services. For example, you can use tools like [console1984](https://github.com/basecamp/console1984) to restrict decrypted data access in the Rails console. You can also take advantage of automatic [parameter filtering](#filtering-params-named-as-encrypted-columns) for encrypted fields.\n \n-But more importantly, by using Active Record Encryption, you define what constitutes sensitive information in your application at the code level. Active Record Encryption enables granular control of data access in your application and services consuming data from your application. For example, consider [auditable Rails consoles that protect encrypted data](https://github.com/basecamp/console1984) or check the built-in system to [filter controller params automatically](#filtering-params-named-as-encrypted-columns).\n+NOTE: Encryption requires extra storage space because the encrypted value will\n+be larger than the original value. This overhead is negligible at larger sizes.\n+Active Record Encryption also uses compression by default, which can offer up to\n+30% storage savings over the unencrypted version for larger payloads.\n \n-## Basic Usage\n+## Setup\n+\n+To start using Active Record Encryption, you need to generate keys and declare attributes you want to encrypt in the Model.\n \n-### Setup\n+### Generate Encryption Key\n \n-Run `bin/rails db:encryption:init` to generate a random key set:\n+You can generate a random key set by running `bin/rails db:encryption:init`:\n \n ```bash\n $ bin/rails db:encryption:init\n-Add this entry to the credentials of the target environment:\n+```\n \n+Then, add the keys to the credentials file of the target environment:\n+\n+```yml\n+# config/credentials.yml\n active_record_encryption:\n   primary_key: EGY8WhulUOXixybod7ZWwMIL68R9o5kC\n   deterministic_key: aPA5XyALhf75NNnMzaspW7akTfZp0lPY\n   key_derivation_salt: xEY0dt6TZcAMg52K7O84wYzkjvbA62Hz\n ```\n \n-These values can be stored by copying and pasting the generated values into your existing [Rails credentials](/security.html#custom-credentials). Alternatively, these values can be configured from other sources, such as environment variables:\n+These values can be stored by copying and pasting the generated values into your existing [Rails credentials](/security.html#custom-credentials). Then, you can set the credentials in a config file:\n \n ```ruby\n+# config/appication.rb\n+config.active_record.encryption.primary_key = Rails.application.credentials.dig(:active_record_encryption, :primary_key)\n+config.active_record.encryption.deterministic_key = Rails.application.credentials.dig(:active_record_encryption, :deterministic_key)\n+config.active_record.encryption.key_derivation_salt = Rails.application.credentials.dig(:active_record_encryption, :key_derivation_salt)\n+```\n+\n+Alternatively, these values can be configured from other sources, such as environment variables:\n+\n+```ruby\n+# config/application.rb\n config.active_record.encryption.primary_key = ENV[\"ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY\"]\n config.active_record.encryption.deterministic_key = ENV[\"ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY\"]\n config.active_record.encryption.key_derivation_salt = ENV[\"ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT\"]\n ```\n \n-NOTE: These generated values are 32 bytes in length. If you generate these yourself, the minimum lengths you should use are 12 bytes for the primary key (this will be used to derive the AES 32 bytes key) and 20 bytes for the salt.\n+WARNING: It's recommended to use Rails built-in credentials support to store keys. If you set them manually via configuration properties, make sure you don't commit them with your code (e.g. use environment variables).\n+\n+NOTE: The generated values are 32 bytes in length. If you generate these\n+yourself, the recommended minimum length is 12 bytes for the primary key\n+and 20 bytes for the [salt](https://en.wikipedia.org/wiki/Salt_(cryptography)).\n \n-### Declaration of Encrypted Attributes\n+Once the keys are generated and stored, you can start using Active Record Encryption by declaring attributes to be encrypted.\n \n-Encryptable attributes are defined at the model level. These are regular Active Record attributes backed by a column with the same name.\n+### Declare Encrypted Attributes\n+\n+The [`encrypts` method](https://api.rubyonrails.org/classes/ActiveRecord/Encryption/EncryptableRecord.html#method-i-encrypts) defines the attributes to be encrypted at the model level. These are regular Active Record attributes backed by a column with the same name.\n \n ```ruby\n class Article < ApplicationRecord\n   encrypts :title\n end\n-````\n+```\n \n-The library will transparently encrypt these attributes before saving them in the database and will decrypt them upon retrieval:\n+Active Record Encryption will transparently encrypt these attributes before saving them to the database and will decrypt them upon retrieval. For example,\n \n ```ruby\n article = Article.create title: \"Encrypt it all!\"\n article.title # => \"Encrypt it all!\"\n ```\n \n-But, under the hood, the executed SQL looks like this:\n+However, in the Rails console, the executed SQL looks like this:\n \n ```sql\n INSERT INTO `articles` (`title`) VALUES ('{\\\"p\\\":\\\"n7J0/ol+a7DRMeaE\\\",\\\"h\\\":{\\\"iv\\\":\\\"DXZMDWUKfp3bg/Yu\\\",\\\"at\\\":\\\"X1/YjMHbHD4talgF9dt61A==\\\"}}')\n ```\n \n-#### Important: About Storage and Column Size\n-\n-Encryption requires extra space because of Base64 encoding and the metadata stored along with the encrypted payloads. When using the built-in envelope encryption key provider, you can estimate the worst-case overhead at around 255 bytes. This overhead is negligible at larger sizes. Not only because it gets diluted but because the library uses compression by default, which can offer up to 30% storage savings over the unencrypted version for larger payloads.\n-\n-There is an important concern about string column sizes: in modern databases the column size determines the *number of characters* it can allocate, not the number of bytes. For example, with UTF-8, each character can take up to four bytes, so, potentially, a column in a database using UTF-8 can store up to four times its size in terms of *number of bytes*. Now, encrypted payloads are binary strings serialized as Base64, so they can be stored in regular `string` columns. Because they are a sequence of ASCII bytes, an encrypted column can take up to four times its clear version size. So, even if the bytes stored in the database are the same, the column must be four times bigger.\n-\n-In practice, this means:\n+The value inserted is the encrypted value for the `title` attribute.\n \n-* When encrypting short texts written in Western alphabets (mostly ASCII characters), you should account for that 255 additional overhead when defining the column size.\n-* When encrypting short texts written in non-Western alphabets, such as Cyrillic, you should multiply the column size by 4. Notice that the storage overhead is 255 bytes at most.\n-* When encrypting long texts, you can ignore column size concerns.\n+### Querying Encrypted Data: Deterministic vs. Non-deterministic Encryption\n \n-Some examples:\n+By default, Active Record Encryption is non-deterministic, which means that encrypting the same value with the same key twice will result in *different* encrypted values (aka ciphertexts). The non-deterministic approach improves security by making crypto-analysis of ciphertexts harder. However, it also means that queries (such as `WHERE title = \"Encrypt it all!\"`) on encrypted values are not possible, since the same value can result in a different encrypted value that does not match the previously stored ciphertext.\n \n-| Content to encrypt                                | Original column size | Recommended encrypted column size | Storage overhead (worst case) |\n-| ------------------------------------------------- | -------------------- | --------------------------------- | ----------------------------- |\n-| Email addresses                                   | string(255)          | string(510)                       | 255 bytes                     |\n-| Short sequence of emojis                          | string(255)          | string(1020)                      | 255 bytes                     |\n-| Summary of texts written in non-western alphabets | string(500)          | string(2000)                      | 255 bytes                     |\n-| Arbitrary long text                               | text                 | text                              | negligible                    |\n-\n-### Deterministic and Non-deterministic Encryption\n-\n-By default, Active Record Encryption uses a non-deterministic approach to encryption. Non-deterministic, in this context, means that encrypting the same content with the same password twice will result in different ciphertexts. This approach improves security by making crypto-analysis of ciphertexts harder, and querying the database impossible.\n-\n-You can use the `deterministic:`  option to generate initialization vectors in a deterministic way, effectively enabling querying encrypted data.\n+If you need to query the encrypted `email` field on the `Author` model below, you can use deterministic encryption:\n \n ```ruby\n class Author < ApplicationRecord\n   encrypts :email, deterministic: true\n end\n \n-Author.find_by_email(\"some@email.com\") # You can query the model normally\n+# You can only query by email if using deterministic encryption.\n+Author.find_by_email(\"tolkien@email.com\")\n ```\n \n-The non-deterministic approach is recommended unless you need to query the data.\n+The `deterministic:` option generates initialization vectors in a deterministic\n+way, meaning it will produce the same encrypted output given the same input\n+value. This makes querying encrypted attributes possible, like the `email`\n+above.\n \n-NOTE: In non-deterministic mode, Active Record uses AES-GCM with a 256-bits key and a random initialization vector. In deterministic mode, it also uses AES-GCM, but the initialization vector is generated as an HMAC-SHA-256 digest of the key and contents to encrypt.\n+The `:deterministic` option allows for querying by trading off lesser security.\n+The data is still encrypted but the determinism makes crypto-analysis easier.\n+For this reason, non-deterministic encryption is recommended for all data unless\n+you need to query by an attribute.\n \n-NOTE: You can disable deterministic encryption by omitting a `deterministic_key`.\n+NOTE: In non-deterministic mode, Active Record uses\n+[AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)-[GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)\n+with a 256-bits key and a random initialization vector. In deterministic mode,\n+it also uses AES-GCM, but the initialization vector is not random. It is generated as an a function of the key and the plaintext content ([HMAC](https://en.wikipedia.org/wiki/HMAC)-SHA-256 digest of the two).\n \n-## Features\n+NOTE: If you do not define a `deterministic_key`, then you have effectively disabled deterministic encryption.\n \n-### Action Text\n+## Basic Usage\n \n-You can encrypt Action Text attributes by passing `encrypted: true` in their declaration.\n+### Ignoring Case\n+\n+You might need to ignore the case when querying deterministically encrypted data. Two approaches make accomplishing this easier:\n+\n+You can use the `:downcase` option when declaring the encrypted attribute to downcase the content before encryption occurs.\n \n ```ruby\n-class Message < ApplicationRecord\n-  has_rich_text :content, encrypted: true\n+class Person\n+  encrypts :email_address, deterministic: true, downcase: true\n end\n ```\n \n-NOTE: Passing individual encryption options to Action Text attributes is not supported yet. It will use non-deterministic encryption with the global encryption options configured.\n-\n-### Fixtures\n-\n-You can get Rails fixtures encrypted automatically by adding this option to your `test.rb`:\n+When using `:downcase`, the original case is lost. In some situations, you might\n+want to ignore the case only when querying while also storing the original case.\n+For those situations, you can use the `:ignore_case` option. This requires you\n+to add a new column named `original_<column_name>` to store the content with the\n+case unchanged:\n \n ```ruby\n-config.active_record.encryption.encrypt_fixtures = true\n+class Label\n+  encrypts :name, deterministic: true, ignore_case: true # the content with the original case will be stored in the column `original_name`",
        "comment_created_at": "2025-06-26T19:54:32+00:00",
        "comment_author": "p8",
        "comment_body": "```suggestion\r\n  encrypts :name, deterministic: true, ignore_case: true # the encrypted content with the original case will be stored in the column `original_name`\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2178454983",
        "repo_full_name": "rails/rails",
        "pr_number": 55188,
        "pr_file": "guides/source/active_record_encryption.md",
        "discussion_id": "2169865628",
        "commented_code": "@@ -3,151 +3,174 @@\n Active Record Encryption\n ========================\n \n-This guide covers encrypting your database information using Active Record.\n+This guide covers how to encrypt data in your database using Active Record.\n \n After reading this guide, you will know:\n \n * How to set up database encryption with Active Record.\n * How to migrate unencrypted data.\n * How to make different encryption schemes coexist.\n-* How to use the API.\n-* How to configure the library and how to extend it.\n+* More about advanced concepts like Encryption Contexts and Key Providers.\n \n --------------------------------------------------------------------------------\n \n-Active Record supports application-level encryption. It works by declaring which attributes should be encrypted and seamlessly encrypting and decrypting them when necessary. The encryption layer sits between the database and the application. The application will access unencrypted data, but the database will store it encrypted.\n+Active Record Encryption exists to protect sensitive information in your application, such as personally identifiable information (PII) about your users. Active Record supports application-level encryption by allowing you to declare which attributes should be encrypted. It enables transparent encryption and decryption of attributes when saving and retrieving data. The encryption layer sits between the application and the database.\n \n ## Why Encrypt Data at the Application Level?\n \n-Active Record Encryption exists to protect sensitive information in your application. A typical example is personally identifiable information from users. But why would you want application-level encryption if you are already encrypting your database at rest?\n+Encrypting specific attributes at the application-level adds an additional security layer. For example, if someone gains access to your application logs or database backup, the encrypted data remains unreadable. It also helps avoid accidental exposure of sensitive information in your application console or logs.\n \n-As an immediate practical benefit, encrypting sensitive attributes adds an additional security layer. For example, if an attacker gained access to your database, a snapshot of it, or your application logs, they wouldn't be able to make sense of the encrypted information. Additionally, encryption can prevent developers from unintentionally exposing users' sensitive data in application logs.\n+Most importantly, this feature lets you explicitly define what data is sensitive in your code. This enables precise access control throughout your application and any connected services. For example, you can use tools like [console1984](https://github.com/basecamp/console1984) to restrict decrypted data access in the Rails console. You can also take advantage of automatic [parameter filtering](#filtering-params-named-as-encrypted-columns) for encrypted fields.\n \n-But more importantly, by using Active Record Encryption, you define what constitutes sensitive information in your application at the code level. Active Record Encryption enables granular control of data access in your application and services consuming data from your application. For example, consider [auditable Rails consoles that protect encrypted data](https://github.com/basecamp/console1984) or check the built-in system to [filter controller params automatically](#filtering-params-named-as-encrypted-columns).\n+NOTE: Encryption requires extra storage space because the encrypted value will\n+be larger than the original value. This overhead is negligible at larger sizes.\n+Active Record Encryption also uses compression by default, which can offer up to\n+30% storage savings over the unencrypted version for larger payloads.\n \n-## Basic Usage\n+## Setup\n+\n+To start using Active Record Encryption, you need to generate keys and declare attributes you want to encrypt in the Model.\n \n-### Setup\n+### Generate Encryption Key\n \n-Run `bin/rails db:encryption:init` to generate a random key set:\n+You can generate a random key set by running `bin/rails db:encryption:init`:\n \n ```bash\n $ bin/rails db:encryption:init\n-Add this entry to the credentials of the target environment:\n+```\n \n+Then, add the keys to the credentials file of the target environment:\n+\n+```yml\n+# config/credentials.yml\n active_record_encryption:\n   primary_key: EGY8WhulUOXixybod7ZWwMIL68R9o5kC\n   deterministic_key: aPA5XyALhf75NNnMzaspW7akTfZp0lPY\n   key_derivation_salt: xEY0dt6TZcAMg52K7O84wYzkjvbA62Hz\n ```\n \n-These values can be stored by copying and pasting the generated values into your existing [Rails credentials](/security.html#custom-credentials). Alternatively, these values can be configured from other sources, such as environment variables:\n+These values can be stored by copying and pasting the generated values into your existing [Rails credentials](/security.html#custom-credentials). Then, you can set the credentials in a config file:\n \n ```ruby\n+# config/appication.rb\n+config.active_record.encryption.primary_key = Rails.application.credentials.dig(:active_record_encryption, :primary_key)\n+config.active_record.encryption.deterministic_key = Rails.application.credentials.dig(:active_record_encryption, :deterministic_key)\n+config.active_record.encryption.key_derivation_salt = Rails.application.credentials.dig(:active_record_encryption, :key_derivation_salt)\n+```\n+\n+Alternatively, these values can be configured from other sources, such as environment variables:\n+\n+```ruby\n+# config/application.rb\n config.active_record.encryption.primary_key = ENV[\"ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY\"]\n config.active_record.encryption.deterministic_key = ENV[\"ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY\"]\n config.active_record.encryption.key_derivation_salt = ENV[\"ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT\"]\n ```\n \n-NOTE: These generated values are 32 bytes in length. If you generate these yourself, the minimum lengths you should use are 12 bytes for the primary key (this will be used to derive the AES 32 bytes key) and 20 bytes for the salt.\n+WARNING: It's recommended to use Rails built-in credentials support to store keys. If you set them manually via configuration properties, make sure you don't commit them with your code (e.g. use environment variables).\n+\n+NOTE: The generated values are 32 bytes in length. If you generate these\n+yourself, the recommended minimum length is 12 bytes for the primary key\n+and 20 bytes for the [salt](https://en.wikipedia.org/wiki/Salt_(cryptography)).\n \n-### Declaration of Encrypted Attributes\n+Once the keys are generated and stored, you can start using Active Record Encryption by declaring attributes to be encrypted.\n \n-Encryptable attributes are defined at the model level. These are regular Active Record attributes backed by a column with the same name.\n+### Declare Encrypted Attributes\n+\n+The [`encrypts` method](https://api.rubyonrails.org/classes/ActiveRecord/Encryption/EncryptableRecord.html#method-i-encrypts) defines the attributes to be encrypted at the model level. These are regular Active Record attributes backed by a column with the same name.\n \n ```ruby\n class Article < ApplicationRecord\n   encrypts :title\n end\n-````\n+```\n \n-The library will transparently encrypt these attributes before saving them in the database and will decrypt them upon retrieval:\n+Active Record Encryption will transparently encrypt these attributes before saving them to the database and will decrypt them upon retrieval. For example,\n \n ```ruby\n article = Article.create title: \"Encrypt it all!\"\n article.title # => \"Encrypt it all!\"\n ```\n \n-But, under the hood, the executed SQL looks like this:\n+However, in the Rails console, the executed SQL looks like this:\n \n ```sql\n INSERT INTO `articles` (`title`) VALUES ('{\\\"p\\\":\\\"n7J0/ol+a7DRMeaE\\\",\\\"h\\\":{\\\"iv\\\":\\\"DXZMDWUKfp3bg/Yu\\\",\\\"at\\\":\\\"X1/YjMHbHD4talgF9dt61A==\\\"}}')\n ```\n \n-#### Important: About Storage and Column Size\n-\n-Encryption requires extra space because of Base64 encoding and the metadata stored along with the encrypted payloads. When using the built-in envelope encryption key provider, you can estimate the worst-case overhead at around 255 bytes. This overhead is negligible at larger sizes. Not only because it gets diluted but because the library uses compression by default, which can offer up to 30% storage savings over the unencrypted version for larger payloads.\n-\n-There is an important concern about string column sizes: in modern databases the column size determines the *number of characters* it can allocate, not the number of bytes. For example, with UTF-8, each character can take up to four bytes, so, potentially, a column in a database using UTF-8 can store up to four times its size in terms of *number of bytes*. Now, encrypted payloads are binary strings serialized as Base64, so they can be stored in regular `string` columns. Because they are a sequence of ASCII bytes, an encrypted column can take up to four times its clear version size. So, even if the bytes stored in the database are the same, the column must be four times bigger.\n-\n-In practice, this means:\n+The value inserted is the encrypted value for the `title` attribute.\n \n-* When encrypting short texts written in Western alphabets (mostly ASCII characters), you should account for that 255 additional overhead when defining the column size.\n-* When encrypting short texts written in non-Western alphabets, such as Cyrillic, you should multiply the column size by 4. Notice that the storage overhead is 255 bytes at most.\n-* When encrypting long texts, you can ignore column size concerns.\n+### Querying Encrypted Data: Deterministic vs. Non-deterministic Encryption\n \n-Some examples:\n+By default, Active Record Encryption is non-deterministic, which means that encrypting the same value with the same key twice will result in *different* encrypted values (aka ciphertexts). The non-deterministic approach improves security by making crypto-analysis of ciphertexts harder. However, it also means that queries (such as `WHERE title = \"Encrypt it all!\"`) on encrypted values are not possible, since the same value can result in a different encrypted value that does not match the previously stored ciphertext.\n \n-| Content to encrypt                                | Original column size | Recommended encrypted column size | Storage overhead (worst case) |\n-| ------------------------------------------------- | -------------------- | --------------------------------- | ----------------------------- |\n-| Email addresses                                   | string(255)          | string(510)                       | 255 bytes                     |\n-| Short sequence of emojis                          | string(255)          | string(1020)                      | 255 bytes                     |\n-| Summary of texts written in non-western alphabets | string(500)          | string(2000)                      | 255 bytes                     |\n-| Arbitrary long text                               | text                 | text                              | negligible                    |\n-\n-### Deterministic and Non-deterministic Encryption\n-\n-By default, Active Record Encryption uses a non-deterministic approach to encryption. Non-deterministic, in this context, means that encrypting the same content with the same password twice will result in different ciphertexts. This approach improves security by making crypto-analysis of ciphertexts harder, and querying the database impossible.\n-\n-You can use the `deterministic:`  option to generate initialization vectors in a deterministic way, effectively enabling querying encrypted data.\n+If you need to query the encrypted `email` field on the `Author` model below, you can use deterministic encryption:\n \n ```ruby\n class Author < ApplicationRecord\n   encrypts :email, deterministic: true\n end\n \n-Author.find_by_email(\"some@email.com\") # You can query the model normally\n+# You can only query by email if using deterministic encryption.\n+Author.find_by_email(\"tolkien@email.com\")\n ```\n \n-The non-deterministic approach is recommended unless you need to query the data.\n+The `deterministic:` option generates initialization vectors in a deterministic\n+way, meaning it will produce the same encrypted output given the same input\n+value. This makes querying encrypted attributes possible, like the `email`\n+above.\n \n-NOTE: In non-deterministic mode, Active Record uses AES-GCM with a 256-bits key and a random initialization vector. In deterministic mode, it also uses AES-GCM, but the initialization vector is generated as an HMAC-SHA-256 digest of the key and contents to encrypt.\n+The `:deterministic` option allows for querying by trading off lesser security.\n+The data is still encrypted but the determinism makes crypto-analysis easier.\n+For this reason, non-deterministic encryption is recommended for all data unless\n+you need to query by an attribute.\n \n-NOTE: You can disable deterministic encryption by omitting a `deterministic_key`.\n+NOTE: In non-deterministic mode, Active Record uses\n+[AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)-[GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)\n+with a 256-bits key and a random initialization vector. In deterministic mode,\n+it also uses AES-GCM, but the initialization vector is not random. It is generated as an a function of the key and the plaintext content ([HMAC](https://en.wikipedia.org/wiki/HMAC)-SHA-256 digest of the two).\n \n-## Features\n+NOTE: If you do not define a `deterministic_key`, then you have effectively disabled deterministic encryption.\n \n-### Action Text\n+## Basic Usage\n \n-You can encrypt Action Text attributes by passing `encrypted: true` in their declaration.\n+### Ignoring Case\n+\n+You might need to ignore the case when querying deterministically encrypted data. Two approaches make accomplishing this easier:\n+\n+You can use the `:downcase` option when declaring the encrypted attribute to downcase the content before encryption occurs.\n \n ```ruby\n-class Message < ApplicationRecord\n-  has_rich_text :content, encrypted: true\n+class Person\n+  encrypts :email_address, deterministic: true, downcase: true\n end\n ```\n \n-NOTE: Passing individual encryption options to Action Text attributes is not supported yet. It will use non-deterministic encryption with the global encryption options configured.\n-\n-### Fixtures\n-\n-You can get Rails fixtures encrypted automatically by adding this option to your `test.rb`:\n+When using `:downcase`, the original case is lost. In some situations, you might\n+want to ignore the case only when querying while also storing the original case.\n+For those situations, you can use the `:ignore_case` option. This requires you\n+to add a new column named `original_<column_name>` to store the content with the\n+case unchanged:\n \n ```ruby\n-config.active_record.encryption.encrypt_fixtures = true\n+class Label\n+  encrypts :name, deterministic: true, ignore_case: true # the content with the original case will be stored in the column `original_name`",
        "comment_created_at": "2025-07-01T20:24:04+00:00",
        "comment_author": "bhumi1102",
        "comment_body": "updated manually",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173929875",
    "pr_number": 55254,
    "pr_file": "guides/source/sign_up_and_settings.md",
    "created_at": "2025-06-29T21:18:04+00:00",
    "commented_code": "**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n\nSign Up and Settings\n========================\n\nThis guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n\nAfter reading this guide, you will know how to:\n\n* Add user Sign Up\n* Rate limit controller actions\n* Create a nested layout\n* Separate controllers by role (users and admins)\n* Write tests for users with different roles\n\n--------------------------------------------------------------------------------\n\nIntroduction\n------------\n\nOne of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n\nThis feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n\nLet's get started!\n\nAdding Sign Up\n--------------\n\nWe've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.\n\n### Adding Names To Users\n\nIt's also a good idea to collect the user's name at sign up. This allows us to personalize their experience and address them directly in the application. Let's start by adding `first_name` and `last_name` columns to the database.\n\nIn the terminal, create a migration with these columns:\n\n```bash\n$ rails g migration AddNamesToUsers first_name:string last_name:string\n```\n\nThen migrate the database:\n\n```bash\n$ rails db:migrate\n```\n\nLet's also add a method to combine `first_name` and `last_name`, so that we can display the user's full name.\n\nOpen `app/models/user.rb` and add the following:\n\n```ruby#7-11\nclass User < ApplicationRecord\n  has_secure_password\n  has_many :sessions, dependent: :destroy\n\n  normalizes :email_address, with: ->(e) { e.strip.downcase }\n\n  validates :first_name, :last_name, presence: true",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2173929875",
        "repo_full_name": "rails/rails",
        "pr_number": 55254,
        "pr_file": "guides/source/sign_up_and_settings.md",
        "discussion_id": "2173929875",
        "commented_code": "@@ -0,0 +1,1658 @@\n+**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n+\n+Sign Up and Settings\n+========================\n+\n+This guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n+\n+After reading this guide, you will know how to:\n+\n+* Add user Sign Up\n+* Rate limit controller actions\n+* Create a nested layout\n+* Separate controllers by role (users and admins)\n+* Write tests for users with different roles\n+\n+--------------------------------------------------------------------------------\n+\n+Introduction\n+------------\n+\n+One of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n+\n+This feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n+\n+Let's get started!\n+\n+Adding Sign Up\n+--------------\n+\n+We've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.\n+\n+### Adding Names To Users\n+\n+It's also a good idea to collect the user's name at sign up. This allows us to personalize their experience and address them directly in the application. Let's start by adding `first_name` and `last_name` columns to the database.\n+\n+In the terminal, create a migration with these columns:\n+\n+```bash\n+$ rails g migration AddNamesToUsers first_name:string last_name:string\n+```\n+\n+Then migrate the database:\n+\n+```bash\n+$ rails db:migrate\n+```\n+\n+Let's also add a method to combine `first_name` and `last_name`, so that we can display the user's full name.\n+\n+Open `app/models/user.rb` and add the following:\n+\n+```ruby#7-11\n+class User < ApplicationRecord\n+  has_secure_password\n+  has_many :sessions, dependent: :destroy\n+\n+  normalizes :email_address, with: ->(e) { e.strip.downcase }\n+\n+  validates :first_name, :last_name, presence: true",
        "comment_created_at": "2025-06-29T21:18:04+00:00",
        "comment_author": "gregmolnar",
        "comment_body": "Maybe it would worth mention here that has_secure_password only validates the presence of the password, but not the minimum length or complexity. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174482294",
    "pr_number": 55254,
    "pr_file": "guides/source/sign_up_and_settings.md",
    "created_at": "2025-06-30T08:09:33+00:00",
    "commented_code": "**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n\nSign Up and Settings\n========================\n\nThis guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n\nAfter reading this guide, you will know how to:\n\n* Add user Sign Up\n* Rate limit controller actions\n* Create a nested layout\n* Separate controllers by role (users and admins)\n* Write tests for users with different roles\n\n--------------------------------------------------------------------------------\n\nIntroduction\n------------\n\nOne of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n\nThis feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n\nLet's get started!\n\nAdding Sign Up\n--------------\n\nWe've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.\n\n### Adding Names To Users\n\nIt's also a good idea to collect the user's name at sign up. This allows us to personalize their experience and address them directly in the application. Let's start by adding `first_name` and `last_name` columns to the database.\n\nIn the terminal, create a migration with these columns:\n\n```bash\n$ rails g migration AddNamesToUsers first_name:string last_name:string\n```\n\nThen migrate the database:\n\n```bash\n$ rails db:migrate\n```\n\nLet's also add a method to combine `first_name` and `last_name`, so that we can display the user's full name.\n\nOpen `app/models/user.rb` and add the following:\n\n```ruby#7-11\nclass User < ApplicationRecord\n  has_secure_password\n  has_many :sessions, dependent: :destroy\n\n  normalizes :email_address, with: ->(e) { e.strip.downcase }\n\n  validates :first_name, :last_name, presence: true\n\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\n```\n\nNext, let's add sign up so we can register new users.\n\n### Sign Up Routes & Controller\n\nNow that our database has all the necessary columns to register new users, the next step is to create a route for sign up and its matching controller.\n\nIn `config/routes.rb`, let's add a resource for sign up:\n\n```ruby#3\nresource :session\nresources :passwords, param: :token\nresource :sign_up\n```\n\nWe're using a singular resource here because we want a singular route for `/sign_up`.\n\nThis route directs requests to `app/controllers/sign_ups_controller.rb` so let's create that controller file now.\n\n```ruby\nclass SignUpsController < ApplicationController\n  def show\n    @user = User.new\n  end\nend\n```\n\nWe're using the `show` action to create a new `User` instance, which will be used to display the sign up form.\n\nLet's create the form next. Create `app/views/sign_ups/show.html.erb` with the following code:\n\n```erb\n<h1>Sign Up</h1>\n\n<%= form_with model: @user, url: sign_up_path do |form| %>\n  <% if form.object.errors.any? %>\n    <div>Error: <%= form.object.errors.full_messages.first %></div>\n  <% end %>\n\n  <div>\n    <%= form.label :first_name %>\n    <%= form.text_field :first_name, required: true, autofocus: true, autocomplete: \"given-name\" %>\n  </div>\n\n  <div>\n    <%= form.label :last_name %>\n    <%= form.text_field :last_name, required: true, autocomplete: \"family-name\" %>\n  </div>\n\n  <div>\n    <%= form.label :email_address %>\n    <%= form.email_field :email_address, required: true, autocomplete: \"email\" %>\n  </div>\n\n  <div>\n    <%= form.label :password %>\n    <%= form.password_field :password, required: true, autocomplete: \"new-password\" %>\n  </div>\n\n  <div>\n    <%= form.label :password_confirmation %>\n    <%= form.password_field :password_confirmation, required: true, autocomplete: \"new-password\" %>\n  </div>\n\n  <div>\n    <%= form.submit \"Sign up\" %>\n  </div>\n<% end %>\n```\n\nThis form collects the user's name, email, and password. We're using the `autocomplete` attribute to help the browser suggest the values for these fields based on the user's saved information.\n\nYou'll also notice we set `url: sign_up_path` in the form alongside `model: @user`. Without this `url:` argument, `form_with` would see we have a `User` and send the form to `/users` by default. Since we want the form to submit to `/sign_up`, we set the `url:` to override the default route.\n\nBack in `app/controllers/sign_ups_controller.rb` we can handle the form submission by adding the `create` action.\n\n```ruby#6-19\nclass SignUpsController < ApplicationController\n  def show\n    @user = User.new\n  end\n\n  def create\n    @user = User.new(sign_up_params)\n    if @user.save\n      start_new_session_for(@user)\n      redirect_to root_path\n    else\n      render :show, status: :unprocessable_entity\n    end\n  end\n\n  private\n    def sign_up_params\n      params.expect(user: [ :first_name, :last_name, :email_address, :password, :password_confirmation ])\n    end\nend\n```\n\nThe `create` action assigns parameters and attempts to save the user to the database. If successful, it logs the user in and redirects to `root_path`, otherwise it re-renders the form with errors.\n\nAuthenticated users can still access `SignUpsController` and create another account while they're logged in which can be confusing.\n\nLet's fix this by adding a helper to the `Authentication` module in `app/controllers/concerns/authentication.rb`.\n\n```ruby#14-17\nmodule Authentication\n  extend ActiveSupport::Concern\n\n  included do\n    before_action :require_authentication\n    helper_method :authenticated?\n  end\n\n  class_methods do\n    def allow_unauthenticated_access(**options)\n      skip_before_action :require_authentication, **options\n    end\n\n    def unauthenticated_access_only(**options)\n      allow_unauthenticated_access **options\n      before_action -> { redirect_to root_path if authenticated? }, **options\n    end\n\n    # ...\n```\n\nThe `unauthenticated_only_access` class method can be used in any controller where we want to restrict actions to unauthenticated users only.\n\nWe can then use this method at the top of `SignUpsController`.\n\n```ruby#2\nclass SignUpsController < ApplicationController\n  unauthenticated_access_only\n\n  # ...\nend\n```\n\n### Rate Limiting Sign Up\n\nOur application will be accessible on the internet so we're bound to have malicious bots and users trying to spam our application. We can add rate limiting to sign up to slow down anyone submitting too many requests.\n\nRails makes this easy with the [`rate_limit`](https://api.rubyonrails.org/classes/ActionController/RateLimiting/ClassMethods.html) method in controllers.\n\n```ruby#3\nclass SignUpsController < ApplicationController\n  unauthenticated_only_access\n  rate_limit to: 10, within: 3.minutes, only: :create, with: -> { redirect_to sign_up_path, alert: \"Try again later.\" }\n\n  # ...\nend\n```\n\nThis will block any form submissions that happen more than 10 times within 3 minutes.\n\nEditing Passwords\n-----------------\n\nNow that users can login, let's create all the usual places that users would expect to update their profile, password, email address, and other settings.\n\n### Using Namespaces\n\nThe Rails authentication generator already created at `app/controllers/passwords_controller.rb` is the controller for password resets. This means we need to use a different controller for editing passwords of authenticated users.\n\nTo prevent conflicts, we can use a feature called **namespaces**. A namespace organizes routes, controllers, and views into folders and helps prevent conflicts like our two passwords controllers.\n\nWe'll create a namespace called \"Settings\" to separate out the user and store settings from the rest of our application.\n\nIn `config/routes.rb` we can add the Settings namespace along with a resource for editing passwords:\n\n```ruby\nnamespace :settings do\n  resource :password, only: [:show, :update]\nend\n```\n\nThis will generate a route for `/settings/password` for editing the current user's password which is separate from the password resets routes at `/password`.\n\n### Adding the Namespaced Passwords Controller & View\n\nNamespaces also move controllers into a matching module in Ruby. This controller will be in a `settings` folder to match the namespace.\n\nLet's create the folder and controller at `app/controllers/settings/passwords_controller.rb` and start with the `show` action.\n\n```ruby\nclass Settings::PasswordsController < ApplicationController\n  def show\n  end\nend\n```\n\nViews also move to a `settings` folder so let's create the folder and view at `app/views/settings/passwords/show.html.erb` for this action.\n\n```erb\n<h1>Password</h1>\n\n<%= form_with model: Current.user, url: settings_password_path do |form| %>\n  <% if form.object.errors.any? %>\n    <div><%= form.object.errors.full_messages.first %></div>\n  <% end %>\n\n  <div>\n    <%= form.label :password_challenge %>\n    <%= form.password_field :password_challenge, required: true, autocomplete: \"current-password\" %>\n  </div>\n\n  <div>\n    <%= form.label :password %>\n    <%= form.password_field :password, required: true, autocomplete: \"new-password\" %>\n  </div>\n\n  <div>\n    <%= form.label :password_confirmation %>\n    <%= form.password_field :password_confirmation, required: true, autocomplete: \"new-password\" %>\n  </div>\n\n  <div>\n    <%= form.submit \"Update password\" %>\n  </div>\n<% end %>\n```\n\nWe've set the `url:` argument to ensure the form submits to our namespaced route and is processed by the `Settings::PasswordsController`. Passing `model: Current.user` also tells `form_with` to submit a `PATCH` request to process the form with the `update` action.\n\n### Safely Updating Passwords\n\nLet's add that `update` action to the controller now.\n\n```ruby#5-17\nclass Settings::PasswordsController < Settings::BaseController\n  def show\n  end\n\n  def update\n    if Current.user.update(password_params)\n      redirect_to settings_profile_path, status: :see_other, notice: \"Your password has been updated.\"\n    else\n      render :show, status: :unprocessable_entity\n    end\n  end\n\n  private\n    def password_params\n      params.expect(user: [ :password, :password_confirmation, :password_challenge ]).with_defaults(password_challenge: \"\")\n    end\nend\n```\n\nFor security, we need to ensure that the user is the only one who can update their password. The `has_secure_password` method in our `User` model provides this attribute. If `password_challenge` is present, it will validate the password challenge against the user's current password in the database to confirm it matches.\n\nA malicious user could try deleting the `password_challenge` field in the browser to bypass this validation. To prevent this and ensure the validation always runs, we use `.with_defaults(password_challenge: \"\")` to set a default value even if the `password_challenge` parameter is missing.\n\nYou can now visit http://localhost:3000/settings/password to update your password.\n\n### Renaming The Password Challenge Attribute\n\nWhile `password_challenge` is a good name for our code, users are used to seeing \"Current password\" for this form field. We can rename this with locales in Rails to change how this attribute is displayed on the frontend.\n\nAdd the following to `config/locales/en.yml`:\n\n```yaml#7-10\nen:\n  hello: \"Hello world\"\n  products:\n    index:\n      title: \"Products\"\n\n  activerecord:\n    attributes:\n      user:\n        password_challenge: \"Current password\"\n```\n\nTo learn more, check out the [I18n Guide])https://guides.rubyonrails.org/i18n.html#translations-for-active-record-models)\n\nEditing User Profiles\n---------------------\n\nNext, let's add a page so user's can edit their profile, like updating their first and last name.\n\n### Profile Routes & Controller\n\nIn `config/routes.rb`, add a profile resource under the settings namespace. We can also add a root to the namespace to handle any visits to `/settings` and redirect them to profile settings.\n\n```ruby#3,5\nnamespace :settings do\n  resource :password, only: [ :show, :update ]\n  resource :profile, only: [ :show, :update ]\n\n  root to: redirect(\"/settings_profile\")\nend\n```\n\nLet's create our controller for editing profiles at `app/controllers/settings/profiles_controller.rb`.\n\n```ruby\nclass Settings::ProfilesController < ApplicationController\n  def show\n  end\n\n  def update\n    if Current.user.update(profile_params)\n      redirect_to settings_profile_path, status: :see_other, notice: \"Your profile was updated successfully.\"\n    else\n      render :show, status: :unprocessable_entity\n    end\n  end\n\n  private\n    def profile_params\n      params.expect(user: [ :first_name, :last_name ])\n    end\nend\n```\n\nThis is very similar to the passwords controller but only allows updating the user's profile details like first and last name.\n\nThen create `app/views/settings/profiles/show.html.erb` to show the edit profile form.\n\n```erb\n<h1>Profile</h1>\n\n<%= form_with model: Current.user, url: settings_profile_path do |form| %>\n  <% if form.object.errors.any? %>\n    <div>Error: <%= form.object.errors.full_messages.first %></div>\n  <% end %>\n\n  <div>\n    <%= form.label :first_name %>\n    <%= form.text_field :first_name, required: true, autocomplete: \"given-name\" %>\n  </div>\n\n  <div>\n    <%= form.label :last_name %>\n    <%= form.text_field :last_name, required: true, autocomplete: \"family-name\" %>\n  </div>\n\n  <div>\n    <%= form.submit \"Update profile\" %>\n  </div>\n<% end %>\n```\n\nYou can now visit http://localhost:3000/settings/profile to update your name.\n\n### Updating Navigation\n\nLet's update the navigation to include a link to Settings next to the Log out button.\n\nOpen `app/views/layouts/application.html.erb` and update the navbar. We'll also add a div for any alert messages from our controllers while we're here.\n\n```erb#9,13-19\n<!DOCTYPE html>\n<html>\n  <head>\n    <%# ... %>\n  </head>\n\n  <body>\n    <div class=\"notice\"><%= notice %></div>\n    <div class=\"alert\"><%= alert %></div>\n\n    <nav class=\"navbar\">\n      <%= link_to \"Home\", root_path %>\n      <% if authenticated? %>\n        <%= link_to \"Settings\", settings_root_path %>\n        <%= button_to \"Log out\", session_path, method: :delete %>\n      <% else %>\n        <%= link_to \"Sign Up\", sign_up_path %>\n        <%= link_to \"Login\", new_session_path %>\n      <% end %>\n    </nav>\n```\n\nYou'll now see a Settings link in the navbar when authenticated.\n\n### Settings Layout\n\nWhile we're here, let's add a new layout for Settings so we can organize them in a sidebar. To do this, we're going to use a [Nested Layout](layouts_and_rendering.html#using-nested-layouts).\n\nA nested layout allows you add HTML (like a sidebar) while still rendering the application layout. This means we don't have to duplicate our head tags or navigation in our Settings layout.\n\nLet's create `app/views/layouts/settings.html.erb` and add the following:\n\n```erb\n<%= content_for :content do %>\n  <section class=\"settings\">\n    <nav>\n      <h4>Account Settings</h4>\n      <%= link_to \"Profile\", settings_profile_path %>\n      <%= link_to \"Password\", settings_password_path %>\n    </nav>\n\n    <div>\n      <%= yield %>\n    </div>\n  </section>\n<% end %>\n\n<%= render template: \"layouts/application\" %>\n```\n\nIn the settings layout, we're providing HTML for the sidebar and telling Rails to render the application layout as the parent.\n\nWe need to modify the application layout to render the content from the nested layout using `yield(:content)`.\n\n```erb#11,23\n<!DOCTYPE html>\n<html>\n  <head>\n    <%# ... %>\n  </head>\n\n  <body>\n    <div class=\"notice\"><%= notice %></div>\n    <div class=\"alert\"><%= alert %></div>\n\n    <nav class=\"navbar\">\n      <%= link_to \"Home\", root_path %>\n      <% if authenticated? %>\n        <%= link_to \"Settings\", settings_root_path %>\n        <%= button_to \"Log out\", session_path, method: :delete %>\n      <% else %>\n        <%= link_to \"Sign Up\", sign_up_path %>\n        <%= link_to \"Login\", new_session_path %>\n      <% end %>\n    </nav>\n\n    <main>\n      <%= content_for?(:content) ? yield(:content) : yield %>\n    </main>\n  </body>\n</html\n```\n\nThis allows the application controller to be used normally with `yield` or it can be a parent layout if `content_for(:content)` is used in a nested layout.\n\nWe now have two separate `<nav>` tags, so we need to update our existing CSS selectors to avoid conflicts.\n\nTo do this, add the the `.navbar` class to these selectors.\n\n```css#1,11\nnav.navbar {\n  justify-content: flex-end;\n  display: flex;\n  font-size: 0.875em;\n  gap: 0.5rem;\n  max-width: 1024px;\n  margin: 0 auto;\n  padding: 1rem;\n}\n\nnav.navbar a {\n  display: inline-block;\n}\n```\n\nThen add some CSS to display the Settings nav as a sidebar.\n\n```css\nsection.settings {\n  display: flex;\n  gap: 1rem;\n}\n\nsection.settings nav {\n  width: 200px;\n}\n\nsection.settings nav a {\n  display: block;\n}\n```\n\nTo use this new layout, we can tell the controller we want to use a specific layout. We can add `layout \"settings\"` to any controller to change the layout that is rendered.\n\nSince we will have many controllers that use this layout, we can create a base class to define shared configuration and use inheritance to use them.\n\nAdd `app/controllers/settings/base_controller.rb` and add the following:\n\n```ruby\nclass Settings::BaseController < ApplicationController\n  layout \"settings\"\nend\n```\n\nThen update `app/controllers/settings/passwords_controller.rb` to inherit from this controller.\n\n```ruby\nclass Settings::PasswordsController < Settings::BaseController\n```\n\nAnd update `app/controllers/settings/profiles_controller.rb` to inherit from it too.\n\n```ruby\nclass Settings::ProfilesController < Settings::BaseController\n```\n\nDeleting Accounts\n-----------------\n\nNext, let's add the ability to delete your account. We'll start by adding another namespaced route for account to `config/routes.rb`.\n\n```ruby#2\nnamespace :settings do\n  resource :account, only: [ :show, :destroy ]\n  resource :password, only: [ :show, :update ]\n  resource :profile, only: [ :show, :update ]\n\n  root to: redirect(\"/settings/profile\")\nend\n```\n\nTo handle these new routes, create `app/controllers/settings/accounts_controller.rb` and add the following:\n\n```ruby\nclass Settings::AccountsController < Settings::BaseController\n  def show\n  end\n\n  def destroy\n    terminate_session\n    Current.user.destroy\n    redirect_to root_path, notice: \"Your account has been deleted.\"\n  end\nend\n```\n\nThe controller for deleting accounts is pretty straightforward. We have a `show` action to display the page and a `destroy` action to logout and delete the user. It also inherits from `Settings::BaseController` so it will use the settings layout like the others.\n\nNow let's add the view at `app/views/settings/accounts/show.html.erb` with the following:\n\n```erb\n<h1>Account</h1>\n\n<%= button_to \"Delete my account\", settings_account_path, method: :delete, data: {turbo_confirm: \"Are you sure? This cannot be undone.\"} %>\n```\n\nAnd finally, we'll add a link to Account in the setting layout's sidebar.\n\n```erb#7\n<%= content_for :content do %>\n  <section class=\"settings\">\n    <nav>\n      <h4>Account Settings</h4>\n      <%= link_to \"Profile\", settings_profile_path %>\n      <%= link_to \"Password\", settings_password_path %>\n      <%= link_to \"Account\", settings_account_path %>\n    </nav>\n\n    <div>\n      <%= yield %>\n    </div>\n  </section>\n<% end %>\n\n<%= render template: \"layouts/application\" %>\n```\n\nThat's it! You can now delete your account.\n\nUpdating Email Addresses\n------------------------\n\nOccassionally, users need to change the email address on their account. To do this safely, we need to store the new email address and send an email to confirm the change.\n\n### Adding Unconfirmed Email To Users\n\nWe'll start by adding a new field to the users table in our database. This will store the new email address while we're waiting for confirmation.\n\n```bash\n$ rails g migration AddUnconfirmedEmailToUsers unconfirmed_email:string\n```\n\nThen migrate the database.\n\n```bash\n$ rails db:migrate\n```\n\n\n### Email Routes & Controller\n\nNext we can add an email route under the `:settings` namespace in `config/routes.rb`.\n\n```ruby#3\nnamespace :settings do\n  resource :account, only: [ :show, :destroy ]\n  resource :email, only: [ :show, :update ]\n  resource :password, only: [ :show, :update ]\n  resource :profile, only: [ :show, :update ]\n\n  root to: redirect(\"/settings/profile\")\nend\n```\n\nThen we'll create `app/controllers/settings/emails_controller.rb` to display this.\n\n```ruby\nclass Settings::EmailsController < Settings::BaseController\n  def show\n  end\nend\n```\n\nAnd finally, we'll create our view at `app/views/settings/emails/show.html.erb`:\n\n```erb\n<h1>Change Email</h1>\n\n<%= form_with model: Current.user, url: settings_email_path do |form| %>\n  <% if form.object.errors.any? %>\n    <div>Error: <%= form.object.errors.full_messages.first %></div>\n  <% end %>\n\n  <div>\n    <%= form.label :unconfirmed_email, \"New email address\" %>\n    <%= form.email_field :unconfirmed_email, required: true %>\n  </div>\n\n  <div>\n    <%= form.label :password_challenge %>\n    <%= form.password_field :password_challenge, required: true, autocomplete: \"current-password\" %>\n  </div>\n\n  <div>\n    <%= form.submit \"Update email address\" %>\n  </div>\n<% end %>\n```\n\nTo keep things secure, we need to ask for the new email address and validate user's current password to ensure only the owner of the account can change the email.\n\nIn our controller, we will validate the current password and save the new email address before sending an email to confirm the new email address.\n\n```ruby\nclass Settings::EmailsController < Settings::BaseController\n  def show\n  end\n\n  def update\n    if Current.user.update(email_params)\n      UserMailer.with(user: Current.user).email_confirmation.deliver_later\n      redirect_to settings_email_path, status: :see_other, notice: \"We've sent a verification email to #{Current.user.unconfirmed_email}.\"\n    else\n      render :edit, status: :unprocessable_entity\n    end\n  end\n\n  private\n    def email_params\n      params.expect(user: [ :password_challenge, :unconfirmed_email ]).with_defaults(password_challenge: \"\")\n    end\nend\n```\n\nThis uses the same `with_defaults(password_challenge: \"\")` as `Settings::PasswordsController` to trigger the password challenge validation.\n\nWe haven't created the `UserMailer` yet, so let's do that next.\n\n### New Email Confirmation\n\nLet's use the mailer generator to create the `UserMailer` we referenced in `Settings::EmailsController`:\n\n```bash\n$ rails generate mailer User email_confirmation\n      create  app/mailers/user_mailer.rb\n      invoke  erb\n      create    app/views/user_mailer\n      create    app/views/user_mailer/email_confirmation.text.erb\n      create    app/views/user_mailer/email_confirmation.html.erb\n      invoke  test_unit\n      create    test/mailers/user_mailer_test.rb\n      create    test/mailers/previews/user_mailer_preview.rb\n```\n\nWe'll need to generate a token to include in the email body. Open `app/models/user.rb` and add the following:\n\n```ruby#9-15\nclass User < ApplicationRecord\n  has_secure_password\n  has_many :sessions, dependent: :destroy\n\n  normalizes :email_address, with: ->(e) { e.strip.downcase }\n\n  validates :first_name, :last_name, presence: true\n\n  generates_token_for :email_confirmation, expires_in: 7.days do\n    unconfirmed_email\n  end\n\n  def confirm_email\n    update(email_address: unconfirmed_email, unconfirmed_email: nil)\n  end\n\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\nend\n```\n\nThis adds a token generator we can use for email confirmations. The token encodes the unconfirmed email, so it becomes invalid if the email changes or the token expires.\n\nLet's update `app/mailers/user_mailer.rb` to generate a new token for the email:\n\n```ruby\nclass UserMailer < ApplicationMailer\n  # Subject can be set in your I18n file at config/locales/en.yml\n  # with the following lookup:\n  #\n  #   en.user_mailer.email_confirmation.subject\n  def email_confirmation\n    @token = params[:user].generate_token_for(:email_confirmation)\n    mail to: params[:user].unconfirmed_email\n  end\nend\n```\n\nWe'll include the token in the HTML view at `app/views/user_mailer/email_confirmation.html.erb`:\n\n```erb\n<h1>Verify your email address</h1>\n\n<p><%= link_to \"Confirm your email\", email_confirmation_url(token: @token) %></p>\n```\n\nAnd `app/views/user_mailer/email_confirmation.text.erb`:\n\n```erb\nConfirm your email: <%= email_confirmation_url(token: @token) %>\n```\n\n### Email Confirmation Controller\n\nThe confirmation email includes a link to our Rails app to verify the email change.\n\nLet's add a route for this to `config/routes.rb`\n\n```ruby\nnamespace :email do\n  resources :confirmations, param: :token, only: [ :show ]\nend\n```\n\nWhen a user clicks a link in their email, it will open a browser and make a GET request to the app. This means we only need the `show` action for this controller.\n\nNext, add the following to `app/controllers/emails/confirmations_controller.rb`\n\n```ruby\nclass Email::ConfirmationsController < ApplicationController\n  allow_unauthenticated_access\n\n  def show\n    user = User.find_by_token_for(:email_confirmation, params[:token])\n    if user&.confirm_email\n      flash[:notice] = \"Your email has been confirmed.\"\n    else\n      flash[:alert] = \"Invalid token.\"\n    end\n    redirect_to root_path\n  end\nend\n```\n\nWe want to confirm the email address whether the user is authenticated or not, so this controller allows unauthenticated access. We use the `find_by_token_for` method to validate the token and look up the matching `User` record. If successful, we call the `confirm_email` method to update the user's email and reset `unconfirmed_email` to `nil`. If the token isn't valid, the `user` variable will be `nil`, and we will display an alert message.\n\nSeparating Admins & Users\n-------------------------\n\nNow that anyone can sign up for an account on our store, we need to differentiate between regular users and admins.\n\n### Adding An Admin Flag\n\nWe'll start by adding a column to the User model.\n\n```bash\n$ rails g migration AddAdminToUsers admin:boolean\n```\n\nThen migrate the database.\n\n```bash\n$ rails db:migrate\n```\n\nA `User` with `admin` set to `true` should be able to add and remove products and access other administrative areas of the store.\n\n### Readonly Attributes\n\nWe need to be very careful that `admin` is not editable by any malicious users. This is easy enough by keeping the `:admin` attribute out of any permitted parameters list.\n\nOptionally, we can mark the admin attribute as readonly for added security. This will tell Rails to raise an error anytime the admin attribute is changed. It can still be set when creating a record, but provides an additional layer of security against unauthorized changes. You may want to skip this if you'll be changing the admin flag for users often but in our e-commerce store, it's a useful safeguard.\n\nWe can add `attr_readonly` in our model to protect the attribute from updates.\n\n```ruby#5\nclass User < ApplicationRecord\n  has_secure_password\n  has_many :sessions, dependent: :destroy\n\n  attr_readonly :admin\n\n  # ...\n```\n\nWhen admin is readonly, we have to directly update this in the database instead of using Active Record.\n\nRails has a command called `dbconsole` that will open a database console where we can directly interact with the database using SQL.\n\n```bash\n$ rails dbconsole\nSQLite version 3.43.2 2023-10-10 13:08:14\nEnter \".help\" for usage hints.\nsqlite>\n```\n\nIn the SQLite prompt, we can update the admin column for a record using an `UPDATE` statement and using `WHERE` to filter to a single user ID.\n\n```sql\nUPDATE users SET admin=true WHERE users.id=1;\n```\n\nTo close the SQLite prompt, enter the following command:\n\n```\n.quit\n```\n\nViewing All Users\n-----------------\n\nAs a store admin, we will want to view and manage users for customer support, marketing, etc.\n\nFirst, we'll need to add a route in the settings namespace for users in `config/routes.rb`.\n\n```ruby#2\nnamespace :settings do\n  resource :account, only: [ :show, :destroy ]\n  resource :email, only: [ :show, :update ]\n  resource :password, only: [ :show, :update ]\n  resource :profile, only: [ :show, :update ]\n\n  # Admins only\n  resources :users\n\n  root to: redirect(\"/settings/profile\")\nend\n```\n\n### Adding Admin Only Access\n\nThe controller for users should be accessible to admins only. Before we create that controller, let's add a class method to the `Authentication` module to restrict access to admins only.\n\nOpen `app/controllers/concerns/authentication.rb` and add:\n\n```ruby#19-21\nmodule Authentication\n  extend ActiveSupport::Concern\n\n  included do\n    before_action :require_authentication\n    helper_method :authenticated?\n  end\n\n  class_methods do\n    def allow_unauthenticated_access(**options)\n      skip_before_action :require_authentication, **options\n    end\n\n    def unauthenticated_access_only(**options)\n      allow_unauthenticated_access **options\n      before_action -> { redirect_to root_path if authenticated? }, **options\n    end\n\n    def admin_access_only(**options)",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2174482294",
        "repo_full_name": "rails/rails",
        "pr_number": 55254,
        "pr_file": "guides/source/sign_up_and_settings.md",
        "discussion_id": "2174482294",
        "commented_code": "@@ -0,0 +1,1658 @@\n+**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON <https://guides.rubyonrails.org>.**\n+\n+Sign Up and Settings\n+========================\n+\n+This guide covers adding Sign Up and Settings to the store e-commerce application in the [Getting Started Guide](getting_started.html)). We will use the final code from that guide as a starting place.\n+\n+After reading this guide, you will know how to:\n+\n+* Add user Sign Up\n+* Rate limit controller actions\n+* Create a nested layout\n+* Separate controllers by role (users and admins)\n+* Write tests for users with different roles\n+\n+--------------------------------------------------------------------------------\n+\n+Introduction\n+------------\n+\n+One of the most common features to add to any application is a sign up process for registering new users. The e-commerce application we've built so far only has authentication and users must be created in the Rails console or a script.\n+\n+This feature is required before we can add other features. For example, to let users create wishlists, they will need to be able to sign up first before they can create a wishlist associated with their account.\n+\n+Let's get started!\n+\n+Adding Sign Up\n+--------------\n+\n+We've already used the Rails authentication generator to allow users to login to their accounts. The generator created a `User` model with `email_address:string` and `password_digest:string` columns in the database. It also added `has_secure_password` to the `User` model which handles passwords and confirmations. This takes care of most of what we need to add sign up to our application.\n+\n+### Adding Names To Users\n+\n+It's also a good idea to collect the user's name at sign up. This allows us to personalize their experience and address them directly in the application. Let's start by adding `first_name` and `last_name` columns to the database.\n+\n+In the terminal, create a migration with these columns:\n+\n+```bash\n+$ rails g migration AddNamesToUsers first_name:string last_name:string\n+```\n+\n+Then migrate the database:\n+\n+```bash\n+$ rails db:migrate\n+```\n+\n+Let's also add a method to combine `first_name` and `last_name`, so that we can display the user's full name.\n+\n+Open `app/models/user.rb` and add the following:\n+\n+```ruby#7-11\n+class User < ApplicationRecord\n+  has_secure_password\n+  has_many :sessions, dependent: :destroy\n+\n+  normalizes :email_address, with: ->(e) { e.strip.downcase }\n+\n+  validates :first_name, :last_name, presence: true\n+\n+  def full_name\n+    \"#{first_name} #{last_name}\"\n+  end\n+end\n+```\n+\n+Next, let's add sign up so we can register new users.\n+\n+### Sign Up Routes & Controller\n+\n+Now that our database has all the necessary columns to register new users, the next step is to create a route for sign up and its matching controller.\n+\n+In `config/routes.rb`, let's add a resource for sign up:\n+\n+```ruby#3\n+resource :session\n+resources :passwords, param: :token\n+resource :sign_up\n+```\n+\n+We're using a singular resource here because we want a singular route for `/sign_up`.\n+\n+This route directs requests to `app/controllers/sign_ups_controller.rb` so let's create that controller file now.\n+\n+```ruby\n+class SignUpsController < ApplicationController\n+  def show\n+    @user = User.new\n+  end\n+end\n+```\n+\n+We're using the `show` action to create a new `User` instance, which will be used to display the sign up form.\n+\n+Let's create the form next. Create `app/views/sign_ups/show.html.erb` with the following code:\n+\n+```erb\n+<h1>Sign Up</h1>\n+\n+<%= form_with model: @user, url: sign_up_path do |form| %>\n+  <% if form.object.errors.any? %>\n+    <div>Error: <%= form.object.errors.full_messages.first %></div>\n+  <% end %>\n+\n+  <div>\n+    <%= form.label :first_name %>\n+    <%= form.text_field :first_name, required: true, autofocus: true, autocomplete: \"given-name\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :last_name %>\n+    <%= form.text_field :last_name, required: true, autocomplete: \"family-name\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :email_address %>\n+    <%= form.email_field :email_address, required: true, autocomplete: \"email\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password %>\n+    <%= form.password_field :password, required: true, autocomplete: \"new-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password_confirmation %>\n+    <%= form.password_field :password_confirmation, required: true, autocomplete: \"new-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.submit \"Sign up\" %>\n+  </div>\n+<% end %>\n+```\n+\n+This form collects the user's name, email, and password. We're using the `autocomplete` attribute to help the browser suggest the values for these fields based on the user's saved information.\n+\n+You'll also notice we set `url: sign_up_path` in the form alongside `model: @user`. Without this `url:` argument, `form_with` would see we have a `User` and send the form to `/users` by default. Since we want the form to submit to `/sign_up`, we set the `url:` to override the default route.\n+\n+Back in `app/controllers/sign_ups_controller.rb` we can handle the form submission by adding the `create` action.\n+\n+```ruby#6-19\n+class SignUpsController < ApplicationController\n+  def show\n+    @user = User.new\n+  end\n+\n+  def create\n+    @user = User.new(sign_up_params)\n+    if @user.save\n+      start_new_session_for(@user)\n+      redirect_to root_path\n+    else\n+      render :show, status: :unprocessable_entity\n+    end\n+  end\n+\n+  private\n+    def sign_up_params\n+      params.expect(user: [ :first_name, :last_name, :email_address, :password, :password_confirmation ])\n+    end\n+end\n+```\n+\n+The `create` action assigns parameters and attempts to save the user to the database. If successful, it logs the user in and redirects to `root_path`, otherwise it re-renders the form with errors.\n+\n+Authenticated users can still access `SignUpsController` and create another account while they're logged in which can be confusing.\n+\n+Let's fix this by adding a helper to the `Authentication` module in `app/controllers/concerns/authentication.rb`.\n+\n+```ruby#14-17\n+module Authentication\n+  extend ActiveSupport::Concern\n+\n+  included do\n+    before_action :require_authentication\n+    helper_method :authenticated?\n+  end\n+\n+  class_methods do\n+    def allow_unauthenticated_access(**options)\n+      skip_before_action :require_authentication, **options\n+    end\n+\n+    def unauthenticated_access_only(**options)\n+      allow_unauthenticated_access **options\n+      before_action -> { redirect_to root_path if authenticated? }, **options\n+    end\n+\n+    # ...\n+```\n+\n+The `unauthenticated_only_access` class method can be used in any controller where we want to restrict actions to unauthenticated users only.\n+\n+We can then use this method at the top of `SignUpsController`.\n+\n+```ruby#2\n+class SignUpsController < ApplicationController\n+  unauthenticated_access_only\n+\n+  # ...\n+end\n+```\n+\n+### Rate Limiting Sign Up\n+\n+Our application will be accessible on the internet so we're bound to have malicious bots and users trying to spam our application. We can add rate limiting to sign up to slow down anyone submitting too many requests.\n+\n+Rails makes this easy with the [`rate_limit`](https://api.rubyonrails.org/classes/ActionController/RateLimiting/ClassMethods.html) method in controllers.\n+\n+```ruby#3\n+class SignUpsController < ApplicationController\n+  unauthenticated_only_access\n+  rate_limit to: 10, within: 3.minutes, only: :create, with: -> { redirect_to sign_up_path, alert: \"Try again later.\" }\n+\n+  # ...\n+end\n+```\n+\n+This will block any form submissions that happen more than 10 times within 3 minutes.\n+\n+Editing Passwords\n+-----------------\n+\n+Now that users can login, let's create all the usual places that users would expect to update their profile, password, email address, and other settings.\n+\n+### Using Namespaces\n+\n+The Rails authentication generator already created at `app/controllers/passwords_controller.rb` is the controller for password resets. This means we need to use a different controller for editing passwords of authenticated users.\n+\n+To prevent conflicts, we can use a feature called **namespaces**. A namespace organizes routes, controllers, and views into folders and helps prevent conflicts like our two passwords controllers.\n+\n+We'll create a namespace called \"Settings\" to separate out the user and store settings from the rest of our application.\n+\n+In `config/routes.rb` we can add the Settings namespace along with a resource for editing passwords:\n+\n+```ruby\n+namespace :settings do\n+  resource :password, only: [:show, :update]\n+end\n+```\n+\n+This will generate a route for `/settings/password` for editing the current user's password which is separate from the password resets routes at `/password`.\n+\n+### Adding the Namespaced Passwords Controller & View\n+\n+Namespaces also move controllers into a matching module in Ruby. This controller will be in a `settings` folder to match the namespace.\n+\n+Let's create the folder and controller at `app/controllers/settings/passwords_controller.rb` and start with the `show` action.\n+\n+```ruby\n+class Settings::PasswordsController < ApplicationController\n+  def show\n+  end\n+end\n+```\n+\n+Views also move to a `settings` folder so let's create the folder and view at `app/views/settings/passwords/show.html.erb` for this action.\n+\n+```erb\n+<h1>Password</h1>\n+\n+<%= form_with model: Current.user, url: settings_password_path do |form| %>\n+  <% if form.object.errors.any? %>\n+    <div><%= form.object.errors.full_messages.first %></div>\n+  <% end %>\n+\n+  <div>\n+    <%= form.label :password_challenge %>\n+    <%= form.password_field :password_challenge, required: true, autocomplete: \"current-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password %>\n+    <%= form.password_field :password, required: true, autocomplete: \"new-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password_confirmation %>\n+    <%= form.password_field :password_confirmation, required: true, autocomplete: \"new-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.submit \"Update password\" %>\n+  </div>\n+<% end %>\n+```\n+\n+We've set the `url:` argument to ensure the form submits to our namespaced route and is processed by the `Settings::PasswordsController`. Passing `model: Current.user` also tells `form_with` to submit a `PATCH` request to process the form with the `update` action.\n+\n+### Safely Updating Passwords\n+\n+Let's add that `update` action to the controller now.\n+\n+```ruby#5-17\n+class Settings::PasswordsController < Settings::BaseController\n+  def show\n+  end\n+\n+  def update\n+    if Current.user.update(password_params)\n+      redirect_to settings_profile_path, status: :see_other, notice: \"Your password has been updated.\"\n+    else\n+      render :show, status: :unprocessable_entity\n+    end\n+  end\n+\n+  private\n+    def password_params\n+      params.expect(user: [ :password, :password_confirmation, :password_challenge ]).with_defaults(password_challenge: \"\")\n+    end\n+end\n+```\n+\n+For security, we need to ensure that the user is the only one who can update their password. The `has_secure_password` method in our `User` model provides this attribute. If `password_challenge` is present, it will validate the password challenge against the user's current password in the database to confirm it matches.\n+\n+A malicious user could try deleting the `password_challenge` field in the browser to bypass this validation. To prevent this and ensure the validation always runs, we use `.with_defaults(password_challenge: \"\")` to set a default value even if the `password_challenge` parameter is missing.\n+\n+You can now visit http://localhost:3000/settings/password to update your password.\n+\n+### Renaming The Password Challenge Attribute\n+\n+While `password_challenge` is a good name for our code, users are used to seeing \"Current password\" for this form field. We can rename this with locales in Rails to change how this attribute is displayed on the frontend.\n+\n+Add the following to `config/locales/en.yml`:\n+\n+```yaml#7-10\n+en:\n+  hello: \"Hello world\"\n+  products:\n+    index:\n+      title: \"Products\"\n+\n+  activerecord:\n+    attributes:\n+      user:\n+        password_challenge: \"Current password\"\n+```\n+\n+To learn more, check out the [I18n Guide])https://guides.rubyonrails.org/i18n.html#translations-for-active-record-models)\n+\n+Editing User Profiles\n+---------------------\n+\n+Next, let's add a page so user's can edit their profile, like updating their first and last name.\n+\n+### Profile Routes & Controller\n+\n+In `config/routes.rb`, add a profile resource under the settings namespace. We can also add a root to the namespace to handle any visits to `/settings` and redirect them to profile settings.\n+\n+```ruby#3,5\n+namespace :settings do\n+  resource :password, only: [ :show, :update ]\n+  resource :profile, only: [ :show, :update ]\n+\n+  root to: redirect(\"/settings_profile\")\n+end\n+```\n+\n+Let's create our controller for editing profiles at `app/controllers/settings/profiles_controller.rb`.\n+\n+```ruby\n+class Settings::ProfilesController < ApplicationController\n+  def show\n+  end\n+\n+  def update\n+    if Current.user.update(profile_params)\n+      redirect_to settings_profile_path, status: :see_other, notice: \"Your profile was updated successfully.\"\n+    else\n+      render :show, status: :unprocessable_entity\n+    end\n+  end\n+\n+  private\n+    def profile_params\n+      params.expect(user: [ :first_name, :last_name ])\n+    end\n+end\n+```\n+\n+This is very similar to the passwords controller but only allows updating the user's profile details like first and last name.\n+\n+Then create `app/views/settings/profiles/show.html.erb` to show the edit profile form.\n+\n+```erb\n+<h1>Profile</h1>\n+\n+<%= form_with model: Current.user, url: settings_profile_path do |form| %>\n+  <% if form.object.errors.any? %>\n+    <div>Error: <%= form.object.errors.full_messages.first %></div>\n+  <% end %>\n+\n+  <div>\n+    <%= form.label :first_name %>\n+    <%= form.text_field :first_name, required: true, autocomplete: \"given-name\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :last_name %>\n+    <%= form.text_field :last_name, required: true, autocomplete: \"family-name\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.submit \"Update profile\" %>\n+  </div>\n+<% end %>\n+```\n+\n+You can now visit http://localhost:3000/settings/profile to update your name.\n+\n+### Updating Navigation\n+\n+Let's update the navigation to include a link to Settings next to the Log out button.\n+\n+Open `app/views/layouts/application.html.erb` and update the navbar. We'll also add a div for any alert messages from our controllers while we're here.\n+\n+```erb#9,13-19\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <%# ... %>\n+  </head>\n+\n+  <body>\n+    <div class=\"notice\"><%= notice %></div>\n+    <div class=\"alert\"><%= alert %></div>\n+\n+    <nav class=\"navbar\">\n+      <%= link_to \"Home\", root_path %>\n+      <% if authenticated? %>\n+        <%= link_to \"Settings\", settings_root_path %>\n+        <%= button_to \"Log out\", session_path, method: :delete %>\n+      <% else %>\n+        <%= link_to \"Sign Up\", sign_up_path %>\n+        <%= link_to \"Login\", new_session_path %>\n+      <% end %>\n+    </nav>\n+```\n+\n+You'll now see a Settings link in the navbar when authenticated.\n+\n+### Settings Layout\n+\n+While we're here, let's add a new layout for Settings so we can organize them in a sidebar. To do this, we're going to use a [Nested Layout](layouts_and_rendering.html#using-nested-layouts).\n+\n+A nested layout allows you add HTML (like a sidebar) while still rendering the application layout. This means we don't have to duplicate our head tags or navigation in our Settings layout.\n+\n+Let's create `app/views/layouts/settings.html.erb` and add the following:\n+\n+```erb\n+<%= content_for :content do %>\n+  <section class=\"settings\">\n+    <nav>\n+      <h4>Account Settings</h4>\n+      <%= link_to \"Profile\", settings_profile_path %>\n+      <%= link_to \"Password\", settings_password_path %>\n+    </nav>\n+\n+    <div>\n+      <%= yield %>\n+    </div>\n+  </section>\n+<% end %>\n+\n+<%= render template: \"layouts/application\" %>\n+```\n+\n+In the settings layout, we're providing HTML for the sidebar and telling Rails to render the application layout as the parent.\n+\n+We need to modify the application layout to render the content from the nested layout using `yield(:content)`.\n+\n+```erb#11,23\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <%# ... %>\n+  </head>\n+\n+  <body>\n+    <div class=\"notice\"><%= notice %></div>\n+    <div class=\"alert\"><%= alert %></div>\n+\n+    <nav class=\"navbar\">\n+      <%= link_to \"Home\", root_path %>\n+      <% if authenticated? %>\n+        <%= link_to \"Settings\", settings_root_path %>\n+        <%= button_to \"Log out\", session_path, method: :delete %>\n+      <% else %>\n+        <%= link_to \"Sign Up\", sign_up_path %>\n+        <%= link_to \"Login\", new_session_path %>\n+      <% end %>\n+    </nav>\n+\n+    <main>\n+      <%= content_for?(:content) ? yield(:content) : yield %>\n+    </main>\n+  </body>\n+</html\n+```\n+\n+This allows the application controller to be used normally with `yield` or it can be a parent layout if `content_for(:content)` is used in a nested layout.\n+\n+We now have two separate `<nav>` tags, so we need to update our existing CSS selectors to avoid conflicts.\n+\n+To do this, add the the `.navbar` class to these selectors.\n+\n+```css#1,11\n+nav.navbar {\n+  justify-content: flex-end;\n+  display: flex;\n+  font-size: 0.875em;\n+  gap: 0.5rem;\n+  max-width: 1024px;\n+  margin: 0 auto;\n+  padding: 1rem;\n+}\n+\n+nav.navbar a {\n+  display: inline-block;\n+}\n+```\n+\n+Then add some CSS to display the Settings nav as a sidebar.\n+\n+```css\n+section.settings {\n+  display: flex;\n+  gap: 1rem;\n+}\n+\n+section.settings nav {\n+  width: 200px;\n+}\n+\n+section.settings nav a {\n+  display: block;\n+}\n+```\n+\n+To use this new layout, we can tell the controller we want to use a specific layout. We can add `layout \"settings\"` to any controller to change the layout that is rendered.\n+\n+Since we will have many controllers that use this layout, we can create a base class to define shared configuration and use inheritance to use them.\n+\n+Add `app/controllers/settings/base_controller.rb` and add the following:\n+\n+```ruby\n+class Settings::BaseController < ApplicationController\n+  layout \"settings\"\n+end\n+```\n+\n+Then update `app/controllers/settings/passwords_controller.rb` to inherit from this controller.\n+\n+```ruby\n+class Settings::PasswordsController < Settings::BaseController\n+```\n+\n+And update `app/controllers/settings/profiles_controller.rb` to inherit from it too.\n+\n+```ruby\n+class Settings::ProfilesController < Settings::BaseController\n+```\n+\n+Deleting Accounts\n+-----------------\n+\n+Next, let's add the ability to delete your account. We'll start by adding another namespaced route for account to `config/routes.rb`.\n+\n+```ruby#2\n+namespace :settings do\n+  resource :account, only: [ :show, :destroy ]\n+  resource :password, only: [ :show, :update ]\n+  resource :profile, only: [ :show, :update ]\n+\n+  root to: redirect(\"/settings/profile\")\n+end\n+```\n+\n+To handle these new routes, create `app/controllers/settings/accounts_controller.rb` and add the following:\n+\n+```ruby\n+class Settings::AccountsController < Settings::BaseController\n+  def show\n+  end\n+\n+  def destroy\n+    terminate_session\n+    Current.user.destroy\n+    redirect_to root_path, notice: \"Your account has been deleted.\"\n+  end\n+end\n+```\n+\n+The controller for deleting accounts is pretty straightforward. We have a `show` action to display the page and a `destroy` action to logout and delete the user. It also inherits from `Settings::BaseController` so it will use the settings layout like the others.\n+\n+Now let's add the view at `app/views/settings/accounts/show.html.erb` with the following:\n+\n+```erb\n+<h1>Account</h1>\n+\n+<%= button_to \"Delete my account\", settings_account_path, method: :delete, data: {turbo_confirm: \"Are you sure? This cannot be undone.\"} %>\n+```\n+\n+And finally, we'll add a link to Account in the setting layout's sidebar.\n+\n+```erb#7\n+<%= content_for :content do %>\n+  <section class=\"settings\">\n+    <nav>\n+      <h4>Account Settings</h4>\n+      <%= link_to \"Profile\", settings_profile_path %>\n+      <%= link_to \"Password\", settings_password_path %>\n+      <%= link_to \"Account\", settings_account_path %>\n+    </nav>\n+\n+    <div>\n+      <%= yield %>\n+    </div>\n+  </section>\n+<% end %>\n+\n+<%= render template: \"layouts/application\" %>\n+```\n+\n+That's it! You can now delete your account.\n+\n+Updating Email Addresses\n+------------------------\n+\n+Occassionally, users need to change the email address on their account. To do this safely, we need to store the new email address and send an email to confirm the change.\n+\n+### Adding Unconfirmed Email To Users\n+\n+We'll start by adding a new field to the users table in our database. This will store the new email address while we're waiting for confirmation.\n+\n+```bash\n+$ rails g migration AddUnconfirmedEmailToUsers unconfirmed_email:string\n+```\n+\n+Then migrate the database.\n+\n+```bash\n+$ rails db:migrate\n+```\n+\n+\n+### Email Routes & Controller\n+\n+Next we can add an email route under the `:settings` namespace in `config/routes.rb`.\n+\n+```ruby#3\n+namespace :settings do\n+  resource :account, only: [ :show, :destroy ]\n+  resource :email, only: [ :show, :update ]\n+  resource :password, only: [ :show, :update ]\n+  resource :profile, only: [ :show, :update ]\n+\n+  root to: redirect(\"/settings/profile\")\n+end\n+```\n+\n+Then we'll create `app/controllers/settings/emails_controller.rb` to display this.\n+\n+```ruby\n+class Settings::EmailsController < Settings::BaseController\n+  def show\n+  end\n+end\n+```\n+\n+And finally, we'll create our view at `app/views/settings/emails/show.html.erb`:\n+\n+```erb\n+<h1>Change Email</h1>\n+\n+<%= form_with model: Current.user, url: settings_email_path do |form| %>\n+  <% if form.object.errors.any? %>\n+    <div>Error: <%= form.object.errors.full_messages.first %></div>\n+  <% end %>\n+\n+  <div>\n+    <%= form.label :unconfirmed_email, \"New email address\" %>\n+    <%= form.email_field :unconfirmed_email, required: true %>\n+  </div>\n+\n+  <div>\n+    <%= form.label :password_challenge %>\n+    <%= form.password_field :password_challenge, required: true, autocomplete: \"current-password\" %>\n+  </div>\n+\n+  <div>\n+    <%= form.submit \"Update email address\" %>\n+  </div>\n+<% end %>\n+```\n+\n+To keep things secure, we need to ask for the new email address and validate user's current password to ensure only the owner of the account can change the email.\n+\n+In our controller, we will validate the current password and save the new email address before sending an email to confirm the new email address.\n+\n+```ruby\n+class Settings::EmailsController < Settings::BaseController\n+  def show\n+  end\n+\n+  def update\n+    if Current.user.update(email_params)\n+      UserMailer.with(user: Current.user).email_confirmation.deliver_later\n+      redirect_to settings_email_path, status: :see_other, notice: \"We've sent a verification email to #{Current.user.unconfirmed_email}.\"\n+    else\n+      render :edit, status: :unprocessable_entity\n+    end\n+  end\n+\n+  private\n+    def email_params\n+      params.expect(user: [ :password_challenge, :unconfirmed_email ]).with_defaults(password_challenge: \"\")\n+    end\n+end\n+```\n+\n+This uses the same `with_defaults(password_challenge: \"\")` as `Settings::PasswordsController` to trigger the password challenge validation.\n+\n+We haven't created the `UserMailer` yet, so let's do that next.\n+\n+### New Email Confirmation\n+\n+Let's use the mailer generator to create the `UserMailer` we referenced in `Settings::EmailsController`:\n+\n+```bash\n+$ rails generate mailer User email_confirmation\n+      create  app/mailers/user_mailer.rb\n+      invoke  erb\n+      create    app/views/user_mailer\n+      create    app/views/user_mailer/email_confirmation.text.erb\n+      create    app/views/user_mailer/email_confirmation.html.erb\n+      invoke  test_unit\n+      create    test/mailers/user_mailer_test.rb\n+      create    test/mailers/previews/user_mailer_preview.rb\n+```\n+\n+We'll need to generate a token to include in the email body. Open `app/models/user.rb` and add the following:\n+\n+```ruby#9-15\n+class User < ApplicationRecord\n+  has_secure_password\n+  has_many :sessions, dependent: :destroy\n+\n+  normalizes :email_address, with: ->(e) { e.strip.downcase }\n+\n+  validates :first_name, :last_name, presence: true\n+\n+  generates_token_for :email_confirmation, expires_in: 7.days do\n+    unconfirmed_email\n+  end\n+\n+  def confirm_email\n+    update(email_address: unconfirmed_email, unconfirmed_email: nil)\n+  end\n+\n+  def full_name\n+    \"#{first_name} #{last_name}\"\n+  end\n+end\n+```\n+\n+This adds a token generator we can use for email confirmations. The token encodes the unconfirmed email, so it becomes invalid if the email changes or the token expires.\n+\n+Let's update `app/mailers/user_mailer.rb` to generate a new token for the email:\n+\n+```ruby\n+class UserMailer < ApplicationMailer\n+  # Subject can be set in your I18n file at config/locales/en.yml\n+  # with the following lookup:\n+  #\n+  #   en.user_mailer.email_confirmation.subject\n+  def email_confirmation\n+    @token = params[:user].generate_token_for(:email_confirmation)\n+    mail to: params[:user].unconfirmed_email\n+  end\n+end\n+```\n+\n+We'll include the token in the HTML view at `app/views/user_mailer/email_confirmation.html.erb`:\n+\n+```erb\n+<h1>Verify your email address</h1>\n+\n+<p><%= link_to \"Confirm your email\", email_confirmation_url(token: @token) %></p>\n+```\n+\n+And `app/views/user_mailer/email_confirmation.text.erb`:\n+\n+```erb\n+Confirm your email: <%= email_confirmation_url(token: @token) %>\n+```\n+\n+### Email Confirmation Controller\n+\n+The confirmation email includes a link to our Rails app to verify the email change.\n+\n+Let's add a route for this to `config/routes.rb`\n+\n+```ruby\n+namespace :email do\n+  resources :confirmations, param: :token, only: [ :show ]\n+end\n+```\n+\n+When a user clicks a link in their email, it will open a browser and make a GET request to the app. This means we only need the `show` action for this controller.\n+\n+Next, add the following to `app/controllers/emails/confirmations_controller.rb`\n+\n+```ruby\n+class Email::ConfirmationsController < ApplicationController\n+  allow_unauthenticated_access\n+\n+  def show\n+    user = User.find_by_token_for(:email_confirmation, params[:token])\n+    if user&.confirm_email\n+      flash[:notice] = \"Your email has been confirmed.\"\n+    else\n+      flash[:alert] = \"Invalid token.\"\n+    end\n+    redirect_to root_path\n+  end\n+end\n+```\n+\n+We want to confirm the email address whether the user is authenticated or not, so this controller allows unauthenticated access. We use the `find_by_token_for` method to validate the token and look up the matching `User` record. If successful, we call the `confirm_email` method to update the user's email and reset `unconfirmed_email` to `nil`. If the token isn't valid, the `user` variable will be `nil`, and we will display an alert message.\n+\n+Separating Admins & Users\n+-------------------------\n+\n+Now that anyone can sign up for an account on our store, we need to differentiate between regular users and admins.\n+\n+### Adding An Admin Flag\n+\n+We'll start by adding a column to the User model.\n+\n+```bash\n+$ rails g migration AddAdminToUsers admin:boolean\n+```\n+\n+Then migrate the database.\n+\n+```bash\n+$ rails db:migrate\n+```\n+\n+A `User` with `admin` set to `true` should be able to add and remove products and access other administrative areas of the store.\n+\n+### Readonly Attributes\n+\n+We need to be very careful that `admin` is not editable by any malicious users. This is easy enough by keeping the `:admin` attribute out of any permitted parameters list.\n+\n+Optionally, we can mark the admin attribute as readonly for added security. This will tell Rails to raise an error anytime the admin attribute is changed. It can still be set when creating a record, but provides an additional layer of security against unauthorized changes. You may want to skip this if you'll be changing the admin flag for users often but in our e-commerce store, it's a useful safeguard.\n+\n+We can add `attr_readonly` in our model to protect the attribute from updates.\n+\n+```ruby#5\n+class User < ApplicationRecord\n+  has_secure_password\n+  has_many :sessions, dependent: :destroy\n+\n+  attr_readonly :admin\n+\n+  # ...\n+```\n+\n+When admin is readonly, we have to directly update this in the database instead of using Active Record.\n+\n+Rails has a command called `dbconsole` that will open a database console where we can directly interact with the database using SQL.\n+\n+```bash\n+$ rails dbconsole\n+SQLite version 3.43.2 2023-10-10 13:08:14\n+Enter \".help\" for usage hints.\n+sqlite>\n+```\n+\n+In the SQLite prompt, we can update the admin column for a record using an `UPDATE` statement and using `WHERE` to filter to a single user ID.\n+\n+```sql\n+UPDATE users SET admin=true WHERE users.id=1;\n+```\n+\n+To close the SQLite prompt, enter the following command:\n+\n+```\n+.quit\n+```\n+\n+Viewing All Users\n+-----------------\n+\n+As a store admin, we will want to view and manage users for customer support, marketing, etc.\n+\n+First, we'll need to add a route in the settings namespace for users in `config/routes.rb`.\n+\n+```ruby#2\n+namespace :settings do\n+  resource :account, only: [ :show, :destroy ]\n+  resource :email, only: [ :show, :update ]\n+  resource :password, only: [ :show, :update ]\n+  resource :profile, only: [ :show, :update ]\n+\n+  # Admins only\n+  resources :users\n+\n+  root to: redirect(\"/settings/profile\")\n+end\n+```\n+\n+### Adding Admin Only Access\n+\n+The controller for users should be accessible to admins only. Before we create that controller, let's add a class method to the `Authentication` module to restrict access to admins only.\n+\n+Open `app/controllers/concerns/authentication.rb` and add:\n+\n+```ruby#19-21\n+module Authentication\n+  extend ActiveSupport::Concern\n+\n+  included do\n+    before_action :require_authentication\n+    helper_method :authenticated?\n+  end\n+\n+  class_methods do\n+    def allow_unauthenticated_access(**options)\n+      skip_before_action :require_authentication, **options\n+    end\n+\n+    def unauthenticated_access_only(**options)\n+      allow_unauthenticated_access **options\n+      before_action -> { redirect_to root_path if authenticated? }, **options\n+    end\n+\n+    def admin_access_only(**options)",
        "comment_created_at": "2025-06-30T08:09:33+00:00",
        "comment_author": "brunoprietog",
        "comment_body": "This seems a bit out of place to me. This is an action more typical of an authorization concept, not so much authentication. Maybe move it somewhere else? Maybe an `Authorization` concern that has a `require_admin` as a class method.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "633023754",
    "pr_number": 42193,
    "pr_file": "guides/source/active_storage_overview.md",
    "created_at": "2021-05-16T00:50:58+00:00",
    "commented_code": "```yaml\nlocal:\n  service: Disk\n  environment: development\n  root: <%= Rails.root.join(\"storage\") %>\n\ntest:\n  service: Disk\n  environment: test\n  root: <%= Rails.root.join(\"tmp/storage\") %>\n\namazon:\n  service: S3\n  environment: production\n  access_key_id: \"\"\n  secret_access_key: \"\"\n  bucket: \"\"\n  region: \"\" # e.g. 'us-east-1'\n```\n\nThe `environment` configuration is optional, but makes Active Storage more secure\nby preventing access to the specified except when Rails is running in the specified environment.",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "633023754",
        "repo_full_name": "rails/rails",
        "pr_number": 42193,
        "pr_file": "guides/source/active_storage_overview.md",
        "discussion_id": "633023754",
        "commented_code": "@@ -52,20 +52,26 @@ below declares three services named `local`, `test`, and `amazon`:\n ```yaml\n local:\n   service: Disk\n+  environment: development\n   root: <%= Rails.root.join(\"storage\") %>\n \n test:\n   service: Disk\n+  environment: test\n   root: <%= Rails.root.join(\"tmp/storage\") %>\n \n amazon:\n   service: S3\n+  environment: production\n   access_key_id: \"\"\n   secret_access_key: \"\"\n   bucket: \"\"\n   region: \"\" # e.g. 'us-east-1'\n ```\n \n+The `environment` configuration is optional, but makes Active Storage more secure\n+by preventing access to the specified except when Rails is running in the specified environment.",
        "comment_created_at": "2021-05-16T00:50:58+00:00",
        "comment_author": "zzak",
        "comment_body": "\"by preventing access to the specified environment except when Rails is running in said environment.\"",
        "pr_file_module": null
      },
      {
        "comment_id": "633024440",
        "repo_full_name": "rails/rails",
        "pr_number": 42193,
        "pr_file": "guides/source/active_storage_overview.md",
        "discussion_id": "633023754",
        "commented_code": "@@ -52,20 +52,26 @@ below declares three services named `local`, `test`, and `amazon`:\n ```yaml\n local:\n   service: Disk\n+  environment: development\n   root: <%= Rails.root.join(\"storage\") %>\n \n test:\n   service: Disk\n+  environment: test\n   root: <%= Rails.root.join(\"tmp/storage\") %>\n \n amazon:\n   service: S3\n+  environment: production\n   access_key_id: \"\"\n   secret_access_key: \"\"\n   bucket: \"\"\n   region: \"\" # e.g. 'us-east-1'\n ```\n \n+The `environment` configuration is optional, but makes Active Storage more secure\n+by preventing access to the specified except when Rails is running in the specified environment.",
        "comment_created_at": "2021-05-16T01:00:58+00:00",
        "comment_author": "ghiculescu",
        "comment_body": "```suggestion\r\nby preventing access to the specified service except when Rails is running in the stated environment.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2073260356",
    "pr_number": 55017,
    "pr_file": "guides/source/configuring.md",
    "created_at": "2025-05-05T11:18:04+00:00",
    "commented_code": "#### `config.action_dispatch.signed_cookie_digest`\n\nSets the digest to be used for signed cookies. This defaults to `\"SHA1\"`.\nSets the digest to be used for signed cookies. This defaults to `\"SHA256\"`.",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2073260356",
        "repo_full_name": "rails/rails",
        "pr_number": 55017,
        "pr_file": "guides/source/configuring.md",
        "discussion_id": "2073260356",
        "commented_code": "@@ -2067,7 +2067,7 @@ Sets the cipher to be used for encrypted cookies. This defaults to\n \n #### `config.action_dispatch.signed_cookie_digest`\n \n-Sets the digest to be used for signed cookies. This defaults to `\"SHA1\"`.\n+Sets the digest to be used for signed cookies. This defaults to `\"SHA256\"`.",
        "comment_created_at": "2025-05-05T11:18:04+00:00",
        "comment_author": "Earlopain",
        "comment_body": "The default should depend on `load_defaults` so that upgrading/legacy apps continue to work. Previous PRs for similar things should give a good template you can take inspiration from: https://github.com/rails/rails/pull/41043\r\n\r\nThis probably also needs some update https://github.com/rails/rails/blob/96a2f03a2a82e91ab4438b625ba47bd8ed917b45/guides/source/security.md#L333-L347\r\n\r\nThere are also some tests like https://github.com/rails/rails/blob/96a2f03a2a82e91ab4438b625ba47bd8ed917b45/actionpack/test/dispatch/cookies_test.rb#L630-L631 that don't make much sense anymore when the default is already SHA256.",
        "pr_file_module": null
      },
      {
        "comment_id": "2076254149",
        "repo_full_name": "rails/rails",
        "pr_number": 55017,
        "pr_file": "guides/source/configuring.md",
        "discussion_id": "2073260356",
        "commented_code": "@@ -2067,7 +2067,7 @@ Sets the cipher to be used for encrypted cookies. This defaults to\n \n #### `config.action_dispatch.signed_cookie_digest`\n \n-Sets the digest to be used for signed cookies. This defaults to `\"SHA1\"`.\n+Sets the digest to be used for signed cookies. This defaults to `\"SHA256\"`.",
        "comment_created_at": "2025-05-06T20:45:54+00:00",
        "comment_author": "jg23497",
        "comment_body": "Thanks for the pointers!\r\n\r\nI have done as you suggested with `load_defaults`. I notice that the `signed_cookie_digest` configuration was [added in Rails 5.2](https://github.com/rails/rails/pull/29716) and so have added the previous \"SHA1\" default to the method's \"5.2\" switch clause.\r\n\r\nI will revisit cookies_test.rb soon to check the redundant tests, hopefully tomorrow.",
        "pr_file_module": null
      },
      {
        "comment_id": "2077259167",
        "repo_full_name": "rails/rails",
        "pr_number": 55017,
        "pr_file": "guides/source/configuring.md",
        "discussion_id": "2073260356",
        "commented_code": "@@ -2067,7 +2067,7 @@ Sets the cipher to be used for encrypted cookies. This defaults to\n \n #### `config.action_dispatch.signed_cookie_digest`\n \n-Sets the digest to be used for signed cookies. This defaults to `\"SHA1\"`.\n+Sets the digest to be used for signed cookies. This defaults to `\"SHA256\"`.",
        "comment_created_at": "2025-05-07T09:48:48+00:00",
        "comment_author": "jg23497",
        "comment_body": "I have updated the relevant unit tests.\r\n\r\nTesting with a Rails app, I can also confirm that by default `config.load_defaults 8.1` produces a SHA256 signed cookie digest and `config.load_defaults 8.0` produces SHA1.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2088812859",
    "pr_number": 55020,
    "pr_file": "guides/source/generators.md",
    "created_at": "2025-05-14T12:22:34+00:00",
    "commented_code": "create      app/views/comments/show.json.jbuilder\n```\n\nApplication Templates\n---------------------\nCreating Application Templates\n------------------------------\n\nApplication templates are a little different from generators. While generators\nadd files to an existing Rails application (models, views, etc.), templates are\nused to automate the setup of a new Rails application. Templates are written as\na Ruby script.\n\nLet's see how to use a template while creating a new Rails application and also\nan example of a template Ruby script.\n\n### Usage\n\nApplication templates are a special kind of generator. They can use all of the\n[generator helper methods](#generator-helper-methods), but are written as a Ruby\nscript instead of a Ruby class. Here is an example:\nTo apply a template while creating a new Rails application, you need to provide\nthe location of the template using the `-m` option.\n\n```bash\n$ rails new blog -m ~/template.rb\n```\n\nYou can also use the `app:template` command to apply templates to an existing\nRails application. The location of the template needs to be passed in via the\n`LOCATION` environment variable.\n\n```bash\n$ bin/rails app:template LOCATION=~/template.rb\n```\n\nTemplates don't have to be stored locally, you can also specify a URL instead of\na path:\n\n```bash\n$ rails new blog -m http://example.com/template.rb\n$ bin/rails app:template LOCATION=http://example.com/template.rb",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2088812859",
        "repo_full_name": "rails/rails",
        "pr_number": 55020,
        "pr_file": "guides/source/generators.md",
        "discussion_id": "2088812859",
        "commented_code": "@@ -449,12 +446,44 @@ $ bin/rails generate scaffold Comment body:text\n       create      app/views/comments/show.json.jbuilder\n ```\n \n-Application Templates\n----------------------\n+Creating Application Templates\n+------------------------------\n+\n+Application templates are a little different from generators. While generators\n+add files to an existing Rails application (models, views, etc.), templates are\n+used to automate the setup of a new Rails application. Templates are written as\n+a Ruby script.\n+\n+Let's see how to use a template while creating a new Rails application and also\n+an example of a template Ruby script.\n+\n+### Usage\n \n-Application templates are a special kind of generator. They can use all of the\n-[generator helper methods](#generator-helper-methods), but are written as a Ruby\n-script instead of a Ruby class. Here is an example:\n+To apply a template while creating a new Rails application, you need to provide\n+the location of the template using the `-m` option.\n+\n+```bash\n+$ rails new blog -m ~/template.rb\n+```\n+\n+You can also use the `app:template` command to apply templates to an existing\n+Rails application. The location of the template needs to be passed in via the\n+`LOCATION` environment variable.\n+\n+```bash\n+$ bin/rails app:template LOCATION=~/template.rb\n+```\n+\n+Templates don't have to be stored locally, you can also specify a URL instead of\n+a path:\n+\n+```bash\n+$ rails new blog -m http://example.com/template.rb\n+$ bin/rails app:template LOCATION=http://example.com/template.rb",
        "comment_created_at": "2025-05-14T12:22:34+00:00",
        "comment_author": "p8",
        "comment_body": "Nitpick, but executing a remote script should probably be done with https:\r\n\r\n```suggestion\r\n$ rails new blog -m https://example.com/template.rb\r\n$ bin/rails app:template LOCATION=https://example.com/template.rb\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2088837798",
    "pr_number": 55020,
    "pr_file": "guides/source/generators.md",
    "created_at": "2025-05-14T12:36:34+00:00",
    "commented_code": "create      app/views/comments/show.json.jbuilder\n```\n\nApplication Templates\n---------------------\nCreating Application Templates\n------------------------------\n\nApplication templates are a little different from generators. While generators\nadd files to an existing Rails application (models, views, etc.), templates are\nused to automate the setup of a new Rails application. Templates are written as\na Ruby script.\n\nLet's see how to use a template while creating a new Rails application and also\nan example of a template Ruby script.\n\n### Usage\n\nApplication templates are a special kind of generator. They can use all of the\n[generator helper methods](#generator-helper-methods), but are written as a Ruby\nscript instead of a Ruby class. Here is an example:\nTo apply a template while creating a new Rails application, you need to provide\nthe location of the template using the `-m` option.\n\n```bash\n$ rails new blog -m ~/template.rb\n```\n\nYou can also use the `app:template` command to apply templates to an existing\nRails application. The location of the template needs to be passed in via the\n`LOCATION` environment variable.\n\n```bash\n$ bin/rails app:template LOCATION=~/template.rb\n```\n\nTemplates don't have to be stored locally, you can also specify a URL instead of\na path:\n\n```bash\n$ rails new blog -m http://example.com/template.rb\n$ bin/rails app:template LOCATION=http://example.com/template.rb\n```",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2088837798",
        "repo_full_name": "rails/rails",
        "pr_number": 55020,
        "pr_file": "guides/source/generators.md",
        "discussion_id": "2088837798",
        "commented_code": "@@ -449,12 +446,44 @@ $ bin/rails generate scaffold Comment body:text\n       create      app/views/comments/show.json.jbuilder\n ```\n \n-Application Templates\n----------------------\n+Creating Application Templates\n+------------------------------\n+\n+Application templates are a little different from generators. While generators\n+add files to an existing Rails application (models, views, etc.), templates are\n+used to automate the setup of a new Rails application. Templates are written as\n+a Ruby script.\n+\n+Let's see how to use a template while creating a new Rails application and also\n+an example of a template Ruby script.\n+\n+### Usage\n \n-Application templates are a special kind of generator. They can use all of the\n-[generator helper methods](#generator-helper-methods), but are written as a Ruby\n-script instead of a Ruby class. Here is an example:\n+To apply a template while creating a new Rails application, you need to provide\n+the location of the template using the `-m` option.\n+\n+```bash\n+$ rails new blog -m ~/template.rb\n+```\n+\n+You can also use the `app:template` command to apply templates to an existing\n+Rails application. The location of the template needs to be passed in via the\n+`LOCATION` environment variable.\n+\n+```bash\n+$ bin/rails app:template LOCATION=~/template.rb\n+```\n+\n+Templates don't have to be stored locally, you can also specify a URL instead of\n+a path:\n+\n+```bash\n+$ rails new blog -m http://example.com/template.rb\n+$ bin/rails app:template LOCATION=http://example.com/template.rb\n+```\n+",
        "comment_created_at": "2025-05-14T12:36:34+00:00",
        "comment_author": "p8",
        "comment_body": "It's probably a good idea to add a warning for using URL's:\r\n```suggestion\r\n\r\nWARNING: Caution should be taken executing remote scripts from third parties. As the template script is plain Ruby it's easy to compromise your local machine. For example: download a virus, remove files or upload your private files to a server.\r\n\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2088991356",
        "repo_full_name": "rails/rails",
        "pr_number": 55020,
        "pr_file": "guides/source/generators.md",
        "discussion_id": "2088837798",
        "commented_code": "@@ -449,12 +446,44 @@ $ bin/rails generate scaffold Comment body:text\n       create      app/views/comments/show.json.jbuilder\n ```\n \n-Application Templates\n----------------------\n+Creating Application Templates\n+------------------------------\n+\n+Application templates are a little different from generators. While generators\n+add files to an existing Rails application (models, views, etc.), templates are\n+used to automate the setup of a new Rails application. Templates are written as\n+a Ruby script.\n+\n+Let's see how to use a template while creating a new Rails application and also\n+an example of a template Ruby script.\n+\n+### Usage\n \n-Application templates are a special kind of generator. They can use all of the\n-[generator helper methods](#generator-helper-methods), but are written as a Ruby\n-script instead of a Ruby class. Here is an example:\n+To apply a template while creating a new Rails application, you need to provide\n+the location of the template using the `-m` option.\n+\n+```bash\n+$ rails new blog -m ~/template.rb\n+```\n+\n+You can also use the `app:template` command to apply templates to an existing\n+Rails application. The location of the template needs to be passed in via the\n+`LOCATION` environment variable.\n+\n+```bash\n+$ bin/rails app:template LOCATION=~/template.rb\n+```\n+\n+Templates don't have to be stored locally, you can also specify a URL instead of\n+a path:\n+\n+```bash\n+$ rails new blog -m http://example.com/template.rb\n+$ bin/rails app:template LOCATION=http://example.com/template.rb\n+```\n+",
        "comment_created_at": "2025-05-14T13:44:37+00:00",
        "comment_author": "bhumi1102",
        "comment_body": "Good call!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "441060183",
    "pr_number": 39398,
    "pr_file": "actionpack/CHANGELOG.md",
    "created_at": "2020-06-16T18:31:33+00:00",
    "commented_code": "*   Allow Content Security Policy DSL to generate for API responses.\n    *Tim Wade*",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "441060183",
        "repo_full_name": "rails/rails",
        "pr_number": 39398,
        "pr_file": "actionpack/CHANGELOG.md",
        "discussion_id": "441060183",
        "commented_code": "@@ -1,3 +1,6 @@\n+*   Allow Content Security Policy DSL to generate for API responses.\n+    *Tim Wade*",
        "comment_created_at": "2020-06-16T18:31:33+00:00",
        "comment_author": "jeremy",
        "comment_body": "Let's describe this a bit more. The summary in the pull request is great! We'll now send CSP headers with all responses, not just HTML, to protect API responses that could be loaded in a browser.",
        "pr_file_module": null
      }
    ]
  }
]
