[
  {
    "discussion_id": "2154107065",
    "pr_number": 55135,
    "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb",
    "created_at": "2025-06-18T09:19:39+00:00",
    "commented_code": "#\n      # See TableDefinition#column\n\n      ##\n      # :method: bigint\n      # :call-seq: bigint(*names, **options)\n      #\n      # Adds a +bigint+ column for storing large integer values.\n      #\n      # On PostgreSQL, you can use the +array: true+ option to store an array of big integers.\n      #\n      # Example:\n      #\n      #   t.bigint :account_id\n      #   t.bigint :event_ids, array: true, default: []",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2154107065",
        "repo_full_name": "rails/rails",
        "pr_number": 55135,
        "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb",
        "discussion_id": "2154107065",
        "commented_code": "@@ -339,6 +339,225 @@ def primary_key(name, type = :primary_key, **options)\n       #\n       # See TableDefinition#column\n \n+      ##\n+      # :method: bigint\n+      # :call-seq: bigint(*names, **options)\n+      #\n+      # Adds a +bigint+ column for storing large integer values.\n+      #\n+      # On PostgreSQL, you can use the +array: true+ option to store an array of big integers.\n+      #\n+      # Example:\n+      #\n+      #   t.bigint :account_id\n+      #   t.bigint :event_ids, array: true, default: []",
        "comment_created_at": "2025-06-18T09:19:39+00:00",
        "comment_author": "p8",
        "comment_body": "For newcomers it's probably unclear what `t` stands for.\r\nMaybe add `create_table` in the examples to make things clearer:\r\n```suggestion\r\n      #   create_table :subscriptions do |t|\r\n      #     t.bigint :account_id\r\n      #     t.bigint :event_ids, array: true, default: []\r\n      #   end\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154343247",
    "pr_number": 55135,
    "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
    "created_at": "2025-06-18T11:19:01+00:00",
    "commented_code": "##\n        # :method: bigserial\n        # :call-seq: bigserial(*names, **options)\n        #\n        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n        #\n        # This is commonly used for primary keys or large counters that require a greater range\n        # than +serial+ (which is 32-bit).\n        #\n        # Example:\n        #\n        #   t.bigserial :event_id\n        #\n        # The column can also be explicitly declared as the primary key:\n        #\n        #   create_table :events, id: false do |t|\n        #     t.bigserial :id, primary_key: true\n        #   end\n        #\n\n        ##\n        # :method: bit\n        # :call-seq: bit(*names, **options)\n        #\n        # Adds a +bit+ column for storing fixed-length bit strings.\n        #\n        # This type is useful for compactly representing flags or settings as binary values.\n        # By default, you can specify the number of bits the column should store.\n        #\n        # Example:\n        #\n        #   t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n        #\n        # When assigning values, use bit strings:\n        #\n        #   irb> user = User.new",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2154343247",
        "repo_full_name": "rails/rails",
        "pr_number": 55135,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
        "discussion_id": "2154343247",
        "commented_code": "@@ -45,130 +45,805 @@ def primary_key(name, type = :primary_key, **options)\n         ##\n         # :method: bigserial\n         # :call-seq: bigserial(*names, **options)\n+        #\n+        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n+        #\n+        # This is commonly used for primary keys or large counters that require a greater range\n+        # than +serial+ (which is 32-bit).\n+        #\n+        # Example:\n+        #\n+        #   t.bigserial :event_id\n+        #\n+        # The column can also be explicitly declared as the primary key:\n+        #\n+        #   create_table :events, id: false do |t|\n+        #     t.bigserial :id, primary_key: true\n+        #   end\n+        #\n \n         ##\n         # :method: bit\n         # :call-seq: bit(*names, **options)\n+        #\n+        # Adds a +bit+ column for storing fixed-length bit strings.\n+        #\n+        # This type is useful for compactly representing flags or settings as binary values.\n+        # By default, you can specify the number of bits the column should store.\n+        #\n+        # Example:\n+        #\n+        #   t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   irb> user = User.new",
        "comment_created_at": "2025-06-18T11:19:01+00:00",
        "comment_author": "p8",
        "comment_body": "I think we don't think we commonly use a `irb>` prompt for the API docs.\r\nIt's common to just use the Ruby code:\r\n```suggestion\r\n        #   user = User.new\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166825175",
    "pr_number": 55135,
    "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
    "created_at": "2025-06-25T14:11:27+00:00",
    "commented_code": "##\n        # :method: bigserial\n        # :call-seq: bigserial(*names, **options)\n        #\n        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n        #\n        # This is commonly used for primary keys or large counters that require a greater range\n        # than +serial+ (which is 32-bit).\n        #\n        # Example:\n        #\n        #   create_table :events do |t|\n        #     t.bigserial :event_id\n        #   end\n        #\n        # The column can also be explicitly declared as the primary key:\n        #\n        #   create_table :events, id: false do |t|\n        #     t.bigserial :id, primary_key: true\n        #   end\n        #\n\n        ##\n        # :method: bit\n        # :call-seq: bit(*names, **options)\n        #\n        # Adds a +bit+ column for storing fixed-length bit strings.\n        #\n        # This type is useful for compactly representing flags or settings as binary values.\n        # By default, you can specify the number of bits the column should store.\n        #\n        # Example:\n        #\n        #   create_table :users do |t|\n        #     t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n        #   end\n        #\n        # When assigning values, use bit strings:\n        #\n        #   user = User.new\n        #   user.settings = \"01010101\"  # This is a bit string\n        #   user.save!\n\n        ##\n        # :method: bit_varying\n        # :call-seq: bit_varying(*names, **options)\n        #\n        # Adds a +bit_varying+ column for storing variable-length bit strings.\n        #\n        # This type is useful for representing binary flags, feature toggles, or compact\n        # settings as sequences of bits.\n        #\n        # Example:\n        #\n        #   create_table :users do |t|\n        #     t.bit_varying :settings\n        #   end\n        #\n        # The column type can also be specified explicitly:\n        #\n        #   create_table :users do |t|\n        #     t.column :flags, 'bit varying(16)'  # Up to 16 bits\n        #   end\n        #\n        # When assigning values, use bit strings:\n        #\n        #   user = User.new\n        #   user.flags = \"10101\"  # Valid bit string\n        #   user.save!\n        #\n        # When assigning an integer, it will be converted to a bit string:\n        #\n        #   user = User.new\n        #   user.flags = 42  # Stored as \"00101010\"\n        #   user.save!\n        #\n        # When assigning a string that is not a valid bit string, it will raise an error:\n        #\n        #   user = User.new\n        #   user.flags = \"invalid\"  # Raises a PostgreSQL error\n\n        ##\n        # :method: box\n        # :call-seq: box(*names, **options)\n        #\n        # Adds a +box+ column for storing rectangular boxes in a 2D plane.\n        #\n        # The +box+ type is backed by PostgreSQL and represents a rectangle\n        # defined by two opposite corner points.\n        #\n        # Example:\n        #\n        #   create_table :shapes do |t|\n        #     t.box :bounds\n        #   end\n        #\n        # Values can be assigned using PostgreSQL's box syntax:\n        #\n        #   Shape.create(bounds: '((4,4),(1,1))')\n        #\n        # This creates a rectangular box spanning the area between the points\n        # (4,4) and (1,1).\n        #\n        # PostgreSQL treats the order of the points as irrelevant for storage,\n        # but by convention, the first point is considered the upper-right\n        # corner and the second the lower-left.\n\n        ##\n        # :method: binary\n        # :call-seq: binary(*names, **options)\n        #\n        # Adds a binary column mapped to PostgreSQLâ€™s +bytea+ type.\n        #\n        # This is commonly used to store raw binary data such as files, images, or other blobs.\n        #\n        # Example:\n        #\n        #   create_table :responses do |t|\n        #     t.binary :payload\n        #   end\n        #\n        # Binary data from a file can be assigned like this:\n        #\n        #   data = File.read(Rails.root.join(\"tmp/output.pdf\"))\n        #   Document.create(payload: data)\n        #\n        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-binary.html]\n\n        ##\n        # :method: cidr\n        # :call-seq: cidr(*names, **options)\n        #\n        # Adds a +cidr+ column for storing IP addresses and network ranges.\n        #\n        # The +cidr+ stands for Classless Inter-Domain Routing.\n        # It is used to store IP addresses along with their subnet masks, such as '192.168.0.0/24'.\n        # The +cidr+ type is mapped to Ruby [IPAddr](https://docs.ruby-lang.org/en/master/IPAddr.html).\n        #\n        # Example:\n        #\n        #   create_table(:devices, force: true) do |t|\n        #     t.cidr \"network\"\n        #   end\n        #\n        # Values can be assigned using standard PostgreSQL CIDR syntax:\n        #\n        #   device = Device.create(network: '192.168.0.0/24')\n        #   device.network\n        #   # => #<IPAddr: IPv4:192.168.0.0/255.255.255.0>\n        #\n        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-net-types.html]\n\n        ##\n        # :method: circle\n        # :call-seq: circle(*names, **options)\n        #\n        # Adds a +circle+ column for storing circular geometric objects.\n        #\n        # Example:\n        #\n        #   create_table :circles do |t|\n        #     t.circle :bounds\n        #   end\n        #\n        # A circle value is stored as a center point and a radius. In SQL, the format is: CIRCLE '((x, y), r)'\n        #\n        #  Circle.create(bounds: '((1,1),2)')\n        #\n        # This creates a circle centered at (1,1) with a radius of 2.\n\n        ##\n        # :method: citext\n        # :call-seq: citext(*names, **options)\n        #\n        # Adds a +citext+ column for storing case-insensitive text values.\n        #\n        # This is backed by PostgreSQLâ€™s +citext+ extension, which treats values\n        # as case-insensitive for comparisons and indexing.\n        #\n        # Example:\n        #\n        #   create_table :users do |t|\n        #     t.citext :email\n        #   end\n        #\n        # This creates a column named +email+ that will treat values like \"User@example.com\"\n        # and \"user@example.com\" as equal.\n\n        ##\n        # :method: daterange\n        # :call-seq: daterange(*names, **options)\n        #\n        # Adds a +daterange+ column which allows storage and querying\n        # of inclusive or exclusive date intervals.\n        #\n        # This type is mapped to {Ruby Range}[https://docs.ruby-lang.org/en/master/Range.html] objects.\n        #\n        # Example:\n        #   create_table :events do |t|\n        #     t.daterange :duration\n        #   end\n        #\n        # This creates a column named +duration+ that can store ranges like:\n        #   '2024-01-01'..'2024-12-31'\n        #\n        #  Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))\n        #\n        #  event = Event.first\n        #  event.duration\n        #  # => Tue, 11 Feb 2014...Thu, 13 Feb 2014\n        #\n        # For all events on a given date:\n        #\n        #  Event.where(\"duration @> ?::date\", Date.new(2014, 2, 12))\n        #\n        # Working with range bounds:\n        #\n        #  event = Event.select(\"lower(duration) AS starts_at\").select(\"upper(duration) AS ends_at\").first\n        #\n        #  event.starts_at\n        #  # => Tue, 11 Feb 2014\n        #\n        #  event.ends_at\n        #  # => Thu, 13 Feb 2014\n        #\n        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/rangetypes.html] and PostgreSQL range functions and operators}[https://www.postgresql.org/docs/current/static/functions-range.html]\n\n        ##\n        # :method: enum\n        # :call-seq: enum(*names, **options)\n        #\n        # Adds an +enum+ column for storing enumerated values.\n        #\n        # The PostgreSQL +enum+ type can be used directly as a column, or mapped to\n        # an {ActiveRecord::Enum}[https://api.rubyonrails.org/classes/ActiveRecord/Enum.html]\n        # to add model-level helpers and validations.\n        #\n        # Example:\n        #\n        # Creating an enum type and using it in a new table:\n        #\n        #   # db/migrate/20131220144913_create_articles.rb\n        #   def change\n        #     create_enum :article_status, [\"draft\", \"published\", \"archived\"]\n        #\n        #     create_table :articles do |t|\n        #       t.enum :status, enum_type: :article_status, default: \"draft\", null: false\n        #     end\n        #   end\n        #\n        # The enum can also be added it to an existing table:\n        #\n        #   # db/migrate/20230113024409_add_status_to_articles.rb\n        #   def change\n        #     create_enum :article_status, [\"draft\", \"published\", \"archived\"]\n        #     add_column :articles, :status, :enum, enum_type: :article_status, default: \"draft\", null: false\n        #   end\n        #\n        # The above migrations are reversible. If you need custom up/down logic:\n        #\n        #   def down\n        #     drop_table :articles\n        #     # OR: remove_column :articles, :status\n        #     drop_enum :article_status\n        #   end\n        #\n        # Make sure you remove any columns or tables that depend on the enum type before dropping it.\n        #\n        # Declaring enum in the model adds helper methods and prevents invalid values from being assigned to instances of the class:\n        #\n        #   # app/models/article.rb\n        #   class Article < ApplicationRecord\n        #     enum :status, {\n        #       draft: \"draft\", published: \"published\", archived: \"archived\"\n        #     }, prefix: true\n        #   end\n        #\n        # Usage:\n        #\n        #  article = Article.create\n        #  article.status\n        #  # => \"draft\"\n        #\n        #  article.status_published!\n        #  article.status\n        #  # => \"published\"\n        #\n        #  article.status_archived?\n        #  # => false\n        #\n        #  article.status = \"deleted\"\n        #  # => ArgumentError: 'deleted' is not a valid status\n        #\n        # To rename an enum type:\n        #\n        #   def change\n        #     rename_enum :article_status, :article_state\n        #   end\n        #\n        # To add new values to an enum:\n        #\n        #   def up\n        #     add_enum_value :article_state, \"archived\"                     # Appends at end\n        #     add_enum_value :article_state, \"in review\", before: \"published\"\n        #     add_enum_value :article_state, \"approved\", after: \"in review\"\n        #     add_enum_value :article_state, \"rejected\", if_not_exists: true\n        #   end\n        #\n        # {Enum values can't be dropped}[https://www.postgresql.org/message-id/29F36C7C98AB09499B1A209D48EAA615B7653DBC8A@mail2a.alliedtesting.com], so +add_enum_value+ is irreversible.\n        #\n        # To rename an enum value:\n        #\n        #   def change\n        #     rename_enum_value :article_state, from: \"archived\", to: \"deleted\"\n        #   end\n        #\n        # To inspect all enum types and values in the database use this query in +bin/rails db+ or +psql+ console:",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2166825175",
        "repo_full_name": "rails/rails",
        "pr_number": 55135,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
        "discussion_id": "2166825175",
        "commented_code": "@@ -45,130 +45,859 @@ def primary_key(name, type = :primary_key, **options)\n         ##\n         # :method: bigserial\n         # :call-seq: bigserial(*names, **options)\n+        #\n+        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n+        #\n+        # This is commonly used for primary keys or large counters that require a greater range\n+        # than +serial+ (which is 32-bit).\n+        #\n+        # Example:\n+        #\n+        #   create_table :events do |t|\n+        #     t.bigserial :event_id\n+        #   end\n+        #\n+        # The column can also be explicitly declared as the primary key:\n+        #\n+        #   create_table :events, id: false do |t|\n+        #     t.bigserial :id, primary_key: true\n+        #   end\n+        #\n \n         ##\n         # :method: bit\n         # :call-seq: bit(*names, **options)\n+        #\n+        # Adds a +bit+ column for storing fixed-length bit strings.\n+        #\n+        # This type is useful for compactly representing flags or settings as binary values.\n+        # By default, you can specify the number of bits the column should store.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n+        #   end\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   user = User.new\n+        #   user.settings = \"01010101\"  # This is a bit string\n+        #   user.save!\n \n         ##\n         # :method: bit_varying\n         # :call-seq: bit_varying(*names, **options)\n+        #\n+        # Adds a +bit_varying+ column for storing variable-length bit strings.\n+        #\n+        # This type is useful for representing binary flags, feature toggles, or compact\n+        # settings as sequences of bits.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.bit_varying :settings\n+        #   end\n+        #\n+        # The column type can also be specified explicitly:\n+        #\n+        #   create_table :users do |t|\n+        #     t.column :flags, 'bit varying(16)'  # Up to 16 bits\n+        #   end\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   user = User.new\n+        #   user.flags = \"10101\"  # Valid bit string\n+        #   user.save!\n+        #\n+        # When assigning an integer, it will be converted to a bit string:\n+        #\n+        #   user = User.new\n+        #   user.flags = 42  # Stored as \"00101010\"\n+        #   user.save!\n+        #\n+        # When assigning a string that is not a valid bit string, it will raise an error:\n+        #\n+        #   user = User.new\n+        #   user.flags = \"invalid\"  # Raises a PostgreSQL error\n+\n+        ##\n+        # :method: box\n+        # :call-seq: box(*names, **options)\n+        #\n+        # Adds a +box+ column for storing rectangular boxes in a 2D plane.\n+        #\n+        # The +box+ type is backed by PostgreSQL and represents a rectangle\n+        # defined by two opposite corner points.\n+        #\n+        # Example:\n+        #\n+        #   create_table :shapes do |t|\n+        #     t.box :bounds\n+        #   end\n+        #\n+        # Values can be assigned using PostgreSQL's box syntax:\n+        #\n+        #   Shape.create(bounds: '((4,4),(1,1))')\n+        #\n+        # This creates a rectangular box spanning the area between the points\n+        # (4,4) and (1,1).\n+        #\n+        # PostgreSQL treats the order of the points as irrelevant for storage,\n+        # but by convention, the first point is considered the upper-right\n+        # corner and the second the lower-left.\n+\n+        ##\n+        # :method: binary\n+        # :call-seq: binary(*names, **options)\n+        #\n+        # Adds a binary column mapped to PostgreSQLâ€™s +bytea+ type.\n+        #\n+        # This is commonly used to store raw binary data such as files, images, or other blobs.\n+        #\n+        # Example:\n+        #\n+        #   create_table :responses do |t|\n+        #     t.binary :payload\n+        #   end\n+        #\n+        # Binary data from a file can be assigned like this:\n+        #\n+        #   data = File.read(Rails.root.join(\"tmp/output.pdf\"))\n+        #   Document.create(payload: data)\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-binary.html]\n \n         ##\n         # :method: cidr\n         # :call-seq: cidr(*names, **options)\n+        #\n+        # Adds a +cidr+ column for storing IP addresses and network ranges.\n+        #\n+        # The +cidr+ stands for Classless Inter-Domain Routing.\n+        # It is used to store IP addresses along with their subnet masks, such as '192.168.0.0/24'.\n+        # The +cidr+ type is mapped to Ruby [IPAddr](https://docs.ruby-lang.org/en/master/IPAddr.html).\n+        #\n+        # Example:\n+        #\n+        #   create_table(:devices, force: true) do |t|\n+        #     t.cidr \"network\"\n+        #   end\n+        #\n+        # Values can be assigned using standard PostgreSQL CIDR syntax:\n+        #\n+        #   device = Device.create(network: '192.168.0.0/24')\n+        #   device.network\n+        #   # => #<IPAddr: IPv4:192.168.0.0/255.255.255.0>\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-net-types.html]\n+\n+        ##\n+        # :method: circle\n+        # :call-seq: circle(*names, **options)\n+        #\n+        # Adds a +circle+ column for storing circular geometric objects.\n+        #\n+        # Example:\n+        #\n+        #   create_table :circles do |t|\n+        #     t.circle :bounds\n+        #   end\n+        #\n+        # A circle value is stored as a center point and a radius. In SQL, the format is: CIRCLE '((x, y), r)'\n+        #\n+        #  Circle.create(bounds: '((1,1),2)')\n+        #\n+        # This creates a circle centered at (1,1) with a radius of 2.\n \n         ##\n         # :method: citext\n         # :call-seq: citext(*names, **options)\n+        #\n+        # Adds a +citext+ column for storing case-insensitive text values.\n+        #\n+        # This is backed by PostgreSQLâ€™s +citext+ extension, which treats values\n+        # as case-insensitive for comparisons and indexing.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.citext :email\n+        #   end\n+        #\n+        # This creates a column named +email+ that will treat values like \"User@example.com\"\n+        # and \"user@example.com\" as equal.\n \n         ##\n         # :method: daterange\n         # :call-seq: daterange(*names, **options)\n+        #\n+        # Adds a +daterange+ column which allows storage and querying\n+        # of inclusive or exclusive date intervals.\n+        #\n+        # This type is mapped to {Ruby Range}[https://docs.ruby-lang.org/en/master/Range.html] objects.\n+        #\n+        # Example:\n+        #   create_table :events do |t|\n+        #     t.daterange :duration\n+        #   end\n+        #\n+        # This creates a column named +duration+ that can store ranges like:\n+        #   '2024-01-01'..'2024-12-31'\n+        #\n+        #  Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))\n+        #\n+        #  event = Event.first\n+        #  event.duration\n+        #  # => Tue, 11 Feb 2014...Thu, 13 Feb 2014\n+        #\n+        # For all events on a given date:\n+        #\n+        #  Event.where(\"duration @> ?::date\", Date.new(2014, 2, 12))\n+        #\n+        # Working with range bounds:\n+        #\n+        #  event = Event.select(\"lower(duration) AS starts_at\").select(\"upper(duration) AS ends_at\").first\n+        #\n+        #  event.starts_at\n+        #  # => Tue, 11 Feb 2014\n+        #\n+        #  event.ends_at\n+        #  # => Thu, 13 Feb 2014\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/rangetypes.html] and PostgreSQL range functions and operators}[https://www.postgresql.org/docs/current/static/functions-range.html]\n+\n+        ##\n+        # :method: enum\n+        # :call-seq: enum(*names, **options)\n+        #\n+        # Adds an +enum+ column for storing enumerated values.\n+        #\n+        # The PostgreSQL +enum+ type can be used directly as a column, or mapped to\n+        # an {ActiveRecord::Enum}[https://api.rubyonrails.org/classes/ActiveRecord/Enum.html]\n+        # to add model-level helpers and validations.\n+        #\n+        # Example:\n+        #\n+        # Creating an enum type and using it in a new table:\n+        #\n+        #   # db/migrate/20131220144913_create_articles.rb\n+        #   def change\n+        #     create_enum :article_status, [\"draft\", \"published\", \"archived\"]\n+        #\n+        #     create_table :articles do |t|\n+        #       t.enum :status, enum_type: :article_status, default: \"draft\", null: false\n+        #     end\n+        #   end\n+        #\n+        # The enum can also be added it to an existing table:\n+        #\n+        #   # db/migrate/20230113024409_add_status_to_articles.rb\n+        #   def change\n+        #     create_enum :article_status, [\"draft\", \"published\", \"archived\"]\n+        #     add_column :articles, :status, :enum, enum_type: :article_status, default: \"draft\", null: false\n+        #   end\n+        #\n+        # The above migrations are reversible. If you need custom up/down logic:\n+        #\n+        #   def down\n+        #     drop_table :articles\n+        #     # OR: remove_column :articles, :status\n+        #     drop_enum :article_status\n+        #   end\n+        #\n+        # Make sure you remove any columns or tables that depend on the enum type before dropping it.\n+        #\n+        # Declaring enum in the model adds helper methods and prevents invalid values from being assigned to instances of the class:\n+        #\n+        #   # app/models/article.rb\n+        #   class Article < ApplicationRecord\n+        #     enum :status, {\n+        #       draft: \"draft\", published: \"published\", archived: \"archived\"\n+        #     }, prefix: true\n+        #   end\n+        #\n+        # Usage:\n+        #\n+        #  article = Article.create\n+        #  article.status\n+        #  # => \"draft\"\n+        #\n+        #  article.status_published!\n+        #  article.status\n+        #  # => \"published\"\n+        #\n+        #  article.status_archived?\n+        #  # => false\n+        #\n+        #  article.status = \"deleted\"\n+        #  # => ArgumentError: 'deleted' is not a valid status\n+        #\n+        # To rename an enum type:\n+        #\n+        #   def change\n+        #     rename_enum :article_status, :article_state\n+        #   end\n+        #\n+        # To add new values to an enum:\n+        #\n+        #   def up\n+        #     add_enum_value :article_state, \"archived\"                     # Appends at end\n+        #     add_enum_value :article_state, \"in review\", before: \"published\"\n+        #     add_enum_value :article_state, \"approved\", after: \"in review\"\n+        #     add_enum_value :article_state, \"rejected\", if_not_exists: true\n+        #   end\n+        #\n+        # {Enum values can't be dropped}[https://www.postgresql.org/message-id/29F36C7C98AB09499B1A209D48EAA615B7653DBC8A@mail2a.alliedtesting.com], so +add_enum_value+ is irreversible.\n+        #\n+        # To rename an enum value:\n+        #\n+        #   def change\n+        #     rename_enum_value :article_state, from: \"archived\", to: \"deleted\"\n+        #   end\n+        #\n+        # To inspect all enum types and values in the database use this query in +bin/rails db+ or +psql+ console:",
        "comment_created_at": "2025-06-25T14:11:27+00:00",
        "comment_author": "p8",
        "comment_body": "Using `+` [doesn't work](https://edgeguides.rubyonrails.org/api_documentation_guidelines.html#fixed-width-font) if the inner statement contains spaces.\r\n```\r\necho \"+bin/rails db+\" | rdoc --pipe\r\n```\r\nThese need to be surrounded with `<tt>`.\r\n```suggestion\r\n        # To inspect all enum types and values in the database use this query in +bin/rails db+ or +psql+ console:\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2174419508",
        "repo_full_name": "rails/rails",
        "pr_number": 55135,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
        "discussion_id": "2166825175",
        "commented_code": "@@ -45,130 +45,859 @@ def primary_key(name, type = :primary_key, **options)\n         ##\n         # :method: bigserial\n         # :call-seq: bigserial(*names, **options)\n+        #\n+        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n+        #\n+        # This is commonly used for primary keys or large counters that require a greater range\n+        # than +serial+ (which is 32-bit).\n+        #\n+        # Example:\n+        #\n+        #   create_table :events do |t|\n+        #     t.bigserial :event_id\n+        #   end\n+        #\n+        # The column can also be explicitly declared as the primary key:\n+        #\n+        #   create_table :events, id: false do |t|\n+        #     t.bigserial :id, primary_key: true\n+        #   end\n+        #\n \n         ##\n         # :method: bit\n         # :call-seq: bit(*names, **options)\n+        #\n+        # Adds a +bit+ column for storing fixed-length bit strings.\n+        #\n+        # This type is useful for compactly representing flags or settings as binary values.\n+        # By default, you can specify the number of bits the column should store.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n+        #   end\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   user = User.new\n+        #   user.settings = \"01010101\"  # This is a bit string\n+        #   user.save!\n \n         ##\n         # :method: bit_varying\n         # :call-seq: bit_varying(*names, **options)\n+        #\n+        # Adds a +bit_varying+ column for storing variable-length bit strings.\n+        #\n+        # This type is useful for representing binary flags, feature toggles, or compact\n+        # settings as sequences of bits.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.bit_varying :settings\n+        #   end\n+        #\n+        # The column type can also be specified explicitly:\n+        #\n+        #   create_table :users do |t|\n+        #     t.column :flags, 'bit varying(16)'  # Up to 16 bits\n+        #   end\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   user = User.new\n+        #   user.flags = \"10101\"  # Valid bit string\n+        #   user.save!\n+        #\n+        # When assigning an integer, it will be converted to a bit string:\n+        #\n+        #   user = User.new\n+        #   user.flags = 42  # Stored as \"00101010\"\n+        #   user.save!\n+        #\n+        # When assigning a string that is not a valid bit string, it will raise an error:\n+        #\n+        #   user = User.new\n+        #   user.flags = \"invalid\"  # Raises a PostgreSQL error\n+\n+        ##\n+        # :method: box\n+        # :call-seq: box(*names, **options)\n+        #\n+        # Adds a +box+ column for storing rectangular boxes in a 2D plane.\n+        #\n+        # The +box+ type is backed by PostgreSQL and represents a rectangle\n+        # defined by two opposite corner points.\n+        #\n+        # Example:\n+        #\n+        #   create_table :shapes do |t|\n+        #     t.box :bounds\n+        #   end\n+        #\n+        # Values can be assigned using PostgreSQL's box syntax:\n+        #\n+        #   Shape.create(bounds: '((4,4),(1,1))')\n+        #\n+        # This creates a rectangular box spanning the area between the points\n+        # (4,4) and (1,1).\n+        #\n+        # PostgreSQL treats the order of the points as irrelevant for storage,\n+        # but by convention, the first point is considered the upper-right\n+        # corner and the second the lower-left.\n+\n+        ##\n+        # :method: binary\n+        # :call-seq: binary(*names, **options)\n+        #\n+        # Adds a binary column mapped to PostgreSQLâ€™s +bytea+ type.\n+        #\n+        # This is commonly used to store raw binary data such as files, images, or other blobs.\n+        #\n+        # Example:\n+        #\n+        #   create_table :responses do |t|\n+        #     t.binary :payload\n+        #   end\n+        #\n+        # Binary data from a file can be assigned like this:\n+        #\n+        #   data = File.read(Rails.root.join(\"tmp/output.pdf\"))\n+        #   Document.create(payload: data)\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-binary.html]\n \n         ##\n         # :method: cidr\n         # :call-seq: cidr(*names, **options)\n+        #\n+        # Adds a +cidr+ column for storing IP addresses and network ranges.\n+        #\n+        # The +cidr+ stands for Classless Inter-Domain Routing.\n+        # It is used to store IP addresses along with their subnet masks, such as '192.168.0.0/24'.\n+        # The +cidr+ type is mapped to Ruby [IPAddr](https://docs.ruby-lang.org/en/master/IPAddr.html).\n+        #\n+        # Example:\n+        #\n+        #   create_table(:devices, force: true) do |t|\n+        #     t.cidr \"network\"\n+        #   end\n+        #\n+        # Values can be assigned using standard PostgreSQL CIDR syntax:\n+        #\n+        #   device = Device.create(network: '192.168.0.0/24')\n+        #   device.network\n+        #   # => #<IPAddr: IPv4:192.168.0.0/255.255.255.0>\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-net-types.html]\n+\n+        ##\n+        # :method: circle\n+        # :call-seq: circle(*names, **options)\n+        #\n+        # Adds a +circle+ column for storing circular geometric objects.\n+        #\n+        # Example:\n+        #\n+        #   create_table :circles do |t|\n+        #     t.circle :bounds\n+        #   end\n+        #\n+        # A circle value is stored as a center point and a radius. In SQL, the format is: CIRCLE '((x, y), r)'\n+        #\n+        #  Circle.create(bounds: '((1,1),2)')\n+        #\n+        # This creates a circle centered at (1,1) with a radius of 2.\n \n         ##\n         # :method: citext\n         # :call-seq: citext(*names, **options)\n+        #\n+        # Adds a +citext+ column for storing case-insensitive text values.\n+        #\n+        # This is backed by PostgreSQLâ€™s +citext+ extension, which treats values\n+        # as case-insensitive for comparisons and indexing.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.citext :email\n+        #   end\n+        #\n+        # This creates a column named +email+ that will treat values like \"User@example.com\"\n+        # and \"user@example.com\" as equal.\n \n         ##\n         # :method: daterange\n         # :call-seq: daterange(*names, **options)\n+        #\n+        # Adds a +daterange+ column which allows storage and querying\n+        # of inclusive or exclusive date intervals.\n+        #\n+        # This type is mapped to {Ruby Range}[https://docs.ruby-lang.org/en/master/Range.html] objects.\n+        #\n+        # Example:\n+        #   create_table :events do |t|\n+        #     t.daterange :duration\n+        #   end\n+        #\n+        # This creates a column named +duration+ that can store ranges like:\n+        #   '2024-01-01'..'2024-12-31'\n+        #\n+        #  Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))\n+        #\n+        #  event = Event.first\n+        #  event.duration\n+        #  # => Tue, 11 Feb 2014...Thu, 13 Feb 2014\n+        #\n+        # For all events on a given date:\n+        #\n+        #  Event.where(\"duration @> ?::date\", Date.new(2014, 2, 12))\n+        #\n+        # Working with range bounds:\n+        #\n+        #  event = Event.select(\"lower(duration) AS starts_at\").select(\"upper(duration) AS ends_at\").first\n+        #\n+        #  event.starts_at\n+        #  # => Tue, 11 Feb 2014\n+        #\n+        #  event.ends_at\n+        #  # => Thu, 13 Feb 2014\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/rangetypes.html] and PostgreSQL range functions and operators}[https://www.postgresql.org/docs/current/static/functions-range.html]\n+\n+        ##\n+        # :method: enum\n+        # :call-seq: enum(*names, **options)\n+        #\n+        # Adds an +enum+ column for storing enumerated values.\n+        #\n+        # The PostgreSQL +enum+ type can be used directly as a column, or mapped to\n+        # an {ActiveRecord::Enum}[https://api.rubyonrails.org/classes/ActiveRecord/Enum.html]\n+        # to add model-level helpers and validations.\n+        #\n+        # Example:\n+        #\n+        # Creating an enum type and using it in a new table:\n+        #\n+        #   # db/migrate/20131220144913_create_articles.rb\n+        #   def change\n+        #     create_enum :article_status, [\"draft\", \"published\", \"archived\"]\n+        #\n+        #     create_table :articles do |t|\n+        #       t.enum :status, enum_type: :article_status, default: \"draft\", null: false\n+        #     end\n+        #   end\n+        #\n+        # The enum can also be added it to an existing table:\n+        #\n+        #   # db/migrate/20230113024409_add_status_to_articles.rb\n+        #   def change\n+        #     create_enum :article_status, [\"draft\", \"published\", \"archived\"]\n+        #     add_column :articles, :status, :enum, enum_type: :article_status, default: \"draft\", null: false\n+        #   end\n+        #\n+        # The above migrations are reversible. If you need custom up/down logic:\n+        #\n+        #   def down\n+        #     drop_table :articles\n+        #     # OR: remove_column :articles, :status\n+        #     drop_enum :article_status\n+        #   end\n+        #\n+        # Make sure you remove any columns or tables that depend on the enum type before dropping it.\n+        #\n+        # Declaring enum in the model adds helper methods and prevents invalid values from being assigned to instances of the class:\n+        #\n+        #   # app/models/article.rb\n+        #   class Article < ApplicationRecord\n+        #     enum :status, {\n+        #       draft: \"draft\", published: \"published\", archived: \"archived\"\n+        #     }, prefix: true\n+        #   end\n+        #\n+        # Usage:\n+        #\n+        #  article = Article.create\n+        #  article.status\n+        #  # => \"draft\"\n+        #\n+        #  article.status_published!\n+        #  article.status\n+        #  # => \"published\"\n+        #\n+        #  article.status_archived?\n+        #  # => false\n+        #\n+        #  article.status = \"deleted\"\n+        #  # => ArgumentError: 'deleted' is not a valid status\n+        #\n+        # To rename an enum type:\n+        #\n+        #   def change\n+        #     rename_enum :article_status, :article_state\n+        #   end\n+        #\n+        # To add new values to an enum:\n+        #\n+        #   def up\n+        #     add_enum_value :article_state, \"archived\"                     # Appends at end\n+        #     add_enum_value :article_state, \"in review\", before: \"published\"\n+        #     add_enum_value :article_state, \"approved\", after: \"in review\"\n+        #     add_enum_value :article_state, \"rejected\", if_not_exists: true\n+        #   end\n+        #\n+        # {Enum values can't be dropped}[https://www.postgresql.org/message-id/29F36C7C98AB09499B1A209D48EAA615B7653DBC8A@mail2a.alliedtesting.com], so +add_enum_value+ is irreversible.\n+        #\n+        # To rename an enum value:\n+        #\n+        #   def change\n+        #     rename_enum_value :article_state, from: \"archived\", to: \"deleted\"\n+        #   end\n+        #\n+        # To inspect all enum types and values in the database use this query in +bin/rails db+ or +psql+ console:",
        "comment_created_at": "2025-06-30T07:34:06+00:00",
        "comment_author": "Ridhwana",
        "comment_body": "âœ…",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166856107",
    "pr_number": 55135,
    "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
    "created_at": "2025-06-25T14:21:54+00:00",
    "commented_code": "##\n        # :method: bigserial\n        # :call-seq: bigserial(*names, **options)\n        #\n        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n        #\n        # This is commonly used for primary keys or large counters that require a greater range\n        # than +serial+ (which is 32-bit).\n        #\n        # Example:\n        #\n        #   create_table :events do |t|\n        #     t.bigserial :event_id\n        #   end\n        #\n        # The column can also be explicitly declared as the primary key:\n        #\n        #   create_table :events, id: false do |t|\n        #     t.bigserial :id, primary_key: true\n        #   end\n        #\n\n        ##\n        # :method: bit\n        # :call-seq: bit(*names, **options)\n        #\n        # Adds a +bit+ column for storing fixed-length bit strings.\n        #\n        # This type is useful for compactly representing flags or settings as binary values.\n        # By default, you can specify the number of bits the column should store.\n        #\n        # Example:\n        #\n        #   create_table :users do |t|\n        #     t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n        #   end\n        #\n        # When assigning values, use bit strings:\n        #\n        #   user = User.new\n        #   user.settings = \"01010101\"  # This is a bit string\n        #   user.save!\n\n        ##\n        # :method: bit_varying\n        # :call-seq: bit_varying(*names, **options)\n        #\n        # Adds a +bit_varying+ column for storing variable-length bit strings.\n        #\n        # This type is useful for representing binary flags, feature toggles, or compact\n        # settings as sequences of bits.\n        #\n        # Example:\n        #\n        #   create_table :users do |t|\n        #     t.bit_varying :settings\n        #   end\n        #\n        # The column type can also be specified explicitly:\n        #\n        #   create_table :users do |t|\n        #     t.column :flags, 'bit varying(16)'  # Up to 16 bits\n        #   end\n        #\n        # When assigning values, use bit strings:\n        #\n        #   user = User.new\n        #   user.flags = \"10101\"  # Valid bit string\n        #   user.save!\n        #\n        # When assigning an integer, it will be converted to a bit string:\n        #\n        #   user = User.new\n        #   user.flags = 42  # Stored as \"00101010\"\n        #   user.save!\n        #\n        # When assigning a string that is not a valid bit string, it will raise an error:\n        #\n        #   user = User.new\n        #   user.flags = \"invalid\"  # Raises a PostgreSQL error\n\n        ##\n        # :method: box\n        # :call-seq: box(*names, **options)\n        #\n        # Adds a +box+ column for storing rectangular boxes in a 2D plane.\n        #\n        # The +box+ type is backed by PostgreSQL and represents a rectangle\n        # defined by two opposite corner points.\n        #\n        # Example:\n        #\n        #   create_table :shapes do |t|\n        #     t.box :bounds\n        #   end\n        #\n        # Values can be assigned using PostgreSQL's box syntax:\n        #\n        #   Shape.create(bounds: '((4,4),(1,1))')\n        #\n        # This creates a rectangular box spanning the area between the points\n        # (4,4) and (1,1).\n        #\n        # PostgreSQL treats the order of the points as irrelevant for storage,\n        # but by convention, the first point is considered the upper-right\n        # corner and the second the lower-left.\n\n        ##\n        # :method: binary\n        # :call-seq: binary(*names, **options)\n        #\n        # Adds a binary column mapped to PostgreSQLâ€™s +bytea+ type.\n        #\n        # This is commonly used to store raw binary data such as files, images, or other blobs.\n        #\n        # Example:\n        #\n        #   create_table :responses do |t|\n        #     t.binary :payload\n        #   end\n        #\n        # Binary data from a file can be assigned like this:\n        #\n        #   data = File.read(Rails.root.join(\"tmp/output.pdf\"))\n        #   Document.create(payload: data)\n        #\n        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-binary.html]\n\n        ##\n        # :method: cidr\n        # :call-seq: cidr(*names, **options)\n        #\n        # Adds a +cidr+ column for storing IP addresses and network ranges.\n        #\n        # The +cidr+ stands for Classless Inter-Domain Routing.\n        # It is used to store IP addresses along with their subnet masks, such as '192.168.0.0/24'.",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2166856107",
        "repo_full_name": "rails/rails",
        "pr_number": 55135,
        "pr_file": "activerecord/lib/active_record/connection_adapters/postgresql/schema_definitions.rb",
        "discussion_id": "2166856107",
        "commented_code": "@@ -45,130 +45,859 @@ def primary_key(name, type = :primary_key, **options)\n         ##\n         # :method: bigserial\n         # :call-seq: bigserial(*names, **options)\n+        #\n+        # Adds a +bigserial+ column, which is a PostgreSQL auto-incrementing 64-bit integer.\n+        #\n+        # This is commonly used for primary keys or large counters that require a greater range\n+        # than +serial+ (which is 32-bit).\n+        #\n+        # Example:\n+        #\n+        #   create_table :events do |t|\n+        #     t.bigserial :event_id\n+        #   end\n+        #\n+        # The column can also be explicitly declared as the primary key:\n+        #\n+        #   create_table :events, id: false do |t|\n+        #     t.bigserial :id, primary_key: true\n+        #   end\n+        #\n \n         ##\n         # :method: bit\n         # :call-seq: bit(*names, **options)\n+        #\n+        # Adds a +bit+ column for storing fixed-length bit strings.\n+        #\n+        # This type is useful for compactly representing flags or settings as binary values.\n+        # By default, you can specify the number of bits the column should store.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.column :settings, \"bit(8)\"  # Stores exactly 8 bits\n+        #   end\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   user = User.new\n+        #   user.settings = \"01010101\"  # This is a bit string\n+        #   user.save!\n \n         ##\n         # :method: bit_varying\n         # :call-seq: bit_varying(*names, **options)\n+        #\n+        # Adds a +bit_varying+ column for storing variable-length bit strings.\n+        #\n+        # This type is useful for representing binary flags, feature toggles, or compact\n+        # settings as sequences of bits.\n+        #\n+        # Example:\n+        #\n+        #   create_table :users do |t|\n+        #     t.bit_varying :settings\n+        #   end\n+        #\n+        # The column type can also be specified explicitly:\n+        #\n+        #   create_table :users do |t|\n+        #     t.column :flags, 'bit varying(16)'  # Up to 16 bits\n+        #   end\n+        #\n+        # When assigning values, use bit strings:\n+        #\n+        #   user = User.new\n+        #   user.flags = \"10101\"  # Valid bit string\n+        #   user.save!\n+        #\n+        # When assigning an integer, it will be converted to a bit string:\n+        #\n+        #   user = User.new\n+        #   user.flags = 42  # Stored as \"00101010\"\n+        #   user.save!\n+        #\n+        # When assigning a string that is not a valid bit string, it will raise an error:\n+        #\n+        #   user = User.new\n+        #   user.flags = \"invalid\"  # Raises a PostgreSQL error\n+\n+        ##\n+        # :method: box\n+        # :call-seq: box(*names, **options)\n+        #\n+        # Adds a +box+ column for storing rectangular boxes in a 2D plane.\n+        #\n+        # The +box+ type is backed by PostgreSQL and represents a rectangle\n+        # defined by two opposite corner points.\n+        #\n+        # Example:\n+        #\n+        #   create_table :shapes do |t|\n+        #     t.box :bounds\n+        #   end\n+        #\n+        # Values can be assigned using PostgreSQL's box syntax:\n+        #\n+        #   Shape.create(bounds: '((4,4),(1,1))')\n+        #\n+        # This creates a rectangular box spanning the area between the points\n+        # (4,4) and (1,1).\n+        #\n+        # PostgreSQL treats the order of the points as irrelevant for storage,\n+        # but by convention, the first point is considered the upper-right\n+        # corner and the second the lower-left.\n+\n+        ##\n+        # :method: binary\n+        # :call-seq: binary(*names, **options)\n+        #\n+        # Adds a binary column mapped to PostgreSQLâ€™s +bytea+ type.\n+        #\n+        # This is commonly used to store raw binary data such as files, images, or other blobs.\n+        #\n+        # Example:\n+        #\n+        #   create_table :responses do |t|\n+        #     t.binary :payload\n+        #   end\n+        #\n+        # Binary data from a file can be assigned like this:\n+        #\n+        #   data = File.read(Rails.root.join(\"tmp/output.pdf\"))\n+        #   Document.create(payload: data)\n+        #\n+        # ðŸ”— See also: {PostgreSQL type definition}[https://www.postgresql.org/docs/current/static/datatype-binary.html]\n \n         ##\n         # :method: cidr\n         # :call-seq: cidr(*names, **options)\n+        #\n+        # Adds a +cidr+ column for storing IP addresses and network ranges.\n+        #\n+        # The +cidr+ stands for Classless Inter-Domain Routing.\n+        # It is used to store IP addresses along with their subnet masks, such as '192.168.0.0/24'.",
        "comment_created_at": "2025-06-25T14:21:54+00:00",
        "comment_author": "p8",
        "comment_body": "Single quotes `'` are transformed to `â€˜` by Rdoc:\r\n<img width=\"988\" alt=\"image\" src=\"https://github.com/user-attachments/assets/b683fc57-a017-4c15-a7d4-1ad77feb23fb\" />\r\nThis can be avoided by wrapping it in `<tt>` tags:\r\n```suggestion\r\n        # It is used to store IP addresses along with their subnet masks, such as <tt>192.168.0.0/24</tt>.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166884710",
    "pr_number": 55135,
    "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb",
    "created_at": "2025-06-25T14:32:19+00:00",
    "commented_code": "column(name, type, **options, primary_key: true)\n      end\n\n      ##\n      # :method: column\n      # :call-seq: column(name, type, **options)\n      #\n      # Appends a column or columns of a specified type.\n      #\n      #  t.string(:goat)\n      #  t.string(:goat, :sheep)\n      #\n      # See TableDefinition#column\n\n      ##\n      # :method: bigint\n      # :call-seq: bigint(*names, **options)\n      #\n      # Adds a +bigint+ column for storing large integer values.\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Example:\n      #\n      #   create_table :subscriptions do |t|\n      #     t.bigint :account_id\n      #     t.bigint :event_ids, array: true, default: []\n      #   end\n\n      ##\n      # :method: binary\n      # :call-seq: binary(*names, **options)\n      #\n      # Adds a +binary+ column for storing binary data such as files or blobs.\n      #\n      # Example:\n      #\n      #   create_table :responses do |t|\n      #     t.binary :payload\n      #   end\n\n      ##\n      # :method: boolean\n      # :call-seq: boolean(*names, **options)\n      #\n      # Adds a +boolean+ column for storing true/false values.\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Example:\n      #\n      #   create_table :features do |t|\n      #     t.boolean :active\n      #     t.boolean :flags, array: true, default: []\n      #   end\n\n      ##\n      # :method: date\n      # :call-seq: date(*names, **options)\n      #\n      # Adds a +date+ column for storing calendar dates (year, month, day).\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Example:\n      #\n      #   create_table :schedules do |t|\n      #     t.date :published_on\n      #     t.date :holidays, array: true, default: []\n      #   end\n\n      ##\n      # :method: datetime\n      # :call-seq: datetime(*names, **options)\n      #\n      # Adds a +datetime+ column for storing precise date and time values.\n      #\n      # On PostgreSQL, you can use the +array: true+ option to store an array of datetimes.\n      #\n      # Example:\n      #\n      #   create_table :posts do |t|\n      #     t.datetime :posted_at\n      #     t.datetime :access_times, array: true\n      #   end\n\n      ##\n      # :method: decimal\n      # :call-seq: decimal(*names, **options)\n      #\n      # Adds a +decimal+ column for storing fixed-point numbers.\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      # Use the +:precision+ and +:scale+ options to control the number format.\n      #\n      # Example:\n      #\n      #   create_table :products do |t|\n      #     t.decimal :price, precision: 10, scale: 2\n      #     t.decimal :tax_rates, array: true\n      #   end\n\n      ##\n      # :method: float\n      # :call-seq: float(*names, **options)\n      #\n      # Adds a +float+ column for storing approximate decimal numbers.\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Example:\n      #\n      #   create_table :reviews do |t|\n      #     t.float :rating\n      #     t.float :samples, array: true\n      #   end\n\n      ##\n      # :method: integer\n      # :call-seq: integer(*names, **options)\n      #\n      # Adds an +integer+ column for storing whole numbers.\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Example:\n      #\n      #   create_table :books do |t|\n      #     t.integer :ratings, array: true, default: []\n      #   end\n\n      ##\n      # :method: json\n      # :call-seq: json(*names, **options)\n      #\n      # Adds a +json+ column for storing structured data in JSON format.\n      #\n      # Use this for unindexed, flexible key-value data. For indexed JSON support, prefer +jsonb+ on PostgreSQL.\n      #\n      # Example:\n      #\n      #   create_table :accounts do |t|\n      #     t.json :settings\n      #   end\n\n      ##\n      # :method: string\n      # :call-seq: string(*names, **options)\n      #\n      # Adds a +string+ column for storing short text values.\n      #\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # You can limit the maximum length using the +:limit+ option.\n      #\n      # Example:\n      #\n      #   create_table :labels do |t|\n      #     t.string :name, limit: 50\n      #     t.string :tags, array: true, default: []",
    "repo_full_name": "rails/rails",
    "discussion_comments": [
      {
        "comment_id": "2166884710",
        "repo_full_name": "rails/rails",
        "pr_number": 55135,
        "pr_file": "activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb",
        "discussion_id": "2166884710",
        "commented_code": "@@ -328,6 +328,259 @@ def primary_key(name, type = :primary_key, **options)\n         column(name, type, **options, primary_key: true)\n       end\n \n+      ##\n+      # :method: column\n+      # :call-seq: column(name, type, **options)\n+      #\n+      # Appends a column or columns of a specified type.\n+      #\n+      #  t.string(:goat)\n+      #  t.string(:goat, :sheep)\n+      #\n+      # See TableDefinition#column\n+\n+      ##\n+      # :method: bigint\n+      # :call-seq: bigint(*names, **options)\n+      #\n+      # Adds a +bigint+ column for storing large integer values.\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      #\n+      # Example:\n+      #\n+      #   create_table :subscriptions do |t|\n+      #     t.bigint :account_id\n+      #     t.bigint :event_ids, array: true, default: []\n+      #   end\n+\n+      ##\n+      # :method: binary\n+      # :call-seq: binary(*names, **options)\n+      #\n+      # Adds a +binary+ column for storing binary data such as files or blobs.\n+      #\n+      # Example:\n+      #\n+      #   create_table :responses do |t|\n+      #     t.binary :payload\n+      #   end\n+\n+      ##\n+      # :method: boolean\n+      # :call-seq: boolean(*names, **options)\n+      #\n+      # Adds a +boolean+ column for storing true/false values.\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      #\n+      # Example:\n+      #\n+      #   create_table :features do |t|\n+      #     t.boolean :active\n+      #     t.boolean :flags, array: true, default: []\n+      #   end\n+\n+      ##\n+      # :method: date\n+      # :call-seq: date(*names, **options)\n+      #\n+      # Adds a +date+ column for storing calendar dates (year, month, day).\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      #\n+      # Example:\n+      #\n+      #   create_table :schedules do |t|\n+      #     t.date :published_on\n+      #     t.date :holidays, array: true, default: []\n+      #   end\n+\n+      ##\n+      # :method: datetime\n+      # :call-seq: datetime(*names, **options)\n+      #\n+      # Adds a +datetime+ column for storing precise date and time values.\n+      #\n+      # On PostgreSQL, you can use the +array: true+ option to store an array of datetimes.\n+      #\n+      # Example:\n+      #\n+      #   create_table :posts do |t|\n+      #     t.datetime :posted_at\n+      #     t.datetime :access_times, array: true\n+      #   end\n+\n+      ##\n+      # :method: decimal\n+      # :call-seq: decimal(*names, **options)\n+      #\n+      # Adds a +decimal+ column for storing fixed-point numbers.\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      # Use the +:precision+ and +:scale+ options to control the number format.\n+      #\n+      # Example:\n+      #\n+      #   create_table :products do |t|\n+      #     t.decimal :price, precision: 10, scale: 2\n+      #     t.decimal :tax_rates, array: true\n+      #   end\n+\n+      ##\n+      # :method: float\n+      # :call-seq: float(*names, **options)\n+      #\n+      # Adds a +float+ column for storing approximate decimal numbers.\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      #\n+      # Example:\n+      #\n+      #   create_table :reviews do |t|\n+      #     t.float :rating\n+      #     t.float :samples, array: true\n+      #   end\n+\n+      ##\n+      # :method: integer\n+      # :call-seq: integer(*names, **options)\n+      #\n+      # Adds an +integer+ column for storing whole numbers.\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      #\n+      # Example:\n+      #\n+      #   create_table :books do |t|\n+      #     t.integer :ratings, array: true, default: []\n+      #   end\n+\n+      ##\n+      # :method: json\n+      # :call-seq: json(*names, **options)\n+      #\n+      # Adds a +json+ column for storing structured data in JSON format.\n+      #\n+      # Use this for unindexed, flexible key-value data. For indexed JSON support, prefer +jsonb+ on PostgreSQL.\n+      #\n+      # Example:\n+      #\n+      #   create_table :accounts do |t|\n+      #     t.json :settings\n+      #   end\n+\n+      ##\n+      # :method: string\n+      # :call-seq: string(*names, **options)\n+      #\n+      # Adds a +string+ column for storing short text values.\n+      #\n+      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n+      # for available options.\n+      #\n+      # You can limit the maximum length using the +:limit+ option.\n+      #\n+      # Example:\n+      #\n+      #   create_table :labels do |t|\n+      #     t.string :name, limit: 50\n+      #     t.string :tags, array: true, default: []",
        "comment_created_at": "2025-06-25T14:32:19+00:00",
        "comment_author": "p8",
        "comment_body": "```suggestion\r\n```",
        "pr_file_module": null
      }
    ]
  }
]