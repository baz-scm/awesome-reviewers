[
  {
    "discussion_id": "2164846050",
    "pr_number": 50454,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/textinput/ReactEditText.kt",
    "created_at": "2025-06-24T20:28:46+00:00",
    "commented_code": "}\n   }\n \n+  public fun maybeUpdateTypeface() {\n+    if (!typefaceDirty) {\n+      return\n+    }\n+\n+    typefaceDirty = false\n+    updateTypefaceAndFlags()\n+    forceUpdateTypefaceAndFlagsOnLayout = true",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2164846050",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50454,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/textinput/ReactEditText.kt",
        "discussion_id": "2164846050",
        "commented_code": "@@ -610,6 +611,16 @@ public open class ReactEditText public constructor(context: Context) : AppCompat\n         }\n   }\n \n+  public fun maybeUpdateTypeface() {\n+    if (!typefaceDirty) {\n+      return\n+    }\n+\n+    typefaceDirty = false\n+    updateTypefaceAndFlags()\n+    forceUpdateTypefaceAndFlagsOnLayout = true",
        "comment_created_at": "2025-06-24T20:28:46+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "If I am reading this right, this means that, for any case where we have had a transaction (props are changed, and `onAfterUpdateTransaction()` called), then if we have changed any flags contributing to typeface, we force recreating the typeface, before, and after layout?\r\n\r\nThis seems like it would impact performance, and may not be the right way to solve the issue happening here.\r\n\r\nCould you help me understand the mechanism, for what changes here, between the invalidations? That way, we could find a more durable solution. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145334304",
    "pr_number": 51929,
    "pr_file": "packages/rn-tester/android/app/src/main/java/com/facebook/react/uiapp/RNTesterActivity.kt",
    "created_at": "2025-06-13T15:24:48+00:00",
    "commented_code": "if (this::initialProps.isInitialized) initialProps else Bundle()\n   }\n \n+  // set background color so it will show below transparent system bars on forced edge-to-edge\n+  private fun maybeUpdateBackgroundColor() {\n+    val isDarkMode =\n+      resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK ==\n+        Configuration.UI_MODE_NIGHT_YES\n+\n+    val color = if (isDarkMode) \"#0b0600\" else \"#f3f8ff\"",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2145334304",
        "repo_full_name": "facebook/react-native",
        "pr_number": 51929,
        "pr_file": "packages/rn-tester/android/app/src/main/java/com/facebook/react/uiapp/RNTesterActivity.kt",
        "discussion_id": "2145334304",
        "commented_code": "@@ -43,13 +44,23 @@ internal class RNTesterActivity : ReactActivity() {\n         if (this::initialProps.isInitialized) initialProps else Bundle()\n   }\n \n+  // set background color so it will show below transparent system bars on forced edge-to-edge\n+  private fun maybeUpdateBackgroundColor() {\n+    val isDarkMode =\n+      resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK ==\n+        Configuration.UI_MODE_NIGHT_YES\n+\n+    val color = if (isDarkMode) \"#0b0600\" else \"#f3f8ff\"",
        "comment_created_at": "2025-06-13T15:24:48+00:00",
        "comment_author": "alanleedev",
        "comment_body": "Can we use int constructor instead of converting from hex string which doesn't require conversion? \r\n```\r\ntrue -> Color.rgb(11, 6, 0),\r\nfalse -> Color.rgb(243, 248, 255),\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2010559990",
    "pr_number": 50209,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/uimanager/style/RadialGradient.kt",
    "created_at": "2025-03-24T16:43:45+00:00",
    "commented_code": "+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.uimanager.style\n+\n+import ColorStop\n+import ColorStopUtils\n+import android.content.Context\n+import android.graphics.RadialGradient as AndroidRadialGradient\n+import android.graphics.Matrix\n+import android.graphics.Shader\n+import com.facebook.react.bridge.ColorPropConverter\n+import com.facebook.react.bridge.ReadableArray\n+import com.facebook.react.bridge.ReadableMap\n+import com.facebook.react.bridge.ReadableType\n+import com.facebook.react.uimanager.FloatUtil\n+import com.facebook.react.uimanager.LengthPercentage\n+import com.facebook.react.uimanager.LengthPercentageType\n+import kotlin.math.max\n+import kotlin.math.min\n+import kotlin.math.pow\n+import kotlin.math.sqrt\n+\n+internal class RadialGradient(\n+  shapeString: String,\n+  private val sizeMap: ReadableMap?,\n+  private val positionMap: ReadableMap?,\n+  private val colorStopsArray: ReadableArray,\n+  private val context: Context\n+) {\n+  private enum class Shape {\n+    CIRCLE,\n+    ELLIPSE;\n+    \n+    companion object {\n+      fun fromString(value: String): Shape {\n+        return when (value.lowercase()) {\n+          \"circle\" -> CIRCLE\n+          \"ellipse\" -> ELLIPSE\n+          else -> ELLIPSE\n+        }\n+      }\n+    }\n+  }\n+\n+  private enum class SizeKeyword {\n+    CLOSEST_SIDE,\n+    FARTHEST_SIDE,\n+    CLOSEST_CORNER,\n+    FARTHEST_CORNER;\n+\n+    companion object {\n+      fun fromString(value: String?): SizeKeyword {\n+        return when (value?.lowercase()) {\n+          \"closest-side\" -> CLOSEST_SIDE\n+          \"farthest-side\" -> FARTHEST_SIDE\n+          \"closest-corner\" -> CLOSEST_CORNER\n+          else -> FARTHEST_CORNER\n+        }\n+      }\n+    }\n+  }\n+\n+  private data class GradientSize(\n+    val sizeType: SizeType,\n+    val value: Any\n+  ) {\n+    enum class SizeType {\n+      KEYWORD,\n+      DIMENSIONS\n+    }\n+\n+    data class Dimensions(\n+      val x: LengthPercentage,\n+      val y: LengthPercentage\n+    )\n+  }\n+\n+  private class Position(\n+    val top: LengthPercentage? = null,\n+    val left: LengthPercentage? = null,\n+    val right: LengthPercentage? = null,\n+    val bottom: LengthPercentage? = null\n+  )\n+\n+  private val shape: Shape = Shape.fromString(shapeString)\n+  private val isCircle: Boolean = shape == Shape.CIRCLE\n+\n+  private val position: Position = run {\n+    val defaultPosition = Position(\n+      top = LengthPercentage(50f, LengthPercentageType.PERCENT),\n+      left = LengthPercentage(50f, LengthPercentageType.PERCENT)\n+    )\n+\n+    if (positionMap == null) {\n+      return@run defaultPosition\n+    }\n+\n+    var top: LengthPercentage? = null\n+    var left: LengthPercentage? = null\n+    var right: LengthPercentage? = null\n+    var bottom: LengthPercentage? = null\n+\n+    if (positionMap.hasKey(\"top\")) {\n+      val rawTop = positionMap.getDynamic(\"top\")\n+      top = LengthPercentage.setFromDynamic(rawTop)\n+    } else if (positionMap.hasKey(\"bottom\")) {\n+      val rawBottom = positionMap.getDynamic(\"bottom\")\n+      bottom = LengthPercentage.setFromDynamic(rawBottom)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    if (positionMap.hasKey(\"left\")) {\n+      val rawLeft = positionMap.getDynamic(\"left\")\n+      left = LengthPercentage.setFromDynamic(rawLeft)\n+    } else if (positionMap.hasKey(\"right\")) {\n+      val rawRight = positionMap.getDynamic(\"right\")\n+      right = LengthPercentage.setFromDynamic(rawRight)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    Position(top, left, right, bottom)\n+  }\n+\n+  private val size: GradientSize = run {\n+    if (sizeMap == null) {\n+      return@run GradientSize(\n+        GradientSize.SizeType.KEYWORD,\n+        SizeKeyword.FARTHEST_CORNER\n+      )\n+    }\n+\n+    if (sizeMap.hasKey(\"keyword\")) {\n+      val keywordString = sizeMap.getString(\"keyword\")\n+      val keyword = SizeKeyword.fromString(keywordString)\n+      return@run GradientSize(\n+        GradientSize.SizeType.KEYWORD,\n+        keyword\n+      )\n+    }\n+\n+    if (sizeMap.hasKey(\"x\") && sizeMap.hasKey(\"y\")) {\n+      val xDynamic = sizeMap.getDynamic(\"x\")\n+      val yDynamic = sizeMap.getDynamic(\"y\")\n+      val x = LengthPercentage.setFromDynamic(xDynamic)\n+      val y = LengthPercentage.setFromDynamic(yDynamic)\n+\n+      if (x != null && y != null) {\n+        return@run GradientSize(\n+          GradientSize.SizeType.DIMENSIONS,\n+          GradientSize.Dimensions(x, y)\n+        )\n+      }\n+    }\n+\n+    GradientSize(\n+      GradientSize.SizeType.KEYWORD,\n+      SizeKeyword.FARTHEST_CORNER\n+    )\n+  }\n+\n+  private val colorStops: ArrayList<ColorStop> = run {\n+    val stops = ArrayList<ColorStop>(colorStopsArray.size())\n+    for (i in 0 until colorStopsArray.size()) {\n+      val colorStop = colorStopsArray.getMap(i) ?: continue\n+      val color: Int? =\n+        when {\n+          !colorStop.hasKey(\"color\") || colorStop.isNull(\"color\") -> {\n+            null\n+          }\n+\n+          colorStop.getType(\"color\") == ReadableType.Map -> {\n+            ColorPropConverter.getColor(colorStop.getMap(\"color\"), context)\n+          }\n+\n+          else -> colorStop.getInt(\"color\")\n+        }\n+\n+      val position = LengthPercentage.setFromDynamic(colorStop.getDynamic(\"position\"))\n+      stops.add(ColorStop(color, position))\n+    }\n+    stops\n+  }\n+\n+  fun getShader(width: Float, height: Float): Shader {\n+    var centerX: Float = width / 2f\n+    var centerY: Float = height / 2f\n+    \n+    if (position.top != null) {\n+      centerY = position.top.resolveToPixel(height)",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2010559990",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50209,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/uimanager/style/RadialGradient.kt",
        "discussion_id": "2010559990",
        "commented_code": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.uimanager.style\n+\n+import ColorStop\n+import ColorStopUtils\n+import android.content.Context\n+import android.graphics.RadialGradient as AndroidRadialGradient\n+import android.graphics.Matrix\n+import android.graphics.Shader\n+import com.facebook.react.bridge.ColorPropConverter\n+import com.facebook.react.bridge.ReadableArray\n+import com.facebook.react.bridge.ReadableMap\n+import com.facebook.react.bridge.ReadableType\n+import com.facebook.react.uimanager.FloatUtil\n+import com.facebook.react.uimanager.LengthPercentage\n+import com.facebook.react.uimanager.LengthPercentageType\n+import kotlin.math.max\n+import kotlin.math.min\n+import kotlin.math.pow\n+import kotlin.math.sqrt\n+\n+internal class RadialGradient(\n+  shapeString: String,\n+  private val sizeMap: ReadableMap?,\n+  private val positionMap: ReadableMap?,\n+  private val colorStopsArray: ReadableArray,\n+  private val context: Context\n+) {\n+  private enum class Shape {\n+    CIRCLE,\n+    ELLIPSE;\n+    \n+    companion object {\n+      fun fromString(value: String): Shape {\n+        return when (value.lowercase()) {\n+          \"circle\" -> CIRCLE\n+          \"ellipse\" -> ELLIPSE\n+          else -> ELLIPSE\n+        }\n+      }\n+    }\n+  }\n+\n+  private enum class SizeKeyword {\n+    CLOSEST_SIDE,\n+    FARTHEST_SIDE,\n+    CLOSEST_CORNER,\n+    FARTHEST_CORNER;\n+\n+    companion object {\n+      fun fromString(value: String?): SizeKeyword {\n+        return when (value?.lowercase()) {\n+          \"closest-side\" -> CLOSEST_SIDE\n+          \"farthest-side\" -> FARTHEST_SIDE\n+          \"closest-corner\" -> CLOSEST_CORNER\n+          else -> FARTHEST_CORNER\n+        }\n+      }\n+    }\n+  }\n+\n+  private data class GradientSize(\n+    val sizeType: SizeType,\n+    val value: Any\n+  ) {\n+    enum class SizeType {\n+      KEYWORD,\n+      DIMENSIONS\n+    }\n+\n+    data class Dimensions(\n+      val x: LengthPercentage,\n+      val y: LengthPercentage\n+    )\n+  }\n+\n+  private class Position(\n+    val top: LengthPercentage? = null,\n+    val left: LengthPercentage? = null,\n+    val right: LengthPercentage? = null,\n+    val bottom: LengthPercentage? = null\n+  )\n+\n+  private val shape: Shape = Shape.fromString(shapeString)\n+  private val isCircle: Boolean = shape == Shape.CIRCLE\n+\n+  private val position: Position = run {\n+    val defaultPosition = Position(\n+      top = LengthPercentage(50f, LengthPercentageType.PERCENT),\n+      left = LengthPercentage(50f, LengthPercentageType.PERCENT)\n+    )\n+\n+    if (positionMap == null) {\n+      return@run defaultPosition\n+    }\n+\n+    var top: LengthPercentage? = null\n+    var left: LengthPercentage? = null\n+    var right: LengthPercentage? = null\n+    var bottom: LengthPercentage? = null\n+\n+    if (positionMap.hasKey(\"top\")) {\n+      val rawTop = positionMap.getDynamic(\"top\")\n+      top = LengthPercentage.setFromDynamic(rawTop)\n+    } else if (positionMap.hasKey(\"bottom\")) {\n+      val rawBottom = positionMap.getDynamic(\"bottom\")\n+      bottom = LengthPercentage.setFromDynamic(rawBottom)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    if (positionMap.hasKey(\"left\")) {\n+      val rawLeft = positionMap.getDynamic(\"left\")\n+      left = LengthPercentage.setFromDynamic(rawLeft)\n+    } else if (positionMap.hasKey(\"right\")) {\n+      val rawRight = positionMap.getDynamic(\"right\")\n+      right = LengthPercentage.setFromDynamic(rawRight)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    Position(top, left, right, bottom)\n+  }\n+\n+  private val size: GradientSize = run {\n+    if (sizeMap == null) {\n+      return@run GradientSize(\n+        GradientSize.SizeType.KEYWORD,\n+        SizeKeyword.FARTHEST_CORNER\n+      )\n+    }\n+\n+    if (sizeMap.hasKey(\"keyword\")) {\n+      val keywordString = sizeMap.getString(\"keyword\")\n+      val keyword = SizeKeyword.fromString(keywordString)\n+      return@run GradientSize(\n+        GradientSize.SizeType.KEYWORD,\n+        keyword\n+      )\n+    }\n+\n+    if (sizeMap.hasKey(\"x\") && sizeMap.hasKey(\"y\")) {\n+      val xDynamic = sizeMap.getDynamic(\"x\")\n+      val yDynamic = sizeMap.getDynamic(\"y\")\n+      val x = LengthPercentage.setFromDynamic(xDynamic)\n+      val y = LengthPercentage.setFromDynamic(yDynamic)\n+\n+      if (x != null && y != null) {\n+        return@run GradientSize(\n+          GradientSize.SizeType.DIMENSIONS,\n+          GradientSize.Dimensions(x, y)\n+        )\n+      }\n+    }\n+\n+    GradientSize(\n+      GradientSize.SizeType.KEYWORD,\n+      SizeKeyword.FARTHEST_CORNER\n+    )\n+  }\n+\n+  private val colorStops: ArrayList<ColorStop> = run {\n+    val stops = ArrayList<ColorStop>(colorStopsArray.size())\n+    for (i in 0 until colorStopsArray.size()) {\n+      val colorStop = colorStopsArray.getMap(i) ?: continue\n+      val color: Int? =\n+        when {\n+          !colorStop.hasKey(\"color\") || colorStop.isNull(\"color\") -> {\n+            null\n+          }\n+\n+          colorStop.getType(\"color\") == ReadableType.Map -> {\n+            ColorPropConverter.getColor(colorStop.getMap(\"color\"), context)\n+          }\n+\n+          else -> colorStop.getInt(\"color\")\n+        }\n+\n+      val position = LengthPercentage.setFromDynamic(colorStop.getDynamic(\"position\"))\n+      stops.add(ColorStop(color, position))\n+    }\n+    stops\n+  }\n+\n+  fun getShader(width: Float, height: Float): Shader {\n+    var centerX: Float = width / 2f\n+    var centerY: Float = height / 2f\n+    \n+    if (position.top != null) {\n+      centerY = position.top.resolveToPixel(height)",
        "comment_created_at": "2025-03-24T16:43:45+00:00",
        "comment_author": "jorge-cab",
        "comment_body": "For this and all other usages of resolveToPixel\r\n\r\n```suggestion\r\n      centerY = position.top.resolve(height).dpToPx()\r\n```",
        "pr_file_module": null
      }
    ]
  }
]