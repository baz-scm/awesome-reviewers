[
  {
    "discussion_id": "1621385196",
    "pr_number": 44667,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/text/internal/span/CustomStyleSpan.kt",
    "created_at": "2024-05-30T20:19:41+00:00",
    "commented_code": "}\n \n   public companion object {\n+    private val TAG = CustomStyleSpan::class.simpleName\n     private fun apply(\n         paint: Paint,\n         style: Int,\n         weight: Int,\n         fontFeatureSettingsParam: String?,\n         family: String?,\n+        fontVariationSettingsParam: String?,\n         assetManager: AssetManager\n     ) {\n       val typeface =\n           ReactTypefaceUtils.applyStyles(paint.typeface, style, weight, family, assetManager)\n       paint.apply {\n         fontFeatureSettings = fontFeatureSettingsParam\n         setTypeface(typeface)\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+          try {\n+            fontVariationSettings = fontVariationSettingsParam\n+          } catch (e: Exception) {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1621385196",
        "repo_full_name": "facebook/react-native",
        "pr_number": 44667,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/text/internal/span/CustomStyleSpan.kt",
        "discussion_id": "1621385196",
        "commented_code": "@@ -59,19 +61,28 @@ public class CustomStyleSpan(\n         }\n \n   public companion object {\n+    private val TAG = CustomStyleSpan::class.simpleName\n     private fun apply(\n         paint: Paint,\n         style: Int,\n         weight: Int,\n         fontFeatureSettingsParam: String?,\n         family: String?,\n+        fontVariationSettingsParam: String?,\n         assetManager: AssetManager\n     ) {\n       val typeface =\n           ReactTypefaceUtils.applyStyles(paint.typeface, style, weight, family, assetManager)\n       paint.apply {\n         fontFeatureSettings = fontFeatureSettingsParam\n         setTypeface(typeface)\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+          try {\n+            fontVariationSettings = fontVariationSettingsParam\n+          } catch (e: Exception) {",
        "comment_created_at": "2024-05-30T20:19:41+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "```suggestion\r\n          } catch (e: IllegalArgumentExeption) {\r\n```\r\n\r\nWe only want to be permissive in the case of invalid input, not swallow unexpected other errors. The contract is that this produces [IllegalArgumentException](https://developer.android.com/reference/android/graphics/Paint#setFontVariationSettings(java.lang.String))",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2014641150",
    "pr_number": 50269,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/uimanager/style/RadialGradient.kt",
    "created_at": "2025-03-26T17:12:41+00:00",
    "commented_code": "+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.uimanager.style\n+\n+import ColorStop\n+import ColorStopUtils\n+import android.content.Context\n+import android.graphics.RadialGradient as AndroidRadialGradient\n+import android.graphics.Matrix\n+import android.graphics.Shader\n+import com.facebook.react.bridge.ColorPropConverter\n+import com.facebook.react.bridge.ReadableArray\n+import com.facebook.react.bridge.ReadableMap\n+import com.facebook.react.bridge.ReadableType\n+import com.facebook.react.uimanager.FloatUtil\n+import com.facebook.react.uimanager.LengthPercentage\n+import com.facebook.react.uimanager.LengthPercentageType\n+import com.facebook.react.uimanager.PixelUtil.dpToPx\n+import kotlin.math.max\n+import kotlin.math.min\n+import kotlin.math.pow\n+import kotlin.math.sqrt\n+\n+internal class RadialGradient(\n+  gradientMap: ReadableMap,\n+  private val context: Context\n+) : Gradient {\n+  private enum class Shape {\n+    CIRCLE,\n+    ELLIPSE;\n+    \n+    companion object {\n+      fun fromString(value: String): Shape {\n+        return when (value.lowercase()) {\n+          \"circle\" -> CIRCLE\n+          \"ellipse\" -> ELLIPSE\n+          else -> ELLIPSE\n+        }\n+      }\n+    }\n+  }\n+\n+  private enum class SizeKeyword {\n+    CLOSEST_SIDE,\n+    FARTHEST_SIDE,\n+    CLOSEST_CORNER,\n+    FARTHEST_CORNER;\n+\n+    companion object {\n+      fun fromString(value: String?): SizeKeyword {\n+        return when (value?.lowercase()) {\n+          \"closest-side\" -> CLOSEST_SIDE\n+          \"farthest-side\" -> FARTHEST_SIDE\n+          \"closest-corner\" -> CLOSEST_CORNER\n+          else -> FARTHEST_CORNER\n+        }\n+      }\n+    }\n+  }\n+\n+  private data class GradientSize(\n+    val sizeType: SizeType,\n+    val value: Any\n+  ) {\n+    enum class SizeType {\n+      KEYWORD,\n+      DIMENSIONS\n+    }\n+\n+    data class Dimensions(\n+      val x: LengthPercentage,\n+      val y: LengthPercentage\n+    )\n+  }\n+\n+  private class Position(\n+    val top: LengthPercentage? = null,\n+    val left: LengthPercentage? = null,\n+    val right: LengthPercentage? = null,\n+    val bottom: LengthPercentage? = null\n+  )\n+\n+  private val shape: Shape = run {\n+    val shapeString = gradientMap.getString(\"shape\") ?: throw IllegalArgumentException(\"Radial gradient must have shape\")\n+    Shape.fromString(shapeString)\n+  }\n+  private val isCircle: Boolean = shape == Shape.CIRCLE\n+\n+  private val position: Position = run {\n+    val positionMap = gradientMap.getMap(\"position\")\n+    val defaultPosition = Position(\n+      top = LengthPercentage(50f, LengthPercentageType.PERCENT),\n+      left = LengthPercentage(50f, LengthPercentageType.PERCENT)\n+    )\n+\n+    if (positionMap == null) {\n+      return@run defaultPosition\n+    }\n+\n+    var top: LengthPercentage? = null\n+    var left: LengthPercentage? = null\n+    var right: LengthPercentage? = null\n+    var bottom: LengthPercentage? = null\n+\n+    if (positionMap.hasKey(\"top\")) {\n+      val rawTop = positionMap.getDynamic(\"top\")\n+      top = LengthPercentage.setFromDynamic(rawTop)\n+    } else if (positionMap.hasKey(\"bottom\")) {\n+      val rawBottom = positionMap.getDynamic(\"bottom\")\n+      bottom = LengthPercentage.setFromDynamic(rawBottom)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    if (positionMap.hasKey(\"left\")) {\n+      val rawLeft = positionMap.getDynamic(\"left\")\n+      left = LengthPercentage.setFromDynamic(rawLeft)\n+    } else if (positionMap.hasKey(\"right\")) {\n+      val rawRight = positionMap.getDynamic(\"right\")\n+      right = LengthPercentage.setFromDynamic(rawRight)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    Position(top, left, right, bottom)\n+  }\n+\n+  private val size: GradientSize = run {\n+    if (gradientMap.hasKey(\"size\")) {\n+      if (gradientMap.getType(\"size\") == ReadableType.String) {\n+        val sizeKeyword = gradientMap.getString(\"size\");\n+        return@run GradientSize(\n+          GradientSize.SizeType.KEYWORD,\n+          SizeKeyword.fromString(sizeKeyword)\n+        )\n+      } else if (gradientMap.getType(\"size\") ==  ReadableType.Map) {\n+        val sizeMap = gradientMap.getMap(\"size\")\n+        if (sizeMap != null) {\n+          if (sizeMap.hasKey(\"x\") && sizeMap.hasKey(\"y\")) {\n+            val x = LengthPercentage.setFromDynamic(sizeMap.getDynamic(\"x\"))\n+            val y = LengthPercentage.setFromDynamic(sizeMap.getDynamic(\"y\"))\n+            if (x != null && y != null) {\n+              return@run GradientSize(\n+                GradientSize.SizeType.DIMENSIONS,\n+                GradientSize.Dimensions(x, y)\n+              )\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    GradientSize(\n+      GradientSize.SizeType.KEYWORD,\n+      SizeKeyword.FARTHEST_CORNER\n+    )\n+  }\n+\n+  private val colorStops: ArrayList<ColorStop> = run {\n+    val colorStopsArray =\n+      gradientMap.getArray(\"colorStops\")\n+        ?: throw IllegalArgumentException(\"Invalid colorStops array\")\n+    val stops = ArrayList<ColorStop>(colorStopsArray.size())\n+    for (i in 0 until colorStopsArray.size()) {\n+      val colorStop = colorStopsArray.getMap(i) ?: continue\n+      val color: Int? =\n+        when {\n+          !colorStop.hasKey(\"color\") || colorStop.isNull(\"color\") -> {\n+            null\n+          }\n+\n+          colorStop.getType(\"color\") == ReadableType.Map -> {\n+            ColorPropConverter.getColor(colorStop.getMap(\"color\"), context)\n+          }\n+\n+          else -> colorStop.getInt(\"color\")\n+        }\n+\n+      val position = LengthPercentage.setFromDynamic(colorStop.getDynamic(\"position\"))\n+      stops.add(ColorStop(color, position))\n+    }\n+    stops\n+  }\n+\n+  override fun getShader(width: Float, height: Float): Shader {\n+    var centerX: Float = width / 2f\n+    var centerY: Float = height / 2f\n+    \n+    if (position.top != null) {\n+      centerY =\n+        if (position.top.type == LengthPercentageType.PERCENT)\n+          position.top.resolve(height)\n+        else\n+          position.top.resolve(height).dpToPx()\n+    } else if (position.bottom != null) {\n+      centerY =\n+        if (position.bottom.type == LengthPercentageType.PERCENT)\n+          height - position.bottom.resolve(height)\n+        else\n+          height - position.bottom.resolve(height).dpToPx()\n+    }\n+\n+    if (position.left != null) {\n+      centerX =\n+        if (position.left.type == LengthPercentageType.PERCENT)\n+          position.left.resolve(width)\n+        else\n+          position.left.resolve(width).dpToPx()\n+    } else if (position.right != null) {\n+      centerX =\n+        if (position.right.type == LengthPercentageType.PERCENT)\n+          width - position.right.resolve(width)\n+        else\n+          width - position.right.resolve(width).dpToPx()\n+    }\n+\n+    val (radiusX, radiusY) = calculateRadius(centerX, centerY, width, height)\n+\n+    val finalStops = ColorStopUtils.getFixedColorStops(colorStops, max(radiusX, radiusY))\n+    val colors = IntArray(finalStops.size)\n+    val positions = FloatArray(finalStops.size)\n+\n+    finalStops.forEachIndexed { i, colorStop ->\n+      val color = colorStop.color\n+      if (color != null && colorStop.position != null) {\n+        colors[i] = color\n+        positions[i] = colorStop.position\n+      }\n+    }\n+\n+    val shader = AndroidRadialGradient(\n+      centerX,\n+      centerY,\n+      radiusX,",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2014641150",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50269,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/uimanager/style/RadialGradient.kt",
        "discussion_id": "2014641150",
        "commented_code": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.uimanager.style\n+\n+import ColorStop\n+import ColorStopUtils\n+import android.content.Context\n+import android.graphics.RadialGradient as AndroidRadialGradient\n+import android.graphics.Matrix\n+import android.graphics.Shader\n+import com.facebook.react.bridge.ColorPropConverter\n+import com.facebook.react.bridge.ReadableArray\n+import com.facebook.react.bridge.ReadableMap\n+import com.facebook.react.bridge.ReadableType\n+import com.facebook.react.uimanager.FloatUtil\n+import com.facebook.react.uimanager.LengthPercentage\n+import com.facebook.react.uimanager.LengthPercentageType\n+import com.facebook.react.uimanager.PixelUtil.dpToPx\n+import kotlin.math.max\n+import kotlin.math.min\n+import kotlin.math.pow\n+import kotlin.math.sqrt\n+\n+internal class RadialGradient(\n+  gradientMap: ReadableMap,\n+  private val context: Context\n+) : Gradient {\n+  private enum class Shape {\n+    CIRCLE,\n+    ELLIPSE;\n+    \n+    companion object {\n+      fun fromString(value: String): Shape {\n+        return when (value.lowercase()) {\n+          \"circle\" -> CIRCLE\n+          \"ellipse\" -> ELLIPSE\n+          else -> ELLIPSE\n+        }\n+      }\n+    }\n+  }\n+\n+  private enum class SizeKeyword {\n+    CLOSEST_SIDE,\n+    FARTHEST_SIDE,\n+    CLOSEST_CORNER,\n+    FARTHEST_CORNER;\n+\n+    companion object {\n+      fun fromString(value: String?): SizeKeyword {\n+        return when (value?.lowercase()) {\n+          \"closest-side\" -> CLOSEST_SIDE\n+          \"farthest-side\" -> FARTHEST_SIDE\n+          \"closest-corner\" -> CLOSEST_CORNER\n+          else -> FARTHEST_CORNER\n+        }\n+      }\n+    }\n+  }\n+\n+  private data class GradientSize(\n+    val sizeType: SizeType,\n+    val value: Any\n+  ) {\n+    enum class SizeType {\n+      KEYWORD,\n+      DIMENSIONS\n+    }\n+\n+    data class Dimensions(\n+      val x: LengthPercentage,\n+      val y: LengthPercentage\n+    )\n+  }\n+\n+  private class Position(\n+    val top: LengthPercentage? = null,\n+    val left: LengthPercentage? = null,\n+    val right: LengthPercentage? = null,\n+    val bottom: LengthPercentage? = null\n+  )\n+\n+  private val shape: Shape = run {\n+    val shapeString = gradientMap.getString(\"shape\") ?: throw IllegalArgumentException(\"Radial gradient must have shape\")\n+    Shape.fromString(shapeString)\n+  }\n+  private val isCircle: Boolean = shape == Shape.CIRCLE\n+\n+  private val position: Position = run {\n+    val positionMap = gradientMap.getMap(\"position\")\n+    val defaultPosition = Position(\n+      top = LengthPercentage(50f, LengthPercentageType.PERCENT),\n+      left = LengthPercentage(50f, LengthPercentageType.PERCENT)\n+    )\n+\n+    if (positionMap == null) {\n+      return@run defaultPosition\n+    }\n+\n+    var top: LengthPercentage? = null\n+    var left: LengthPercentage? = null\n+    var right: LengthPercentage? = null\n+    var bottom: LengthPercentage? = null\n+\n+    if (positionMap.hasKey(\"top\")) {\n+      val rawTop = positionMap.getDynamic(\"top\")\n+      top = LengthPercentage.setFromDynamic(rawTop)\n+    } else if (positionMap.hasKey(\"bottom\")) {\n+      val rawBottom = positionMap.getDynamic(\"bottom\")\n+      bottom = LengthPercentage.setFromDynamic(rawBottom)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    if (positionMap.hasKey(\"left\")) {\n+      val rawLeft = positionMap.getDynamic(\"left\")\n+      left = LengthPercentage.setFromDynamic(rawLeft)\n+    } else if (positionMap.hasKey(\"right\")) {\n+      val rawRight = positionMap.getDynamic(\"right\")\n+      right = LengthPercentage.setFromDynamic(rawRight)\n+    } else {\n+      return@run defaultPosition\n+    }\n+\n+    Position(top, left, right, bottom)\n+  }\n+\n+  private val size: GradientSize = run {\n+    if (gradientMap.hasKey(\"size\")) {\n+      if (gradientMap.getType(\"size\") == ReadableType.String) {\n+        val sizeKeyword = gradientMap.getString(\"size\");\n+        return@run GradientSize(\n+          GradientSize.SizeType.KEYWORD,\n+          SizeKeyword.fromString(sizeKeyword)\n+        )\n+      } else if (gradientMap.getType(\"size\") ==  ReadableType.Map) {\n+        val sizeMap = gradientMap.getMap(\"size\")\n+        if (sizeMap != null) {\n+          if (sizeMap.hasKey(\"x\") && sizeMap.hasKey(\"y\")) {\n+            val x = LengthPercentage.setFromDynamic(sizeMap.getDynamic(\"x\"))\n+            val y = LengthPercentage.setFromDynamic(sizeMap.getDynamic(\"y\"))\n+            if (x != null && y != null) {\n+              return@run GradientSize(\n+                GradientSize.SizeType.DIMENSIONS,\n+                GradientSize.Dimensions(x, y)\n+              )\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    GradientSize(\n+      GradientSize.SizeType.KEYWORD,\n+      SizeKeyword.FARTHEST_CORNER\n+    )\n+  }\n+\n+  private val colorStops: ArrayList<ColorStop> = run {\n+    val colorStopsArray =\n+      gradientMap.getArray(\"colorStops\")\n+        ?: throw IllegalArgumentException(\"Invalid colorStops array\")\n+    val stops = ArrayList<ColorStop>(colorStopsArray.size())\n+    for (i in 0 until colorStopsArray.size()) {\n+      val colorStop = colorStopsArray.getMap(i) ?: continue\n+      val color: Int? =\n+        when {\n+          !colorStop.hasKey(\"color\") || colorStop.isNull(\"color\") -> {\n+            null\n+          }\n+\n+          colorStop.getType(\"color\") == ReadableType.Map -> {\n+            ColorPropConverter.getColor(colorStop.getMap(\"color\"), context)\n+          }\n+\n+          else -> colorStop.getInt(\"color\")\n+        }\n+\n+      val position = LengthPercentage.setFromDynamic(colorStop.getDynamic(\"position\"))\n+      stops.add(ColorStop(color, position))\n+    }\n+    stops\n+  }\n+\n+  override fun getShader(width: Float, height: Float): Shader {\n+    var centerX: Float = width / 2f\n+    var centerY: Float = height / 2f\n+    \n+    if (position.top != null) {\n+      centerY =\n+        if (position.top.type == LengthPercentageType.PERCENT)\n+          position.top.resolve(height)\n+        else\n+          position.top.resolve(height).dpToPx()\n+    } else if (position.bottom != null) {\n+      centerY =\n+        if (position.bottom.type == LengthPercentageType.PERCENT)\n+          height - position.bottom.resolve(height)\n+        else\n+          height - position.bottom.resolve(height).dpToPx()\n+    }\n+\n+    if (position.left != null) {\n+      centerX =\n+        if (position.left.type == LengthPercentageType.PERCENT)\n+          position.left.resolve(width)\n+        else\n+          position.left.resolve(width).dpToPx()\n+    } else if (position.right != null) {\n+      centerX =\n+        if (position.right.type == LengthPercentageType.PERCENT)\n+          width - position.right.resolve(width)\n+        else\n+          width - position.right.resolve(width).dpToPx()\n+    }\n+\n+    val (radiusX, radiusY) = calculateRadius(centerX, centerY, width, height)\n+\n+    val finalStops = ColorStopUtils.getFixedColorStops(colorStops, max(radiusX, radiusY))\n+    val colors = IntArray(finalStops.size)\n+    val positions = FloatArray(finalStops.size)\n+\n+    finalStops.forEachIndexed { i, colorStop ->\n+      val color = colorStop.color\n+      if (color != null && colorStop.position != null) {\n+        colors[i] = color\n+        positions[i] = colorStop.position\n+      }\n+    }\n+\n+    val shader = AndroidRadialGradient(\n+      centerX,\n+      centerY,\n+      radiusX,",
        "comment_created_at": "2025-03-26T17:12:41+00:00",
        "comment_author": "jorge-cab",
        "comment_body": "I think this will crash when passing a radius of 0? \r\n\r\nSomething like `radial-gradient(0px 0px at center, red, blue)`\r\n\r\nNegative radius seems fine though it should fail like on web, I would add test for both cases",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2110237507",
    "pr_number": 51631,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/internal/interop/InteropUiBlockListener.kt",
    "created_at": "2025-05-27T20:59:27+00:00",
    "commented_code": "}\n \n   override fun willMountItems(uiManager: UIManager) {\n-    if (beforeUIBlocks.isEmpty()) {\n-      return\n-    }\n-    beforeUIBlocks.forEach {\n+    // avoid ConcurrentModificationException by iterating over a copy\n+    try {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2110237507",
        "repo_full_name": "facebook/react-native",
        "pr_number": 51631,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/fabric/internal/interop/InteropUiBlockListener.kt",
        "discussion_id": "2110237507",
        "commented_code": "@@ -39,27 +39,29 @@ internal class InteropUIBlockListener : UIManagerListener {\n   }\n \n   override fun willMountItems(uiManager: UIManager) {\n-    if (beforeUIBlocks.isEmpty()) {\n-      return\n-    }\n-    beforeUIBlocks.forEach {\n+    // avoid ConcurrentModificationException by iterating over a copy\n+    try {",
        "comment_created_at": "2025-05-27T20:59:27+00:00",
        "comment_author": "javache",
        "comment_body": "Remove the try, since there's no catch/finally",
        "pr_file_module": null
      }
    ]
  }
]