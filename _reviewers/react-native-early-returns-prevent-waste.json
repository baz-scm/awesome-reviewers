[
  {
    "discussion_id": "1943786308",
    "pr_number": 49217,
    "pr_file": "packages/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js",
    "created_at": "2025-02-05T22:55:02+00:00",
    "commented_code": "}\n \n   __addChild(child: AnimatedNode): void {\n+    // Prevent adding duplicate animated nodes.\n+    if (this._children.includes(child)) {\n+      return;\n+    }",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1943786308",
        "repo_full_name": "facebook/react-native",
        "pr_number": 49217,
        "pr_file": "packages/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js",
        "discussion_id": "1943786308",
        "commented_code": "@@ -39,6 +39,10 @@ export default class AnimatedWithChildren extends AnimatedNode {\n   }\n \n   __addChild(child: AnimatedNode): void {\n+    // Prevent adding duplicate animated nodes.\n+    if (this._children.includes(child)) {\n+      return;\n+    }",
        "comment_created_at": "2025-02-05T22:55:02+00:00",
        "comment_author": "c-miles",
        "comment_body": "This check prevents duplicate animated nodes from being added, which fixes the memory leak we observed.\r\n\t\r\nThe fact that `_addChild` is being called repeatedly with the same node may suggest an opportunity for further architectural review, though this fix addresses the immediate issue.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1437007374",
    "pr_number": 41967,
    "pr_file": "packages/metro-config/index.js",
    "created_at": "2023-12-27T12:21:13+00:00",
    "commented_code": "].join('|'),\n );\n \n+/**\n+ * Resolves the root of an NPM or Yarn workspace, by traversing the file tree upwards from a `candidatePath` in the search for\n+ * - a directory with a package.json\n+ * - which has a `workspaces` array of strings\n+ * - which (possibly via a glob) includes the project root\n+ * @param {string} projectRoot Project root to find a workspace root for\n+ * @param {string | undefined} candidatePath Current path to search from\n+ * @returns Path of a workspace root or `undefined`\n+ */\n+function getWorkspaceRoot(projectRoot /*: string */, candidatePath /*: string */ = projectRoot) /*: string | void */ {\n+  const packageJsonPath = path.resolve(candidatePath, 'package.json');\n+  if (fs.existsSync(packageJsonPath)) {\n+    try {\n+      const { workspaces } = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n+      if (Array.isArray(workspaces)) {\n+        // If one of the workspaces match the project root, this is the workspace root\n+        // Note: While NPM workspaces doesn't currently support globs, Yarn does.\n+        const matches = fastGlob.sync(workspaces, {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1437007374",
        "repo_full_name": "facebook/react-native",
        "pr_number": 41967,
        "pr_file": "packages/metro-config/index.js",
        "discussion_id": "1437007374",
        "commented_code": "@@ -36,6 +39,53 @@ const INTERNAL_CALLSITES_REGEX = new RegExp(\n   ].join('|'),\n );\n \n+/**\n+ * Resolves the root of an NPM or Yarn workspace, by traversing the file tree upwards from a `candidatePath` in the search for\n+ * - a directory with a package.json\n+ * - which has a `workspaces` array of strings\n+ * - which (possibly via a glob) includes the project root\n+ * @param {string} projectRoot Project root to find a workspace root for\n+ * @param {string | undefined} candidatePath Current path to search from\n+ * @returns Path of a workspace root or `undefined`\n+ */\n+function getWorkspaceRoot(projectRoot /*: string */, candidatePath /*: string */ = projectRoot) /*: string | void */ {\n+  const packageJsonPath = path.resolve(candidatePath, 'package.json');\n+  if (fs.existsSync(packageJsonPath)) {\n+    try {\n+      const { workspaces } = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n+      if (Array.isArray(workspaces)) {\n+        // If one of the workspaces match the project root, this is the workspace root\n+        // Note: While NPM workspaces doesn't currently support globs, Yarn does.\n+        const matches = fastGlob.sync(workspaces, {",
        "comment_created_at": "2023-12-27T12:21:13+00:00",
        "comment_author": "robhogan",
        "comment_body": "Can we avoid globbing the file system here? We should only need to check that `projectRoot` satisfies one of the globs, which we can do without IO - we don't need to enumerate the other matches on disk.",
        "pr_file_module": null
      },
      {
        "comment_id": "1437222678",
        "repo_full_name": "facebook/react-native",
        "pr_number": 41967,
        "pr_file": "packages/metro-config/index.js",
        "discussion_id": "1437007374",
        "commented_code": "@@ -36,6 +39,53 @@ const INTERNAL_CALLSITES_REGEX = new RegExp(\n   ].join('|'),\n );\n \n+/**\n+ * Resolves the root of an NPM or Yarn workspace, by traversing the file tree upwards from a `candidatePath` in the search for\n+ * - a directory with a package.json\n+ * - which has a `workspaces` array of strings\n+ * - which (possibly via a glob) includes the project root\n+ * @param {string} projectRoot Project root to find a workspace root for\n+ * @param {string | undefined} candidatePath Current path to search from\n+ * @returns Path of a workspace root or `undefined`\n+ */\n+function getWorkspaceRoot(projectRoot /*: string */, candidatePath /*: string */ = projectRoot) /*: string | void */ {\n+  const packageJsonPath = path.resolve(candidatePath, 'package.json');\n+  if (fs.existsSync(packageJsonPath)) {\n+    try {\n+      const { workspaces } = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n+      if (Array.isArray(workspaces)) {\n+        // If one of the workspaces match the project root, this is the workspace root\n+        // Note: While NPM workspaces doesn't currently support globs, Yarn does.\n+        const matches = fastGlob.sync(workspaces, {",
        "comment_created_at": "2023-12-27T19:42:21+00:00",
        "comment_author": "kraenhansen",
        "comment_body": "I agree, this could be refactored to be less IO intensive. I'll update this to use `micromatch` (which is the underlying dependency of fast-glob)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1556096602",
    "pr_number": 41218,
    "pr_file": "packages/rn-tester-e2e/tests/helpers/utils.js",
    "created_at": "2024-04-08T16:11:29+00:00",
    "commented_code": "* @format\n  */\n \n-import {driver} from '../../jest.setup';\n-\n type PlatformsReference = {\n   ios: string,\n   android: string,\n };\n \n class Utils {\n   async checkElementExistence(locator: string): Promise<boolean> {\n-    await driver.$(locator).waitForDisplayed();\n-    return driver.$(locator).isDisplayed();\n+    await $(locator).waitForDisplayed();\n+    return $(locator).isDisplayed();",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1556096602",
        "repo_full_name": "facebook/react-native",
        "pr_number": 41218,
        "pr_file": "packages/rn-tester-e2e/tests/helpers/utils.js",
        "discussion_id": "1556096602",
        "commented_code": "@@ -8,40 +8,42 @@\n  * @format\n  */\n \n-import {driver} from '../../jest.setup';\n-\n type PlatformsReference = {\n   ios: string,\n   android: string,\n };\n \n class Utils {\n   async checkElementExistence(locator: string): Promise<boolean> {\n-    await driver.$(locator).waitForDisplayed();\n-    return driver.$(locator).isDisplayed();\n+    await $(locator).waitForDisplayed();\n+    return $(locator).isDisplayed();",
        "comment_created_at": "2024-04-08T16:11:29+00:00",
        "comment_author": "samuelfreiberg",
        "comment_body": "You can just return `await $(locator).waitForDisplayed();`. Such as `return await $(locator).waitForDisplayed();`.\r\n\r\nwaitForDisplayed throws an error if it fails, or returns true if it succeeds. Adding `return $(locator).isDisplayed();` is unnecessary and will decrease perf by adding another API call.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1933072050",
    "pr_number": 48993,
    "pr_file": "packages/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js",
    "created_at": "2025-01-29T01:11:01+00:00",
    "commented_code": "'use strict';\n \n-import type {PlatformConfig} from '../AnimatedPlatformConfig';\n-\n-import NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\n import AnimatedNode from './AnimatedNode';\n+import NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\n+import type {PlatformConfig} from '../AnimatedPlatformConfig';\n \n const {connectAnimatedNodes, disconnectAnimatedNodes} =\n   NativeAnimatedHelper.API;\n \n export default class AnimatedWithChildren extends AnimatedNode {\n   _children: Array<AnimatedNode> = [];\n+  _parents: Array<AnimatedNode> = [];\n \n-  __makeNative(platformConfig: ?PlatformConfig) {\n-    if (!this.__isNative) {\n-      this.__isNative = true;\n+  // Public method to add a child\n+  addChild(child: AnimatedNode): void {\n+    this.__addChild(child);\n+  }\n \n-      const children = this._children;\n-      let length = children.length;\n-      if (length > 0) {\n-        for (let ii = 0; ii < length; ii++) {\n-          const child = children[ii];\n-          child.__makeNative(platformConfig);\n-          connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());\n-        }\n-      }\n-    }\n-    super.__makeNative(platformConfig);\n+  // Public method to remove a child\n+  removeChild(child: AnimatedNode): void {\n+    this.__removeChild(child);\n   }\n \n   __addChild(child: AnimatedNode): void {\n     if (this._children.length === 0) {\n       this.__attach();\n     }\n     this._children.push(child);\n+    child.addParent(this); // Maintain bidirectional parent-child relationship",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1933072050",
        "repo_full_name": "facebook/react-native",
        "pr_number": 48993,
        "pr_file": "packages/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js",
        "discussion_id": "1933072050",
        "commented_code": "@@ -10,41 +10,34 @@\n \n 'use strict';\n \n-import type {PlatformConfig} from '../AnimatedPlatformConfig';\n-\n-import NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\n import AnimatedNode from './AnimatedNode';\n+import NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\n+import type {PlatformConfig} from '../AnimatedPlatformConfig';\n \n const {connectAnimatedNodes, disconnectAnimatedNodes} =\n   NativeAnimatedHelper.API;\n \n export default class AnimatedWithChildren extends AnimatedNode {\n   _children: Array<AnimatedNode> = [];\n+  _parents: Array<AnimatedNode> = [];\n \n-  __makeNative(platformConfig: ?PlatformConfig) {\n-    if (!this.__isNative) {\n-      this.__isNative = true;\n+  // Public method to add a child\n+  addChild(child: AnimatedNode): void {\n+    this.__addChild(child);\n+  }\n \n-      const children = this._children;\n-      let length = children.length;\n-      if (length > 0) {\n-        for (let ii = 0; ii < length; ii++) {\n-          const child = children[ii];\n-          child.__makeNative(platformConfig);\n-          connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());\n-        }\n-      }\n-    }\n-    super.__makeNative(platformConfig);\n+  // Public method to remove a child\n+  removeChild(child: AnimatedNode): void {\n+    this.__removeChild(child);\n   }\n \n   __addChild(child: AnimatedNode): void {\n     if (this._children.length === 0) {\n       this.__attach();\n     }\n     this._children.push(child);\n+    child.addParent(this); // Maintain bidirectional parent-child relationship",
        "comment_created_at": "2025-01-29T01:11:01+00:00",
        "comment_author": "c-miles",
        "comment_body": " I\u2019m still seeing a memory leak as we keep adding the same child to `_children` multiple times. Here's an example where there's 334 children in the array while only 2 is expected.\r\n \r\n<img width=\"1095\" alt=\"Screenshot 2025-01-28 at 8 08 38\u202fPM\" src=\"https://github.com/user-attachments/assets/34893017-8aa7-4c4d-862a-808cb582756a\" />\r\n\r\n<br>\r\n<br>\r\n\r\n I resolved this locally by adding an `!this._children.includes(child)` check just like you're doing in `addParent` below\r\n \r\n Here's my original issue on react-native-web for reference, where I implemented just that change to resolve it: [RN-web issue](https://github.com/necolas/react-native-web/issues/2756)\r\n\r\nI was able to achieve the same result by tweaking the changes to your updated __addChild method, which resolves the issue\r\n\r\n```javascript\r\n  __addChild(child: AnimatedNode): void {\r\n    if (!this._children.includes(child)) {\r\n      if (this._children.length === 0) {\r\n        this.__attach()\r\n      }\r\n  \r\n      this._children.push(child)\r\n  \r\n      if (typeof child.addParent === 'function') {\r\n        child.addParent(this)\r\n      }\r\n  \r\n      if (this.__isNative) {\r\n        child.__makeNative(this.__getPlatformConfig())\r\n        connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag())\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "329535780",
    "pr_number": 26444,
    "pr_file": "Libraries/Lists/VirtualizedList.js",
    "created_at": "2019-09-30T11:50:36+00:00",
    "commented_code": "}\n \n   _maybeCallOnEndReached() {\n-    const {\n-      data,\n-      getItemCount,\n-      onEndReached,\n-      onEndReachedThreshold,\n-    } = this.props;\n-    const {contentLength, visibleLength, offset} = this._scrollMetrics;\n+    const {onEndReached, onEndReachedThreshold} = this.props;\n+    if (!onEndReached) {\n+      return;\n+    }\n+\n+    const {contentLength, visibleLength, offset, dOffset} = this._scrollMetrics;\n+\n+    // Scrolled in a direction that doesn't require a check,\n+    // such as scrolling up in the vertical list\n+    if (offset <= 0 || dOffset <= 0) {\n+      return;\n+    }\n+\n+    // contentLength did not change because no new data was added\n+    if (contentLength === this._sentEndForContentLength) {\n+      return;\n+    }\n+\n     const distanceFromEnd = contentLength - visibleLength - offset;\n-    if (\n-      onEndReached &&\n-      this.state.last === getItemCount(data) - 1 &&\n-      /* $FlowFixMe(>=0.63.0 site=react_native_fb) This comment suppresses an\n-       * error found when Flow v0.63 was deployed. To see the error delete this\n-       * comment and run Flow. */\n-      distanceFromEnd < onEndReachedThreshold * visibleLength &&\n-      (this._hasDataChangedSinceEndReached ||\n-        this._scrollMetrics.contentLength !== this._sentEndForContentLength)\n-    ) {\n-      // Only call onEndReached once for a given dataset + content length.\n-      this._hasDataChangedSinceEndReached = false;\n-      this._sentEndForContentLength = this._scrollMetrics.contentLength;\n-      onEndReached({distanceFromEnd});\n+\n+    // If the distance is farther than can be seen on the screen\n+    if (distanceFromEnd >= visibleLength) {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "329535780",
        "repo_full_name": "facebook/react-native",
        "pr_number": 26444,
        "pr_file": "Libraries/Lists/VirtualizedList.js",
        "discussion_id": "329535780",
        "commented_code": "@@ -1372,29 +1369,39 @@ class VirtualizedList extends React.PureComponent<Props, State> {\n   }\n \n   _maybeCallOnEndReached() {\n-    const {\n-      data,\n-      getItemCount,\n-      onEndReached,\n-      onEndReachedThreshold,\n-    } = this.props;\n-    const {contentLength, visibleLength, offset} = this._scrollMetrics;\n+    const {onEndReached, onEndReachedThreshold} = this.props;\n+    if (!onEndReached) {\n+      return;\n+    }\n+\n+    const {contentLength, visibleLength, offset, dOffset} = this._scrollMetrics;\n+\n+    // Scrolled in a direction that doesn't require a check,\n+    // such as scrolling up in the vertical list\n+    if (offset <= 0 || dOffset <= 0) {\n+      return;\n+    }\n+\n+    // contentLength did not change because no new data was added\n+    if (contentLength === this._sentEndForContentLength) {\n+      return;\n+    }\n+\n     const distanceFromEnd = contentLength - visibleLength - offset;\n-    if (\n-      onEndReached &&\n-      this.state.last === getItemCount(data) - 1 &&\n-      /* $FlowFixMe(>=0.63.0 site=react_native_fb) This comment suppresses an\n-       * error found when Flow v0.63 was deployed. To see the error delete this\n-       * comment and run Flow. */\n-      distanceFromEnd < onEndReachedThreshold * visibleLength &&\n-      (this._hasDataChangedSinceEndReached ||\n-        this._scrollMetrics.contentLength !== this._sentEndForContentLength)\n-    ) {\n-      // Only call onEndReached once for a given dataset + content length.\n-      this._hasDataChangedSinceEndReached = false;\n-      this._sentEndForContentLength = this._scrollMetrics.contentLength;\n-      onEndReached({distanceFromEnd});\n+\n+    // If the distance is farther than can be seen on the screen\n+    if (distanceFromEnd >= visibleLength) {",
        "comment_created_at": "2019-09-30T11:50:36+00:00",
        "comment_author": "sahrens",
        "comment_body": "`onEndReachedThreshold` can be greater than 1, in which case this check would be wrong. It's also unnecessary additional complexity since the `onEndReachedThreshold` check below will handle this case.",
        "pr_file_module": null
      },
      {
        "comment_id": "330376121",
        "repo_full_name": "facebook/react-native",
        "pr_number": 26444,
        "pr_file": "Libraries/Lists/VirtualizedList.js",
        "discussion_id": "329535780",
        "commented_code": "@@ -1372,29 +1369,39 @@ class VirtualizedList extends React.PureComponent<Props, State> {\n   }\n \n   _maybeCallOnEndReached() {\n-    const {\n-      data,\n-      getItemCount,\n-      onEndReached,\n-      onEndReachedThreshold,\n-    } = this.props;\n-    const {contentLength, visibleLength, offset} = this._scrollMetrics;\n+    const {onEndReached, onEndReachedThreshold} = this.props;\n+    if (!onEndReached) {\n+      return;\n+    }\n+\n+    const {contentLength, visibleLength, offset, dOffset} = this._scrollMetrics;\n+\n+    // Scrolled in a direction that doesn't require a check,\n+    // such as scrolling up in the vertical list\n+    if (offset <= 0 || dOffset <= 0) {\n+      return;\n+    }\n+\n+    // contentLength did not change because no new data was added\n+    if (contentLength === this._sentEndForContentLength) {\n+      return;\n+    }\n+\n     const distanceFromEnd = contentLength - visibleLength - offset;\n-    if (\n-      onEndReached &&\n-      this.state.last === getItemCount(data) - 1 &&\n-      /* $FlowFixMe(>=0.63.0 site=react_native_fb) This comment suppresses an\n-       * error found when Flow v0.63 was deployed. To see the error delete this\n-       * comment and run Flow. */\n-      distanceFromEnd < onEndReachedThreshold * visibleLength &&\n-      (this._hasDataChangedSinceEndReached ||\n-        this._scrollMetrics.contentLength !== this._sentEndForContentLength)\n-    ) {\n-      // Only call onEndReached once for a given dataset + content length.\n-      this._hasDataChangedSinceEndReached = false;\n-      this._sentEndForContentLength = this._scrollMetrics.contentLength;\n-      onEndReached({distanceFromEnd});\n+\n+    // If the distance is farther than can be seen on the screen\n+    if (distanceFromEnd >= visibleLength) {",
        "comment_created_at": "2019-10-02T05:26:18+00:00",
        "comment_author": "ifsnow",
        "comment_body": "You're right, but this is defensive logic to eliminate the possibility of duplicate calls in fast scrolling if `onEndReachedThreshold` is large such as default value(2). You can see the added [test code](https://github.com/facebook/react-native/blob/2d3f6ca9801ef92b446458a2efc795db4ec17021/Libraries/Lists/__tests__/VirtualizedList-test.js#L327).\r\n",
        "pr_file_module": null
      }
    ]
  }
]