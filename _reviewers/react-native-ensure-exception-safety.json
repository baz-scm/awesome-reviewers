[
  {
    "discussion_id": "1355025463",
    "pr_number": 40764,
    "pr_file": "packages/react-native/ReactCommon/react/nativemodule/core/platform/ios/ReactCommon/RCTTurboModule.mm",
    "created_at": "2023-10-11T13:36:43+00:00",
    "commented_code": "TurboModulePerfLogger::asyncMethodCallExecutionStart(moduleName, methodNameStr.c_str(), asyncCallCounter);\n     }\n \n-    @try {\n-      [inv invokeWithTarget:strongModule];\n-    } @catch (NSException *exception) {\n-      throw convertNSExceptionToJSError(runtime, exception);\n-    } @finally {\n-      [retainedObjectsForInvocation removeAllObjects];\n+    std::optional<jsi::JSError> handledCatch = std::nullopt;\n+    try {\n+      @try {\n+        [inv invokeWithTarget:strongModule];\n+       } @catch (NSException *exception) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"name\": exception.name,\n+                       @\"message\": exception.reason,\n+                       @\"stackSymbols\": exception.callStackSymbols,\n+                       @\"stackReturnAddresses\": exception.callStackReturnAddresses,\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @catch (NSError *error) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"userInfo\": error.userInfo,\n+                       @\"domain\": error.domain,\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @catch (NSString *errorMessage) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"message\": errorMessage,\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @catch (id e) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"message\": @\"Unknown Objective-C Object thrown.\",\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @finally {\n+         [retainedObjectsForInvocation removeAllObjects];\n+       }\n+    } catch (const std::exception &exception) {\n+      handledCatch = handleCause(runtime,\n+                  isSync,\n+                  @{\n+                    @\"message\": [NSString stringWithUTF8String:exception.what()],\n+                  },\n+                  retainedObjectsForInvocation,\n+                  optionalInternalRejectBlock);\n+    } catch (const std::string &errorMessage) {\n+      handledCatch = handleCause(runtime,\n+                  isSync,\n+                  @{\n+                    @\"message\": [NSString stringWithUTF8String:errorMessage.c_str()],\n+                  },\n+                  retainedObjectsForInvocation,\n+                  optionalInternalRejectBlock);\n+    } catch (...) {\n+      handledCatch = handleCause(runtime,\n+                  isSync,\n+                  @{\n+                    @\"message\": @\"Unknown C++ exception thrown.\",\n+                  },\n+                  retainedObjectsForInvocation,\n+                  optionalInternalRejectBlock);\n+    }\n+\n+    if (handledCatch.has_value()) {\n+      throw handledCatch.value();\n     }",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1355025463",
        "repo_full_name": "facebook/react-native",
        "pr_number": 40764,
        "pr_file": "packages/react-native/ReactCommon/react/nativemodule/core/platform/ios/ReactCommon/RCTTurboModule.mm",
        "discussion_id": "1355025463",
        "commented_code": "@@ -400,12 +481,77 @@ id convertJSIValueToObjCObject(jsi::Runtime &runtime, const jsi::Value &value, s\n       TurboModulePerfLogger::asyncMethodCallExecutionStart(moduleName, methodNameStr.c_str(), asyncCallCounter);\n     }\n \n-    @try {\n-      [inv invokeWithTarget:strongModule];\n-    } @catch (NSException *exception) {\n-      throw convertNSExceptionToJSError(runtime, exception);\n-    } @finally {\n-      [retainedObjectsForInvocation removeAllObjects];\n+    std::optional<jsi::JSError> handledCatch = std::nullopt;\n+    try {\n+      @try {\n+        [inv invokeWithTarget:strongModule];\n+       } @catch (NSException *exception) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"name\": exception.name,\n+                       @\"message\": exception.reason,\n+                       @\"stackSymbols\": exception.callStackSymbols,\n+                       @\"stackReturnAddresses\": exception.callStackReturnAddresses,\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @catch (NSError *error) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"userInfo\": error.userInfo,\n+                       @\"domain\": error.domain,\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @catch (NSString *errorMessage) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"message\": errorMessage,\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @catch (id e) {\n+         handledCatch = handleCause(runtime,\n+                     isSync,\n+                     @{\n+                       @\"message\": @\"Unknown Objective-C Object thrown.\",\n+                     },\n+                     retainedObjectsForInvocation,\n+                     optionalInternalRejectBlock);\n+       } @finally {\n+         [retainedObjectsForInvocation removeAllObjects];\n+       }\n+    } catch (const std::exception &exception) {\n+      handledCatch = handleCause(runtime,\n+                  isSync,\n+                  @{\n+                    @\"message\": [NSString stringWithUTF8String:exception.what()],\n+                  },\n+                  retainedObjectsForInvocation,\n+                  optionalInternalRejectBlock);\n+    } catch (const std::string &errorMessage) {\n+      handledCatch = handleCause(runtime,\n+                  isSync,\n+                  @{\n+                    @\"message\": [NSString stringWithUTF8String:errorMessage.c_str()],\n+                  },\n+                  retainedObjectsForInvocation,\n+                  optionalInternalRejectBlock);\n+    } catch (...) {\n+      handledCatch = handleCause(runtime,\n+                  isSync,\n+                  @{\n+                    @\"message\": @\"Unknown C++ exception thrown.\",\n+                  },\n+                  retainedObjectsForInvocation,\n+                  optionalInternalRejectBlock);\n+    }\n+\n+    if (handledCatch.has_value()) {\n+      throw handledCatch.value();\n     }",
        "comment_created_at": "2023-10-11T13:36:43+00:00",
        "comment_author": "javache",
        "comment_body": "I think you want some logic here that catches if it's safe, but re-throws otherwise.\r\n\r\n```\r\n    NSDictionary *caughtException = nil;\r\n    BOOL shouldCatchException = isSync || optionalInternalRejectBlock;\r\n    try {\r\n      @try {\r\n        [inv invokeWithTarget:strongModule];\r\n       } @catch (NSException *exception) {\r\n         caughtException = maybeCatchException(shouldCatchException, @{\r\n                       @\"name\": exception.name,\r\n                       @\"message\": exception.reason,\r\n                       @\"stackSymbols\": exception.callStackSymbols,\r\n                       @\"stackReturnAddresses\": exception.callStackReturnAddresses,\r\n                     });\r\n       } ...\r\n    } catch { ... }\r\n\r\n    if (caughtException) {\r\n      if (isSync) {\r\n        throw convertNSDictionaryToJSError(runtime, caughtException);\r\n      } else {\r\n        optionalInternalRejectBlock(caughtException);\r\n      }\r\n    }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1663982559",
    "pr_number": 40764,
    "pr_file": "packages/react-native/ReactCommon/react/nativemodule/core/platform/ios/ReactCommon/RCTTurboModule.mm",
    "created_at": "2024-07-03T10:42:13+00:00",
    "commented_code": "TurboModulePerfLogger::asyncMethodCallExecutionStart(moduleName, methodNameStr.c_str(), asyncCallCounter);\n     }\n \n-    @try {\n-      [inv invokeWithTarget:strongModule];\n-    } @catch (NSException *exception) {\n-      throw convertNSExceptionToJSError(runtime, exception);\n-    } @finally {\n-      [retainedObjectsForInvocation removeAllObjects];\n+    NSError *caughtException = nil;\n+    BOOL shouldCatchException = isSync || reject;\n+    try {\n+      @try {\n+        [inv invokeWithTarget:strongModule];\n+       } @catch (NSException *exception) {\n+         caughtException = maybeCatchException(\n+                     shouldCatchException, @{\n+                       @\"name\": exception.name,\n+                       NSLocalizedDescriptionKey: exception.reason,\n+                       @\"stackSymbols\": exception.callStackSymbols,\n+                       @\"stackReturnAddresses\": exception.callStackReturnAddresses,\n+                     });\n+       } @catch (NSError *error) {\n+         caughtException = maybeCatchException(shouldCatchException, error);\n+       } @catch (NSString *errorMessage) {\n+         caughtException = maybeCatchException(shouldCatchException, @{\n+                      NSLocalizedDescriptionKey: errorMessage,\n+                     });\n+       } @catch (id e) {\n+         caughtException = maybeCatchException(shouldCatchException, @{\n+                      NSLocalizedDescriptionKey: @\"Unknown Objective-C Object thrown.\",\n+                     });\n+       }\n+    } catch (const std::exception &exception) {\n+      caughtException = maybeCatchException(shouldCatchException, @{\n+                    NSLocalizedDescriptionKey: [NSString stringWithUTF8String:exception.what()],\n+                  });\n+    } catch (const std::string &errorMessage) {\n+      caughtException = maybeCatchException(shouldCatchException, @{\n+                    NSLocalizedDescriptionKey: [NSString stringWithUTF8String:errorMessage.c_str()],\n+                  });\n+    } catch (...) {\n+      caughtException = maybeCatchException(shouldCatchException, @{\n+                    NSLocalizedDescriptionKey: @\"Unknown C++ exception thrown.\",\n+                  });\n+    }\n+    [retainedObjectsForInvocation removeAllObjects];",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1663982559",
        "repo_full_name": "facebook/react-native",
        "pr_number": 40764,
        "pr_file": "packages/react-native/ReactCommon/react/nativemodule/core/platform/ios/ReactCommon/RCTTurboModule.mm",
        "discussion_id": "1663982559",
        "commented_code": "@@ -340,12 +387,51 @@ id convertJSIValueToObjCObject(jsi::Runtime &runtime, const jsi::Value &value, s\n       TurboModulePerfLogger::asyncMethodCallExecutionStart(moduleName, methodNameStr.c_str(), asyncCallCounter);\n     }\n \n-    @try {\n-      [inv invokeWithTarget:strongModule];\n-    } @catch (NSException *exception) {\n-      throw convertNSExceptionToJSError(runtime, exception);\n-    } @finally {\n-      [retainedObjectsForInvocation removeAllObjects];\n+    NSError *caughtException = nil;\n+    BOOL shouldCatchException = isSync || reject;\n+    try {\n+      @try {\n+        [inv invokeWithTarget:strongModule];\n+       } @catch (NSException *exception) {\n+         caughtException = maybeCatchException(\n+                     shouldCatchException, @{\n+                       @\"name\": exception.name,\n+                       NSLocalizedDescriptionKey: exception.reason,\n+                       @\"stackSymbols\": exception.callStackSymbols,\n+                       @\"stackReturnAddresses\": exception.callStackReturnAddresses,\n+                     });\n+       } @catch (NSError *error) {\n+         caughtException = maybeCatchException(shouldCatchException, error);\n+       } @catch (NSString *errorMessage) {\n+         caughtException = maybeCatchException(shouldCatchException, @{\n+                      NSLocalizedDescriptionKey: errorMessage,\n+                     });\n+       } @catch (id e) {\n+         caughtException = maybeCatchException(shouldCatchException, @{\n+                      NSLocalizedDescriptionKey: @\"Unknown Objective-C Object thrown.\",\n+                     });\n+       }\n+    } catch (const std::exception &exception) {\n+      caughtException = maybeCatchException(shouldCatchException, @{\n+                    NSLocalizedDescriptionKey: [NSString stringWithUTF8String:exception.what()],\n+                  });\n+    } catch (const std::string &errorMessage) {\n+      caughtException = maybeCatchException(shouldCatchException, @{\n+                    NSLocalizedDescriptionKey: [NSString stringWithUTF8String:errorMessage.c_str()],\n+                  });\n+    } catch (...) {\n+      caughtException = maybeCatchException(shouldCatchException, @{\n+                    NSLocalizedDescriptionKey: @\"Unknown C++ exception thrown.\",\n+                  });\n+    }\n+    [retainedObjectsForInvocation removeAllObjects];",
        "comment_created_at": "2024-07-03T10:42:13+00:00",
        "comment_author": "javache",
        "comment_body": "This still needs to go in a @finally, otherwise, we'll leak `retainedObjectsForInvocation` when exceptions are thrown.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1876157277",
    "pr_number": 48047,
    "pr_file": "packages/react-native/ReactCommon/react/renderer/core/RawValue.h",
    "created_at": "2024-12-09T15:11:50+00:00",
    "commented_code": "return true;\n   }\n \n+  template <typename T>\n+  static bool checkValueType(\n+      jsi::Runtime* runtime,\n+      const jsi::Value& value,\n+      std::unordered_map<std::string, T>* /*type*/) {\n+    if (!value.isObject()) {\n+      return false;\n+    }\n+\n+    jsi::Object asObject = value.getObject(*runtime);\n+\n+    auto propertyNames = asObject.getPropertyNames(*runtime);\n+    size_t size = propertyNames.size(*runtime);\n+    for (size_t i = 0; i < size; i++) {\n+      jsi::String propertyName =\n+          propertyNames.getValueAtIndex(*runtime, i).getString(*runtime);\n+      jsi::Value propertyValue = asObject.getProperty(*runtime, propertyName);\n+      if (!checkValueType(runtime, propertyValue, (T*)nullptr)) {\n+        return false;\n+      }\n+\n+      // Note: We test only one element.\n+      break;\n+    }\n+\n+    return true;\n+  }\n+\n   // Casts\n   static RawValue castValue(\n       const folly::dynamic& dynamic,\n       RawValue* /*type*/) noexcept {\n     return RawValue(dynamic);\n   }\n \n+  static RawValue castValue(\n+      jsi::Runtime* runtime,\n+      const jsi::Value& value,\n+      RawValue* /*type*/) noexcept {\n+    return RawValue(*runtime, value);\n+  }\n+\n   static bool castValue(const folly::dynamic& dynamic, bool* /*type*/) {\n     return dynamic.getBool();\n   }\n \n+  static bool\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, bool* /*type*/) {\n+    return value.asBool();\n+  }\n+\n   static int castValue(const folly::dynamic& dynamic, int* /*type*/) {\n     return static_cast<int>(dynamic.asInt());\n   }\n \n+  static int\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int* /*type*/) {\n+    double number = value.asNumber();\n+    return static_cast<int>(number);\n+  }\n+\n   static int64_t castValue(const folly::dynamic& dynamic, int64_t* /*type*/) {\n     return dynamic.asInt();\n   }\n \n+  static int64_t\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int64_t* /*type*/) {\n+    double number = value.asNumber();\n+    return static_cast<int64_t>(number);\n+  }\n+\n   static float castValue(const folly::dynamic& dynamic, float* /*type*/) {\n     return static_cast<float>(dynamic.asDouble());\n   }\n \n+  static float\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, float* /*type*/) {\n+    double number = value.asNumber();\n+    return static_cast<float>(number);\n+  }\n+\n   static double castValue(const folly::dynamic& dynamic, double* /*type*/) {\n     return dynamic.asDouble();\n   }\n \n+  static double\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, double* /*type*/) {\n+    return value.asNumber();\n+  }\n+\n   static std::string castValue(\n       const folly::dynamic& dynamic,\n       std::string* /*type*/) {\n     return dynamic.getString();\n   }\n \n+  static std::string castValue(\n+      jsi::Runtime* runtime,\n+      const jsi::Value& value,\n+      std::string* /*type*/) {\n+    jsi::String stringValue = value.asString(*runtime);\n+    return stringValue.utf8(*runtime);\n+  }\n+\n+  static JsiValueReturnType castValue(\n+      const folly::dynamic& dynamic,\n+      JsiValueReturnType* /*type*/) {\n+    react_native_assert(false);\n+    throw new std::runtime_error(",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1876157277",
        "repo_full_name": "facebook/react-native",
        "pr_number": 48047,
        "pr_file": "packages/react-native/ReactCommon/react/renderer/core/RawValue.h",
        "discussion_id": "1876157277",
        "commented_code": "@@ -204,39 +338,125 @@ class RawValue {\n     return true;\n   }\n \n+  template <typename T>\n+  static bool checkValueType(\n+      jsi::Runtime* runtime,\n+      const jsi::Value& value,\n+      std::unordered_map<std::string, T>* /*type*/) {\n+    if (!value.isObject()) {\n+      return false;\n+    }\n+\n+    jsi::Object asObject = value.getObject(*runtime);\n+\n+    auto propertyNames = asObject.getPropertyNames(*runtime);\n+    size_t size = propertyNames.size(*runtime);\n+    for (size_t i = 0; i < size; i++) {\n+      jsi::String propertyName =\n+          propertyNames.getValueAtIndex(*runtime, i).getString(*runtime);\n+      jsi::Value propertyValue = asObject.getProperty(*runtime, propertyName);\n+      if (!checkValueType(runtime, propertyValue, (T*)nullptr)) {\n+        return false;\n+      }\n+\n+      // Note: We test only one element.\n+      break;\n+    }\n+\n+    return true;\n+  }\n+\n   // Casts\n   static RawValue castValue(\n       const folly::dynamic& dynamic,\n       RawValue* /*type*/) noexcept {\n     return RawValue(dynamic);\n   }\n \n+  static RawValue castValue(\n+      jsi::Runtime* runtime,\n+      const jsi::Value& value,\n+      RawValue* /*type*/) noexcept {\n+    return RawValue(*runtime, value);\n+  }\n+\n   static bool castValue(const folly::dynamic& dynamic, bool* /*type*/) {\n     return dynamic.getBool();\n   }\n \n+  static bool\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, bool* /*type*/) {\n+    return value.asBool();\n+  }\n+\n   static int castValue(const folly::dynamic& dynamic, int* /*type*/) {\n     return static_cast<int>(dynamic.asInt());\n   }\n \n+  static int\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int* /*type*/) {\n+    double number = value.asNumber();\n+    return static_cast<int>(number);\n+  }\n+\n   static int64_t castValue(const folly::dynamic& dynamic, int64_t* /*type*/) {\n     return dynamic.asInt();\n   }\n \n+  static int64_t\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, int64_t* /*type*/) {\n+    double number = value.asNumber();\n+    return static_cast<int64_t>(number);\n+  }\n+\n   static float castValue(const folly::dynamic& dynamic, float* /*type*/) {\n     return static_cast<float>(dynamic.asDouble());\n   }\n \n+  static float\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, float* /*type*/) {\n+    double number = value.asNumber();\n+    return static_cast<float>(number);\n+  }\n+\n   static double castValue(const folly::dynamic& dynamic, double* /*type*/) {\n     return dynamic.asDouble();\n   }\n \n+  static double\n+  castValue(jsi::Runtime* runtime, const jsi::Value& value, double* /*type*/) {\n+    return value.asNumber();\n+  }\n+\n   static std::string castValue(\n       const folly::dynamic& dynamic,\n       std::string* /*type*/) {\n     return dynamic.getString();\n   }\n \n+  static std::string castValue(\n+      jsi::Runtime* runtime,\n+      const jsi::Value& value,\n+      std::string* /*type*/) {\n+    jsi::String stringValue = value.asString(*runtime);\n+    return stringValue.utf8(*runtime);\n+  }\n+\n+  static JsiValueReturnType castValue(\n+      const folly::dynamic& dynamic,\n+      JsiValueReturnType* /*type*/) {\n+    react_native_assert(false);\n+    throw new std::runtime_error(",
        "comment_created_at": "2024-12-09T15:11:50+00:00",
        "comment_author": "javache",
        "comment_body": "C++ exceptions shouldn't be heap allocated\r\n```suggestion\r\n    throw std::runtime_error(\r\n```",
        "pr_file_module": null
      }
    ]
  }
]