[
  {
    "discussion_id": "2014553249",
    "pr_number": 50268,
    "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
    "created_at": "2025-03-26T16:24:31+00:00",
    "commented_code": "}>,\n };\n \n-const DEFAULT_DIRECTION: LinearGradientDirection = {\n-  type: 'angle',\n-  value: 180,\n+// Radial Gradient\n+const DEFAULT_RADIAL_SHAPE = 'ellipse';\n+const DEFAULT_RADIAL_SIZE = 'farthest-corner';\n+// center\n+const DEFAULT_RADIAL_POSITION: RadialGradientPosition = {\n+  top: '50%',\n+  left: '50%',\n };\n+type RadialExtent =\n+  | 'closest-corner'\n+  | 'closest-side'\n+  | 'farthest-corner'\n+  | 'farthest-side';\n+type RadialGradientSize =\n+  | RadialExtent\n+  | {\n+      x: string | number,\n+      y: string | number,\n+    };\n+type RadialGradientShape = 'circle' | 'ellipse';\n+type RadialGradientPosition =\n+  | {\n+      top: number | string,\n+      left: number | string,\n+    }\n+  | {\n+      top: number | string,\n+      right: number | string,\n+    }\n+  | {\n+      bottom: number | string,\n+      right: number | string,\n+    }\n+  | {\n+      bottom: number | string,\n+      left: number | string,\n+    };\n+type RadialGradientBackgroundImage = {\n+  type: 'radialGradient',\n+  shape: RadialGradientShape,\n+  size: RadialGradientSize,\n+  position: RadialGradientPosition,\n+  colorStops: $ReadOnlyArray<{\n+    color: ColorStopColor,\n+    position: ColorStopPosition,\n+  }>,\n+};\n+\n+// null color indicate that the transition hint syntax is used. e.g. red, 20%, blue\n+type ColorStopColor = ProcessedColorValue | null;\n+// percentage or pixel value\n+type ColorStopPosition = number | string | null;\n+\n+type ParsedBackgroundImageValue =\n+  | LinearGradientBackgroundImage\n+  | RadialGradientBackgroundImage;\n \n export default function processBackgroundImage(\n-  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n-): $ReadOnlyArray<ParsedGradientValue> {\n-  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n+  backgroundImage: ?($ReadOnlyArray<BackgroundImageValue> | string),\n+): $ReadOnlyArray<ParsedBackgroundImageValue> {\n+  let result: $ReadOnlyArray<ParsedBackgroundImageValue> = [];\n   if (backgroundImage == null) {\n     return result;\n   }\n \n   if (typeof backgroundImage === 'string') {\n-    result = parseCSSLinearGradient(backgroundImage.replace(/\n/g, ' '));\n+    result = parseBackgroundImageCSSString(backgroundImage.replace(/\n/g, ' '));\n   } else if (Array.isArray(backgroundImage)) {\n     for (const bgImage of backgroundImage) {\n-      const processedColorStops: Array<{\n-        color: ColorStopColor,\n-        position: ColorStopPosition,\n-      }> = [];\n-      for (let index = 0; index < bgImage.colorStops.length; index++) {\n-        const colorStop = bgImage.colorStops[index];\n-        const positions = colorStop.positions;\n-        // Color transition hint syntax (red, 20%, blue)\n-        if (\n-          colorStop.color == null &&\n-          Array.isArray(positions) &&\n-          positions.length === 1\n-        ) {\n-          const position = positions[0];\n-          if (\n-            typeof position === 'number' ||\n-            (typeof position === 'string' && position.endsWith('%'))\n-          ) {\n-            processedColorStops.push({\n-              color: null,\n-              position,\n-            });\n+      const processedColorStops = processColorStops(bgImage);\n+      if (processedColorStops == null) {\n+        // If a color stop is invalid, return an empty array and do not apply any gradient. Same as web.\n+        return [];\n+      }\n+\n+      if (bgImage.type === 'linearGradient') {\n+        let direction: LinearGradientDirection =\n+          LINEAR_GRADIENT_DEFAULT_DIRECTION;\n+        const bgDirection =\n+          bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n+\n+        if (bgDirection != null) {\n+          if (LINEAR_GRADIENT_ANGLE_UNIT_REGEX.test(bgDirection)) {\n+            const parsedAngle = getAngleInDegrees(bgDirection);\n+            if (parsedAngle != null) {\n+              direction = {\n+                type: 'angle',\n+                value: parsedAngle,\n+              };\n+            } else {\n+              // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n+              return [];\n+            }\n+          } else if (LINEAR_GRADIENT_DIRECTION_REGEX.test(bgDirection)) {\n+            const parsedDirection = getDirectionForKeyword(bgDirection);\n+            if (parsedDirection != null) {\n+              direction = parsedDirection;\n+            } else {\n+              // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n+              return [];\n+            }\n           } else {\n-            // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n-            return [];\n-          }\n-        } else {\n-          const processedColor = processColor(colorStop.color);\n-          if (processedColor == null) {\n-            // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n+            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n             return [];\n           }\n-          if (positions != null && positions.length > 0) {\n-            for (const position of positions) {\n-              if (\n-                typeof position === 'number' ||\n-                (typeof position === 'string' && position.endsWith('%'))\n-              ) {\n-                processedColorStops.push({\n-                  color: processedColor,\n-                  position,\n-                });\n-              } else {\n-                // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n-                return [];\n-              }\n-            }\n+        }\n+\n+        result = result.concat({\n+          type: 'linearGradient',\n+          direction,\n+          colorStops: processedColorStops,\n+        });\n+      } else if (bgImage.type === 'radialGradient') {\n+        let shape: RadialGradientShape = DEFAULT_RADIAL_SHAPE;\n+        let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n+        let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n+\n+        if (bgImage.shape != null) {\n+          if (bgImage.shape === 'circle' || bgImage.shape === 'ellipse') {\n+            shape = bgImage.shape;\n           } else {\n-            processedColorStops.push({\n-              color: processedColor,\n-              position: null,\n-            });\n+            // If the shape is invalid, return an empty array and do not apply any gradient. Same as web.\n+            return [];\n           }\n         }\n-      }\n \n-      let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n-      const bgDirection =\n-        bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n-\n-      if (bgDirection != null) {\n-        if (ANGLE_UNIT_REGEX.test(bgDirection)) {\n-          const parsedAngle = getAngleInDegrees(bgDirection);\n-          if (parsedAngle != null) {\n-            direction = {\n-              type: 'angle',\n-              value: parsedAngle,\n+        if (bgImage.size != null) {\n+          if (\n+            typeof bgImage.size === 'string' &&\n+            (bgImage.size === 'closest-side' ||\n+              bgImage.size === 'closest-corner' ||\n+              bgImage.size === 'farthest-side' ||\n+              bgImage.size === 'farthest-corner')\n+          ) {\n+            size = bgImage.size;\n+          } else if (\n+            typeof bgImage.size === 'object' &&\n+            bgImage.size.x != null &&\n+            bgImage.size.y != null\n+          ) {\n+            size = {\n+              x: bgImage.size.x,\n+              y: bgImage.size.y,\n             };\n           } else {\n-            // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n+            // If the size is invalid, return an empty array and do not apply any gradient. Same as web.\n             return [];\n           }\n-        } else if (DIRECTION_KEYWORD_REGEX.test(bgDirection)) {\n-          const parsedDirection = getDirectionForKeyword(bgDirection);\n-          if (parsedDirection != null) {\n-            direction = parsedDirection;\n+        }\n+\n+        if (bgImage.position != null) {\n+          position = bgImage.position;\n+        }\n+\n+        result = result.concat({\n+          type: 'radialGradient',\n+          shape,\n+          size,\n+          position,\n+          colorStops: processedColorStops,\n+        });\n+      }\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+function processColorStops(bgImage: BackgroundImageValue): $ReadOnlyArray<{\n+  color: ColorStopColor,\n+  position: ColorStopPosition,\n+}> | null {\n+  const processedColorStops: Array<{\n+    color: ColorStopColor,\n+    position: ColorStopPosition,\n+  }> = [];\n+\n+  for (let index = 0; index < bgImage.colorStops.length; index++) {\n+    const colorStop = bgImage.colorStops[index];\n+    const positions = colorStop.positions;\n+    // Color transition hint syntax (red, 20%, blue)\n+    if (\n+      colorStop.color == null &&\n+      Array.isArray(positions) &&\n+      positions.length === 1\n+    ) {\n+      const position = positions[0];\n+      if (\n+        typeof position === 'number' ||\n+        (typeof position === 'string' && position.endsWith('%'))\n+      ) {\n+        processedColorStops.push({\n+          color: null,\n+          position,\n+        });\n+      } else {\n+        // If a position is invalid, return null and do not apply gradient. Same as web.\n+        return null;\n+      }\n+    } else {\n+      const processedColor = processColor(colorStop.color);\n+      if (processedColor == null) {\n+        // If a color is invalid, return null and do not apply gradient. Same as web.\n+        return null;\n+      }\n+      if (positions != null && positions.length > 0) {\n+        for (const position of positions) {\n+          if (\n+            typeof position === 'number' ||\n+            (typeof position === 'string' && position.endsWith('%'))\n+          ) {\n+            processedColorStops.push({\n+              color: processedColor,\n+              position,\n+            });\n           } else {\n-            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n-            return [];\n+            // If a position is invalid, return null and do not apply gradient. Same as web.\n+            return null;\n           }\n-        } else {\n-          // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n-          return [];\n         }\n+      } else {\n+        processedColorStops.push({\n+          color: processedColor,\n+          position: null,\n+        });\n       }\n-\n-      result = result.concat({\n-        type: 'linearGradient',\n-        direction,\n-        colorStops: processedColorStops,\n-      });\n     }\n   }\n \n-  return result;\n+  return processedColorStops;\n }\n \n-function parseCSSLinearGradient(\n+function parseBackgroundImageCSSString(\n   cssString: string,\n-): $ReadOnlyArray<ParsedGradientValue> {\n+): $ReadOnlyArray<ParsedBackgroundImageValue> {\n   const gradients = [];\n   let match;\n+  // matches one or more linear-gradient or radial-gradient functions in CSS\n+  const gradientRegex =\n+    /(linear|radial)-gradient\\s*\\(((?:\\([^)]*\\)|[^()])*)\\)/gi;\n \n-  // matches one or more linear-gradient functions in CSS\n-  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n-\n-  while ((match = linearGradientRegex.exec(cssString))) {\n-    const gradientContent = match[1];\n-    const parts = gradientContent.split(',');\n-    let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n-    const trimmedDirection = parts[0].trim().toLowerCase();\n-\n-    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n-      const parsedAngle = getAngleInDegrees(trimmedDirection);\n-      if (parsedAngle != null) {\n-        direction = {\n-          type: 'angle',\n-          value: parsedAngle,\n-        };\n-        parts.shift();\n-      } else {\n-        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n-        return [];\n+  while ((match = gradientRegex.exec(cssString))) {\n+    const [, type, gradientContent] = match;\n+    const isRadial = type.toLowerCase() === 'radial';\n+\n+    const gradient = isRadial\n+      ? parseRadialGradientCSSString(gradientContent)\n+      : parseLinearGradientCSSString(gradientContent);\n+\n+    if (gradient != null) {\n+      gradients.push(gradient);\n+    }\n+  }\n+\n+  return gradients;\n+}\n+\n+function parseRadialGradientCSSString(\n+  gradientContent: string,\n+): RadialGradientBackgroundImage | null {\n+  let shape = DEFAULT_RADIAL_SHAPE;\n+  let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n+  let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n+\n+  // split the content by commas, but not if inside parentheses (for color values)\n+  const parts = gradientContent.split(/,(?![^(]*\\))/);\n+  // first part may contain shape, size, and position\n+  // [ <radial-shape> || <radial-size> ]? [ at <position> ]?\n+  const firstPartStr = parts[0].trim();\n+  const remainingParts = [...parts];\n+  let hasShapeSizeOrPositionString = false;\n+  let hasExplicitSingleSize = false;\n+  let hasExplicitShape = false;\n+  const firstPartTokens = firstPartStr.split(/\\s+/);\n+\n+  while (firstPartTokens.length > 0) {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2014553249",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50268,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "2014553249",
        "commented_code": "@@ -36,261 +37,700 @@ type ParsedGradientValue = {\n   }>,\n };\n \n-const DEFAULT_DIRECTION: LinearGradientDirection = {\n-  type: 'angle',\n-  value: 180,\n+// Radial Gradient\n+const DEFAULT_RADIAL_SHAPE = 'ellipse';\n+const DEFAULT_RADIAL_SIZE = 'farthest-corner';\n+// center\n+const DEFAULT_RADIAL_POSITION: RadialGradientPosition = {\n+  top: '50%',\n+  left: '50%',\n };\n+type RadialExtent =\n+  | 'closest-corner'\n+  | 'closest-side'\n+  | 'farthest-corner'\n+  | 'farthest-side';\n+type RadialGradientSize =\n+  | RadialExtent\n+  | {\n+      x: string | number,\n+      y: string | number,\n+    };\n+type RadialGradientShape = 'circle' | 'ellipse';\n+type RadialGradientPosition =\n+  | {\n+      top: number | string,\n+      left: number | string,\n+    }\n+  | {\n+      top: number | string,\n+      right: number | string,\n+    }\n+  | {\n+      bottom: number | string,\n+      right: number | string,\n+    }\n+  | {\n+      bottom: number | string,\n+      left: number | string,\n+    };\n+type RadialGradientBackgroundImage = {\n+  type: 'radialGradient',\n+  shape: RadialGradientShape,\n+  size: RadialGradientSize,\n+  position: RadialGradientPosition,\n+  colorStops: $ReadOnlyArray<{\n+    color: ColorStopColor,\n+    position: ColorStopPosition,\n+  }>,\n+};\n+\n+// null color indicate that the transition hint syntax is used. e.g. red, 20%, blue\n+type ColorStopColor = ProcessedColorValue | null;\n+// percentage or pixel value\n+type ColorStopPosition = number | string | null;\n+\n+type ParsedBackgroundImageValue =\n+  | LinearGradientBackgroundImage\n+  | RadialGradientBackgroundImage;\n \n export default function processBackgroundImage(\n-  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n-): $ReadOnlyArray<ParsedGradientValue> {\n-  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n+  backgroundImage: ?($ReadOnlyArray<BackgroundImageValue> | string),\n+): $ReadOnlyArray<ParsedBackgroundImageValue> {\n+  let result: $ReadOnlyArray<ParsedBackgroundImageValue> = [];\n   if (backgroundImage == null) {\n     return result;\n   }\n \n   if (typeof backgroundImage === 'string') {\n-    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n+    result = parseBackgroundImageCSSString(backgroundImage.replace(/\\n/g, ' '));\n   } else if (Array.isArray(backgroundImage)) {\n     for (const bgImage of backgroundImage) {\n-      const processedColorStops: Array<{\n-        color: ColorStopColor,\n-        position: ColorStopPosition,\n-      }> = [];\n-      for (let index = 0; index < bgImage.colorStops.length; index++) {\n-        const colorStop = bgImage.colorStops[index];\n-        const positions = colorStop.positions;\n-        // Color transition hint syntax (red, 20%, blue)\n-        if (\n-          colorStop.color == null &&\n-          Array.isArray(positions) &&\n-          positions.length === 1\n-        ) {\n-          const position = positions[0];\n-          if (\n-            typeof position === 'number' ||\n-            (typeof position === 'string' && position.endsWith('%'))\n-          ) {\n-            processedColorStops.push({\n-              color: null,\n-              position,\n-            });\n+      const processedColorStops = processColorStops(bgImage);\n+      if (processedColorStops == null) {\n+        // If a color stop is invalid, return an empty array and do not apply any gradient. Same as web.\n+        return [];\n+      }\n+\n+      if (bgImage.type === 'linearGradient') {\n+        let direction: LinearGradientDirection =\n+          LINEAR_GRADIENT_DEFAULT_DIRECTION;\n+        const bgDirection =\n+          bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n+\n+        if (bgDirection != null) {\n+          if (LINEAR_GRADIENT_ANGLE_UNIT_REGEX.test(bgDirection)) {\n+            const parsedAngle = getAngleInDegrees(bgDirection);\n+            if (parsedAngle != null) {\n+              direction = {\n+                type: 'angle',\n+                value: parsedAngle,\n+              };\n+            } else {\n+              // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n+              return [];\n+            }\n+          } else if (LINEAR_GRADIENT_DIRECTION_REGEX.test(bgDirection)) {\n+            const parsedDirection = getDirectionForKeyword(bgDirection);\n+            if (parsedDirection != null) {\n+              direction = parsedDirection;\n+            } else {\n+              // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n+              return [];\n+            }\n           } else {\n-            // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n-            return [];\n-          }\n-        } else {\n-          const processedColor = processColor(colorStop.color);\n-          if (processedColor == null) {\n-            // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n+            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n             return [];\n           }\n-          if (positions != null && positions.length > 0) {\n-            for (const position of positions) {\n-              if (\n-                typeof position === 'number' ||\n-                (typeof position === 'string' && position.endsWith('%'))\n-              ) {\n-                processedColorStops.push({\n-                  color: processedColor,\n-                  position,\n-                });\n-              } else {\n-                // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n-                return [];\n-              }\n-            }\n+        }\n+\n+        result = result.concat({\n+          type: 'linearGradient',\n+          direction,\n+          colorStops: processedColorStops,\n+        });\n+      } else if (bgImage.type === 'radialGradient') {\n+        let shape: RadialGradientShape = DEFAULT_RADIAL_SHAPE;\n+        let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n+        let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n+\n+        if (bgImage.shape != null) {\n+          if (bgImage.shape === 'circle' || bgImage.shape === 'ellipse') {\n+            shape = bgImage.shape;\n           } else {\n-            processedColorStops.push({\n-              color: processedColor,\n-              position: null,\n-            });\n+            // If the shape is invalid, return an empty array and do not apply any gradient. Same as web.\n+            return [];\n           }\n         }\n-      }\n \n-      let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n-      const bgDirection =\n-        bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n-\n-      if (bgDirection != null) {\n-        if (ANGLE_UNIT_REGEX.test(bgDirection)) {\n-          const parsedAngle = getAngleInDegrees(bgDirection);\n-          if (parsedAngle != null) {\n-            direction = {\n-              type: 'angle',\n-              value: parsedAngle,\n+        if (bgImage.size != null) {\n+          if (\n+            typeof bgImage.size === 'string' &&\n+            (bgImage.size === 'closest-side' ||\n+              bgImage.size === 'closest-corner' ||\n+              bgImage.size === 'farthest-side' ||\n+              bgImage.size === 'farthest-corner')\n+          ) {\n+            size = bgImage.size;\n+          } else if (\n+            typeof bgImage.size === 'object' &&\n+            bgImage.size.x != null &&\n+            bgImage.size.y != null\n+          ) {\n+            size = {\n+              x: bgImage.size.x,\n+              y: bgImage.size.y,\n             };\n           } else {\n-            // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n+            // If the size is invalid, return an empty array and do not apply any gradient. Same as web.\n             return [];\n           }\n-        } else if (DIRECTION_KEYWORD_REGEX.test(bgDirection)) {\n-          const parsedDirection = getDirectionForKeyword(bgDirection);\n-          if (parsedDirection != null) {\n-            direction = parsedDirection;\n+        }\n+\n+        if (bgImage.position != null) {\n+          position = bgImage.position;\n+        }\n+\n+        result = result.concat({\n+          type: 'radialGradient',\n+          shape,\n+          size,\n+          position,\n+          colorStops: processedColorStops,\n+        });\n+      }\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+function processColorStops(bgImage: BackgroundImageValue): $ReadOnlyArray<{\n+  color: ColorStopColor,\n+  position: ColorStopPosition,\n+}> | null {\n+  const processedColorStops: Array<{\n+    color: ColorStopColor,\n+    position: ColorStopPosition,\n+  }> = [];\n+\n+  for (let index = 0; index < bgImage.colorStops.length; index++) {\n+    const colorStop = bgImage.colorStops[index];\n+    const positions = colorStop.positions;\n+    // Color transition hint syntax (red, 20%, blue)\n+    if (\n+      colorStop.color == null &&\n+      Array.isArray(positions) &&\n+      positions.length === 1\n+    ) {\n+      const position = positions[0];\n+      if (\n+        typeof position === 'number' ||\n+        (typeof position === 'string' && position.endsWith('%'))\n+      ) {\n+        processedColorStops.push({\n+          color: null,\n+          position,\n+        });\n+      } else {\n+        // If a position is invalid, return null and do not apply gradient. Same as web.\n+        return null;\n+      }\n+    } else {\n+      const processedColor = processColor(colorStop.color);\n+      if (processedColor == null) {\n+        // If a color is invalid, return null and do not apply gradient. Same as web.\n+        return null;\n+      }\n+      if (positions != null && positions.length > 0) {\n+        for (const position of positions) {\n+          if (\n+            typeof position === 'number' ||\n+            (typeof position === 'string' && position.endsWith('%'))\n+          ) {\n+            processedColorStops.push({\n+              color: processedColor,\n+              position,\n+            });\n           } else {\n-            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n-            return [];\n+            // If a position is invalid, return null and do not apply gradient. Same as web.\n+            return null;\n           }\n-        } else {\n-          // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n-          return [];\n         }\n+      } else {\n+        processedColorStops.push({\n+          color: processedColor,\n+          position: null,\n+        });\n       }\n-\n-      result = result.concat({\n-        type: 'linearGradient',\n-        direction,\n-        colorStops: processedColorStops,\n-      });\n     }\n   }\n \n-  return result;\n+  return processedColorStops;\n }\n \n-function parseCSSLinearGradient(\n+function parseBackgroundImageCSSString(\n   cssString: string,\n-): $ReadOnlyArray<ParsedGradientValue> {\n+): $ReadOnlyArray<ParsedBackgroundImageValue> {\n   const gradients = [];\n   let match;\n+  // matches one or more linear-gradient or radial-gradient functions in CSS\n+  const gradientRegex =\n+    /(linear|radial)-gradient\\s*\\(((?:\\([^)]*\\)|[^()])*)\\)/gi;\n \n-  // matches one or more linear-gradient functions in CSS\n-  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n-\n-  while ((match = linearGradientRegex.exec(cssString))) {\n-    const gradientContent = match[1];\n-    const parts = gradientContent.split(',');\n-    let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n-    const trimmedDirection = parts[0].trim().toLowerCase();\n-\n-    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n-      const parsedAngle = getAngleInDegrees(trimmedDirection);\n-      if (parsedAngle != null) {\n-        direction = {\n-          type: 'angle',\n-          value: parsedAngle,\n-        };\n-        parts.shift();\n-      } else {\n-        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n-        return [];\n+  while ((match = gradientRegex.exec(cssString))) {\n+    const [, type, gradientContent] = match;\n+    const isRadial = type.toLowerCase() === 'radial';\n+\n+    const gradient = isRadial\n+      ? parseRadialGradientCSSString(gradientContent)\n+      : parseLinearGradientCSSString(gradientContent);\n+\n+    if (gradient != null) {\n+      gradients.push(gradient);\n+    }\n+  }\n+\n+  return gradients;\n+}\n+\n+function parseRadialGradientCSSString(\n+  gradientContent: string,\n+): RadialGradientBackgroundImage | null {\n+  let shape = DEFAULT_RADIAL_SHAPE;\n+  let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n+  let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n+\n+  // split the content by commas, but not if inside parentheses (for color values)\n+  const parts = gradientContent.split(/,(?![^(]*\\))/);\n+  // first part may contain shape, size, and position\n+  // [ <radial-shape> || <radial-size> ]? [ at <position> ]?\n+  const firstPartStr = parts[0].trim();\n+  const remainingParts = [...parts];\n+  let hasShapeSizeOrPositionString = false;\n+  let hasExplicitSingleSize = false;\n+  let hasExplicitShape = false;\n+  const firstPartTokens = firstPartStr.split(/\\s+/);\n+\n+  while (firstPartTokens.length > 0) {",
        "comment_created_at": "2025-03-26T16:24:31+00:00",
        "comment_author": "jorge-cab",
        "comment_body": "So all the parsing done with `firstPartTokens` is the position part of radial-gradient? Can we maybe move to a function `parseRadialGradientPosition` so that it is easier to reason about?",
        "pr_file_module": null
      },
      {
        "comment_id": "2017316729",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50268,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "2014553249",
        "commented_code": "@@ -36,261 +37,700 @@ type ParsedGradientValue = {\n   }>,\n };\n \n-const DEFAULT_DIRECTION: LinearGradientDirection = {\n-  type: 'angle',\n-  value: 180,\n+// Radial Gradient\n+const DEFAULT_RADIAL_SHAPE = 'ellipse';\n+const DEFAULT_RADIAL_SIZE = 'farthest-corner';\n+// center\n+const DEFAULT_RADIAL_POSITION: RadialGradientPosition = {\n+  top: '50%',\n+  left: '50%',\n };\n+type RadialExtent =\n+  | 'closest-corner'\n+  | 'closest-side'\n+  | 'farthest-corner'\n+  | 'farthest-side';\n+type RadialGradientSize =\n+  | RadialExtent\n+  | {\n+      x: string | number,\n+      y: string | number,\n+    };\n+type RadialGradientShape = 'circle' | 'ellipse';\n+type RadialGradientPosition =\n+  | {\n+      top: number | string,\n+      left: number | string,\n+    }\n+  | {\n+      top: number | string,\n+      right: number | string,\n+    }\n+  | {\n+      bottom: number | string,\n+      right: number | string,\n+    }\n+  | {\n+      bottom: number | string,\n+      left: number | string,\n+    };\n+type RadialGradientBackgroundImage = {\n+  type: 'radialGradient',\n+  shape: RadialGradientShape,\n+  size: RadialGradientSize,\n+  position: RadialGradientPosition,\n+  colorStops: $ReadOnlyArray<{\n+    color: ColorStopColor,\n+    position: ColorStopPosition,\n+  }>,\n+};\n+\n+// null color indicate that the transition hint syntax is used. e.g. red, 20%, blue\n+type ColorStopColor = ProcessedColorValue | null;\n+// percentage or pixel value\n+type ColorStopPosition = number | string | null;\n+\n+type ParsedBackgroundImageValue =\n+  | LinearGradientBackgroundImage\n+  | RadialGradientBackgroundImage;\n \n export default function processBackgroundImage(\n-  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n-): $ReadOnlyArray<ParsedGradientValue> {\n-  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n+  backgroundImage: ?($ReadOnlyArray<BackgroundImageValue> | string),\n+): $ReadOnlyArray<ParsedBackgroundImageValue> {\n+  let result: $ReadOnlyArray<ParsedBackgroundImageValue> = [];\n   if (backgroundImage == null) {\n     return result;\n   }\n \n   if (typeof backgroundImage === 'string') {\n-    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n+    result = parseBackgroundImageCSSString(backgroundImage.replace(/\\n/g, ' '));\n   } else if (Array.isArray(backgroundImage)) {\n     for (const bgImage of backgroundImage) {\n-      const processedColorStops: Array<{\n-        color: ColorStopColor,\n-        position: ColorStopPosition,\n-      }> = [];\n-      for (let index = 0; index < bgImage.colorStops.length; index++) {\n-        const colorStop = bgImage.colorStops[index];\n-        const positions = colorStop.positions;\n-        // Color transition hint syntax (red, 20%, blue)\n-        if (\n-          colorStop.color == null &&\n-          Array.isArray(positions) &&\n-          positions.length === 1\n-        ) {\n-          const position = positions[0];\n-          if (\n-            typeof position === 'number' ||\n-            (typeof position === 'string' && position.endsWith('%'))\n-          ) {\n-            processedColorStops.push({\n-              color: null,\n-              position,\n-            });\n+      const processedColorStops = processColorStops(bgImage);\n+      if (processedColorStops == null) {\n+        // If a color stop is invalid, return an empty array and do not apply any gradient. Same as web.\n+        return [];\n+      }\n+\n+      if (bgImage.type === 'linearGradient') {\n+        let direction: LinearGradientDirection =\n+          LINEAR_GRADIENT_DEFAULT_DIRECTION;\n+        const bgDirection =\n+          bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n+\n+        if (bgDirection != null) {\n+          if (LINEAR_GRADIENT_ANGLE_UNIT_REGEX.test(bgDirection)) {\n+            const parsedAngle = getAngleInDegrees(bgDirection);\n+            if (parsedAngle != null) {\n+              direction = {\n+                type: 'angle',\n+                value: parsedAngle,\n+              };\n+            } else {\n+              // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n+              return [];\n+            }\n+          } else if (LINEAR_GRADIENT_DIRECTION_REGEX.test(bgDirection)) {\n+            const parsedDirection = getDirectionForKeyword(bgDirection);\n+            if (parsedDirection != null) {\n+              direction = parsedDirection;\n+            } else {\n+              // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n+              return [];\n+            }\n           } else {\n-            // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n-            return [];\n-          }\n-        } else {\n-          const processedColor = processColor(colorStop.color);\n-          if (processedColor == null) {\n-            // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n+            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n             return [];\n           }\n-          if (positions != null && positions.length > 0) {\n-            for (const position of positions) {\n-              if (\n-                typeof position === 'number' ||\n-                (typeof position === 'string' && position.endsWith('%'))\n-              ) {\n-                processedColorStops.push({\n-                  color: processedColor,\n-                  position,\n-                });\n-              } else {\n-                // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n-                return [];\n-              }\n-            }\n+        }\n+\n+        result = result.concat({\n+          type: 'linearGradient',\n+          direction,\n+          colorStops: processedColorStops,\n+        });\n+      } else if (bgImage.type === 'radialGradient') {\n+        let shape: RadialGradientShape = DEFAULT_RADIAL_SHAPE;\n+        let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n+        let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n+\n+        if (bgImage.shape != null) {\n+          if (bgImage.shape === 'circle' || bgImage.shape === 'ellipse') {\n+            shape = bgImage.shape;\n           } else {\n-            processedColorStops.push({\n-              color: processedColor,\n-              position: null,\n-            });\n+            // If the shape is invalid, return an empty array and do not apply any gradient. Same as web.\n+            return [];\n           }\n         }\n-      }\n \n-      let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n-      const bgDirection =\n-        bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n-\n-      if (bgDirection != null) {\n-        if (ANGLE_UNIT_REGEX.test(bgDirection)) {\n-          const parsedAngle = getAngleInDegrees(bgDirection);\n-          if (parsedAngle != null) {\n-            direction = {\n-              type: 'angle',\n-              value: parsedAngle,\n+        if (bgImage.size != null) {\n+          if (\n+            typeof bgImage.size === 'string' &&\n+            (bgImage.size === 'closest-side' ||\n+              bgImage.size === 'closest-corner' ||\n+              bgImage.size === 'farthest-side' ||\n+              bgImage.size === 'farthest-corner')\n+          ) {\n+            size = bgImage.size;\n+          } else if (\n+            typeof bgImage.size === 'object' &&\n+            bgImage.size.x != null &&\n+            bgImage.size.y != null\n+          ) {\n+            size = {\n+              x: bgImage.size.x,\n+              y: bgImage.size.y,\n             };\n           } else {\n-            // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n+            // If the size is invalid, return an empty array and do not apply any gradient. Same as web.\n             return [];\n           }\n-        } else if (DIRECTION_KEYWORD_REGEX.test(bgDirection)) {\n-          const parsedDirection = getDirectionForKeyword(bgDirection);\n-          if (parsedDirection != null) {\n-            direction = parsedDirection;\n+        }\n+\n+        if (bgImage.position != null) {\n+          position = bgImage.position;\n+        }\n+\n+        result = result.concat({\n+          type: 'radialGradient',\n+          shape,\n+          size,\n+          position,\n+          colorStops: processedColorStops,\n+        });\n+      }\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+function processColorStops(bgImage: BackgroundImageValue): $ReadOnlyArray<{\n+  color: ColorStopColor,\n+  position: ColorStopPosition,\n+}> | null {\n+  const processedColorStops: Array<{\n+    color: ColorStopColor,\n+    position: ColorStopPosition,\n+  }> = [];\n+\n+  for (let index = 0; index < bgImage.colorStops.length; index++) {\n+    const colorStop = bgImage.colorStops[index];\n+    const positions = colorStop.positions;\n+    // Color transition hint syntax (red, 20%, blue)\n+    if (\n+      colorStop.color == null &&\n+      Array.isArray(positions) &&\n+      positions.length === 1\n+    ) {\n+      const position = positions[0];\n+      if (\n+        typeof position === 'number' ||\n+        (typeof position === 'string' && position.endsWith('%'))\n+      ) {\n+        processedColorStops.push({\n+          color: null,\n+          position,\n+        });\n+      } else {\n+        // If a position is invalid, return null and do not apply gradient. Same as web.\n+        return null;\n+      }\n+    } else {\n+      const processedColor = processColor(colorStop.color);\n+      if (processedColor == null) {\n+        // If a color is invalid, return null and do not apply gradient. Same as web.\n+        return null;\n+      }\n+      if (positions != null && positions.length > 0) {\n+        for (const position of positions) {\n+          if (\n+            typeof position === 'number' ||\n+            (typeof position === 'string' && position.endsWith('%'))\n+          ) {\n+            processedColorStops.push({\n+              color: processedColor,\n+              position,\n+            });\n           } else {\n-            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n-            return [];\n+            // If a position is invalid, return null and do not apply gradient. Same as web.\n+            return null;\n           }\n-        } else {\n-          // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n-          return [];\n         }\n+      } else {\n+        processedColorStops.push({\n+          color: processedColor,\n+          position: null,\n+        });\n       }\n-\n-      result = result.concat({\n-        type: 'linearGradient',\n-        direction,\n-        colorStops: processedColorStops,\n-      });\n     }\n   }\n \n-  return result;\n+  return processedColorStops;\n }\n \n-function parseCSSLinearGradient(\n+function parseBackgroundImageCSSString(\n   cssString: string,\n-): $ReadOnlyArray<ParsedGradientValue> {\n+): $ReadOnlyArray<ParsedBackgroundImageValue> {\n   const gradients = [];\n   let match;\n+  // matches one or more linear-gradient or radial-gradient functions in CSS\n+  const gradientRegex =\n+    /(linear|radial)-gradient\\s*\\(((?:\\([^)]*\\)|[^()])*)\\)/gi;\n \n-  // matches one or more linear-gradient functions in CSS\n-  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n-\n-  while ((match = linearGradientRegex.exec(cssString))) {\n-    const gradientContent = match[1];\n-    const parts = gradientContent.split(',');\n-    let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n-    const trimmedDirection = parts[0].trim().toLowerCase();\n-\n-    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n-      const parsedAngle = getAngleInDegrees(trimmedDirection);\n-      if (parsedAngle != null) {\n-        direction = {\n-          type: 'angle',\n-          value: parsedAngle,\n-        };\n-        parts.shift();\n-      } else {\n-        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n-        return [];\n+  while ((match = gradientRegex.exec(cssString))) {\n+    const [, type, gradientContent] = match;\n+    const isRadial = type.toLowerCase() === 'radial';\n+\n+    const gradient = isRadial\n+      ? parseRadialGradientCSSString(gradientContent)\n+      : parseLinearGradientCSSString(gradientContent);\n+\n+    if (gradient != null) {\n+      gradients.push(gradient);\n+    }\n+  }\n+\n+  return gradients;\n+}\n+\n+function parseRadialGradientCSSString(\n+  gradientContent: string,\n+): RadialGradientBackgroundImage | null {\n+  let shape = DEFAULT_RADIAL_SHAPE;\n+  let size: RadialGradientSize = DEFAULT_RADIAL_SIZE;\n+  let position: RadialGradientPosition = {...DEFAULT_RADIAL_POSITION};\n+\n+  // split the content by commas, but not if inside parentheses (for color values)\n+  const parts = gradientContent.split(/,(?![^(]*\\))/);\n+  // first part may contain shape, size, and position\n+  // [ <radial-shape> || <radial-size> ]? [ at <position> ]?\n+  const firstPartStr = parts[0].trim();\n+  const remainingParts = [...parts];\n+  let hasShapeSizeOrPositionString = false;\n+  let hasExplicitSingleSize = false;\n+  let hasExplicitShape = false;\n+  const firstPartTokens = firstPartStr.split(/\\s+/);\n+\n+  while (firstPartTokens.length > 0) {",
        "comment_created_at": "2025-03-27T17:56:24+00:00",
        "comment_author": "intergalacticspacehighway",
        "comment_body": "`firstPartTokens` could be shape, size and positions e.g. `radial-gradient(circle 100px at top left, red, green)`. Here, `circle 100px at top left` is the `firstPartTokens`. If none of these then they could be color stops. e.g. `radial-gradient(red, green)`. I added a comment, maybe that could do the job? But let me know!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2015000204",
    "pr_number": 50268,
    "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
    "created_at": "2025-03-26T21:07:42+00:00",
    "commented_code": "'use strict';\n \n import type {ProcessedColorValue} from './processColor';\n-import type {GradientValue} from './StyleSheetTypes';\n-\n+import type {BackgroundImageValue} from './StyleSheetTypes';",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2015000204",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50268,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "2015000204",
        "commented_code": "@@ -11,23 +11,24 @@\n 'use strict';\n \n import type {ProcessedColorValue} from './processColor';\n-import type {GradientValue} from './StyleSheetTypes';\n-\n+import type {BackgroundImageValue} from './StyleSheetTypes';",
        "comment_created_at": "2025-03-26T21:07:42+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "This file is starting to do a lot of things \ud83d\ude05. Any way we could split the structure to more distinct files/functions for e.g. linear gradient vs radial gradient vs url vs layer list?\r\n\r\nNote that on Android, we added some checks for UIManagerType to only allow some new features when using Fabric. This is to avoid confusing parity gaps between Android and iOS (where iOS Paper has separate impl we are not touching), but it's also to let us delete all the ViewConfig processors for new features, once the native parsing stack (which will be Fabric only) is rolled out.",
        "pr_file_module": null
      },
      {
        "comment_id": "2020349462",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50268,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "2015000204",
        "commented_code": "@@ -11,23 +11,24 @@\n 'use strict';\n \n import type {ProcessedColorValue} from './processColor';\n-import type {GradientValue} from './StyleSheetTypes';\n-\n+import type {BackgroundImageValue} from './StyleSheetTypes';",
        "comment_created_at": "2025-03-31T02:38:38+00:00",
        "comment_author": "intergalacticspacehighway",
        "comment_body": "> Any way we could split the structure\r\n\r\nyes, how about we add a directory `StyleSheet/BackgroundImage` and create files like `linearGradient`, `radialGradient`, `types` and `utils` inside of it. I wanted to do that but kept it like this to keep it consistent with other files. \ud83d\ude05 \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1966838813",
    "pr_number": 49614,
    "pr_file": "scripts/releases/prebuild/index.js",
    "created_at": "2025-02-23T17:16:24+00:00",
    "commented_code": "+/**\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ *\n+ * @flow\n+ * @format\n+ * @oncall react_native\n+ */\n+\n+const {buildDepenencies} = require('./build');\n+const {createFramework} = require('./compose-framework');\n+const {dependencies, platforms} = require('./configuration');\n+const {cleanFolder} = require('./folders');\n+const {setupDependencies} = require('./setupDependencies');\n+const {createSwiftPackageFile} = require('./swift-package');\n+const path = require('path');\n+const yargs = require('yargs');\n+\n+require('../../babel-register').registerForScript();\n+\n+const THIRD_PARTY_PATH = 'packages/react-native/third-party';\n+const BUILD_DESTINATION = '.build';\n+\n+const SCHEME = 'ReactNativeDependencies';\n+\n+const cli = yargs\n+  .usage(\n+    'This script prepares iOS prebuilds for React Native. It downloads the dependencies, prepare them, builds them and creates the XCFrameworks.' +\n+      'Calling the script with no options will build all the dependencies for all the slices and configurations.',\n+  )\n+  .option('setup', {\n+    alias: 's',\n+    type: 'boolean',\n+    describe: 'Download and setup dependencies',\n+  })\n+  .option('swiftpackage', {\n+    alias: 'w',\n+    type: 'boolean',\n+    describe: 'Creates the Package.swift file',\n+  })\n+  .option('build', {\n+    alias: 'b',\n+    type: 'boolean',\n+    describe: 'Build dependencies/platforms',\n+  })\n+  .option('compose', {\n+    alias: 'c',\n+    type: 'boolean',\n+    describe: 'Compose xcframework from built dependencies',\n+  })\n+  .option('platforms', {\n+    alias: 'p',\n+    type: 'array',\n+    default: platforms,\n+    describe: 'Specify one or more platforms to build for',\n+  })\n+  .option('dependencies', {\n+    alias: 'd',\n+    type: 'array',\n+    default: dependencies.map(d => d.name),\n+    describe: 'Specify one or more dependencies',\n+  })\n+  .help();\n+\n+const arrayLike = (value /*: Array<any> */) /*: Array<any> */ =>\n+  Array.isArray(value) ? value : [value];\n+\n+/**\n+ * Main entry point\n+ */\n+async function main() {\n+  const argv = await cli.argv;\n+\n+  // Verify that the platforms argument is valid\n+  const invalidPlatforms = arrayLike(argv.platforms).filter(",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1966838813",
        "repo_full_name": "facebook/react-native",
        "pr_number": 49614,
        "pr_file": "scripts/releases/prebuild/index.js",
        "discussion_id": "1966838813",
        "commented_code": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ *\n+ * @flow\n+ * @format\n+ * @oncall react_native\n+ */\n+\n+const {buildDepenencies} = require('./build');\n+const {createFramework} = require('./compose-framework');\n+const {dependencies, platforms} = require('./configuration');\n+const {cleanFolder} = require('./folders');\n+const {setupDependencies} = require('./setupDependencies');\n+const {createSwiftPackageFile} = require('./swift-package');\n+const path = require('path');\n+const yargs = require('yargs');\n+\n+require('../../babel-register').registerForScript();\n+\n+const THIRD_PARTY_PATH = 'packages/react-native/third-party';\n+const BUILD_DESTINATION = '.build';\n+\n+const SCHEME = 'ReactNativeDependencies';\n+\n+const cli = yargs\n+  .usage(\n+    'This script prepares iOS prebuilds for React Native. It downloads the dependencies, prepare them, builds them and creates the XCFrameworks.' +\n+      'Calling the script with no options will build all the dependencies for all the slices and configurations.',\n+  )\n+  .option('setup', {\n+    alias: 's',\n+    type: 'boolean',\n+    describe: 'Download and setup dependencies',\n+  })\n+  .option('swiftpackage', {\n+    alias: 'w',\n+    type: 'boolean',\n+    describe: 'Creates the Package.swift file',\n+  })\n+  .option('build', {\n+    alias: 'b',\n+    type: 'boolean',\n+    describe: 'Build dependencies/platforms',\n+  })\n+  .option('compose', {\n+    alias: 'c',\n+    type: 'boolean',\n+    describe: 'Compose xcframework from built dependencies',\n+  })\n+  .option('platforms', {\n+    alias: 'p',\n+    type: 'array',\n+    default: platforms,\n+    describe: 'Specify one or more platforms to build for',\n+  })\n+  .option('dependencies', {\n+    alias: 'd',\n+    type: 'array',\n+    default: dependencies.map(d => d.name),\n+    describe: 'Specify one or more dependencies',\n+  })\n+  .help();\n+\n+const arrayLike = (value /*: Array<any> */) /*: Array<any> */ =>\n+  Array.isArray(value) ? value : [value];\n+\n+/**\n+ * Main entry point\n+ */\n+async function main() {\n+  const argv = await cli.argv;\n+\n+  // Verify that the platforms argument is valid\n+  const invalidPlatforms = arrayLike(argv.platforms).filter(",
        "comment_created_at": "2025-02-23T17:16:24+00:00",
        "comment_author": "cipolleschi",
        "comment_body": "I'd rather extract all the validation in a separate function. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1967314286",
        "repo_full_name": "facebook/react-native",
        "pr_number": 49614,
        "pr_file": "scripts/releases/prebuild/index.js",
        "discussion_id": "1966838813",
        "commented_code": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ *\n+ * @flow\n+ * @format\n+ * @oncall react_native\n+ */\n+\n+const {buildDepenencies} = require('./build');\n+const {createFramework} = require('./compose-framework');\n+const {dependencies, platforms} = require('./configuration');\n+const {cleanFolder} = require('./folders');\n+const {setupDependencies} = require('./setupDependencies');\n+const {createSwiftPackageFile} = require('./swift-package');\n+const path = require('path');\n+const yargs = require('yargs');\n+\n+require('../../babel-register').registerForScript();\n+\n+const THIRD_PARTY_PATH = 'packages/react-native/third-party';\n+const BUILD_DESTINATION = '.build';\n+\n+const SCHEME = 'ReactNativeDependencies';\n+\n+const cli = yargs\n+  .usage(\n+    'This script prepares iOS prebuilds for React Native. It downloads the dependencies, prepare them, builds them and creates the XCFrameworks.' +\n+      'Calling the script with no options will build all the dependencies for all the slices and configurations.',\n+  )\n+  .option('setup', {\n+    alias: 's',\n+    type: 'boolean',\n+    describe: 'Download and setup dependencies',\n+  })\n+  .option('swiftpackage', {\n+    alias: 'w',\n+    type: 'boolean',\n+    describe: 'Creates the Package.swift file',\n+  })\n+  .option('build', {\n+    alias: 'b',\n+    type: 'boolean',\n+    describe: 'Build dependencies/platforms',\n+  })\n+  .option('compose', {\n+    alias: 'c',\n+    type: 'boolean',\n+    describe: 'Compose xcframework from built dependencies',\n+  })\n+  .option('platforms', {\n+    alias: 'p',\n+    type: 'array',\n+    default: platforms,\n+    describe: 'Specify one or more platforms to build for',\n+  })\n+  .option('dependencies', {\n+    alias: 'd',\n+    type: 'array',\n+    default: dependencies.map(d => d.name),\n+    describe: 'Specify one or more dependencies',\n+  })\n+  .help();\n+\n+const arrayLike = (value /*: Array<any> */) /*: Array<any> */ =>\n+  Array.isArray(value) ? value : [value];\n+\n+/**\n+ * Main entry point\n+ */\n+async function main() {\n+  const argv = await cli.argv;\n+\n+  // Verify that the platforms argument is valid\n+  const invalidPlatforms = arrayLike(argv.platforms).filter(",
        "comment_created_at": "2025-02-24T09:53:57+00:00",
        "comment_author": "chrfalch",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "646202935",
    "pr_number": 31632,
    "pr_file": "Libraries/Components/Pressable/Pressable.js",
    "created_at": "2021-06-06T23:32:34+00:00",
    "commented_code": "? {...props.accessibilityState, disabled}\n       : props.accessibilityState;\n \n-  const restPropsWithDefaults: React.ElementConfig<typeof View> = {\n+  let restPropsWithDefaults: React.ElementConfig<typeof View> = {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "646202935",
        "repo_full_name": "facebook/react-native",
        "pr_number": 31632,
        "pr_file": "Libraries/Components/Pressable/Pressable.js",
        "discussion_id": "646202935",
        "commented_code": "@@ -180,15 +180,28 @@ function Pressable(props: Props, forwardedRef): React.Node {\n       ? {...props.accessibilityState, disabled}\n       : props.accessibilityState;\n \n-  const restPropsWithDefaults: React.ElementConfig<typeof View> = {\n+  let restPropsWithDefaults: React.ElementConfig<typeof View> = {",
        "comment_created_at": "2021-06-06T23:32:34+00:00",
        "comment_author": "yungsters",
        "comment_body": "Can you keep this as `const` and instead create a new `const` local variable that contains the ripple props (or remains undefined) that you spread in here?\n\nIt's a minor code reorganization, but it helps keep the code slightly more readable in the long-term the more you can have `const` variables that \u2014 as you read the declaration \u2014 you know will not be reassigned later.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "646203427",
    "pr_number": 31632,
    "pr_file": "Libraries/Components/Pressable/useAndroidRippleForView.js",
    "created_at": "2021-06-06T23:36:41+00:00",
    "commented_code": "'Unexpected color given for Ripple color',\n       );\n \n+      let viewProps = {};",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "646203427",
        "repo_full_name": "facebook/react-native",
        "pr_number": 31632,
        "pr_file": "Libraries/Components/Pressable/useAndroidRippleForView.js",
        "discussion_id": "646203427",
        "commented_code": "@@ -58,16 +61,23 @@ export default function useAndroidRippleForView(\n         'Unexpected color given for Ripple color',\n       );\n \n+      let viewProps = {};",
        "comment_created_at": "2021-06-06T23:36:41+00:00",
        "comment_author": "yungsters",
        "comment_body": "Similar feedback as above about making this `const`. You can also instantiating this after `backgroundValue`:\n\n```\nconst viewProps = foreground === true\n  ? {nativeForegroundAndroid: backgroundValue}\n  : {nativeBackgroundAndroid: backgroundValue};\n```\n\nCould even return this to line 80 as a ternary property initialization in the return statement.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2018758183",
    "pr_number": 50043,
    "pr_file": "packages/react-native/Libraries/Blob/__tests__/URL-test.js",
    "created_at": "2025-03-28T14:10:26+00:00",
    "commented_code": "expect(url.pathname).toBe('/docs/path');\n     expect(url.port).toBe('8080');\n     expect(url.search).toBe('?query=testQuery&key=value');\n+\n+    // Test searchParams\n+    const searchParams = url.searchParams;\n+    expect(searchParams.get('query')).toBe('testQuery');\n+    expect(searchParams.get('key')).toBe('value');\n+\n+    const paramsFromString = new URLSearchParams(\n+      '?param1=value1+value2&param2=value%20with%20space',\n+    );",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "2018758183",
        "repo_full_name": "facebook/react-native",
        "pr_number": 50043,
        "pr_file": "packages/react-native/Libraries/Blob/__tests__/URL-test.js",
        "discussion_id": "2018758183",
        "commented_code": "@@ -52,5 +54,75 @@ describe('URL', function () {\n     expect(url.pathname).toBe('/docs/path');\n     expect(url.port).toBe('8080');\n     expect(url.search).toBe('?query=testQuery&key=value');\n+\n+    // Test searchParams\n+    const searchParams = url.searchParams;\n+    expect(searchParams.get('query')).toBe('testQuery');\n+    expect(searchParams.get('key')).toBe('value');\n+\n+    const paramsFromString = new URLSearchParams(\n+      '?param1=value1+value2&param2=value%20with%20space',\n+    );",
        "comment_created_at": "2025-03-28T14:10:26+00:00",
        "comment_author": "huntie",
        "comment_body": "nit: Let's be slightly more self-documenting with these cases\r\n\r\n```suggestion\r\n    const paramsFromString = new URLSearchParams(\r\n      [\r\n        '?param1=value1',\r\n        '&param2=value2%20with%20spaces',\r\n        '&param3=value3+with+spaces+legacy',\r\n      ].join('')\r\n    );\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1831695328",
    "pr_number": 47452,
    "pr_file": "packages/react-native-codegen/src/parsers/typescript/parser.js",
    "created_at": "2024-11-06T20:53:47+00:00",
    "commented_code": "parseEnumMembersType(typeAnnotation: $FlowFixMe): NativeModuleEnumMemberType {\n     const enumInitializer = typeAnnotation.members[0]?.initializer;\n-    const enumMembersType: ?NativeModuleEnumMemberType =\n-      !enumInitializer || enumInitializer.type === 'StringLiteral'\n-        ? 'StringTypeAnnotation'\n-        : enumInitializer.type === 'NumericLiteral'\n-        ? 'NumberTypeAnnotation'\n-        : null;\n+    const enumInitializerType = enumInitializer?.type;\n+\n+    let enumMembersType: ?NativeModuleEnumMemberType = null;\n+\n+    switch (enumInitializerType) {\n+      case undefined:",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1831695328",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47452,
        "pr_file": "packages/react-native-codegen/src/parsers/typescript/parser.js",
        "discussion_id": "1831695328",
        "commented_code": "@@ -183,12 +183,27 @@ class TypeScriptParser implements Parser {\n \n   parseEnumMembersType(typeAnnotation: $FlowFixMe): NativeModuleEnumMemberType {\n     const enumInitializer = typeAnnotation.members[0]?.initializer;\n-    const enumMembersType: ?NativeModuleEnumMemberType =\n-      !enumInitializer || enumInitializer.type === 'StringLiteral'\n-        ? 'StringTypeAnnotation'\n-        : enumInitializer.type === 'NumericLiteral'\n-        ? 'NumberTypeAnnotation'\n-        : null;\n+    const enumInitializerType = enumInitializer?.type;\n+\n+    let enumMembersType: ?NativeModuleEnumMemberType = null;\n+\n+    switch (enumInitializerType) {\n+      case undefined:",
        "comment_created_at": "2024-11-06T20:53:47+00:00",
        "comment_author": "elicwhite",
        "comment_body": "Can you leave a comment explaining this case, because it's very very strange to see `undefined` as a case in a switch. It's almost worth pulling it out into its own if statement above the switch.",
        "pr_file_module": null
      },
      {
        "comment_id": "1838096225",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47452,
        "pr_file": "packages/react-native-codegen/src/parsers/typescript/parser.js",
        "discussion_id": "1831695328",
        "commented_code": "@@ -183,12 +183,27 @@ class TypeScriptParser implements Parser {\n \n   parseEnumMembersType(typeAnnotation: $FlowFixMe): NativeModuleEnumMemberType {\n     const enumInitializer = typeAnnotation.members[0]?.initializer;\n-    const enumMembersType: ?NativeModuleEnumMemberType =\n-      !enumInitializer || enumInitializer.type === 'StringLiteral'\n-        ? 'StringTypeAnnotation'\n-        : enumInitializer.type === 'NumericLiteral'\n-        ? 'NumberTypeAnnotation'\n-        : null;\n+    const enumInitializerType = enumInitializer?.type;\n+\n+    let enumMembersType: ?NativeModuleEnumMemberType = null;\n+\n+    switch (enumInitializerType) {\n+      case undefined:",
        "comment_created_at": "2024-11-12T13:24:32+00:00",
        "comment_author": "okwasniewski",
        "comment_body": "Fixed, I've extracted this to a separate if statement above the switch",
        "pr_file_module": null
      }
    ]
  }
]