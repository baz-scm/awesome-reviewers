[
  {
    "discussion_id": "1829700416",
    "pr_number": 47426,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/fresco/ReactOkHttpNetworkFetcher.kt",
    "created_at": "2024-11-05T16:55:21+00:00",
    "commented_code": "ImageCacheControl.RELOAD -> {\n           cacheControlBuilder.noCache()\n         }\n+        ImageCacheControl.FORCE_CACHE -> {\n+          cacheControlBuilder\n+            .onlyIfCached()\n+            .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)\n+        }",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1829700416",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47426,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/fresco/ReactOkHttpNetworkFetcher.kt",
        "discussion_id": "1829700416",
        "commented_code": "@@ -43,6 +44,11 @@ internal class ReactOkHttpNetworkFetcher(private val okHttpClient: OkHttpClient)\n         ImageCacheControl.RELOAD -> {\n           cacheControlBuilder.noCache()\n         }\n+        ImageCacheControl.FORCE_CACHE -> {\n+          cacheControlBuilder\n+            .onlyIfCached()\n+            .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)\n+        }",
        "comment_created_at": "2024-11-05T16:55:21+00:00",
        "comment_author": "mateoguzmana",
        "comment_body": "Ref: [okhttp/src/main/kotlin/okhttp3/internal/-CacheControlCommon.kt](https://github.com/square/okhttp/blob/f1e6d01aea30844f0ddc7394208ec13d59d5e6f8/okhttp/src/main/kotlin/okhttp3/internal/-CacheControlCommon.kt#L61-L65)",
        "pr_file_module": null
      },
      {
        "comment_id": "1833116881",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47426,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/fresco/ReactOkHttpNetworkFetcher.kt",
        "discussion_id": "1829700416",
        "commented_code": "@@ -43,6 +44,11 @@ internal class ReactOkHttpNetworkFetcher(private val okHttpClient: OkHttpClient)\n         ImageCacheControl.RELOAD -> {\n           cacheControlBuilder.noCache()\n         }\n+        ImageCacheControl.FORCE_CACHE -> {\n+          cacheControlBuilder\n+            .onlyIfCached()\n+            .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)\n+        }",
        "comment_created_at": "2024-11-07T17:42:05+00:00",
        "comment_author": "Abbondanzo",
        "comment_body": "Is `onlyIfCached` the correct add here? Per MDN:\r\n>The client indicates that an already-cached response should be returned. If a cache has a stored response, even a stale one, it will be returned. If no cached response is available, a [504 Gateway Timeout](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504) response will be returned.",
        "pr_file_module": null
      },
      {
        "comment_id": "1834862683",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47426,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/fresco/ReactOkHttpNetworkFetcher.kt",
        "discussion_id": "1829700416",
        "commented_code": "@@ -43,6 +44,11 @@ internal class ReactOkHttpNetworkFetcher(private val okHttpClient: OkHttpClient)\n         ImageCacheControl.RELOAD -> {\n           cacheControlBuilder.noCache()\n         }\n+        ImageCacheControl.FORCE_CACHE -> {\n+          cacheControlBuilder\n+            .onlyIfCached()\n+            .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)\n+        }",
        "comment_created_at": "2024-11-08T18:10:01+00:00",
        "comment_author": "mateoguzmana",
        "comment_body": "You are right, I was overlooking it when using the reference from `OkHttp3` as that utility has `onlyIfCache` set, but for our logic it doesn't apply. I've removed it in dca3d3a08f9604aa3a6286e43ef03371a3e56732",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1825345183",
    "pr_number": 47348,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
    "created_at": "2024-11-01T01:55:37+00:00",
    "commented_code": "imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1825345183",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47348,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
        "discussion_id": "1825345183",
        "commented_code": "@@ -439,6 +444,38 @@ public class ReactImageView(\n       imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)",
        "comment_created_at": "2024-11-01T01:55:37+00:00",
        "comment_author": "Abbondanzo",
        "comment_body": "Fresco contains three caches that we'll want to check:\r\n1. Bitmap cache\r\n2. Encoded memory cache\r\n3. Disk cache\r\n\r\nCache keys are determined by the full image request so it's best to build the image request here first before asking Fresco if it has that image ready to serve.",
        "pr_file_module": null
      },
      {
        "comment_id": "1826079453",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47348,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
        "discussion_id": "1825345183",
        "commented_code": "@@ -439,6 +444,38 @@ public class ReactImageView(\n       imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)",
        "comment_created_at": "2024-11-01T17:06:56+00:00",
        "comment_author": "mateoguzmana",
        "comment_body": "Nice observation, I've addressed that here to cover the three cache levels 0e36839d89f4f5f3fa8184ad3bb1d44a066250ee \u2013\u00a0added a small example of how it looks in the PR description",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1825348978",
    "pr_number": 47348,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
    "created_at": "2024-11-01T02:03:36+00:00",
    "commented_code": "imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)\n+\n+      dataSource.subscribe(object : BaseDataSubscriber<Boolean>() {\n+        override fun onNewResultImpl(dataSource: DataSource<Boolean>) {\n+          if (!dataSource.isFinished()) return\n+\n+          val isInCache: Boolean = dataSource.getResult() ?: false\n+\n+          if (isInCache) {\n+            setupImageRequest(uri, cacheControl, postprocessor, resizeOptions)",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1825348978",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47348,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
        "discussion_id": "1825348978",
        "commented_code": "@@ -439,6 +444,38 @@ public class ReactImageView(\n       imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)\n+\n+      dataSource.subscribe(object : BaseDataSubscriber<Boolean>() {\n+        override fun onNewResultImpl(dataSource: DataSource<Boolean>) {\n+          if (!dataSource.isFinished()) return\n+\n+          val isInCache: Boolean = dataSource.getResult() ?: false\n+\n+          if (isInCache) {\n+            setupImageRequest(uri, cacheControl, postprocessor, resizeOptions)",
        "comment_created_at": "2024-11-01T02:03:36+00:00",
        "comment_author": "Abbondanzo",
        "comment_body": "If the image is not available in any of our caches, this should dispatch a load fail (i.e. `eventDispatcher.dispatchEvent(createErrorEvent(...))`. \r\n\r\nAlternatively, we could take advantage of Fresco's lowest permitted request levels (per https://frescolib.org/docs/image-requests.html). A lowest permitted level of `DISK_CACHE` should circumvent the need to check caches altogether. It's important to confirm that `onError` is called in JS for cases where the image is not available from cache.",
        "pr_file_module": null
      },
      {
        "comment_id": "1826078038",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47348,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
        "discussion_id": "1825348978",
        "commented_code": "@@ -439,6 +444,38 @@ public class ReactImageView(\n       imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)\n+\n+      dataSource.subscribe(object : BaseDataSubscriber<Boolean>() {\n+        override fun onNewResultImpl(dataSource: DataSource<Boolean>) {\n+          if (!dataSource.isFinished()) return\n+\n+          val isInCache: Boolean = dataSource.getResult() ?: false\n+\n+          if (isInCache) {\n+            setupImageRequest(uri, cacheControl, postprocessor, resizeOptions)",
        "comment_created_at": "2024-11-01T17:05:30+00:00",
        "comment_author": "mateoguzmana",
        "comment_body": "Thanks a lot for your quick review @Abbondanzo, I've added error handling in d01ccb83a3e20cb80241fd80840c0541f60d087c.\r\n\r\nThe alternative with the request levels seems interesting and could be a good optimisation. Will look further into it",
        "pr_file_module": null
      },
      {
        "comment_id": "1826318779",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47348,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
        "discussion_id": "1825348978",
        "commented_code": "@@ -439,6 +444,38 @@ public class ReactImageView(\n       imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)\n+\n+      dataSource.subscribe(object : BaseDataSubscriber<Boolean>() {\n+        override fun onNewResultImpl(dataSource: DataSource<Boolean>) {\n+          if (!dataSource.isFinished()) return\n+\n+          val isInCache: Boolean = dataSource.getResult() ?: false\n+\n+          if (isInCache) {\n+            setupImageRequest(uri, cacheControl, postprocessor, resizeOptions)",
        "comment_created_at": "2024-11-01T21:38:40+00:00",
        "comment_author": "Abbondanzo",
        "comment_body": "Brought this change over to the Fresco team and they recommended just taking advantage of the request level for a few reasons:\r\n-  Under the hood, Fresco propagates the error from [here](https://github.com/facebook/fresco/blob/8e79c29fab817fe0cf789f46c7ca722416727482/imagepipeline/src/main/java/com/facebook/imagepipeline/producers/DecodeProducer.kt#L126) so we don't have to implement any special error dispatching. This error will automatically get passed into our downloadListener's `onFailure` method so there's no need to add custom branching logic for dispatching errors\r\n- Reading from bitmap and encoded memory caches is synchronous and would yield the image result much earlier on. This would best be done before asking the disk cache\r\n- Even though this change reads disk cache from a different thread, it doesn't create the image request until the disk cache read finishes. We should send the image request as soon as possible to let Fresco decide what decoder to read from\r\n- This change reads from disk cache twice, first to detect if the image is available and then to actually decode it. We can avoid the second round trip by letting Fresco read from cache and perform decoding all at once\r\n\r\nThis should be as easy as tacking on `setLowestPermittedRequestLevel` like so:\r\n```kotlin\r\n val requestLevel =\r\n        if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) RequestLevel.DISK_CACHE\r\n        else RequestLevel.FULL_FETCH\r\n\r\nval imageRequestBuilder =\r\n        ImageRequestBuilder.newBuilderWithSource(uri)\r\n            // ... other setters ...\r\n            .setLowestPermittedRequestLevel(requestLevel)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1826605086",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47348,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/image/ReactImageView.kt",
        "discussion_id": "1825348978",
        "commented_code": "@@ -439,6 +444,38 @@ public class ReactImageView(\n       imagePipeline.evictFromCache(uri)\n     }\n \n+    if (cacheControl == ImageCacheControl.ONLY_IF_CACHED) {\n+      val imagePipeline = Fresco.getImagePipeline()\n+      val dataSource = imagePipeline.isInDiskCache(uri)\n+\n+      dataSource.subscribe(object : BaseDataSubscriber<Boolean>() {\n+        override fun onNewResultImpl(dataSource: DataSource<Boolean>) {\n+          if (!dataSource.isFinished()) return\n+\n+          val isInCache: Boolean = dataSource.getResult() ?: false\n+\n+          if (isInCache) {\n+            setupImageRequest(uri, cacheControl, postprocessor, resizeOptions)",
        "comment_created_at": "2024-11-02T17:21:53+00:00",
        "comment_author": "mateoguzmana",
        "comment_body": "Thanks a lot again for the detailed feedback and bringing it to the team. I've implemented this approach and it looks way simpler now!\r\n\r\nAlso retested and it gives the same loading output as with the other approach, and also the errors are being propagated to JS when there is no image available in our caches.",
        "pr_file_module": null
      }
    ]
  }
]