[
  {
    "discussion_id": "779112578",
    "pr_number": 29466,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactHorizontalScrollView.java",
    "created_at": "2022-01-05T20:22:02+00:00",
    "commented_code": "updateStateOnScroll(getScrollX(), getScrollY());\n   }\n \n+  /**\n+   * Called when a mContentView's layout has changed. Fixes the scroll position depending on\n+   * maintainVisibleContentPosition\n+   */\n+  @Override\n+  public void onLayoutChange(\n+      View v,\n+      int left,\n+      int top,\n+      int right,\n+      int bottom,\n+      int oldLeft,\n+      int oldTop,\n+      int oldRight,\n+      int oldBottom) {\n+    if (mContentView == null) {\n+      return;\n+    }\n+\n+    if (this.mMaintainVisibleContentPositionData != null) {\n+      scrollMaintainVisibleContentPosition();\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a scroll. Finds the first\n+   * completely visible view in the ScrollView and stores it for later use.\n+   */\n+  private void computeFirstVisibleItemForMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+    int minIdx = maintainVisibleContentPositionData.minIndexForVisible;\n+\n+    ReactViewGroup contentView = (ReactViewGroup) getChildAt(0);\n+    if (contentView == null) return;\n+\n+    for (int i = minIdx; i < contentView.getChildCount(); i++) {\n+      // Find the first entirely visible view. This must be done after we update the content offset\n+      // or it will tend to grab rows that were made visible by the shift in position\n+      View child = contentView.getChildAt(i);\n+      if (child.getX() >= currentScrollX || i == contentView.getChildCount() - 1) {\n+        firstVisibleViewForMaintainVisibleContentPosition = new WeakReference<>(child);\n+        Rect frame = new Rect();\n+        child.getHitRect(frame);\n+        prevFirstVisibleFrameForMaintainVisibleContentPosition = frame;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a layout change. Detects if the\n+   * layout change impacts the scroll position and corrects it if needed.\n+   */\n+  private void scrollMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        this.mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+\n+    View firstVisibleView =\n+        firstVisibleViewForMaintainVisibleContentPosition != null\n+            ? firstVisibleViewForMaintainVisibleContentPosition.get()\n+            : null;\n+    if (firstVisibleView == null) return;\n+    Rect prevFirstVisibleFrame = this.prevFirstVisibleFrameForMaintainVisibleContentPosition;\n+    if (prevFirstVisibleFrame == null) return;\n+\n+    Rect newFrame = new Rect();\n+    firstVisibleView.getHitRect(newFrame);\n+    int deltaX = newFrame.left - prevFirstVisibleFrame.left;\n+\n+    if (Math.abs(deltaX) > 1) {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "779112578",
        "repo_full_name": "facebook/react-native",
        "pr_number": 29466,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactHorizontalScrollView.java",
        "discussion_id": "779112578",
        "commented_code": "@@ -1239,6 +1288,97 @@ private void updateStateOnScroll() {\n     updateStateOnScroll(getScrollX(), getScrollY());\n   }\n \n+  /**\n+   * Called when a mContentView's layout has changed. Fixes the scroll position depending on\n+   * maintainVisibleContentPosition\n+   */\n+  @Override\n+  public void onLayoutChange(\n+      View v,\n+      int left,\n+      int top,\n+      int right,\n+      int bottom,\n+      int oldLeft,\n+      int oldTop,\n+      int oldRight,\n+      int oldBottom) {\n+    if (mContentView == null) {\n+      return;\n+    }\n+\n+    if (this.mMaintainVisibleContentPositionData != null) {\n+      scrollMaintainVisibleContentPosition();\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a scroll. Finds the first\n+   * completely visible view in the ScrollView and stores it for later use.\n+   */\n+  private void computeFirstVisibleItemForMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+    int minIdx = maintainVisibleContentPositionData.minIndexForVisible;\n+\n+    ReactViewGroup contentView = (ReactViewGroup) getChildAt(0);\n+    if (contentView == null) return;\n+\n+    for (int i = minIdx; i < contentView.getChildCount(); i++) {\n+      // Find the first entirely visible view. This must be done after we update the content offset\n+      // or it will tend to grab rows that were made visible by the shift in position\n+      View child = contentView.getChildAt(i);\n+      if (child.getX() >= currentScrollX || i == contentView.getChildCount() - 1) {\n+        firstVisibleViewForMaintainVisibleContentPosition = new WeakReference<>(child);\n+        Rect frame = new Rect();\n+        child.getHitRect(frame);\n+        prevFirstVisibleFrameForMaintainVisibleContentPosition = frame;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a layout change. Detects if the\n+   * layout change impacts the scroll position and corrects it if needed.\n+   */\n+  private void scrollMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        this.mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+\n+    View firstVisibleView =\n+        firstVisibleViewForMaintainVisibleContentPosition != null\n+            ? firstVisibleViewForMaintainVisibleContentPosition.get()\n+            : null;\n+    if (firstVisibleView == null) return;\n+    Rect prevFirstVisibleFrame = this.prevFirstVisibleFrameForMaintainVisibleContentPosition;\n+    if (prevFirstVisibleFrame == null) return;\n+\n+    Rect newFrame = new Rect();\n+    firstVisibleView.getHitRect(newFrame);\n+    int deltaX = newFrame.left - prevFirstVisibleFrame.left;\n+\n+    if (Math.abs(deltaX) > 1) {",
        "comment_created_at": "2022-01-05T20:22:02+00:00",
        "comment_author": "yungsters",
        "comment_body": "It may be better to store this value using a constant.\r\n\r\n```suggestion\r\n    if (Math.abs(deltaX) > SCROLL_DELTA_EPSILON) {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1811929434",
    "pr_number": 47122,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/text/TextLayoutManager.java",
    "created_at": "2024-10-23T06:01:49+00:00",
    "commented_code": "== LayoutDirection.RTL;\n   }\n \n-  private static Layout.Alignment getTextAlignment(MapBuffer attributedString, Spannable spanned) {\n+  @Nullable\n+  private static String getTextAlignmentAttr(MapBuffer attributedString) {\n     // TODO: Don't read AS_KEY_FRAGMENTS, which may be expensive, and is not present when using\n-    // cached Spannable\n     if (!attributedString.contains(AS_KEY_FRAGMENTS)) {\n-      return Layout.Alignment.ALIGN_NORMAL;\n+      return null;\n     }\n \n+    MapBuffer fragments = attributedString.getMapBuffer(AS_KEY_FRAGMENTS);\n+    if (fragments.getCount() != 0) {\n+      MapBuffer fragment = fragments.getMapBuffer(0);\n+      MapBuffer textAttributes = fragment.getMapBuffer(FR_KEY_TEXT_ATTRIBUTES);\n+\n+      if (textAttributes.contains(TextAttributeProps.TA_KEY_ALIGNMENT)) {\n+        return textAttributes.getString(TextAttributeProps.TA_KEY_ALIGNMENT);\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+\n+  private static int getTextJustificationMode(@Nullable String alignmentAttr) {\n+    int justificationMode = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? 0 : Layout.JUSTIFICATION_MODE_NONE;\n+\n+    if (alignmentAttr != null && alignmentAttr.equals(\"justified\")) {\n+      justificationMode = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? 1 : Layout.JUSTIFICATION_MODE_INTER_WORD;",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1811929434",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47122,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/text/TextLayoutManager.java",
        "discussion_id": "1811929434",
        "commented_code": "@@ -146,13 +146,42 @@ public static boolean isRTL(MapBuffer attributedString) {\n         == LayoutDirection.RTL;\n   }\n \n-  private static Layout.Alignment getTextAlignment(MapBuffer attributedString, Spannable spanned) {\n+  @Nullable\n+  private static String getTextAlignmentAttr(MapBuffer attributedString) {\n     // TODO: Don't read AS_KEY_FRAGMENTS, which may be expensive, and is not present when using\n-    // cached Spannable\n     if (!attributedString.contains(AS_KEY_FRAGMENTS)) {\n-      return Layout.Alignment.ALIGN_NORMAL;\n+      return null;\n     }\n \n+    MapBuffer fragments = attributedString.getMapBuffer(AS_KEY_FRAGMENTS);\n+    if (fragments.getCount() != 0) {\n+      MapBuffer fragment = fragments.getMapBuffer(0);\n+      MapBuffer textAttributes = fragment.getMapBuffer(FR_KEY_TEXT_ATTRIBUTES);\n+\n+      if (textAttributes.contains(TextAttributeProps.TA_KEY_ALIGNMENT)) {\n+        return textAttributes.getString(TextAttributeProps.TA_KEY_ALIGNMENT);\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+\n+  private static int getTextJustificationMode(@Nullable String alignmentAttr) {\n+    int justificationMode = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? 0 : Layout.JUSTIFICATION_MODE_NONE;\n+\n+    if (alignmentAttr != null && alignmentAttr.equals(\"justified\")) {\n+      justificationMode = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? 1 : Layout.JUSTIFICATION_MODE_INTER_WORD;",
        "comment_created_at": "2024-10-23T06:01:49+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "What's the significance of `1` here? We will never use this value on the old versions, right? Maybe we should just early return something invalid like `-1`;",
        "pr_file_module": null
      },
      {
        "comment_id": "1814466295",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47122,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/text/TextLayoutManager.java",
        "discussion_id": "1811929434",
        "commented_code": "@@ -146,13 +146,42 @@ public static boolean isRTL(MapBuffer attributedString) {\n         == LayoutDirection.RTL;\n   }\n \n-  private static Layout.Alignment getTextAlignment(MapBuffer attributedString, Spannable spanned) {\n+  @Nullable\n+  private static String getTextAlignmentAttr(MapBuffer attributedString) {\n     // TODO: Don't read AS_KEY_FRAGMENTS, which may be expensive, and is not present when using\n-    // cached Spannable\n     if (!attributedString.contains(AS_KEY_FRAGMENTS)) {\n-      return Layout.Alignment.ALIGN_NORMAL;\n+      return null;\n     }\n \n+    MapBuffer fragments = attributedString.getMapBuffer(AS_KEY_FRAGMENTS);\n+    if (fragments.getCount() != 0) {\n+      MapBuffer fragment = fragments.getMapBuffer(0);\n+      MapBuffer textAttributes = fragment.getMapBuffer(FR_KEY_TEXT_ATTRIBUTES);\n+\n+      if (textAttributes.contains(TextAttributeProps.TA_KEY_ALIGNMENT)) {\n+        return textAttributes.getString(TextAttributeProps.TA_KEY_ALIGNMENT);\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+\n+  private static int getTextJustificationMode(@Nullable String alignmentAttr) {\n+    int justificationMode = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? 0 : Layout.JUSTIFICATION_MODE_NONE;\n+\n+    if (alignmentAttr != null && alignmentAttr.equals(\"justified\")) {\n+      justificationMode = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? 1 : Layout.JUSTIFICATION_MODE_INTER_WORD;",
        "comment_created_at": "2024-10-24T07:57:59+00:00",
        "comment_author": "coado",
        "comment_body": "Yeah I somehow missed that it won't be even used \ud83d\ude05",
        "pr_file_module": null
      }
    ]
  }
]