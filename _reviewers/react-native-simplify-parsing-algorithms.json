[
  {
    "discussion_id": "1655390125",
    "pr_number": 45055,
    "pr_file": "packages/react-native/Libraries/Blob/URL.js",
    "created_at": "2024-06-26T19:03:15+00:00",
    "commented_code": "}\n }\n \n-function validateBaseUrl(url: string) {\n-  // from this MIT-licensed gist: https://gist.github.com/dperini/729294\n-  return /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)*(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/.test(\n-    url,\n-  );\n-}\n-\n-export class URL {\n-  _url: string;\n-  _searchParamsInstance: ?URLSearchParams = null;\n-\n-  static createObjectURL(blob: Blob): string {\n-    if (BLOB_URL_PREFIX === null) {\n-      throw new Error('Cannot create URL for blob!');\n-    }\n-    return `${BLOB_URL_PREFIX}${blob.data.blobId}?offset=${blob.data.offset}&size=${blob.size}`;\n-  }\n-\n-  static revokeObjectURL(url: string) {\n-    // Do nothing.\n-  }\n-\n-  // $FlowFixMe[missing-local-annot]\n-  constructor(url: string, base: string | URL) {\n-    let baseUrl = null;\n-    if (!base || validateBaseUrl(url)) {\n-      this._url = url;\n-      if (!this._url.endsWith('/')) {\n-        this._url += '/';\n-      }\n-    } else {\n-      if (typeof base === 'string') {\n-        baseUrl = base;\n-        if (!validateBaseUrl(baseUrl)) {\n-          throw new TypeError(`Invalid base URL: ${baseUrl}`);\n-        }\n-      } else {\n-        baseUrl = base.toString();\n-      }\n-      if (baseUrl.endsWith('/')) {\n-        baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n-      }\n-      if (!url.startsWith('/')) {\n-        url = `/${url}`;\n-      }\n-      if (baseUrl.endsWith(url)) {\n-        url = '';\n-      }\n-      this._url = `${baseUrl}${url}`;\n-    }\n-  }\n+function resolveRelativeUrl(relative: string, base: string): string {\n+  const baseUrl = new URL(base);\n \n-  get hash(): string {\n-    throw new Error('URL.hash is not implemented');\n+  if (relative.startsWith('http://') || relative.startsWith('https://')) {\n+    return relative;\n   }\n \n-  get host(): string {\n-    throw new Error('URL.host is not implemented');\n+  if (relative.startsWith('/')) {\n+    return baseUrl.protocol + '//' + baseUrl.host + encodeURI(relative);\n   }\n \n-  get hostname(): string {\n-    throw new Error('URL.hostname is not implemented');\n-  }\n+  const baseParts = baseUrl.pathname.split('/');\n+  const relativeParts = relative.split('/');\n \n-  get href(): string {\n-    return this.toString();\n-  }\n+  baseParts.pop();\n \n-  get origin(): string {\n-    throw new Error('URL.origin is not implemented');\n+  for (const part of relativeParts) {\n+    if (part === '.') continue;\n+    if (part === '..') baseParts.pop();\n+    else baseParts.push(part);\n   }\n \n-  get password(): string {\n-    throw new Error('URL.password is not implemented');\n-  }\n+  return baseUrl.protocol + '//' + baseUrl.host + baseParts.join('/');\n+}\n \n-  get pathname(): string {\n-    throw new Error('URL.pathname not implemented');\n-  }\n+export class URL {\n+  protocol: string;\n+  username: string;\n+  password: string;\n+  host: string;\n+  hostname: string;\n+  port: string;\n+  pathname: string;\n+  search: string;\n+  hash: string;\n+  origin: string;\n+  _url: string;\n+  _searchParamsInstance: ?URLSearchParams = null;\n \n-  get port(): string {\n-    throw new Error('URL.port is not implemented');\n-  }\n+  constructor(url: string, base?: string | URL) {\n+    if (base) {\n+      if (typeof base === 'string') {\n+        base = new URL(base);\n+      }\n+      url = resolveRelativeUrl(url, base.href);\n+    } else {\n+      url = encodeURI(url);\n+    }\n \n-  get protocol(): string {\n-    throw new Error('URL.protocol is not implemented');\n-  }\n+    const parser = this.parseURL(url);\n+    this._url = url;\n+    this.protocol = parser.protocol;\n+    this.username = parser.username;\n+    this.password = parser.password;\n+    this.host = parser.host;\n+    this.hostname = parser.hostname;\n+    this.port = parser.port;\n+    this.pathname = parser.pathname;\n+    this.search = parser.search;\n+    this.hash = parser.hash;\n+    this.origin = parser.origin;\n+\n+    if (this.pathname === '/' && !this.href.endsWith('/')) {\n+      this._url += '/';\n+    }\n \n-  get search(): string {\n-    throw new Error('URL.search is not implemented');\n+    this._searchParamsInstance = new URLSearchParams(this.search);\n+  }\n+\n+  parseURL(url: string): {\n+    protocol: string,\n+    username: string,\n+    password: string,\n+    host: string,\n+    hostname: string,\n+    port: string,\n+    pathname: string,\n+    search: string,\n+    hash: string,\n+    origin: string,\n+  } {\n+    const urlPattern =",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1655390125",
        "repo_full_name": "facebook/react-native",
        "pr_number": 45055,
        "pr_file": "packages/react-native/Libraries/Blob/URL.js",
        "discussion_id": "1655390125",
        "commented_code": "@@ -114,96 +114,104 @@ export class URLSearchParams {\n   }\n }\n \n-function validateBaseUrl(url: string) {\n-  // from this MIT-licensed gist: https://gist.github.com/dperini/729294\n-  return /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)*(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/.test(\n-    url,\n-  );\n-}\n-\n-export class URL {\n-  _url: string;\n-  _searchParamsInstance: ?URLSearchParams = null;\n-\n-  static createObjectURL(blob: Blob): string {\n-    if (BLOB_URL_PREFIX === null) {\n-      throw new Error('Cannot create URL for blob!');\n-    }\n-    return `${BLOB_URL_PREFIX}${blob.data.blobId}?offset=${blob.data.offset}&size=${blob.size}`;\n-  }\n-\n-  static revokeObjectURL(url: string) {\n-    // Do nothing.\n-  }\n-\n-  // $FlowFixMe[missing-local-annot]\n-  constructor(url: string, base: string | URL) {\n-    let baseUrl = null;\n-    if (!base || validateBaseUrl(url)) {\n-      this._url = url;\n-      if (!this._url.endsWith('/')) {\n-        this._url += '/';\n-      }\n-    } else {\n-      if (typeof base === 'string') {\n-        baseUrl = base;\n-        if (!validateBaseUrl(baseUrl)) {\n-          throw new TypeError(`Invalid base URL: ${baseUrl}`);\n-        }\n-      } else {\n-        baseUrl = base.toString();\n-      }\n-      if (baseUrl.endsWith('/')) {\n-        baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n-      }\n-      if (!url.startsWith('/')) {\n-        url = `/${url}`;\n-      }\n-      if (baseUrl.endsWith(url)) {\n-        url = '';\n-      }\n-      this._url = `${baseUrl}${url}`;\n-    }\n-  }\n+function resolveRelativeUrl(relative: string, base: string): string {\n+  const baseUrl = new URL(base);\n \n-  get hash(): string {\n-    throw new Error('URL.hash is not implemented');\n+  if (relative.startsWith('http://') || relative.startsWith('https://')) {\n+    return relative;\n   }\n \n-  get host(): string {\n-    throw new Error('URL.host is not implemented');\n+  if (relative.startsWith('/')) {\n+    return baseUrl.protocol + '//' + baseUrl.host + encodeURI(relative);\n   }\n \n-  get hostname(): string {\n-    throw new Error('URL.hostname is not implemented');\n-  }\n+  const baseParts = baseUrl.pathname.split('/');\n+  const relativeParts = relative.split('/');\n \n-  get href(): string {\n-    return this.toString();\n-  }\n+  baseParts.pop();\n \n-  get origin(): string {\n-    throw new Error('URL.origin is not implemented');\n+  for (const part of relativeParts) {\n+    if (part === '.') continue;\n+    if (part === '..') baseParts.pop();\n+    else baseParts.push(part);\n   }\n \n-  get password(): string {\n-    throw new Error('URL.password is not implemented');\n-  }\n+  return baseUrl.protocol + '//' + baseUrl.host + baseParts.join('/');\n+}\n \n-  get pathname(): string {\n-    throw new Error('URL.pathname not implemented');\n-  }\n+export class URL {\n+  protocol: string;\n+  username: string;\n+  password: string;\n+  host: string;\n+  hostname: string;\n+  port: string;\n+  pathname: string;\n+  search: string;\n+  hash: string;\n+  origin: string;\n+  _url: string;\n+  _searchParamsInstance: ?URLSearchParams = null;\n \n-  get port(): string {\n-    throw new Error('URL.port is not implemented');\n-  }\n+  constructor(url: string, base?: string | URL) {\n+    if (base) {\n+      if (typeof base === 'string') {\n+        base = new URL(base);\n+      }\n+      url = resolveRelativeUrl(url, base.href);\n+    } else {\n+      url = encodeURI(url);\n+    }\n \n-  get protocol(): string {\n-    throw new Error('URL.protocol is not implemented');\n-  }\n+    const parser = this.parseURL(url);\n+    this._url = url;\n+    this.protocol = parser.protocol;\n+    this.username = parser.username;\n+    this.password = parser.password;\n+    this.host = parser.host;\n+    this.hostname = parser.hostname;\n+    this.port = parser.port;\n+    this.pathname = parser.pathname;\n+    this.search = parser.search;\n+    this.hash = parser.hash;\n+    this.origin = parser.origin;\n+\n+    if (this.pathname === '/' && !this.href.endsWith('/')) {\n+      this._url += '/';\n+    }\n \n-  get search(): string {\n-    throw new Error('URL.search is not implemented');\n+    this._searchParamsInstance = new URLSearchParams(this.search);\n+  }\n+\n+  parseURL(url: string): {\n+    protocol: string,\n+    username: string,\n+    password: string,\n+    host: string,\n+    hostname: string,\n+    port: string,\n+    pathname: string,\n+    search: string,\n+    hash: string,\n+    origin: string,\n+  } {\n+    const urlPattern =",
        "comment_created_at": "2024-06-26T19:03:15+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "Where does this regex come from?\r\n\r\nAt a quick glance, I know we should be more permissive in allowing schemes that are not just http. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1656934258",
        "repo_full_name": "facebook/react-native",
        "pr_number": 45055,
        "pr_file": "packages/react-native/Libraries/Blob/URL.js",
        "discussion_id": "1655390125",
        "commented_code": "@@ -114,96 +114,104 @@ export class URLSearchParams {\n   }\n }\n \n-function validateBaseUrl(url: string) {\n-  // from this MIT-licensed gist: https://gist.github.com/dperini/729294\n-  return /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)*(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/.test(\n-    url,\n-  );\n-}\n-\n-export class URL {\n-  _url: string;\n-  _searchParamsInstance: ?URLSearchParams = null;\n-\n-  static createObjectURL(blob: Blob): string {\n-    if (BLOB_URL_PREFIX === null) {\n-      throw new Error('Cannot create URL for blob!');\n-    }\n-    return `${BLOB_URL_PREFIX}${blob.data.blobId}?offset=${blob.data.offset}&size=${blob.size}`;\n-  }\n-\n-  static revokeObjectURL(url: string) {\n-    // Do nothing.\n-  }\n-\n-  // $FlowFixMe[missing-local-annot]\n-  constructor(url: string, base: string | URL) {\n-    let baseUrl = null;\n-    if (!base || validateBaseUrl(url)) {\n-      this._url = url;\n-      if (!this._url.endsWith('/')) {\n-        this._url += '/';\n-      }\n-    } else {\n-      if (typeof base === 'string') {\n-        baseUrl = base;\n-        if (!validateBaseUrl(baseUrl)) {\n-          throw new TypeError(`Invalid base URL: ${baseUrl}`);\n-        }\n-      } else {\n-        baseUrl = base.toString();\n-      }\n-      if (baseUrl.endsWith('/')) {\n-        baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n-      }\n-      if (!url.startsWith('/')) {\n-        url = `/${url}`;\n-      }\n-      if (baseUrl.endsWith(url)) {\n-        url = '';\n-      }\n-      this._url = `${baseUrl}${url}`;\n-    }\n-  }\n+function resolveRelativeUrl(relative: string, base: string): string {\n+  const baseUrl = new URL(base);\n \n-  get hash(): string {\n-    throw new Error('URL.hash is not implemented');\n+  if (relative.startsWith('http://') || relative.startsWith('https://')) {\n+    return relative;\n   }\n \n-  get host(): string {\n-    throw new Error('URL.host is not implemented');\n+  if (relative.startsWith('/')) {\n+    return baseUrl.protocol + '//' + baseUrl.host + encodeURI(relative);\n   }\n \n-  get hostname(): string {\n-    throw new Error('URL.hostname is not implemented');\n-  }\n+  const baseParts = baseUrl.pathname.split('/');\n+  const relativeParts = relative.split('/');\n \n-  get href(): string {\n-    return this.toString();\n-  }\n+  baseParts.pop();\n \n-  get origin(): string {\n-    throw new Error('URL.origin is not implemented');\n+  for (const part of relativeParts) {\n+    if (part === '.') continue;\n+    if (part === '..') baseParts.pop();\n+    else baseParts.push(part);\n   }\n \n-  get password(): string {\n-    throw new Error('URL.password is not implemented');\n-  }\n+  return baseUrl.protocol + '//' + baseUrl.host + baseParts.join('/');\n+}\n \n-  get pathname(): string {\n-    throw new Error('URL.pathname not implemented');\n-  }\n+export class URL {\n+  protocol: string;\n+  username: string;\n+  password: string;\n+  host: string;\n+  hostname: string;\n+  port: string;\n+  pathname: string;\n+  search: string;\n+  hash: string;\n+  origin: string;\n+  _url: string;\n+  _searchParamsInstance: ?URLSearchParams = null;\n \n-  get port(): string {\n-    throw new Error('URL.port is not implemented');\n-  }\n+  constructor(url: string, base?: string | URL) {\n+    if (base) {\n+      if (typeof base === 'string') {\n+        base = new URL(base);\n+      }\n+      url = resolveRelativeUrl(url, base.href);\n+    } else {\n+      url = encodeURI(url);\n+    }\n \n-  get protocol(): string {\n-    throw new Error('URL.protocol is not implemented');\n-  }\n+    const parser = this.parseURL(url);\n+    this._url = url;\n+    this.protocol = parser.protocol;\n+    this.username = parser.username;\n+    this.password = parser.password;\n+    this.host = parser.host;\n+    this.hostname = parser.hostname;\n+    this.port = parser.port;\n+    this.pathname = parser.pathname;\n+    this.search = parser.search;\n+    this.hash = parser.hash;\n+    this.origin = parser.origin;\n+\n+    if (this.pathname === '/' && !this.href.endsWith('/')) {\n+      this._url += '/';\n+    }\n \n-  get search(): string {\n-    throw new Error('URL.search is not implemented');\n+    this._searchParamsInstance = new URLSearchParams(this.search);\n+  }\n+\n+  parseURL(url: string): {\n+    protocol: string,\n+    username: string,\n+    password: string,\n+    host: string,\n+    hostname: string,\n+    port: string,\n+    pathname: string,\n+    search: string,\n+    hash: string,\n+    origin: string,\n+  } {\n+    const urlPattern =",
        "comment_created_at": "2024-06-27T10:59:18+00:00",
        "comment_author": "sossost",
        "comment_body": "@NickGerleman Oh I almost missed that, I'm not good enough to see that, thanks for the advice.",
        "pr_file_module": null
      },
      {
        "comment_id": "1657883540",
        "repo_full_name": "facebook/react-native",
        "pr_number": 45055,
        "pr_file": "packages/react-native/Libraries/Blob/URL.js",
        "discussion_id": "1655390125",
        "commented_code": "@@ -114,96 +114,104 @@ export class URLSearchParams {\n   }\n }\n \n-function validateBaseUrl(url: string) {\n-  // from this MIT-licensed gist: https://gist.github.com/dperini/729294\n-  return /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)*(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/.test(\n-    url,\n-  );\n-}\n-\n-export class URL {\n-  _url: string;\n-  _searchParamsInstance: ?URLSearchParams = null;\n-\n-  static createObjectURL(blob: Blob): string {\n-    if (BLOB_URL_PREFIX === null) {\n-      throw new Error('Cannot create URL for blob!');\n-    }\n-    return `${BLOB_URL_PREFIX}${blob.data.blobId}?offset=${blob.data.offset}&size=${blob.size}`;\n-  }\n-\n-  static revokeObjectURL(url: string) {\n-    // Do nothing.\n-  }\n-\n-  // $FlowFixMe[missing-local-annot]\n-  constructor(url: string, base: string | URL) {\n-    let baseUrl = null;\n-    if (!base || validateBaseUrl(url)) {\n-      this._url = url;\n-      if (!this._url.endsWith('/')) {\n-        this._url += '/';\n-      }\n-    } else {\n-      if (typeof base === 'string') {\n-        baseUrl = base;\n-        if (!validateBaseUrl(baseUrl)) {\n-          throw new TypeError(`Invalid base URL: ${baseUrl}`);\n-        }\n-      } else {\n-        baseUrl = base.toString();\n-      }\n-      if (baseUrl.endsWith('/')) {\n-        baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n-      }\n-      if (!url.startsWith('/')) {\n-        url = `/${url}`;\n-      }\n-      if (baseUrl.endsWith(url)) {\n-        url = '';\n-      }\n-      this._url = `${baseUrl}${url}`;\n-    }\n-  }\n+function resolveRelativeUrl(relative: string, base: string): string {\n+  const baseUrl = new URL(base);\n \n-  get hash(): string {\n-    throw new Error('URL.hash is not implemented');\n+  if (relative.startsWith('http://') || relative.startsWith('https://')) {\n+    return relative;\n   }\n \n-  get host(): string {\n-    throw new Error('URL.host is not implemented');\n+  if (relative.startsWith('/')) {\n+    return baseUrl.protocol + '//' + baseUrl.host + encodeURI(relative);\n   }\n \n-  get hostname(): string {\n-    throw new Error('URL.hostname is not implemented');\n-  }\n+  const baseParts = baseUrl.pathname.split('/');\n+  const relativeParts = relative.split('/');\n \n-  get href(): string {\n-    return this.toString();\n-  }\n+  baseParts.pop();\n \n-  get origin(): string {\n-    throw new Error('URL.origin is not implemented');\n+  for (const part of relativeParts) {\n+    if (part === '.') continue;\n+    if (part === '..') baseParts.pop();\n+    else baseParts.push(part);\n   }\n \n-  get password(): string {\n-    throw new Error('URL.password is not implemented');\n-  }\n+  return baseUrl.protocol + '//' + baseUrl.host + baseParts.join('/');\n+}\n \n-  get pathname(): string {\n-    throw new Error('URL.pathname not implemented');\n-  }\n+export class URL {\n+  protocol: string;\n+  username: string;\n+  password: string;\n+  host: string;\n+  hostname: string;\n+  port: string;\n+  pathname: string;\n+  search: string;\n+  hash: string;\n+  origin: string;\n+  _url: string;\n+  _searchParamsInstance: ?URLSearchParams = null;\n \n-  get port(): string {\n-    throw new Error('URL.port is not implemented');\n-  }\n+  constructor(url: string, base?: string | URL) {\n+    if (base) {\n+      if (typeof base === 'string') {\n+        base = new URL(base);\n+      }\n+      url = resolveRelativeUrl(url, base.href);\n+    } else {\n+      url = encodeURI(url);\n+    }\n \n-  get protocol(): string {\n-    throw new Error('URL.protocol is not implemented');\n-  }\n+    const parser = this.parseURL(url);\n+    this._url = url;\n+    this.protocol = parser.protocol;\n+    this.username = parser.username;\n+    this.password = parser.password;\n+    this.host = parser.host;\n+    this.hostname = parser.hostname;\n+    this.port = parser.port;\n+    this.pathname = parser.pathname;\n+    this.search = parser.search;\n+    this.hash = parser.hash;\n+    this.origin = parser.origin;\n+\n+    if (this.pathname === '/' && !this.href.endsWith('/')) {\n+      this._url += '/';\n+    }\n \n-  get search(): string {\n-    throw new Error('URL.search is not implemented');\n+    this._searchParamsInstance = new URLSearchParams(this.search);\n+  }\n+\n+  parseURL(url: string): {\n+    protocol: string,\n+    username: string,\n+    password: string,\n+    host: string,\n+    hostname: string,\n+    port: string,\n+    pathname: string,\n+    search: string,\n+    hash: string,\n+    origin: string,\n+  } {\n+    const urlPattern =",
        "comment_created_at": "2024-06-27T22:32:03+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "Are we getting this regex from a source, or trying to derive it?",
        "pr_file_module": null
      },
      {
        "comment_id": "1659766219",
        "repo_full_name": "facebook/react-native",
        "pr_number": 45055,
        "pr_file": "packages/react-native/Libraries/Blob/URL.js",
        "discussion_id": "1655390125",
        "commented_code": "@@ -114,96 +114,104 @@ export class URLSearchParams {\n   }\n }\n \n-function validateBaseUrl(url: string) {\n-  // from this MIT-licensed gist: https://gist.github.com/dperini/729294\n-  return /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)*(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/.test(\n-    url,\n-  );\n-}\n-\n-export class URL {\n-  _url: string;\n-  _searchParamsInstance: ?URLSearchParams = null;\n-\n-  static createObjectURL(blob: Blob): string {\n-    if (BLOB_URL_PREFIX === null) {\n-      throw new Error('Cannot create URL for blob!');\n-    }\n-    return `${BLOB_URL_PREFIX}${blob.data.blobId}?offset=${blob.data.offset}&size=${blob.size}`;\n-  }\n-\n-  static revokeObjectURL(url: string) {\n-    // Do nothing.\n-  }\n-\n-  // $FlowFixMe[missing-local-annot]\n-  constructor(url: string, base: string | URL) {\n-    let baseUrl = null;\n-    if (!base || validateBaseUrl(url)) {\n-      this._url = url;\n-      if (!this._url.endsWith('/')) {\n-        this._url += '/';\n-      }\n-    } else {\n-      if (typeof base === 'string') {\n-        baseUrl = base;\n-        if (!validateBaseUrl(baseUrl)) {\n-          throw new TypeError(`Invalid base URL: ${baseUrl}`);\n-        }\n-      } else {\n-        baseUrl = base.toString();\n-      }\n-      if (baseUrl.endsWith('/')) {\n-        baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n-      }\n-      if (!url.startsWith('/')) {\n-        url = `/${url}`;\n-      }\n-      if (baseUrl.endsWith(url)) {\n-        url = '';\n-      }\n-      this._url = `${baseUrl}${url}`;\n-    }\n-  }\n+function resolveRelativeUrl(relative: string, base: string): string {\n+  const baseUrl = new URL(base);\n \n-  get hash(): string {\n-    throw new Error('URL.hash is not implemented');\n+  if (relative.startsWith('http://') || relative.startsWith('https://')) {\n+    return relative;\n   }\n \n-  get host(): string {\n-    throw new Error('URL.host is not implemented');\n+  if (relative.startsWith('/')) {\n+    return baseUrl.protocol + '//' + baseUrl.host + encodeURI(relative);\n   }\n \n-  get hostname(): string {\n-    throw new Error('URL.hostname is not implemented');\n-  }\n+  const baseParts = baseUrl.pathname.split('/');\n+  const relativeParts = relative.split('/');\n \n-  get href(): string {\n-    return this.toString();\n-  }\n+  baseParts.pop();\n \n-  get origin(): string {\n-    throw new Error('URL.origin is not implemented');\n+  for (const part of relativeParts) {\n+    if (part === '.') continue;\n+    if (part === '..') baseParts.pop();\n+    else baseParts.push(part);\n   }\n \n-  get password(): string {\n-    throw new Error('URL.password is not implemented');\n-  }\n+  return baseUrl.protocol + '//' + baseUrl.host + baseParts.join('/');\n+}\n \n-  get pathname(): string {\n-    throw new Error('URL.pathname not implemented');\n-  }\n+export class URL {\n+  protocol: string;\n+  username: string;\n+  password: string;\n+  host: string;\n+  hostname: string;\n+  port: string;\n+  pathname: string;\n+  search: string;\n+  hash: string;\n+  origin: string;\n+  _url: string;\n+  _searchParamsInstance: ?URLSearchParams = null;\n \n-  get port(): string {\n-    throw new Error('URL.port is not implemented');\n-  }\n+  constructor(url: string, base?: string | URL) {\n+    if (base) {\n+      if (typeof base === 'string') {\n+        base = new URL(base);\n+      }\n+      url = resolveRelativeUrl(url, base.href);\n+    } else {\n+      url = encodeURI(url);\n+    }\n \n-  get protocol(): string {\n-    throw new Error('URL.protocol is not implemented');\n-  }\n+    const parser = this.parseURL(url);\n+    this._url = url;\n+    this.protocol = parser.protocol;\n+    this.username = parser.username;\n+    this.password = parser.password;\n+    this.host = parser.host;\n+    this.hostname = parser.hostname;\n+    this.port = parser.port;\n+    this.pathname = parser.pathname;\n+    this.search = parser.search;\n+    this.hash = parser.hash;\n+    this.origin = parser.origin;\n+\n+    if (this.pathname === '/' && !this.href.endsWith('/')) {\n+      this._url += '/';\n+    }\n \n-  get search(): string {\n-    throw new Error('URL.search is not implemented');\n+    this._searchParamsInstance = new URLSearchParams(this.search);\n+  }\n+\n+  parseURL(url: string): {\n+    protocol: string,\n+    username: string,\n+    password: string,\n+    host: string,\n+    hostname: string,\n+    port: string,\n+    pathname: string,\n+    search: string,\n+    hash: string,\n+    origin: string,\n+  } {\n+    const urlPattern =",
        "comment_created_at": "2024-06-29T11:14:39+00:00",
        "comment_author": "sossost",
        "comment_body": "@NickGerleman No, I didn't get this regex from a source. I derived it myself.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1821032473",
    "pr_number": 47003,
    "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
    "created_at": "2024-10-29T15:24:40+00:00",
    "commented_code": "}\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1821032473",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47003,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "1821032473",
        "commented_code": "@@ -76,37 +91,39 @@ export default function processBackgroundImage(\n         }\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {",
        "comment_created_at": "2024-10-29T15:24:40+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "nit: if the single keyword variants are directlty convertible to angles, that might make sense to simplify during parsing\r\n\r\nhttps://www.w3.org/TR/css-images-3/#linear-gradient-syntax",
        "pr_file_module": null
      },
      {
        "comment_id": "1824897157",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47003,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "1821032473",
        "commented_code": "@@ -76,37 +91,39 @@ export default function processBackgroundImage(\n         }\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {",
        "comment_created_at": "2024-10-31T17:37:52+00:00",
        "comment_author": "jorge-cab",
        "comment_body": "I thought about this too but it seems keywords like `to top left` (which means the angle should align with the view's corner) need information about the view which we can't do during parsing.\r\n\r\nWe could however preemptively parse `to top`, `to left` etc since those map to constant angle values. However naively I feel like we should avoid parsing in such a fragmented way",
        "pr_file_module": null
      },
      {
        "comment_id": "1826155432",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47003,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "1821032473",
        "commented_code": "@@ -76,37 +91,39 @@ export default function processBackgroundImage(\n         }\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {",
        "comment_created_at": "2024-11-01T18:21:50+00:00",
        "comment_author": "intergalacticspacehighway",
        "comment_body": "i also had same thoughts as @jorge-cab about parsing in fragmented way but i am down to re-using angles and passing only corner styles, will make the change, lmk if sounds good to you @jorge-cab. \r\ni was also thinking in the longer term that dimension-dependent styles like these could be part of layout nodes right before setting native view dimensions, lot of native styling logic could be moved there and code can be reused among platforms. e.g transform-origin, translate with %, gradients, also support for calc function etc. Is there an ongoing effort in that direction? i can also take a look, i know @NickGerleman is working on native CSS parser, but i haven't dug very deep into it yet.",
        "pr_file_module": null
      },
      {
        "comment_id": "1826281338",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47003,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "1821032473",
        "commented_code": "@@ -76,37 +91,39 @@ export default function processBackgroundImage(\n         }\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {",
        "comment_created_at": "2024-11-01T20:45:46+00:00",
        "comment_author": "intergalacticspacehighway",
        "comment_body": "Updated [here](https://github.com/facebook/react-native/pull/47003/commits/d308b7d501e7343a58f041e91d3f925e48a6efdb#diff-645b1d95fc4a2f92f0a8a2e695cd9b4c31ebc977adac0a38b39c46946f3fd530R227), loving it. It made it more concise and reusable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1821036631",
    "pr_number": 47003,
    "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
    "created_at": "2024-10-29T15:25:57+00:00",
    "commented_code": "}\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {\n+            type: 'direction',\n+            value: parsedDirection,",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1821036631",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47003,
        "pr_file": "packages/react-native/Libraries/StyleSheet/processBackgroundImage.js",
        "discussion_id": "1821036631",
        "commented_code": "@@ -76,37 +91,39 @@ export default function processBackgroundImage(\n         }\n       }\n \n-      let points: {\n-        start: ParsedGradientValue['start'],\n-        end: ParsedGradientValue['end'],\n-      } | null = null;\n-\n-      if (typeof bgImage.direction === 'undefined') {\n-        points = TO_BOTTOM_START_END_POINTS;\n-      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n-        const angle = parseAngle(bgImage.direction);\n-        if (angle != null) {\n-          points = calculateStartEndPointsFromAngle(angle);\n+      let orientation: LinearGradientOrientation = DEFAULT_ORIENTATION;\n+\n+      if (\n+        bgImage.direction != null &&\n+        ANGLE_UNIT_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedAngle = getAngleInDegrees(bgImage.direction);\n+        if (parsedAngle != null) {\n+          orientation = {\n+            type: 'angle',\n+            value: parsedAngle,\n+          };\n         }\n-      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n-        const processedPoints = calculateStartEndPointsFromDirection(\n-          bgImage.direction,\n-        );\n-        if (processedPoints != null) {\n-          points = processedPoints;\n+      } else if (\n+        bgImage.direction != null &&\n+        DIRECTION_REGEX.test(bgImage.direction)\n+      ) {\n+        const parsedDirection = getDirectionString(bgImage.direction);\n+        if (parsedDirection != null) {\n+          orientation = {\n+            type: 'direction',\n+            value: parsedDirection,",
        "comment_created_at": "2024-10-29T15:25:57+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "Apart from those that can be simplified to angles, we have four corners this could point to, so it might be simpler to pass one of four well known values to native for these.",
        "pr_file_module": null
      }
    ]
  }
]