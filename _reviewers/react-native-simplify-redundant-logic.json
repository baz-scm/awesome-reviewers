[
  {
    "discussion_id": "1937179451",
    "pr_number": 46884,
    "pr_file": "packages/react-native/React/Fabric/Mounting/ComponentViews/Text/RCTParagraphComponentView.mm",
    "created_at": "2025-01-31T12:34:31+00:00",
    "commented_code": "CAShapeLayer *_highlightLayer;\n }\n \n+- (CGRect)calculateCenteredFrameWithAttributedText:(NSAttributedString *)attributedText\n+                                             frame:(CGRect)frame {\n+  UIFont *font = [attributedText attribute:NSFontAttributeName atIndex:0 effectiveRange:NULL];\n+  if (!font) {\n+      font = [UIFont systemFontOfSize:14];\n+  }\n+\n+  NSParagraphStyle *paragraphStyle = [attributedText attribute:NSParagraphStyleAttributeName atIndex:0 effectiveRange:NULL];\n+  CGFloat lineHeight = font.lineHeight;\n+\n+  if (paragraphStyle && paragraphStyle.minimumLineHeight > 0) {\n+      lineHeight = paragraphStyle.minimumLineHeight;\n+  }\n+\n+  CGFloat ascent = font.ascender;\n+  CGFloat descent = fabs(font.descender);\n+  CGFloat textHeight = ascent + descent;\n+\n+  CGFloat verticalOffset = 0;\n+  // Adjust vertical offset to ensure text is vertically centered relative to the line height.\n+  // Positive offset when text height exceeds line height, negative when line height exceeds text height.\n+  if (textHeight > lineHeight) {\n+      CGFloat difference = textHeight - lineHeight;\n+      verticalOffset = difference / 2.0;\n+  } else if (textHeight < lineHeight) {\n+      CGFloat difference = lineHeight - textHeight;\n+      verticalOffset = -(difference / 2.0);\n+  }",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1937179451",
        "repo_full_name": "facebook/react-native",
        "pr_number": 46884,
        "pr_file": "packages/react-native/React/Fabric/Mounting/ComponentViews/Text/RCTParagraphComponentView.mm",
        "discussion_id": "1937179451",
        "commented_code": "@@ -326,6 +327,40 @@ @implementation RCTParagraphTextView {\n   CAShapeLayer *_highlightLayer;\n }\n \n+- (CGRect)calculateCenteredFrameWithAttributedText:(NSAttributedString *)attributedText\n+                                             frame:(CGRect)frame {\n+  UIFont *font = [attributedText attribute:NSFontAttributeName atIndex:0 effectiveRange:NULL];\n+  if (!font) {\n+      font = [UIFont systemFontOfSize:14];\n+  }\n+\n+  NSParagraphStyle *paragraphStyle = [attributedText attribute:NSParagraphStyleAttributeName atIndex:0 effectiveRange:NULL];\n+  CGFloat lineHeight = font.lineHeight;\n+\n+  if (paragraphStyle && paragraphStyle.minimumLineHeight > 0) {\n+      lineHeight = paragraphStyle.minimumLineHeight;\n+  }\n+\n+  CGFloat ascent = font.ascender;\n+  CGFloat descent = fabs(font.descender);\n+  CGFloat textHeight = ascent + descent;\n+\n+  CGFloat verticalOffset = 0;\n+  // Adjust vertical offset to ensure text is vertically centered relative to the line height.\n+  // Positive offset when text height exceeds line height, negative when line height exceeds text height.\n+  if (textHeight > lineHeight) {\n+      CGFloat difference = textHeight - lineHeight;\n+      verticalOffset = difference / 2.0;\n+  } else if (textHeight < lineHeight) {\n+      CGFloat difference = lineHeight - textHeight;\n+      verticalOffset = -(difference / 2.0);\n+  }",
        "comment_created_at": "2025-01-31T12:34:31+00:00",
        "comment_author": "cipolleschi",
        "comment_body": "@NickGerleman \r\n> nit: these checks are redundant, since one inverts both the subtraction order, and then inverts again for the difference.\r\n\r\n```suggestion\r\n  CGFloat difference = textHeight - lineHeight;\r\n  CGFloat verticalOffset = difference / 2.0;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1946434918",
    "pr_number": 49240,
    "pr_file": "packages/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTPullToRefreshViewComponentView.mm",
    "created_at": "2025-02-07T12:10:56+00:00",
    "commented_code": "@end\n \n @implementation RCTPullToRefreshViewComponentView {\n+  Props::Shared _initialProps;\n+  BOOL _isBeforeInitialLayout;",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1946434918",
        "repo_full_name": "facebook/react-native",
        "pr_number": 49240,
        "pr_file": "packages/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTPullToRefreshViewComponentView.mm",
        "discussion_id": "1946434918",
        "commented_code": "@@ -24,6 +24,8 @@ @interface RCTPullToRefreshViewComponentView () <RCTPullToRefreshViewViewProtoco\n @end\n \n @implementation RCTPullToRefreshViewComponentView {\n+  Props::Shared _initialProps;\n+  BOOL _isBeforeInitialLayout;",
        "comment_created_at": "2025-02-07T12:10:56+00:00",
        "comment_author": "cipolleschi",
        "comment_body": "instead of this prop... can't we just use the `_props` property and check whether it is initialized or not?",
        "pr_file_module": null
      },
      {
        "comment_id": "1958723198",
        "repo_full_name": "facebook/react-native",
        "pr_number": 49240,
        "pr_file": "packages/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTPullToRefreshViewComponentView.mm",
        "discussion_id": "1946434918",
        "commented_code": "@@ -24,6 +24,8 @@ @interface RCTPullToRefreshViewComponentView () <RCTPullToRefreshViewViewProtoco\n @end\n \n @implementation RCTPullToRefreshViewComponentView {\n+  Props::Shared _initialProps;\n+  BOOL _isBeforeInitialLayout;",
        "comment_created_at": "2025-02-17T19:50:40+00:00",
        "comment_author": "High5Apps",
        "comment_body": "Good catch- yes I'll remove `_initialProps` from my next revision in favor of just using `_props`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1956175487",
    "pr_number": 49371,
    "pr_file": "packages/react-native/Libraries/AppDelegate/RCTAppSetupUtils.mm",
    "created_at": "2025-02-14T13:46:23+00:00",
    "commented_code": "facebook::react::RuntimeSchedulerBinding::createAndInstallIfNeeded(runtime, runtimeScheduler);\n         }\n       }));\n+#elif USE_THIRD_PARTY_JSC != 1\n+  return std::make_unique<facebook::react::JSCExecutorFactory>(\n+     facebook::react::RCTJSIExecutorRuntimeInstaller([bridge, runtimeScheduler](facebook::jsi::Runtime &runtime) {\n+       if (!bridge) {\n+         return;\n+       }\n+       if (runtimeScheduler) {\n+         facebook::react::RuntimeSchedulerBinding::createAndInstallIfNeeded(runtime, runtimeScheduler);\n+       }\n+     }));\n+#else\n+  throw std::runtime_error(\"No JSExecutorFactory specified.\");\n+  return nullptr;\n+#endif // USE_HERMES",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1956175487",
        "repo_full_name": "facebook/react-native",
        "pr_number": 49371,
        "pr_file": "packages/react-native/Libraries/AppDelegate/RCTAppSetupUtils.mm",
        "discussion_id": "1956175487",
        "commented_code": "@@ -164,4 +174,18 @@ void RCTAppSetupPrepareApp(UIApplication *application, BOOL turboModuleEnabled)\n           facebook::react::RuntimeSchedulerBinding::createAndInstallIfNeeded(runtime, runtimeScheduler);\n         }\n       }));\n+#elif USE_THIRD_PARTY_JSC != 1\n+  return std::make_unique<facebook::react::JSCExecutorFactory>(\n+     facebook::react::RCTJSIExecutorRuntimeInstaller([bridge, runtimeScheduler](facebook::jsi::Runtime &runtime) {\n+       if (!bridge) {\n+         return;\n+       }\n+       if (runtimeScheduler) {\n+         facebook::react::RuntimeSchedulerBinding::createAndInstallIfNeeded(runtime, runtimeScheduler);\n+       }\n+     }));\n+#else\n+  throw std::runtime_error(\"No JSExecutorFactory specified.\");\n+  return nullptr;\n+#endif // USE_HERMES",
        "comment_created_at": "2025-02-14T13:46:23+00:00",
        "comment_author": "cipolleschi",
        "comment_body": "Same as before. I'd extract the lambda to avoid duplicating code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1848459079",
    "pr_number": 47671,
    "pr_file": "packages/react-native/Libraries/Text/TextInput/Singleline/RCTUITextField.mm",
    "created_at": "2024-11-19T14:23:33+00:00",
    "commented_code": "self.attributedText = originalText;\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  static BOOL isFirstRender = YES;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueLeadingBarButtonGroups;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueTrailingBarButtonGroups;",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1848459079",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47671,
        "pr_file": "packages/react-native/Libraries/Text/TextInput/Singleline/RCTUITextField.mm",
        "discussion_id": "1848459079",
        "commented_code": "@@ -115,6 +115,37 @@ - (void)setSecureTextEntry:(BOOL)secureTextEntry\n   self.attributedText = originalText;\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  static BOOL isFirstRender = YES;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueLeadingBarButtonGroups;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueTrailingBarButtonGroups;",
        "comment_created_at": "2024-11-19T14:23:33+00:00",
        "comment_author": "okwasniewski",
        "comment_body": "This doesn't look too good. It can probably lead to issues if you render multiple text fields next to each other, as the static property will be shared across instances.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1848632908",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47671,
        "pr_file": "packages/react-native/Libraries/Text/TextInput/Singleline/RCTUITextField.mm",
        "discussion_id": "1848459079",
        "commented_code": "@@ -115,6 +115,37 @@ - (void)setSecureTextEntry:(BOOL)secureTextEntry\n   self.attributedText = originalText;\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  static BOOL isFirstRender = YES;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueLeadingBarButtonGroups;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueTrailingBarButtonGroups;",
        "comment_created_at": "2024-11-19T15:59:54+00:00",
        "comment_author": "rezkiy37",
        "comment_body": "Ah, got it. I will try to make it unique for each instance. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1848696123",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47671,
        "pr_file": "packages/react-native/Libraries/Text/TextInput/Singleline/RCTUITextField.mm",
        "discussion_id": "1848459079",
        "commented_code": "@@ -115,6 +115,37 @@ - (void)setSecureTextEntry:(BOOL)secureTextEntry\n   self.attributedText = originalText;\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  static BOOL isFirstRender = YES;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueLeadingBarButtonGroups;\n+  static NSArray<UIBarButtonItemGroup *> *initialValueTrailingBarButtonGroups;",
        "comment_created_at": "2024-11-19T16:38:04+00:00",
        "comment_author": "rezkiy37",
        "comment_body": "Done - 210ba707897ef851fbf314a736ea174be1549571.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1849959826",
    "pr_number": 47671,
    "pr_file": "packages/react-native/Libraries/Text/TextInput/Multiline/RCTUITextView.mm",
    "created_at": "2024-11-20T09:37:22+00:00",
    "commented_code": "[self _invalidatePlaceholderVisibility];\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  // Initialize the initial values only once\n+  if (_isFirstRender) {\n+    _isFirstRender = NO;\n+    // Capture initial values of leading and trailing button groups\n+    _initialValueLeadingBarButtonGroups = self.inputAssistantItem.leadingBarButtonGroups;\n+    _initialValueTrailingBarButtonGroups = self.inputAssistantItem.trailingBarButtonGroups;\n+  }",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1849959826",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47671,
        "pr_file": "packages/react-native/Libraries/Text/TextInput/Multiline/RCTUITextView.mm",
        "discussion_id": "1849959826",
        "commented_code": "@@ -132,6 +135,26 @@ - (void)textDidChange\n   [self _invalidatePlaceholderVisibility];\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  // Initialize the initial values only once\n+  if (_isFirstRender) {\n+    _isFirstRender = NO;\n+    // Capture initial values of leading and trailing button groups\n+    _initialValueLeadingBarButtonGroups = self.inputAssistantItem.leadingBarButtonGroups;\n+    _initialValueTrailingBarButtonGroups = self.inputAssistantItem.trailingBarButtonGroups;\n+  }",
        "comment_created_at": "2024-11-20T09:37:22+00:00",
        "comment_author": "okwasniewski",
        "comment_body": "This `isFirstRender` flag isn't the best idea.. \r\n\r\nYou can set these flags just once in the initializer, right? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1850229090",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47671,
        "pr_file": "packages/react-native/Libraries/Text/TextInput/Multiline/RCTUITextView.mm",
        "discussion_id": "1849959826",
        "commented_code": "@@ -132,6 +135,26 @@ - (void)textDidChange\n   [self _invalidatePlaceholderVisibility];\n }\n \n+- (void)setDisableKeyboardShortcuts:(BOOL)disableKeyboardShortcuts\n+{\n+  // Initialize the initial values only once\n+  if (_isFirstRender) {\n+    _isFirstRender = NO;\n+    // Capture initial values of leading and trailing button groups\n+    _initialValueLeadingBarButtonGroups = self.inputAssistantItem.leadingBarButtonGroups;\n+    _initialValueTrailingBarButtonGroups = self.inputAssistantItem.trailingBarButtonGroups;\n+  }",
        "comment_created_at": "2024-11-20T12:24:30+00:00",
        "comment_author": "rezkiy37",
        "comment_body": "Done - aa3fbcabf96853232d4ee359afe7942002e8154d, 374a7b50a06a7f6b89270167b40552539e114a5d.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861955029",
    "pr_number": 47998,
    "pr_file": "packages/react-native/ReactCommon/react/runtime/platform/ios/ReactCommon/RCTInstance.mm",
    "created_at": "2024-11-28T10:44:56+00:00",
    "commented_code": "[_bridgeModuleDecorator.callableJSModules\n           setBridgelessJSModuleMethodInvoker:^(\n               NSString *moduleName, NSString *methodName, NSArray *args, dispatch_block_t onComplete) {\n-            // TODO: Make RCTInstance call onComplete\n-            [weakSelf callFunctionOnJSModule:moduleName method:methodName args:args];\n+            [weakSelf callFunctionOnJSModule:moduleName method:methodName args:args completion:onComplete];\n           }];",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1861955029",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47998,
        "pr_file": "packages/react-native/ReactCommon/react/runtime/platform/ios/ReactCommon/RCTInstance.mm",
        "discussion_id": "1861955029",
        "commented_code": "@@ -121,8 +121,7 @@ - (instancetype)initWithDelegate:(id<RCTInstanceDelegate>)delegate\n       [_bridgeModuleDecorator.callableJSModules\n           setBridgelessJSModuleMethodInvoker:^(\n               NSString *moduleName, NSString *methodName, NSArray *args, dispatch_block_t onComplete) {\n-            // TODO: Make RCTInstance call onComplete\n-            [weakSelf callFunctionOnJSModule:moduleName method:methodName args:args];\n+            [weakSelf callFunctionOnJSModule:moduleName method:methodName args:args completion:onComplete];\n           }];",
        "comment_created_at": "2024-11-28T10:44:56+00:00",
        "comment_author": "javache",
        "comment_body": "Could we inline the onComplete callback here?\r\n\r\n```\r\nif (onComplete) {\r\n  [self callFunctionOnBufferedRuntimeExecutor:[completion](facebook::jsi::Runtime &_) { completion(); }];\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1821137287",
    "pr_number": 47003,
    "pr_file": "packages/react-native/React/Fabric/Utils/RCTLinearGradient.mm",
    "created_at": "2024-10-29T16:08:50+00:00",
    "commented_code": "+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+#import \"RCTLinearGradient.h\"\n+\n+#import <React/RCTConversions.h>\n+\n+using namespace facebook::react;\n+\n+@implementation RCTLinearGradient\n+\n++ (CALayer *)gradientLayerWithSize:(CGSize)size\n+                          gradient:(const LinearGradient&) gradient {\n+  \n+  UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:size];\n+  auto orientation = gradient.orientation;\n+  auto colorStops = gradient.colorStops;\n+  \n+  UIImage *gradientImage = [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) {\n+    CGContextRef context = rendererContext.CGContext;\n+    NSMutableArray *colors = [NSMutableArray array];\n+    CGFloat locations[colorStops.size()];\n+    \n+    for (size_t i = 0; i < colorStops.size(); ++i) {\n+      const auto &colorStop = colorStops[i];\n+      UIColor *color = RCTUIColorFromSharedColor(colorStop.color);\n+      [colors addObject:(id)color.CGColor];\n+      locations[i] = colorStop.position;\n+    }\n+    \n+    auto colorSpace = getDefaultColorSpace() == ColorSpace::sRGB ? CGColorSpaceCreateDeviceRGB() : CGColorSpaceCreateWithName(kCGColorSpaceDisplayP3);\n+    \n+    CGGradientRef cgGradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)colors, locations);\n+    \n+    CGPoint startPoint;\n+    CGPoint endPoint;\n+    \n+    if (orientation.type == GradientOrientationType::Angle) {\n+      CGFloat angle = std::get<Float>(orientation.value);\n+      setPointsFromAngle(angle, size, &startPoint, &endPoint);\n+    } else if (orientation.type == GradientOrientationType::Direction) {\n+      NSString *direction = [NSString stringWithUTF8String:std::get<std::string>(orientation.value).c_str()];\n+      CGFloat angle = getAngleFromDirection(direction, size);\n+      setPointsFromAngle(angle, size, &startPoint, &endPoint);\n+    } else {\n+      // Default to top-to-bottom gradient\n+      startPoint = CGPointMake(0.0, 0.0);\n+      endPoint = CGPointMake(0.0, size.height);\n+    }\n+    \n+    CGContextDrawLinearGradient(context, cgGradient, startPoint, endPoint, 0);\n+    \n+    CGColorSpaceRelease(colorSpace);\n+    CGGradientRelease(cgGradient);\n+  }];\n+  \n+  CALayer *gradientLayer = [CALayer layer];\n+  gradientLayer.contents = (__bridge id)gradientImage.CGImage;\n+  \n+  return gradientLayer;\n+}\n+\n+\n+// Spec: https://www.w3.org/TR/css-images-3/#linear-gradient-syntax\n+// Reference: https://github.com/chromium/chromium/blob/d32abbe13f5d52be7127fe25d5b778498165fab8/third_party/blink/renderer/core/css/css_gradient_value.cc#L1057\n+static void setPointsFromAngle(CGFloat angle, CGSize size, CGPoint *startPoint, CGPoint *endPoint) {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1821137287",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47003,
        "pr_file": "packages/react-native/React/Fabric/Utils/RCTLinearGradient.mm",
        "discussion_id": "1821137287",
        "commented_code": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+#import \"RCTLinearGradient.h\"\n+\n+#import <React/RCTConversions.h>\n+\n+using namespace facebook::react;\n+\n+@implementation RCTLinearGradient\n+\n++ (CALayer *)gradientLayerWithSize:(CGSize)size\n+                          gradient:(const LinearGradient&) gradient {\n+  \n+  UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:size];\n+  auto orientation = gradient.orientation;\n+  auto colorStops = gradient.colorStops;\n+  \n+  UIImage *gradientImage = [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) {\n+    CGContextRef context = rendererContext.CGContext;\n+    NSMutableArray *colors = [NSMutableArray array];\n+    CGFloat locations[colorStops.size()];\n+    \n+    for (size_t i = 0; i < colorStops.size(); ++i) {\n+      const auto &colorStop = colorStops[i];\n+      UIColor *color = RCTUIColorFromSharedColor(colorStop.color);\n+      [colors addObject:(id)color.CGColor];\n+      locations[i] = colorStop.position;\n+    }\n+    \n+    auto colorSpace = getDefaultColorSpace() == ColorSpace::sRGB ? CGColorSpaceCreateDeviceRGB() : CGColorSpaceCreateWithName(kCGColorSpaceDisplayP3);\n+    \n+    CGGradientRef cgGradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)colors, locations);\n+    \n+    CGPoint startPoint;\n+    CGPoint endPoint;\n+    \n+    if (orientation.type == GradientOrientationType::Angle) {\n+      CGFloat angle = std::get<Float>(orientation.value);\n+      setPointsFromAngle(angle, size, &startPoint, &endPoint);\n+    } else if (orientation.type == GradientOrientationType::Direction) {\n+      NSString *direction = [NSString stringWithUTF8String:std::get<std::string>(orientation.value).c_str()];\n+      CGFloat angle = getAngleFromDirection(direction, size);\n+      setPointsFromAngle(angle, size, &startPoint, &endPoint);\n+    } else {\n+      // Default to top-to-bottom gradient\n+      startPoint = CGPointMake(0.0, 0.0);\n+      endPoint = CGPointMake(0.0, size.height);\n+    }\n+    \n+    CGContextDrawLinearGradient(context, cgGradient, startPoint, endPoint, 0);\n+    \n+    CGColorSpaceRelease(colorSpace);\n+    CGGradientRelease(cgGradient);\n+  }];\n+  \n+  CALayer *gradientLayer = [CALayer layer];\n+  gradientLayer.contents = (__bridge id)gradientImage.CGImage;\n+  \n+  return gradientLayer;\n+}\n+\n+\n+// Spec: https://www.w3.org/TR/css-images-3/#linear-gradient-syntax\n+// Reference: https://github.com/chromium/chromium/blob/d32abbe13f5d52be7127fe25d5b778498165fab8/third_party/blink/renderer/core/css/css_gradient_value.cc#L1057\n+static void setPointsFromAngle(CGFloat angle, CGSize size, CGPoint *startPoint, CGPoint *endPoint) {",
        "comment_created_at": "2024-10-29T16:08:50+00:00",
        "comment_author": "NickGerleman",
        "comment_body": "nit: instead of out params, could this return a struct/tuple? Caller could then destructure (in IIFE if needed)",
        "pr_file_module": null
      }
    ]
  }
]