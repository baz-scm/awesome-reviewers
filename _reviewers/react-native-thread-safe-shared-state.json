[
  {
    "discussion_id": "779111410",
    "pr_number": 29466,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactHorizontalScrollView.java",
    "created_at": "2022-01-05T20:19:49+00:00",
    "commented_code": "updateStateOnScroll(getScrollX(), getScrollY());\n   }\n \n+  /**\n+   * Called when a mContentView's layout has changed. Fixes the scroll position depending on\n+   * maintainVisibleContentPosition\n+   */\n+  @Override\n+  public void onLayoutChange(\n+      View v,\n+      int left,\n+      int top,\n+      int right,\n+      int bottom,\n+      int oldLeft,\n+      int oldTop,\n+      int oldRight,\n+      int oldBottom) {\n+    if (mContentView == null) {\n+      return;\n+    }\n+\n+    if (this.mMaintainVisibleContentPositionData != null) {\n+      scrollMaintainVisibleContentPosition();\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a scroll. Finds the first\n+   * completely visible view in the ScrollView and stores it for later use.\n+   */\n+  private void computeFirstVisibleItemForMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+    int minIdx = maintainVisibleContentPositionData.minIndexForVisible;\n+\n+    ReactViewGroup contentView = (ReactViewGroup) getChildAt(0);\n+    if (contentView == null) return;\n+\n+    for (int i = minIdx; i < contentView.getChildCount(); i++) {\n+      // Find the first entirely visible view. This must be done after we update the content offset\n+      // or it will tend to grab rows that were made visible by the shift in position\n+      View child = contentView.getChildAt(i);\n+      if (child.getX() >= currentScrollX || i == contentView.getChildCount() - 1) {\n+        firstVisibleViewForMaintainVisibleContentPosition = new WeakReference<>(child);\n+        Rect frame = new Rect();\n+        child.getHitRect(frame);\n+        prevFirstVisibleFrameForMaintainVisibleContentPosition = frame;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a layout change. Detects if the\n+   * layout change impacts the scroll position and corrects it if needed.\n+   */\n+  private void scrollMaintainVisibleContentPosition() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "779111410",
        "repo_full_name": "facebook/react-native",
        "pr_number": 29466,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactHorizontalScrollView.java",
        "discussion_id": "779111410",
        "commented_code": "@@ -1239,6 +1288,97 @@ private void updateStateOnScroll() {\n     updateStateOnScroll(getScrollX(), getScrollY());\n   }\n \n+  /**\n+   * Called when a mContentView's layout has changed. Fixes the scroll position depending on\n+   * maintainVisibleContentPosition\n+   */\n+  @Override\n+  public void onLayoutChange(\n+      View v,\n+      int left,\n+      int top,\n+      int right,\n+      int bottom,\n+      int oldLeft,\n+      int oldTop,\n+      int oldRight,\n+      int oldBottom) {\n+    if (mContentView == null) {\n+      return;\n+    }\n+\n+    if (this.mMaintainVisibleContentPositionData != null) {\n+      scrollMaintainVisibleContentPosition();\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a scroll. Finds the first\n+   * completely visible view in the ScrollView and stores it for later use.\n+   */\n+  private void computeFirstVisibleItemForMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+    int minIdx = maintainVisibleContentPositionData.minIndexForVisible;\n+\n+    ReactViewGroup contentView = (ReactViewGroup) getChildAt(0);\n+    if (contentView == null) return;\n+\n+    for (int i = minIdx; i < contentView.getChildCount(); i++) {\n+      // Find the first entirely visible view. This must be done after we update the content offset\n+      // or it will tend to grab rows that were made visible by the shift in position\n+      View child = contentView.getChildAt(i);\n+      if (child.getX() >= currentScrollX || i == contentView.getChildCount() - 1) {\n+        firstVisibleViewForMaintainVisibleContentPosition = new WeakReference<>(child);\n+        Rect frame = new Rect();\n+        child.getHitRect(frame);\n+        prevFirstVisibleFrameForMaintainVisibleContentPosition = frame;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a layout change. Detects if the\n+   * layout change impacts the scroll position and corrects it if needed.\n+   */\n+  private void scrollMaintainVisibleContentPosition() {",
        "comment_created_at": "2022-01-05T20:19:49+00:00",
        "comment_author": "yungsters",
        "comment_body": "There are some problems with this approach.\r\n\r\n1. When the scroll view first loads and no scroll events occur before items are prepended, this approach would not maintain scroll position because `firstVisibleView` is only set after at least one scroll event.\r\n2. There could be a race condition between when the VirtualizedList prepends an item and when we invoke a scroll event (`onScroll` vs. `onLayoutChange`). This can cause the delta of the cached item to incorrectly be zero, leading to the scroll position not being maintained.\r\n3. We noticed that when there are many items in the list, `onLayoutChange` does not get called and the scroll position is not maintained. (This may be due to the loop computation being too expensive.)",
        "pr_file_module": null
      },
      {
        "comment_id": "814392081",
        "repo_full_name": "facebook/react-native",
        "pr_number": 29466,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactHorizontalScrollView.java",
        "discussion_id": "779111410",
        "commented_code": "@@ -1239,6 +1288,97 @@ private void updateStateOnScroll() {\n     updateStateOnScroll(getScrollX(), getScrollY());\n   }\n \n+  /**\n+   * Called when a mContentView's layout has changed. Fixes the scroll position depending on\n+   * maintainVisibleContentPosition\n+   */\n+  @Override\n+  public void onLayoutChange(\n+      View v,\n+      int left,\n+      int top,\n+      int right,\n+      int bottom,\n+      int oldLeft,\n+      int oldTop,\n+      int oldRight,\n+      int oldBottom) {\n+    if (mContentView == null) {\n+      return;\n+    }\n+\n+    if (this.mMaintainVisibleContentPositionData != null) {\n+      scrollMaintainVisibleContentPosition();\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a scroll. Finds the first\n+   * completely visible view in the ScrollView and stores it for later use.\n+   */\n+  private void computeFirstVisibleItemForMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+    int minIdx = maintainVisibleContentPositionData.minIndexForVisible;\n+\n+    ReactViewGroup contentView = (ReactViewGroup) getChildAt(0);\n+    if (contentView == null) return;\n+\n+    for (int i = minIdx; i < contentView.getChildCount(); i++) {\n+      // Find the first entirely visible view. This must be done after we update the content offset\n+      // or it will tend to grab rows that were made visible by the shift in position\n+      View child = contentView.getChildAt(i);\n+      if (child.getX() >= currentScrollX || i == contentView.getChildCount() - 1) {\n+        firstVisibleViewForMaintainVisibleContentPosition = new WeakReference<>(child);\n+        Rect frame = new Rect();\n+        child.getHitRect(frame);\n+        prevFirstVisibleFrameForMaintainVisibleContentPosition = frame;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a layout change. Detects if the\n+   * layout change impacts the scroll position and corrects it if needed.\n+   */\n+  private void scrollMaintainVisibleContentPosition() {",
        "comment_created_at": "2022-02-25T00:50:36+00:00",
        "comment_author": "roryabraham",
        "comment_body": "> There could be a race condition between when the VirtualizedList prepends an item and when we invoke a scroll event (onScroll vs. onLayoutChange). This can cause the delta of the cached item to incorrectly be zero, leading to the scroll position not being maintained.\r\n\r\nI've been digging into this problem and trying to find a solution. Any suggestions?",
        "pr_file_module": null
      },
      {
        "comment_id": "814396026",
        "repo_full_name": "facebook/react-native",
        "pr_number": 29466,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactHorizontalScrollView.java",
        "discussion_id": "779111410",
        "commented_code": "@@ -1239,6 +1288,97 @@ private void updateStateOnScroll() {\n     updateStateOnScroll(getScrollX(), getScrollY());\n   }\n \n+  /**\n+   * Called when a mContentView's layout has changed. Fixes the scroll position depending on\n+   * maintainVisibleContentPosition\n+   */\n+  @Override\n+  public void onLayoutChange(\n+      View v,\n+      int left,\n+      int top,\n+      int right,\n+      int bottom,\n+      int oldLeft,\n+      int oldTop,\n+      int oldRight,\n+      int oldBottom) {\n+    if (mContentView == null) {\n+      return;\n+    }\n+\n+    if (this.mMaintainVisibleContentPositionData != null) {\n+      scrollMaintainVisibleContentPosition();\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a scroll. Finds the first\n+   * completely visible view in the ScrollView and stores it for later use.\n+   */\n+  private void computeFirstVisibleItemForMaintainVisibleContentPosition() {\n+    ReactScrollViewMaintainVisibleContentPositionData maintainVisibleContentPositionData =\n+        mMaintainVisibleContentPositionData;\n+    if (maintainVisibleContentPositionData == null) return;\n+\n+    int currentScrollX = getScrollX();\n+    int minIdx = maintainVisibleContentPositionData.minIndexForVisible;\n+\n+    ReactViewGroup contentView = (ReactViewGroup) getChildAt(0);\n+    if (contentView == null) return;\n+\n+    for (int i = minIdx; i < contentView.getChildCount(); i++) {\n+      // Find the first entirely visible view. This must be done after we update the content offset\n+      // or it will tend to grab rows that were made visible by the shift in position\n+      View child = contentView.getChildAt(i);\n+      if (child.getX() >= currentScrollX || i == contentView.getChildCount() - 1) {\n+        firstVisibleViewForMaintainVisibleContentPosition = new WeakReference<>(child);\n+        Rect frame = new Rect();\n+        child.getHitRect(frame);\n+        prevFirstVisibleFrameForMaintainVisibleContentPosition = frame;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called when maintainVisibleContentPosition is used and after a layout change. Detects if the\n+   * layout change impacts the scroll position and corrects it if needed.\n+   */\n+  private void scrollMaintainVisibleContentPosition() {",
        "comment_created_at": "2022-02-25T01:01:06+00:00",
        "comment_author": "roryabraham",
        "comment_body": "Unless I'm mistaken, the same problem exists with the current iOS implementation of `maintainVisibleContentPosition` and may be the cause of https://github.com/facebook/react-native/issues/25239",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860814985",
    "pr_number": 47634,
    "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
    "created_at": "2024-11-27T14:58:01+00:00",
    "commented_code": "updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1860814985",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-11-27T14:58:01+00:00",
        "comment_author": "tdn120",
        "comment_body": "Does this account for multiple views/transitions?  Seems like we'd need to remove the id(s) instead, and then:\r\n`mIsTransitioning = mChildrenRemovedWhileTransitioning.isEmpty();`\r\n\r\nAlso probably worth keeping `mChildrenRemovedWhileTransitioning` once we create it, we just don't want to create on init, it in cases where transitions aren't used at all.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1860879039",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-11-27T15:36:01+00:00",
        "comment_author": "kkafar",
        "comment_body": "I've changed nulling the hashset to clearing it here: https://github.com/facebook/react-native/pull/47634/commits/a7c7af3eaaa2879c9d4f086d3aa6063b89b940be.",
        "pr_file_module": null
      },
      {
        "comment_id": "1860883891",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-11-27T15:39:06+00:00",
        "comment_author": "kkafar",
        "comment_body": "@tdn120 I'm not sure though, what you mean by this:\r\n\r\n> Does this account for multiple views/transitions? Seems like we'd need to remove the id(s) instead [...]\r\n\r\nCould you elaborate here? \r\n\r\nThe `ReactViewGroup` instance is responsible only of tracking its transitioning state & children. I wrote it so to align it with Android `parent.startViewTransition(child)` behaviour - it modifies only the `parent` behaviour with respect to this single `child`. The `child` is unaware of any changes.",
        "pr_file_module": null
      },
      {
        "comment_id": "1860905674",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-11-27T15:52:56+00:00",
        "comment_author": "tdn120",
        "comment_body": "Just at a basic level, if you have a timeline of:\r\n```\r\nstartViewTransition(viewA)\r\nstartViewTransition(viewB)\r\nendViewTransition(viewA) \r\n```\r\nAt this point you would clear `mIsTransitioning` and `mChildrenRemovedWhileTransitioning`, so wouldn't `viewB` be out of sync until its transition ends?",
        "pr_file_module": null
      },
      {
        "comment_id": "1865548641",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-12-02T09:52:15+00:00",
        "comment_author": "kkafar",
        "comment_body": "I was OOO by the end of last week. Back here now \ud83d\udc4b\ud83c\udffb \r\n\r\n~I think I still don't understand the issue here.~\r\n\r\n~Android docs [explicitly state](https://developer.android.com/reference/android/view/ViewGroup#startViewTransition(android.view.View)) that a call to `startViewTransition` should be accompanied by call to `endViewTransition`. It is left up to the programmer to ensure this.~\r\n\r\n~If you - as a API user - fail to fulfil this contract you'll get inconsistent (possibly buggy) behaviour and I believe there is not much we can do on React Native end to prevent that.~\r\n\r\n~Regarding the example:~\r\n\r\n```java\r\nthis.startViewTransition(viewA)\r\nthis.startViewTransition(viewB)\r\nthis.endViewTransition(viewA) \r\n```\r\n\r\n~...~\r\n\r\nOh, it just got to me. Yeah, I think you're right and that is a very good catch. Thanks. I'll update the code in a bit. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1865551343",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-12-02T09:54:03+00:00",
        "comment_author": "kkafar",
        "comment_body": "I should keep track of which children are transitioning and clear the state only if there are no more such children. \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1865733197",
        "repo_full_name": "facebook/react-native",
        "pr_number": 47634,
        "pr_file": "packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/view/ReactViewGroup.java",
        "discussion_id": "1860814985",
        "commented_code": "@@ -405,6 +410,26 @@ public void updateClippingRect() {\n     updateClippingToRect(mClippingRect);\n   }\n \n+  @Override\n+  public void startViewTransition(View view) {\n+    super.startViewTransition(view);\n+    mIsTransitioning = true;\n+  }\n+\n+  @Override\n+  public void endViewTransition(View view) {\n+    super.endViewTransition(view);\n+    mIsTransitioning = false;\n+    mChildrenRemovedWhileTransitioning = null;",
        "comment_created_at": "2024-12-02T12:04:40+00:00",
        "comment_author": "kkafar",
        "comment_body": "@tdn120 I am thinking about various approaches, trying to avoid allocating additional hash set as much as possible. I would need it to store all the children for which `startViewTransition` has been called and then remove them from the set in `endViewTransition`. The working approach would look somehow like that:\r\n\r\n```java\r\n  public boolean isChildTransitioning(View child) {\r\n    return mTransitioningChildren != null && mTransitioningChildren.contains(child.getid());\r\n  }\r\n\r\n  public void onViewRemoved(View child) {\r\n    ...\r\n\r\n    if (isChildTransitioning(child)) {\r\n      // This call would allocate\r\n      ensureChildrenRemovedWhileTransitioning.add(child.getId());\r\n    }\r\n\r\n    ...\r\n  }\r\n\r\n  public void startViewTransition(View view) {\r\n    super.startViewTransition(view);\r\n    ensureTransitioningChildren().add(view.getId());\r\n  }\r\n\r\n  public void endViewTransition(View view) {\r\n    super.endViewTransition(view);\r\n    ensureTransitioningChildren().remove(view.getId());\r\n    if (mChildrenRemovedWhileTransitioning != null) {\r\n      mChildrenRemovedWhileTransitioning.remove(view.getId());\r\n    }\r\n  }\r\n```\r\n\r\nHowever, this requires 2 hash sets...\r\n\r\nOnly way to improve I see here is to rely in `onViewRemoved` on the fact, that **if children is transitioning and it has been removed then its parent won't be nulled out**. \r\nHence we could check it like this:\r\n\r\n```java\r\npublic void onViewRemoved(View child) {\r\n    ...\r\n    \r\n    if (child.getParent() != null) {\r\n        ensureChildrenRemovedWhileTransitioning.add(child.getId());\r\n    }\r\n\r\n    ...\r\n}\r\n```\r\n\r\nLooking at Android code [(link)](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java#5398) this would be reliable, but we would be relaying on implementation detail. I feel like this behaviour is implicitly suggested in `startViewTransition` & `endViewTransition` docs, by stating that these remove child from parent state but noting about removing parent from child state, however this is not explicit.\r\n\r\nEven if I'm overlooking some case this still would solve the initial issue, so we should be fine on this front.\r\n\r\nAnother possibility is to store the information on whether the view is transitioning or not directly on the child view itself, by using a tag as you suggested.\r\n\r\nLemme know which behavior you would agree for.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "704111554",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-09-08T07:04:40+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "704111554",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "704111554",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {",
        "comment_created_at": "2021-09-08T07:04:40+00:00",
        "comment_author": "analysis-bot",
        "comment_body": "`google-java-format` suggested changes:\n```diff\n@@ -51,7 +50,7 @@\n-      new ThreadLocal<Object[]>() {\n-        @Nullable\n-        @Override\n-        protected Object[] initialValue() {\n-          return new Object[2];\n-        }\n-      };\n+        new ThreadLocal<Object[]>() {\n+          @Nullable\n+          @Override\n+          protected Object[] initialValue() {\n+            return new Object[2];\n+          }\n+        };\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "704111557",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-09-08T07:04:41+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "704111557",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "704111557",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {",
        "comment_created_at": "2021-09-08T07:04:41+00:00",
        "comment_author": "analysis-bot",
        "comment_body": "`google-java-format` suggested changes:\n```diff\n@@ -69,7 +68,7 @@\n-      new ThreadLocal<Object[]>() {\n-        @Nullable\n-        @Override\n-        protected Object[] initialValue() {\n-          return new Object[1];\n-        }\n-      };\n+        new ThreadLocal<Object[]>() {\n+          @Nullable\n+          @Override\n+          protected Object[] initialValue() {\n+            return new Object[1];\n+          }\n+        };\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "704111559",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-09-08T07:04:41+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[1];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "704111559",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "704111559",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[1];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {",
        "comment_created_at": "2021-09-08T07:04:41+00:00",
        "comment_author": "analysis-bot",
        "comment_body": "`google-java-format` suggested changes:\n```diff\n@@ -78,7 +77,7 @@\n-      new ThreadLocal<Object[]>() {\n-        @Nullable\n-        @Override\n-        protected Object[] initialValue() {\n-          return new Object[2];\n-        }\n-      };\n+        new ThreadLocal<Object[]>() {\n+          @Nullable\n+          @Override\n+          protected Object[] initialValue() {\n+            return new Object[2];\n+          }\n+        };\n\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "735891151",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-10-25T19:19:23+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "735891151",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "735891151",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =",
        "comment_created_at": "2021-10-25T19:19:23+00:00",
        "comment_author": "ShikaSD",
        "comment_body": "Could you please extract creation in a method to cleanup this init a little? \ud83d\ude42 \r\ne.g.:\r\n```\r\nprivate static ThreadLocal<Object[]> threadLocalArray(int size) {\r\n    return new ThreadLocal<Object[]>() {\r\n        @Nullable\r\n        @Override\r\n        protected Object[] initialValue() {\r\n          return new Object[size];\r\n        }\r\n      };\r\n}",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "739062382",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-10-29T09:03:37+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "739062382",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "739062382",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {",
        "comment_created_at": "2021-10-29T09:03:37+00:00",
        "comment_author": "analysis-bot",
        "comment_body": "`google-java-format` suggested changes:\n```diff\n@@ -51,7 +50,7 @@\n-      new ThreadLocal<Object[]>() {\n-        @Nullable\n-        @Override\n-        protected Object[] initialValue() {\n-          return new Object[2];\n-        }\n-      };\n+        new ThreadLocal<Object[]>() {\n+          @Nullable\n+          @Override\n+          protected Object[] initialValue() {\n+            return new Object[2];\n+          }\n+        };\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "739062387",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-10-29T09:03:38+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "739062387",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "739062387",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {",
        "comment_created_at": "2021-10-29T09:03:38+00:00",
        "comment_author": "analysis-bot",
        "comment_body": "`google-java-format` suggested changes:\n```diff\n@@ -69,7 +68,7 @@\n-      new ThreadLocal<Object[]>() {\n-        @Nullable\n-        @Override\n-        protected Object[] initialValue() {\n-          return new Object[1];\n-        }\n-      };\n+        new ThreadLocal<Object[]>() {\n+          @Nullable\n+          @Override\n+          protected Object[] initialValue() {\n+            return new Object[1];\n+          }\n+        };\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "739062389",
    "pr_number": 32167,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
    "created_at": "2021-10-29T09:03:38+00:00",
    "commented_code": "protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[1];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "739062389",
        "repo_full_name": "facebook/react-native",
        "pr_number": 32167,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/uimanager/ViewManagersPropertyCache.java",
        "discussion_id": "739062389",
        "commented_code": "@@ -45,13 +45,43 @@ public static void clear() {\n     protected final Method mSetter;\n     protected final @Nullable Integer mIndex; /* non-null only for group setters */\n \n-    // The following Object arrays are used to prevent extra allocations from varargs when we call\n-    // Method.invoke. It's safe for those objects to be static as we update properties in a single\n-    // thread sequentially\n-    private static final Object[] VIEW_MGR_ARGS = new Object[2];\n-    private static final Object[] VIEW_MGR_GROUP_ARGS = new Object[3];\n-    private static final Object[] SHADOW_ARGS = new Object[1];\n-    private static final Object[] SHADOW_GROUP_ARGS = new Object[2];\n+    \n+    /** use ThreadLocal for every shadow thread */\n+    private static final ThreadLocal<Object[]> VIEW_MGR_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[2];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> VIEW_MGR_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[3];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_ARGS =\n+      new ThreadLocal<Object[]>() {\n+        @Nullable\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[1];\n+        }\n+      };\n+\n+    private static final ThreadLocal<Object[]> SHADOW_GROUP_ARGS =\n+      new ThreadLocal<Object[]>() {",
        "comment_created_at": "2021-10-29T09:03:38+00:00",
        "comment_author": "analysis-bot",
        "comment_body": "`google-java-format` suggested changes:\n```diff\n@@ -78,7 +77,7 @@\n-      new ThreadLocal<Object[]>() {\n-        @Nullable\n-        @Override\n-        protected Object[] initialValue() {\n-          return new Object[2];\n-        }\n-      };\n+        new ThreadLocal<Object[]>() {\n+          @Nullable\n+          @Override\n+          protected Object[] initialValue() {\n+            return new Object[2];\n+          }\n+        };\n\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1007362951",
    "pr_number": 35049,
    "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/MaintainVisibleScrollPositionHelper.java",
    "created_at": "2022-10-27T20:50:57+00:00",
    "commented_code": "+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.views.scroll;\n+\n+import android.graphics.Rect;\n+import android.view.View;\n+import android.view.ViewGroup;\n+\n+import androidx.annotation.Nullable;\n+\n+import com.facebook.infer.annotation.Assertions;\n+import com.facebook.react.bridge.ReactContext;\n+import com.facebook.react.bridge.ReadableMap;\n+import com.facebook.react.bridge.UIManager;\n+import com.facebook.react.bridge.UIManagerListener;\n+import com.facebook.react.bridge.UiThreadUtil;\n+import com.facebook.react.uimanager.UIManagerHelper;\n+import com.facebook.react.uimanager.common.ViewUtil;\n+import com.facebook.react.views.view.ReactViewGroup;\n+import com.facebook.react.views.scroll.ReactScrollViewHelper.HasSmoothScroll;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Manage state for the maintainVisibleContentPosition prop.\n+ *\n+ * This uses UIManager to listen to updates and capture position of items before and after layout.\n+ */\n+public class MaintainVisibleScrollPositionHelper<ScrollViewT extends ViewGroup & HasSmoothScroll> implements UIManagerListener {\n+  private final ScrollViewT mScrollView;\n+  private final boolean mHorizontal;\n+  private @Nullable Config mConfig;\n+  private @Nullable WeakReference<View> mFirstVisibleView = null;\n+  private @Nullable Rect mPrevFirstVisibleFrame = null;\n+  private boolean mListening = false;\n+\n+  public static class Config {\n+    public final int minIndexForVisible;\n+    public final @Nullable Integer autoScrollToTopThreshold;\n+\n+    Config(int minIndexForVisible, @Nullable Integer autoScrollToTopThreshold) {\n+      this.minIndexForVisible = minIndexForVisible;\n+      this.autoScrollToTopThreshold = autoScrollToTopThreshold;\n+    }\n+\n+    static Config fromReadableMap(ReadableMap value) {\n+      int minIndexForVisible = value.getInt(\"minIndexForVisible\");\n+      Integer autoScrollToTopThreshold =\n+        value.hasKey(\"autoscrollToTopThreshold\")\n+          ? value.getInt(\"autoscrollToTopThreshold\")\n+          : null;\n+      return new Config(minIndexForVisible, autoScrollToTopThreshold);\n+    }\n+  }\n+\n+  public MaintainVisibleScrollPositionHelper(ScrollViewT scrollView, boolean horizontal) {\n+    mScrollView = scrollView;\n+    mHorizontal = horizontal;\n+  }\n+\n+  public void setConfig(@Nullable Config config) {\n+    mConfig = config;\n+  }\n+\n+  /**\n+   * Start listening to view hierarchy updates. Should be called when this is created.\n+   */\n+  public void start() {\n+    if (mListening) {\n+      return;\n+    }\n+    mListening = true;\n+    getUIManagerModule().addUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Stop listening to view hierarchy updates. Should be called before this is destroyed.\n+   */\n+  public void stop() {\n+    if (!mListening) {\n+      return;\n+    }\n+    mListening = false;\n+    getUIManagerModule().removeUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Update the scroll position of the managed ScrollView. This should be called after layout\n+   * has been updated.\n+   */\n+  public void updateScrollPosition() {\n+    if (mConfig == null\n+      || mFirstVisibleView == null\n+      || mPrevFirstVisibleFrame == null) {\n+      return;\n+    }\n+\n+    View firstVisibleView = mFirstVisibleView.get();",
    "repo_full_name": "facebook/react-native",
    "discussion_comments": [
      {
        "comment_id": "1007362951",
        "repo_full_name": "facebook/react-native",
        "pr_number": 35049,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/MaintainVisibleScrollPositionHelper.java",
        "discussion_id": "1007362951",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.views.scroll;\n+\n+import android.graphics.Rect;\n+import android.view.View;\n+import android.view.ViewGroup;\n+\n+import androidx.annotation.Nullable;\n+\n+import com.facebook.infer.annotation.Assertions;\n+import com.facebook.react.bridge.ReactContext;\n+import com.facebook.react.bridge.ReadableMap;\n+import com.facebook.react.bridge.UIManager;\n+import com.facebook.react.bridge.UIManagerListener;\n+import com.facebook.react.bridge.UiThreadUtil;\n+import com.facebook.react.uimanager.UIManagerHelper;\n+import com.facebook.react.uimanager.common.ViewUtil;\n+import com.facebook.react.views.view.ReactViewGroup;\n+import com.facebook.react.views.scroll.ReactScrollViewHelper.HasSmoothScroll;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Manage state for the maintainVisibleContentPosition prop.\n+ *\n+ * This uses UIManager to listen to updates and capture position of items before and after layout.\n+ */\n+public class MaintainVisibleScrollPositionHelper<ScrollViewT extends ViewGroup & HasSmoothScroll> implements UIManagerListener {\n+  private final ScrollViewT mScrollView;\n+  private final boolean mHorizontal;\n+  private @Nullable Config mConfig;\n+  private @Nullable WeakReference<View> mFirstVisibleView = null;\n+  private @Nullable Rect mPrevFirstVisibleFrame = null;\n+  private boolean mListening = false;\n+\n+  public static class Config {\n+    public final int minIndexForVisible;\n+    public final @Nullable Integer autoScrollToTopThreshold;\n+\n+    Config(int minIndexForVisible, @Nullable Integer autoScrollToTopThreshold) {\n+      this.minIndexForVisible = minIndexForVisible;\n+      this.autoScrollToTopThreshold = autoScrollToTopThreshold;\n+    }\n+\n+    static Config fromReadableMap(ReadableMap value) {\n+      int minIndexForVisible = value.getInt(\"minIndexForVisible\");\n+      Integer autoScrollToTopThreshold =\n+        value.hasKey(\"autoscrollToTopThreshold\")\n+          ? value.getInt(\"autoscrollToTopThreshold\")\n+          : null;\n+      return new Config(minIndexForVisible, autoScrollToTopThreshold);\n+    }\n+  }\n+\n+  public MaintainVisibleScrollPositionHelper(ScrollViewT scrollView, boolean horizontal) {\n+    mScrollView = scrollView;\n+    mHorizontal = horizontal;\n+  }\n+\n+  public void setConfig(@Nullable Config config) {\n+    mConfig = config;\n+  }\n+\n+  /**\n+   * Start listening to view hierarchy updates. Should be called when this is created.\n+   */\n+  public void start() {\n+    if (mListening) {\n+      return;\n+    }\n+    mListening = true;\n+    getUIManagerModule().addUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Stop listening to view hierarchy updates. Should be called before this is destroyed.\n+   */\n+  public void stop() {\n+    if (!mListening) {\n+      return;\n+    }\n+    mListening = false;\n+    getUIManagerModule().removeUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Update the scroll position of the managed ScrollView. This should be called after layout\n+   * has been updated.\n+   */\n+  public void updateScrollPosition() {\n+    if (mConfig == null\n+      || mFirstVisibleView == null\n+      || mPrevFirstVisibleFrame == null) {\n+      return;\n+    }\n+\n+    View firstVisibleView = mFirstVisibleView.get();",
        "comment_created_at": "2022-10-27T20:50:57+00:00",
        "comment_author": "ryancat",
        "comment_body": "`updateScrollPosition` is getting called on layout change. Is this always going to happen after computing `mFirstVisibleView`, which here it does in listener to `willDispatchViewUpdates`?\r\n\r\nIn theory I think it should, as we will dispatch the mounting instruction in JS thread or UI thread (when sync update) before the native platform to update the layout. However, since we are doing the computing on UI thread asynchronously, I am not sure if there will be a race condition where the first visible view is computed after we called this method.\r\n\r\ncc @javache what do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1009960342",
        "repo_full_name": "facebook/react-native",
        "pr_number": 35049,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/MaintainVisibleScrollPositionHelper.java",
        "discussion_id": "1007362951",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.views.scroll;\n+\n+import android.graphics.Rect;\n+import android.view.View;\n+import android.view.ViewGroup;\n+\n+import androidx.annotation.Nullable;\n+\n+import com.facebook.infer.annotation.Assertions;\n+import com.facebook.react.bridge.ReactContext;\n+import com.facebook.react.bridge.ReadableMap;\n+import com.facebook.react.bridge.UIManager;\n+import com.facebook.react.bridge.UIManagerListener;\n+import com.facebook.react.bridge.UiThreadUtil;\n+import com.facebook.react.uimanager.UIManagerHelper;\n+import com.facebook.react.uimanager.common.ViewUtil;\n+import com.facebook.react.views.view.ReactViewGroup;\n+import com.facebook.react.views.scroll.ReactScrollViewHelper.HasSmoothScroll;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Manage state for the maintainVisibleContentPosition prop.\n+ *\n+ * This uses UIManager to listen to updates and capture position of items before and after layout.\n+ */\n+public class MaintainVisibleScrollPositionHelper<ScrollViewT extends ViewGroup & HasSmoothScroll> implements UIManagerListener {\n+  private final ScrollViewT mScrollView;\n+  private final boolean mHorizontal;\n+  private @Nullable Config mConfig;\n+  private @Nullable WeakReference<View> mFirstVisibleView = null;\n+  private @Nullable Rect mPrevFirstVisibleFrame = null;\n+  private boolean mListening = false;\n+\n+  public static class Config {\n+    public final int minIndexForVisible;\n+    public final @Nullable Integer autoScrollToTopThreshold;\n+\n+    Config(int minIndexForVisible, @Nullable Integer autoScrollToTopThreshold) {\n+      this.minIndexForVisible = minIndexForVisible;\n+      this.autoScrollToTopThreshold = autoScrollToTopThreshold;\n+    }\n+\n+    static Config fromReadableMap(ReadableMap value) {\n+      int minIndexForVisible = value.getInt(\"minIndexForVisible\");\n+      Integer autoScrollToTopThreshold =\n+        value.hasKey(\"autoscrollToTopThreshold\")\n+          ? value.getInt(\"autoscrollToTopThreshold\")\n+          : null;\n+      return new Config(minIndexForVisible, autoScrollToTopThreshold);\n+    }\n+  }\n+\n+  public MaintainVisibleScrollPositionHelper(ScrollViewT scrollView, boolean horizontal) {\n+    mScrollView = scrollView;\n+    mHorizontal = horizontal;\n+  }\n+\n+  public void setConfig(@Nullable Config config) {\n+    mConfig = config;\n+  }\n+\n+  /**\n+   * Start listening to view hierarchy updates. Should be called when this is created.\n+   */\n+  public void start() {\n+    if (mListening) {\n+      return;\n+    }\n+    mListening = true;\n+    getUIManagerModule().addUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Stop listening to view hierarchy updates. Should be called before this is destroyed.\n+   */\n+  public void stop() {\n+    if (!mListening) {\n+      return;\n+    }\n+    mListening = false;\n+    getUIManagerModule().removeUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Update the scroll position of the managed ScrollView. This should be called after layout\n+   * has been updated.\n+   */\n+  public void updateScrollPosition() {\n+    if (mConfig == null\n+      || mFirstVisibleView == null\n+      || mPrevFirstVisibleFrame == null) {\n+      return;\n+    }\n+\n+    View firstVisibleView = mFirstVisibleView.get();",
        "comment_created_at": "2022-10-31T23:46:47+00:00",
        "comment_author": "janicduplessis",
        "comment_body": "If willDispatchViewUpdates is called from ui thread (which I\u2019m not sure if it ever does) the dispatch to ui thread will be done synchronously by runOnUIThread. Ideally we could have a way to observe before / after views are updated on the ui thread but wanted to avoid adding more methods to UIManagerObserver for old arch. In my tests this always worked so I was fine with this solution.",
        "pr_file_module": null
      },
      {
        "comment_id": "1288195469",
        "repo_full_name": "facebook/react-native",
        "pr_number": 35049,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/MaintainVisibleScrollPositionHelper.java",
        "discussion_id": "1007362951",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.views.scroll;\n+\n+import android.graphics.Rect;\n+import android.view.View;\n+import android.view.ViewGroup;\n+\n+import androidx.annotation.Nullable;\n+\n+import com.facebook.infer.annotation.Assertions;\n+import com.facebook.react.bridge.ReactContext;\n+import com.facebook.react.bridge.ReadableMap;\n+import com.facebook.react.bridge.UIManager;\n+import com.facebook.react.bridge.UIManagerListener;\n+import com.facebook.react.bridge.UiThreadUtil;\n+import com.facebook.react.uimanager.UIManagerHelper;\n+import com.facebook.react.uimanager.common.ViewUtil;\n+import com.facebook.react.views.view.ReactViewGroup;\n+import com.facebook.react.views.scroll.ReactScrollViewHelper.HasSmoothScroll;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Manage state for the maintainVisibleContentPosition prop.\n+ *\n+ * This uses UIManager to listen to updates and capture position of items before and after layout.\n+ */\n+public class MaintainVisibleScrollPositionHelper<ScrollViewT extends ViewGroup & HasSmoothScroll> implements UIManagerListener {\n+  private final ScrollViewT mScrollView;\n+  private final boolean mHorizontal;\n+  private @Nullable Config mConfig;\n+  private @Nullable WeakReference<View> mFirstVisibleView = null;\n+  private @Nullable Rect mPrevFirstVisibleFrame = null;\n+  private boolean mListening = false;\n+\n+  public static class Config {\n+    public final int minIndexForVisible;\n+    public final @Nullable Integer autoScrollToTopThreshold;\n+\n+    Config(int minIndexForVisible, @Nullable Integer autoScrollToTopThreshold) {\n+      this.minIndexForVisible = minIndexForVisible;\n+      this.autoScrollToTopThreshold = autoScrollToTopThreshold;\n+    }\n+\n+    static Config fromReadableMap(ReadableMap value) {\n+      int minIndexForVisible = value.getInt(\"minIndexForVisible\");\n+      Integer autoScrollToTopThreshold =\n+        value.hasKey(\"autoscrollToTopThreshold\")\n+          ? value.getInt(\"autoscrollToTopThreshold\")\n+          : null;\n+      return new Config(minIndexForVisible, autoScrollToTopThreshold);\n+    }\n+  }\n+\n+  public MaintainVisibleScrollPositionHelper(ScrollViewT scrollView, boolean horizontal) {\n+    mScrollView = scrollView;\n+    mHorizontal = horizontal;\n+  }\n+\n+  public void setConfig(@Nullable Config config) {\n+    mConfig = config;\n+  }\n+\n+  /**\n+   * Start listening to view hierarchy updates. Should be called when this is created.\n+   */\n+  public void start() {\n+    if (mListening) {\n+      return;\n+    }\n+    mListening = true;\n+    getUIManagerModule().addUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Stop listening to view hierarchy updates. Should be called before this is destroyed.\n+   */\n+  public void stop() {\n+    if (!mListening) {\n+      return;\n+    }\n+    mListening = false;\n+    getUIManagerModule().removeUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Update the scroll position of the managed ScrollView. This should be called after layout\n+   * has been updated.\n+   */\n+  public void updateScrollPosition() {\n+    if (mConfig == null\n+      || mFirstVisibleView == null\n+      || mPrevFirstVisibleFrame == null) {\n+      return;\n+    }\n+\n+    View firstVisibleView = mFirstVisibleView.get();",
        "comment_created_at": "2023-08-09T09:16:25+00:00",
        "comment_author": "Rays15",
        "comment_body": "@janicduplessis `firstVisibleView` may be null, i ran into.\r\n`\r\nE/unknown:ReactNative: Exception in native call\r\n    java.lang.NullPointerException: Attempt to invoke virtual method 'void android.view.View.getHitRect(android.graphics.Rect)' on a null object reference\r\n        at com.facebook.react.views.scroll.MaintainVisibleScrollPositionHelper.updateScrollPositionInternal(MaintainVisibleScrollPositionHelper.java:107)\r\n        at com.facebook.react.views.scroll.MaintainVisibleScrollPositionHelper.updateScrollPosition(MaintainVisibleScrollPositionHelper.java:97)\r\n        at com.facebook.react.views.scroll.ReactScrollView.onLayoutChange(ReactScrollView.java:1128)\r\n        at android.view.View.layout(View.java:20717)\r\n        at android.view.ViewGroup.layout(ViewGroup.java:6198)\r\n        at com.facebook.react.uimanager.NativeViewHierarchyManager.updateLayout(NativeViewHierarchyManager.java:254)\r\n        at com.facebook.react.uimanager.NativeViewHierarchyManager.updateLayout(NativeViewHierarchyManager.java:222)\r\n`",
        "pr_file_module": null
      },
      {
        "comment_id": "1288519682",
        "repo_full_name": "facebook/react-native",
        "pr_number": 35049,
        "pr_file": "ReactAndroid/src/main/java/com/facebook/react/views/scroll/MaintainVisibleScrollPositionHelper.java",
        "discussion_id": "1007362951",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) Meta Platforms, Inc. and affiliates.\n+ *\n+ * This source code is licensed under the MIT license found in the\n+ * LICENSE file in the root directory of this source tree.\n+ */\n+\n+package com.facebook.react.views.scroll;\n+\n+import android.graphics.Rect;\n+import android.view.View;\n+import android.view.ViewGroup;\n+\n+import androidx.annotation.Nullable;\n+\n+import com.facebook.infer.annotation.Assertions;\n+import com.facebook.react.bridge.ReactContext;\n+import com.facebook.react.bridge.ReadableMap;\n+import com.facebook.react.bridge.UIManager;\n+import com.facebook.react.bridge.UIManagerListener;\n+import com.facebook.react.bridge.UiThreadUtil;\n+import com.facebook.react.uimanager.UIManagerHelper;\n+import com.facebook.react.uimanager.common.ViewUtil;\n+import com.facebook.react.views.view.ReactViewGroup;\n+import com.facebook.react.views.scroll.ReactScrollViewHelper.HasSmoothScroll;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Manage state for the maintainVisibleContentPosition prop.\n+ *\n+ * This uses UIManager to listen to updates and capture position of items before and after layout.\n+ */\n+public class MaintainVisibleScrollPositionHelper<ScrollViewT extends ViewGroup & HasSmoothScroll> implements UIManagerListener {\n+  private final ScrollViewT mScrollView;\n+  private final boolean mHorizontal;\n+  private @Nullable Config mConfig;\n+  private @Nullable WeakReference<View> mFirstVisibleView = null;\n+  private @Nullable Rect mPrevFirstVisibleFrame = null;\n+  private boolean mListening = false;\n+\n+  public static class Config {\n+    public final int minIndexForVisible;\n+    public final @Nullable Integer autoScrollToTopThreshold;\n+\n+    Config(int minIndexForVisible, @Nullable Integer autoScrollToTopThreshold) {\n+      this.minIndexForVisible = minIndexForVisible;\n+      this.autoScrollToTopThreshold = autoScrollToTopThreshold;\n+    }\n+\n+    static Config fromReadableMap(ReadableMap value) {\n+      int minIndexForVisible = value.getInt(\"minIndexForVisible\");\n+      Integer autoScrollToTopThreshold =\n+        value.hasKey(\"autoscrollToTopThreshold\")\n+          ? value.getInt(\"autoscrollToTopThreshold\")\n+          : null;\n+      return new Config(minIndexForVisible, autoScrollToTopThreshold);\n+    }\n+  }\n+\n+  public MaintainVisibleScrollPositionHelper(ScrollViewT scrollView, boolean horizontal) {\n+    mScrollView = scrollView;\n+    mHorizontal = horizontal;\n+  }\n+\n+  public void setConfig(@Nullable Config config) {\n+    mConfig = config;\n+  }\n+\n+  /**\n+   * Start listening to view hierarchy updates. Should be called when this is created.\n+   */\n+  public void start() {\n+    if (mListening) {\n+      return;\n+    }\n+    mListening = true;\n+    getUIManagerModule().addUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Stop listening to view hierarchy updates. Should be called before this is destroyed.\n+   */\n+  public void stop() {\n+    if (!mListening) {\n+      return;\n+    }\n+    mListening = false;\n+    getUIManagerModule().removeUIManagerEventListener(this);\n+  }\n+\n+  /**\n+   * Update the scroll position of the managed ScrollView. This should be called after layout\n+   * has been updated.\n+   */\n+  public void updateScrollPosition() {\n+    if (mConfig == null\n+      || mFirstVisibleView == null\n+      || mPrevFirstVisibleFrame == null) {\n+      return;\n+    }\n+\n+    View firstVisibleView = mFirstVisibleView.get();",
        "comment_created_at": "2023-08-09T13:52:31+00:00",
        "comment_author": "janicduplessis",
        "comment_body": "I see, yes it is missing a null check, I'll open a PR to fix it.",
        "pr_file_module": null
      }
    ]
  }
]