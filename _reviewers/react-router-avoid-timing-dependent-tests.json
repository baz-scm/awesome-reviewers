[
  {
    "discussion_id": "1992843402",
    "pr_number": 13210,
    "pr_file": "integration/middleware-test.ts",
    "created_at": "2025-03-13T06:04:08+00:00",
    "commented_code": "await page.waitForSelector(\"[data-child]\");\n \n       // 2 separate server requests made\n-      expect(requests).toEqual([\n+      expect(requests.sort()).toEqual([",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1992843402",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13210,
        "pr_file": "integration/middleware-test.ts",
        "discussion_id": "1992843402",
        "commented_code": "@@ -1074,7 +1253,7 @@ test.describe(\"Middleware\", () => {\n       await page.waitForSelector(\"[data-child]\");\n \n       // 2 separate server requests made\n-      expect(requests).toEqual([\n+      expect(requests.sort()).toEqual([",
        "comment_created_at": "2025-03-13T06:04:08+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "This test was flaky in Firefox due to the order of requests not being deterministic.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1727407626",
    "pr_number": 11620,
    "pr_file": "packages/react-router/__tests__/router/navigation-blocking-test.ts",
    "created_at": "2024-08-22T15:52:24+00:00",
    "commented_code": "router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.getBlocker(\"KEY\", fn)).toEqual({\n-          state: \"unblocked\",\n-          proceed: undefined,\n-          reset: undefined,\n-          location: undefined,\n-        });\n+        await waitFor(() =>\n+          expect(router.getBlocker(\"KEY\", fn)).toEqual({\n+            state: \"unblocked\",\n+            proceed: undefined,\n+            reset: undefined,\n+            location: undefined,\n+          })\n+        );\n       });\n \n       it(\"navigates after proceeding navigation completes\", async () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.state.location.pathname).toBe(\"/about\");\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")\n+        );\n+      });\n+    });\n+\n+    describe(\"proceeds from blocked state using browser history\", () => {\n+      let fn = () => true;\n+\n+      // we want to navigate so that `/about` is the previous entry in the\n+      // stack here since it has a loader that won't resolve immediately\n+      beforeEach(async () => {\n+        const history = createBrowserHistory();\n+\n+        router = createRouter({\n+          history,\n+          routes,\n+        });\n+\n+        router.initialize();\n+\n+        await router.navigate(\"/\");\n+        await router.navigate(\"/about\");\n+        await router.navigate(\"/contact\");\n+      });\n+\n+      it(\"proceeds after quick block of back navigation\", async () => {\n+        router.getBlocker(\"KEY\", fn);\n+\n+        await router.navigate(-1); // This does not really wait for the navigation to happen\n+        await waitFor(\n+          () => expect(router.getBlocker(\"KEY\", fn).state).toBe(\"blocked\"),\n+          { interval: 1 }\n+        ); // This awaits the navigation\n+        router.getBlocker(\"KEY\", fn).proceed!();\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1727407626",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 11620,
        "pr_file": "packages/react-router/__tests__/router/navigation-blocking-test.ts",
        "discussion_id": "1727407626",
        "commented_code": "@@ -442,21 +454,58 @@ describe(\"navigation blocking\", () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.getBlocker(\"KEY\", fn)).toEqual({\n-          state: \"unblocked\",\n-          proceed: undefined,\n-          reset: undefined,\n-          location: undefined,\n-        });\n+        await waitFor(() =>\n+          expect(router.getBlocker(\"KEY\", fn)).toEqual({\n+            state: \"unblocked\",\n+            proceed: undefined,\n+            reset: undefined,\n+            location: undefined,\n+          })\n+        );\n       });\n \n       it(\"navigates after proceeding navigation completes\", async () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.state.location.pathname).toBe(\"/about\");\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")\n+        );\n+      });\n+    });\n+\n+    describe(\"proceeds from blocked state using browser history\", () => {\n+      let fn = () => true;\n+\n+      // we want to navigate so that `/about` is the previous entry in the\n+      // stack here since it has a loader that won't resolve immediately\n+      beforeEach(async () => {\n+        const history = createBrowserHistory();\n+\n+        router = createRouter({\n+          history,\n+          routes,\n+        });\n+\n+        router.initialize();\n+\n+        await router.navigate(\"/\");\n+        await router.navigate(\"/about\");\n+        await router.navigate(\"/contact\");\n+      });\n+\n+      it(\"proceeds after quick block of back navigation\", async () => {\n+        router.getBlocker(\"KEY\", fn);\n+\n+        await router.navigate(-1); // This does not really wait for the navigation to happen\n+        await waitFor(\n+          () => expect(router.getBlocker(\"KEY\", fn).state).toBe(\"blocked\"),\n+          { interval: 1 }\n+        ); // This awaits the navigation\n+        router.getBlocker(\"KEY\", fn).proceed!();\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")",
        "comment_created_at": "2024-08-22T15:52:24+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Are we sure this test exhibits the actual bug?  I see this failure when run against `dev`:\r\n\r\n```\r\n\u25cf navigation blocking \u203a proceeds from blocked state using browser history \u203a proceeds after quick block of back navigation\r\n\r\n    expect(received).toBe(expected) // Object.is equality\r\n\r\n    Expected: \"/about\"\r\n    Received: \"/\"\r\n```\r\n\r\nThe reproduction for the original issue leaves you on the original blocked page (`/three`) but this test, without the fix, actually ends up going back 2 history locations?",
        "pr_file_module": null
      },
      {
        "comment_id": "1728490365",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 11620,
        "pr_file": "packages/react-router/__tests__/router/navigation-blocking-test.ts",
        "discussion_id": "1727407626",
        "commented_code": "@@ -442,21 +454,58 @@ describe(\"navigation blocking\", () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.getBlocker(\"KEY\", fn)).toEqual({\n-          state: \"unblocked\",\n-          proceed: undefined,\n-          reset: undefined,\n-          location: undefined,\n-        });\n+        await waitFor(() =>\n+          expect(router.getBlocker(\"KEY\", fn)).toEqual({\n+            state: \"unblocked\",\n+            proceed: undefined,\n+            reset: undefined,\n+            location: undefined,\n+          })\n+        );\n       });\n \n       it(\"navigates after proceeding navigation completes\", async () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.state.location.pathname).toBe(\"/about\");\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")\n+        );\n+      });\n+    });\n+\n+    describe(\"proceeds from blocked state using browser history\", () => {\n+      let fn = () => true;\n+\n+      // we want to navigate so that `/about` is the previous entry in the\n+      // stack here since it has a loader that won't resolve immediately\n+      beforeEach(async () => {\n+        const history = createBrowserHistory();\n+\n+        router = createRouter({\n+          history,\n+          routes,\n+        });\n+\n+        router.initialize();\n+\n+        await router.navigate(\"/\");\n+        await router.navigate(\"/about\");\n+        await router.navigate(\"/contact\");\n+      });\n+\n+      it(\"proceeds after quick block of back navigation\", async () => {\n+        router.getBlocker(\"KEY\", fn);\n+\n+        await router.navigate(-1); // This does not really wait for the navigation to happen\n+        await waitFor(\n+          () => expect(router.getBlocker(\"KEY\", fn).state).toBe(\"blocked\"),\n+          { interval: 1 }\n+        ); // This awaits the navigation\n+        router.getBlocker(\"KEY\", fn).proceed!();\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")",
        "comment_created_at": "2024-08-23T07:15:22+00:00",
        "comment_author": "Artur-",
        "comment_body": "I am not sure why it behaves differently here. My assumption was that maybe JSDOM (or whoever emulates browser navigation here) behaves differently in the case where navigation is in progress and you navigate again. I think it still covers the issue though, which is that if you navigate during navigation, you will end up somewhere else than you would expect.\r\n\r\nIf you have ideas on how to improve the test, I am all ears",
        "pr_file_module": null
      },
      {
        "comment_id": "1731384721",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 11620,
        "pr_file": "packages/react-router/__tests__/router/navigation-blocking-test.ts",
        "discussion_id": "1727407626",
        "commented_code": "@@ -442,21 +454,58 @@ describe(\"navigation blocking\", () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.getBlocker(\"KEY\", fn)).toEqual({\n-          state: \"unblocked\",\n-          proceed: undefined,\n-          reset: undefined,\n-          location: undefined,\n-        });\n+        await waitFor(() =>\n+          expect(router.getBlocker(\"KEY\", fn)).toEqual({\n+            state: \"unblocked\",\n+            proceed: undefined,\n+            reset: undefined,\n+            location: undefined,\n+          })\n+        );\n       });\n \n       it(\"navigates after proceeding navigation completes\", async () => {\n         router.getBlocker(\"KEY\", fn);\n         await router.navigate(-1);\n         router.getBlocker(\"KEY\", fn).proceed?.();\n-        await sleep(LOADER_LATENCY_MS);\n-        expect(router.state.location.pathname).toBe(\"/about\");\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")\n+        );\n+      });\n+    });\n+\n+    describe(\"proceeds from blocked state using browser history\", () => {\n+      let fn = () => true;\n+\n+      // we want to navigate so that `/about` is the previous entry in the\n+      // stack here since it has a loader that won't resolve immediately\n+      beforeEach(async () => {\n+        const history = createBrowserHistory();\n+\n+        router = createRouter({\n+          history,\n+          routes,\n+        });\n+\n+        router.initialize();\n+\n+        await router.navigate(\"/\");\n+        await router.navigate(\"/about\");\n+        await router.navigate(\"/contact\");\n+      });\n+\n+      it(\"proceeds after quick block of back navigation\", async () => {\n+        router.getBlocker(\"KEY\", fn);\n+\n+        await router.navigate(-1); // This does not really wait for the navigation to happen\n+        await waitFor(\n+          () => expect(router.getBlocker(\"KEY\", fn).state).toBe(\"blocked\"),\n+          { interval: 1 }\n+        ); // This awaits the navigation\n+        router.getBlocker(\"KEY\", fn).proceed!();\n+        await waitFor(() =>\n+          expect(router.state.location.pathname).toBe(\"/about\")",
        "comment_created_at": "2024-08-26T15:01:47+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Ah ok yeah this is probably a JSDOM issue.  I'm going to test this through an integration test in a real browser in https://github.com/remix-run/remix/pull/9914 instead of trying to hack JSDOM into behaving correctly",
        "pr_file_module": null
      }
    ]
  }
]