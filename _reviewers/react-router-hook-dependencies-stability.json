[
  {
    "discussion_id": "2070327163",
    "pr_number": 13511,
    "pr_file": "packages/react-router/lib/hooks.tsx",
    "created_at": "2025-05-01T14:21:06+00:00",
    "commented_code": "export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),\n+    [dataRouterContext.router]",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2070327163",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13511,
        "pr_file": "packages/react-router/lib/hooks.tsx",
        "discussion_id": "2070327163",
        "commented_code": "@@ -1046,14 +1046,14 @@ export function useNavigation() {\n export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),\n+    [dataRouterContext.router]",
        "comment_created_at": "2025-05-01T14:21:06+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "I'm pretty sure this is no more stable than before\r\n\r\n- Before `dataRouterContext.router` was a dependency to the `React.useMemo` below.\r\n- Now `dataRouterContext.router` is a dependency to the `React.useCallback` for `revalidate\r\n- Now `revalidate` is a dependency to the `React.useMemo` below\r\n- Effectively `dataRouterContext.router` is still a dependency of the `React.useMemo` below\r\n\r\nYou could narrow and make `dataRouterContext.router.revalidate` the dependency. I'm not sure how stable it is",
        "pr_file_module": null
      },
      {
        "comment_id": "2070339813",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13511,
        "pr_file": "packages/react-router/lib/hooks.tsx",
        "discussion_id": "2070327163",
        "commented_code": "@@ -1046,14 +1046,14 @@ export function useNavigation() {\n export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),\n+    [dataRouterContext.router]",
        "comment_created_at": "2025-05-01T14:30:22+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "I actually think this will work - the \"fix\" is removing `state.revalidation` as a dep of the revalidate function.  `dataRouterContext.router` should remain stable for the duration of the app ",
        "pr_file_module": null
      },
      {
        "comment_id": "2070340514",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13511,
        "pr_file": "packages/react-router/lib/hooks.tsx",
        "discussion_id": "2070327163",
        "commented_code": "@@ -1046,14 +1046,14 @@ export function useNavigation() {\n export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),\n+    [dataRouterContext.router]",
        "comment_created_at": "2025-05-01T14:30:54+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Previously, when you kicked off a revalidation and `state.revalidation` went into a `loading` state, you got a new instance of the `revalidate` function",
        "pr_file_module": null
      },
      {
        "comment_id": "2070353562",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13511,
        "pr_file": "packages/react-router/lib/hooks.tsx",
        "discussion_id": "2070327163",
        "commented_code": "@@ -1046,14 +1046,14 @@ export function useNavigation() {\n export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),\n+    [dataRouterContext.router]",
        "comment_created_at": "2025-05-01T14:41:46+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "Ahh yep, I see it now, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070344288",
    "pr_number": 13511,
    "pr_file": "packages/react-router/lib/hooks.tsx",
    "created_at": "2025-05-01T14:33:54+00:00",
    "commented_code": "export function useRevalidator() {",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2070344288",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13511,
        "pr_file": "packages/react-router/lib/hooks.tsx",
        "discussion_id": "2070344288",
        "commented_code": "@@ -1046,14 +1046,14 @@ export function useNavigation() {\n export function useRevalidator() {",
        "comment_created_at": "2025-05-01T14:33:54+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Can we throw existing return types on here to ensure we keep the contract the same?\r\n\r\n```suggestion\r\nexport function useRevalidator(): {\r\n  revalidate: () => Promise<void>;\r\n  state: DataRouter[\"state\"][\"revalidation\"];\r\n} {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070346996",
    "pr_number": 13511,
    "pr_file": "packages/react-router/lib/hooks.tsx",
    "created_at": "2025-05-01T14:36:05+00:00",
    "commented_code": "export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2070346996",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13511,
        "pr_file": "packages/react-router/lib/hooks.tsx",
        "discussion_id": "2070346996",
        "commented_code": "@@ -1046,14 +1046,14 @@ export function useNavigation() {\n export function useRevalidator() {\n   let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n   let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n+  let revalidate = React.useCallback(\n+    async () => dataRouterContext.router.revalidate(),",
        "comment_created_at": "2025-05-01T14:36:05+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Can we keep this like it was so we don't couple the return value of `useRevalidator().revalidate` and `router.revalidate`?\r\n\r\n```suggestion\r\n    async revalidate() {\r\n      await dataRouterContext.router.revalidate();\r\n    },\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1591351238",
    "pr_number": 11521,
    "pr_file": "packages/react-router/__tests__/dom/special-characters-test.tsx",
    "created_at": "2024-05-06T17:44:55+00:00",
    "commented_code": "it(\"does not encode characters in MemoryRouter (navigate)\", () => {\n         function Start() {\n           let navigate = useNavigate();\n-          // eslint-disable-next-line react-hooks/exhaustive-deps\n-          React.useEffect(() => navigate(\"/with space\"), []);\n+          React.useEffect(() => {\n+            navigate(\"/with space\");\n+          }, [navigate]);",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1591351238",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 11521,
        "pr_file": "packages/react-router/__tests__/dom/special-characters-test.tsx",
        "discussion_id": "1591351238",
        "commented_code": "@@ -831,8 +831,9 @@ describe(\"special character tests\", () => {\n       it(\"does not encode characters in MemoryRouter (navigate)\", () => {\n         function Start() {\n           let navigate = useNavigate();\n-          // eslint-disable-next-line react-hooks/exhaustive-deps\n-          React.useEffect(() => navigate(\"/with space\"), []);\n+          React.useEffect(() => {\n+            navigate(\"/with space\");\n+          }, [navigate]);",
        "comment_created_at": "2024-05-06T17:44:55+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Tests needed to be updated so they don't return promises from `useEffect`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1417205076",
    "pr_number": 10740,
    "pr_file": "packages/react-router-dom/index.tsx",
    "created_at": "2023-12-06T12:32:21+00:00",
    "commented_code": "let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1417205076",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-06T12:32:21+00:00",
        "comment_author": "Brendonovich",
        "comment_body": "I'm fairly certain that while this works in most cases, it's not transition-safe.\r\n\r\nQuoting [the rules](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) for `useRef`:\r\n> Do not write or read ref.current during rendering, except for initialization. This makes your component\u2019s behavior unpredictable.\r\n\r\nWriting to `searchParamsRef` during render like this violates those rules, and I wouldn't be surprised if it leads to inconsistent states when using `startTransition`, which may be a concern for RRv7.\r\n\r\nI think the correct solution in the future would be to wrap `setSearchParams` in `useEffectEvent`, but that isn't stable yet \ud83d\ude43 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1420659570",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-08T15:32:20+00:00",
        "comment_author": "mysuf",
        "comment_body": "What about this (it is derived from older code, but the principle is obvious):\r\n```\r\nconst searchParamsRef = React.useRef();\r\nconst [searchParams, setRawSearchParams] = React.useState();\r\n\r\nReact.useEffect(() => {\r\n\tsearchParamsRef.current = getSearchParamsForLocation(\r\n\t\tlocation.search,\r\n\t\tdefaultSearchParamsRef.current\r\n  \t)\r\n\tsetRawSearchParams(searchParamsRef.current);\r\n},\r\n[location.search]);\r\n\r\nlet navigate = useNavigate();\r\nlet setSearchParams = React.useCallback<SetURLSearchParams>(\r\n  (nextInit, navigateOptions) => {\r\n\tconst newSearchParams = createSearchParams(\r\n\t  typeof nextInit === \"function\" ? nextInit(searchParamsRef.current) : nextInit\r\n\t);\r\n\tnavigate(\"?\" + newSearchParams, navigateOptions);\r\n  },\r\n  [navigate]\r\n);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1421056609",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-08T21:54:56+00:00",
        "comment_author": "rwilliams3088",
        "comment_body": "> I'm fairly certain that while this works in most cases, it's not transition-safe.\r\n> \r\n> Quoting [the rules](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) for `useRef`:\r\n> \r\n> > Do not write or read ref.current during rendering, except for initialization. This makes your component\u2019s behavior unpredictable.\r\n> \r\n> Writing to `searchParamsRef` during render like this violates those rules, and I wouldn't be surprised if it leads to inconsistent states when using `startTransition`, which may be a concern for RRv7.\r\n> \r\n> I think the correct solution in the future would be to wrap `setSearchParams` in `useEffectEvent`, but that isn't stable yet \ud83d\ude43\r\n\r\nIn context, if you take a look at the example code in question, they are saying not to set the reference's value during the body of the function component - or equivalently the render function on a class component. It is not saying that you should not assign references within the context of a useEffect (or useMemo specifically in this case). That is a standard usage for a reference: useEffect doesn't run during rendering https://react.dev/reference/react/useEffect",
        "pr_file_module": null
      },
      {
        "comment_id": "1421315566",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-09T07:49:04+00:00",
        "comment_author": "Brendonovich",
        "comment_body": "> What about this\r\n\r\nI think that should be alright, would just need to validate that it works\r\n\r\n> It is not saying that you should not assign references within the context of a useEffect (or useMemo specifically in this case)\r\n\r\nYou're right in that you can write to refs in `useEffect`, but you still shouldn't do it in `useMemo` since the callback of a `useMemo` does get ran during render (if its dependencies change ofc)",
        "pr_file_module": null
      },
      {
        "comment_id": "1423001190",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-11T18:59:37+00:00",
        "comment_author": "rwilliams3088",
        "comment_body": "> You're right in that you can write to refs in `useEffect`, but you still shouldn't do it in `useMemo` since the callback of a `useMemo` does get ran during render (if its dependencies change ofc)\r\n\r\n`useMemo` executes between re-renders just like `useEffect`: https://react.dev/reference/react/useMemo\r\n\r\n> useMemo is a React Hook that lets you cache the result of a calculation *between re-renders.*\r\n\r\nAll hooks behave like this; executing asynchronously from the rendering logic. If hooks were just standard function calls that executed synchronously, then there wouldn't be any reason to dub them `hooks` and demand that they follow special rules. Think of `useMemo` as nothing more than a specialized case of `useEffect` that focuses on caching a value, with cache invalidation based upon the dependency list. Similarly, `useCallback` is just a specialized case of `useEffect` for caching a function, which can be invalidated based upon the dependency list. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1423038836",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-11T19:40:43+00:00",
        "comment_author": "Brendonovich",
        "comment_body": "> useMemo executes between re-renders just like useEffect\n> All hooks behave like this; executing asynchronously from the rendering logic.\n\nThis isn't true. Effects are asynchronous, but memos are synchronous and are evaluated during render (if their dependencies change). This can be proved by looking at the `ReactFiberHooks.jsx` implementation of `useMemo`. Notice that the execution of `nextCreate` isn't deferred, rather it's called inline during render.\n\n![image](https://github.com/remix-run/react-router/assets/14191578/b0efcf0a-e3e1-430b-8f64-6500cc366733)\n\nAlso, the 'between rerenders' part means that the value is cached between rerenders, not that the function is called between rerenders.\n\n> If hooks were just standard function calls that executed synchronously, then there wouldn't be any reason to dub them `hooks` and demand they follow special rules.\n\nIn the case of `useMemo`, the special thing that makes it a hook is the fact that it caches previous executions, as the cache is stored as part of the hook tree's state. The function you pass to a memo should have 0 side effects, so it shouldn't care how it's executed, but if memos themselves were asynchronous then you'd have all sorts of stale closure problems. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1423086433",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-11T20:25:29+00:00",
        "comment_author": "mysuf",
        "comment_body": "Honestly I don't think that setting refference during useMemo could cause any issues cos it is non-reactive type and it would need to hit same event loop tick in specific order (possibility close to zero), but since this is widely used public repo and it is close to zero, but not a zero, I would choose recommended solution just to avoid these long threads.. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1423129273",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-11T21:08:42+00:00",
        "comment_author": "rwilliams3088",
        "comment_body": "@Brendonovich I did some more testing, and it would appear that you are correct - `useMemo` does execute synchronously with the re-rendering process. My test code:\r\n\r\n```\r\nexport interface MemoTestProps {\r\n  n: number;\r\n}\r\n\r\nexport const MemoTest = (props: MemoTestProps) => {\r\n  const [i, setIndex] = useState<number>(0);\r\n  const renderCount = useRef<number>(0);\r\n  const memoCount = useRef<number>(0);\r\n\r\n  renderCount.current += 1;\r\n\r\n  console.log(`renderCount before useMemo: ${renderCount.current}, memoCount: ${memoCount.current}`);\r\n  const cachedValue = useMemo(() => {\r\n    memoCount.current += 1;\r\n    console.log(`updated memoCount: ${memoCount.current}`);\r\n    return i;\r\n  }, [i]);\r\n  console.log(`renderCount after useMemo: ${renderCount.current}, memoCount: ${memoCount.current}`);\r\n  \r\n  useEffect(() => {\r\n    if (i < props.n) {\r\n      setIndex(prev => prev + 1);\r\n    }\r\n  }, [i, setIndex, props.n]);\r\n\r\n  return (\r\n    <div>\r\n      <p><label>Render Count:</label> <span>{renderCount.current}</span></p>\r\n      <p><label>Memo Count:</label> <span>{memoCount.current}</span></p>\r\n      <p><label>Cached Value:</label> <span>{cachedValue}</span></p>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\nThe `memoCount` can be observed to always update synchronously with the `renderCount` in the log output.\r\n\r\nI will find some time to look back over this to see if there is a better solution then; although the current solution is still far better than leaving the broken behavior.",
        "pr_file_module": null
      },
      {
        "comment_id": "1423354829",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-12T03:13:02+00:00",
        "comment_author": "Brendonovich",
        "comment_body": "> I don't think that setting reference during useMemo could cause any issues cos it is non-reactive type and it would need to hit same event loop tick in specific order (possibility close to zero)\r\n\r\nEvent loop ticks aren't the problem, writing to a ref during render is simply not good as not all results of renders are actually _used_, so just because a value is calculated during render doesn't mean the user will see that value, as during a Transition the results of that render may get thrown away by React, and yet if you put that value into a ref during render it'll stick around and be accessible in other places, even though that render was never used.\r\n\r\nI think the `useEffect` solution should be fine.",
        "pr_file_module": null
      },
      {
        "comment_id": "1427482709",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10740,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1417205076",
        "commented_code": "@@ -993,30 +993,33 @@ export function useSearchParams(\n \n   let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n   let hasSetSearchParamsRef = React.useRef(false);\n+  let searchParamsRef = React.useRef<URLSearchParams>(defaultSearchParamsRef.current);\n \n   let location = useLocation();\n   let searchParams = React.useMemo(\n-    () =>\n+    () => {\n       // Only merge in the defaults if we haven't yet called setSearchParams.\n       // Once we call that we want those to take precedence, otherwise you can't\n       // remove a param with setSearchParams({}) if it has an initial value\n-      getSearchParamsForLocation(\n+      searchParamsRef.current = getSearchParamsForLocation(\n         location.search,\n         hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n-      ),\n+      );\n+      return searchParamsRef.current;\n+    },\n     [location.search]",
        "comment_created_at": "2023-12-15T02:21:11+00:00",
        "comment_author": "rwilliams3088",
        "comment_body": "I've updated the PR so that it uses a useEffect to updated the reference.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1182905901",
    "pr_number": 10435,
    "pr_file": "packages/react-router/lib/components.tsx",
    "created_at": "2023-05-02T18:30:49+00:00",
    "commented_code": "`only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1182905901",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10435,
        "pr_file": "packages/react-router/lib/components.tsx",
        "discussion_id": "1182905901",
        "commented_code": "@@ -214,18 +218,24 @@ export function Navigate({\n       `only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
        "comment_created_at": "2023-05-02T18:30:49+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "The reason this was problematic in 6.11 is that we would call navigate twice and when in a `RouterProvider` we'd delay resolving the relative path until inside the router.  And thus the second execution would re-resolve `to` against the current location (which in a on-loader scenario would already be updated from the first effect).\r\n\r\nInstead, we resolve the absolute path here in `Navigate` so that duplicate calls to navigate via the data router go to the same path - just as they do in `BrowserRouter`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1182911691",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10435,
        "pr_file": "packages/react-router/lib/components.tsx",
        "discussion_id": "1182905901",
        "commented_code": "@@ -214,18 +218,24 @@ export function Navigate({\n       `only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
        "comment_created_at": "2023-05-02T18:36:47+00:00",
        "comment_author": "jacob-ebey",
        "comment_body": "I'm a little worried about `state` being in there. I'd still like to see this be an empty array as I think we are going to see bad app/library provider code that immediately flows new state / props down causing a new state identity due to no-one ever in the history of app code memoing the value they pass in. If tests are passing across react v17 and 18 though I'm fine shipping it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1183017746",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10435,
        "pr_file": "packages/react-router/lib/components.tsx",
        "discussion_id": "1182905901",
        "commented_code": "@@ -214,18 +218,24 @@ export function Navigate({\n       `only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
        "comment_created_at": "2023-05-02T20:25:50+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "For future reference we tested the unit test setups from [93ccb2b](https://github.com/remix-run/react-router/pull/10435/commits/93ccb2b5d967142270a084cdd166bcc34943fefb) in demo apps using react 16.8 and 18 and confirmed the UI was the same (even if the underlying React.StrictMode execution approaches differed).  We may try to see if we can get our test suite running against both versions in a separate undertaking.",
        "pr_file_module": null
      },
      {
        "comment_id": "1183018372",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10435,
        "pr_file": "packages/react-router/lib/components.tsx",
        "discussion_id": "1182905901",
        "commented_code": "@@ -214,18 +218,24 @@ export function Navigate({\n       `only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
        "comment_created_at": "2023-05-02T20:26:32+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Also, I think we're no worse off than we were previously where the effect had no second param since it would have re-run every time anyway?",
        "pr_file_module": null
      },
      {
        "comment_id": "1183020394",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10435,
        "pr_file": "packages/react-router/lib/components.tsx",
        "discussion_id": "1182905901",
        "commented_code": "@@ -214,18 +218,24 @@ export function Navigate({\n       `only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
        "comment_created_at": "2023-05-02T20:29:02+00:00",
        "comment_author": "jacob-ebey",
        "comment_body": "Thanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "1314090650",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10435,
        "pr_file": "packages/react-router/lib/components.tsx",
        "discussion_id": "1182905901",
        "commented_code": "@@ -214,18 +218,24 @@ export function Navigate({\n       `only ever rendered in response to some user interaction or state change.`\n   );\n \n-  let dataRouterState = React.useContext(DataRouterStateContext);\n+  let { matches } = React.useContext(RouteContext);\n+  let { pathname: locationPathname } = useLocation();\n   let navigate = useNavigate();\n \n-  React.useEffect(() => {\n-    // Avoid kicking off multiple navigations if we're in the middle of a\n-    // data-router navigation, since components get re-rendered when we enter\n-    // a submitting/loading state\n-    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n-      return;\n-    }\n-    navigate(to, { replace, state, relative });\n-  });\n+  // Resolve the path outside of the effect so that when effects run twice in\n+  // StrictMode they navigate to the same place\n+  let path = resolveTo(\n+    to,\n+    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n+    locationPathname,\n+    relative === \"path\"\n+  );\n+  let jsonPath = JSON.stringify(path);\n+\n+  React.useEffect(\n+    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n+    [navigate, jsonPath, relative, replace, state]\n+  );",
        "comment_created_at": "2023-09-03T03:55:09+00:00",
        "comment_author": "ericcan",
        "comment_body": "> I'm a little worried about `state` being in there. I'd still like to see this be an empty array as I think we are going to see bad app/library provider code that immediately flows new state / props down causing a new state identity due to no-one ever in the history of app code memoing the value they pass in. If tests are passing across react v17 and 18 though I'm fine shipping it.\r\n\r\nThis wound up biting me. I had an object that I was passing to state that wasn't memo'd. I think the check for dataRouterState !== \"idle\" saved me prior to 6.11.1, but with this change I had a flurry of redirects (each calling a loader and reloading a file hundreds of times).",
        "pr_file_module": null
      }
    ]
  }
]