[
  {
    "discussion_id": "1780363957",
    "pr_number": 12046,
    "pr_file": "packages/react-router-dev/vite/route-chunks.ts",
    "created_at": "2024-09-30T03:49:24+00:00",
    "commented_code": "identifiers: new Set(),\n   };\n \n+  // Ensure we don't recurse indefinitely\n+  if (visited.has(path)) {\n+    return identifiers;\n+  }\n+\n   visited.add(path);\n \n   // Recursively traverse the AST to find all identifiers the path depends on.\n   path.traverse({\n     Identifier(path) {\n+      // We can skip all of this work if we've already processed this identifier.\n+      if (identifiers.has(path)) {\n+        return;\n+      }\n+\n       identifiers.add(path);\n+\n       let binding = path.scope.getBinding(path.node.name);\n-      if (binding?.path && !visited.has(binding.path)) {\n-        getDependentIdentifiersForPath(binding.path, { visited, identifiers });\n+\n+      if (!binding) {\n+        return;\n+      }\n+\n+      getDependentIdentifiersForPath(binding.path, { visited, identifiers });\n+\n+      // Trace all references to the identifier\n+      for (let reference of binding.referencePaths) {\n+        // Each export declaration is handled separately in our chunking logic\n+        // so we don't want to trace the entire export statement, otherwise all\n+        // identifiers in the export statement will be marked as dependencies\n+        // and we won't be able to split chunks sharing this export statement.\n+        if (reference.isExportNamedDeclaration()) {\n+          continue;\n+        }\n+\n+        getDependentIdentifiersForPath(reference, {\n+          visited,\n+          identifiers,\n+        });\n+      }\n+\n+      // For completeness we also want to trace constant violations since, even\n+      // though the code results in a runtime error, it still compiles.\n+      for (let constantViolation of binding.constantViolations) {\n+        getDependentIdentifiersForPath(constantViolation, {\n+          visited,\n+          identifiers,\n+        });\n       }\n     },\n   });\n \n-  // If the identifier is part of a destructuring assignment, we include all\n-  // other identifiers in the expression as dependencies.\n+  let topLevelStatement = getTopLevelStatementPathForPath(path);\n+  let withinImportStatement = topLevelStatement.isImportDeclaration();\n+  let withinExportStatement = topLevelStatement.isExportDeclaration();\n+\n+  // Include all identifiers in the top-level statement as dependencies, except\n+  // for import/export statements since they have more fine-grained filtering.\n+  if (!withinImportStatement && !withinExportStatement) {\n+    getDependentIdentifiersForPath(topLevelStatement, {\n+      visited,\n+      identifiers,\n+    });\n+  }\n+\n+  // Destructuring assignments in export statements have more fine-grained\n+  // filtering, so we include all identifiers in the expression as dependencies.\n   if (\n+    withinExportStatement &&",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1780363957",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12046,
        "pr_file": "packages/react-router-dev/vite/route-chunks.ts",
        "discussion_id": "1780363957",
        "commented_code": "@@ -266,55 +276,108 @@ function getDependentIdentifiersForPath(\n     identifiers: new Set(),\n   };\n \n+  // Ensure we don't recurse indefinitely\n+  if (visited.has(path)) {\n+    return identifiers;\n+  }\n+\n   visited.add(path);\n \n   // Recursively traverse the AST to find all identifiers the path depends on.\n   path.traverse({\n     Identifier(path) {\n+      // We can skip all of this work if we've already processed this identifier.\n+      if (identifiers.has(path)) {\n+        return;\n+      }\n+\n       identifiers.add(path);\n+\n       let binding = path.scope.getBinding(path.node.name);\n-      if (binding?.path && !visited.has(binding.path)) {\n-        getDependentIdentifiersForPath(binding.path, { visited, identifiers });\n+\n+      if (!binding) {\n+        return;\n+      }\n+\n+      getDependentIdentifiersForPath(binding.path, { visited, identifiers });\n+\n+      // Trace all references to the identifier\n+      for (let reference of binding.referencePaths) {\n+        // Each export declaration is handled separately in our chunking logic\n+        // so we don't want to trace the entire export statement, otherwise all\n+        // identifiers in the export statement will be marked as dependencies\n+        // and we won't be able to split chunks sharing this export statement.\n+        if (reference.isExportNamedDeclaration()) {\n+          continue;\n+        }\n+\n+        getDependentIdentifiersForPath(reference, {\n+          visited,\n+          identifiers,\n+        });\n+      }\n+\n+      // For completeness we also want to trace constant violations since, even\n+      // though the code results in a runtime error, it still compiles.\n+      for (let constantViolation of binding.constantViolations) {\n+        getDependentIdentifiersForPath(constantViolation, {\n+          visited,\n+          identifiers,\n+        });\n       }\n     },\n   });\n \n-  // If the identifier is part of a destructuring assignment, we include all\n-  // other identifiers in the expression as dependencies.\n+  let topLevelStatement = getTopLevelStatementPathForPath(path);\n+  let withinImportStatement = topLevelStatement.isImportDeclaration();\n+  let withinExportStatement = topLevelStatement.isExportDeclaration();\n+\n+  // Include all identifiers in the top-level statement as dependencies, except\n+  // for import/export statements since they have more fine-grained filtering.\n+  if (!withinImportStatement && !withinExportStatement) {\n+    getDependentIdentifiersForPath(topLevelStatement, {\n+      visited,\n+      identifiers,\n+    });\n+  }\n+\n+  // Destructuring assignments in export statements have more fine-grained\n+  // filtering, so we include all identifiers in the expression as dependencies.\n   if (\n+    withinExportStatement &&",
        "comment_created_at": "2024-09-30T03:49:24+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "This code was already targeting export statements specifically, it just wasn't explicitly scoped in the code. Now that we have much more general tracing of dependencies above, we can scope this extra check much more aggressively.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1509921332",
    "pr_number": 11319,
    "pr_file": "packages/router/router.ts",
    "created_at": "2024-03-02T08:35:13+00:00",
    "commented_code": "}\n   }\n \n+  type MatchNode = {\n+    match: AgnosticDataRouteMatch\n+    ancestor?: MatchNode\n+    descendents: MatchNode[]\n+  }\n+\n+  function createMatcherForest(matches: AgnosticDataRouteMatch[]): MatchNode[] {",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1509921332",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 11319,
        "pr_file": "packages/router/router.ts",
        "discussion_id": "1509921332",
        "commented_code": "@@ -2419,29 +2421,127 @@ export function createRouter(init: RouterInit): Router {\n     }\n   }\n \n+  type MatchNode = {\n+    match: AgnosticDataRouteMatch\n+    ancestor?: MatchNode\n+    descendents: MatchNode[]\n+  }\n+\n+  function createMatcherForest(matches: AgnosticDataRouteMatch[]): MatchNode[] {",
        "comment_created_at": "2024-03-02T08:35:13+00:00",
        "comment_author": "steinybot",
        "comment_body": "This is possibly overkill but I didn't want to assume that the matches were in any particular order or that matches were strictly limited to a single path (in graph theory terms) even though that probably is the case (although the found router allows for multiple paths which is actually quite nice in some cases so I'd leave that capability in here since there is pretty much zero cost to it).",
        "pr_file_module": null
      }
    ]
  }
]