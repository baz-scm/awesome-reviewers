[
  {
    "discussion_id": "2208272699",
    "pr_number": 14002,
    "pr_file": "docs/api/declarative-routers/unstable_HistoryRouter.md",
    "created_at": "2025-07-15T18:11:48+00:00",
    "commented_code": "----\n-title: HistoryRouter",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2208272699",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 14002,
        "pr_file": "docs/api/declarative-routers/unstable_HistoryRouter.md",
        "discussion_id": "2208272699",
        "commented_code": "@@ -1,36 +0,0 @@\n----\n-title: HistoryRouter",
        "comment_created_at": "2025-07-15T18:11:48+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "This will now be auto-generated as just `HistoryRouter.md` so the URL stays stable even if we ever stabilize the API (which we won't in this case, but now it's consistent with how we handle `usePrompt` and others)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200674939",
    "pr_number": 13971,
    "pr_file": "docs/how-to/react-server-components.md",
    "created_at": "2025-07-11T13:01:48+00:00",
    "commented_code": "---\n-title: React Server Components\n-# need to ship it first!\n-hidden: true\n+title: React Server Components (unstable)\n+unstable: true\n ---\n \n # React Server Components\n \n-<docs-info>This feature is still in development and not yet available.</docs-info>\n+[MODES: data]\n \n-In the future, async components can be rendered in loaders like any other data:\n+<br/>\n+<br/>\n \n-```tsx filename=app/product-page.tsx\n-// route(\"products/:pid\", \"./product-page.tsx\");\n-import type { Route } from \"./+types/product\";\n-import Product from \"./product\";\n-import Reviews from \"./reviews\";\n+<docs-warning>React Server Components support is experimental and subject to breaking changes.</docs-warning>\n \n-export async function loader({ params }: Route.LoaderArgs) {\n-  return {\n-    product: <Product id={params.pid} />,\n-    reviews: <Reviews productId={params.pid} />,\n-  };\n+React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19.\n+\n+From the docs:\n+\n+> Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.\n+> <cite>- [React \"Server Components\" docs][react-server-components-doc]</cite>\n+\n+React Router provides a set of APIs for integrating with RSC-native bundlers, allowing you to leverage [Server Components][react-server-components-doc] and [Server Functions][react-server-functions-doc] in your React Router applications.\n+\n+## Quick Start\n+\n+The quickest way to get started is with one of our templates.\n+\n+These templates come with React Router RSC APIs already configured with the respective bundler, offering you out of the box features such as:\n+\n+- Server Components Routes\n+- Server Side Rendering (SSR)\n+- Client Components (via [`\"use client\"`][use-client-docs] directive)\n+- Server Functions (via [`\"use server\"`][use-server-docs] directive)\n+\n+**Parcel Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-parcel\n+```\n+\n+**Vite Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-vite\n+```\n+\n+## Using RSC with React Router\n+\n+### Configuring Routes\n+\n+Routes are configured as an argument to [`matchRSCServerRequest`][match-rsc-server-request]. At a minimum, you need a path and component:\n+\n+```tsx\n+function Root() {\n+  return <h1>Hello world</h1>;\n+}\n+\n+matchRSCServerRequest({\n+  // ...other options\n+  routes: [{ path: \"/\", Component: Root }],\n+});\n+```\n+\n+While you can define components inline, we recommend using the `lazy()` option and defining [Route Modules][route-module] for both startup performance and code organization\n+\n+<docs-info>\n+\n+The [Route Modules][route-module] up until now have been a [Framework Mode][framework-mode] only feature. However, the `lazy` field of the RSC route config expects the same exports as the Route Module exports, unifying the APIs even further.\n+\n+</docs-info>\n+\n+```tsx filename=app/routes.ts\n+import type { unstable_RSCRouteConfig as RSCRouteConfig } from \"react-router\";\n+\n+export function routes() {\n+  return [\n+    {\n+      id: \"root\",\n+      path: \"\",\n+      lazy: () => import(\"./root/route\"),\n+      children: [\n+        {\n+          id: \"home\",\n+          index: true,\n+          lazy: () => import(\"./home/route\"),\n+        },\n+        {\n+          id: \"about\",\n+          path: \"about\",\n+          lazy: () => import(\"./about/route\"),\n+        },\n+      ],\n+    },\n+  ] satisfies RSCRouteConfig;\n }\n+```\n \n-export default function ProductPage({\n-  loaderData,\n-}: Route.ComponentProps) {\n+### Server Component Routes\n+\n+By default each route's `default` export renders a Server Component\n+\n+```tsx\n+export default function Home() {\n   return (\n-    <div>\n-      {loaderData.product}\n-      <Suspense fallback={<div>loading...</div>}>\n-        {loaderData.reviews}\n-      </Suspense>\n-    </div>\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+      </article>\n+    </main>\n   );\n }\n ```\n \n-```tsx filename=app/product.tsx\n-export async function Product({ id }: { id: string }) {\n-  const product = await fakeDb.getProduct(id);\n+A nice feature of Server Components is that you can fetch data directly from your component by making it asynchronous.\n+\n+```tsx\n+export default async function Home() {\n+  let user = await getUserData();\n+\n+  return (\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+        <p>\n+          Hello, {user ? user.name : \"anonymous person\"}!\n+        </p>\n+      </article>\n+    </main>\n+  );\n+}\n+```\n+\n+<docs-info>\n+\n+Server Components can also be returned from your loaders and actions. In general, if you are using RSC to build your application, loaders are primarily useful for things like setting `status` codes or return `redirect`s.\n+\n+Using Server Components in loaders can be helpful for incremental adoption of RSC.\n+\n+</docs-info>\n+\n+### Server Functions\n+\n+[Server Functions][react-server-functions-doc] are a React feature that allow you to call async functions executed on the server. They're defined with the [`\"use server\"`][use-server-docs] directive.\n+\n+```tsx\n+\"use server\";\n+\n+export async function updateFavorite(formData: FormData) {\n+  let movieId = formData.get(\"id\");\n+  let intent = formData.get(\"intent\");\n+  if (intent === \"add\") {\n+    await addFavorite(Number(movieId));\n+  } else {\n+    await removeFavorite(Number(movieId));\n+  }\n+}\n+import { updateFavorite } from \"./action.ts\";\n+```\n+\n+```tsx\n+export async function AddToFavoritesForm({\n+  movieId,\n+}: {\n+  movieId: number;\n+}) {\n+  let isFav = await isFavorite(movieId);\n   return (\n-    <div>\n-      <h1>{product.title}</h1>\n-      <p>{product.description}</p>\n-    </div>\n+    <form action={updateFavorite}>\n+      <input type=\"hidden\" name=\"id\" value={movieId} />\n+      <input\n+        type=\"hidden\"\n+        name=\"intent\"\n+        value={isFav ? \"remove\" : \"add\"}\n+      />\n+      <AddToFavoritesButton isFav={isFav} />\n+    </form>\n   );\n }\n ```\n+\n+Note that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation.\n+\n+### Client Properties\n+\n+Routes are defined on the server at runtime, but we can still provide `clientLoader`, `clientAction`, and `shouldRevalidate` through the utilization of client references and `\"use client\"`.\n+\n+```tsx filename=src/routes/root/client.tsx\n+\"use client\";\n+\n+export function clientAction() {}\n+\n+export function clientLoader() {}\n+\n+export function shouldRevalidate() {}\n+```\n+\n+We can then re-export these from our lazy loaded route module:\n+\n+```tsx filename=src/routes/root/route.tsx\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // ...\n+}\n+```\n+\n+This is also the way we would make an entire route a Client Component.\n+\n+```tsx filename=src/routes/root/route.tsx lines=[6,11]\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+  default as ClientRoot,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // Adding a Server Component at the root is required by bundlers\n+  // if you're using css side-effects imports.\n+  return <ClientRoot />;\n+}\n+```\n+\n+## Configuring RSC with React Router\n+\n+React Router provides several APIs that allow you to easily integrate with RSC-native bundlers, useful if you are using React Router data mode to make your own [custom framework][custom-framework].\n+\n+### Entry points\n+\n+React Server Components require 3 things:\n+\n+1. A server to handle the request and convert the RSC payload into HTML\n+2. A React server to generate RSC payloads\n+3. A client handler to hydrate the generated HTML and set the `callServer` function to support post-hydration server actions\n+\n+The following naming conventions have been chosen for familiarity and simplicity. Feel free to name and configure your entry points as you see fit.\n+\n+See the relevant bundler documentation below for specific code examples for each of the following entry points.\n+\n+These examples all use [express][express] and [@mjackson/node-fetch-server][node-fetch-server] for the server and request handling.\n+\n+**Server**\n+\n+<docs-info>\n+\n+You don't have to use SSR at all. You can choose to use RSC to \"prerender\" HTML for Static Site Generation (SSG) or something like Incremental Static Regeneration (ISR).\n+\n+</docs-info>\n+\n+`entry.ssr.tsx` is the entry point for the server. It is responsible for handling the request, calling the RSC server, and converting the RSC payload into HTML on document requests (server-side rendering).\n+\n+Relevant APIs:\n+\n+- [`routeRSCServerRequest`][route-rsc-server-request]\n+- [`RSCStaticRouter`][rsc-static-router]\n+\n+**RSC Server**\n+\n+<docs-info>\n+\n+Even though you have a \"React Server\" and a server responsible for request handling/SSR, you don't actually need to have 2 separate servers. You can simply have 2 separate module graphs within the same server. This is important because React behaves differently when generating RSC payloads vs. when generating HTML to be hydrated on the client.\n+\n+</docs-info>\n+\n+`entry.rsc.tsx` is the entry point for the React Server. It is responsible for matching the request to a route and generating RSC payloads.\n+\n+Relevant APIs:\n+\n+- [`matchRSCServerRequest`][match-rsc-server-request]\n+\n+**Client**\n+\n+`entry.client.tsx` is the entry point for the client. It is responsible for hydrating the generated HTML and setting the `callServer` function to support post-hydration server actions.",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2200674939",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13971,
        "pr_file": "docs/how-to/react-server-components.md",
        "discussion_id": "2200674939",
        "commented_code": "@@ -1,50 +1,738 @@\n ---\n-title: React Server Components\n-# need to ship it first!\n-hidden: true\n+title: React Server Components (unstable)\n+unstable: true\n ---\n \n # React Server Components\n \n-<docs-info>This feature is still in development and not yet available.</docs-info>\n+[MODES: data]\n \n-In the future, async components can be rendered in loaders like any other data:\n+<br/>\n+<br/>\n \n-```tsx filename=app/product-page.tsx\n-// route(\"products/:pid\", \"./product-page.tsx\");\n-import type { Route } from \"./+types/product\";\n-import Product from \"./product\";\n-import Reviews from \"./reviews\";\n+<docs-warning>React Server Components support is experimental and subject to breaking changes.</docs-warning>\n \n-export async function loader({ params }: Route.LoaderArgs) {\n-  return {\n-    product: <Product id={params.pid} />,\n-    reviews: <Reviews productId={params.pid} />,\n-  };\n+React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19.\n+\n+From the docs:\n+\n+> Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.\n+> <cite>- [React \"Server Components\" docs][react-server-components-doc]</cite>\n+\n+React Router provides a set of APIs for integrating with RSC-native bundlers, allowing you to leverage [Server Components][react-server-components-doc] and [Server Functions][react-server-functions-doc] in your React Router applications.\n+\n+## Quick Start\n+\n+The quickest way to get started is with one of our templates.\n+\n+These templates come with React Router RSC APIs already configured with the respective bundler, offering you out of the box features such as:\n+\n+- Server Components Routes\n+- Server Side Rendering (SSR)\n+- Client Components (via [`\"use client\"`][use-client-docs] directive)\n+- Server Functions (via [`\"use server\"`][use-server-docs] directive)\n+\n+**Parcel Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-parcel\n+```\n+\n+**Vite Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-vite\n+```\n+\n+## Using RSC with React Router\n+\n+### Configuring Routes\n+\n+Routes are configured as an argument to [`matchRSCServerRequest`][match-rsc-server-request]. At a minimum, you need a path and component:\n+\n+```tsx\n+function Root() {\n+  return <h1>Hello world</h1>;\n+}\n+\n+matchRSCServerRequest({\n+  // ...other options\n+  routes: [{ path: \"/\", Component: Root }],\n+});\n+```\n+\n+While you can define components inline, we recommend using the `lazy()` option and defining [Route Modules][route-module] for both startup performance and code organization\n+\n+<docs-info>\n+\n+The [Route Modules][route-module] up until now have been a [Framework Mode][framework-mode] only feature. However, the `lazy` field of the RSC route config expects the same exports as the Route Module exports, unifying the APIs even further.\n+\n+</docs-info>\n+\n+```tsx filename=app/routes.ts\n+import type { unstable_RSCRouteConfig as RSCRouteConfig } from \"react-router\";\n+\n+export function routes() {\n+  return [\n+    {\n+      id: \"root\",\n+      path: \"\",\n+      lazy: () => import(\"./root/route\"),\n+      children: [\n+        {\n+          id: \"home\",\n+          index: true,\n+          lazy: () => import(\"./home/route\"),\n+        },\n+        {\n+          id: \"about\",\n+          path: \"about\",\n+          lazy: () => import(\"./about/route\"),\n+        },\n+      ],\n+    },\n+  ] satisfies RSCRouteConfig;\n }\n+```\n \n-export default function ProductPage({\n-  loaderData,\n-}: Route.ComponentProps) {\n+### Server Component Routes\n+\n+By default each route's `default` export renders a Server Component\n+\n+```tsx\n+export default function Home() {\n   return (\n-    <div>\n-      {loaderData.product}\n-      <Suspense fallback={<div>loading...</div>}>\n-        {loaderData.reviews}\n-      </Suspense>\n-    </div>\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+      </article>\n+    </main>\n   );\n }\n ```\n \n-```tsx filename=app/product.tsx\n-export async function Product({ id }: { id: string }) {\n-  const product = await fakeDb.getProduct(id);\n+A nice feature of Server Components is that you can fetch data directly from your component by making it asynchronous.\n+\n+```tsx\n+export default async function Home() {\n+  let user = await getUserData();\n+\n+  return (\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+        <p>\n+          Hello, {user ? user.name : \"anonymous person\"}!\n+        </p>\n+      </article>\n+    </main>\n+  );\n+}\n+```\n+\n+<docs-info>\n+\n+Server Components can also be returned from your loaders and actions. In general, if you are using RSC to build your application, loaders are primarily useful for things like setting `status` codes or return `redirect`s.\n+\n+Using Server Components in loaders can be helpful for incremental adoption of RSC.\n+\n+</docs-info>\n+\n+### Server Functions\n+\n+[Server Functions][react-server-functions-doc] are a React feature that allow you to call async functions executed on the server. They're defined with the [`\"use server\"`][use-server-docs] directive.\n+\n+```tsx\n+\"use server\";\n+\n+export async function updateFavorite(formData: FormData) {\n+  let movieId = formData.get(\"id\");\n+  let intent = formData.get(\"intent\");\n+  if (intent === \"add\") {\n+    await addFavorite(Number(movieId));\n+  } else {\n+    await removeFavorite(Number(movieId));\n+  }\n+}\n+import { updateFavorite } from \"./action.ts\";\n+```\n+\n+```tsx\n+export async function AddToFavoritesForm({\n+  movieId,\n+}: {\n+  movieId: number;\n+}) {\n+  let isFav = await isFavorite(movieId);\n   return (\n-    <div>\n-      <h1>{product.title}</h1>\n-      <p>{product.description}</p>\n-    </div>\n+    <form action={updateFavorite}>\n+      <input type=\"hidden\" name=\"id\" value={movieId} />\n+      <input\n+        type=\"hidden\"\n+        name=\"intent\"\n+        value={isFav ? \"remove\" : \"add\"}\n+      />\n+      <AddToFavoritesButton isFav={isFav} />\n+    </form>\n   );\n }\n ```\n+\n+Note that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation.\n+\n+### Client Properties\n+\n+Routes are defined on the server at runtime, but we can still provide `clientLoader`, `clientAction`, and `shouldRevalidate` through the utilization of client references and `\"use client\"`.\n+\n+```tsx filename=src/routes/root/client.tsx\n+\"use client\";\n+\n+export function clientAction() {}\n+\n+export function clientLoader() {}\n+\n+export function shouldRevalidate() {}\n+```\n+\n+We can then re-export these from our lazy loaded route module:\n+\n+```tsx filename=src/routes/root/route.tsx\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // ...\n+}\n+```\n+\n+This is also the way we would make an entire route a Client Component.\n+\n+```tsx filename=src/routes/root/route.tsx lines=[6,11]\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+  default as ClientRoot,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // Adding a Server Component at the root is required by bundlers\n+  // if you're using css side-effects imports.\n+  return <ClientRoot />;\n+}\n+```\n+\n+## Configuring RSC with React Router\n+\n+React Router provides several APIs that allow you to easily integrate with RSC-native bundlers, useful if you are using React Router data mode to make your own [custom framework][custom-framework].\n+\n+### Entry points\n+\n+React Server Components require 3 things:\n+\n+1. A server to handle the request and convert the RSC payload into HTML\n+2. A React server to generate RSC payloads\n+3. A client handler to hydrate the generated HTML and set the `callServer` function to support post-hydration server actions\n+\n+The following naming conventions have been chosen for familiarity and simplicity. Feel free to name and configure your entry points as you see fit.\n+\n+See the relevant bundler documentation below for specific code examples for each of the following entry points.\n+\n+These examples all use [express][express] and [@mjackson/node-fetch-server][node-fetch-server] for the server and request handling.\n+\n+**Server**\n+\n+<docs-info>\n+\n+You don't have to use SSR at all. You can choose to use RSC to \"prerender\" HTML for Static Site Generation (SSG) or something like Incremental Static Regeneration (ISR).\n+\n+</docs-info>\n+\n+`entry.ssr.tsx` is the entry point for the server. It is responsible for handling the request, calling the RSC server, and converting the RSC payload into HTML on document requests (server-side rendering).\n+\n+Relevant APIs:\n+\n+- [`routeRSCServerRequest`][route-rsc-server-request]\n+- [`RSCStaticRouter`][rsc-static-router]\n+\n+**RSC Server**\n+\n+<docs-info>\n+\n+Even though you have a \"React Server\" and a server responsible for request handling/SSR, you don't actually need to have 2 separate servers. You can simply have 2 separate module graphs within the same server. This is important because React behaves differently when generating RSC payloads vs. when generating HTML to be hydrated on the client.\n+\n+</docs-info>\n+\n+`entry.rsc.tsx` is the entry point for the React Server. It is responsible for matching the request to a route and generating RSC payloads.\n+\n+Relevant APIs:\n+\n+- [`matchRSCServerRequest`][match-rsc-server-request]\n+\n+**Client**\n+\n+`entry.client.tsx` is the entry point for the client. It is responsible for hydrating the generated HTML and setting the `callServer` function to support post-hydration server actions.",
        "comment_created_at": "2025-07-11T13:01:48+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Nit - we use the term \"browser\" in our code and repo playgrounds/templates.  I think the original motivation was to avoid any confusion of the SSR Server being a \"client\" of the RSC server.  I'm happy with either, but if we go with client it's probably worth updating our internal code to align.",
        "pr_file_module": null
      },
      {
        "comment_id": "2200787055",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13971,
        "pr_file": "docs/how-to/react-server-components.md",
        "discussion_id": "2200674939",
        "commented_code": "@@ -1,50 +1,738 @@\n ---\n-title: React Server Components\n-# need to ship it first!\n-hidden: true\n+title: React Server Components (unstable)\n+unstable: true\n ---\n \n # React Server Components\n \n-<docs-info>This feature is still in development and not yet available.</docs-info>\n+[MODES: data]\n \n-In the future, async components can be rendered in loaders like any other data:\n+<br/>\n+<br/>\n \n-```tsx filename=app/product-page.tsx\n-// route(\"products/:pid\", \"./product-page.tsx\");\n-import type { Route } from \"./+types/product\";\n-import Product from \"./product\";\n-import Reviews from \"./reviews\";\n+<docs-warning>React Server Components support is experimental and subject to breaking changes.</docs-warning>\n \n-export async function loader({ params }: Route.LoaderArgs) {\n-  return {\n-    product: <Product id={params.pid} />,\n-    reviews: <Reviews productId={params.pid} />,\n-  };\n+React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19.\n+\n+From the docs:\n+\n+> Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.\n+> <cite>- [React \"Server Components\" docs][react-server-components-doc]</cite>\n+\n+React Router provides a set of APIs for integrating with RSC-native bundlers, allowing you to leverage [Server Components][react-server-components-doc] and [Server Functions][react-server-functions-doc] in your React Router applications.\n+\n+## Quick Start\n+\n+The quickest way to get started is with one of our templates.\n+\n+These templates come with React Router RSC APIs already configured with the respective bundler, offering you out of the box features such as:\n+\n+- Server Components Routes\n+- Server Side Rendering (SSR)\n+- Client Components (via [`\"use client\"`][use-client-docs] directive)\n+- Server Functions (via [`\"use server\"`][use-server-docs] directive)\n+\n+**Parcel Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-parcel\n+```\n+\n+**Vite Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-vite\n+```\n+\n+## Using RSC with React Router\n+\n+### Configuring Routes\n+\n+Routes are configured as an argument to [`matchRSCServerRequest`][match-rsc-server-request]. At a minimum, you need a path and component:\n+\n+```tsx\n+function Root() {\n+  return <h1>Hello world</h1>;\n+}\n+\n+matchRSCServerRequest({\n+  // ...other options\n+  routes: [{ path: \"/\", Component: Root }],\n+});\n+```\n+\n+While you can define components inline, we recommend using the `lazy()` option and defining [Route Modules][route-module] for both startup performance and code organization\n+\n+<docs-info>\n+\n+The [Route Modules][route-module] up until now have been a [Framework Mode][framework-mode] only feature. However, the `lazy` field of the RSC route config expects the same exports as the Route Module exports, unifying the APIs even further.\n+\n+</docs-info>\n+\n+```tsx filename=app/routes.ts\n+import type { unstable_RSCRouteConfig as RSCRouteConfig } from \"react-router\";\n+\n+export function routes() {\n+  return [\n+    {\n+      id: \"root\",\n+      path: \"\",\n+      lazy: () => import(\"./root/route\"),\n+      children: [\n+        {\n+          id: \"home\",\n+          index: true,\n+          lazy: () => import(\"./home/route\"),\n+        },\n+        {\n+          id: \"about\",\n+          path: \"about\",\n+          lazy: () => import(\"./about/route\"),\n+        },\n+      ],\n+    },\n+  ] satisfies RSCRouteConfig;\n }\n+```\n \n-export default function ProductPage({\n-  loaderData,\n-}: Route.ComponentProps) {\n+### Server Component Routes\n+\n+By default each route's `default` export renders a Server Component\n+\n+```tsx\n+export default function Home() {\n   return (\n-    <div>\n-      {loaderData.product}\n-      <Suspense fallback={<div>loading...</div>}>\n-        {loaderData.reviews}\n-      </Suspense>\n-    </div>\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+      </article>\n+    </main>\n   );\n }\n ```\n \n-```tsx filename=app/product.tsx\n-export async function Product({ id }: { id: string }) {\n-  const product = await fakeDb.getProduct(id);\n+A nice feature of Server Components is that you can fetch data directly from your component by making it asynchronous.\n+\n+```tsx\n+export default async function Home() {\n+  let user = await getUserData();\n+\n+  return (\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+        <p>\n+          Hello, {user ? user.name : \"anonymous person\"}!\n+        </p>\n+      </article>\n+    </main>\n+  );\n+}\n+```\n+\n+<docs-info>\n+\n+Server Components can also be returned from your loaders and actions. In general, if you are using RSC to build your application, loaders are primarily useful for things like setting `status` codes or return `redirect`s.\n+\n+Using Server Components in loaders can be helpful for incremental adoption of RSC.\n+\n+</docs-info>\n+\n+### Server Functions\n+\n+[Server Functions][react-server-functions-doc] are a React feature that allow you to call async functions executed on the server. They're defined with the [`\"use server\"`][use-server-docs] directive.\n+\n+```tsx\n+\"use server\";\n+\n+export async function updateFavorite(formData: FormData) {\n+  let movieId = formData.get(\"id\");\n+  let intent = formData.get(\"intent\");\n+  if (intent === \"add\") {\n+    await addFavorite(Number(movieId));\n+  } else {\n+    await removeFavorite(Number(movieId));\n+  }\n+}\n+import { updateFavorite } from \"./action.ts\";\n+```\n+\n+```tsx\n+export async function AddToFavoritesForm({\n+  movieId,\n+}: {\n+  movieId: number;\n+}) {\n+  let isFav = await isFavorite(movieId);\n   return (\n-    <div>\n-      <h1>{product.title}</h1>\n-      <p>{product.description}</p>\n-    </div>\n+    <form action={updateFavorite}>\n+      <input type=\"hidden\" name=\"id\" value={movieId} />\n+      <input\n+        type=\"hidden\"\n+        name=\"intent\"\n+        value={isFav ? \"remove\" : \"add\"}\n+      />\n+      <AddToFavoritesButton isFav={isFav} />\n+    </form>\n   );\n }\n ```\n+\n+Note that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation.\n+\n+### Client Properties\n+\n+Routes are defined on the server at runtime, but we can still provide `clientLoader`, `clientAction`, and `shouldRevalidate` through the utilization of client references and `\"use client\"`.\n+\n+```tsx filename=src/routes/root/client.tsx\n+\"use client\";\n+\n+export function clientAction() {}\n+\n+export function clientLoader() {}\n+\n+export function shouldRevalidate() {}\n+```\n+\n+We can then re-export these from our lazy loaded route module:\n+\n+```tsx filename=src/routes/root/route.tsx\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // ...\n+}\n+```\n+\n+This is also the way we would make an entire route a Client Component.\n+\n+```tsx filename=src/routes/root/route.tsx lines=[6,11]\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+  default as ClientRoot,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // Adding a Server Component at the root is required by bundlers\n+  // if you're using css side-effects imports.\n+  return <ClientRoot />;\n+}\n+```\n+\n+## Configuring RSC with React Router\n+\n+React Router provides several APIs that allow you to easily integrate with RSC-native bundlers, useful if you are using React Router data mode to make your own [custom framework][custom-framework].\n+\n+### Entry points\n+\n+React Server Components require 3 things:\n+\n+1. A server to handle the request and convert the RSC payload into HTML\n+2. A React server to generate RSC payloads\n+3. A client handler to hydrate the generated HTML and set the `callServer` function to support post-hydration server actions\n+\n+The following naming conventions have been chosen for familiarity and simplicity. Feel free to name and configure your entry points as you see fit.\n+\n+See the relevant bundler documentation below for specific code examples for each of the following entry points.\n+\n+These examples all use [express][express] and [@mjackson/node-fetch-server][node-fetch-server] for the server and request handling.\n+\n+**Server**\n+\n+<docs-info>\n+\n+You don't have to use SSR at all. You can choose to use RSC to \"prerender\" HTML for Static Site Generation (SSG) or something like Incremental Static Regeneration (ISR).\n+\n+</docs-info>\n+\n+`entry.ssr.tsx` is the entry point for the server. It is responsible for handling the request, calling the RSC server, and converting the RSC payload into HTML on document requests (server-side rendering).\n+\n+Relevant APIs:\n+\n+- [`routeRSCServerRequest`][route-rsc-server-request]\n+- [`RSCStaticRouter`][rsc-static-router]\n+\n+**RSC Server**\n+\n+<docs-info>\n+\n+Even though you have a \"React Server\" and a server responsible for request handling/SSR, you don't actually need to have 2 separate servers. You can simply have 2 separate module graphs within the same server. This is important because React behaves differently when generating RSC payloads vs. when generating HTML to be hydrated on the client.\n+\n+</docs-info>\n+\n+`entry.rsc.tsx` is the entry point for the React Server. It is responsible for matching the request to a route and generating RSC payloads.\n+\n+Relevant APIs:\n+\n+- [`matchRSCServerRequest`][match-rsc-server-request]\n+\n+**Client**\n+\n+`entry.client.tsx` is the entry point for the client. It is responsible for hydrating the generated HTML and setting the `callServer` function to support post-hydration server actions.",
        "comment_created_at": "2025-07-11T13:43:29+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "Ah okay, yeah I think I went with client just because it aligned with what Vite had, but honestly that's no the best reason.\r\n\r\nI think browser is more clear anyway, since that's really the client we're talking about in this context. I'll update this doc and the templates",
        "pr_file_module": null
      },
      {
        "comment_id": "2200814786",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13971,
        "pr_file": "docs/how-to/react-server-components.md",
        "discussion_id": "2200674939",
        "commented_code": "@@ -1,50 +1,738 @@\n ---\n-title: React Server Components\n-# need to ship it first!\n-hidden: true\n+title: React Server Components (unstable)\n+unstable: true\n ---\n \n # React Server Components\n \n-<docs-info>This feature is still in development and not yet available.</docs-info>\n+[MODES: data]\n \n-In the future, async components can be rendered in loaders like any other data:\n+<br/>\n+<br/>\n \n-```tsx filename=app/product-page.tsx\n-// route(\"products/:pid\", \"./product-page.tsx\");\n-import type { Route } from \"./+types/product\";\n-import Product from \"./product\";\n-import Reviews from \"./reviews\";\n+<docs-warning>React Server Components support is experimental and subject to breaking changes.</docs-warning>\n \n-export async function loader({ params }: Route.LoaderArgs) {\n-  return {\n-    product: <Product id={params.pid} />,\n-    reviews: <Reviews productId={params.pid} />,\n-  };\n+React Server Components (RSC) refers generally to an architecture and set of APIs provided by React since version 19.\n+\n+From the docs:\n+\n+> Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.\n+> <cite>- [React \"Server Components\" docs][react-server-components-doc]</cite>\n+\n+React Router provides a set of APIs for integrating with RSC-native bundlers, allowing you to leverage [Server Components][react-server-components-doc] and [Server Functions][react-server-functions-doc] in your React Router applications.\n+\n+## Quick Start\n+\n+The quickest way to get started is with one of our templates.\n+\n+These templates come with React Router RSC APIs already configured with the respective bundler, offering you out of the box features such as:\n+\n+- Server Components Routes\n+- Server Side Rendering (SSR)\n+- Client Components (via [`\"use client\"`][use-client-docs] directive)\n+- Server Functions (via [`\"use server\"`][use-server-docs] directive)\n+\n+**Parcel Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-parcel\n+```\n+\n+**Vite Template**\n+\n+```shellscript\n+npx create-react-router-app@latest --template=unstable_rsc-vite\n+```\n+\n+## Using RSC with React Router\n+\n+### Configuring Routes\n+\n+Routes are configured as an argument to [`matchRSCServerRequest`][match-rsc-server-request]. At a minimum, you need a path and component:\n+\n+```tsx\n+function Root() {\n+  return <h1>Hello world</h1>;\n+}\n+\n+matchRSCServerRequest({\n+  // ...other options\n+  routes: [{ path: \"/\", Component: Root }],\n+});\n+```\n+\n+While you can define components inline, we recommend using the `lazy()` option and defining [Route Modules][route-module] for both startup performance and code organization\n+\n+<docs-info>\n+\n+The [Route Modules][route-module] up until now have been a [Framework Mode][framework-mode] only feature. However, the `lazy` field of the RSC route config expects the same exports as the Route Module exports, unifying the APIs even further.\n+\n+</docs-info>\n+\n+```tsx filename=app/routes.ts\n+import type { unstable_RSCRouteConfig as RSCRouteConfig } from \"react-router\";\n+\n+export function routes() {\n+  return [\n+    {\n+      id: \"root\",\n+      path: \"\",\n+      lazy: () => import(\"./root/route\"),\n+      children: [\n+        {\n+          id: \"home\",\n+          index: true,\n+          lazy: () => import(\"./home/route\"),\n+        },\n+        {\n+          id: \"about\",\n+          path: \"about\",\n+          lazy: () => import(\"./about/route\"),\n+        },\n+      ],\n+    },\n+  ] satisfies RSCRouteConfig;\n }\n+```\n \n-export default function ProductPage({\n-  loaderData,\n-}: Route.ComponentProps) {\n+### Server Component Routes\n+\n+By default each route's `default` export renders a Server Component\n+\n+```tsx\n+export default function Home() {\n   return (\n-    <div>\n-      {loaderData.product}\n-      <Suspense fallback={<div>loading...</div>}>\n-        {loaderData.reviews}\n-      </Suspense>\n-    </div>\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+      </article>\n+    </main>\n   );\n }\n ```\n \n-```tsx filename=app/product.tsx\n-export async function Product({ id }: { id: string }) {\n-  const product = await fakeDb.getProduct(id);\n+A nice feature of Server Components is that you can fetch data directly from your component by making it asynchronous.\n+\n+```tsx\n+export default async function Home() {\n+  let user = await getUserData();\n+\n+  return (\n+    <main>\n+      <article>\n+        <h1>Welcome to React Router RSC</h1>\n+        <p>\n+          You won't find me running any JavaScript in the\n+          browser!\n+        </p>\n+        <p>\n+          Hello, {user ? user.name : \"anonymous person\"}!\n+        </p>\n+      </article>\n+    </main>\n+  );\n+}\n+```\n+\n+<docs-info>\n+\n+Server Components can also be returned from your loaders and actions. In general, if you are using RSC to build your application, loaders are primarily useful for things like setting `status` codes or return `redirect`s.\n+\n+Using Server Components in loaders can be helpful for incremental adoption of RSC.\n+\n+</docs-info>\n+\n+### Server Functions\n+\n+[Server Functions][react-server-functions-doc] are a React feature that allow you to call async functions executed on the server. They're defined with the [`\"use server\"`][use-server-docs] directive.\n+\n+```tsx\n+\"use server\";\n+\n+export async function updateFavorite(formData: FormData) {\n+  let movieId = formData.get(\"id\");\n+  let intent = formData.get(\"intent\");\n+  if (intent === \"add\") {\n+    await addFavorite(Number(movieId));\n+  } else {\n+    await removeFavorite(Number(movieId));\n+  }\n+}\n+import { updateFavorite } from \"./action.ts\";\n+```\n+\n+```tsx\n+export async function AddToFavoritesForm({\n+  movieId,\n+}: {\n+  movieId: number;\n+}) {\n+  let isFav = await isFavorite(movieId);\n   return (\n-    <div>\n-      <h1>{product.title}</h1>\n-      <p>{product.description}</p>\n-    </div>\n+    <form action={updateFavorite}>\n+      <input type=\"hidden\" name=\"id\" value={movieId} />\n+      <input\n+        type=\"hidden\"\n+        name=\"intent\"\n+        value={isFav ? \"remove\" : \"add\"}\n+      />\n+      <AddToFavoritesButton isFav={isFav} />\n+    </form>\n   );\n }\n ```\n+\n+Note that after server functions are called, React Router will automatically revalidate the route and update the UI with the new server content. You don't have to mess around with any cache invalidation.\n+\n+### Client Properties\n+\n+Routes are defined on the server at runtime, but we can still provide `clientLoader`, `clientAction`, and `shouldRevalidate` through the utilization of client references and `\"use client\"`.\n+\n+```tsx filename=src/routes/root/client.tsx\n+\"use client\";\n+\n+export function clientAction() {}\n+\n+export function clientLoader() {}\n+\n+export function shouldRevalidate() {}\n+```\n+\n+We can then re-export these from our lazy loaded route module:\n+\n+```tsx filename=src/routes/root/route.tsx\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // ...\n+}\n+```\n+\n+This is also the way we would make an entire route a Client Component.\n+\n+```tsx filename=src/routes/root/route.tsx lines=[6,11]\n+export {\n+  clientAction,\n+  clientLoader,\n+  shouldRevalidate,\n+  default as ClientRoot,\n+} from \"./route.client\";\n+\n+export default function Root() {\n+  // Adding a Server Component at the root is required by bundlers\n+  // if you're using css side-effects imports.\n+  return <ClientRoot />;\n+}\n+```\n+\n+## Configuring RSC with React Router\n+\n+React Router provides several APIs that allow you to easily integrate with RSC-native bundlers, useful if you are using React Router data mode to make your own [custom framework][custom-framework].\n+\n+### Entry points\n+\n+React Server Components require 3 things:\n+\n+1. A server to handle the request and convert the RSC payload into HTML\n+2. A React server to generate RSC payloads\n+3. A client handler to hydrate the generated HTML and set the `callServer` function to support post-hydration server actions\n+\n+The following naming conventions have been chosen for familiarity and simplicity. Feel free to name and configure your entry points as you see fit.\n+\n+See the relevant bundler documentation below for specific code examples for each of the following entry points.\n+\n+These examples all use [express][express] and [@mjackson/node-fetch-server][node-fetch-server] for the server and request handling.\n+\n+**Server**\n+\n+<docs-info>\n+\n+You don't have to use SSR at all. You can choose to use RSC to \"prerender\" HTML for Static Site Generation (SSG) or something like Incremental Static Regeneration (ISR).\n+\n+</docs-info>\n+\n+`entry.ssr.tsx` is the entry point for the server. It is responsible for handling the request, calling the RSC server, and converting the RSC payload into HTML on document requests (server-side rendering).\n+\n+Relevant APIs:\n+\n+- [`routeRSCServerRequest`][route-rsc-server-request]\n+- [`RSCStaticRouter`][rsc-static-router]\n+\n+**RSC Server**\n+\n+<docs-info>\n+\n+Even though you have a \"React Server\" and a server responsible for request handling/SSR, you don't actually need to have 2 separate servers. You can simply have 2 separate module graphs within the same server. This is important because React behaves differently when generating RSC payloads vs. when generating HTML to be hydrated on the client.\n+\n+</docs-info>\n+\n+`entry.rsc.tsx` is the entry point for the React Server. It is responsible for matching the request to a route and generating RSC payloads.\n+\n+Relevant APIs:\n+\n+- [`matchRSCServerRequest`][match-rsc-server-request]\n+\n+**Client**\n+\n+`entry.client.tsx` is the entry point for the client. It is responsible for hydrating the generated HTML and setting the `callServer` function to support post-hydration server actions.",
        "comment_created_at": "2025-07-11T13:57:12+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "Alright, updated! Thanks @brophdawg11 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1823420312",
    "pr_number": 12210,
    "pr_file": "docs/explanation/type-safety.md",
    "created_at": "2024-10-30T21:32:31+00:00",
    "commented_code": "+---\n+title: Type safety\n+---\n+\n+# Type safety\n+\n+React Router generates types for each route in your app that you can use to get type safety for each route module export.\n+\n+For example, let's say you have a `products/:id` route configured:\n+\n+```ts filename=app/routes.ts\n+import {\n+  type RouteConfig,\n+  route,\n+} from \"@react-router/dev/routes\";\n+\n+export const routes: RouteConfig = [\n+  route(\"products/:id\", \"./routes/product.tsx\"),\n+];\n+```\n+\n+Then, you can import route-specific types like so:\n+\n+```tsx filename=app/routes/product.tsx\n+import type * as Route from \"./+types.product\";\n+// types generated for this route \ud83d\udc46\n+\n+export function loader({ params }: Route.LoaderArgs) {\n+  //                      \ud83d\udc46 { id: string }\n+  return { planet: `world #${params.id}` };\n+}\n+\n+export default function Component({\n+  loaderData, // \ud83d\udc48 { planet: string }\n+}: Route.ComponentProps) {\n+  return <h1>Hello, {loaderData.planet}!</h1>;\n+}\n+```\n+\n+If you haven't done so already, check out our guide for [setting up type safety][setting-up-type-safety] in a new project.\n+\n+## `typegen` command\n+\n+You can manually generate types with the `typegen` command:\n+\n+```sh\n+react-router typegen\n+```\n+\n+You can also use `--watch` to automatically regenerate types as files change:\n+\n+```sh\n+react-router typegen --watch\n+```\n+\n+The following types are generated for each route:\n+\n+- `LoaderArgs`\n+- `ClientLoaderArgs`\n+- `ActionArgs`\n+- `ClientActionArgs`\n+- `HydrateFallbackProps`\n+- `ComponentProps` (for the `default` export)\n+- `ErrorBoundaryProps`\n+\n+## How it works\n+\n+React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app.",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1823420312",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "docs/explanation/type-safety.md",
        "discussion_id": "1823420312",
        "commented_code": "@@ -0,0 +1,74 @@\n+---\n+title: Type safety\n+---\n+\n+# Type safety\n+\n+React Router generates types for each route in your app that you can use to get type safety for each route module export.\n+\n+For example, let's say you have a `products/:id` route configured:\n+\n+```ts filename=app/routes.ts\n+import {\n+  type RouteConfig,\n+  route,\n+} from \"@react-router/dev/routes\";\n+\n+export const routes: RouteConfig = [\n+  route(\"products/:id\", \"./routes/product.tsx\"),\n+];\n+```\n+\n+Then, you can import route-specific types like so:\n+\n+```tsx filename=app/routes/product.tsx\n+import type * as Route from \"./+types.product\";\n+// types generated for this route \ud83d\udc46\n+\n+export function loader({ params }: Route.LoaderArgs) {\n+  //                      \ud83d\udc46 { id: string }\n+  return { planet: `world #${params.id}` };\n+}\n+\n+export default function Component({\n+  loaderData, // \ud83d\udc48 { planet: string }\n+}: Route.ComponentProps) {\n+  return <h1>Hello, {loaderData.planet}!</h1>;\n+}\n+```\n+\n+If you haven't done so already, check out our guide for [setting up type safety][setting-up-type-safety] in a new project.\n+\n+## `typegen` command\n+\n+You can manually generate types with the `typegen` command:\n+\n+```sh\n+react-router typegen\n+```\n+\n+You can also use `--watch` to automatically regenerate types as files change:\n+\n+```sh\n+react-router typegen --watch\n+```\n+\n+The following types are generated for each route:\n+\n+- `LoaderArgs`\n+- `ClientLoaderArgs`\n+- `ActionArgs`\n+- `ClientActionArgs`\n+- `HydrateFallbackProps`\n+- `ComponentProps` (for the `default` export)\n+- `ErrorBoundaryProps`\n+\n+## How it works\n+\n+React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app.",
        "comment_created_at": "2024-10-30T21:32:31+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "What does \"executes your route config\" mean? Also, is `app/routes.ts` configurable? I thought it wasn't, and if not we shouldn't say \"by default\". If it is I just need to update my knowledge",
        "pr_file_module": null
      },
      {
        "comment_id": "1823431798",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "docs/explanation/type-safety.md",
        "discussion_id": "1823420312",
        "commented_code": "@@ -0,0 +1,74 @@\n+---\n+title: Type safety\n+---\n+\n+# Type safety\n+\n+React Router generates types for each route in your app that you can use to get type safety for each route module export.\n+\n+For example, let's say you have a `products/:id` route configured:\n+\n+```ts filename=app/routes.ts\n+import {\n+  type RouteConfig,\n+  route,\n+} from \"@react-router/dev/routes\";\n+\n+export const routes: RouteConfig = [\n+  route(\"products/:id\", \"./routes/product.tsx\"),\n+];\n+```\n+\n+Then, you can import route-specific types like so:\n+\n+```tsx filename=app/routes/product.tsx\n+import type * as Route from \"./+types.product\";\n+// types generated for this route \ud83d\udc46\n+\n+export function loader({ params }: Route.LoaderArgs) {\n+  //                      \ud83d\udc46 { id: string }\n+  return { planet: `world #${params.id}` };\n+}\n+\n+export default function Component({\n+  loaderData, // \ud83d\udc48 { planet: string }\n+}: Route.ComponentProps) {\n+  return <h1>Hello, {loaderData.planet}!</h1>;\n+}\n+```\n+\n+If you haven't done so already, check out our guide for [setting up type safety][setting-up-type-safety] in a new project.\n+\n+## `typegen` command\n+\n+You can manually generate types with the `typegen` command:\n+\n+```sh\n+react-router typegen\n+```\n+\n+You can also use `--watch` to automatically regenerate types as files change:\n+\n+```sh\n+react-router typegen --watch\n+```\n+\n+The following types are generated for each route:\n+\n+- `LoaderArgs`\n+- `ClientLoaderArgs`\n+- `ActionArgs`\n+- `ClientActionArgs`\n+- `HydrateFallbackProps`\n+- `ComponentProps` (for the `default` export)\n+- `ErrorBoundaryProps`\n+\n+## How it works\n+\n+React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app.",
        "comment_created_at": "2024-10-30T21:43:37+00:00",
        "comment_author": "pcattori",
        "comment_body": "`app/` is configurable, and you can have other extensions for `route.ts` (`.tsx`, `.js`, `.jsx`) if you want",
        "pr_file_module": null
      },
      {
        "comment_id": "1823434870",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "docs/explanation/type-safety.md",
        "discussion_id": "1823420312",
        "commented_code": "@@ -0,0 +1,74 @@\n+---\n+title: Type safety\n+---\n+\n+# Type safety\n+\n+React Router generates types for each route in your app that you can use to get type safety for each route module export.\n+\n+For example, let's say you have a `products/:id` route configured:\n+\n+```ts filename=app/routes.ts\n+import {\n+  type RouteConfig,\n+  route,\n+} from \"@react-router/dev/routes\";\n+\n+export const routes: RouteConfig = [\n+  route(\"products/:id\", \"./routes/product.tsx\"),\n+];\n+```\n+\n+Then, you can import route-specific types like so:\n+\n+```tsx filename=app/routes/product.tsx\n+import type * as Route from \"./+types.product\";\n+// types generated for this route \ud83d\udc46\n+\n+export function loader({ params }: Route.LoaderArgs) {\n+  //                      \ud83d\udc46 { id: string }\n+  return { planet: `world #${params.id}` };\n+}\n+\n+export default function Component({\n+  loaderData, // \ud83d\udc48 { planet: string }\n+}: Route.ComponentProps) {\n+  return <h1>Hello, {loaderData.planet}!</h1>;\n+}\n+```\n+\n+If you haven't done so already, check out our guide for [setting up type safety][setting-up-type-safety] in a new project.\n+\n+## `typegen` command\n+\n+You can manually generate types with the `typegen` command:\n+\n+```sh\n+react-router typegen\n+```\n+\n+You can also use `--watch` to automatically regenerate types as files change:\n+\n+```sh\n+react-router typegen --watch\n+```\n+\n+The following types are generated for each route:\n+\n+- `LoaderArgs`\n+- `ClientLoaderArgs`\n+- `ActionArgs`\n+- `ClientActionArgs`\n+- `HydrateFallbackProps`\n+- `ComponentProps` (for the `default` export)\n+- `ErrorBoundaryProps`\n+\n+## How it works\n+\n+React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app.",
        "comment_created_at": "2024-10-30T21:47:01+00:00",
        "comment_author": "pcattori",
        "comment_body": "\"executes your route config\" -> runs it with node (technically vite-node so that it can directly run `.ts` file) and looks at the `routes` export",
        "pr_file_module": null
      },
      {
        "comment_id": "1823552353",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "docs/explanation/type-safety.md",
        "discussion_id": "1823420312",
        "commented_code": "@@ -0,0 +1,74 @@\n+---\n+title: Type safety\n+---\n+\n+# Type safety\n+\n+React Router generates types for each route in your app that you can use to get type safety for each route module export.\n+\n+For example, let's say you have a `products/:id` route configured:\n+\n+```ts filename=app/routes.ts\n+import {\n+  type RouteConfig,\n+  route,\n+} from \"@react-router/dev/routes\";\n+\n+export const routes: RouteConfig = [\n+  route(\"products/:id\", \"./routes/product.tsx\"),\n+];\n+```\n+\n+Then, you can import route-specific types like so:\n+\n+```tsx filename=app/routes/product.tsx\n+import type * as Route from \"./+types.product\";\n+// types generated for this route \ud83d\udc46\n+\n+export function loader({ params }: Route.LoaderArgs) {\n+  //                      \ud83d\udc46 { id: string }\n+  return { planet: `world #${params.id}` };\n+}\n+\n+export default function Component({\n+  loaderData, // \ud83d\udc48 { planet: string }\n+}: Route.ComponentProps) {\n+  return <h1>Hello, {loaderData.planet}!</h1>;\n+}\n+```\n+\n+If you haven't done so already, check out our guide for [setting up type safety][setting-up-type-safety] in a new project.\n+\n+## `typegen` command\n+\n+You can manually generate types with the `typegen` command:\n+\n+```sh\n+react-router typegen\n+```\n+\n+You can also use `--watch` to automatically regenerate types as files change:\n+\n+```sh\n+react-router typegen --watch\n+```\n+\n+The following types are generated for each route:\n+\n+- `LoaderArgs`\n+- `ClientLoaderArgs`\n+- `ActionArgs`\n+- `ClientActionArgs`\n+- `HydrateFallbackProps`\n+- `ComponentProps` (for the `default` export)\n+- `ErrorBoundaryProps`\n+\n+## How it works\n+\n+React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app.",
        "comment_created_at": "2024-10-30T22:49:22+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "FWIW I've just been leaning into calling it `routes.ts` and `app/routes.ts` everywhere to avoid this sort of framing which can be confusing. Instead we could make sure to always link to a page with more detail about how it's more complicated than that?",
        "pr_file_module": null
      },
      {
        "comment_id": "1824333031",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "docs/explanation/type-safety.md",
        "discussion_id": "1823420312",
        "commented_code": "@@ -0,0 +1,74 @@\n+---\n+title: Type safety\n+---\n+\n+# Type safety\n+\n+React Router generates types for each route in your app that you can use to get type safety for each route module export.\n+\n+For example, let's say you have a `products/:id` route configured:\n+\n+```ts filename=app/routes.ts\n+import {\n+  type RouteConfig,\n+  route,\n+} from \"@react-router/dev/routes\";\n+\n+export const routes: RouteConfig = [\n+  route(\"products/:id\", \"./routes/product.tsx\"),\n+];\n+```\n+\n+Then, you can import route-specific types like so:\n+\n+```tsx filename=app/routes/product.tsx\n+import type * as Route from \"./+types.product\";\n+// types generated for this route \ud83d\udc46\n+\n+export function loader({ params }: Route.LoaderArgs) {\n+  //                      \ud83d\udc46 { id: string }\n+  return { planet: `world #${params.id}` };\n+}\n+\n+export default function Component({\n+  loaderData, // \ud83d\udc48 { planet: string }\n+}: Route.ComponentProps) {\n+  return <h1>Hello, {loaderData.planet}!</h1>;\n+}\n+```\n+\n+If you haven't done so already, check out our guide for [setting up type safety][setting-up-type-safety] in a new project.\n+\n+## `typegen` command\n+\n+You can manually generate types with the `typegen` command:\n+\n+```sh\n+react-router typegen\n+```\n+\n+You can also use `--watch` to automatically regenerate types as files change:\n+\n+```sh\n+react-router typegen --watch\n+```\n+\n+The following types are generated for each route:\n+\n+- `LoaderArgs`\n+- `ClientLoaderArgs`\n+- `ActionArgs`\n+- `ClientActionArgs`\n+- `HydrateFallbackProps`\n+- `ComponentProps` (for the `default` export)\n+- `ErrorBoundaryProps`\n+\n+## How it works\n+\n+React Router's type generation executes your route config (`app/routes.ts` by default) to determine the routes for your app.",
        "comment_created_at": "2024-10-31T11:59:24+00:00",
        "comment_author": "pcattori",
        "comment_body": "\ud83d\udcaf I'd love to call it \"route config\" and have that link to a _Route Config_ doc that explains it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1878547711",
    "pr_number": 12504,
    "pr_file": "docs/tutorials/framework.md",
    "created_at": "2024-12-10T17:45:00+00:00",
    "commented_code": "+---\n+title: Framework Tutorial\n+order: 1\n+---\n+\n+# Framework Tutorial\n+\n+We'll be building a small, but feature-rich app that lets you keep track of your contacts. There's no database or other \"production ready\" things, so we can stay focused on the features React Router gives you. We expect it to take about 30m if you're following along, otherwise it's a quick read.\n+\n+TODO: add screenshot\n+\n+\ud83d\udc49 **Every time you see this it means you need to do something in the app!**\n+\n+The rest is just there for your information and deeper understanding. Let's get to it.\n+\n+## Setup\n+\n+\ud83d\udc49 **Generate a basic template**\n+\n+```shellscript nonumber\n+npx create-react-router@latest --template remix-run/react-router/tutorial\n+```\n+\n+This uses a pretty bare-bones template but includes our css and data model, so we can focus on React Router.\n+\n+\ud83d\udc49 **Start the app**\n+\n+```shellscript nonumber\n+# cd into the app directory\n+cd {wherever you put the app}\n+\n+# install dependencies if you haven't already\n+npm install\n+\n+# start the server\n+npm run dev\n+```\n+\n+You should be able to open up [http://localhost:5173][http-localhost-5173] and see an unstyled screen that looks like this:\n+\n+<!-- img elements will look will be in the form: <!-- <img class=\"tutorial\" src=\"/_docs/v7_framework_tutorial/n.webp\" /> -->\n+\n+## The Root Route\n+\n+Note the file at `app/root.tsx`. This is what we call the [\"Root Route\"][root-route]. It's the first component in the UI that renders, so it typically contains the global layout for the page, as well as a the default [Error Boundary][error-boundaries].\n+\n+<details>\n+\n+<summary>Expand here to see the root component code</summary>\n+\n+```tsx filename=app/root.tsx\n+import {\n+  Form,\n+  Scripts,\n+  ScrollRestoration,\n+  isRouteErrorResponse,\n+} from \"react-router\";\n+import type { Route } from \"./+types/root\";\n+\n+import appStylesHref from \"./app.css?url\";\n+\n+export function Layout({\n+  children,\n+}: {\n+  children: React.ReactNode;\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <head>\n+        <meta charSet=\"utf-8\" />\n+        <meta\n+          name=\"viewport\"\n+          content=\"width=device-width, initial-scale=1\"\n+        />\n+        <link rel=\"stylesheet\" href={appStylesHref} />\n+      </head>\n+      <body>\n+        {children}\n+        <ScrollRestoration />\n+        <Scripts />\n+      </body>\n+    </html>\n+  );\n+}\n+\n+export default function App() {\n+  return (\n+    <>\n+      <div id=\"sidebar\">\n+        <h1>React Router Contacts</h1>\n+        <div>\n+          <Form id=\"search-form\" role=\"search\">\n+            <input\n+              aria-label=\"Search contacts\"\n+              id=\"q\"\n+              name=\"q\"\n+              placeholder=\"Search\"\n+              type=\"search\"\n+            />\n+            <div\n+              aria-hidden\n+              hidden={true}\n+              id=\"search-spinner\"\n+            />\n+          </Form>\n+          <Form method=\"post\">\n+            <button type=\"submit\">New</button>\n+          </Form>\n+        </div>\n+        <nav>\n+          <ul>\n+            <li>\n+              <a href={`/contacts/1`}>Your Name</a>\n+            </li>\n+            <li>\n+              <a href={`/contacts/2`}>Your Friend</a>\n+            </li>\n+          </ul>\n+        </nav>\n+      </div>\n+    </>\n+  );\n+}\n+\n+export function ErrorBoundary({\n+  error,\n+}: Route.ErrorBoundaryProps) {\n+  let message = \"Oops!\";\n+  let details = \"An unexpected error occurred.\";\n+  let stack: string | undefined;\n+\n+  if (isRouteErrorResponse(error)) {\n+    message = error.status === 404 ? \"404\" : \"Error\";\n+    details =\n+      error.status === 404\n+        ? \"The requested page could not be found.\"\n+        : error.statusText || details;\n+  } else if (\n+    import.meta.env.DEV &&\n+    error &&\n+    error instanceof Error\n+  ) {\n+    details = error.message;\n+    stack = error.stack;\n+  }\n+\n+  return (\n+    <main id=\"error-page\">\n+      <h1>{message}</h1>\n+      <p>{details}</p>\n+      {stack && (\n+        <pre>\n+          <code>{stack}</code>\n+        </pre>\n+      )}\n+    </main>\n+  );\n+}\n+```\n+\n+</details>\n+\n+## The Contact Route UI\n+\n+If you click on one of the sidebar items you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.\n+\n+\ud83d\udc49 **Create a contact route module**\n+\n+```shellscript nonumber\n+mkdir app/pages\n+touch app/pages/contact.tsx",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1878547711",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12504,
        "pr_file": "docs/tutorials/framework.md",
        "discussion_id": "1878547711",
        "commented_code": "@@ -0,0 +1,1960 @@\n+---\n+title: Framework Tutorial\n+order: 1\n+---\n+\n+# Framework Tutorial\n+\n+We'll be building a small, but feature-rich app that lets you keep track of your contacts. There's no database or other \"production ready\" things, so we can stay focused on the features React Router gives you. We expect it to take about 30m if you're following along, otherwise it's a quick read.\n+\n+TODO: add screenshot\n+\n+\ud83d\udc49 **Every time you see this it means you need to do something in the app!**\n+\n+The rest is just there for your information and deeper understanding. Let's get to it.\n+\n+## Setup\n+\n+\ud83d\udc49 **Generate a basic template**\n+\n+```shellscript nonumber\n+npx create-react-router@latest --template remix-run/react-router/tutorial\n+```\n+\n+This uses a pretty bare-bones template but includes our css and data model, so we can focus on React Router.\n+\n+\ud83d\udc49 **Start the app**\n+\n+```shellscript nonumber\n+# cd into the app directory\n+cd {wherever you put the app}\n+\n+# install dependencies if you haven't already\n+npm install\n+\n+# start the server\n+npm run dev\n+```\n+\n+You should be able to open up [http://localhost:5173][http-localhost-5173] and see an unstyled screen that looks like this:\n+\n+<!-- img elements will look will be in the form: <!-- <img class=\"tutorial\" src=\"/_docs/v7_framework_tutorial/n.webp\" /> -->\n+\n+## The Root Route\n+\n+Note the file at `app/root.tsx`. This is what we call the [\"Root Route\"][root-route]. It's the first component in the UI that renders, so it typically contains the global layout for the page, as well as a the default [Error Boundary][error-boundaries].\n+\n+<details>\n+\n+<summary>Expand here to see the root component code</summary>\n+\n+```tsx filename=app/root.tsx\n+import {\n+  Form,\n+  Scripts,\n+  ScrollRestoration,\n+  isRouteErrorResponse,\n+} from \"react-router\";\n+import type { Route } from \"./+types/root\";\n+\n+import appStylesHref from \"./app.css?url\";\n+\n+export function Layout({\n+  children,\n+}: {\n+  children: React.ReactNode;\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <head>\n+        <meta charSet=\"utf-8\" />\n+        <meta\n+          name=\"viewport\"\n+          content=\"width=device-width, initial-scale=1\"\n+        />\n+        <link rel=\"stylesheet\" href={appStylesHref} />\n+      </head>\n+      <body>\n+        {children}\n+        <ScrollRestoration />\n+        <Scripts />\n+      </body>\n+    </html>\n+  );\n+}\n+\n+export default function App() {\n+  return (\n+    <>\n+      <div id=\"sidebar\">\n+        <h1>React Router Contacts</h1>\n+        <div>\n+          <Form id=\"search-form\" role=\"search\">\n+            <input\n+              aria-label=\"Search contacts\"\n+              id=\"q\"\n+              name=\"q\"\n+              placeholder=\"Search\"\n+              type=\"search\"\n+            />\n+            <div\n+              aria-hidden\n+              hidden={true}\n+              id=\"search-spinner\"\n+            />\n+          </Form>\n+          <Form method=\"post\">\n+            <button type=\"submit\">New</button>\n+          </Form>\n+        </div>\n+        <nav>\n+          <ul>\n+            <li>\n+              <a href={`/contacts/1`}>Your Name</a>\n+            </li>\n+            <li>\n+              <a href={`/contacts/2`}>Your Friend</a>\n+            </li>\n+          </ul>\n+        </nav>\n+      </div>\n+    </>\n+  );\n+}\n+\n+export function ErrorBoundary({\n+  error,\n+}: Route.ErrorBoundaryProps) {\n+  let message = \"Oops!\";\n+  let details = \"An unexpected error occurred.\";\n+  let stack: string | undefined;\n+\n+  if (isRouteErrorResponse(error)) {\n+    message = error.status === 404 ? \"404\" : \"Error\";\n+    details =\n+      error.status === 404\n+        ? \"The requested page could not be found.\"\n+        : error.statusText || details;\n+  } else if (\n+    import.meta.env.DEV &&\n+    error &&\n+    error instanceof Error\n+  ) {\n+    details = error.message;\n+    stack = error.stack;\n+  }\n+\n+  return (\n+    <main id=\"error-page\">\n+      <h1>{message}</h1>\n+      <p>{details}</p>\n+      {stack && (\n+        <pre>\n+          <code>{stack}</code>\n+        </pre>\n+      )}\n+    </main>\n+  );\n+}\n+```\n+\n+</details>\n+\n+## The Contact Route UI\n+\n+If you click on one of the sidebar items you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.\n+\n+\ud83d\udc49 **Create a contact route module**\n+\n+```shellscript nonumber\n+mkdir app/pages\n+touch app/pages/contact.tsx",
        "comment_created_at": "2024-12-10T17:45:00+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "Is `pages` an explicit choice here?  Should we be consistent with https://github.com/remix-run/react-router-templates/tree/main/default/app/routes?",
        "pr_file_module": null
      },
      {
        "comment_id": "1878737217",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12504,
        "pr_file": "docs/tutorials/framework.md",
        "discussion_id": "1878547711",
        "commented_code": "@@ -0,0 +1,1960 @@\n+---\n+title: Framework Tutorial\n+order: 1\n+---\n+\n+# Framework Tutorial\n+\n+We'll be building a small, but feature-rich app that lets you keep track of your contacts. There's no database or other \"production ready\" things, so we can stay focused on the features React Router gives you. We expect it to take about 30m if you're following along, otherwise it's a quick read.\n+\n+TODO: add screenshot\n+\n+\ud83d\udc49 **Every time you see this it means you need to do something in the app!**\n+\n+The rest is just there for your information and deeper understanding. Let's get to it.\n+\n+## Setup\n+\n+\ud83d\udc49 **Generate a basic template**\n+\n+```shellscript nonumber\n+npx create-react-router@latest --template remix-run/react-router/tutorial\n+```\n+\n+This uses a pretty bare-bones template but includes our css and data model, so we can focus on React Router.\n+\n+\ud83d\udc49 **Start the app**\n+\n+```shellscript nonumber\n+# cd into the app directory\n+cd {wherever you put the app}\n+\n+# install dependencies if you haven't already\n+npm install\n+\n+# start the server\n+npm run dev\n+```\n+\n+You should be able to open up [http://localhost:5173][http-localhost-5173] and see an unstyled screen that looks like this:\n+\n+<!-- img elements will look will be in the form: <!-- <img class=\"tutorial\" src=\"/_docs/v7_framework_tutorial/n.webp\" /> -->\n+\n+## The Root Route\n+\n+Note the file at `app/root.tsx`. This is what we call the [\"Root Route\"][root-route]. It's the first component in the UI that renders, so it typically contains the global layout for the page, as well as a the default [Error Boundary][error-boundaries].\n+\n+<details>\n+\n+<summary>Expand here to see the root component code</summary>\n+\n+```tsx filename=app/root.tsx\n+import {\n+  Form,\n+  Scripts,\n+  ScrollRestoration,\n+  isRouteErrorResponse,\n+} from \"react-router\";\n+import type { Route } from \"./+types/root\";\n+\n+import appStylesHref from \"./app.css?url\";\n+\n+export function Layout({\n+  children,\n+}: {\n+  children: React.ReactNode;\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <head>\n+        <meta charSet=\"utf-8\" />\n+        <meta\n+          name=\"viewport\"\n+          content=\"width=device-width, initial-scale=1\"\n+        />\n+        <link rel=\"stylesheet\" href={appStylesHref} />\n+      </head>\n+      <body>\n+        {children}\n+        <ScrollRestoration />\n+        <Scripts />\n+      </body>\n+    </html>\n+  );\n+}\n+\n+export default function App() {\n+  return (\n+    <>\n+      <div id=\"sidebar\">\n+        <h1>React Router Contacts</h1>\n+        <div>\n+          <Form id=\"search-form\" role=\"search\">\n+            <input\n+              aria-label=\"Search contacts\"\n+              id=\"q\"\n+              name=\"q\"\n+              placeholder=\"Search\"\n+              type=\"search\"\n+            />\n+            <div\n+              aria-hidden\n+              hidden={true}\n+              id=\"search-spinner\"\n+            />\n+          </Form>\n+          <Form method=\"post\">\n+            <button type=\"submit\">New</button>\n+          </Form>\n+        </div>\n+        <nav>\n+          <ul>\n+            <li>\n+              <a href={`/contacts/1`}>Your Name</a>\n+            </li>\n+            <li>\n+              <a href={`/contacts/2`}>Your Friend</a>\n+            </li>\n+          </ul>\n+        </nav>\n+      </div>\n+    </>\n+  );\n+}\n+\n+export function ErrorBoundary({\n+  error,\n+}: Route.ErrorBoundaryProps) {\n+  let message = \"Oops!\";\n+  let details = \"An unexpected error occurred.\";\n+  let stack: string | undefined;\n+\n+  if (isRouteErrorResponse(error)) {\n+    message = error.status === 404 ? \"404\" : \"Error\";\n+    details =\n+      error.status === 404\n+        ? \"The requested page could not be found.\"\n+        : error.statusText || details;\n+  } else if (\n+    import.meta.env.DEV &&\n+    error &&\n+    error instanceof Error\n+  ) {\n+    details = error.message;\n+    stack = error.stack;\n+  }\n+\n+  return (\n+    <main id=\"error-page\">\n+      <h1>{message}</h1>\n+      <p>{details}</p>\n+      {stack && (\n+        <pre>\n+          <code>{stack}</code>\n+        </pre>\n+      )}\n+    </main>\n+  );\n+}\n+```\n+\n+</details>\n+\n+## The Contact Route UI\n+\n+If you click on one of the sidebar items you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.\n+\n+\ud83d\udc49 **Create a contact route module**\n+\n+```shellscript nonumber\n+mkdir app/pages\n+touch app/pages/contact.tsx",
        "comment_created_at": "2024-12-10T19:50:06+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "Yeah, I deliberately chose pages to try to move away from `routes` to try to break away harder from the old format.\r\n\r\nHowever, I would prefer we don't have discrepancies, so I'll change to `routes/`. I may change everything all at once at some later point if I still feel strongly",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1831597454",
    "pr_number": 12241,
    "pr_file": "docs/framework/how-to/file-uploads.md",
    "created_at": "2024-11-06T19:27:43+00:00",
    "commented_code": "+---\n+title: File Uploads\n+---\n+\n+# File Uploads\n+\n+Handle file uploads in your React Router applications. This guide uses some packages from the [Remix The Web][remix-the-web] project to make file uploads easier.\n+\n+_Thank you to David Adams for [his original guide](https://programmingarehard.com/2024/09/06/remix-file-uploads-updated.html/) on how to implement file uploads in Remix. You can refer to it for even more examples._\n+\n+## Basic File Upload\n+\n+\ud83d\udc49 **Add the form data parser**\n+\n+`form-data-parser` is a wrapper around `request.formData()` that provides streaming support for handling file uploads.\n+\n+```shellscript\n+npm i @mjackson/form-data-parser\n+```\n+\n+[See the `form-data-parser` docs for more information][form-data-parser]\n+\n+\ud83d\udc49 **Create a route with an upload action**\n+\n+The `parseFormData` function takes an `uploadHandler` function as an argument. This function will be called for each file upload in the form.\n+\n+<docs-warning>\n+\n+You must set the form's `enctype` to `multipart/form-data` for file uploads to work.\n+\n+</docs-warning>\n+\n+```tsx filename=routes/user.$id.tsx\n+import {\n+  type FileUpload,\n+  parseFormData,\n+} from \"@mjackson/form-data-parser\";\n+\n+export async function action({\n+  request,\n+}: ActionFunctionArgs) {\n+  const uploadHandler = async (fileUpload: FileUpload) => {\n+    if (fileUpload.fieldName === \"avatar\") {\n+      // process the upload and return a File\n+    }\n+  };\n+\n+  const formData = await parseFormData(\n+    request,\n+    uploadHandler\n+  );\n+  // 'avatar' has already been processed at this point\n+  const file = formData.get(\"avatar\");\n+}\n+\n+export default function Component() {\n+  return (\n+    <Form method=\"post\" encType=\"multipart/form-data\">\n+      <input type=\"file\" name=\"avatar\" />\n+      <button>Submit</button>\n+    </Form>\n+  );\n+}\n+```\n+\n+## Local Storage Implementation\n+\n+\ud83d\udc49 **Add the storage package**\n+\n+`file-storage` is a key/value interface for storing [File objects][file] in JavaScript. Similar to how `localStorage` allows you to store key/value pairs of strings in the browser, file-storage allows you to store key/value pairs of files on the server.\n+\n+```shellscript\n+npm i @mjackson/file-storage\n+```\n+\n+[See the `file-storage` docs for more information][file-storage]\n+\n+\ud83d\udc49 **Create a storage configuration**\n+\n+Create a file that exports a `LocalFileStorage` instance to be used by different routes.\n+\n+```ts filename=file-storage.server.ts",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1831597454",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12241,
        "pr_file": "docs/framework/how-to/file-uploads.md",
        "discussion_id": "1831597454",
        "commented_code": "@@ -0,0 +1,195 @@\n+---\n+title: File Uploads\n+---\n+\n+# File Uploads\n+\n+Handle file uploads in your React Router applications. This guide uses some packages from the [Remix The Web][remix-the-web] project to make file uploads easier.\n+\n+_Thank you to David Adams for [his original guide](https://programmingarehard.com/2024/09/06/remix-file-uploads-updated.html/) on how to implement file uploads in Remix. You can refer to it for even more examples._\n+\n+## Basic File Upload\n+\n+\ud83d\udc49 **Add the form data parser**\n+\n+`form-data-parser` is a wrapper around `request.formData()` that provides streaming support for handling file uploads.\n+\n+```shellscript\n+npm i @mjackson/form-data-parser\n+```\n+\n+[See the `form-data-parser` docs for more information][form-data-parser]\n+\n+\ud83d\udc49 **Create a route with an upload action**\n+\n+The `parseFormData` function takes an `uploadHandler` function as an argument. This function will be called for each file upload in the form.\n+\n+<docs-warning>\n+\n+You must set the form's `enctype` to `multipart/form-data` for file uploads to work.\n+\n+</docs-warning>\n+\n+```tsx filename=routes/user.$id.tsx\n+import {\n+  type FileUpload,\n+  parseFormData,\n+} from \"@mjackson/form-data-parser\";\n+\n+export async function action({\n+  request,\n+}: ActionFunctionArgs) {\n+  const uploadHandler = async (fileUpload: FileUpload) => {\n+    if (fileUpload.fieldName === \"avatar\") {\n+      // process the upload and return a File\n+    }\n+  };\n+\n+  const formData = await parseFormData(\n+    request,\n+    uploadHandler\n+  );\n+  // 'avatar' has already been processed at this point\n+  const file = formData.get(\"avatar\");\n+}\n+\n+export default function Component() {\n+  return (\n+    <Form method=\"post\" encType=\"multipart/form-data\">\n+      <input type=\"file\" name=\"avatar\" />\n+      <button>Submit</button>\n+    </Form>\n+  );\n+}\n+```\n+\n+## Local Storage Implementation\n+\n+\ud83d\udc49 **Add the storage package**\n+\n+`file-storage` is a key/value interface for storing [File objects][file] in JavaScript. Similar to how `localStorage` allows you to store key/value pairs of strings in the browser, file-storage allows you to store key/value pairs of files on the server.\n+\n+```shellscript\n+npm i @mjackson/file-storage\n+```\n+\n+[See the `file-storage` docs for more information][file-storage]\n+\n+\ud83d\udc49 **Create a storage configuration**\n+\n+Create a file that exports a `LocalFileStorage` instance to be used by different routes.\n+\n+```ts filename=file-storage.server.ts",
        "comment_created_at": "2024-11-06T19:27:43+00:00",
        "comment_author": "mjackson",
        "comment_body": "Might wanna call this file `avatar-storage.server.ts` or something similar. It's a bit more descriptive than just \"file storage\".",
        "pr_file_module": null
      },
      {
        "comment_id": "1831607718",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12241,
        "pr_file": "docs/framework/how-to/file-uploads.md",
        "discussion_id": "1831597454",
        "commented_code": "@@ -0,0 +1,195 @@\n+---\n+title: File Uploads\n+---\n+\n+# File Uploads\n+\n+Handle file uploads in your React Router applications. This guide uses some packages from the [Remix The Web][remix-the-web] project to make file uploads easier.\n+\n+_Thank you to David Adams for [his original guide](https://programmingarehard.com/2024/09/06/remix-file-uploads-updated.html/) on how to implement file uploads in Remix. You can refer to it for even more examples._\n+\n+## Basic File Upload\n+\n+\ud83d\udc49 **Add the form data parser**\n+\n+`form-data-parser` is a wrapper around `request.formData()` that provides streaming support for handling file uploads.\n+\n+```shellscript\n+npm i @mjackson/form-data-parser\n+```\n+\n+[See the `form-data-parser` docs for more information][form-data-parser]\n+\n+\ud83d\udc49 **Create a route with an upload action**\n+\n+The `parseFormData` function takes an `uploadHandler` function as an argument. This function will be called for each file upload in the form.\n+\n+<docs-warning>\n+\n+You must set the form's `enctype` to `multipart/form-data` for file uploads to work.\n+\n+</docs-warning>\n+\n+```tsx filename=routes/user.$id.tsx\n+import {\n+  type FileUpload,\n+  parseFormData,\n+} from \"@mjackson/form-data-parser\";\n+\n+export async function action({\n+  request,\n+}: ActionFunctionArgs) {\n+  const uploadHandler = async (fileUpload: FileUpload) => {\n+    if (fileUpload.fieldName === \"avatar\") {\n+      // process the upload and return a File\n+    }\n+  };\n+\n+  const formData = await parseFormData(\n+    request,\n+    uploadHandler\n+  );\n+  // 'avatar' has already been processed at this point\n+  const file = formData.get(\"avatar\");\n+}\n+\n+export default function Component() {\n+  return (\n+    <Form method=\"post\" encType=\"multipart/form-data\">\n+      <input type=\"file\" name=\"avatar\" />\n+      <button>Submit</button>\n+    </Form>\n+  );\n+}\n+```\n+\n+## Local Storage Implementation\n+\n+\ud83d\udc49 **Add the storage package**\n+\n+`file-storage` is a key/value interface for storing [File objects][file] in JavaScript. Similar to how `localStorage` allows you to store key/value pairs of strings in the browser, file-storage allows you to store key/value pairs of files on the server.\n+\n+```shellscript\n+npm i @mjackson/file-storage\n+```\n+\n+[See the `file-storage` docs for more information][file-storage]\n+\n+\ud83d\udc49 **Create a storage configuration**\n+\n+Create a file that exports a `LocalFileStorage` instance to be used by different routes.\n+\n+```ts filename=file-storage.server.ts",
        "comment_created_at": "2024-11-06T19:36:23+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "Good idea, updated!",
        "pr_file_module": null
      }
    ]
  }
]