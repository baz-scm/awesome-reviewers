[
  {
    "discussion_id": "2059262956",
    "pr_number": 13461,
    "pr_file": "packages/react-router/lib/dom/ssr/errorBoundaries.tsx",
    "created_at": "2025-04-24T21:28:30+00:00",
    "commented_code": "<h1 style={{ fontSize: \"24px\" }}>\n           {error.status} {error.statusText}\n         </h1>\n-        {heyDeveloper}\n+        {ENABLE_DEV_WARNINGS && heyDeveloper}",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2059262956",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13461,
        "pr_file": "packages/react-router/lib/dom/ssr/errorBoundaries.tsx",
        "discussion_id": "2059262956",
        "commented_code": "@@ -96,7 +97,7 @@ export function RemixRootDefaultErrorBoundary({\n         <h1 style={{ fontSize: \"24px\" }}>\n           {error.status} {error.statusText}\n         </h1>\n-        {heyDeveloper}\n+        {ENABLE_DEV_WARNINGS && heyDeveloper}",
        "comment_created_at": "2025-04-24T21:28:30+00:00",
        "comment_author": "MichaelDeBoey",
        "comment_body": "Let's [use ternaries rather than `&&` in JSX](https://kentcdodds.com/blog/use-ternaries-rather-than-and-and-in-jsx)\r\n\r\n```suggestion\r\n        {ENABLE_DEV_WARNINGS ? heyDeveloper : null}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2021581446",
    "pr_number": 13294,
    "pr_file": "packages/react-router/lib/dom/ssr/routes.tsx",
    "created_at": "2025-03-31T18:33:43+00:00",
    "commented_code": "};\n       }\n \n-      if (route.hasClientMiddleware) {\n-        dataRoute.unstable_lazyMiddleware = async () => {\n-          invariant(route);\n-          let clientMiddlewareModule = await import(\n-            /* @vite-ignore */\n-            /* webpackIgnore: true */\n-            route.clientMiddlewareModule || route.module\n-          );\n-          invariant(\n-            clientMiddlewareModule?.unstable_clientMiddleware,\n-            \"No `unstable_clientMiddleware` export in chunk\"\n+      let lazyRoutePromise:\n+        | ReturnType<typeof loadRouteModuleWithBlockingLinks>\n+        | undefined;\n+      async function getLazyRoute() {\n+        if (lazyRoutePromise) {\n+          return await lazyRoutePromise;\n+        }\n+        lazyRoutePromise = (async () => {\n+          if (route.clientLoaderModule || route.clientActionModule) {\n+            // If a client loader/action chunk is present, we push the loading of\n+            // the main route chunk to the next tick to ensure the downloading of\n+            // loader/action chunks takes precedence. This can be seen via their\n+            // order in the network tab. Also note that since this is happening\n+            // within `route.lazy`, this imperceptible delay only happens on the\n+            // first load of this route.\n+            await new Promise((resolve) => setTimeout(resolve, 0));\n+          }\n+\n+          let routeModulePromise = loadRouteModuleWithBlockingLinks(\n+            route,\n+            routeModulesCache\n           );\n-          return clientMiddlewareModule.unstable_clientMiddleware;\n-        };\n+          prefetchRouteModuleChunks(route);\n+          return await routeModulePromise;\n+        })();\n+        return await lazyRoutePromise;\n       }\n \n-      // Load all other modules via route.lazy()\n-      dataRoute.lazy = async () => {\n-        if (route.clientLoaderModule || route.clientActionModule) {\n-          // If a client loader/action chunk is present, we push the loading of\n-          // the main route chunk to the next tick to ensure the downloading of\n-          // loader/action chunks takes precedence. This can be seen via their\n-          // order in the network tab. Also note that since this is happening\n-          // within `route.lazy`, this imperceptible delay only happens on the\n-          // first load of this route.\n-          await new Promise((resolve) => setTimeout(resolve, 0));\n-        }\n-\n-        let modPromise = loadRouteModuleWithBlockingLinks(\n-          route,\n-          routeModulesCache\n-        );\n-        prefetchRouteModuleChunks(route);\n-        let mod = await modPromise;\n-\n-        let lazyRoute: Partial<DataRouteObject> = { ...mod };\n-        if (mod.clientLoader) {\n-          let clientLoader = mod.clientLoader;\n-          lazyRoute.loader = (\n-            args: LoaderFunctionArgs,\n-            singleFetch?: unknown\n-          ) =>\n-            clientLoader({\n-              ...args,\n-              async serverLoader() {\n-                preventInvalidServerHandlerCall(\"loader\", route);\n-                return fetchServerLoader(singleFetch);\n+      dataRoute.lazy = {\n+        loader:\n+          dataRoute.loader || !route.hasClientLoader\n+            ? undefined\n+            : async () => {",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "2021581446",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13294,
        "pr_file": "packages/react-router/lib/dom/ssr/routes.tsx",
        "discussion_id": "2021581446",
        "commented_code": "@@ -473,89 +473,95 @@ export function createClientRoutes(\n         };\n       }\n \n-      if (route.hasClientMiddleware) {\n-        dataRoute.unstable_lazyMiddleware = async () => {\n-          invariant(route);\n-          let clientMiddlewareModule = await import(\n-            /* @vite-ignore */\n-            /* webpackIgnore: true */\n-            route.clientMiddlewareModule || route.module\n-          );\n-          invariant(\n-            clientMiddlewareModule?.unstable_clientMiddleware,\n-            \"No `unstable_clientMiddleware` export in chunk\"\n+      let lazyRoutePromise:\n+        | ReturnType<typeof loadRouteModuleWithBlockingLinks>\n+        | undefined;\n+      async function getLazyRoute() {\n+        if (lazyRoutePromise) {\n+          return await lazyRoutePromise;\n+        }\n+        lazyRoutePromise = (async () => {\n+          if (route.clientLoaderModule || route.clientActionModule) {\n+            // If a client loader/action chunk is present, we push the loading of\n+            // the main route chunk to the next tick to ensure the downloading of\n+            // loader/action chunks takes precedence. This can be seen via their\n+            // order in the network tab. Also note that since this is happening\n+            // within `route.lazy`, this imperceptible delay only happens on the\n+            // first load of this route.\n+            await new Promise((resolve) => setTimeout(resolve, 0));\n+          }\n+\n+          let routeModulePromise = loadRouteModuleWithBlockingLinks(\n+            route,\n+            routeModulesCache\n           );\n-          return clientMiddlewareModule.unstable_clientMiddleware;\n-        };\n+          prefetchRouteModuleChunks(route);\n+          return await routeModulePromise;\n+        })();\n+        return await lazyRoutePromise;\n       }\n \n-      // Load all other modules via route.lazy()\n-      dataRoute.lazy = async () => {\n-        if (route.clientLoaderModule || route.clientActionModule) {\n-          // If a client loader/action chunk is present, we push the loading of\n-          // the main route chunk to the next tick to ensure the downloading of\n-          // loader/action chunks takes precedence. This can be seen via their\n-          // order in the network tab. Also note that since this is happening\n-          // within `route.lazy`, this imperceptible delay only happens on the\n-          // first load of this route.\n-          await new Promise((resolve) => setTimeout(resolve, 0));\n-        }\n-\n-        let modPromise = loadRouteModuleWithBlockingLinks(\n-          route,\n-          routeModulesCache\n-        );\n-        prefetchRouteModuleChunks(route);\n-        let mod = await modPromise;\n-\n-        let lazyRoute: Partial<DataRouteObject> = { ...mod };\n-        if (mod.clientLoader) {\n-          let clientLoader = mod.clientLoader;\n-          lazyRoute.loader = (\n-            args: LoaderFunctionArgs,\n-            singleFetch?: unknown\n-          ) =>\n-            clientLoader({\n-              ...args,\n-              async serverLoader() {\n-                preventInvalidServerHandlerCall(\"loader\", route);\n-                return fetchServerLoader(singleFetch);\n+      dataRoute.lazy = {\n+        loader:\n+          dataRoute.loader || !route.hasClientLoader\n+            ? undefined\n+            : async () => {",
        "comment_created_at": "2025-03-31T18:33:43+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "I think I expected to see the `if (route.clientLoaderModule)` logic above moving down into `route.lazy.loader` as well?  I think it would be another split in this conditional (using if/else for readability now that it has 3 branches).  It might nicely colocate all of our loader initialization whereas we used to have 2 spots (outside/inside of `lazy`)\r\n\r\n```ts\r\n      // assume `dataRoute.lazy` is initialized as an empty object above - may not \r\n      // be the way we want to do it but it might read nicely as we build up the \r\n      // route object and let us colocate initialization logic per-field...\r\n      if (!route.hasClientLoader) {\r\n        // No `clientLoader` exists, use the `loader` to load styles and call the\r\n        // server `loader` (if it exists) in parallel with `route.lazy` execution\r\n        dataRoute.loader = (_: LoaderFunctionArgs, singleFetch?: unknown) =>\r\n          prefetchStylesAndCallHandler(() => {\r\n            return fetchServerLoader(singleFetch);\r\n          });\r\n      } else if (route.clientLoaderModule) {\r\n        // A `clientLoader` module exists, load it with route.lazy.loader\r\n        dataRoute.lazy.loader = async () => {\r\n          invariant(route.clientLoaderModule);\r\n          let { clientLoader } = await import(\r\n            /* @vite-ignore */\r\n            /* webpackIgnore: true */\r\n            route.clientLoaderModule\r\n          );\r\n          return (args: LoaderFunctionArgs, singleFetch?: unknown) =>\r\n            clientLoader({\r\n              ...args,\r\n              async serverLoader() {\r\n                preventInvalidServerHandlerCall(\"loader\", route);\r\n                return fetchServerLoader(singleFetch);\r\n              },\r\n            });\r\n        };\r\n      } else {\r\n        // No `clientLoader` module exists, load the `clientLoader` via the\r\n        // full route module\r\n        dataRoute.lazy.loader = async () => {\r\n          let { clientLoader } = await getLazyRoute();\r\n          invariant(clientLoader, \"No `clientLoader` export found\");\r\n          // This below is the same as above so may be able to be shared.  \r\n          // All that differs between this and the conditional branch above is \r\n          // where we get `clientLoader` from...\r\n          return (args: LoaderFunctionArgs, singleFetch?: unknown) =>\r\n            clientLoader({\r\n              ...args,\r\n              async serverLoader() {\r\n                preventInvalidServerHandlerCall(\"loader\", route);\r\n                return fetchServerLoader(singleFetch);\r\n              },\r\n            });\r\n        };\r\n      }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2021926206",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 13294,
        "pr_file": "packages/react-router/lib/dom/ssr/routes.tsx",
        "discussion_id": "2021581446",
        "commented_code": "@@ -473,89 +473,95 @@ export function createClientRoutes(\n         };\n       }\n \n-      if (route.hasClientMiddleware) {\n-        dataRoute.unstable_lazyMiddleware = async () => {\n-          invariant(route);\n-          let clientMiddlewareModule = await import(\n-            /* @vite-ignore */\n-            /* webpackIgnore: true */\n-            route.clientMiddlewareModule || route.module\n-          );\n-          invariant(\n-            clientMiddlewareModule?.unstable_clientMiddleware,\n-            \"No `unstable_clientMiddleware` export in chunk\"\n+      let lazyRoutePromise:\n+        | ReturnType<typeof loadRouteModuleWithBlockingLinks>\n+        | undefined;\n+      async function getLazyRoute() {\n+        if (lazyRoutePromise) {\n+          return await lazyRoutePromise;\n+        }\n+        lazyRoutePromise = (async () => {\n+          if (route.clientLoaderModule || route.clientActionModule) {\n+            // If a client loader/action chunk is present, we push the loading of\n+            // the main route chunk to the next tick to ensure the downloading of\n+            // loader/action chunks takes precedence. This can be seen via their\n+            // order in the network tab. Also note that since this is happening\n+            // within `route.lazy`, this imperceptible delay only happens on the\n+            // first load of this route.\n+            await new Promise((resolve) => setTimeout(resolve, 0));\n+          }\n+\n+          let routeModulePromise = loadRouteModuleWithBlockingLinks(\n+            route,\n+            routeModulesCache\n           );\n-          return clientMiddlewareModule.unstable_clientMiddleware;\n-        };\n+          prefetchRouteModuleChunks(route);\n+          return await routeModulePromise;\n+        })();\n+        return await lazyRoutePromise;\n       }\n \n-      // Load all other modules via route.lazy()\n-      dataRoute.lazy = async () => {\n-        if (route.clientLoaderModule || route.clientActionModule) {\n-          // If a client loader/action chunk is present, we push the loading of\n-          // the main route chunk to the next tick to ensure the downloading of\n-          // loader/action chunks takes precedence. This can be seen via their\n-          // order in the network tab. Also note that since this is happening\n-          // within `route.lazy`, this imperceptible delay only happens on the\n-          // first load of this route.\n-          await new Promise((resolve) => setTimeout(resolve, 0));\n-        }\n-\n-        let modPromise = loadRouteModuleWithBlockingLinks(\n-          route,\n-          routeModulesCache\n-        );\n-        prefetchRouteModuleChunks(route);\n-        let mod = await modPromise;\n-\n-        let lazyRoute: Partial<DataRouteObject> = { ...mod };\n-        if (mod.clientLoader) {\n-          let clientLoader = mod.clientLoader;\n-          lazyRoute.loader = (\n-            args: LoaderFunctionArgs,\n-            singleFetch?: unknown\n-          ) =>\n-            clientLoader({\n-              ...args,\n-              async serverLoader() {\n-                preventInvalidServerHandlerCall(\"loader\", route);\n-                return fetchServerLoader(singleFetch);\n+      dataRoute.lazy = {\n+        loader:\n+          dataRoute.loader || !route.hasClientLoader\n+            ? undefined\n+            : async () => {",
        "comment_created_at": "2025-03-31T23:57:18+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "Thanks for catching this, I've pushed a refactor that cleans this up.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1344352908",
    "pr_number": 10734,
    "pr_file": "packages/react-router-dom/index.tsx",
    "created_at": "2023-10-03T15:59:30+00:00",
    "commented_code": ": null;\n       toPathname = toPathname.toLowerCase();\n     }\n-\n+    const endSlashPosition = (toPathname.length > 1 && toPathname[toPathname.length - 1] === \"/\") ? toPathname.length - 1 : toPathname.length;",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1344352908",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 10734,
        "pr_file": "packages/react-router-dom/index.tsx",
        "discussion_id": "1344352908",
        "commented_code": "@@ -657,12 +657,13 @@ export const NavLink = React.forwardRef<HTMLAnchorElement, NavLinkProps>(\n         : null;\n       toPathname = toPathname.toLowerCase();\n     }\n-\n+    const endSlashPosition = (toPathname.length > 1 && toPathname[toPathname.length - 1] === \"/\") ? toPathname.length - 1 : toPathname.length;",
        "comment_created_at": "2023-10-03T15:59:30+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "We can use `endsWith` here for a little more clarity:\r\n\r\n```suggestion\r\n    const endSlashPosition =\r\n      toPathname.length > 1 && toPathname.endsWith(\"/\")\r\n        ? toPathname.length - 1\r\n        : toPathname.length;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]