[
  {
    "discussion_id": "1951493091",
    "pr_number": 12945,
    "pr_file": "packages/react-router/lib/server-runtime/server.ts",
    "created_at": "2025-02-11T19:44:13+00:00",
    "commented_code": ");\n     }\n \n+    if (!response) {\n+      return new Response(\"Unknown Server Error\", { status: 500 });",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1951493091",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12945,
        "pr_file": "packages/react-router/lib/server-runtime/server.ts",
        "discussion_id": "1951493091",
        "commented_code": "@@ -230,6 +230,10 @@ export const createRequestHandler: CreateRequestHandlerFunction = (\n       );\n     }\n \n+    if (!response) {\n+      return new Response(\"Unknown Server Error\", { status: 500 });",
        "comment_created_at": "2025-02-11T19:44:13+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "We can probably run this through the same utility we use elsewhere\r\n\r\n```suggestion\r\n      let error = new Error('Unhandled request')\r\n      return returnLastResortErrorResponse(error, serverMode);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1843044574",
    "pr_number": 12251,
    "pr_file": "packages/react-router-dev/config/config.ts",
    "created_at": "2024-11-15T00:30:20+00:00",
    "commented_code": "return o;\n };\n \n-export function resolvePublicPath(viteUserConfig: Vite.UserConfig) {\n-  return viteUserConfig.base ?? \"/\";\n+type Result<T> =\n+  | {\n+      ok: true;\n+      value: T;\n+      error?: undefined;\n+    }\n+  | {\n+      ok: false;\n+      value?: undefined;\n+      error: string;\n+    };\n+\n+function ok<T>(value: T): Result<T> {\n+  return { ok: true, value };\n }\n \n-let isFirstLoad = true;\n-let lastValidRoutes: RouteManifest = {};\n+function err<T>(error: string): Result<T> {\n+  return { ok: false, error };\n+}\n \n-export async function resolveReactRouterConfig({\n-  rootDirectory,\n-  reactRouterUserConfig,\n-  routeConfigChanged,\n-  viteUserConfig,\n-  viteCommand,\n-  routesViteNodeContext,\n+async function resolveConfig({\n+  root,\n+  viteNodeContext,\n+  reactRouterConfigFile,\n }: {\n-  rootDirectory: string;\n-  reactRouterUserConfig: ReactRouterConfig;\n-  routeConfigChanged: boolean;\n-  viteUserConfig: Vite.UserConfig;\n-  viteCommand: Vite.ConfigEnv[\"command\"];\n-  routesViteNodeContext: ViteNode.Context;\n-}) {\n-  let vite = importViteEsmSync();\n+  root: string;\n+  viteNodeContext: ViteNode.Context;\n+  reactRouterConfigFile?: string;\n+}): Promise<Result<ResolvedReactRouterConfig>> {\n+  let reactRouterUserConfig: ReactRouterConfig = {};\n+\n+  if (reactRouterConfigFile) {\n+    try {\n+      let configModule = await viteNodeContext.runner.executeFile(",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1843044574",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12251,
        "pr_file": "packages/react-router-dev/config/config.ts",
        "discussion_id": "1843044574",
        "commented_code": "@@ -275,33 +279,55 @@ let deepFreeze = (o: any) => {\n   return o;\n };\n \n-export function resolvePublicPath(viteUserConfig: Vite.UserConfig) {\n-  return viteUserConfig.base ?? \"/\";\n+type Result<T> =\n+  | {\n+      ok: true;\n+      value: T;\n+      error?: undefined;\n+    }\n+  | {\n+      ok: false;\n+      value?: undefined;\n+      error: string;\n+    };\n+\n+function ok<T>(value: T): Result<T> {\n+  return { ok: true, value };\n }\n \n-let isFirstLoad = true;\n-let lastValidRoutes: RouteManifest = {};\n+function err<T>(error: string): Result<T> {\n+  return { ok: false, error };\n+}\n \n-export async function resolveReactRouterConfig({\n-  rootDirectory,\n-  reactRouterUserConfig,\n-  routeConfigChanged,\n-  viteUserConfig,\n-  viteCommand,\n-  routesViteNodeContext,\n+async function resolveConfig({\n+  root,\n+  viteNodeContext,\n+  reactRouterConfigFile,\n }: {\n-  rootDirectory: string;\n-  reactRouterUserConfig: ReactRouterConfig;\n-  routeConfigChanged: boolean;\n-  viteUserConfig: Vite.UserConfig;\n-  viteCommand: Vite.ConfigEnv[\"command\"];\n-  routesViteNodeContext: ViteNode.Context;\n-}) {\n-  let vite = importViteEsmSync();\n+  root: string;\n+  viteNodeContext: ViteNode.Context;\n+  reactRouterConfigFile?: string;\n+}): Promise<Result<ResolvedReactRouterConfig>> {\n+  let reactRouterUserConfig: ReactRouterConfig = {};\n+\n+  if (reactRouterConfigFile) {\n+    try {\n+      let configModule = await viteNodeContext.runner.executeFile(",
        "comment_created_at": "2024-11-15T00:30:20+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "Review feedback: We should have our own error for when the file is missing rather than letting it fail within Vite when trying to load it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1843045235",
    "pr_number": 12251,
    "pr_file": "packages/react-router-dev/config/config.ts",
    "created_at": "2024-11-15T00:31:10+00:00",
    "commented_code": "return o;\n };\n \n-export function resolvePublicPath(viteUserConfig: Vite.UserConfig) {\n-  return viteUserConfig.base ?? \"/\";\n+type Result<T> =\n+  | {\n+      ok: true;\n+      value: T;\n+      error?: undefined;\n+    }\n+  | {\n+      ok: false;\n+      value?: undefined;\n+      error: string;\n+    };\n+\n+function ok<T>(value: T): Result<T> {\n+  return { ok: true, value };\n }\n \n-let isFirstLoad = true;\n-let lastValidRoutes: RouteManifest = {};\n+function err<T>(error: string): Result<T> {\n+  return { ok: false, error };\n+}\n \n-export async function resolveReactRouterConfig({\n-  rootDirectory,\n-  reactRouterUserConfig,\n-  routeConfigChanged,\n-  viteUserConfig,\n-  viteCommand,\n-  routesViteNodeContext,\n+async function resolveConfig({\n+  root,\n+  viteNodeContext,\n+  reactRouterConfigFile,\n }: {\n-  rootDirectory: string;\n-  reactRouterUserConfig: ReactRouterConfig;\n-  routeConfigChanged: boolean;\n-  viteUserConfig: Vite.UserConfig;\n-  viteCommand: Vite.ConfigEnv[\"command\"];\n-  routesViteNodeContext: ViteNode.Context;\n-}) {\n-  let vite = importViteEsmSync();\n+  root: string;\n+  viteNodeContext: ViteNode.Context;\n+  reactRouterConfigFile?: string;\n+}): Promise<Result<ResolvedReactRouterConfig>> {\n+  let reactRouterUserConfig: ReactRouterConfig = {};\n+\n+  if (reactRouterConfigFile) {\n+    try {\n+      let configModule = await viteNodeContext.runner.executeFile(\n+        reactRouterConfigFile\n+      );\n \n-  let logger = vite.createLogger(viteUserConfig.logLevel, {\n-    prefix: \"[react-router]\",\n-  });\n+      if (typeof configModule.default !== \"object\") {",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1843045235",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12251,
        "pr_file": "packages/react-router-dev/config/config.ts",
        "discussion_id": "1843045235",
        "commented_code": "@@ -275,33 +279,55 @@ let deepFreeze = (o: any) => {\n   return o;\n };\n \n-export function resolvePublicPath(viteUserConfig: Vite.UserConfig) {\n-  return viteUserConfig.base ?? \"/\";\n+type Result<T> =\n+  | {\n+      ok: true;\n+      value: T;\n+      error?: undefined;\n+    }\n+  | {\n+      ok: false;\n+      value?: undefined;\n+      error: string;\n+    };\n+\n+function ok<T>(value: T): Result<T> {\n+  return { ok: true, value };\n }\n \n-let isFirstLoad = true;\n-let lastValidRoutes: RouteManifest = {};\n+function err<T>(error: string): Result<T> {\n+  return { ok: false, error };\n+}\n \n-export async function resolveReactRouterConfig({\n-  rootDirectory,\n-  reactRouterUserConfig,\n-  routeConfigChanged,\n-  viteUserConfig,\n-  viteCommand,\n-  routesViteNodeContext,\n+async function resolveConfig({\n+  root,\n+  viteNodeContext,\n+  reactRouterConfigFile,\n }: {\n-  rootDirectory: string;\n-  reactRouterUserConfig: ReactRouterConfig;\n-  routeConfigChanged: boolean;\n-  viteUserConfig: Vite.UserConfig;\n-  viteCommand: Vite.ConfigEnv[\"command\"];\n-  routesViteNodeContext: ViteNode.Context;\n-}) {\n-  let vite = importViteEsmSync();\n+  root: string;\n+  viteNodeContext: ViteNode.Context;\n+  reactRouterConfigFile?: string;\n+}): Promise<Result<ResolvedReactRouterConfig>> {\n+  let reactRouterUserConfig: ReactRouterConfig = {};\n+\n+  if (reactRouterConfigFile) {\n+    try {\n+      let configModule = await viteNodeContext.runner.executeFile(\n+        reactRouterConfigFile\n+      );\n \n-  let logger = vite.createLogger(viteUserConfig.logLevel, {\n-    prefix: \"[react-router]\",\n-  });\n+      if (typeof configModule.default !== \"object\") {",
        "comment_created_at": "2024-11-15T00:31:10+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "We should error when the default export is missing entirely.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1781531861",
    "pr_number": 12050,
    "pr_file": "packages/router/router.ts",
    "created_at": "2024-09-30T17:44:37+00:00",
    "commented_code": "function abortFetcher(key: string) {\n     let controller = fetchControllers.get(key);\n-    invariant(controller, `Expected fetch controller: ${key}`);",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1781531861",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12050,
        "pr_file": "packages/router/router.ts",
        "discussion_id": "1781531861",
        "commented_code": "@@ -3018,9 +3014,10 @@ export function createRouter(init: RouterInit): Router {\n \n   function abortFetcher(key: string) {\n     let controller = fetchControllers.get(key);\n-    invariant(controller, `Expected fetch controller: ${key}`);",
        "comment_created_at": "2024-09-30T17:44:37+00:00",
        "comment_author": "brophdawg11",
        "comment_body": "All but 2 uses of `abortFetcher` were already defensive against this invariant and the 2 that weren't were the bug we're fixing, so now that they all want to be defensive we can just flatten the defensive check into this method.",
        "pr_file_module": null
      }
    ]
  }
]