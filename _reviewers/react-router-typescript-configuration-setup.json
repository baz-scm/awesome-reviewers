[
  {
    "discussion_id": "1784571306",
    "pr_number": 12019,
    "pr_file": "decisions/0012-type-inference.md",
    "created_at": "2024-10-02T13:51:59+00:00",
    "commented_code": "+# Type inference\n+\n+Date: 2024-09-20\n+\n+Status: accepted\n+\n+Supersedes [#0003](./0003-infer-types-for-useloaderdata-and-useactiondata-from-loader-and-action-via-generics.md)\n+\n+## Context\n+\n+Now that Remix is being merged upstream into React Router, we have an opportunity to revisit our approach to typesafety.\n+\n+### Type inference\n+\n+There are three major aspects to typesafety in a framework like React Router:\n+\n+1. **Type inference from the route config**\n+\n+   Some types are defined in the route config (`routes.ts`) but need to be inferred within a route module.\n+\n+   For example, let's look at URL path parameters.\n+   Remix had no mechanism for inferring path parameters as that information is not present _within_ a route module.\n+   If a route's URL path was `/products/:id`, you'd have to manually specify `\"id\"` as a valid path parameter within that route module:\n+\n+   ```ts\n+   const params = useParams<\"id\">();\n+   params.id;\n+   ```\n+\n+   This generic was nothing more than a convenient way to do a type cast.\n+   You could completely alter the URL path for a route module, typechecking would pass, but then you would get runtime errors.\n+\n+2. **Type inference within a route**\n+\n+   Some types are defined within a route module but need to be inferred across route exports.\n+\n+   For example, loader data is defined by the return type of `loader` but needs to be accessed within the `default` component export:\n+\n+   ```ts\n+   export function loader() {\n+     // define here \ud83d\udc47\n+     return { planet: \"world\" };\n+   }\n+\n+   export default function Component() {\n+     // access here \ud83d\udc47\n+     const data = useLoaderData<typeof loader>();\n+   }\n+   ```\n+\n+   Unlike the `useParams` generic, this isn't just a type cast.\n+   The `useLoaderData` generic ensures that types account for serialization across the network.\n+   However, it still requires you to add `typeof loader` every time.\n+\n+   Not only that, but complex routes get very tricky to type correctly.\n+   For example, `clientLoader`s don't run during the initial SSR render, but you can force the `clientLoader` data to always be present in your route component if you set `clientLoader.hydrate = true` _and_ provide a `HydrateFallback`.\n+   Here are a couple cases that trip up most users:\n+\n+   | `loader` | `clientLoader` | `clientLoader.hydrate` | `HydrateFallback` | Generic for `useLoaderData`            |\n+   | -------- | -------------- | ---------------------- | ----------------- | -------------------------------------- |\n+   | \u2705       | \u274c             | `false`                | \u274c                | `typeof loader`                        |\n+   | \u274c       | \u2705             | `false`                | \u274c                | `typeof clientLoader \\| undefined`     |\n+   | \u2705       | \u2705             | `false`                | \u274c                | `typeof loader \\| typeof clientLoader` |\n+   | \u2705       | \u2705             | `true`                 | \u274c                | `typeof loader \\| typeof clientLoader` |\n+   | \u2705       | \u2705             | `true`                 | \u2705                | `typeof clientLoader`                  |\n+\n+   The generic for `useLoaderData` starts to feel a lot like doing your taxes: there's only one right answer, Remix knows what it is, but you're going to get quizzed on it anyway.\n+\n+3. **Type inference across routes**\n+\n+   Some types are defined in one route module but need to be inferred in another route module.\n+   This is common when wanting to access loader data of matched routes like when using `useMatches` or `useRouteLoaderData`.\n+\n+   ```ts\n+   import type { loader as otherLoader } from \"../other-route.ts\";\n+   // hope the other route is also matched \ud83d\udc47 otherwise this will error at runtime\n+   const otherData = useRouteLoaderData<typeof otherLoader>();\n+   ```\n+\n+   Again, its up to you to wire up the generics with correct types.\n+   In this case you need to know both types defined in the route config (to know which routes are matched) and types defined in other route modules (to know the loader data for those routes).\n+\n+In practice, Remix's generics work fine most of the time.\n+But they are mostly boilerplate and can become error-prone as the app scales.\n+An ideal solution would infer types correctly on your behalf, doing away with tedious generics.\n+\n+## Goals\n+\n+- Type inference from the route config (`routes.ts`)\n+- Type inference within a route\n+- Type inference across routes\n+- Same code path for type inference whether using programmatic routing or file-based routing\n+- Compatibility with standard tooling for treeshaking, HMR, etc.\n+- Minimal impact on runtime API design\n+\n+## Decisions\n+\n+### Route exports API\n+\n+Keep the route module export API as is.\n+Route modules should continue to export separate values for `loader`, `clientLoader`, `action`, `ErrorBoundary`, `default` component, etc.\n+That way standard transforms like treeshaking and React Fast Refresh (HMR) work out-of-the-box.\n+\n+Additionally, this approach introduces no breaking changes allowing Remix users to upgrade to React Router v7 more easily.\n+\n+### Pass path params, loader data, and action data as props\n+\n+Hooks like `useParams`, `useLoaderData`, and `useActionData` are defined once in `react-router` and are meant to be used in _any_ route.\n+Without any coupling to a specific route, inferring route-specific types becomes impossible and would necessitate user-supplied generics.\n+\n+Instead, each route export should be provided route-specific args:\n+\n+```ts\n+// Imagine that we *somehow* had route-specific types for:\n+// - LoaderArgs\n+// - ClientLoaderArgs\n+// - DefaultProps\n+\n+export function loader({ params }: LoaderArgs) {}\n+\n+export function clientLoader({ params, serverLoader }: ClientLoaderArgs) {}\n+\n+export default function Component({\n+  params,\n+  loaderData,\n+  actionData,\n+}: DefaultProps) {\n+  // ...\n+}\n+```\n+\n+We'll keep those hooks around for backwards compatibility, but eventually the aim is to deprecate and remove them.\n+We can design new, typesafe alternatives for any edge cases.\n+\n+### Typegen\n+\n+While React Router will default to programmatic routing, it can easily be configured for file-based routing.\n+That means that sometimes route URLs will only be represented as file paths.\n+Unfortunately, TypeScript cannot use the filesystem as part of its type inference nor type checking.\n+The only tenable way to infer types based on file paths is through code generation.\n+\n+We _could_ have typegen just for file-based routing, but then we'd need to maintain a separate code path for type inference in programmatic routing.\n+To keep things simple, React Router treats any value returned by `routes.ts` the same; it will not make assumptions about _how_ those routes were constructed and will run typegen in all cases.\n+\n+To that end, React Router will generate types for each route module into a special, gitignored `.react-router` directory.\n+For example:\n+\n+```txt\n+- .react-router/\n+  - types/\n+    - app/\n+      - routes/\n+        - +types.product.ts\n+- app/\n+  - routes/\n+    - product.tsx\n+```\n+\n+The path within `.react-router/types` purposefully mirrors the path to the corresponding route module.\n+By setting things up like this, we can use `tsconfig.json`'s [rootDirs](https://www.typescriptlang.org/tsconfig/#rootDirs) option to let you conveniently import from the typegen file as if it was a sibling:\n+\n+```ts\n+// app/routes/product.tsx\n+import { LoaderArgs, DefaultProps } from \"./+types.product\";\n+```\n+\n+TypeScript will even give you import autocompletion for the typegen file and the `+` prefix helps to distinguish it as a special file.\n+Big thanks to Svelte Kit for showing us that [`rootDirs` trick](https://svelte.dev/blog/zero-config-type-safety#virtual-files)!\n+\n+### TypeScript plugin\n+\n+Typegen solutions often receive criticism due to typegen'd files becoming out of sync during development.\n+This happens because many typegen solutions require you to then rerun a script to update the typegen'd files.\n+\n+Instead, our typegen will automatically run within a TypeScript plugin.\n+That means you should never need to manually run a typegen command during development.\n+It also means that you don't need to run our dev server for typegen to take effect.\n+The only requirement is that your editor is open.",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1784571306",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12019,
        "pr_file": "decisions/0012-type-inference.md",
        "discussion_id": "1784571306",
        "commented_code": "@@ -0,0 +1,275 @@\n+# Type inference\n+\n+Date: 2024-09-20\n+\n+Status: accepted\n+\n+Supersedes [#0003](./0003-infer-types-for-useloaderdata-and-useactiondata-from-loader-and-action-via-generics.md)\n+\n+## Context\n+\n+Now that Remix is being merged upstream into React Router, we have an opportunity to revisit our approach to typesafety.\n+\n+### Type inference\n+\n+There are three major aspects to typesafety in a framework like React Router:\n+\n+1. **Type inference from the route config**\n+\n+   Some types are defined in the route config (`routes.ts`) but need to be inferred within a route module.\n+\n+   For example, let's look at URL path parameters.\n+   Remix had no mechanism for inferring path parameters as that information is not present _within_ a route module.\n+   If a route's URL path was `/products/:id`, you'd have to manually specify `\"id\"` as a valid path parameter within that route module:\n+\n+   ```ts\n+   const params = useParams<\"id\">();\n+   params.id;\n+   ```\n+\n+   This generic was nothing more than a convenient way to do a type cast.\n+   You could completely alter the URL path for a route module, typechecking would pass, but then you would get runtime errors.\n+\n+2. **Type inference within a route**\n+\n+   Some types are defined within a route module but need to be inferred across route exports.\n+\n+   For example, loader data is defined by the return type of `loader` but needs to be accessed within the `default` component export:\n+\n+   ```ts\n+   export function loader() {\n+     // define here \ud83d\udc47\n+     return { planet: \"world\" };\n+   }\n+\n+   export default function Component() {\n+     // access here \ud83d\udc47\n+     const data = useLoaderData<typeof loader>();\n+   }\n+   ```\n+\n+   Unlike the `useParams` generic, this isn't just a type cast.\n+   The `useLoaderData` generic ensures that types account for serialization across the network.\n+   However, it still requires you to add `typeof loader` every time.\n+\n+   Not only that, but complex routes get very tricky to type correctly.\n+   For example, `clientLoader`s don't run during the initial SSR render, but you can force the `clientLoader` data to always be present in your route component if you set `clientLoader.hydrate = true` _and_ provide a `HydrateFallback`.\n+   Here are a couple cases that trip up most users:\n+\n+   | `loader` | `clientLoader` | `clientLoader.hydrate` | `HydrateFallback` | Generic for `useLoaderData`            |\n+   | -------- | -------------- | ---------------------- | ----------------- | -------------------------------------- |\n+   | \u2705       | \u274c             | `false`                | \u274c                | `typeof loader`                        |\n+   | \u274c       | \u2705             | `false`                | \u274c                | `typeof clientLoader \\| undefined`     |\n+   | \u2705       | \u2705             | `false`                | \u274c                | `typeof loader \\| typeof clientLoader` |\n+   | \u2705       | \u2705             | `true`                 | \u274c                | `typeof loader \\| typeof clientLoader` |\n+   | \u2705       | \u2705             | `true`                 | \u2705                | `typeof clientLoader`                  |\n+\n+   The generic for `useLoaderData` starts to feel a lot like doing your taxes: there's only one right answer, Remix knows what it is, but you're going to get quizzed on it anyway.\n+\n+3. **Type inference across routes**\n+\n+   Some types are defined in one route module but need to be inferred in another route module.\n+   This is common when wanting to access loader data of matched routes like when using `useMatches` or `useRouteLoaderData`.\n+\n+   ```ts\n+   import type { loader as otherLoader } from \"../other-route.ts\";\n+   // hope the other route is also matched \ud83d\udc47 otherwise this will error at runtime\n+   const otherData = useRouteLoaderData<typeof otherLoader>();\n+   ```\n+\n+   Again, its up to you to wire up the generics with correct types.\n+   In this case you need to know both types defined in the route config (to know which routes are matched) and types defined in other route modules (to know the loader data for those routes).\n+\n+In practice, Remix's generics work fine most of the time.\n+But they are mostly boilerplate and can become error-prone as the app scales.\n+An ideal solution would infer types correctly on your behalf, doing away with tedious generics.\n+\n+## Goals\n+\n+- Type inference from the route config (`routes.ts`)\n+- Type inference within a route\n+- Type inference across routes\n+- Same code path for type inference whether using programmatic routing or file-based routing\n+- Compatibility with standard tooling for treeshaking, HMR, etc.\n+- Minimal impact on runtime API design\n+\n+## Decisions\n+\n+### Route exports API\n+\n+Keep the route module export API as is.\n+Route modules should continue to export separate values for `loader`, `clientLoader`, `action`, `ErrorBoundary`, `default` component, etc.\n+That way standard transforms like treeshaking and React Fast Refresh (HMR) work out-of-the-box.\n+\n+Additionally, this approach introduces no breaking changes allowing Remix users to upgrade to React Router v7 more easily.\n+\n+### Pass path params, loader data, and action data as props\n+\n+Hooks like `useParams`, `useLoaderData`, and `useActionData` are defined once in `react-router` and are meant to be used in _any_ route.\n+Without any coupling to a specific route, inferring route-specific types becomes impossible and would necessitate user-supplied generics.\n+\n+Instead, each route export should be provided route-specific args:\n+\n+```ts\n+// Imagine that we *somehow* had route-specific types for:\n+// - LoaderArgs\n+// - ClientLoaderArgs\n+// - DefaultProps\n+\n+export function loader({ params }: LoaderArgs) {}\n+\n+export function clientLoader({ params, serverLoader }: ClientLoaderArgs) {}\n+\n+export default function Component({\n+  params,\n+  loaderData,\n+  actionData,\n+}: DefaultProps) {\n+  // ...\n+}\n+```\n+\n+We'll keep those hooks around for backwards compatibility, but eventually the aim is to deprecate and remove them.\n+We can design new, typesafe alternatives for any edge cases.\n+\n+### Typegen\n+\n+While React Router will default to programmatic routing, it can easily be configured for file-based routing.\n+That means that sometimes route URLs will only be represented as file paths.\n+Unfortunately, TypeScript cannot use the filesystem as part of its type inference nor type checking.\n+The only tenable way to infer types based on file paths is through code generation.\n+\n+We _could_ have typegen just for file-based routing, but then we'd need to maintain a separate code path for type inference in programmatic routing.\n+To keep things simple, React Router treats any value returned by `routes.ts` the same; it will not make assumptions about _how_ those routes were constructed and will run typegen in all cases.\n+\n+To that end, React Router will generate types for each route module into a special, gitignored `.react-router` directory.\n+For example:\n+\n+```txt\n+- .react-router/\n+  - types/\n+    - app/\n+      - routes/\n+        - +types.product.ts\n+- app/\n+  - routes/\n+    - product.tsx\n+```\n+\n+The path within `.react-router/types` purposefully mirrors the path to the corresponding route module.\n+By setting things up like this, we can use `tsconfig.json`'s [rootDirs](https://www.typescriptlang.org/tsconfig/#rootDirs) option to let you conveniently import from the typegen file as if it was a sibling:\n+\n+```ts\n+// app/routes/product.tsx\n+import { LoaderArgs, DefaultProps } from \"./+types.product\";\n+```\n+\n+TypeScript will even give you import autocompletion for the typegen file and the `+` prefix helps to distinguish it as a special file.\n+Big thanks to Svelte Kit for showing us that [`rootDirs` trick](https://svelte.dev/blog/zero-config-type-safety#virtual-files)!\n+\n+### TypeScript plugin\n+\n+Typegen solutions often receive criticism due to typegen'd files becoming out of sync during development.\n+This happens because many typegen solutions require you to then rerun a script to update the typegen'd files.\n+\n+Instead, our typegen will automatically run within a TypeScript plugin.\n+That means you should never need to manually run a typegen command during development.\n+It also means that you don't need to run our dev server for typegen to take effect.\n+The only requirement is that your editor is open.",
        "comment_created_at": "2024-10-02T13:51:59+00:00",
        "comment_author": "yesmeck",
        "comment_body": "If it requires the editor to be open, how can we run type checking in CI?",
        "pr_file_module": null
      },
      {
        "comment_id": "1784577030",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12019,
        "pr_file": "decisions/0012-type-inference.md",
        "discussion_id": "1784571306",
        "commented_code": "@@ -0,0 +1,275 @@\n+# Type inference\n+\n+Date: 2024-09-20\n+\n+Status: accepted\n+\n+Supersedes [#0003](./0003-infer-types-for-useloaderdata-and-useactiondata-from-loader-and-action-via-generics.md)\n+\n+## Context\n+\n+Now that Remix is being merged upstream into React Router, we have an opportunity to revisit our approach to typesafety.\n+\n+### Type inference\n+\n+There are three major aspects to typesafety in a framework like React Router:\n+\n+1. **Type inference from the route config**\n+\n+   Some types are defined in the route config (`routes.ts`) but need to be inferred within a route module.\n+\n+   For example, let's look at URL path parameters.\n+   Remix had no mechanism for inferring path parameters as that information is not present _within_ a route module.\n+   If a route's URL path was `/products/:id`, you'd have to manually specify `\"id\"` as a valid path parameter within that route module:\n+\n+   ```ts\n+   const params = useParams<\"id\">();\n+   params.id;\n+   ```\n+\n+   This generic was nothing more than a convenient way to do a type cast.\n+   You could completely alter the URL path for a route module, typechecking would pass, but then you would get runtime errors.\n+\n+2. **Type inference within a route**\n+\n+   Some types are defined within a route module but need to be inferred across route exports.\n+\n+   For example, loader data is defined by the return type of `loader` but needs to be accessed within the `default` component export:\n+\n+   ```ts\n+   export function loader() {\n+     // define here \ud83d\udc47\n+     return { planet: \"world\" };\n+   }\n+\n+   export default function Component() {\n+     // access here \ud83d\udc47\n+     const data = useLoaderData<typeof loader>();\n+   }\n+   ```\n+\n+   Unlike the `useParams` generic, this isn't just a type cast.\n+   The `useLoaderData` generic ensures that types account for serialization across the network.\n+   However, it still requires you to add `typeof loader` every time.\n+\n+   Not only that, but complex routes get very tricky to type correctly.\n+   For example, `clientLoader`s don't run during the initial SSR render, but you can force the `clientLoader` data to always be present in your route component if you set `clientLoader.hydrate = true` _and_ provide a `HydrateFallback`.\n+   Here are a couple cases that trip up most users:\n+\n+   | `loader` | `clientLoader` | `clientLoader.hydrate` | `HydrateFallback` | Generic for `useLoaderData`            |\n+   | -------- | -------------- | ---------------------- | ----------------- | -------------------------------------- |\n+   | \u2705       | \u274c             | `false`                | \u274c                | `typeof loader`                        |\n+   | \u274c       | \u2705             | `false`                | \u274c                | `typeof clientLoader \\| undefined`     |\n+   | \u2705       | \u2705             | `false`                | \u274c                | `typeof loader \\| typeof clientLoader` |\n+   | \u2705       | \u2705             | `true`                 | \u274c                | `typeof loader \\| typeof clientLoader` |\n+   | \u2705       | \u2705             | `true`                 | \u2705                | `typeof clientLoader`                  |\n+\n+   The generic for `useLoaderData` starts to feel a lot like doing your taxes: there's only one right answer, Remix knows what it is, but you're going to get quizzed on it anyway.\n+\n+3. **Type inference across routes**\n+\n+   Some types are defined in one route module but need to be inferred in another route module.\n+   This is common when wanting to access loader data of matched routes like when using `useMatches` or `useRouteLoaderData`.\n+\n+   ```ts\n+   import type { loader as otherLoader } from \"../other-route.ts\";\n+   // hope the other route is also matched \ud83d\udc47 otherwise this will error at runtime\n+   const otherData = useRouteLoaderData<typeof otherLoader>();\n+   ```\n+\n+   Again, its up to you to wire up the generics with correct types.\n+   In this case you need to know both types defined in the route config (to know which routes are matched) and types defined in other route modules (to know the loader data for those routes).\n+\n+In practice, Remix's generics work fine most of the time.\n+But they are mostly boilerplate and can become error-prone as the app scales.\n+An ideal solution would infer types correctly on your behalf, doing away with tedious generics.\n+\n+## Goals\n+\n+- Type inference from the route config (`routes.ts`)\n+- Type inference within a route\n+- Type inference across routes\n+- Same code path for type inference whether using programmatic routing or file-based routing\n+- Compatibility with standard tooling for treeshaking, HMR, etc.\n+- Minimal impact on runtime API design\n+\n+## Decisions\n+\n+### Route exports API\n+\n+Keep the route module export API as is.\n+Route modules should continue to export separate values for `loader`, `clientLoader`, `action`, `ErrorBoundary`, `default` component, etc.\n+That way standard transforms like treeshaking and React Fast Refresh (HMR) work out-of-the-box.\n+\n+Additionally, this approach introduces no breaking changes allowing Remix users to upgrade to React Router v7 more easily.\n+\n+### Pass path params, loader data, and action data as props\n+\n+Hooks like `useParams`, `useLoaderData`, and `useActionData` are defined once in `react-router` and are meant to be used in _any_ route.\n+Without any coupling to a specific route, inferring route-specific types becomes impossible and would necessitate user-supplied generics.\n+\n+Instead, each route export should be provided route-specific args:\n+\n+```ts\n+// Imagine that we *somehow* had route-specific types for:\n+// - LoaderArgs\n+// - ClientLoaderArgs\n+// - DefaultProps\n+\n+export function loader({ params }: LoaderArgs) {}\n+\n+export function clientLoader({ params, serverLoader }: ClientLoaderArgs) {}\n+\n+export default function Component({\n+  params,\n+  loaderData,\n+  actionData,\n+}: DefaultProps) {\n+  // ...\n+}\n+```\n+\n+We'll keep those hooks around for backwards compatibility, but eventually the aim is to deprecate and remove them.\n+We can design new, typesafe alternatives for any edge cases.\n+\n+### Typegen\n+\n+While React Router will default to programmatic routing, it can easily be configured for file-based routing.\n+That means that sometimes route URLs will only be represented as file paths.\n+Unfortunately, TypeScript cannot use the filesystem as part of its type inference nor type checking.\n+The only tenable way to infer types based on file paths is through code generation.\n+\n+We _could_ have typegen just for file-based routing, but then we'd need to maintain a separate code path for type inference in programmatic routing.\n+To keep things simple, React Router treats any value returned by `routes.ts` the same; it will not make assumptions about _how_ those routes were constructed and will run typegen in all cases.\n+\n+To that end, React Router will generate types for each route module into a special, gitignored `.react-router` directory.\n+For example:\n+\n+```txt\n+- .react-router/\n+  - types/\n+    - app/\n+      - routes/\n+        - +types.product.ts\n+- app/\n+  - routes/\n+    - product.tsx\n+```\n+\n+The path within `.react-router/types` purposefully mirrors the path to the corresponding route module.\n+By setting things up like this, we can use `tsconfig.json`'s [rootDirs](https://www.typescriptlang.org/tsconfig/#rootDirs) option to let you conveniently import from the typegen file as if it was a sibling:\n+\n+```ts\n+// app/routes/product.tsx\n+import { LoaderArgs, DefaultProps } from \"./+types.product\";\n+```\n+\n+TypeScript will even give you import autocompletion for the typegen file and the `+` prefix helps to distinguish it as a special file.\n+Big thanks to Svelte Kit for showing us that [`rootDirs` trick](https://svelte.dev/blog/zero-config-type-safety#virtual-files)!\n+\n+### TypeScript plugin\n+\n+Typegen solutions often receive criticism due to typegen'd files becoming out of sync during development.\n+This happens because many typegen solutions require you to then rerun a script to update the typegen'd files.\n+\n+Instead, our typegen will automatically run within a TypeScript plugin.\n+That means you should never need to manually run a typegen command during development.\n+It also means that you don't need to run our dev server for typegen to take effect.\n+The only requirement is that your editor is open.",
        "comment_created_at": "2024-10-02T13:55:06+00:00",
        "comment_author": "gustavopch",
        "comment_body": "Call `react-router typegen`.\r\n\r\nhttps://github.com/remix-run/react-router/pull/12019/files/7e87c5de8dd3559f40c5c6381f86ef2c83a7754b#diff-b4decd81f218989fd648eb6fe661b12169a00eb76bcfa9846c949df6818bcea1R57-R60",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1823428975",
    "pr_number": 12210,
    "pr_file": "docs/how-to/setting-up-type-safety.md",
    "created_at": "2024-10-30T21:40:17+00:00",
    "commented_code": "+---\n+title: Setting up type safety\n+---\n+\n+To know more about how type safety works in React Router, check out our [dedicated explanation](../explanation//type-safety.md).\n+\n+# Setting up type safety\n+\n+React Router generates types for into a `.react-router/` directory at the root of your app.\n+This directory is fully managed by React Router and is derived from your route config (`app/routes.ts` by default), so it should be gitignore'd.\n+\n+\ud83d\udc49 **Add `.react-router/` to `.gitignore`**\n+\n+```txt\n+.react-router/\n+```\n+\n+You should also ensure that generated types are always present before running typechecking,\n+especially for running typechecking in CI.\n+\n+\ud83d\udc49 **Add `react-router typegen` to your `typecheck` command in `package.json`**\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"typecheck\": \"react-router typegen && tsc\"\n+  }\n+}\n+```\n+\n+To get TypeScript to use those generated types, you'll need to add them to `include` in `tsconfig.json`.\n+And to be able to import them as if they files next to your route modules, you'll also need to [configure `rootDirs`](https://www.typescriptlang.org/tsconfig/#rootDirs).\n+\n+\ud83d\udc49 **Configure `tsconfig.json` for generated types**\n+\n+```json\n+{\n+  \"include\": [\".react-router/types/**/*\"],\n+  \"compilerOptions\": {\n+    \"rootDirs\": [\".\", \"./.react-router/types\"]\n+  }\n+}\n+```\n+\n+## Automatic typegen in VSCode (optional)\n+\n+If you'd rather not need to remember to run `react-router typegen --watch` every time you start working on your app, you can use [VSCode Tasks](https://code.visualstudio.com/docs/editor/tasks) to automate this.",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1823428975",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "docs/how-to/setting-up-type-safety.md",
        "discussion_id": "1823428975",
        "commented_code": "@@ -0,0 +1,92 @@\n+---\n+title: Setting up type safety\n+---\n+\n+To know more about how type safety works in React Router, check out our [dedicated explanation](../explanation//type-safety.md).\n+\n+# Setting up type safety\n+\n+React Router generates types for into a `.react-router/` directory at the root of your app.\n+This directory is fully managed by React Router and is derived from your route config (`app/routes.ts` by default), so it should be gitignore'd.\n+\n+\ud83d\udc49 **Add `.react-router/` to `.gitignore`**\n+\n+```txt\n+.react-router/\n+```\n+\n+You should also ensure that generated types are always present before running typechecking,\n+especially for running typechecking in CI.\n+\n+\ud83d\udc49 **Add `react-router typegen` to your `typecheck` command in `package.json`**\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"typecheck\": \"react-router typegen && tsc\"\n+  }\n+}\n+```\n+\n+To get TypeScript to use those generated types, you'll need to add them to `include` in `tsconfig.json`.\n+And to be able to import them as if they files next to your route modules, you'll also need to [configure `rootDirs`](https://www.typescriptlang.org/tsconfig/#rootDirs).\n+\n+\ud83d\udc49 **Configure `tsconfig.json` for generated types**\n+\n+```json\n+{\n+  \"include\": [\".react-router/types/**/*\"],\n+  \"compilerOptions\": {\n+    \"rootDirs\": [\".\", \"./.react-router/types\"]\n+  }\n+}\n+```\n+\n+## Automatic typegen in VSCode (optional)\n+\n+If you'd rather not need to remember to run `react-router typegen --watch` every time you start working on your app, you can use [VSCode Tasks](https://code.visualstudio.com/docs/editor/tasks) to automate this.",
        "comment_created_at": "2024-10-30T21:40:17+00:00",
        "comment_author": "brookslybrand",
        "comment_body": "This is the first time the watch flag has been mentioned. Should this command be referenced above? I imagine whether you're using vscode or not you'll want to add this script",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1823538276",
    "pr_number": 12210,
    "pr_file": "decisions/0012-type-inference.md",
    "created_at": "2024-10-30T22:40:55+00:00",
    "commented_code": "For Svelte Kit, this isn't as big of an issue since they already need their own typecheck command for the Svelte language: `svelte-check`.\n    But since React Router is pure TypeScript, it would be more natural to invoke `tsc` directly in your `package.json` scripts.\n \n+### TypeScript plugin\n+\n+Originally, we created a basic TypeScript plugin to automatically run typegen in watch mode.\n+One nice thing about this approach is that it worked across all editors.\n+\n+However, there were a couple drawbacks:\n+\n+1. A TypeScript plugin will silently fail to run unless you have installed dependencies prior to opening up the project in your editor.\n+\n+2. A TypeScript plugin requires your editor to use the local (workspace) version of TypeScript.\n+   But by default [VSCode won't use the workspace version of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript), forcing you to run the `Select TypeScript Version` command every time you open up a new project.\n+   You can workaround this via the `typescript.tsdk` and `typescript.enablePromptUseWorkspaceTsdk` options in `.vscode/settings.json`, but those only take effect when that _specific_ directory is opened as by VSCode.\n+   For example, if you added `.vscode/settings.json` to a subfolder of a monorepo those options would be ignored when opening the root of the monorepo with VSCode.\n+\n+3. Debugging a TypeScript plugin is not straightforward as you need to know to run the `Open TS Server log` command in VSCode and sift through verbose logs.\n+   Without this knowledge, its hard to know if you've set up typegen correctly.\n+   And even if you do know this, its tedious to find out what went wrong.\n+\n+After we decided not to purse \"zero-effort typesafety\" (as described above), our TypeScript plugin was already a simple passthrough that kicked off typegen as a side-effect.",
    "repo_full_name": "remix-run/react-router",
    "discussion_comments": [
      {
        "comment_id": "1823538276",
        "repo_full_name": "remix-run/react-router",
        "pr_number": 12210,
        "pr_file": "decisions/0012-type-inference.md",
        "discussion_id": "1823538276",
        "commented_code": "@@ -265,6 +255,27 @@ Initially, this seemed like a good fit for React Router too, but we ran into a c\n    For Svelte Kit, this isn't as big of an issue since they already need their own typecheck command for the Svelte language: `svelte-check`.\n    But since React Router is pure TypeScript, it would be more natural to invoke `tsc` directly in your `package.json` scripts.\n \n+### TypeScript plugin\n+\n+Originally, we created a basic TypeScript plugin to automatically run typegen in watch mode.\n+One nice thing about this approach is that it worked across all editors.\n+\n+However, there were a couple drawbacks:\n+\n+1. A TypeScript plugin will silently fail to run unless you have installed dependencies prior to opening up the project in your editor.\n+\n+2. A TypeScript plugin requires your editor to use the local (workspace) version of TypeScript.\n+   But by default [VSCode won't use the workspace version of TypeScript](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript), forcing you to run the `Select TypeScript Version` command every time you open up a new project.\n+   You can workaround this via the `typescript.tsdk` and `typescript.enablePromptUseWorkspaceTsdk` options in `.vscode/settings.json`, but those only take effect when that _specific_ directory is opened as by VSCode.\n+   For example, if you added `.vscode/settings.json` to a subfolder of a monorepo those options would be ignored when opening the root of the monorepo with VSCode.\n+\n+3. Debugging a TypeScript plugin is not straightforward as you need to know to run the `Open TS Server log` command in VSCode and sift through verbose logs.\n+   Without this knowledge, its hard to know if you've set up typegen correctly.\n+   And even if you do know this, its tedious to find out what went wrong.\n+\n+After we decided not to purse \"zero-effort typesafety\" (as described above), our TypeScript plugin was already a simple passthrough that kicked off typegen as a side-effect.",
        "comment_created_at": "2024-10-30T22:40:55+00:00",
        "comment_author": "markdalgleish",
        "comment_body": "```suggestion\r\nAfter we decided not to pursue \"zero-effort typesafety\" (as described above), our TypeScript plugin was already a simple passthrough that kicked off typegen as a side-effect.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]