[
  {
    "discussion_id": "2071481512",
    "pr_number": 732,
    "pr_file": "refact-agent/engine/src/indexing_utils.rs",
    "created_at": "2025-05-02T11:31:39+00:00",
    "commented_code": "+use std::time::Duration;\n+use tracing::info;\n+use tokio::sync::RwLock as ARwLock;\n+use std::sync::Arc;\n+\n+use crate::global_context::GlobalContext;\n+use crate::http::routers::v1::status::get_rag_status;\n+\n+/// Waits for both AST and VecDB indexing to complete based on --wait-ast and --wait-vecdb.\n+pub async fn wait_for_indexing(",
    "repo_full_name": "smallcloudai/refact",
    "discussion_comments": [
      {
        "comment_id": "2071481512",
        "repo_full_name": "smallcloudai/refact",
        "pr_number": 732,
        "pr_file": "refact-agent/engine/src/indexing_utils.rs",
        "discussion_id": "2071481512",
        "commented_code": "@@ -0,0 +1,50 @@\n+use std::time::Duration;\n+use tracing::info;\n+use tokio::sync::RwLock as ARwLock;\n+use std::sync::Arc;\n+\n+use crate::global_context::GlobalContext;\n+use crate::http::routers::v1::status::get_rag_status;\n+\n+/// Waits for both AST and VecDB indexing to complete based on --wait-ast and --wait-vecdb.\n+pub async fn wait_for_indexing(",
        "comment_created_at": "2025-05-02T11:31:39+00:00",
        "comment_author": "humbertoyusta",
        "comment_body": "I would add something in the name that makes more clear that is conditional, I would prefer something like `_if_needed` or _maybe` at the end",
        "pr_file_module": null
      },
      {
        "comment_id": "2071503693",
        "repo_full_name": "smallcloudai/refact",
        "pr_number": 732,
        "pr_file": "refact-agent/engine/src/indexing_utils.rs",
        "discussion_id": "2071481512",
        "commented_code": "@@ -0,0 +1,50 @@\n+use std::time::Duration;\n+use tracing::info;\n+use tokio::sync::RwLock as ARwLock;\n+use std::sync::Arc;\n+\n+use crate::global_context::GlobalContext;\n+use crate::http::routers::v1::status::get_rag_status;\n+\n+/// Waits for both AST and VecDB indexing to complete based on --wait-ast and --wait-vecdb.\n+pub async fn wait_for_indexing(",
        "comment_created_at": "2025-05-02T11:51:51+00:00",
        "comment_author": "MDario123",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2102183634",
    "pr_number": 786,
    "pr_file": "refact-agent/engine/src/files_correction_cache.rs",
    "created_at": "2025-05-22T10:09:53+00:00",
    "commented_code": "+use std::collections::{HashMap, HashSet};\n+use std::path::{PathBuf};\n+\n+struct TrieNode {\n+    children: HashMap<usize, TrieNode>,\n+    count: usize,\n+    is_root: bool,\n+}\n+\n+impl TrieNode {\n+    fn new() -> Self {\n+        TrieNode {\n+            children: HashMap::new(),\n+            count: 0,\n+            is_root: false,\n+        }\n+    }\n+}\n+\n+pub struct PathTrie {\n+    root: TrieNode,\n+    index_to_component: HashMap<usize, String>,\n+}\n+\n+fn shortest_root_path(path: &PathBuf, root_paths: &Vec<PathBuf>) -> PathBuf {\n+    for root_path in root_paths.iter() {\n+        match path.strip_prefix(&root_path) {\n+            Ok(_) => return root_path.clone(),\n+            Err(_) => continue,\n+        }\n+    }\n+    PathBuf::new()\n+}\n+\n+pub struct ShortestPathsIter<'a> {\n+    trie: &'a PathTrie,\n+    stack: Vec<(\n+        &'a TrieNode,\n+        HashSet<usize>,\n+        String,\n+    )>,\n+}\n+\n+impl<'a> Iterator for ShortestPathsIter<'a> {\n+    type Item = String;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        while let Some((node, indices_to_process, _)) = self.stack.last_mut() {\n+            // 1. if node is_root or have no children we should end with the node and return path\n+            if node.is_root || node.children.is_empty() {\n+                let mut path = PathBuf::new();\n+                for (_, _, component) in self.stack.iter().rev() {\n+                    if !component.is_empty() {\n+                        path.push(component);\n+                    }\n+                }\n+                self.stack.pop();\n+                return Some(path.to_string_lossy().to_string());\n+            }\n+            // 2. go deeper or end with the node\n+            if let Some(index) = indices_to_process.iter().next().cloned() {\n+                indices_to_process.remove(&index);\n+                let child = node.children.get(&index).unwrap();\n+                let component = if child.is_root {\n+                    String::new()  // we don't want to add root_path component\n+                } else {\n+                    self.trie.index_to_component.get(&index).unwrap().clone()\n+                };\n+                self.stack.push((\n+                    child,\n+                    child.children.keys().cloned().collect::<HashSet<usize>>(),\n+                    component,\n+                ));\n+            } else {\n+                self.stack.pop();\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl PathTrie {\n+    pub fn new() -> Self {\n+        PathTrie {\n+            root: TrieNode::new(),\n+            index_to_component: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn build(paths: &Vec<PathBuf>, root_paths: &Vec<PathBuf>) -> Self {\n+        let mut root = TrieNode::new();\n+        let mut component_to_index = HashMap::new();\n+        let mut index_to_component = HashMap::new();\n+\n+        // NOTE: root paths should be sorted with shortest at front\n+        let mut sorted_root_paths = root_paths.clone();\n+        sorted_root_paths.sort_by(|a, b| {\n+            let component_count_a = a.components().count();\n+            let component_count_b = b.components().count();\n+            match component_count_a.cmp(&component_count_b) {\n+                std::cmp::Ordering::Equal => {\n+                    a.cmp(b)\n+                },\n+                other => other\n+            }\n+        });\n+\n+        for path in paths.iter() {\n+            // 1. find shortest root for given path (can be empty)\n+            let root_path = shortest_root_path(path, &sorted_root_paths);\n+            let root_path_components = root_path.components().count();\n+\n+            let components: Vec<String> = path\n+                .components()\n+                .map(|comp| comp.as_os_str().to_string_lossy().to_string())\n+                .collect();\n+\n+            // 2. iteratively insert components of the path\n+            // (can be root_path instead of single component)\n+            let mut node = &mut root;\n+            for i in (0..components.len()).rev() {\n+                let is_root = root_path_components == i + 1;\n+                let component = if is_root {\n+                    &root_path.to_string_lossy().to_string()\n+                } else {\n+                    &components[i]\n+                };\n+                let index = if let Some(index) = component_to_index.get(component) {\n+                    *index\n+                } else {\n+                    let index = component_to_index.len();\n+                    component_to_index.insert(component.clone(), index);\n+                    index_to_component.insert(index, component.clone());\n+                    index\n+                };\n+                node = node.children.entry(index).or_insert_with(TrieNode::new);\n+                node.count += 1;\n+                node.is_root = is_root;\n+                if is_root {\n+                    node.is_root = is_root;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        PathTrie { root, index_to_component }\n+    }\n+\n+    fn _search_for_nodes(&self, path: &PathBuf) -> Vec<(&TrieNode, PathBuf)> {\n+        let mut nodes = vec![];\n+        let mut components: Vec<String> = path\n+            .components()\n+            .map(|comp| comp.as_os_str().to_string_lossy().to_string())\n+            .collect();\n+\n+        let mut current = &self.root;\n+        loop {\n+            // 1. collect root_component_postfix and pop next component\n+            let mut components_prefix = PathBuf::new();\n+            for component in components.iter() {\n+                components_prefix.push(component.clone());\n+            }\n+            let component = components.pop().unwrap();\n+\n+            // 2. iterate over all children: match root ones and find next\n+            let mut is_next_found = false;\n+            for (index, child) in current.children.iter() {\n+                if let Some(child_component) = self.index_to_component.get(index) {\n+                    if child.is_root {\n+                        let mut root_path = PathBuf::from(child_component);\n+                        if !root_path.ends_with(&components_prefix) {\n+                            continue;\n+                        }\n+                        match path.strip_prefix(&components_prefix) {\n+                            Ok(root_relative_path) => {\n+                                root_path.push(root_relative_path);\n+                                nodes.push((child, root_path));\n+                            },\n+                            Err(_) => continue,  // should not happen, but anyway\n+                        };\n+                    } else if *child_component == component {\n+                        is_next_found = true;\n+                        current = child;\n+                    }\n+                }\n+            }\n+\n+            // 3. give up if we can't find next node\n+            if !is_next_found {\n+                break;\n+            }\n+\n+            // 4. if no components we're break\n+            if components.is_empty() {\n+                nodes.push((current, path.clone()));\n+                break;\n+            }\n+        }\n+\n+        nodes\n+    }\n+\n+    #[allow(dead_code)]\n+    fn count_matches(&self, path: &PathBuf) -> usize {\n+        let mut counter = 0;\n+        for (node, _) in self._search_for_nodes(path) {\n+            counter += node.count;\n+        }\n+        counter\n+    }\n+\n+    pub fn find_matches(&self, path: &PathBuf) -> Vec<PathBuf> {\n+        let mut result = vec![];\n+        for (root_node, relative_path) in self._search_for_nodes(path) {\n+            if root_node.is_root {\n+                result.push(relative_path);\n+                continue;\n+            }\n+            let mut stack = Vec::new();\n+            stack.push((root_node, vec![]));\n+            while let Some((node, components)) = stack.pop() {\n+                if node.children.is_empty() {\n+                    let mut matched_path = PathBuf::new();\n+                    for index in components.iter().rev() {\n+                        let component = self.index_to_component.get(index).unwrap();\n+                        matched_path.push(component);\n+                    }\n+                    matched_path.push(path);\n+                    result.push(matched_path);\n+                } else {\n+                    for (index, child) in &node.children {\n+                        let mut child_components = components.clone();\n+                        child_components.push(*index);\n+                        stack.push((child, child_components));\n+                    }\n+                }\n+            }\n+        }\n+        result\n+    }\n+\n+    pub fn shortest_path(&self, path: &PathBuf) -> Option<PathBuf> {",
    "repo_full_name": "smallcloudai/refact",
    "discussion_comments": [
      {
        "comment_id": "2102183634",
        "repo_full_name": "smallcloudai/refact",
        "pr_number": 786,
        "pr_file": "refact-agent/engine/src/files_correction_cache.rs",
        "discussion_id": "2102183634",
        "commented_code": "@@ -0,0 +1,279 @@\n+use std::collections::{HashMap, HashSet};\n+use std::path::{PathBuf};\n+\n+struct TrieNode {\n+    children: HashMap<usize, TrieNode>,\n+    count: usize,\n+    is_root: bool,\n+}\n+\n+impl TrieNode {\n+    fn new() -> Self {\n+        TrieNode {\n+            children: HashMap::new(),\n+            count: 0,\n+            is_root: false,\n+        }\n+    }\n+}\n+\n+pub struct PathTrie {\n+    root: TrieNode,\n+    index_to_component: HashMap<usize, String>,\n+}\n+\n+fn shortest_root_path(path: &PathBuf, root_paths: &Vec<PathBuf>) -> PathBuf {\n+    for root_path in root_paths.iter() {\n+        match path.strip_prefix(&root_path) {\n+            Ok(_) => return root_path.clone(),\n+            Err(_) => continue,\n+        }\n+    }\n+    PathBuf::new()\n+}\n+\n+pub struct ShortestPathsIter<'a> {\n+    trie: &'a PathTrie,\n+    stack: Vec<(\n+        &'a TrieNode,\n+        HashSet<usize>,\n+        String,\n+    )>,\n+}\n+\n+impl<'a> Iterator for ShortestPathsIter<'a> {\n+    type Item = String;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        while let Some((node, indices_to_process, _)) = self.stack.last_mut() {\n+            // 1. if node is_root or have no children we should end with the node and return path\n+            if node.is_root || node.children.is_empty() {\n+                let mut path = PathBuf::new();\n+                for (_, _, component) in self.stack.iter().rev() {\n+                    if !component.is_empty() {\n+                        path.push(component);\n+                    }\n+                }\n+                self.stack.pop();\n+                return Some(path.to_string_lossy().to_string());\n+            }\n+            // 2. go deeper or end with the node\n+            if let Some(index) = indices_to_process.iter().next().cloned() {\n+                indices_to_process.remove(&index);\n+                let child = node.children.get(&index).unwrap();\n+                let component = if child.is_root {\n+                    String::new()  // we don't want to add root_path component\n+                } else {\n+                    self.trie.index_to_component.get(&index).unwrap().clone()\n+                };\n+                self.stack.push((\n+                    child,\n+                    child.children.keys().cloned().collect::<HashSet<usize>>(),\n+                    component,\n+                ));\n+            } else {\n+                self.stack.pop();\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl PathTrie {\n+    pub fn new() -> Self {\n+        PathTrie {\n+            root: TrieNode::new(),\n+            index_to_component: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn build(paths: &Vec<PathBuf>, root_paths: &Vec<PathBuf>) -> Self {\n+        let mut root = TrieNode::new();\n+        let mut component_to_index = HashMap::new();\n+        let mut index_to_component = HashMap::new();\n+\n+        // NOTE: root paths should be sorted with shortest at front\n+        let mut sorted_root_paths = root_paths.clone();\n+        sorted_root_paths.sort_by(|a, b| {\n+            let component_count_a = a.components().count();\n+            let component_count_b = b.components().count();\n+            match component_count_a.cmp(&component_count_b) {\n+                std::cmp::Ordering::Equal => {\n+                    a.cmp(b)\n+                },\n+                other => other\n+            }\n+        });\n+\n+        for path in paths.iter() {\n+            // 1. find shortest root for given path (can be empty)\n+            let root_path = shortest_root_path(path, &sorted_root_paths);\n+            let root_path_components = root_path.components().count();\n+\n+            let components: Vec<String> = path\n+                .components()\n+                .map(|comp| comp.as_os_str().to_string_lossy().to_string())\n+                .collect();\n+\n+            // 2. iteratively insert components of the path\n+            // (can be root_path instead of single component)\n+            let mut node = &mut root;\n+            for i in (0..components.len()).rev() {\n+                let is_root = root_path_components == i + 1;\n+                let component = if is_root {\n+                    &root_path.to_string_lossy().to_string()\n+                } else {\n+                    &components[i]\n+                };\n+                let index = if let Some(index) = component_to_index.get(component) {\n+                    *index\n+                } else {\n+                    let index = component_to_index.len();\n+                    component_to_index.insert(component.clone(), index);\n+                    index_to_component.insert(index, component.clone());\n+                    index\n+                };\n+                node = node.children.entry(index).or_insert_with(TrieNode::new);\n+                node.count += 1;\n+                node.is_root = is_root;\n+                if is_root {\n+                    node.is_root = is_root;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        PathTrie { root, index_to_component }\n+    }\n+\n+    fn _search_for_nodes(&self, path: &PathBuf) -> Vec<(&TrieNode, PathBuf)> {\n+        let mut nodes = vec![];\n+        let mut components: Vec<String> = path\n+            .components()\n+            .map(|comp| comp.as_os_str().to_string_lossy().to_string())\n+            .collect();\n+\n+        let mut current = &self.root;\n+        loop {\n+            // 1. collect root_component_postfix and pop next component\n+            let mut components_prefix = PathBuf::new();\n+            for component in components.iter() {\n+                components_prefix.push(component.clone());\n+            }\n+            let component = components.pop().unwrap();\n+\n+            // 2. iterate over all children: match root ones and find next\n+            let mut is_next_found = false;\n+            for (index, child) in current.children.iter() {\n+                if let Some(child_component) = self.index_to_component.get(index) {\n+                    if child.is_root {\n+                        let mut root_path = PathBuf::from(child_component);\n+                        if !root_path.ends_with(&components_prefix) {\n+                            continue;\n+                        }\n+                        match path.strip_prefix(&components_prefix) {\n+                            Ok(root_relative_path) => {\n+                                root_path.push(root_relative_path);\n+                                nodes.push((child, root_path));\n+                            },\n+                            Err(_) => continue,  // should not happen, but anyway\n+                        };\n+                    } else if *child_component == component {\n+                        is_next_found = true;\n+                        current = child;\n+                    }\n+                }\n+            }\n+\n+            // 3. give up if we can't find next node\n+            if !is_next_found {\n+                break;\n+            }\n+\n+            // 4. if no components we're break\n+            if components.is_empty() {\n+                nodes.push((current, path.clone()));\n+                break;\n+            }\n+        }\n+\n+        nodes\n+    }\n+\n+    #[allow(dead_code)]\n+    fn count_matches(&self, path: &PathBuf) -> usize {\n+        let mut counter = 0;\n+        for (node, _) in self._search_for_nodes(path) {\n+            counter += node.count;\n+        }\n+        counter\n+    }\n+\n+    pub fn find_matches(&self, path: &PathBuf) -> Vec<PathBuf> {\n+        let mut result = vec![];\n+        for (root_node, relative_path) in self._search_for_nodes(path) {\n+            if root_node.is_root {\n+                result.push(relative_path);\n+                continue;\n+            }\n+            let mut stack = Vec::new();\n+            stack.push((root_node, vec![]));\n+            while let Some((node, components)) = stack.pop() {\n+                if node.children.is_empty() {\n+                    let mut matched_path = PathBuf::new();\n+                    for index in components.iter().rev() {\n+                        let component = self.index_to_component.get(index).unwrap();\n+                        matched_path.push(component);\n+                    }\n+                    matched_path.push(path);\n+                    result.push(matched_path);\n+                } else {\n+                    for (index, child) in &node.children {\n+                        let mut child_components = components.clone();\n+                        child_components.push(*index);\n+                        stack.push((child, child_components));\n+                    }\n+                }\n+            }\n+        }\n+        result\n+    }\n+\n+    pub fn shortest_path(&self, path: &PathBuf) -> Option<PathBuf> {",
        "comment_created_at": "2025-05-22T10:09:53+00:00",
        "comment_author": "humbertoyusta",
        "comment_body": "Same comment as in previous PR:\r\n\r\nThis unique paths, for fuzzy search, or return to front end/IDE, are meant to be like the previous cache_shortened, to do fuzzy search over them, we'll need them to be AT LEAST the length from workspace folder, for example, if I have opened my project in /home/user/work/ and I have a file /home/user/work/dir1/file.ext, it should never be shortened to just file.ext but to dir1/file.ext",
        "pr_file_module": null
      }
    ]
  }
]