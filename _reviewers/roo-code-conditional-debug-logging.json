[
  {
    "discussion_id": "2219691881",
    "pr_number": 5626,
    "pr_file": "webview-ui/src/components/file-changes/FilesChangedOverview.tsx",
    "created_at": "2025-07-21T16:31:03+00:00",
    "commented_code": "+import React from \"react\"\n+import { FileChangeset, FileChange } from \"@roo-code/types\"\n+import { useTranslation } from \"react-i18next\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { vscode } from \"@/utils/vscode\"\n+\n+// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n+interface FilesChangedOverviewProps {}\n+\n+interface _CheckpointEventData {\n+\ttype: \"checkpoint_created\" | \"checkpoint_restored\"\n+\tcheckpoint: string\n+\tpreviousCheckpoint?: string\n+}\n+\n+/**\n+ * FilesChangedOverview is a self-managing component that listens for checkpoint events\n+ * and displays file changes. It manages its own state and communicates with the backend\n+ * through VS Code message passing.\n+ */\n+const FilesChangedOverview: React.FC<FilesChangedOverviewProps> = () => {\n+\tconst { t } = useTranslation()\n+\tconst { filesChangedEnabled } = useExtensionState()\n+\n+\t// Self-managed state\n+\tconst [changeset, setChangeset] = React.useState<FileChangeset | null>(null)\n+\tconst [isInitialized, setIsInitialized] = React.useState(false)\n+\n+\tconst files = React.useMemo(() => changeset?.files || [], [changeset?.files])\n+\tconst [isCollapsed, setIsCollapsed] = React.useState(true)\n+\n+\t// Performance optimization: Use virtualization for large file lists\n+\tconst VIRTUALIZATION_THRESHOLD = 50\n+\tconst ITEM_HEIGHT = 32 // Approximate height of each file item\n+\tconst MAX_VISIBLE_ITEMS = 10\n+\tconst [scrollTop, setScrollTop] = React.useState(0)\n+\n+\tconst shouldVirtualize = files.length > VIRTUALIZATION_THRESHOLD\n+\n+\t// Calculate visible items for virtualization\n+\tconst visibleItems = React.useMemo(() => {\n+\t\tif (!shouldVirtualize) return files\n+\n+\t\tconst startIndex = Math.floor(scrollTop / ITEM_HEIGHT)\n+\t\tconst endIndex = Math.min(startIndex + MAX_VISIBLE_ITEMS, files.length)\n+\t\treturn files.slice(startIndex, endIndex).map((file, index) => ({\n+\t\t\t...file,\n+\t\t\tvirtualIndex: startIndex + index,\n+\t\t}))\n+\t}, [files, scrollTop, shouldVirtualize])\n+\n+\tconst totalHeight = shouldVirtualize ? files.length * ITEM_HEIGHT : \"auto\"\n+\tconst offsetY = shouldVirtualize ? Math.floor(scrollTop / ITEM_HEIGHT) * ITEM_HEIGHT : 0\n+\n+\t// Simple double-click prevention\n+\tconst [isProcessing, setIsProcessing] = React.useState(false)\n+\tconst timeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n+\n+\t// Cleanup timeout on unmount\n+\tReact.useEffect(() => {\n+\t\treturn () => {\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t}\n+\t}, [])\n+\n+\t// FCO initialization logic\n+\tconst checkInit = React.useCallback(\n+\t\t(baseCheckpoint: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tconsole.log(\"[FCO] Initializing with base checkpoint:\", baseCheckpoint)\n+\t\t\t\tsetIsInitialized(true)\n+\t\t\t}\n+\t\t},\n+\t\t[isInitialized],\n+\t)\n+\n+\t// Update changeset - backend handles filtering, no local filtering needed\n+\tconst updateChangeset = React.useCallback((newChangeset: FileChangeset) => {\n+\t\tsetChangeset(newChangeset)\n+\t}, [])\n+\n+\t// Handle checkpoint creation\n+\tconst handleCheckpointCreated = React.useCallback(\n+\t\t(checkpoint: string, previousCheckpoint?: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tcheckInit(previousCheckpoint || checkpoint)\n+\t\t\t}\n+\t\t\t// Note: Backend automatically sends file changes during checkpoint creation\n+\t\t\t// No need to request them here - just wait for the filesChanged message\n+\t\t},\n+\t\t[isInitialized, checkInit],\n+\t)\n+\n+\t// Handle checkpoint restoration with the 4 examples logic\n+\tconst handleCheckpointRestored = React.useCallback((restoredCheckpoint: string) => {\n+\t\tconsole.log(\"[FCO] Handling checkpoint restore to:\", restoredCheckpoint)\n+\n+\t\t// Request file changes after checkpoint restore\n+\t\t// Backend should calculate changes from initial baseline to restored checkpoint\n+\t\tvscode.postMessage({ type: \"filesChangedRequest\" })\n+\t}, [])\n+\n+\t// Action handlers\n+\tconst handleViewDiff = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"viewDiff\", uri })\n+\t}, [])\n+\n+\tconst handleAcceptFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"acceptFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"rejectFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleAcceptAll = React.useCallback(() => {\n+\t\tvscode.postMessage({ type: \"acceptAllFileChanges\" })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectAll = React.useCallback(() => {\n+\t\tconst visibleUris = files.map((file) => file.uri)\n+\t\tvscode.postMessage({ type: \"rejectAllFileChanges\", uris: visibleUris })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [files])\n+\n+\tconst handleWithDebounce = React.useCallback(\n+\t\tasync (operation: () => void) => {\n+\t\t\tif (isProcessing) return\n+\t\t\tsetIsProcessing(true)\n+\t\t\ttry {\n+\t\t\t\toperation()\n+\t\t\t} catch (_error) {\n+\t\t\t\t// Silently handle any errors to prevent crashing\n+\t\t\t\t// Debug logging removed for production\n+\t\t\t}\n+\t\t\t// Brief delay to prevent double-clicks\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t\ttimeoutRef.current = setTimeout(() => setIsProcessing(false), 300)\n+\t\t},\n+\t\t[isProcessing],\n+\t)\n+\n+\t/**\n+\t * Handles scroll events for virtualization\n+\t * Updates scrollTop state to calculate visible items\n+\t */\n+\tconst handleScroll = React.useCallback(\n+\t\t(e: React.UIEvent<HTMLDivElement>) => {\n+\t\t\tif (shouldVirtualize) {\n+\t\t\t\tsetScrollTop(e.currentTarget.scrollTop)\n+\t\t\t}\n+\t\t},\n+\t\t[shouldVirtualize],\n+\t)\n+\n+\t// Listen for filesChanged messages from the backend\n+\tReact.useEffect(() => {\n+\t\tconst handleMessage = (event: MessageEvent) => {\n+\t\t\tconst message = event.data\n+\n+\t\t\t// Guard against null/undefined/malformed messages\n+\t\t\tif (!message || typeof message !== \"object\" || !message.type) {\n+\t\t\t\tconsole.debug(\"[FCO] Ignoring malformed message:\", message)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tswitch (message.type) {\n+\t\t\t\tcase \"filesChanged\":\n+\t\t\t\t\tif (message.filesChanged) {\n+\t\t\t\t\t\tconsole.log(\"[FCO] Received filesChanged message:\", message.filesChanged)",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2219691881",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5626,
        "pr_file": "webview-ui/src/components/file-changes/FilesChangedOverview.tsx",
        "discussion_id": "2219691881",
        "commented_code": "@@ -0,0 +1,516 @@\n+import React from \"react\"\n+import { FileChangeset, FileChange } from \"@roo-code/types\"\n+import { useTranslation } from \"react-i18next\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { vscode } from \"@/utils/vscode\"\n+\n+// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n+interface FilesChangedOverviewProps {}\n+\n+interface _CheckpointEventData {\n+\ttype: \"checkpoint_created\" | \"checkpoint_restored\"\n+\tcheckpoint: string\n+\tpreviousCheckpoint?: string\n+}\n+\n+/**\n+ * FilesChangedOverview is a self-managing component that listens for checkpoint events\n+ * and displays file changes. It manages its own state and communicates with the backend\n+ * through VS Code message passing.\n+ */\n+const FilesChangedOverview: React.FC<FilesChangedOverviewProps> = () => {\n+\tconst { t } = useTranslation()\n+\tconst { filesChangedEnabled } = useExtensionState()\n+\n+\t// Self-managed state\n+\tconst [changeset, setChangeset] = React.useState<FileChangeset | null>(null)\n+\tconst [isInitialized, setIsInitialized] = React.useState(false)\n+\n+\tconst files = React.useMemo(() => changeset?.files || [], [changeset?.files])\n+\tconst [isCollapsed, setIsCollapsed] = React.useState(true)\n+\n+\t// Performance optimization: Use virtualization for large file lists\n+\tconst VIRTUALIZATION_THRESHOLD = 50\n+\tconst ITEM_HEIGHT = 32 // Approximate height of each file item\n+\tconst MAX_VISIBLE_ITEMS = 10\n+\tconst [scrollTop, setScrollTop] = React.useState(0)\n+\n+\tconst shouldVirtualize = files.length > VIRTUALIZATION_THRESHOLD\n+\n+\t// Calculate visible items for virtualization\n+\tconst visibleItems = React.useMemo(() => {\n+\t\tif (!shouldVirtualize) return files\n+\n+\t\tconst startIndex = Math.floor(scrollTop / ITEM_HEIGHT)\n+\t\tconst endIndex = Math.min(startIndex + MAX_VISIBLE_ITEMS, files.length)\n+\t\treturn files.slice(startIndex, endIndex).map((file, index) => ({\n+\t\t\t...file,\n+\t\t\tvirtualIndex: startIndex + index,\n+\t\t}))\n+\t}, [files, scrollTop, shouldVirtualize])\n+\n+\tconst totalHeight = shouldVirtualize ? files.length * ITEM_HEIGHT : \"auto\"\n+\tconst offsetY = shouldVirtualize ? Math.floor(scrollTop / ITEM_HEIGHT) * ITEM_HEIGHT : 0\n+\n+\t// Simple double-click prevention\n+\tconst [isProcessing, setIsProcessing] = React.useState(false)\n+\tconst timeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n+\n+\t// Cleanup timeout on unmount\n+\tReact.useEffect(() => {\n+\t\treturn () => {\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t}\n+\t}, [])\n+\n+\t// FCO initialization logic\n+\tconst checkInit = React.useCallback(\n+\t\t(baseCheckpoint: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tconsole.log(\"[FCO] Initializing with base checkpoint:\", baseCheckpoint)\n+\t\t\t\tsetIsInitialized(true)\n+\t\t\t}\n+\t\t},\n+\t\t[isInitialized],\n+\t)\n+\n+\t// Update changeset - backend handles filtering, no local filtering needed\n+\tconst updateChangeset = React.useCallback((newChangeset: FileChangeset) => {\n+\t\tsetChangeset(newChangeset)\n+\t}, [])\n+\n+\t// Handle checkpoint creation\n+\tconst handleCheckpointCreated = React.useCallback(\n+\t\t(checkpoint: string, previousCheckpoint?: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tcheckInit(previousCheckpoint || checkpoint)\n+\t\t\t}\n+\t\t\t// Note: Backend automatically sends file changes during checkpoint creation\n+\t\t\t// No need to request them here - just wait for the filesChanged message\n+\t\t},\n+\t\t[isInitialized, checkInit],\n+\t)\n+\n+\t// Handle checkpoint restoration with the 4 examples logic\n+\tconst handleCheckpointRestored = React.useCallback((restoredCheckpoint: string) => {\n+\t\tconsole.log(\"[FCO] Handling checkpoint restore to:\", restoredCheckpoint)\n+\n+\t\t// Request file changes after checkpoint restore\n+\t\t// Backend should calculate changes from initial baseline to restored checkpoint\n+\t\tvscode.postMessage({ type: \"filesChangedRequest\" })\n+\t}, [])\n+\n+\t// Action handlers\n+\tconst handleViewDiff = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"viewDiff\", uri })\n+\t}, [])\n+\n+\tconst handleAcceptFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"acceptFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"rejectFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleAcceptAll = React.useCallback(() => {\n+\t\tvscode.postMessage({ type: \"acceptAllFileChanges\" })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectAll = React.useCallback(() => {\n+\t\tconst visibleUris = files.map((file) => file.uri)\n+\t\tvscode.postMessage({ type: \"rejectAllFileChanges\", uris: visibleUris })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [files])\n+\n+\tconst handleWithDebounce = React.useCallback(\n+\t\tasync (operation: () => void) => {\n+\t\t\tif (isProcessing) return\n+\t\t\tsetIsProcessing(true)\n+\t\t\ttry {\n+\t\t\t\toperation()\n+\t\t\t} catch (_error) {\n+\t\t\t\t// Silently handle any errors to prevent crashing\n+\t\t\t\t// Debug logging removed for production\n+\t\t\t}\n+\t\t\t// Brief delay to prevent double-clicks\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t\ttimeoutRef.current = setTimeout(() => setIsProcessing(false), 300)\n+\t\t},\n+\t\t[isProcessing],\n+\t)\n+\n+\t/**\n+\t * Handles scroll events for virtualization\n+\t * Updates scrollTop state to calculate visible items\n+\t */\n+\tconst handleScroll = React.useCallback(\n+\t\t(e: React.UIEvent<HTMLDivElement>) => {\n+\t\t\tif (shouldVirtualize) {\n+\t\t\t\tsetScrollTop(e.currentTarget.scrollTop)\n+\t\t\t}\n+\t\t},\n+\t\t[shouldVirtualize],\n+\t)\n+\n+\t// Listen for filesChanged messages from the backend\n+\tReact.useEffect(() => {\n+\t\tconst handleMessage = (event: MessageEvent) => {\n+\t\t\tconst message = event.data\n+\n+\t\t\t// Guard against null/undefined/malformed messages\n+\t\t\tif (!message || typeof message !== \"object\" || !message.type) {\n+\t\t\t\tconsole.debug(\"[FCO] Ignoring malformed message:\", message)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tswitch (message.type) {\n+\t\t\t\tcase \"filesChanged\":\n+\t\t\t\t\tif (message.filesChanged) {\n+\t\t\t\t\t\tconsole.log(\"[FCO] Received filesChanged message:\", message.filesChanged)",
        "comment_created_at": "2025-07-21T16:31:03+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "I noticed some `console.log` and `console.debug` statements here. Are these intended for debugging and should they be removed before merging?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2106264274",
    "pr_number": 3808,
    "pr_file": "webview-ui/src/components/mcp/McpErrorRow.tsx",
    "created_at": "2025-05-25T17:43:49+00:00",
    "commented_code": "export const McpErrorRow = ({ error }: McpErrorRowProps) => {\n \tconst color = useMemo(() => {\n+\t\t// Add debugging to log what level is coming in\n+\t\tconsole.log(`McpErrorRow level: ${error.level} for message: ${error.message.substring(0, 20)}...`)",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2106264274",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 3808,
        "pr_file": "webview-ui/src/components/mcp/McpErrorRow.tsx",
        "discussion_id": "2106264274",
        "commented_code": "@@ -9,20 +9,55 @@ type McpErrorRowProps = {\n \n export const McpErrorRow = ({ error }: McpErrorRowProps) => {\n \tconst color = useMemo(() => {\n+\t\t// Add debugging to log what level is coming in\n+\t\tconsole.log(`McpErrorRow level: ${error.level} for message: ${error.message.substring(0, 20)}...`)",
        "comment_created_at": "2025-05-25T17:43:49+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "This debug log is helpful for development but should be removed or gated behind a debug flag before production.\n```suggestion\n\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2080408129",
    "pr_number": 3355,
    "pr_file": "webview-ui/src/components/settings/__tests__/ApiOptions.test.tsx",
    "created_at": "2025-05-08T20:19:53+00:00",
    "commented_code": "),\n }))\n \n-jest.mock(\"@src/components/ui/hooks/useSelectedModel\", () => ({\n-\tuseSelectedModel: jest.fn((apiConfiguration: ApiConfiguration) => {\n-\t\tif (apiConfiguration.apiModelId?.includes(\"thinking\")) {\n-\t\t\treturn {\n-\t\t\t\tprovider: apiConfiguration.apiProvider,\n-\t\t\t\tinfo: { thinking: true, contextWindow: 4000, maxTokens: 128000 },\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn {\n-\t\t\t\tprovider: apiConfiguration.apiProvider,\n-\t\t\t\tinfo: { contextWindow: 4000 },\n-\t\t\t}\n-\t\t}\n-\t}),\n+// Modified mocks to accept shouldRender prop\n+jest.mock(\"../ReasoningEffort\", () => ({\n+\tReasoningEffort: () => <div data-testid=\"reasoning-effort-select\" />,\n }))\n \n-jest.mock(\"../ReasoningEffort\", () => ({\n-\tReasoningEffort: ({ apiConfiguration, setApiConfigurationField, value }: any) => (\n-\t\t<div data-testid=\"reasoning-effort-select\">\n-\t\t\t<select\n-\t\t\t\tvalue={value ?? apiConfiguration.openAiCustomModelInfo?.reasoningEffort}\n-\t\t\t\tonChange={(e) => setApiConfigurationField(\"reasoningEffort\", e.target.value)}>\n-\t\t\t\t<option value=\"auto\">Auto</option>\n-\t\t\t\t<option value=\"low\">Low</option>\n-\t\t\t\t<option value=\"medium\">Medium</option>\n-\t\t\t\t<option value=\"high\">High</option>\n-\t\t\t</select>\n-\t\t</div>\n-\t),\n+jest.mock(\"../ThinkingBudget\", () => ({\n+\tThinkingBudget: ({ _modelInfo }: { _modelInfo: any }) => {\n+\t\t// Always render the component for testing purposes\n+\t\treturn <div data-testid=\"mock-thinking-budget\" />\n+\t},\n+}))\n+\n+jest.mock(\"../MaxOutputTokensControl\", () => ({\n+\tMaxOutputTokensControl: ({ _modelInfo }: { _modelInfo: any }) => {\n+\t\t// Always render the component for testing purposes\n+\t\treturn <div data-testid=\"max-output-tokens-control\" />\n+\t},\n }))\n \n const renderApiOptions = (props: Partial<ApiOptionsProps> = {}) => {\n \tconst queryClient = new QueryClient()\n \n+\t// Log the value of useSelectedModel for debugging\n+\tconsole.log(\"useSelectedModel mock return value:\", (useSelectedModel as jest.Mock).mock.results)",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2080408129",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 3355,
        "pr_file": "webview-ui/src/components/settings/__tests__/ApiOptions.test.tsx",
        "discussion_id": "2080408129",
        "commented_code": "@@ -147,40 +174,31 @@ jest.mock(\"../DiffSettingsControl\", () => ({\n \t),\n }))\n \n-jest.mock(\"@src/components/ui/hooks/useSelectedModel\", () => ({\n-\tuseSelectedModel: jest.fn((apiConfiguration: ApiConfiguration) => {\n-\t\tif (apiConfiguration.apiModelId?.includes(\"thinking\")) {\n-\t\t\treturn {\n-\t\t\t\tprovider: apiConfiguration.apiProvider,\n-\t\t\t\tinfo: { thinking: true, contextWindow: 4000, maxTokens: 128000 },\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn {\n-\t\t\t\tprovider: apiConfiguration.apiProvider,\n-\t\t\t\tinfo: { contextWindow: 4000 },\n-\t\t\t}\n-\t\t}\n-\t}),\n+// Modified mocks to accept shouldRender prop\n+jest.mock(\"../ReasoningEffort\", () => ({\n+\tReasoningEffort: () => <div data-testid=\"reasoning-effort-select\" />,\n }))\n \n-jest.mock(\"../ReasoningEffort\", () => ({\n-\tReasoningEffort: ({ apiConfiguration, setApiConfigurationField, value }: any) => (\n-\t\t<div data-testid=\"reasoning-effort-select\">\n-\t\t\t<select\n-\t\t\t\tvalue={value ?? apiConfiguration.openAiCustomModelInfo?.reasoningEffort}\n-\t\t\t\tonChange={(e) => setApiConfigurationField(\"reasoningEffort\", e.target.value)}>\n-\t\t\t\t<option value=\"auto\">Auto</option>\n-\t\t\t\t<option value=\"low\">Low</option>\n-\t\t\t\t<option value=\"medium\">Medium</option>\n-\t\t\t\t<option value=\"high\">High</option>\n-\t\t\t</select>\n-\t\t</div>\n-\t),\n+jest.mock(\"../ThinkingBudget\", () => ({\n+\tThinkingBudget: ({ _modelInfo }: { _modelInfo: any }) => {\n+\t\t// Always render the component for testing purposes\n+\t\treturn <div data-testid=\"mock-thinking-budget\" />\n+\t},\n+}))\n+\n+jest.mock(\"../MaxOutputTokensControl\", () => ({\n+\tMaxOutputTokensControl: ({ _modelInfo }: { _modelInfo: any }) => {\n+\t\t// Always render the component for testing purposes\n+\t\treturn <div data-testid=\"max-output-tokens-control\" />\n+\t},\n }))\n \n const renderApiOptions = (props: Partial<ApiOptionsProps> = {}) => {\n \tconst queryClient = new QueryClient()\n \n+\t// Log the value of useSelectedModel for debugging\n+\tconsole.log(\"useSelectedModel mock return value:\", (useSelectedModel as jest.Mock).mock.results)",
        "comment_created_at": "2025-05-08T20:19:53+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Remove the `console.log` debugging statement before committing to keep test logs clean.\n```suggestion\n\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072365892",
    "pr_number": 3144,
    "pr_file": "webview-ui/src/components/chat/ChatView.tsx",
    "created_at": "2025-05-03T10:14:56+00:00",
    "commented_code": "}\n \n \t\t\tif (isCollapsing && isAtBottom) {\n-\t\t\t\tconst timer = setTimeout(() => scrollToBottomAuto(), 0)\n+\t\t\t\tconst timer = setTimeout(() => {\n+\t\t\t\t\tconsole.log(",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2072365892",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 3144,
        "pr_file": "webview-ui/src/components/chat/ChatView.tsx",
        "discussion_id": "2072365892",
        "commented_code": "@@ -969,51 +1277,98 @@ const ChatViewComponent: React.ForwardRefRenderFunction<ChatViewRef, ChatViewPro\n \t\t\t}\n \n \t\t\tif (isCollapsing && isAtBottom) {\n-\t\t\t\tconst timer = setTimeout(() => scrollToBottomAuto(), 0)\n+\t\t\t\tconst timer = setTimeout(() => {\n+\t\t\t\t\tconsole.log(",
        "comment_created_at": "2025-05-03T10:14:56+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "There are several debug `console.log` statements in functions like `toggleRowExpansion` and `handleRowHeightChange`; consider removing or conditionally disabling these logs in production for cleaner output.\n",
        "pr_file_module": null
      }
    ]
  }
]