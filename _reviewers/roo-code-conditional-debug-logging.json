[
  {
    "discussion_id": "2219691881",
    "pr_number": 5626,
    "pr_file": "webview-ui/src/components/file-changes/FilesChangedOverview.tsx",
    "created_at": "2025-07-21T16:31:03+00:00",
    "commented_code": "+import React from \"react\"\n+import { FileChangeset, FileChange } from \"@roo-code/types\"\n+import { useTranslation } from \"react-i18next\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { vscode } from \"@/utils/vscode\"\n+\n+// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n+interface FilesChangedOverviewProps {}\n+\n+interface _CheckpointEventData {\n+\ttype: \"checkpoint_created\" | \"checkpoint_restored\"\n+\tcheckpoint: string\n+\tpreviousCheckpoint?: string\n+}\n+\n+/**\n+ * FilesChangedOverview is a self-managing component that listens for checkpoint events\n+ * and displays file changes. It manages its own state and communicates with the backend\n+ * through VS Code message passing.\n+ */\n+const FilesChangedOverview: React.FC<FilesChangedOverviewProps> = () => {\n+\tconst { t } = useTranslation()\n+\tconst { filesChangedEnabled } = useExtensionState()\n+\n+\t// Self-managed state\n+\tconst [changeset, setChangeset] = React.useState<FileChangeset | null>(null)\n+\tconst [isInitialized, setIsInitialized] = React.useState(false)\n+\n+\tconst files = React.useMemo(() => changeset?.files || [], [changeset?.files])\n+\tconst [isCollapsed, setIsCollapsed] = React.useState(true)\n+\n+\t// Performance optimization: Use virtualization for large file lists\n+\tconst VIRTUALIZATION_THRESHOLD = 50\n+\tconst ITEM_HEIGHT = 32 // Approximate height of each file item\n+\tconst MAX_VISIBLE_ITEMS = 10\n+\tconst [scrollTop, setScrollTop] = React.useState(0)\n+\n+\tconst shouldVirtualize = files.length > VIRTUALIZATION_THRESHOLD\n+\n+\t// Calculate visible items for virtualization\n+\tconst visibleItems = React.useMemo(() => {\n+\t\tif (!shouldVirtualize) return files\n+\n+\t\tconst startIndex = Math.floor(scrollTop / ITEM_HEIGHT)\n+\t\tconst endIndex = Math.min(startIndex + MAX_VISIBLE_ITEMS, files.length)\n+\t\treturn files.slice(startIndex, endIndex).map((file, index) => ({\n+\t\t\t...file,\n+\t\t\tvirtualIndex: startIndex + index,\n+\t\t}))\n+\t}, [files, scrollTop, shouldVirtualize])\n+\n+\tconst totalHeight = shouldVirtualize ? files.length * ITEM_HEIGHT : \"auto\"\n+\tconst offsetY = shouldVirtualize ? Math.floor(scrollTop / ITEM_HEIGHT) * ITEM_HEIGHT : 0\n+\n+\t// Simple double-click prevention\n+\tconst [isProcessing, setIsProcessing] = React.useState(false)\n+\tconst timeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n+\n+\t// Cleanup timeout on unmount\n+\tReact.useEffect(() => {\n+\t\treturn () => {\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t}\n+\t}, [])\n+\n+\t// FCO initialization logic\n+\tconst checkInit = React.useCallback(\n+\t\t(baseCheckpoint: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tconsole.log(\"[FCO] Initializing with base checkpoint:\", baseCheckpoint)\n+\t\t\t\tsetIsInitialized(true)\n+\t\t\t}\n+\t\t},\n+\t\t[isInitialized],\n+\t)\n+\n+\t// Update changeset - backend handles filtering, no local filtering needed\n+\tconst updateChangeset = React.useCallback((newChangeset: FileChangeset) => {\n+\t\tsetChangeset(newChangeset)\n+\t}, [])\n+\n+\t// Handle checkpoint creation\n+\tconst handleCheckpointCreated = React.useCallback(\n+\t\t(checkpoint: string, previousCheckpoint?: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tcheckInit(previousCheckpoint || checkpoint)\n+\t\t\t}\n+\t\t\t// Note: Backend automatically sends file changes during checkpoint creation\n+\t\t\t// No need to request them here - just wait for the filesChanged message\n+\t\t},\n+\t\t[isInitialized, checkInit],\n+\t)\n+\n+\t// Handle checkpoint restoration with the 4 examples logic\n+\tconst handleCheckpointRestored = React.useCallback((restoredCheckpoint: string) => {\n+\t\tconsole.log(\"[FCO] Handling checkpoint restore to:\", restoredCheckpoint)\n+\n+\t\t// Request file changes after checkpoint restore\n+\t\t// Backend should calculate changes from initial baseline to restored checkpoint\n+\t\tvscode.postMessage({ type: \"filesChangedRequest\" })\n+\t}, [])\n+\n+\t// Action handlers\n+\tconst handleViewDiff = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"viewDiff\", uri })\n+\t}, [])\n+\n+\tconst handleAcceptFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"acceptFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"rejectFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleAcceptAll = React.useCallback(() => {\n+\t\tvscode.postMessage({ type: \"acceptAllFileChanges\" })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectAll = React.useCallback(() => {\n+\t\tconst visibleUris = files.map((file) => file.uri)\n+\t\tvscode.postMessage({ type: \"rejectAllFileChanges\", uris: visibleUris })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [files])\n+\n+\tconst handleWithDebounce = React.useCallback(\n+\t\tasync (operation: () => void) => {\n+\t\t\tif (isProcessing) return\n+\t\t\tsetIsProcessing(true)\n+\t\t\ttry {\n+\t\t\t\toperation()\n+\t\t\t} catch (_error) {\n+\t\t\t\t// Silently handle any errors to prevent crashing\n+\t\t\t\t// Debug logging removed for production\n+\t\t\t}\n+\t\t\t// Brief delay to prevent double-clicks\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t\ttimeoutRef.current = setTimeout(() => setIsProcessing(false), 300)\n+\t\t},\n+\t\t[isProcessing],\n+\t)\n+\n+\t/**\n+\t * Handles scroll events for virtualization\n+\t * Updates scrollTop state to calculate visible items\n+\t */\n+\tconst handleScroll = React.useCallback(\n+\t\t(e: React.UIEvent<HTMLDivElement>) => {\n+\t\t\tif (shouldVirtualize) {\n+\t\t\t\tsetScrollTop(e.currentTarget.scrollTop)\n+\t\t\t}\n+\t\t},\n+\t\t[shouldVirtualize],\n+\t)\n+\n+\t// Listen for filesChanged messages from the backend\n+\tReact.useEffect(() => {\n+\t\tconst handleMessage = (event: MessageEvent) => {\n+\t\t\tconst message = event.data\n+\n+\t\t\t// Guard against null/undefined/malformed messages\n+\t\t\tif (!message || typeof message !== \"object\" || !message.type) {\n+\t\t\t\tconsole.debug(\"[FCO] Ignoring malformed message:\", message)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tswitch (message.type) {\n+\t\t\t\tcase \"filesChanged\":\n+\t\t\t\t\tif (message.filesChanged) {\n+\t\t\t\t\t\tconsole.log(\"[FCO] Received filesChanged message:\", message.filesChanged)",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2219691881",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5626,
        "pr_file": "webview-ui/src/components/file-changes/FilesChangedOverview.tsx",
        "discussion_id": "2219691881",
        "commented_code": "@@ -0,0 +1,516 @@\n+import React from \"react\"\n+import { FileChangeset, FileChange } from \"@roo-code/types\"\n+import { useTranslation } from \"react-i18next\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { vscode } from \"@/utils/vscode\"\n+\n+// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n+interface FilesChangedOverviewProps {}\n+\n+interface _CheckpointEventData {\n+\ttype: \"checkpoint_created\" | \"checkpoint_restored\"\n+\tcheckpoint: string\n+\tpreviousCheckpoint?: string\n+}\n+\n+/**\n+ * FilesChangedOverview is a self-managing component that listens for checkpoint events\n+ * and displays file changes. It manages its own state and communicates with the backend\n+ * through VS Code message passing.\n+ */\n+const FilesChangedOverview: React.FC<FilesChangedOverviewProps> = () => {\n+\tconst { t } = useTranslation()\n+\tconst { filesChangedEnabled } = useExtensionState()\n+\n+\t// Self-managed state\n+\tconst [changeset, setChangeset] = React.useState<FileChangeset | null>(null)\n+\tconst [isInitialized, setIsInitialized] = React.useState(false)\n+\n+\tconst files = React.useMemo(() => changeset?.files || [], [changeset?.files])\n+\tconst [isCollapsed, setIsCollapsed] = React.useState(true)\n+\n+\t// Performance optimization: Use virtualization for large file lists\n+\tconst VIRTUALIZATION_THRESHOLD = 50\n+\tconst ITEM_HEIGHT = 32 // Approximate height of each file item\n+\tconst MAX_VISIBLE_ITEMS = 10\n+\tconst [scrollTop, setScrollTop] = React.useState(0)\n+\n+\tconst shouldVirtualize = files.length > VIRTUALIZATION_THRESHOLD\n+\n+\t// Calculate visible items for virtualization\n+\tconst visibleItems = React.useMemo(() => {\n+\t\tif (!shouldVirtualize) return files\n+\n+\t\tconst startIndex = Math.floor(scrollTop / ITEM_HEIGHT)\n+\t\tconst endIndex = Math.min(startIndex + MAX_VISIBLE_ITEMS, files.length)\n+\t\treturn files.slice(startIndex, endIndex).map((file, index) => ({\n+\t\t\t...file,\n+\t\t\tvirtualIndex: startIndex + index,\n+\t\t}))\n+\t}, [files, scrollTop, shouldVirtualize])\n+\n+\tconst totalHeight = shouldVirtualize ? files.length * ITEM_HEIGHT : \"auto\"\n+\tconst offsetY = shouldVirtualize ? Math.floor(scrollTop / ITEM_HEIGHT) * ITEM_HEIGHT : 0\n+\n+\t// Simple double-click prevention\n+\tconst [isProcessing, setIsProcessing] = React.useState(false)\n+\tconst timeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n+\n+\t// Cleanup timeout on unmount\n+\tReact.useEffect(() => {\n+\t\treturn () => {\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t}\n+\t}, [])\n+\n+\t// FCO initialization logic\n+\tconst checkInit = React.useCallback(\n+\t\t(baseCheckpoint: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tconsole.log(\"[FCO] Initializing with base checkpoint:\", baseCheckpoint)\n+\t\t\t\tsetIsInitialized(true)\n+\t\t\t}\n+\t\t},\n+\t\t[isInitialized],\n+\t)\n+\n+\t// Update changeset - backend handles filtering, no local filtering needed\n+\tconst updateChangeset = React.useCallback((newChangeset: FileChangeset) => {\n+\t\tsetChangeset(newChangeset)\n+\t}, [])\n+\n+\t// Handle checkpoint creation\n+\tconst handleCheckpointCreated = React.useCallback(\n+\t\t(checkpoint: string, previousCheckpoint?: string) => {\n+\t\t\tif (!isInitialized) {\n+\t\t\t\tcheckInit(previousCheckpoint || checkpoint)\n+\t\t\t}\n+\t\t\t// Note: Backend automatically sends file changes during checkpoint creation\n+\t\t\t// No need to request them here - just wait for the filesChanged message\n+\t\t},\n+\t\t[isInitialized, checkInit],\n+\t)\n+\n+\t// Handle checkpoint restoration with the 4 examples logic\n+\tconst handleCheckpointRestored = React.useCallback((restoredCheckpoint: string) => {\n+\t\tconsole.log(\"[FCO] Handling checkpoint restore to:\", restoredCheckpoint)\n+\n+\t\t// Request file changes after checkpoint restore\n+\t\t// Backend should calculate changes from initial baseline to restored checkpoint\n+\t\tvscode.postMessage({ type: \"filesChangedRequest\" })\n+\t}, [])\n+\n+\t// Action handlers\n+\tconst handleViewDiff = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"viewDiff\", uri })\n+\t}, [])\n+\n+\tconst handleAcceptFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"acceptFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectFile = React.useCallback((uri: string) => {\n+\t\tvscode.postMessage({ type: \"rejectFileChange\", uri })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleAcceptAll = React.useCallback(() => {\n+\t\tvscode.postMessage({ type: \"acceptAllFileChanges\" })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [])\n+\n+\tconst handleRejectAll = React.useCallback(() => {\n+\t\tconst visibleUris = files.map((file) => file.uri)\n+\t\tvscode.postMessage({ type: \"rejectAllFileChanges\", uris: visibleUris })\n+\t\t// Backend will send updated filesChanged message with filtered results\n+\t}, [files])\n+\n+\tconst handleWithDebounce = React.useCallback(\n+\t\tasync (operation: () => void) => {\n+\t\t\tif (isProcessing) return\n+\t\t\tsetIsProcessing(true)\n+\t\t\ttry {\n+\t\t\t\toperation()\n+\t\t\t} catch (_error) {\n+\t\t\t\t// Silently handle any errors to prevent crashing\n+\t\t\t\t// Debug logging removed for production\n+\t\t\t}\n+\t\t\t// Brief delay to prevent double-clicks\n+\t\t\tif (timeoutRef.current) {\n+\t\t\t\tclearTimeout(timeoutRef.current)\n+\t\t\t}\n+\t\t\ttimeoutRef.current = setTimeout(() => setIsProcessing(false), 300)\n+\t\t},\n+\t\t[isProcessing],\n+\t)\n+\n+\t/**\n+\t * Handles scroll events for virtualization\n+\t * Updates scrollTop state to calculate visible items\n+\t */\n+\tconst handleScroll = React.useCallback(\n+\t\t(e: React.UIEvent<HTMLDivElement>) => {\n+\t\t\tif (shouldVirtualize) {\n+\t\t\t\tsetScrollTop(e.currentTarget.scrollTop)\n+\t\t\t}\n+\t\t},\n+\t\t[shouldVirtualize],\n+\t)\n+\n+\t// Listen for filesChanged messages from the backend\n+\tReact.useEffect(() => {\n+\t\tconst handleMessage = (event: MessageEvent) => {\n+\t\t\tconst message = event.data\n+\n+\t\t\t// Guard against null/undefined/malformed messages\n+\t\t\tif (!message || typeof message !== \"object\" || !message.type) {\n+\t\t\t\tconsole.debug(\"[FCO] Ignoring malformed message:\", message)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tswitch (message.type) {\n+\t\t\t\tcase \"filesChanged\":\n+\t\t\t\t\tif (message.filesChanged) {\n+\t\t\t\t\t\tconsole.log(\"[FCO] Received filesChanged message:\", message.filesChanged)",
        "comment_created_at": "2025-07-21T16:31:03+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "I noticed some `console.log` and `console.debug` statements here. Are these intended for debugging and should they be removed before merging?",
        "pr_file_module": null
      }
    ]
  }
]