[
  {
    "discussion_id": "2220006602",
    "pr_number": 6031,
    "pr_file": "src/services/telemetry/TelemetryStatusMonitor.ts",
    "created_at": "2025-07-21T18:57:47+00:00",
    "commented_code": "+import * as vscode from \"vscode\"\n+import { CloudService } from \"@roo-code/cloud\"\n+\n+/**\n+ * TelemetryStatusMonitor provides visual feedback about telemetry connection status\n+ * and queue buildup through VSCode notifications and status bar items.\n+ */\n+export class TelemetryStatusMonitor {\n+\tprivate statusBarItem: vscode.StatusBarItem\n+\tprivate lastNotificationTime = 0\n+\tprivate notificationInterval = 300000 // 5 minutes\n+\tprivate isConnected = true\n+\tprivate queueSize = 0\n+\tprivate isAboveThreshold = false\n+\n+\tconstructor(private context: vscode.ExtensionContext) {\n+\t\t// Create status bar item\n+\t\tthis.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100)\n+\t\tthis.statusBarItem.command = \"roo-code.showTelemetryStatus\"\n+\t\tthis.context.subscriptions.push(this.statusBarItem)\n+\n+\t\t// Register command\n+\t\tthis.context.subscriptions.push(\n+\t\t\tvscode.commands.registerCommand(\"roo-code.showTelemetryStatus\", () => {\n+\t\t\t\tthis.showTelemetryStatusQuickPick()\n+\t\t\t}),\n+\t\t)\n+\n+\t\t// Initialize status\n+\t\tthis.updateStatusBar()\n+\t}\n+\n+\t/**\n+\t * Initializes monitoring with CloudService callbacks\n+\t */\n+\tpublic initialize(): void {\n+\t\tif (!CloudService.hasInstance()) {\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Set up callbacks\n+\t\tCloudService.instance.setTelemetryConnectionStatusCallback((isConnected) => {\n+\t\t\tthis.onConnectionStatusChange(isConnected)\n+\t\t})\n+\n+\t\tCloudService.instance.setTelemetryQueueSizeCallback((size, isAboveThreshold) => {\n+\t\t\tthis.onQueueSizeChange(size, isAboveThreshold)\n+\t\t})\n+\n+\t\t// Get initial status\n+\t\tthis.isConnected = CloudService.instance.getTelemetryConnectionStatus()\n+\t\tthis.updateStatusBar()\n+\t}\n+\n+\t/**\n+\t * Handles connection status changes\n+\t */\n+\tprivate onConnectionStatusChange(isConnected: boolean): void {\n+\t\tconst wasConnected = this.isConnected\n+\t\tthis.isConnected = isConnected\n+\n+\t\t// Update status bar\n+\t\tthis.updateStatusBar()\n+\n+\t\t// Show notification on status change\n+\t\tif (wasConnected && !isConnected) {\n+\t\t\tthis.showNotification(\n+\t\t\t\t\"Telemetry connection lost. Events will be queued and retried automatically.\",",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2220006602",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 6031,
        "pr_file": "src/services/telemetry/TelemetryStatusMonitor.ts",
        "discussion_id": "2220006602",
        "commented_code": "@@ -0,0 +1,252 @@\n+import * as vscode from \"vscode\"\n+import { CloudService } from \"@roo-code/cloud\"\n+\n+/**\n+ * TelemetryStatusMonitor provides visual feedback about telemetry connection status\n+ * and queue buildup through VSCode notifications and status bar items.\n+ */\n+export class TelemetryStatusMonitor {\n+\tprivate statusBarItem: vscode.StatusBarItem\n+\tprivate lastNotificationTime = 0\n+\tprivate notificationInterval = 300000 // 5 minutes\n+\tprivate isConnected = true\n+\tprivate queueSize = 0\n+\tprivate isAboveThreshold = false\n+\n+\tconstructor(private context: vscode.ExtensionContext) {\n+\t\t// Create status bar item\n+\t\tthis.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100)\n+\t\tthis.statusBarItem.command = \"roo-code.showTelemetryStatus\"\n+\t\tthis.context.subscriptions.push(this.statusBarItem)\n+\n+\t\t// Register command\n+\t\tthis.context.subscriptions.push(\n+\t\t\tvscode.commands.registerCommand(\"roo-code.showTelemetryStatus\", () => {\n+\t\t\t\tthis.showTelemetryStatusQuickPick()\n+\t\t\t}),\n+\t\t)\n+\n+\t\t// Initialize status\n+\t\tthis.updateStatusBar()\n+\t}\n+\n+\t/**\n+\t * Initializes monitoring with CloudService callbacks\n+\t */\n+\tpublic initialize(): void {\n+\t\tif (!CloudService.hasInstance()) {\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Set up callbacks\n+\t\tCloudService.instance.setTelemetryConnectionStatusCallback((isConnected) => {\n+\t\t\tthis.onConnectionStatusChange(isConnected)\n+\t\t})\n+\n+\t\tCloudService.instance.setTelemetryQueueSizeCallback((size, isAboveThreshold) => {\n+\t\t\tthis.onQueueSizeChange(size, isAboveThreshold)\n+\t\t})\n+\n+\t\t// Get initial status\n+\t\tthis.isConnected = CloudService.instance.getTelemetryConnectionStatus()\n+\t\tthis.updateStatusBar()\n+\t}\n+\n+\t/**\n+\t * Handles connection status changes\n+\t */\n+\tprivate onConnectionStatusChange(isConnected: boolean): void {\n+\t\tconst wasConnected = this.isConnected\n+\t\tthis.isConnected = isConnected\n+\n+\t\t// Update status bar\n+\t\tthis.updateStatusBar()\n+\n+\t\t// Show notification on status change\n+\t\tif (wasConnected && !isConnected) {\n+\t\t\tthis.showNotification(\n+\t\t\t\t\"Telemetry connection lost. Events will be queued and retried automatically.\",",
        "comment_created_at": "2025-07-21T18:57:47+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "User-facing notification strings are hardcoded. Per internationalization guidelines, use a translation utility (e.g. t('...')) instead of inline English messages.\n```suggestion\n\t\t\t\tt(\"Telemetry connection lost. Events will be queued and retried automatically.\"),\n```\n\n<sup>This comment was generated because it violated a code review rule: [irule_C0ez7Rji6ANcGkkX](https://app.ellipsis.dev/RooCodeInc/code-review/rules?id=irule_C0ez7Rji6ANcGkkX).</sup>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177948788",
    "pr_number": 5172,
    "pr_file": "src/core/tools/readFileTool.ts",
    "created_at": "2025-07-01T15:50:38+00:00",
    "commented_code": "const fileExtension = path.extname(relPath).toLowerCase()\n \t\t\t\t\tconst supportedBinaryFormats = getSupportedBinaryFormats()\n \n-\t\t\t\t\tif (!supportedBinaryFormats.includes(fileExtension)) {\n+\t\t\t\t\t// Check if it's a supported image format\n+\t\t\t\t\tif (SUPPORTED_IMAGE_FORMATS.includes(fileExtension as any)) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst imageStats = await fs.stat(fullPath)\n+\n+\t\t\t\t\t\t\t// Check if image file exceeds size limit\n+\t\t\t\t\t\t\tif (imageStats.size > MAX_IMAGE_FILE_SIZE_BYTES) {\n+\t\t\t\t\t\t\t\tconst imageSizeInMB = (imageStats.size / (1024 * 1024)).toFixed(1)\n+\t\t\t\t\t\t\t\tconst notice = `Image file is too large (${imageSizeInMB} MB). The maximum allowed size is 5 MB.`",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2177948788",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5172,
        "pr_file": "src/core/tools/readFileTool.ts",
        "discussion_id": "2177948788",
        "commented_code": "@@ -440,14 +491,83 @@ export async function readFileTool(\n \t\t\t\t\tconst fileExtension = path.extname(relPath).toLowerCase()\n \t\t\t\t\tconst supportedBinaryFormats = getSupportedBinaryFormats()\n \n-\t\t\t\t\tif (!supportedBinaryFormats.includes(fileExtension)) {\n+\t\t\t\t\t// Check if it's a supported image format\n+\t\t\t\t\tif (SUPPORTED_IMAGE_FORMATS.includes(fileExtension as any)) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst imageStats = await fs.stat(fullPath)\n+\n+\t\t\t\t\t\t\t// Check if image file exceeds size limit\n+\t\t\t\t\t\t\tif (imageStats.size > MAX_IMAGE_FILE_SIZE_BYTES) {\n+\t\t\t\t\t\t\t\tconst imageSizeInMB = (imageStats.size / (1024 * 1024)).toFixed(1)\n+\t\t\t\t\t\t\t\tconst notice = `Image file is too large (${imageSizeInMB} MB). The maximum allowed size is 5 MB.`",
        "comment_created_at": "2025-07-01T15:50:38+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "User\u2010facing text (e.g. the notice about oversized images) is hardcoded. For localization, please use the i18n translation function (e.g. t('tools:readFile.imageTooLarge', { size: imageSizeInMB, max: 5 })) instead of inline English strings.\n```suggestion\n\t\t\t\t\t\t\t\tconst notice = t('tools:readFile.imageTooLarge', { size: imageSizeInMB, max: 5 })\n```\n\n<sup>This comment was generated because it violated a code review rule: [irule_C0ez7Rji6ANcGkkX](https://app.ellipsis.dev/RooCodeInc/code-review/rules?id=irule_C0ez7Rji6ANcGkkX).</sup>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2186123185",
    "pr_number": 5172,
    "pr_file": "src/core/tools/readFileTool.ts",
    "created_at": "2025-07-04T21:24:40+00:00",
    "commented_code": "const fileExtension = path.extname(relPath).toLowerCase()\n \t\t\t\t\tconst supportedBinaryFormats = getSupportedBinaryFormats()\n \n-\t\t\t\t\tif (!supportedBinaryFormats.includes(fileExtension)) {\n+\t\t\t\t\t// Check if it's a supported image format\n+\t\t\t\t\tif (SUPPORTED_IMAGE_FORMATS.includes(fileExtension as (typeof SUPPORTED_IMAGE_FORMATS)[number])) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst imageStats = await fs.stat(fullPath)\n+\n+\t\t\t\t\t\t\t// Check if image file exceeds size limit\n+\t\t\t\t\t\t\tif (imageStats.size > maxImageFileSize * 1024 * 1024) {\n+\t\t\t\t\t\t\t\tconst imageSizeInMB = (imageStats.size / (1024 * 1024)).toFixed(1)\n+\t\t\t\t\t\t\t\tconst notice = t(\"tools:readFile.imageTooLarge\", { size: imageSizeInMB, max: maxImageFileSize })\n+\n+\t\t\t\t\t\t\t\t// Track file read\n+\t\t\t\t\t\t\t\tawait cline.fileContextTracker.trackFileContext(relPath, \"read_tool\" as RecordSource)\n+\n+\t\t\t\t\t\t\t\tupdateFileResult(relPath, {\n+\t\t\t\t\t\t\t\t\txmlContent: `<file><path>${relPath}</path>\n<notice>${notice}</notice>\n</file>`,\n+\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tconst { dataUrl: imageDataUrl, buffer } = await readImageAsDataUrlWithBuffer(fullPath)\n+\t\t\t\t\t\t\tconst imageSizeInKB = Math.round(imageStats.size / 1024)\n+\n+\t\t\t\t\t\t\t// For images, get dimensions if possible\n+\t\t\t\t\t\t\tlet dimensionsInfo = \"\"\n+\t\t\t\t\t\t\tif (fileExtension === \".png\") {\n+\t\t\t\t\t\t\t\t// Simple PNG dimension extraction (first 24 bytes contain width/height)\n+\t\t\t\t\t\t\t\tif (buffer.length >= 24) {\n+\t\t\t\t\t\t\t\t\tconst width = buffer.readUInt32BE(16)\n+\t\t\t\t\t\t\t\t\tconst height = buffer.readUInt32BE(20)\n+\t\t\t\t\t\t\t\t\tif (width && height) {\n+\t\t\t\t\t\t\t\t\t\tdimensionsInfo = `${width}x${height} pixels`\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t// Track file read\n+\t\t\t\t\t\t\tawait cline.fileContextTracker.trackFileContext(relPath, \"read_tool\" as RecordSource)\n+\n+\t\t\t\t\t\t\t// Store image data URL separately - NOT in XML\n+\t\t\t\t\t\t\tconst noticeText = dimensionsInfo\n+\t\t\t\t\t\t\t\t? `Image file (${dimensionsInfo}, ${imageSizeInKB} KB)`",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2186123185",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5172,
        "pr_file": "src/core/tools/readFileTool.ts",
        "discussion_id": "2186123185",
        "commented_code": "@@ -440,14 +493,82 @@ export async function readFileTool(\n \t\t\t\t\tconst fileExtension = path.extname(relPath).toLowerCase()\n \t\t\t\t\tconst supportedBinaryFormats = getSupportedBinaryFormats()\n \n-\t\t\t\t\tif (!supportedBinaryFormats.includes(fileExtension)) {\n+\t\t\t\t\t// Check if it's a supported image format\n+\t\t\t\t\tif (SUPPORTED_IMAGE_FORMATS.includes(fileExtension as (typeof SUPPORTED_IMAGE_FORMATS)[number])) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tconst imageStats = await fs.stat(fullPath)\n+\n+\t\t\t\t\t\t\t// Check if image file exceeds size limit\n+\t\t\t\t\t\t\tif (imageStats.size > maxImageFileSize * 1024 * 1024) {\n+\t\t\t\t\t\t\t\tconst imageSizeInMB = (imageStats.size / (1024 * 1024)).toFixed(1)\n+\t\t\t\t\t\t\t\tconst notice = t(\"tools:readFile.imageTooLarge\", { size: imageSizeInMB, max: maxImageFileSize })\n+\n+\t\t\t\t\t\t\t\t// Track file read\n+\t\t\t\t\t\t\t\tawait cline.fileContextTracker.trackFileContext(relPath, \"read_tool\" as RecordSource)\n+\n+\t\t\t\t\t\t\t\tupdateFileResult(relPath, {\n+\t\t\t\t\t\t\t\t\txmlContent: `<file><path>${relPath}</path>\\n<notice>${notice}</notice>\\n</file>`,\n+\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tconst { dataUrl: imageDataUrl, buffer } = await readImageAsDataUrlWithBuffer(fullPath)\n+\t\t\t\t\t\t\tconst imageSizeInKB = Math.round(imageStats.size / 1024)\n+\n+\t\t\t\t\t\t\t// For images, get dimensions if possible\n+\t\t\t\t\t\t\tlet dimensionsInfo = \"\"\n+\t\t\t\t\t\t\tif (fileExtension === \".png\") {\n+\t\t\t\t\t\t\t\t// Simple PNG dimension extraction (first 24 bytes contain width/height)\n+\t\t\t\t\t\t\t\tif (buffer.length >= 24) {\n+\t\t\t\t\t\t\t\t\tconst width = buffer.readUInt32BE(16)\n+\t\t\t\t\t\t\t\t\tconst height = buffer.readUInt32BE(20)\n+\t\t\t\t\t\t\t\t\tif (width && height) {\n+\t\t\t\t\t\t\t\t\t\tdimensionsInfo = `${width}x${height} pixels`\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t// Track file read\n+\t\t\t\t\t\t\tawait cline.fileContextTracker.trackFileContext(relPath, \"read_tool\" as RecordSource)\n+\n+\t\t\t\t\t\t\t// Store image data URL separately - NOT in XML\n+\t\t\t\t\t\t\tconst noticeText = dimensionsInfo\n+\t\t\t\t\t\t\t\t? `Image file (${dimensionsInfo}, ${imageSizeInKB} KB)`",
        "comment_created_at": "2025-07-04T21:24:40+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "I see that the oversized image error uses i18n properly, but this regular image notice is hardcoded. For consistency, could we move these strings to the translation files as well?\n\nFor example:\n```typescript\nconst noticeText = dimensionsInfo\n  ? t(\"tools:readFile.imageWithDimensions\", { dimensions: dimensionsInfo, size: imageSizeInKB })\n  : t(\"tools:readFile.imageWithSize\", { size: imageSizeInKB });\n```\n\nThis would ensure all user-facing strings are translatable and maintain consistency across the codebase.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216753283",
    "pr_number": 5920,
    "pr_file": "src/core/checkpoints/index.ts",
    "created_at": "2025-07-18T19:07:05+00:00",
    "commented_code": "cline.checkpointServiceInitializing = true\n \n-\t\tservice.on(\"initialize\", () => {\n-\t\t\tlog(\"[Task#getCheckpointService] service initialized\")\n-\n-\t\t\ttry {\n-\t\t\t\tconst isCheckpointNeeded =\n-\t\t\t\t\ttypeof cline.clineMessages.find(({ say }) => say === \"checkpoint_saved\") === \"undefined\"\n-\n-\t\t\t\tcline.checkpointService = service\n-\t\t\t\tcline.checkpointServiceInitializing = false\n-\n-\t\t\t\tif (isCheckpointNeeded) {\n-\t\t\t\t\tlog(\"[Task#getCheckpointService] no checkpoints found, saving initial checkpoint\")\n-\t\t\t\t\tcheckpointSave(cline)\n+\t\t// Check if Git is installed before initializing the service\n+\t\tcheckGitInstalled()\n+\t\t\t.then((gitInstalled) => {\n+\t\t\t\tif (!gitInstalled) {\n+\t\t\t\t\tlog(\"[Task#getCheckpointService] Git is not installed, disabling checkpoints\")\n+\t\t\t\t\tcline.enableCheckpoints = false\n+\t\t\t\t\tcline.checkpointServiceInitializing = false\n+\n+\t\t\t\t\t// Show user-friendly notification\n+\t\t\t\t\tvscode.window\n+\t\t\t\t\t\t.showWarningMessage(\n+\t\t\t\t\t\t\t\"Git is required for the checkpoints feature. Please install Git to enable checkpoints.\",",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2216753283",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5920,
        "pr_file": "src/core/checkpoints/index.ts",
        "discussion_id": "2216753283",
        "commented_code": "@@ -70,25 +71,56 @@ export function getCheckpointService(cline: Task) {\n \n \t\tcline.checkpointServiceInitializing = true\n \n-\t\tservice.on(\"initialize\", () => {\n-\t\t\tlog(\"[Task#getCheckpointService] service initialized\")\n-\n-\t\t\ttry {\n-\t\t\t\tconst isCheckpointNeeded =\n-\t\t\t\t\ttypeof cline.clineMessages.find(({ say }) => say === \"checkpoint_saved\") === \"undefined\"\n-\n-\t\t\t\tcline.checkpointService = service\n-\t\t\t\tcline.checkpointServiceInitializing = false\n-\n-\t\t\t\tif (isCheckpointNeeded) {\n-\t\t\t\t\tlog(\"[Task#getCheckpointService] no checkpoints found, saving initial checkpoint\")\n-\t\t\t\t\tcheckpointSave(cline)\n+\t\t// Check if Git is installed before initializing the service\n+\t\tcheckGitInstalled()\n+\t\t\t.then((gitInstalled) => {\n+\t\t\t\tif (!gitInstalled) {\n+\t\t\t\t\tlog(\"[Task#getCheckpointService] Git is not installed, disabling checkpoints\")\n+\t\t\t\t\tcline.enableCheckpoints = false\n+\t\t\t\t\tcline.checkpointServiceInitializing = false\n+\n+\t\t\t\t\t// Show user-friendly notification\n+\t\t\t\t\tvscode.window\n+\t\t\t\t\t\t.showWarningMessage(\n+\t\t\t\t\t\t\t\"Git is required for the checkpoints feature. Please install Git to enable checkpoints.\",",
        "comment_created_at": "2025-07-18T19:07:05+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "User-facing strings (the warning message and button label) are hardcoded in English. Please use the i18n/translation mechanism (e.g. t('...')) to ensure consistency across locales.\n```suggestion\n\t\t\t\t\t\t\tt('Git is required for the checkpoints feature. Please install Git to enable checkpoints.'),\n```\n\n<sup>This comment was generated because it violated a code review rule: [irule_C0ez7Rji6ANcGkkX](https://app.ellipsis.dev/RooCodeInc/code-review/rules?id=irule_C0ez7Rji6ANcGkkX).</sup>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214050398",
    "pr_number": 5798,
    "pr_file": "webview-ui/src/utils/commandPatterns.ts",
    "created_at": "2025-07-17T18:47:02+00:00",
    "commented_code": "+import { parse } from \"shell-quote\"\n+\n+export interface CommandPattern {\n+\tpattern: string\n+\tdescription?: string\n+}\n+\n+export interface SecurityWarning {\n+\ttype: \"subshell\" | \"injection\"\n+\tmessage: string\n+}\n+\n+export function extractCommandPatterns(command: string): string[] {\n+\tif (!command?.trim()) return []\n+\n+\tconst patterns = new Set<string>()\n+\n+\ttry {\n+\t\t// First, remove subshell expressions to avoid extracting their contents\n+\t\tconst cleanedCommand = command\n+\t\t\t.replace(/\\$\\([^)]*\\)/g, \"\") // Remove $() subshells\n+\t\t\t.replace(/`[^`]*`/g, \"\") // Remove backtick subshells\n+\n+\t\tconst parsed = parse(cleanedCommand)\n+\n+\t\tconst commandSeparators = new Set([\"|\", \"&&\", \"||\", \";\"])\n+\t\tlet current: any[] = []\n+\n+\t\tfor (const token of parsed) {\n+\t\t\tif (typeof token === \"object\" && \"op\" in token && token.op && commandSeparators.has(token.op)) {\n+\t\t\t\tif (current.length) processCommand(current, patterns)\n+\t\t\t\tcurrent = []\n+\t\t\t} else {\n+\t\t\t\tcurrent.push(token)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (current.length) processCommand(current, patterns)\n+\t} catch (_error) {\n+\t\t// If parsing fails, try to extract at least the main command\n+\t\tconst mainCommand = command.trim().split(/\\s+/)[0]\n+\t\tif (mainCommand) patterns.add(mainCommand)\n+\t}\n+\n+\treturn Array.from(patterns).sort()\n+}\n+\n+function processCommand(cmd: any[], patterns: Set<string>) {\n+\tif (!cmd.length || typeof cmd[0] !== \"string\") return\n+\n+\tconst mainCmd = cmd[0]\n+\tpatterns.add(mainCmd)\n+\n+\t// Patterns that indicate we should stop looking for subcommands",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2214050398",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5798,
        "pr_file": "webview-ui/src/utils/commandPatterns.ts",
        "discussion_id": "2214050398",
        "commented_code": "@@ -0,0 +1,160 @@\n+import { parse } from \"shell-quote\"\n+\n+export interface CommandPattern {\n+\tpattern: string\n+\tdescription?: string\n+}\n+\n+export interface SecurityWarning {\n+\ttype: \"subshell\" | \"injection\"\n+\tmessage: string\n+}\n+\n+export function extractCommandPatterns(command: string): string[] {\n+\tif (!command?.trim()) return []\n+\n+\tconst patterns = new Set<string>()\n+\n+\ttry {\n+\t\t// First, remove subshell expressions to avoid extracting their contents\n+\t\tconst cleanedCommand = command\n+\t\t\t.replace(/\\$\\([^)]*\\)/g, \"\") // Remove $() subshells\n+\t\t\t.replace(/`[^`]*`/g, \"\") // Remove backtick subshells\n+\n+\t\tconst parsed = parse(cleanedCommand)\n+\n+\t\tconst commandSeparators = new Set([\"|\", \"&&\", \"||\", \";\"])\n+\t\tlet current: any[] = []\n+\n+\t\tfor (const token of parsed) {\n+\t\t\tif (typeof token === \"object\" && \"op\" in token && token.op && commandSeparators.has(token.op)) {\n+\t\t\t\tif (current.length) processCommand(current, patterns)\n+\t\t\t\tcurrent = []\n+\t\t\t} else {\n+\t\t\t\tcurrent.push(token)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (current.length) processCommand(current, patterns)\n+\t} catch (_error) {\n+\t\t// If parsing fails, try to extract at least the main command\n+\t\tconst mainCommand = command.trim().split(/\\s+/)[0]\n+\t\tif (mainCommand) patterns.add(mainCommand)\n+\t}\n+\n+\treturn Array.from(patterns).sort()\n+}\n+\n+function processCommand(cmd: any[], patterns: Set<string>) {\n+\tif (!cmd.length || typeof cmd[0] !== \"string\") return\n+\n+\tconst mainCmd = cmd[0]\n+\tpatterns.add(mainCmd)\n+\n+\t// Patterns that indicate we should stop looking for subcommands",
        "comment_created_at": "2025-07-17T18:47:02+00:00",
        "comment_author": "Copilot",
        "comment_body": "The regex patterns need better documentation. Consider adding inline comments explaining what each pattern matches (e.g., '/^-/' matches flags, '/[\\/.~ ]/' matches paths and special characters).\n```suggestion\n\t// Patterns that indicate we should stop looking for subcommands\n\t// /^-/ matches flags (e.g., arguments starting with a dash like \"-flag\").\n\t// /[\\\\/.~ ]/ matches paths or special characters (e.g., \"/\", \".\", \"~\", or spaces).\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218393774",
    "pr_number": 5998,
    "pr_file": "src/core/tools/executeCommandTool.ts",
    "created_at": "2025-07-21T07:22:24+00:00",
    "commented_code": "return\n \t\t\t}\n \n+\t\t\t// Validate command against allowed/denied lists\n+\t\t\tconst clineProvider = await cline.providerRef.deref()\n+\t\t\tif (clineProvider) {\n+\t\t\t\tconst state = await clineProvider.getState()\n+\t\t\t\tconst { allowedCommands, deniedCommands, alwaysAllowExecute } = state\n+\n+\t\t\t\t// Skip validation if alwaysAllowExecute is true\n+\t\t\t\tif (!alwaysAllowExecute) {\n+\t\t\t\t\t// Extract the base command (first word) for validation\n+\t\t\t\t\tconst baseCommand = command.trim().split(/\\s+/)[0]\n+\n+\t\t\t\t\t// Check denied commands first (takes precedence)\n+\t\t\t\t\tif (deniedCommands && deniedCommands.length > 0) {\n+\t\t\t\t\t\tconst isDenied = deniedCommands.some((deniedCmd) => {\n+\t\t\t\t\t\t\tconst trimmedDenied = deniedCmd.trim()\n+\t\t\t\t\t\t\t// Skip empty strings\n+\t\t\t\t\t\t\tif (!trimmedDenied) return false\n+\t\t\t\t\t\t\tconst deniedBase = trimmedDenied.split(/\\s+/)[0]\n+\t\t\t\t\t\t\treturn baseCommand === deniedBase || command!.startsWith(trimmedDenied)\n+\t\t\t\t\t\t})\n+\n+\t\t\t\t\t\tif (isDenied) {\n+\t\t\t\t\t\t\tawait cline.say(\n+\t\t\t\t\t\t\t\t\"error\",\n+\t\t\t\t\t\t\t\t`Command '${baseCommand}' is in the denied commands list and cannot be executed.`,",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2218393774",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5998,
        "pr_file": "src/core/tools/executeCommandTool.ts",
        "discussion_id": "2218393774",
        "commented_code": "@@ -51,6 +51,68 @@ export async function executeCommandTool(\n \t\t\t\treturn\n \t\t\t}\n \n+\t\t\t// Validate command against allowed/denied lists\n+\t\t\tconst clineProvider = await cline.providerRef.deref()\n+\t\t\tif (clineProvider) {\n+\t\t\t\tconst state = await clineProvider.getState()\n+\t\t\t\tconst { allowedCommands, deniedCommands, alwaysAllowExecute } = state\n+\n+\t\t\t\t// Skip validation if alwaysAllowExecute is true\n+\t\t\t\tif (!alwaysAllowExecute) {\n+\t\t\t\t\t// Extract the base command (first word) for validation\n+\t\t\t\t\tconst baseCommand = command.trim().split(/\\s+/)[0]\n+\n+\t\t\t\t\t// Check denied commands first (takes precedence)\n+\t\t\t\t\tif (deniedCommands && deniedCommands.length > 0) {\n+\t\t\t\t\t\tconst isDenied = deniedCommands.some((deniedCmd) => {\n+\t\t\t\t\t\t\tconst trimmedDenied = deniedCmd.trim()\n+\t\t\t\t\t\t\t// Skip empty strings\n+\t\t\t\t\t\t\tif (!trimmedDenied) return false\n+\t\t\t\t\t\t\tconst deniedBase = trimmedDenied.split(/\\s+/)[0]\n+\t\t\t\t\t\t\treturn baseCommand === deniedBase || command!.startsWith(trimmedDenied)\n+\t\t\t\t\t\t})\n+\n+\t\t\t\t\t\tif (isDenied) {\n+\t\t\t\t\t\t\tawait cline.say(\n+\t\t\t\t\t\t\t\t\"error\",\n+\t\t\t\t\t\t\t\t`Command '${baseCommand}' is in the denied commands list and cannot be executed.`,",
        "comment_created_at": "2025-07-21T07:22:24+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider using the internationalization function (t) for error messages instead of hardcoding them (e.g. for denied commands). This ensures UI consistency with other translatable strings.\n```suggestion\n\t\t\t\t\t\t\t\tt('common:errors:command_denied', { command: baseCommand }),\n```\n\n<sup>This comment was generated because it violated a code review rule: [irule_C0ez7Rji6ANcGkkX](https://app.ellipsis.dev/RooCodeInc/code-review/rules?id=irule_C0ez7Rji6ANcGkkX).</sup>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205598677",
    "pr_number": 5703,
    "pr_file": "src/utils/desktopNotifications.ts",
    "created_at": "2025-07-14T18:54:21+00:00",
    "commented_code": "+import * as notifier from \"node-notifier\"\n+import * as path from \"path\"\n+\n+// Type definitions for node-notifier callback\n+type NotifierCallback = (err: Error | null, response: string, metadata?: any) => void\n+\n+export interface DesktopNotificationOptions {\n+\ttitle: string\n+\tmessage: string\n+\ticon?: string\n+\tsound?: boolean\n+\twait?: boolean\n+\ttimeout?: number\n+\tactions?: string[]\n+\tcloseLabel?: string\n+\tdropdownLabel?: string\n+\treply?: boolean\n+}\n+\n+export type NotificationType = \"approval\" | \"completion\" | \"error\" | \"info\"\n+\n+let isDesktopNotificationsEnabled = false\n+\n+export const setDesktopNotificationsEnabled = (enabled: boolean) => {\n+\tisDesktopNotificationsEnabled = enabled\n+}\n+\n+export const getDesktopNotificationsEnabled = (): boolean => {\n+\treturn isDesktopNotificationsEnabled\n+}\n+\n+/**\n+ * Shows a desktop notification using the native OS notification system\n+ */\n+export const showDesktopNotification = async (\n+\ttype: NotificationType,\n+\toptions: DesktopNotificationOptions,\n+): Promise<void> => {\n+\tif (!isDesktopNotificationsEnabled) {\n+\t\treturn\n+\t}\n+\n+\ttry {\n+\t\t// Get the extension icon path\n+\t\tconst iconPath = getIconPath()\n+\n+\t\tconst notificationOptions: notifier.Notification = {\n+\t\t\ttitle: options.title,\n+\t\t\tmessage: options.message,\n+\t\t\ticon: options.icon || iconPath,\n+\t\t\twait: options.wait || false,\n+\t\t}\n+\n+\t\t// Platform-specific customizations\n+\t\tif (process.platform === \"darwin\") {\n+\t\t\t// macOS specific options\n+\t\t\t;(notificationOptions as any).subtitle = getSubtitleForType(type)\n+\t\t} else if (process.platform === \"win32\") {\n+\t\t\t// Windows specific options\n+\t\t\t;(notificationOptions as any).appID = \"RooCode\"\n+\t\t}\n+\n+\t\tawait new Promise<void>((resolve, reject) => {\n+\t\t\tnotifier.notify(notificationOptions, (err: Error | null, response: string, metadata?: any) => {\n+\t\t\t\tif (err) {\n+\t\t\t\t\treject(err)\n+\t\t\t\t} else {\n+\t\t\t\t\tresolve()\n+\t\t\t\t}\n+\t\t\t})\n+\t\t})\n+\t} catch (error) {\n+\t\t// Silently fail - desktop notifications are not critical\n+\t\tconsole.debug(\"Desktop notification failed:\", error)\n+\t}\n+}\n+\n+/**\n+ * Shows a notification for approval requests\n+ */\n+export const showApprovalNotification = async (toolName: string, message?: string): Promise<void> => {\n+\tawait showDesktopNotification(\"approval\", {\n+\t\ttitle: \"Roo Code - Approval Required\",",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2205598677",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5703,
        "pr_file": "src/utils/desktopNotifications.ts",
        "discussion_id": "2205598677",
        "commented_code": "@@ -0,0 +1,162 @@\n+import * as notifier from \"node-notifier\"\n+import * as path from \"path\"\n+\n+// Type definitions for node-notifier callback\n+type NotifierCallback = (err: Error | null, response: string, metadata?: any) => void\n+\n+export interface DesktopNotificationOptions {\n+\ttitle: string\n+\tmessage: string\n+\ticon?: string\n+\tsound?: boolean\n+\twait?: boolean\n+\ttimeout?: number\n+\tactions?: string[]\n+\tcloseLabel?: string\n+\tdropdownLabel?: string\n+\treply?: boolean\n+}\n+\n+export type NotificationType = \"approval\" | \"completion\" | \"error\" | \"info\"\n+\n+let isDesktopNotificationsEnabled = false\n+\n+export const setDesktopNotificationsEnabled = (enabled: boolean) => {\n+\tisDesktopNotificationsEnabled = enabled\n+}\n+\n+export const getDesktopNotificationsEnabled = (): boolean => {\n+\treturn isDesktopNotificationsEnabled\n+}\n+\n+/**\n+ * Shows a desktop notification using the native OS notification system\n+ */\n+export const showDesktopNotification = async (\n+\ttype: NotificationType,\n+\toptions: DesktopNotificationOptions,\n+): Promise<void> => {\n+\tif (!isDesktopNotificationsEnabled) {\n+\t\treturn\n+\t}\n+\n+\ttry {\n+\t\t// Get the extension icon path\n+\t\tconst iconPath = getIconPath()\n+\n+\t\tconst notificationOptions: notifier.Notification = {\n+\t\t\ttitle: options.title,\n+\t\t\tmessage: options.message,\n+\t\t\ticon: options.icon || iconPath,\n+\t\t\twait: options.wait || false,\n+\t\t}\n+\n+\t\t// Platform-specific customizations\n+\t\tif (process.platform === \"darwin\") {\n+\t\t\t// macOS specific options\n+\t\t\t;(notificationOptions as any).subtitle = getSubtitleForType(type)\n+\t\t} else if (process.platform === \"win32\") {\n+\t\t\t// Windows specific options\n+\t\t\t;(notificationOptions as any).appID = \"RooCode\"\n+\t\t}\n+\n+\t\tawait new Promise<void>((resolve, reject) => {\n+\t\t\tnotifier.notify(notificationOptions, (err: Error | null, response: string, metadata?: any) => {\n+\t\t\t\tif (err) {\n+\t\t\t\t\treject(err)\n+\t\t\t\t} else {\n+\t\t\t\t\tresolve()\n+\t\t\t\t}\n+\t\t\t})\n+\t\t})\n+\t} catch (error) {\n+\t\t// Silently fail - desktop notifications are not critical\n+\t\tconsole.debug(\"Desktop notification failed:\", error)\n+\t}\n+}\n+\n+/**\n+ * Shows a notification for approval requests\n+ */\n+export const showApprovalNotification = async (toolName: string, message?: string): Promise<void> => {\n+\tawait showDesktopNotification(\"approval\", {\n+\t\ttitle: \"Roo Code - Approval Required\",",
        "comment_created_at": "2025-07-14T18:54:21+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider using i18n translations rather than hardcoded English strings for user\u2010facing notification titles and messages. For example, instead of \u201cRoo Code - Approval Required\u201d, use a translation key (e.g. t('notifications.approvalTitle')).\n```suggestion\n\t\ttitle: t('notifications.approvalTitle'),\n```\n\n<sup>This comment was generated because it violated a code review rule: [irule_C0ez7Rji6ANcGkkX](https://app.ellipsis.dev/RooCodeInc/code-review/rules?id=irule_C0ez7Rji6ANcGkkX).</sup>",
        "pr_file_module": null
      }
    ]
  }
]