[
  {
    "discussion_id": "2180825204",
    "pr_number": 5351,
    "pr_file": "src/services/code-index/embedders/openai.ts",
    "created_at": "2025-07-02T19:29:00+00:00",
    "commented_code": "name: \"openai\",\n \t\t}\n \t}\n+\n+\t/**\n+\t * Detects if an error is due to insufficient quota/credits\n+\t * @param error The error object to check\n+\t * @returns True if the error indicates insufficient quota\n+\t */\n+\tprivate isInsufficientQuotaError(error: any): boolean {",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2180825204",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5351,
        "pr_file": "src/services/code-index/embedders/openai.ts",
        "discussion_id": "2180825204",
        "commented_code": "@@ -193,4 +199,31 @@ export class OpenAiEmbedder extends OpenAiNativeHandler implements IEmbedder {\n \t\t\tname: \"openai\",\n \t\t}\n \t}\n+\n+\t/**\n+\t * Detects if an error is due to insufficient quota/credits\n+\t * @param error The error object to check\n+\t * @returns True if the error indicates insufficient quota\n+\t */\n+\tprivate isInsufficientQuotaError(error: any): boolean {",
        "comment_created_at": "2025-07-02T19:29:00+00:00",
        "comment_author": "Copilot",
        "comment_body": "This quota-detection method is duplicated in `openai-compatible.ts`. Consider extracting it into a shared utility to avoid code duplication.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145577950",
    "pr_number": 4494,
    "pr_file": "src/services/checkpoints/ShadowCheckpointService.ts",
    "created_at": "2025-06-13T17:24:17+00:00",
    "commented_code": ")\n \n \t\t\t\tawait git.branch([\"-D\", branchName])\n+\t\t\t\t// --- STAGE 3: Run GC after deleting a branch ---",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2145577950",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 4494,
        "pr_file": "src/services/checkpoints/ShadowCheckpointService.ts",
        "discussion_id": "2145577950",
        "commented_code": "@@ -408,10 +633,34 @@ export abstract class ShadowCheckpointService extends EventEmitter {\n \t\t\t\t)\n \n \t\t\t\tawait git.branch([\"-D\", branchName])\n+\t\t\t\t// --- STAGE 3: Run GC after deleting a branch ---",
        "comment_created_at": "2025-06-13T17:24:17+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "I notice the GC logic is duplicated between lines 636-658 and 674-694. Could we extract this into a separate method to follow DRY principles? Something like:\n\n```typescript\nprivate static async runBackgroundGC(git: SimpleGit, branchName: string): Promise<void> {\n    try {\n        this.log(`[${this.name}#deleteBranch] Running gc --prune=now after deleting branch ${branchName}`);\n        git.raw([\"gc\", \"--prune=now\", \"--quiet\"])\n            .then(() => {\n                this.log(`[${this.name}#deleteBranch] Background gc --prune=now completed for branch ${branchName}`);\n            })\n            .catch((gcError) => {\n                this.log(`[${this.name}#deleteBranch] ERROR: Background gc after deleting branch ${branchName} failed: ${gcError instanceof Error ? gcError.message : String(gcError)}`);\n            });\n    } catch (e) {\n        this.log(`[${this.name}#deleteBranch] ERROR: Failed to initiate gc: ${e instanceof Error ? e.message : String(e)}`);\n    }\n}\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2148626032",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 4494,
        "pr_file": "src/services/checkpoints/ShadowCheckpointService.ts",
        "discussion_id": "2145577950",
        "commented_code": "@@ -408,10 +633,34 @@ export abstract class ShadowCheckpointService extends EventEmitter {\n \t\t\t\t)\n \n \t\t\t\tawait git.branch([\"-D\", branchName])\n+\t\t\t\t// --- STAGE 3: Run GC after deleting a branch ---",
        "comment_created_at": "2025-06-15T17:48:53+00:00",
        "comment_author": "ijin",
        "comment_body": "sure I can do that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2160035900",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 4494,
        "pr_file": "src/services/checkpoints/ShadowCheckpointService.ts",
        "discussion_id": "2145577950",
        "commented_code": "@@ -408,10 +633,34 @@ export abstract class ShadowCheckpointService extends EventEmitter {\n \t\t\t\t)\n \n \t\t\t\tawait git.branch([\"-D\", branchName])\n+\t\t\t\t// --- STAGE 3: Run GC after deleting a branch ---",
        "comment_created_at": "2025-06-21T13:14:30+00:00",
        "comment_author": "ijin",
        "comment_body": "done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2061170476",
    "pr_number": 2670,
    "pr_file": "src/core/tools/executeCommandTool.ts",
    "created_at": "2025-04-26T05:10:27+00:00",
    "commented_code": "import { Terminal } from \"../../integrations/terminal/Terminal\"\n import { TerminalRegistry } from \"../../integrations/terminal/TerminalRegistry\"\n import { telemetryService } from \"../../services/telemetry/TelemetryService\"\n+import { CommandRiskLevel, commandRiskLevels } from \"../../schemas\"\n+\n+// Function to validate risk level\n+export const isValidRiskLevel = (risk: string): boolean => {",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2061170476",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 2670,
        "pr_file": "src/core/tools/executeCommandTool.ts",
        "discussion_id": "2061170476",
        "commented_code": "@@ -11,6 +11,20 @@ import { ExitCodeDetails, TerminalProcess } from \"../../integrations/terminal/Te\n import { Terminal } from \"../../integrations/terminal/Terminal\"\n import { TerminalRegistry } from \"../../integrations/terminal/TerminalRegistry\"\n import { telemetryService } from \"../../services/telemetry/TelemetryService\"\n+import { CommandRiskLevel, commandRiskLevels } from \"../../schemas\"\n+\n+// Function to validate risk level\n+export const isValidRiskLevel = (risk: string): boolean => {",
        "comment_created_at": "2025-04-26T05:10:27+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "This utility function is identical to the existing one. Consider importing and reusing the existing function instead of duplicating it.\n\n- function `isValidRiskLevel` ([commandRiskUtils.ts](https://github.com/RooVetGit/Roo-Code/blob/15bef28351276194654b246ea0440d5baf857f21/webview-ui/src/utils/commandRiskUtils.ts#L14-L16))\n\n<sup>This comment was generated because it violated a code review rule: [mrule_fYE6mUdYYxZL58YF](https://app.ellipsis.dev/RooVetGit/code-review/rules?id=mrule_fYE6mUdYYxZL58YF).</sup>",
        "pr_file_module": null
      },
      {
        "comment_id": "2061177402",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 2670,
        "pr_file": "src/core/tools/executeCommandTool.ts",
        "discussion_id": "2061170476",
        "commented_code": "@@ -11,6 +11,20 @@ import { ExitCodeDetails, TerminalProcess } from \"../../integrations/terminal/Te\n import { Terminal } from \"../../integrations/terminal/Terminal\"\n import { TerminalRegistry } from \"../../integrations/terminal/TerminalRegistry\"\n import { telemetryService } from \"../../services/telemetry/TelemetryService\"\n+import { CommandRiskLevel, commandRiskLevels } from \"../../schemas\"\n+\n+// Function to validate risk level\n+export const isValidRiskLevel = (risk: string): boolean => {",
        "comment_created_at": "2025-04-26T05:32:40+00:00",
        "comment_author": "KJ7LNW",
        "comment_body": "fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157768771",
    "pr_number": 4848,
    "pr_file": "src/utils/autoImportConfig.ts",
    "created_at": "2025-06-19T23:17:31+00:00",
    "commented_code": "+import * as vscode from \"vscode\"\n+import * as path from \"path\"\n+import * as os from \"os\"\n+import fs from \"fs/promises\"\n+import { z, ZodError } from \"zod\"\n+\n+import { globalSettingsSchema } from \"@roo-code/types\"\n+import { TelemetryService } from \"@roo-code/telemetry\"\n+\n+import { Package } from \"../shared/package\"\n+import { ClineProvider } from \"../core/webview/ClineProvider\"\n+\n+import { providerProfilesSchema } from \"../core/config/ProviderSettingsManager\"\n+import { CustomModesManager } from \"../core/config/CustomModesManager\"\n+import { fileExistsAtPath } from \"./fs\"\n+\n+type AutoImportOptions = {\n+\tprovider: ClineProvider\n+\tcustomModesManager: CustomModesManager\n+\toutputChannel: vscode.OutputChannel\n+}\n+\n+/**\n+ * Automatically imports RooCode configuration from a specified path if it exists.\n+ * This function is called during extension activation to allow users to pre-configure\n+ * their settings by placing a config file at a predefined location.\n+ */\n+export async function autoImportConfig({\n+\tprovider,\n+\tcustomModesManager,\n+\toutputChannel,\n+}: AutoImportOptions): Promise<void> {\n+\ttry {\n+\t\t// Get the auto-import config path from VSCode settings\n+\t\tconst configPath = vscode.workspace.getConfiguration(Package.name).get<string>(\"autoImportConfigPath\")\n+\n+\t\tif (!configPath || configPath.trim() === \"\") {\n+\t\t\toutputChannel.appendLine(\"[AutoImport] No auto-import config path specified, skipping auto-import\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Resolve the path (handle ~ for home directory and relative paths)\n+\t\tconst resolvedPath = resolvePath(configPath.trim())\n+\t\toutputChannel.appendLine(`[AutoImport] Checking for config file at: ${resolvedPath}`)\n+\n+\t\t// Check if the file exists\n+\t\tif (!(await fileExistsAtPath(resolvedPath))) {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Config file not found at ${resolvedPath}, skipping auto-import`)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Attempt to import the configuration\n+\t\tconst result = await importConfigFromPath(resolvedPath, {\n+\t\t\tprovider,\n+\t\t\tcustomModesManager,\n+\t\t})\n+\n+\t\tif (result.success) {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Successfully imported configuration from ${resolvedPath}`)\n+\n+\t\t\t// Show a notification to the user\n+\t\t\tvscode.window.showInformationMessage(\n+\t\t\t\t`RooCode configuration automatically imported from ${path.basename(resolvedPath)}`,\n+\t\t\t)\n+\t\t} else {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Failed to import configuration: ${result.error}`)\n+\n+\t\t\t// Show a warning but don't fail the extension activation\n+\t\t\tvscode.window.showWarningMessage(`Failed to auto-import RooCode configuration: ${result.error}`)\n+\t\t}\n+\t} catch (error) {\n+\t\tconst errorMessage = error instanceof Error ? error.message : String(error)\n+\t\toutputChannel.appendLine(`[AutoImport] Unexpected error during auto-import: ${errorMessage}`)\n+\n+\t\t// Log error but don't fail extension activation\n+\t\tconsole.warn(\"Auto-import config error:\", error)\n+\t}\n+}\n+\n+/**\n+ * Resolves a file path, handling home directory expansion and relative paths\n+ */\n+function resolvePath(configPath: string): string {\n+\t// Handle home directory expansion\n+\tif (configPath.startsWith(\"~/\")) {\n+\t\treturn path.join(os.homedir(), configPath.slice(2))\n+\t}\n+\n+\t// Handle absolute paths\n+\tif (path.isAbsolute(configPath)) {\n+\t\treturn configPath\n+\t}\n+\n+\t// Handle relative paths (relative to home directory for safety)\n+\treturn path.join(os.homedir(), configPath)\n+}\n+\n+/**\n+ * Imports configuration from a specific file path\n+ * This is similar to the existing importSettings function but works with a file path\n+ * instead of showing a file dialog\n+ */\n+async function importConfigFromPath(",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2157768771",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 4848,
        "pr_file": "src/utils/autoImportConfig.ts",
        "discussion_id": "2157768771",
        "commented_code": "@@ -0,0 +1,163 @@\n+import * as vscode from \"vscode\"\n+import * as path from \"path\"\n+import * as os from \"os\"\n+import fs from \"fs/promises\"\n+import { z, ZodError } from \"zod\"\n+\n+import { globalSettingsSchema } from \"@roo-code/types\"\n+import { TelemetryService } from \"@roo-code/telemetry\"\n+\n+import { Package } from \"../shared/package\"\n+import { ClineProvider } from \"../core/webview/ClineProvider\"\n+\n+import { providerProfilesSchema } from \"../core/config/ProviderSettingsManager\"\n+import { CustomModesManager } from \"../core/config/CustomModesManager\"\n+import { fileExistsAtPath } from \"./fs\"\n+\n+type AutoImportOptions = {\n+\tprovider: ClineProvider\n+\tcustomModesManager: CustomModesManager\n+\toutputChannel: vscode.OutputChannel\n+}\n+\n+/**\n+ * Automatically imports RooCode configuration from a specified path if it exists.\n+ * This function is called during extension activation to allow users to pre-configure\n+ * their settings by placing a config file at a predefined location.\n+ */\n+export async function autoImportConfig({\n+\tprovider,\n+\tcustomModesManager,\n+\toutputChannel,\n+}: AutoImportOptions): Promise<void> {\n+\ttry {\n+\t\t// Get the auto-import config path from VSCode settings\n+\t\tconst configPath = vscode.workspace.getConfiguration(Package.name).get<string>(\"autoImportConfigPath\")\n+\n+\t\tif (!configPath || configPath.trim() === \"\") {\n+\t\t\toutputChannel.appendLine(\"[AutoImport] No auto-import config path specified, skipping auto-import\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Resolve the path (handle ~ for home directory and relative paths)\n+\t\tconst resolvedPath = resolvePath(configPath.trim())\n+\t\toutputChannel.appendLine(`[AutoImport] Checking for config file at: ${resolvedPath}`)\n+\n+\t\t// Check if the file exists\n+\t\tif (!(await fileExistsAtPath(resolvedPath))) {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Config file not found at ${resolvedPath}, skipping auto-import`)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Attempt to import the configuration\n+\t\tconst result = await importConfigFromPath(resolvedPath, {\n+\t\t\tprovider,\n+\t\t\tcustomModesManager,\n+\t\t})\n+\n+\t\tif (result.success) {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Successfully imported configuration from ${resolvedPath}`)\n+\n+\t\t\t// Show a notification to the user\n+\t\t\tvscode.window.showInformationMessage(\n+\t\t\t\t`RooCode configuration automatically imported from ${path.basename(resolvedPath)}`,\n+\t\t\t)\n+\t\t} else {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Failed to import configuration: ${result.error}`)\n+\n+\t\t\t// Show a warning but don't fail the extension activation\n+\t\t\tvscode.window.showWarningMessage(`Failed to auto-import RooCode configuration: ${result.error}`)\n+\t\t}\n+\t} catch (error) {\n+\t\tconst errorMessage = error instanceof Error ? error.message : String(error)\n+\t\toutputChannel.appendLine(`[AutoImport] Unexpected error during auto-import: ${errorMessage}`)\n+\n+\t\t// Log error but don't fail extension activation\n+\t\tconsole.warn(\"Auto-import config error:\", error)\n+\t}\n+}\n+\n+/**\n+ * Resolves a file path, handling home directory expansion and relative paths\n+ */\n+function resolvePath(configPath: string): string {\n+\t// Handle home directory expansion\n+\tif (configPath.startsWith(\"~/\")) {\n+\t\treturn path.join(os.homedir(), configPath.slice(2))\n+\t}\n+\n+\t// Handle absolute paths\n+\tif (path.isAbsolute(configPath)) {\n+\t\treturn configPath\n+\t}\n+\n+\t// Handle relative paths (relative to home directory for safety)\n+\treturn path.join(os.homedir(), configPath)\n+}\n+\n+/**\n+ * Imports configuration from a specific file path\n+ * This is similar to the existing importSettings function but works with a file path\n+ * instead of showing a file dialog\n+ */\n+async function importConfigFromPath(",
        "comment_created_at": "2025-06-19T23:17:31+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "There's significant code duplication between this `importConfigFromPath` function and the existing `importSettings` function in `src/core/config/importExport.ts`. \n\nCould we refactor to share the common import logic? Perhaps extract a shared function that both can use, something like:\n\n```typescript\nexport async function importConfigFromData(\n  data: unknown,\n  options: ImportOptions\n): Promise<{ success: boolean; error?: string }>\n```\n\nThis would reduce maintenance burden and ensure consistent behavior between manual and automatic imports.",
        "pr_file_module": null
      },
      {
        "comment_id": "2162013864",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 4848,
        "pr_file": "src/utils/autoImportConfig.ts",
        "discussion_id": "2157768771",
        "commented_code": "@@ -0,0 +1,163 @@\n+import * as vscode from \"vscode\"\n+import * as path from \"path\"\n+import * as os from \"os\"\n+import fs from \"fs/promises\"\n+import { z, ZodError } from \"zod\"\n+\n+import { globalSettingsSchema } from \"@roo-code/types\"\n+import { TelemetryService } from \"@roo-code/telemetry\"\n+\n+import { Package } from \"../shared/package\"\n+import { ClineProvider } from \"../core/webview/ClineProvider\"\n+\n+import { providerProfilesSchema } from \"../core/config/ProviderSettingsManager\"\n+import { CustomModesManager } from \"../core/config/CustomModesManager\"\n+import { fileExistsAtPath } from \"./fs\"\n+\n+type AutoImportOptions = {\n+\tprovider: ClineProvider\n+\tcustomModesManager: CustomModesManager\n+\toutputChannel: vscode.OutputChannel\n+}\n+\n+/**\n+ * Automatically imports RooCode configuration from a specified path if it exists.\n+ * This function is called during extension activation to allow users to pre-configure\n+ * their settings by placing a config file at a predefined location.\n+ */\n+export async function autoImportConfig({\n+\tprovider,\n+\tcustomModesManager,\n+\toutputChannel,\n+}: AutoImportOptions): Promise<void> {\n+\ttry {\n+\t\t// Get the auto-import config path from VSCode settings\n+\t\tconst configPath = vscode.workspace.getConfiguration(Package.name).get<string>(\"autoImportConfigPath\")\n+\n+\t\tif (!configPath || configPath.trim() === \"\") {\n+\t\t\toutputChannel.appendLine(\"[AutoImport] No auto-import config path specified, skipping auto-import\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Resolve the path (handle ~ for home directory and relative paths)\n+\t\tconst resolvedPath = resolvePath(configPath.trim())\n+\t\toutputChannel.appendLine(`[AutoImport] Checking for config file at: ${resolvedPath}`)\n+\n+\t\t// Check if the file exists\n+\t\tif (!(await fileExistsAtPath(resolvedPath))) {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Config file not found at ${resolvedPath}, skipping auto-import`)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Attempt to import the configuration\n+\t\tconst result = await importConfigFromPath(resolvedPath, {\n+\t\t\tprovider,\n+\t\t\tcustomModesManager,\n+\t\t})\n+\n+\t\tif (result.success) {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Successfully imported configuration from ${resolvedPath}`)\n+\n+\t\t\t// Show a notification to the user\n+\t\t\tvscode.window.showInformationMessage(\n+\t\t\t\t`RooCode configuration automatically imported from ${path.basename(resolvedPath)}`,\n+\t\t\t)\n+\t\t} else {\n+\t\t\toutputChannel.appendLine(`[AutoImport] Failed to import configuration: ${result.error}`)\n+\n+\t\t\t// Show a warning but don't fail the extension activation\n+\t\t\tvscode.window.showWarningMessage(`Failed to auto-import RooCode configuration: ${result.error}`)\n+\t\t}\n+\t} catch (error) {\n+\t\tconst errorMessage = error instanceof Error ? error.message : String(error)\n+\t\toutputChannel.appendLine(`[AutoImport] Unexpected error during auto-import: ${errorMessage}`)\n+\n+\t\t// Log error but don't fail extension activation\n+\t\tconsole.warn(\"Auto-import config error:\", error)\n+\t}\n+}\n+\n+/**\n+ * Resolves a file path, handling home directory expansion and relative paths\n+ */\n+function resolvePath(configPath: string): string {\n+\t// Handle home directory expansion\n+\tif (configPath.startsWith(\"~/\")) {\n+\t\treturn path.join(os.homedir(), configPath.slice(2))\n+\t}\n+\n+\t// Handle absolute paths\n+\tif (path.isAbsolute(configPath)) {\n+\t\treturn configPath\n+\t}\n+\n+\t// Handle relative paths (relative to home directory for safety)\n+\treturn path.join(os.homedir(), configPath)\n+}\n+\n+/**\n+ * Imports configuration from a specific file path\n+ * This is similar to the existing importSettings function but works with a file path\n+ * instead of showing a file dialog\n+ */\n+async function importConfigFromPath(",
        "comment_created_at": "2025-06-23T16:25:54+00:00",
        "comment_author": "takakoutso",
        "comment_body": "Great point. I've gone ahead and created a helper function `importSettingsFromPath` in `src/core/config/importExport.ts` that both the manual `importSettings` and automatic `autoImportConfig` functions call. Each function simple encapsulates functionality to retrieve and parse file paths and make use of `importSettingsFromPath` to import the settings from that resolved file path. I'll also rename `config` to `settings` to match terminology for consistency.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165589365",
    "pr_number": 5099,
    "pr_file": "src/core/config/CustomModesManager.ts",
    "created_at": "2025-06-25T03:41:23+00:00",
    "commented_code": "return exists ? roomodesPath : undefined\n \t}\n \n+\t/**\n+\t * Strip BOM (Byte Order Mark) from the beginning of a string\n+\t */\n+\tprivate stripBOM(content: string): string {\n+\t\t// Common BOMs: UTF-8, UTF-16 BE, UTF-16 LE\n+\t\tconst boms = [\n+\t\t\t\"\\uFEFF\", // UTF-8 BOM\n+\t\t\t\"\\uFFFE\", // UTF-16 LE BOM (reversed)\n+\t\t]\n+\n+\t\tlet result = content\n+\t\tfor (const bom of boms) {\n+\t\t\tif (result.startsWith(bom)) {\n+\t\t\t\tresult = result.slice(bom.length)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn result\n+\t}\n+\n+\t/**\n+\t * Clean invisible and problematic characters from YAML content\n+\t */\n+\tprivate cleanInvisibleCharacters(content: string): string {\n+\t\t// Replace non-breaking spaces with regular spaces\n+\t\tlet cleaned = content.replace(/\\u00A0/g, \" \")\n+\n+\t\t// Replace other invisible characters that can cause issues\n+\t\t// Zero-width space, zero-width non-joiner, zero-width joiner\n+\t\tcleaned = cleaned.replace(/[\\u200B\\u200C\\u200D]/g, \"\")\n+\n+\t\t// Replace various dash characters with standard hyphen\n+\t\tcleaned = cleaned.replace(/[\\u2010-\\u2015\\u2212]/g, \"-\")\n+\n+\t\t// Replace various quote characters with standard quotes\n+\t\tcleaned = cleaned.replace(/[\\u2018\\u2019]/g, \"'\")\n+\t\tcleaned = cleaned.replace(/[\\u201C\\u201D]/g, '\"')\n+\n+\t\treturn cleaned",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2165589365",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5099,
        "pr_file": "src/core/config/CustomModesManager.ts",
        "discussion_id": "2165589365",
        "commented_code": "@@ -73,12 +73,95 @@ export class CustomModesManager {\n \t\treturn exists ? roomodesPath : undefined\n \t}\n \n+\t/**\n+\t * Strip BOM (Byte Order Mark) from the beginning of a string\n+\t */\n+\tprivate stripBOM(content: string): string {\n+\t\t// Common BOMs: UTF-8, UTF-16 BE, UTF-16 LE\n+\t\tconst boms = [\n+\t\t\t\"\\uFEFF\", // UTF-8 BOM\n+\t\t\t\"\\uFFFE\", // UTF-16 LE BOM (reversed)\n+\t\t]\n+\n+\t\tlet result = content\n+\t\tfor (const bom of boms) {\n+\t\t\tif (result.startsWith(bom)) {\n+\t\t\t\tresult = result.slice(bom.length)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn result\n+\t}\n+\n+\t/**\n+\t * Clean invisible and problematic characters from YAML content\n+\t */\n+\tprivate cleanInvisibleCharacters(content: string): string {\n+\t\t// Replace non-breaking spaces with regular spaces\n+\t\tlet cleaned = content.replace(/\\u00A0/g, \" \")\n+\n+\t\t// Replace other invisible characters that can cause issues\n+\t\t// Zero-width space, zero-width non-joiner, zero-width joiner\n+\t\tcleaned = cleaned.replace(/[\\u200B\\u200C\\u200D]/g, \"\")\n+\n+\t\t// Replace various dash characters with standard hyphen\n+\t\tcleaned = cleaned.replace(/[\\u2010-\\u2015\\u2212]/g, \"-\")\n+\n+\t\t// Replace various quote characters with standard quotes\n+\t\tcleaned = cleaned.replace(/[\\u2018\\u2019]/g, \"'\")\n+\t\tcleaned = cleaned.replace(/[\\u201C\\u201D]/g, '\"')\n+\n+\t\treturn cleaned",
        "comment_created_at": "2025-06-25T03:41:23+00:00",
        "comment_author": "Copilot",
        "comment_body": "[nitpick] Consider consolidating the sequential `replace` calls into a single combined regex or utility function to reduce repetition and improve readability.\n```suggestion\n\t\t// Replace problematic characters with their standard equivalents\n\t\t// Non-breaking spaces -> regular spaces\n\t\t// Zero-width space, non-joiner, joiner -> removed\n\t\t// Various dash characters -> standard hyphen\n\t\t// Various single quotes -> standard single quote\n\t\t// Various double quotes -> standard double quote\n\t\tconst cleaned = content.replace(\n\t\t\t/[\\u00A0\\u200B\\u200C\\u200D\\u2010-\\u2015\\u2212\\u2018\\u2019\\u201C\\u201D]/g,\n\t\t\t(match) => {\n\t\t\t\tswitch (match) {\n\t\t\t\t\tcase \"\\u00A0\": return \" \";\n\t\t\t\t\tcase \"\\u200B\": case \"\\u200C\": case \"\\u200D\": return \"\";\n\t\t\t\t\tcase \"\\u2010\": case \"\\u2011\": case \"\\u2012\": case \"\\u2013\": case \"\\u2014\": case \"\\u2015\": case \"\\u2212\": return \"-\";\n\t\t\t\t\tcase \"\\u2018\": case \"\\u2019\": return \"'\";\n\t\t\t\t\tcase \"\\u201C\": case \"\\u201D\": return '\"';\n\t\t\t\t\tdefault: return match;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\treturn cleaned;\n```",
        "pr_file_module": null
      }
    ]
  }
]