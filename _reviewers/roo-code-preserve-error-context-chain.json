[
  {
    "discussion_id": "2186130236",
    "pr_number": 5403,
    "pr_file": "src/services/code-index/processors/scanner.ts",
    "created_at": "2025-07-04T21:35:02+00:00",
    "commented_code": "await this.qdrantClient.deletePointsByMultipleFilePaths(uniqueFilePaths)\n \t\t\t\t\t} catch (deleteError) {\n \t\t\t\t\t\tconsole.error(\n-\t\t\t\t\t\t\t`[DirectoryScanner] Failed to delete points for ${uniqueFilePaths.length} files before upsert:`,\n+\t\t\t\t\t\t\t`[DirectoryScanner] Failed to delete points for ${uniqueFilePaths.length} files before upsert in workspace ${scanWorkspace}:`,\n \t\t\t\t\t\t\tdeleteError,\n \t\t\t\t\t\t)\n-\t\t\t\t\t\t// Re-throw the error to stop processing this batch attempt\n-\t\t\t\t\t\tthrow deleteError\n+\t\t\t\t\t\t// Re-throw the error with workspace context\n+\t\t\t\t\t\tthrow new Error(\n+\t\t\t\t\t\t\t`Failed to delete points for ${uniqueFilePaths.length} files. Workspace: ${scanWorkspace}. ${deleteError instanceof Error ? deleteError.message : String(deleteError)}`,",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2186130236",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5403,
        "pr_file": "src/services/code-index/processors/scanner.ts",
        "discussion_id": "2186130236",
        "commented_code": "@@ -292,11 +306,13 @@ export class DirectoryScanner implements IDirectoryScanner {\n \t\t\t\t\t\tawait this.qdrantClient.deletePointsByMultipleFilePaths(uniqueFilePaths)\n \t\t\t\t\t} catch (deleteError) {\n \t\t\t\t\t\tconsole.error(\n-\t\t\t\t\t\t\t`[DirectoryScanner] Failed to delete points for ${uniqueFilePaths.length} files before upsert:`,\n+\t\t\t\t\t\t\t`[DirectoryScanner] Failed to delete points for ${uniqueFilePaths.length} files before upsert in workspace ${scanWorkspace}:`,\n \t\t\t\t\t\t\tdeleteError,\n \t\t\t\t\t\t)\n-\t\t\t\t\t\t// Re-throw the error to stop processing this batch attempt\n-\t\t\t\t\t\tthrow deleteError\n+\t\t\t\t\t\t// Re-throw the error with workspace context\n+\t\t\t\t\t\tthrow new Error(\n+\t\t\t\t\t\t\t`Failed to delete points for ${uniqueFilePaths.length} files. Workspace: ${scanWorkspace}. ${deleteError instanceof Error ? deleteError.message : String(deleteError)}`,",
        "comment_created_at": "2025-07-04T21:35:02+00:00",
        "comment_author": "Copilot",
        "comment_body": "Wrapping the original error in a new `Error` instance discards its stack trace and type. Consider using the `cause` option (`new Error(message, { cause: deleteError })`) to preserve the original error context.\n```suggestion\n\t\t\t\t\t\t\t`Failed to delete points for ${uniqueFilePaths.length} files. Workspace: ${scanWorkspace}. ${deleteError instanceof Error ? deleteError.message : String(deleteError)}`,\n\t\t\t\t\t\t\t{ cause: deleteError }\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188428844",
    "pr_number": 5435,
    "pr_file": "packages/cloud/src/StaticSettingsService.ts",
    "created_at": "2025-07-06T16:01:20+00:00",
    "commented_code": "+import {\n+\tORGANIZATION_ALLOW_ALL,\n+\tOrganizationAllowList,\n+\tOrganizationSettings,\n+\torganizationSettingsSchema,\n+} from \"@roo-code/types\"\n+\n+import type { SettingsService } from \"./SettingsService\"\n+\n+export class StaticSettingsService implements SettingsService {\n+\tprivate settings: OrganizationSettings\n+\tprivate log: (...args: unknown[]) => void\n+\n+\tconstructor(envValue: string, log?: (...args: unknown[]) => void) {\n+\t\tthis.log = log || console.log\n+\t\tthis.settings = this.parseEnvironmentSettings(envValue)\n+\t}\n+\n+\tprivate parseEnvironmentSettings(envValue: string): OrganizationSettings {\n+\t\ttry {\n+\t\t\tconst decodedValue = Buffer.from(envValue, \"base64\").toString(\"utf-8\")\n+\t\t\tconst parsedJson = JSON.parse(decodedValue)\n+\t\t\treturn organizationSettingsSchema.parse(parsedJson)\n+\t\t} catch (error) {\n+\t\t\tthis.log(`[StaticSettingsService] failed to parse static settings: ${error.message}`, error)\n+\t\t\tthrow new Error(\"Failed to parse static settings\", error)",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2188428844",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5435,
        "pr_file": "packages/cloud/src/StaticSettingsService.ts",
        "discussion_id": "2188428844",
        "commented_code": "@@ -0,0 +1,41 @@\n+import {\n+\tORGANIZATION_ALLOW_ALL,\n+\tOrganizationAllowList,\n+\tOrganizationSettings,\n+\torganizationSettingsSchema,\n+} from \"@roo-code/types\"\n+\n+import type { SettingsService } from \"./SettingsService\"\n+\n+export class StaticSettingsService implements SettingsService {\n+\tprivate settings: OrganizationSettings\n+\tprivate log: (...args: unknown[]) => void\n+\n+\tconstructor(envValue: string, log?: (...args: unknown[]) => void) {\n+\t\tthis.log = log || console.log\n+\t\tthis.settings = this.parseEnvironmentSettings(envValue)\n+\t}\n+\n+\tprivate parseEnvironmentSettings(envValue: string): OrganizationSettings {\n+\t\ttry {\n+\t\t\tconst decodedValue = Buffer.from(envValue, \"base64\").toString(\"utf-8\")\n+\t\t\tconst parsedJson = JSON.parse(decodedValue)\n+\t\t\treturn organizationSettingsSchema.parse(parsedJson)\n+\t\t} catch (error) {\n+\t\t\tthis.log(`[StaticSettingsService] failed to parse static settings: ${error.message}`, error)\n+\t\t\tthrow new Error(\"Failed to parse static settings\", error)",
        "comment_created_at": "2025-07-06T16:01:20+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Instead of passing the error as a second argument to Error, consider using the 'cause' property (e.g., new Error('Failed to parse static settings', { cause: error })).\n```suggestion\n\t\t\tthrow new Error(\"Failed to parse static settings\", { cause: error })\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2197977596",
    "pr_number": 5565,
    "pr_file": "src/services/code-index/vector-store/qdrant-client.ts",
    "created_at": "2025-07-10T14:54:58+00:00",
    "commented_code": "created = false // Exists and correct\n \t\t\t\t} else {\n \t\t\t\t\t// Exists but wrong vector size, recreate\n-\t\t\t\t\tconsole.warn(\n-\t\t\t\t\t\t`[QdrantVectorStore] Collection ${this.collectionName} exists with vector size ${existingVectorSize}, but expected ${this.vectorSize}. Recreating collection.`,\n-\t\t\t\t\t)\n-\t\t\t\t\tawait this.client.deleteCollection(this.collectionName) // Known to exist\n-\t\t\t\t\tawait this.client.createCollection(this.collectionName, {\n-\t\t\t\t\t\tvectors: {\n-\t\t\t\t\t\t\tsize: this.vectorSize,\n-\t\t\t\t\t\t\tdistance: this.DISTANCE_METRIC,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t})\n-\t\t\t\t\tcreated = true\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tconsole.warn(\n+\t\t\t\t\t\t\t`[QdrantVectorStore] Collection ${this.collectionName} exists with vector size ${existingVectorSize}, but expected ${this.vectorSize}. Recreating collection.`,\n+\t\t\t\t\t\t)\n+\t\t\t\t\t\tawait this.client.deleteCollection(this.collectionName)\n+\t\t\t\t\t\tawait this.client.createCollection(this.collectionName, {\n+\t\t\t\t\t\t\tvectors: {\n+\t\t\t\t\t\t\t\tsize: this.vectorSize,\n+\t\t\t\t\t\t\t\tdistance: this.DISTANCE_METRIC,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\tcreated = true\n+\t\t\t\t\t} catch (recreationError) {\n+\t\t\t\t\t\tconst errorMessage =\n+\t\t\t\t\t\t\trecreationError instanceof Error ? recreationError.message : String(recreationError)\n+\t\t\t\t\t\tconsole.error(\n+\t\t\t\t\t\t\t`[QdrantVectorStore] CRITICAL: Failed to recreate collection ${this.collectionName} for new vector size. Error: ${errorMessage}`,\n+\t\t\t\t\t\t)\n+\t\t\t\t\t\tthrow new Error(",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2197977596",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5565,
        "pr_file": "src/services/code-index/vector-store/qdrant-client.ts",
        "discussion_id": "2197977596",
        "commented_code": "@@ -165,17 +165,30 @@ export class QdrantVectorStore implements IVectorStore {\n \t\t\t\t\tcreated = false // Exists and correct\n \t\t\t\t} else {\n \t\t\t\t\t// Exists but wrong vector size, recreate\n-\t\t\t\t\tconsole.warn(\n-\t\t\t\t\t\t`[QdrantVectorStore] Collection ${this.collectionName} exists with vector size ${existingVectorSize}, but expected ${this.vectorSize}. Recreating collection.`,\n-\t\t\t\t\t)\n-\t\t\t\t\tawait this.client.deleteCollection(this.collectionName) // Known to exist\n-\t\t\t\t\tawait this.client.createCollection(this.collectionName, {\n-\t\t\t\t\t\tvectors: {\n-\t\t\t\t\t\t\tsize: this.vectorSize,\n-\t\t\t\t\t\t\tdistance: this.DISTANCE_METRIC,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t})\n-\t\t\t\t\tcreated = true\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tconsole.warn(\n+\t\t\t\t\t\t\t`[QdrantVectorStore] Collection ${this.collectionName} exists with vector size ${existingVectorSize}, but expected ${this.vectorSize}. Recreating collection.`,\n+\t\t\t\t\t\t)\n+\t\t\t\t\t\tawait this.client.deleteCollection(this.collectionName)\n+\t\t\t\t\t\tawait this.client.createCollection(this.collectionName, {\n+\t\t\t\t\t\t\tvectors: {\n+\t\t\t\t\t\t\t\tsize: this.vectorSize,\n+\t\t\t\t\t\t\t\tdistance: this.DISTANCE_METRIC,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\tcreated = true\n+\t\t\t\t\t} catch (recreationError) {\n+\t\t\t\t\t\tconst errorMessage =\n+\t\t\t\t\t\t\trecreationError instanceof Error ? recreationError.message : String(recreationError)\n+\t\t\t\t\t\tconsole.error(\n+\t\t\t\t\t\t\t`[QdrantVectorStore] CRITICAL: Failed to recreate collection ${this.collectionName} for new vector size. Error: ${errorMessage}`,\n+\t\t\t\t\t\t)\n+\t\t\t\t\t\tthrow new Error(",
        "comment_created_at": "2025-07-10T14:54:58+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "When recreating the collection due to a vector size mismatch, the error is caught and a new Error is thrown using t(). Consider using a custom error class (or error.cause if available) to preserve the original error context instead of relying on substring matching in later catch blocks.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2055279554",
    "pr_number": 2868,
    "pr_file": "src/core/task-persistence/taskMessages.jsonl.ts",
    "created_at": "2025-04-23T05:34:40+00:00",
    "commented_code": "+import * as path from \"path\"\n+import * as fs from \"fs/promises\"\n+import * as readline from \"readline\"\n+import { createReadStream } from \"fs\"\n+\n+import { fileExistsAtPath } from \"../../utils/fs\"\n+\n+import { GlobalFileNames } from \"../../shared/globalFileNames\"\n+import { ClineMessage } from \"../../shared/ExtensionMessage\"\n+import { getTaskDirectoryPath } from \"../../shared/storagePathManager\"\n+\n+import type { ReadTaskMessagesOptions, SaveTaskMessagesOptions } from \"./taskMessages\"\n+\n+export async function readTaskMessages({\n+\ttaskId,\n+\tglobalStoragePath,\n+}: ReadTaskMessagesOptions): Promise<ClineMessage[]> {\n+\tconst taskDir = await getTaskDirectoryPath(globalStoragePath, taskId)\n+\tconst filePath = path.join(taskDir, `${GlobalFileNames.apiConversationHistory}l`)\n+\tconst fileExists = await fileExistsAtPath(filePath)\n+\n+\tif (!fileExists) {\n+\t\treturn []\n+\t}\n+\n+\tconst messages: ClineMessage[] = []\n+\tconst fileStream = createReadStream(filePath, { encoding: \"utf8\" })\n+\tconst rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity })\n+\n+\tfor await (const line of rl) {\n+\t\tif (line.trim()) {\n+\t\t\tmessages.push(JSON.parse(line))",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2055279554",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 2868,
        "pr_file": "src/core/task-persistence/taskMessages.jsonl.ts",
        "discussion_id": "2055279554",
        "commented_code": "@@ -0,0 +1,56 @@\n+import * as path from \"path\"\n+import * as fs from \"fs/promises\"\n+import * as readline from \"readline\"\n+import { createReadStream } from \"fs\"\n+\n+import { fileExistsAtPath } from \"../../utils/fs\"\n+\n+import { GlobalFileNames } from \"../../shared/globalFileNames\"\n+import { ClineMessage } from \"../../shared/ExtensionMessage\"\n+import { getTaskDirectoryPath } from \"../../shared/storagePathManager\"\n+\n+import type { ReadTaskMessagesOptions, SaveTaskMessagesOptions } from \"./taskMessages\"\n+\n+export async function readTaskMessages({\n+\ttaskId,\n+\tglobalStoragePath,\n+}: ReadTaskMessagesOptions): Promise<ClineMessage[]> {\n+\tconst taskDir = await getTaskDirectoryPath(globalStoragePath, taskId)\n+\tconst filePath = path.join(taskDir, `${GlobalFileNames.apiConversationHistory}l`)\n+\tconst fileExists = await fileExistsAtPath(filePath)\n+\n+\tif (!fileExists) {\n+\t\treturn []\n+\t}\n+\n+\tconst messages: ClineMessage[] = []\n+\tconst fileStream = createReadStream(filePath, { encoding: \"utf8\" })\n+\tconst rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity })\n+\n+\tfor await (const line of rl) {\n+\t\tif (line.trim()) {\n+\t\t\tmessages.push(JSON.parse(line))",
        "comment_created_at": "2025-04-23T05:34:40+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "In `readTaskMessages`, `JSON.parse` is used on each line without error handling. Consider wrapping the parse call in a try/catch block to gracefully handle any malformed lines, logging an error if a line cannot be parsed.\n\n<sup>This comment was generated because it violated a code review rule: [mrule_OR1S8PRRHcvbdFib](https://app.ellipsis.dev/RooVetGit/code-review/rules?id=mrule_OR1S8PRRHcvbdFib).</sup>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2130822276",
    "pr_number": 4002,
    "pr_file": "src/utils/fs.ts",
    "created_at": "2025-06-05T23:03:44+00:00",
    "commented_code": "return false\n \t}\n }\n+\n+/**\n+ * Safely read a file and return its trimmed content\n+ */\n+export async function safeReadFile(filePath: string): Promise<string> {\n+\ttry {\n+\t\tconst content = await fs.readFile(filePath, \"utf-8\")\n+\t\treturn content ? content.trim() : \"\"\n+\t} catch (err) {\n+\t\tconst errorCode = (err as NodeJS.ErrnoException).code\n+\t\tif (!errorCode || ![\"ENOENT\", \"EISDIR\"].includes(errorCode)) {",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2130822276",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 4002,
        "pr_file": "src/utils/fs.ts",
        "discussion_id": "2130822276",
        "commented_code": "@@ -45,3 +45,19 @@ export async function fileExistsAtPath(filePath: string): Promise<boolean> {\n \t\treturn false\n \t}\n }\n+\n+/**\n+ * Safely read a file and return its trimmed content\n+ */\n+export async function safeReadFile(filePath: string): Promise<string> {\n+\ttry {\n+\t\tconst content = await fs.readFile(filePath, \"utf-8\")\n+\t\treturn content ? content.trim() : \"\"\n+\t} catch (err) {\n+\t\tconst errorCode = (err as NodeJS.ErrnoException).code\n+\t\tif (!errorCode || ![\"ENOENT\", \"EISDIR\"].includes(errorCode)) {",
        "comment_created_at": "2025-06-05T23:03:44+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "This error handling pattern for ENOENT is duplicated in multiple places:\r\n- Here in `safeReadFile`\r\n- In `ClineProvider.updateContent`\r\n- In `custom-instructions.ts`\r\n- In `custom-system-prompt.ts`\r\n\r\nIt would be a good idea to consolidate this on a single helper function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2093922018",
    "pr_number": 3693,
    "pr_file": "src/integrations/terminal/ExecaTerminalProcess.ts",
    "created_at": "2025-05-17T05:06:14+00:00",
    "commented_code": "timeoutId = setTimeout(() => {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tsubprocess.kill(\"SIGKILL\")\n-\t\t\t\t\t\t} catch (e) {}\n+\t\t\t\t\t\t} catch {}",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2093922018",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 3693,
        "pr_file": "src/integrations/terminal/ExecaTerminalProcess.ts",
        "discussion_id": "2093922018",
        "commented_code": "@@ -70,7 +70,7 @@ export class ExecaTerminalProcess extends BaseTerminalProcess {\n \t\t\t\t\ttimeoutId = setTimeout(() => {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tsubprocess.kill(\"SIGKILL\")\n-\t\t\t\t\t\t} catch (e) {}\n+\t\t\t\t\t\t} catch {}",
        "comment_created_at": "2025-05-17T05:06:14+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider logging errors in the empty catch block when killing the subprocess so that issues during termination aren\u2019t silently ignored.\n```suggestion\n\t\t\t\t\t\t} catch (e) { console.warn(e) }\n```\n\n<sup>This comment was generated because it violated a code review rule: [mrule_OR1S8PRRHcvbdFib](https://app.ellipsis.dev/RooVetGit/code-review/rules?id=mrule_OR1S8PRRHcvbdFib).</sup>",
        "pr_file_module": null
      },
      {
        "comment_id": "2093962589",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 3693,
        "pr_file": "src/integrations/terminal/ExecaTerminalProcess.ts",
        "discussion_id": "2093922018",
        "commented_code": "@@ -70,7 +70,7 @@ export class ExecaTerminalProcess extends BaseTerminalProcess {\n \t\t\t\t\ttimeoutId = setTimeout(() => {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tsubprocess.kill(\"SIGKILL\")\n-\t\t\t\t\t\t} catch (e) {}\n+\t\t\t\t\t\t} catch {}",
        "comment_created_at": "2025-05-17T05:56:52+00:00",
        "comment_author": "KJ7LNW",
        "comment_body": "maybe we need a lint for this?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2099080507",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 3693,
        "pr_file": "src/integrations/terminal/ExecaTerminalProcess.ts",
        "discussion_id": "2093922018",
        "commented_code": "@@ -70,7 +70,7 @@ export class ExecaTerminalProcess extends BaseTerminalProcess {\n \t\t\t\t\ttimeoutId = setTimeout(() => {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tsubprocess.kill(\"SIGKILL\")\n-\t\t\t\t\t\t} catch (e) {}\n+\t\t\t\t\t\t} catch {}",
        "comment_created_at": "2025-05-21T00:33:19+00:00",
        "comment_author": "KJ7LNW",
        "comment_body": "fixed via no-empty",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172827569",
    "pr_number": 5185,
    "pr_file": "src/core/tools/useMcpToolTool.ts",
    "created_at": "2025-06-27T20:25:13+00:00",
    "commented_code": "})\n }\n \n-function processToolContent(toolResult: any): string {\n+function processToolContent(toolResult: any): { text: string; images: string[] } {\n \tif (!toolResult?.content || toolResult.content.length === 0) {\n-\t\treturn \"\"\n+\t\treturn { text: \"\", images: [] }\n \t}\n \n-\treturn toolResult.content\n-\t\t.map((item: any) => {\n-\t\t\tif (item.type === \"text\") {\n-\t\t\t\treturn item.text\n+\tconst textParts: string[] = []\n+\tconst images: string[] = []\n+\n+\ttoolResult.content.forEach((item: any) => {\n+\t\tif (item.type === \"text\") {\n+\t\t\ttextParts.push(item.text)\n+\t\t} else if (item.type === \"image\") {\n+\t\t\tif (item.data && item.mimeType) {\n+\t\t\t\tconst validImageTypes = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\"]\n+\t\t\t\tif (validImageTypes.includes(item.mimeType)) {\n+\t\t\t\t\tconst dataUrl = `data:${item.mimeType};base64,${item.data}`\n+\t\t\t\t\timages.push(dataUrl)",
    "repo_full_name": "RooCodeInc/Roo-Code",
    "discussion_comments": [
      {
        "comment_id": "2172827569",
        "repo_full_name": "RooCodeInc/Roo-Code",
        "pr_number": 5185,
        "pr_file": "src/core/tools/useMcpToolTool.ts",
        "discussion_id": "2172827569",
        "commented_code": "@@ -89,24 +89,39 @@ async function sendExecutionStatus(cline: Task, status: McpExecutionStatus): Pro\n \t})\n }\n \n-function processToolContent(toolResult: any): string {\n+function processToolContent(toolResult: any): { text: string; images: string[] } {\n \tif (!toolResult?.content || toolResult.content.length === 0) {\n-\t\treturn \"\"\n+\t\treturn { text: \"\", images: [] }\n \t}\n \n-\treturn toolResult.content\n-\t\t.map((item: any) => {\n-\t\t\tif (item.type === \"text\") {\n-\t\t\t\treturn item.text\n+\tconst textParts: string[] = []\n+\tconst images: string[] = []\n+\n+\ttoolResult.content.forEach((item: any) => {\n+\t\tif (item.type === \"text\") {\n+\t\t\ttextParts.push(item.text)\n+\t\t} else if (item.type === \"image\") {\n+\t\t\tif (item.data && item.mimeType) {\n+\t\t\t\tconst validImageTypes = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\"]\n+\t\t\t\tif (validImageTypes.includes(item.mimeType)) {\n+\t\t\t\t\tconst dataUrl = `data:${item.mimeType};base64,${item.data}`\n+\t\t\t\t\timages.push(dataUrl)",
        "comment_created_at": "2025-06-27T20:25:13+00:00",
        "comment_author": "daniel-lxs",
        "comment_body": "What happens if the base64 data is corrupted or invalid? Would it be worth wrapping this in a try-catch to handle potential errors when constructing the data URL? This could prevent the entire tool response from failing due to a single corrupted image.",
        "pr_file_module": null
      }
    ]
  }
]