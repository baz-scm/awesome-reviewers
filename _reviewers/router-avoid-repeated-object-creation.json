[
  {
    "discussion_id": "2240980126",
    "pr_number": 4830,
    "pr_file": "packages/router-core/src/router.ts",
    "created_at": "2025-07-29T20:43:55+00:00",
    "commented_code": "}\n \n     try {\n-      await new Promise<void>((resolveAll, rejectAll) => {\n-        ;(async () => {\n-          try {\n-            const handleSerialError = (\n-              index: number,\n-              err: any,\n-              routerCode: string,\n-            ) => {\n-              const { id: matchId, routeId } = matches[index]!\n-              const route = this.looseRoutesById[routeId]!\n-\n-              // Much like suspense, we use a promise here to know if\n-              // we've been outdated by a new loadMatches call and\n-              // should abort the current async operation\n-              if (err instanceof Promise) {\n-                throw err\n-              }\n-\n-              err.routerCode = routerCode\n-              firstBadMatchIndex = firstBadMatchIndex ?? index\n-              handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n-\n-              try {\n-                route.options.onError?.(err)\n-              } catch (errorHandlerErr) {\n-                err = errorHandlerErr\n-                handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n-              }\n+      const handleSerialError = (\n+        index: number,\n+        err: any,\n+        routerCode: string,\n+      ) => {\n+        const { id: matchId, routeId } = matches[index]!\n+        const route = this.looseRoutesById[routeId]!\n+\n+        // Much like suspense, we use a promise here to know if\n+        // we've been outdated by a new loadMatches call and\n+        // should abort the current async operation\n+        if (err instanceof Promise) {\n+          throw err\n+        }\n \n-              updateMatch(matchId, (prev) => {\n-                prev.beforeLoadPromise?.resolve()\n-                prev.loadPromise?.resolve()\n+        err.routerCode = routerCode\n+        firstBadMatchIndex = firstBadMatchIndex ?? index\n+        handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n \n-                return {\n-                  ...prev,\n-                  error: err,\n-                  status: 'error',\n-                  isFetching: false,\n-                  updatedAt: Date.now(),\n-                  abortController: new AbortController(),\n-                  beforeLoadPromise: undefined,\n-                }\n-              })\n-            }\n+        try {\n+          route.options.onError?.(err)\n+        } catch (errorHandlerErr) {\n+          err = errorHandlerErr\n+          handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n+        }\n \n-            for (const [index, { id: matchId, routeId }] of matches.entries()) {\n-              const existingMatch = this.getMatch(matchId)!\n-              const parentMatchId = matches[index - 1]?.id\n-              const parentMatch = parentMatchId\n-                ? this.getMatch(parentMatchId)!\n-                : undefined\n+        updateMatch(matchId, (prev) => {\n+          prev.beforeLoadPromise?.resolve()\n+          prev.loadPromise?.resolve()\n+\n+          return {\n+            ...prev,\n+            error: err,\n+            status: 'error',\n+            isFetching: false,\n+            updatedAt: Date.now(),\n+            abortController: new AbortController(),\n+            beforeLoadPromise: undefined,\n+          }\n+        })\n+      }\n \n-              const route = this.looseRoutesById[routeId]!\n+      for (const [index, { id: matchId, routeId }] of matches.entries()) {\n+        const existingMatch = this.getMatch(matchId)!\n+        const parentMatchId = matches[index - 1]?.id\n+        const parentMatch = parentMatchId\n+          ? this.getMatch(parentMatchId)!\n+          : undefined\n \n-              const pendingMs =\n-                route.options.pendingMs ?? this.options.defaultPendingMs\n+        const route = this.looseRoutesById[routeId]!\n \n-              // on the server, determine whether SSR the current match or not\n-              if (this.isServer) {\n-                let ssr: boolean | 'data-only'\n-                // in SPA mode, only SSR the root route\n-                if (this.isShell()) {\n-                  ssr = matchId === rootRouteId\n-                } else {\n-                  const defaultSsr = this.options.defaultSsr ?? true\n-                  if (parentMatch?.ssr === false) {\n-                    ssr = false\n-                  } else {\n-                    let tempSsr: boolean | 'data-only'\n-                    if (route.options.ssr === undefined) {\n-                      tempSsr = defaultSsr\n-                    } else if (typeof route.options.ssr === 'function') {\n-                      const { search, params } = this.getMatch(matchId)!\n-\n-                      function makeMaybe(value: any, error: any) {\n-                        if (error) {\n-                          return { status: 'error' as const, error }\n-                        }\n-                        return { status: 'success' as const, value }\n-                      }\n-\n-                      const ssrFnContext: SsrContextOptions<any, any, any> = {\n-                        search: makeMaybe(search, existingMatch.searchError),\n-                        params: makeMaybe(params, existingMatch.paramsError),\n-                        location,\n-                        matches: matches.map((match) => ({\n-                          index: match.index,\n-                          pathname: match.pathname,\n-                          fullPath: match.fullPath,\n-                          staticData: match.staticData,\n-                          id: match.id,\n-                          routeId: match.routeId,\n-                          search: makeMaybe(match.search, match.searchError),\n-                          params: makeMaybe(match.params, match.paramsError),\n-                          ssr: match.ssr,\n-                        })),\n-                      }\n-                      tempSsr =\n-                        (await route.options.ssr(ssrFnContext)) ?? defaultSsr\n-                    } else {\n-                      tempSsr = route.options.ssr\n-                    }\n+        const pendingMs =\n+          route.options.pendingMs ?? this.options.defaultPendingMs\n \n-                    if (tempSsr === true && parentMatch?.ssr === 'data-only') {\n-                      ssr = 'data-only'\n-                    } else {\n-                      ssr = tempSsr\n-                    }\n+        // on the server, determine whether SSR the current match or not\n+        if (this.isServer) {\n+          let ssr: boolean | 'data-only'\n+          // in SPA mode, only SSR the root route\n+          if (this.isShell()) {\n+            ssr = matchId === rootRouteId\n+          } else {\n+            const defaultSsr = this.options.defaultSsr ?? true\n+            if (parentMatch?.ssr === false) {\n+              ssr = false\n+            } else {\n+              let tempSsr: boolean | 'data-only'\n+              if (route.options.ssr === undefined) {\n+                tempSsr = defaultSsr\n+              } else if (typeof route.options.ssr === 'function') {\n+                const { search, params } = this.getMatch(matchId)!\n+\n+                function makeMaybe(value: any, error: any) {",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2240980126",
        "repo_full_name": "TanStack/router",
        "pr_number": 4830,
        "pr_file": "packages/router-core/src/router.ts",
        "discussion_id": "2240980126",
        "commented_code": "@@ -2179,588 +2179,567 @@ export class RouterCore<\n     }\n \n     try {\n-      await new Promise<void>((resolveAll, rejectAll) => {\n-        ;(async () => {\n-          try {\n-            const handleSerialError = (\n-              index: number,\n-              err: any,\n-              routerCode: string,\n-            ) => {\n-              const { id: matchId, routeId } = matches[index]!\n-              const route = this.looseRoutesById[routeId]!\n-\n-              // Much like suspense, we use a promise here to know if\n-              // we've been outdated by a new loadMatches call and\n-              // should abort the current async operation\n-              if (err instanceof Promise) {\n-                throw err\n-              }\n-\n-              err.routerCode = routerCode\n-              firstBadMatchIndex = firstBadMatchIndex ?? index\n-              handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n-\n-              try {\n-                route.options.onError?.(err)\n-              } catch (errorHandlerErr) {\n-                err = errorHandlerErr\n-                handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n-              }\n+      const handleSerialError = (\n+        index: number,\n+        err: any,\n+        routerCode: string,\n+      ) => {\n+        const { id: matchId, routeId } = matches[index]!\n+        const route = this.looseRoutesById[routeId]!\n+\n+        // Much like suspense, we use a promise here to know if\n+        // we've been outdated by a new loadMatches call and\n+        // should abort the current async operation\n+        if (err instanceof Promise) {\n+          throw err\n+        }\n \n-              updateMatch(matchId, (prev) => {\n-                prev.beforeLoadPromise?.resolve()\n-                prev.loadPromise?.resolve()\n+        err.routerCode = routerCode\n+        firstBadMatchIndex = firstBadMatchIndex ?? index\n+        handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n \n-                return {\n-                  ...prev,\n-                  error: err,\n-                  status: 'error',\n-                  isFetching: false,\n-                  updatedAt: Date.now(),\n-                  abortController: new AbortController(),\n-                  beforeLoadPromise: undefined,\n-                }\n-              })\n-            }\n+        try {\n+          route.options.onError?.(err)\n+        } catch (errorHandlerErr) {\n+          err = errorHandlerErr\n+          handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n+        }\n \n-            for (const [index, { id: matchId, routeId }] of matches.entries()) {\n-              const existingMatch = this.getMatch(matchId)!\n-              const parentMatchId = matches[index - 1]?.id\n-              const parentMatch = parentMatchId\n-                ? this.getMatch(parentMatchId)!\n-                : undefined\n+        updateMatch(matchId, (prev) => {\n+          prev.beforeLoadPromise?.resolve()\n+          prev.loadPromise?.resolve()\n+\n+          return {\n+            ...prev,\n+            error: err,\n+            status: 'error',\n+            isFetching: false,\n+            updatedAt: Date.now(),\n+            abortController: new AbortController(),\n+            beforeLoadPromise: undefined,\n+          }\n+        })\n+      }\n \n-              const route = this.looseRoutesById[routeId]!\n+      for (const [index, { id: matchId, routeId }] of matches.entries()) {\n+        const existingMatch = this.getMatch(matchId)!\n+        const parentMatchId = matches[index - 1]?.id\n+        const parentMatch = parentMatchId\n+          ? this.getMatch(parentMatchId)!\n+          : undefined\n \n-              const pendingMs =\n-                route.options.pendingMs ?? this.options.defaultPendingMs\n+        const route = this.looseRoutesById[routeId]!\n \n-              // on the server, determine whether SSR the current match or not\n-              if (this.isServer) {\n-                let ssr: boolean | 'data-only'\n-                // in SPA mode, only SSR the root route\n-                if (this.isShell()) {\n-                  ssr = matchId === rootRouteId\n-                } else {\n-                  const defaultSsr = this.options.defaultSsr ?? true\n-                  if (parentMatch?.ssr === false) {\n-                    ssr = false\n-                  } else {\n-                    let tempSsr: boolean | 'data-only'\n-                    if (route.options.ssr === undefined) {\n-                      tempSsr = defaultSsr\n-                    } else if (typeof route.options.ssr === 'function') {\n-                      const { search, params } = this.getMatch(matchId)!\n-\n-                      function makeMaybe(value: any, error: any) {\n-                        if (error) {\n-                          return { status: 'error' as const, error }\n-                        }\n-                        return { status: 'success' as const, value }\n-                      }\n-\n-                      const ssrFnContext: SsrContextOptions<any, any, any> = {\n-                        search: makeMaybe(search, existingMatch.searchError),\n-                        params: makeMaybe(params, existingMatch.paramsError),\n-                        location,\n-                        matches: matches.map((match) => ({\n-                          index: match.index,\n-                          pathname: match.pathname,\n-                          fullPath: match.fullPath,\n-                          staticData: match.staticData,\n-                          id: match.id,\n-                          routeId: match.routeId,\n-                          search: makeMaybe(match.search, match.searchError),\n-                          params: makeMaybe(match.params, match.paramsError),\n-                          ssr: match.ssr,\n-                        })),\n-                      }\n-                      tempSsr =\n-                        (await route.options.ssr(ssrFnContext)) ?? defaultSsr\n-                    } else {\n-                      tempSsr = route.options.ssr\n-                    }\n+        const pendingMs =\n+          route.options.pendingMs ?? this.options.defaultPendingMs\n \n-                    if (tempSsr === true && parentMatch?.ssr === 'data-only') {\n-                      ssr = 'data-only'\n-                    } else {\n-                      ssr = tempSsr\n-                    }\n+        // on the server, determine whether SSR the current match or not\n+        if (this.isServer) {\n+          let ssr: boolean | 'data-only'\n+          // in SPA mode, only SSR the root route\n+          if (this.isShell()) {\n+            ssr = matchId === rootRouteId\n+          } else {\n+            const defaultSsr = this.options.defaultSsr ?? true\n+            if (parentMatch?.ssr === false) {\n+              ssr = false\n+            } else {\n+              let tempSsr: boolean | 'data-only'\n+              if (route.options.ssr === undefined) {\n+                tempSsr = defaultSsr\n+              } else if (typeof route.options.ssr === 'function') {\n+                const { search, params } = this.getMatch(matchId)!\n+\n+                function makeMaybe(value: any, error: any) {",
        "comment_created_at": "2025-07-29T20:43:55+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Would the definition of `makeMaybe` outside of the for loop have any performance gains? (still being left within the scope of `loadMatches` though)",
        "pr_file_module": null
      },
      {
        "comment_id": "2240990509",
        "repo_full_name": "TanStack/router",
        "pr_number": 4830,
        "pr_file": "packages/router-core/src/router.ts",
        "discussion_id": "2240980126",
        "commented_code": "@@ -2179,588 +2179,567 @@ export class RouterCore<\n     }\n \n     try {\n-      await new Promise<void>((resolveAll, rejectAll) => {\n-        ;(async () => {\n-          try {\n-            const handleSerialError = (\n-              index: number,\n-              err: any,\n-              routerCode: string,\n-            ) => {\n-              const { id: matchId, routeId } = matches[index]!\n-              const route = this.looseRoutesById[routeId]!\n-\n-              // Much like suspense, we use a promise here to know if\n-              // we've been outdated by a new loadMatches call and\n-              // should abort the current async operation\n-              if (err instanceof Promise) {\n-                throw err\n-              }\n-\n-              err.routerCode = routerCode\n-              firstBadMatchIndex = firstBadMatchIndex ?? index\n-              handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n-\n-              try {\n-                route.options.onError?.(err)\n-              } catch (errorHandlerErr) {\n-                err = errorHandlerErr\n-                handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n-              }\n+      const handleSerialError = (\n+        index: number,\n+        err: any,\n+        routerCode: string,\n+      ) => {\n+        const { id: matchId, routeId } = matches[index]!\n+        const route = this.looseRoutesById[routeId]!\n+\n+        // Much like suspense, we use a promise here to know if\n+        // we've been outdated by a new loadMatches call and\n+        // should abort the current async operation\n+        if (err instanceof Promise) {\n+          throw err\n+        }\n \n-              updateMatch(matchId, (prev) => {\n-                prev.beforeLoadPromise?.resolve()\n-                prev.loadPromise?.resolve()\n+        err.routerCode = routerCode\n+        firstBadMatchIndex = firstBadMatchIndex ?? index\n+        handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n \n-                return {\n-                  ...prev,\n-                  error: err,\n-                  status: 'error',\n-                  isFetching: false,\n-                  updatedAt: Date.now(),\n-                  abortController: new AbortController(),\n-                  beforeLoadPromise: undefined,\n-                }\n-              })\n-            }\n+        try {\n+          route.options.onError?.(err)\n+        } catch (errorHandlerErr) {\n+          err = errorHandlerErr\n+          handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n+        }\n \n-            for (const [index, { id: matchId, routeId }] of matches.entries()) {\n-              const existingMatch = this.getMatch(matchId)!\n-              const parentMatchId = matches[index - 1]?.id\n-              const parentMatch = parentMatchId\n-                ? this.getMatch(parentMatchId)!\n-                : undefined\n+        updateMatch(matchId, (prev) => {\n+          prev.beforeLoadPromise?.resolve()\n+          prev.loadPromise?.resolve()\n+\n+          return {\n+            ...prev,\n+            error: err,\n+            status: 'error',\n+            isFetching: false,\n+            updatedAt: Date.now(),\n+            abortController: new AbortController(),\n+            beforeLoadPromise: undefined,\n+          }\n+        })\n+      }\n \n-              const route = this.looseRoutesById[routeId]!\n+      for (const [index, { id: matchId, routeId }] of matches.entries()) {\n+        const existingMatch = this.getMatch(matchId)!\n+        const parentMatchId = matches[index - 1]?.id\n+        const parentMatch = parentMatchId\n+          ? this.getMatch(parentMatchId)!\n+          : undefined\n \n-              const pendingMs =\n-                route.options.pendingMs ?? this.options.defaultPendingMs\n+        const route = this.looseRoutesById[routeId]!\n \n-              // on the server, determine whether SSR the current match or not\n-              if (this.isServer) {\n-                let ssr: boolean | 'data-only'\n-                // in SPA mode, only SSR the root route\n-                if (this.isShell()) {\n-                  ssr = matchId === rootRouteId\n-                } else {\n-                  const defaultSsr = this.options.defaultSsr ?? true\n-                  if (parentMatch?.ssr === false) {\n-                    ssr = false\n-                  } else {\n-                    let tempSsr: boolean | 'data-only'\n-                    if (route.options.ssr === undefined) {\n-                      tempSsr = defaultSsr\n-                    } else if (typeof route.options.ssr === 'function') {\n-                      const { search, params } = this.getMatch(matchId)!\n-\n-                      function makeMaybe(value: any, error: any) {\n-                        if (error) {\n-                          return { status: 'error' as const, error }\n-                        }\n-                        return { status: 'success' as const, value }\n-                      }\n-\n-                      const ssrFnContext: SsrContextOptions<any, any, any> = {\n-                        search: makeMaybe(search, existingMatch.searchError),\n-                        params: makeMaybe(params, existingMatch.paramsError),\n-                        location,\n-                        matches: matches.map((match) => ({\n-                          index: match.index,\n-                          pathname: match.pathname,\n-                          fullPath: match.fullPath,\n-                          staticData: match.staticData,\n-                          id: match.id,\n-                          routeId: match.routeId,\n-                          search: makeMaybe(match.search, match.searchError),\n-                          params: makeMaybe(match.params, match.paramsError),\n-                          ssr: match.ssr,\n-                        })),\n-                      }\n-                      tempSsr =\n-                        (await route.options.ssr(ssrFnContext)) ?? defaultSsr\n-                    } else {\n-                      tempSsr = route.options.ssr\n-                    }\n+        const pendingMs =\n+          route.options.pendingMs ?? this.options.defaultPendingMs\n \n-                    if (tempSsr === true && parentMatch?.ssr === 'data-only') {\n-                      ssr = 'data-only'\n-                    } else {\n-                      ssr = tempSsr\n-                    }\n+        // on the server, determine whether SSR the current match or not\n+        if (this.isServer) {\n+          let ssr: boolean | 'data-only'\n+          // in SPA mode, only SSR the root route\n+          if (this.isShell()) {\n+            ssr = matchId === rootRouteId\n+          } else {\n+            const defaultSsr = this.options.defaultSsr ?? true\n+            if (parentMatch?.ssr === false) {\n+              ssr = false\n+            } else {\n+              let tempSsr: boolean | 'data-only'\n+              if (route.options.ssr === undefined) {\n+                tempSsr = defaultSsr\n+              } else if (typeof route.options.ssr === 'function') {\n+                const { search, params } = this.getMatch(matchId)!\n+\n+                function makeMaybe(value: any, error: any) {",
        "comment_created_at": "2025-07-29T20:49:45+00:00",
        "comment_author": "Sheraff",
        "comment_body": "Hoisting that function should bring perf improvements indeed. More generally `loadMatches` should probably be split up into smaller functions. I'm making small \"almost nothing changes\" PRs right now, but I'll be attempting an actual perf PR just after.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1525343717",
    "pr_number": 1310,
    "pr_file": "packages/router-generator/src/generator.ts",
    "created_at": "2024-03-14T18:40:59+00:00",
    "commented_code": "return d.name.startsWith(routeFilePrefix)\n       }\n \n+      if (routeFileIgnoreType) {\n+        return !d.name.match(new RegExp(routeFileIgnoreType, 'g'))",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1525343717",
        "repo_full_name": "TanStack/router",
        "pr_number": 1310,
        "pr_file": "packages/router-generator/src/generator.ts",
        "discussion_id": "1525343717",
        "commented_code": "@@ -55,6 +55,10 @@ async function getRouteNodes(config: Config) {\n         return d.name.startsWith(routeFilePrefix)\n       }\n \n+      if (routeFileIgnoreType) {\n+        return !d.name.match(new RegExp(routeFileIgnoreType, 'g'))",
        "comment_created_at": "2024-03-14T18:40:59+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "create the regex only once",
        "pr_file_module": null
      },
      {
        "comment_id": "1525582605",
        "repo_full_name": "TanStack/router",
        "pr_number": 1310,
        "pr_file": "packages/router-generator/src/generator.ts",
        "discussion_id": "1525343717",
        "commented_code": "@@ -55,6 +55,10 @@ async function getRouteNodes(config: Config) {\n         return d.name.startsWith(routeFilePrefix)\n       }\n \n+      if (routeFileIgnoreType) {\n+        return !d.name.match(new RegExp(routeFileIgnoreType, 'g'))",
        "comment_created_at": "2024-03-14T23:02:01+00:00",
        "comment_author": "goldfrosch",
        "comment_body": "https://github.com/TanStack/router/pull/1310/commits/c4e21de9620695d1f3329f773de3be499de36b5c\r\nthanks!",
        "pr_file_module": null
      }
    ]
  }
]