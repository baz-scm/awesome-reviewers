[
  {
    "discussion_id": "2061488720",
    "pr_number": 3967,
    "pr_file": "docs/router/framework/react/api/router/useHistoryStateHook.md",
    "created_at": "2025-04-26T16:50:04+00:00",
    "commented_code": "+---\n+id: useHistoryStateHook\n+title: useHistoryState hook\n+---\n+\n+The `useHistoryState` method returns the state object that was passed during navigation to the closest match or a specific route match.\n+\n+## useHistoryState options\n+\n+The `useHistoryState` hook accepts an optional `options` object.\n+\n+### `opts.from` option\n+\n+- Type: `string`\n+- Optional\n+- The route ID to get state from. If not provided, the state from the closest match will be used.\n+\n+### `opts.strict` option\n+\n+- Type: `boolean`\n+- Optional - `default: true`\n+- If `true`, the state object type will be strictly typed based on the route's `stateSchema`.",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2061488720",
        "repo_full_name": "TanStack/router",
        "pr_number": 3967,
        "pr_file": "docs/router/framework/react/api/router/useHistoryStateHook.md",
        "discussion_id": "2061488720",
        "commented_code": "@@ -0,0 +1,148 @@\n+---\n+id: useHistoryStateHook\n+title: useHistoryState hook\n+---\n+\n+The `useHistoryState` method returns the state object that was passed during navigation to the closest match or a specific route match.\n+\n+## useHistoryState options\n+\n+The `useHistoryState` hook accepts an optional `options` object.\n+\n+### `opts.from` option\n+\n+- Type: `string`\n+- Optional\n+- The route ID to get state from. If not provided, the state from the closest match will be used.\n+\n+### `opts.strict` option\n+\n+- Type: `boolean`\n+- Optional - `default: true`\n+- If `true`, the state object type will be strictly typed based on the route's `stateSchema`.",
        "comment_created_at": "2025-04-26T16:50:04+00:00",
        "comment_author": "AhmedBaset",
        "comment_body": "```suggestion\r\n- If `true`, the state object type will be strictly typed based on the route's `validateState`.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217494601",
    "pr_number": 4717,
    "pr_file": "docs/router/framework/react/guide/automatic-code-splitting.md",
    "created_at": "2025-07-19T22:49:18+00:00",
    "commented_code": "title: Automatic Code Splitting\n ---\n \n-> [!TIP]\n-> We'll be filling in this guide soon about the wonderful world of automatic code splitting with TanStack Router and the many customization options available to you. Stay tuned!\n+Automatic code splitting is the most powerful and recommended method for optimizing your application's bundle size when using TanStack Router with a supported bundler. It gives you fine-grained, declarative control over how and what parts of your route definitions are lazy-loaded.\n \n-<!-- Include the basic configuration details and the code splitting groupings available which were introduced in https://github.com/TanStack/router/pull/3355-->\n+## How it Works: Under the Hood\n+\n+The magic behind automatic code splitting is a build-time code transformation process handled by the router plugin. It analyzes your route files and rewrites them into an optimized format. This happens in two phases:\n+\n+1.  **Reference File Transformation**: The plugin takes your original route file (e.g., `posts.route.tsx`) and replaces properties like `component` or `loader` with special lazy-loading wrappers (`lazyRouteComponent` or `lazyFn`). These wrappers point to a \"virtual\" file that the bundler will request later.\n+2.  **Virtual File Generation**: When the bundler sees a request for one of these virtual files (e.g., `posts.route.tsx?tsr-split=component`), the plugin intercepts it. It then generates a new, minimal file on-the-fly that contains *only* the code for the requested property (e.g., just the `PostsComponent`).\n+\n+This process ensures that your original code remains clean and readable, while the final bundled output is highly optimized for performance.\n+\n+## Configuration Deep Dive\n+\n+While `autoCodeSplitting: true` works out of the box, you can customize its behavior in your bundler plugin's configuration.\n+\n+### Understanding `CodeSplitGroupings`\n+\n+The core of customization is the concept of \"split groupings\". A split grouping is an array of property names that you want to bundle together into a single lazy-loaded chunk. The configuration is an array of these groups.\n+\n+The available properties to split are:\n+- `component`\n+- `errorComponent`\n+- `pendingComponent`\n+- `notFoundComponent`\n+- `loader`\n+\n+### Default Behavior\n+\n+By default, the plugin uses the following groupings:\n+`[['component'], ['errorComponent'], ['notFoundComponent']]`\n+\n+This means it creates up to three separate lazy-loaded chunks for each route: one for the main component, one for the error component, and one for the not-found component.\n+\n+### Customizing Global Behavior (`defaultBehavior`)\n+\n+You can change the default for all routes using the `defaultBehavior` option. For example, to bundle all UI-related components into a single chunk, you could configure it like this:\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    defaultBehavior: [\n+      ['component', 'pendingComponent', 'errorComponent', 'notFoundComponent'],\n+    ],\n+  },\n+})\n+```\n+Now, `component`, `pendingComponent`, `errorComponent`, and `notFoundComponent` will all be included in the same network request, reducing request overhead if they are often used together.\n+\n+### Splitting the Data Loader\n+\n+> [!IMPORTANT]\n+> **Be warned!!!** Splitting a route loader is a dangerous game.\n+> Splitting the `loader` introduces an additional asynchronous step before data fetching can even begin, which can negatively impact performance. The `loader` is often a critical asset for preloading data. We recommend keeping it in the initial bundle.\n+\n+However, if your loader contains significant logic or large dependencies and you've decided to split it, you can add it to your split groupings:\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    defaultBehavior: [\n+      ['loader'], // The loader will be in its own chunk\n+      ['component'],\n+      // ... other component groupings\n+    ],\n+  },\n+})\n+```\n+\n+### Per-Route Overrides (`codeSplitGroupings`)\n+\n+For ultimate control, you can override the global configuration directly inside a route file by adding a `codeSplitGroupings` property. This is useful for routes that have unique optimization needs.\n+\n+```tsx\n+// src/routes/admin.route.tsx\n+import { createFileRoute } from '@tanstack/react-router'\n+\n+export const Route = createFileRoute('/admin')({\n+  // For this specific route, bundle the loader and component together.\n+  codeSplitGroupings: [['loader', 'component']],\n+  loader: () => import('./-heavy-admin-utils').then(d => d.loadAdminData()),\n+  component: AdminComponent,\n+})\n+\n+function AdminComponent() {\n+  // ...\n+}\n+```\n+\n+### Advanced Programmatic Control (`splitBehavior`)\n+\n+For complex rulesets, you can use the `splitBehavior` function in your config. This function receives the `routeId` and can programmatically return the desired split groupings.\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    splitBehavior: ({ routeId }) => {\n+      // For all routes under /admin, bundle the loader and component together\n+      if (routeId.startsWith('/admin')) {\n+        return [['loader', 'component']]\n+      }\n+      // All other routes will use the `defaultBehavior`\n+    },\n+  },\n+})\n+```\n+\n+### Optimizing for Production (`deleteNodes`)\n+\n+In some cases, you may want to completely remove certain properties from a build. A common use case is removing server-side rendering (`ssr`) logic from the client bundle. The `deleteNodes` option allows you to do this.\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    // This will remove the `ssr` property from all route definitions\n+    // during the build process, reducing the client bundle size.\n+    deleteNodes: ['ssr'],\n+  },\n+})\n+```\n+This is a powerful optimization for isomorphic applications.",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217494601",
        "repo_full_name": "TanStack/router",
        "pr_number": 4717,
        "pr_file": "docs/router/framework/react/guide/automatic-code-splitting.md",
        "discussion_id": "2217494601",
        "commented_code": "@@ -2,7 +2,131 @@\n title: Automatic Code Splitting\n ---\n \n-> [!TIP]\n-> We'll be filling in this guide soon about the wonderful world of automatic code splitting with TanStack Router and the many customization options available to you. Stay tuned!\n+Automatic code splitting is the most powerful and recommended method for optimizing your application's bundle size when using TanStack Router with a supported bundler. It gives you fine-grained, declarative control over how and what parts of your route definitions are lazy-loaded.\n \n-<!-- Include the basic configuration details and the code splitting groupings available which were introduced in https://github.com/TanStack/router/pull/3355-->\n+## How it Works: Under the Hood\n+\n+The magic behind automatic code splitting is a build-time code transformation process handled by the router plugin. It analyzes your route files and rewrites them into an optimized format. This happens in two phases:\n+\n+1.  **Reference File Transformation**: The plugin takes your original route file (e.g., `posts.route.tsx`) and replaces properties like `component` or `loader` with special lazy-loading wrappers (`lazyRouteComponent` or `lazyFn`). These wrappers point to a \"virtual\" file that the bundler will request later.\n+2.  **Virtual File Generation**: When the bundler sees a request for one of these virtual files (e.g., `posts.route.tsx?tsr-split=component`), the plugin intercepts it. It then generates a new, minimal file on-the-fly that contains *only* the code for the requested property (e.g., just the `PostsComponent`).\n+\n+This process ensures that your original code remains clean and readable, while the final bundled output is highly optimized for performance.\n+\n+## Configuration Deep Dive\n+\n+While `autoCodeSplitting: true` works out of the box, you can customize its behavior in your bundler plugin's configuration.\n+\n+### Understanding `CodeSplitGroupings`\n+\n+The core of customization is the concept of \"split groupings\". A split grouping is an array of property names that you want to bundle together into a single lazy-loaded chunk. The configuration is an array of these groups.\n+\n+The available properties to split are:\n+- `component`\n+- `errorComponent`\n+- `pendingComponent`\n+- `notFoundComponent`\n+- `loader`\n+\n+### Default Behavior\n+\n+By default, the plugin uses the following groupings:\n+`[['component'], ['errorComponent'], ['notFoundComponent']]`\n+\n+This means it creates up to three separate lazy-loaded chunks for each route: one for the main component, one for the error component, and one for the not-found component.\n+\n+### Customizing Global Behavior (`defaultBehavior`)\n+\n+You can change the default for all routes using the `defaultBehavior` option. For example, to bundle all UI-related components into a single chunk, you could configure it like this:\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    defaultBehavior: [\n+      ['component', 'pendingComponent', 'errorComponent', 'notFoundComponent'],\n+    ],\n+  },\n+})\n+```\n+Now, `component`, `pendingComponent`, `errorComponent`, and `notFoundComponent` will all be included in the same network request, reducing request overhead if they are often used together.\n+\n+### Splitting the Data Loader\n+\n+> [!IMPORTANT]\n+> **Be warned!!!** Splitting a route loader is a dangerous game.\n+> Splitting the `loader` introduces an additional asynchronous step before data fetching can even begin, which can negatively impact performance. The `loader` is often a critical asset for preloading data. We recommend keeping it in the initial bundle.\n+\n+However, if your loader contains significant logic or large dependencies and you've decided to split it, you can add it to your split groupings:\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    defaultBehavior: [\n+      ['loader'], // The loader will be in its own chunk\n+      ['component'],\n+      // ... other component groupings\n+    ],\n+  },\n+})\n+```\n+\n+### Per-Route Overrides (`codeSplitGroupings`)\n+\n+For ultimate control, you can override the global configuration directly inside a route file by adding a `codeSplitGroupings` property. This is useful for routes that have unique optimization needs.\n+\n+```tsx\n+// src/routes/admin.route.tsx\n+import { createFileRoute } from '@tanstack/react-router'\n+\n+export const Route = createFileRoute('/admin')({\n+  // For this specific route, bundle the loader and component together.\n+  codeSplitGroupings: [['loader', 'component']],\n+  loader: () => import('./-heavy-admin-utils').then(d => d.loadAdminData()),\n+  component: AdminComponent,\n+})\n+\n+function AdminComponent() {\n+  // ...\n+}\n+```\n+\n+### Advanced Programmatic Control (`splitBehavior`)\n+\n+For complex rulesets, you can use the `splitBehavior` function in your config. This function receives the `routeId` and can programmatically return the desired split groupings.\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    splitBehavior: ({ routeId }) => {\n+      // For all routes under /admin, bundle the loader and component together\n+      if (routeId.startsWith('/admin')) {\n+        return [['loader', 'component']]\n+      }\n+      // All other routes will use the `defaultBehavior`\n+    },\n+  },\n+})\n+```\n+\n+### Optimizing for Production (`deleteNodes`)\n+\n+In some cases, you may want to completely remove certain properties from a build. A common use case is removing server-side rendering (`ssr`) logic from the client bundle. The `deleteNodes` option allows you to do this.\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    // This will remove the `ssr` property from all route definitions\n+    // during the build process, reducing the client bundle size.\n+    deleteNodes: ['ssr'],\n+  },\n+})\n+```\n+This is a powerful optimization for isomorphic applications.",
        "comment_created_at": "2025-07-19T22:49:18+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "please remove this section.\r\n\r\n`deleteNodes` is not a public API (yet) and thus shall not be documented",
        "pr_file_module": null
      },
      {
        "comment_id": "2217691140",
        "repo_full_name": "TanStack/router",
        "pr_number": 4717,
        "pr_file": "docs/router/framework/react/guide/automatic-code-splitting.md",
        "discussion_id": "2217494601",
        "commented_code": "@@ -2,7 +2,131 @@\n title: Automatic Code Splitting\n ---\n \n-> [!TIP]\n-> We'll be filling in this guide soon about the wonderful world of automatic code splitting with TanStack Router and the many customization options available to you. Stay tuned!\n+Automatic code splitting is the most powerful and recommended method for optimizing your application's bundle size when using TanStack Router with a supported bundler. It gives you fine-grained, declarative control over how and what parts of your route definitions are lazy-loaded.\n \n-<!-- Include the basic configuration details and the code splitting groupings available which were introduced in https://github.com/TanStack/router/pull/3355-->\n+## How it Works: Under the Hood\n+\n+The magic behind automatic code splitting is a build-time code transformation process handled by the router plugin. It analyzes your route files and rewrites them into an optimized format. This happens in two phases:\n+\n+1.  **Reference File Transformation**: The plugin takes your original route file (e.g., `posts.route.tsx`) and replaces properties like `component` or `loader` with special lazy-loading wrappers (`lazyRouteComponent` or `lazyFn`). These wrappers point to a \"virtual\" file that the bundler will request later.\n+2.  **Virtual File Generation**: When the bundler sees a request for one of these virtual files (e.g., `posts.route.tsx?tsr-split=component`), the plugin intercepts it. It then generates a new, minimal file on-the-fly that contains *only* the code for the requested property (e.g., just the `PostsComponent`).\n+\n+This process ensures that your original code remains clean and readable, while the final bundled output is highly optimized for performance.\n+\n+## Configuration Deep Dive\n+\n+While `autoCodeSplitting: true` works out of the box, you can customize its behavior in your bundler plugin's configuration.\n+\n+### Understanding `CodeSplitGroupings`\n+\n+The core of customization is the concept of \"split groupings\". A split grouping is an array of property names that you want to bundle together into a single lazy-loaded chunk. The configuration is an array of these groups.\n+\n+The available properties to split are:\n+- `component`\n+- `errorComponent`\n+- `pendingComponent`\n+- `notFoundComponent`\n+- `loader`\n+\n+### Default Behavior\n+\n+By default, the plugin uses the following groupings:\n+`[['component'], ['errorComponent'], ['notFoundComponent']]`\n+\n+This means it creates up to three separate lazy-loaded chunks for each route: one for the main component, one for the error component, and one for the not-found component.\n+\n+### Customizing Global Behavior (`defaultBehavior`)\n+\n+You can change the default for all routes using the `defaultBehavior` option. For example, to bundle all UI-related components into a single chunk, you could configure it like this:\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    defaultBehavior: [\n+      ['component', 'pendingComponent', 'errorComponent', 'notFoundComponent'],\n+    ],\n+  },\n+})\n+```\n+Now, `component`, `pendingComponent`, `errorComponent`, and `notFoundComponent` will all be included in the same network request, reducing request overhead if they are often used together.\n+\n+### Splitting the Data Loader\n+\n+> [!IMPORTANT]\n+> **Be warned!!!** Splitting a route loader is a dangerous game.\n+> Splitting the `loader` introduces an additional asynchronous step before data fetching can even begin, which can negatively impact performance. The `loader` is often a critical asset for preloading data. We recommend keeping it in the initial bundle.\n+\n+However, if your loader contains significant logic or large dependencies and you've decided to split it, you can add it to your split groupings:\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    defaultBehavior: [\n+      ['loader'], // The loader will be in its own chunk\n+      ['component'],\n+      // ... other component groupings\n+    ],\n+  },\n+})\n+```\n+\n+### Per-Route Overrides (`codeSplitGroupings`)\n+\n+For ultimate control, you can override the global configuration directly inside a route file by adding a `codeSplitGroupings` property. This is useful for routes that have unique optimization needs.\n+\n+```tsx\n+// src/routes/admin.route.tsx\n+import { createFileRoute } from '@tanstack/react-router'\n+\n+export const Route = createFileRoute('/admin')({\n+  // For this specific route, bundle the loader and component together.\n+  codeSplitGroupings: [['loader', 'component']],\n+  loader: () => import('./-heavy-admin-utils').then(d => d.loadAdminData()),\n+  component: AdminComponent,\n+})\n+\n+function AdminComponent() {\n+  // ...\n+}\n+```\n+\n+### Advanced Programmatic Control (`splitBehavior`)\n+\n+For complex rulesets, you can use the `splitBehavior` function in your config. This function receives the `routeId` and can programmatically return the desired split groupings.\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    splitBehavior: ({ routeId }) => {\n+      // For all routes under /admin, bundle the loader and component together\n+      if (routeId.startsWith('/admin')) {\n+        return [['loader', 'component']]\n+      }\n+      // All other routes will use the `defaultBehavior`\n+    },\n+  },\n+})\n+```\n+\n+### Optimizing for Production (`deleteNodes`)\n+\n+In some cases, you may want to completely remove certain properties from a build. A common use case is removing server-side rendering (`ssr`) logic from the client bundle. The `deleteNodes` option allows you to do this.\n+\n+```ts\n+// vite.config.ts\n+tanstackRouter({\n+  autoCodeSplitting: true,\n+  codeSplittingOptions: {\n+    // This will remove the `ssr` property from all route definitions\n+    // during the build process, reducing the client bundle size.\n+    deleteNodes: ['ssr'],\n+  },\n+})\n+```\n+This is a powerful optimization for isomorphic applications.",
        "comment_created_at": "2025-07-20T08:03:19+00:00",
        "comment_author": "lukstei",
        "comment_body": "changed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2202896054",
    "pr_number": 4633,
    "pr_file": "docs/start/framework/react/static-prerendering.md",
    "created_at": "2025-07-12T19:57:07+00:00",
    "commented_code": "prerender: { enabled: true, outputPath: '/my-page/index.html' },\n         },\n       ],\n+      // Optional function to do the above globally as opposed to per-page\n+      outputPath: (path) =>",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2202896054",
        "repo_full_name": "TanStack/router",
        "pr_number": 4633,
        "pr_file": "docs/start/framework/react/static-prerendering.md",
        "discussion_id": "2202896054",
        "commented_code": "@@ -32,6 +32,9 @@ export default defineConfig({\n           prerender: { enabled: true, outputPath: '/my-page/index.html' },\n         },\n       ],\n+      // Optional function to do the above globally as opposed to per-page\n+      outputPath: (path) =>",
        "comment_created_at": "2025-07-12T19:57:07+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "rename this prop to `defaultOutputPath` to follow our usual config scheme of defaults that can be overriden",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983947398",
    "pr_number": 3678,
    "pr_file": "docs/router/api/file-based-routing.md",
    "created_at": "2025-03-06T19:35:45+00:00",
    "commented_code": "This option allows you to disable the generation of the manifest.\n \n By default, this value is set to `false`.\n+\n+### `disableGeneratedRouteTreeFormatting`\n+\n+This options turns off formatting of the generated route tree which can be time-consuming for large project.",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1983947398",
        "repo_full_name": "TanStack/router",
        "pr_number": 3678,
        "pr_file": "docs/router/api/file-based-routing.md",
        "discussion_id": "1983947398",
        "commented_code": "@@ -202,3 +203,9 @@ By default, this value is set to:\n This option allows you to disable the generation of the manifest.\n \n By default, this value is set to `false`.\n+\n+### `disableGeneratedRouteTreeFormatting`\n+\n+This options turns off formatting of the generated route tree which can be time-consuming for large project.",
        "comment_created_at": "2025-03-06T19:35:45+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "```suggestion\r\nThis option turns off the formatting function on the generated route tree file, which can be time-consuming for large projects.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1845735487",
    "pr_number": 2744,
    "pr_file": "docs/framework/react/start/hosting.md",
    "created_at": "2024-11-18T01:44:29+00:00",
    "commented_code": "### Cloudflare Pages\n \n-Set the `server.preset` value to `cloudflare-pages` in your `app.config.ts` file.\n+1. Installation\n+\n+First you will need to install `unenv`\n+\n+```sh\n+npm install -D unenv\n+```\n+\n+2. Update `app.config.ts`\n+\n+Set the `server.preset` value to `cloudflare-pages` and `server.unenv` value to `cloudflare` in your `app.config.ts` file.",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1845735487",
        "repo_full_name": "TanStack/router",
        "pr_number": 2744,
        "pr_file": "docs/framework/react/start/hosting.md",
        "discussion_id": "1845735487",
        "commented_code": "@@ -67,23 +67,39 @@ Deploy you application to Vercel using their one-click deployment process, and y\n \n ### Cloudflare Pages\n \n-Set the `server.preset` value to `cloudflare-pages` in your `app.config.ts` file.\n+1. Installation\n+\n+First you will need to install `unenv`\n+\n+```sh\n+npm install -D unenv\n+```\n+\n+2. Update `app.config.ts`\n+\n+Set the `server.preset` value to `cloudflare-pages` and `server.unenv` value to `cloudflare` in your `app.config.ts` file.",
        "comment_created_at": "2024-11-18T01:44:29+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "```suggestion\r\nSet the `server.preset` value to `cloudflare-pages` and the `server.unenv` value to the `cloudflare` from `unenv` in your `app.config.ts` file.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]