[
  {
    "discussion_id": "1921520125",
    "pr_number": 3191,
    "pr_file": "packages/react-router/src/scroll-restoration.tsx",
    "created_at": "2025-01-19T10:21:46+00:00",
    "commented_code": "}\n       }\n \n-      if (!cache.state.next[elementSelector]) {\n-        cache.set((c) => ({\n-          ...c,\n-          next: {\n-            ...c.next,\n-            [elementSelector]: {\n-              scrollX: NaN,\n-              scrollY: NaN,\n-            },\n-          },\n-        }))\n-      }\n+      const restoreKey = getKey(router.state.location)\n+\n+      cache.set((state) => {\n+        const keyEntry = (state[restoreKey] =\n+          state[restoreKey] || ({} as ScrollRestorationByElement))\n+\n+        const elementEntry = (keyEntry[elementSelector] =\n+          keyEntry[elementSelector] || ({} as ScrollRestorationEntry))\n+\n+        if (elementSelector === 'window') {\n+          elementEntry.scrollX = window.scrollX || 0\n+          elementEntry.scrollY = window.scrollY || 0\n+        } else if (elementSelector) {\n+          const element = document.querySelector(elementSelector)\n+          if (element) {\n+            elementEntry.scrollX = element.scrollLeft || 0\n+            elementEntry.scrollY = element.scrollTop || 0\n+          }\n+        }\n+\n+        return state\n+      })\n     }\n \n+    // Throttle the scroll event to avoid excessive updates\n     if (typeof document !== 'undefined') {\n       document.addEventListener('scroll', onScroll, true)\n     }\n \n-    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n-      if (event.hrefChanged) {\n-        const restoreKey = getKey(event.fromLocation)\n-        for (const elementSelector in cache.state.next) {\n-          const entry = cache.state.next[elementSelector]!\n-          if (elementSelector === windowKey) {\n-            entry.scrollX = window.scrollX || 0\n-            entry.scrollY = window.scrollY || 0\n-          } else if (elementSelector) {\n-            const element = document.querySelector(elementSelector)\n-            entry.scrollX = element?.scrollLeft || 0\n-            entry.scrollY = element?.scrollTop || 0\n-          }\n-\n-          cache.set((c) => {\n-            const next = { ...c.next }\n-            delete next[elementSelector]\n-\n-            return {\n-              ...c,\n-              next,\n-              cached: {\n-                ...c.cached,\n-                [[restoreKey, elementSelector].join(delimiter)]: entry,\n-              },\n-            }\n-          })\n-        }\n+    const unsubOnResolved = router.subscribe('onRendered', (event) => {\n+      if (!router.resetNextScroll) {\n+        return\n       }\n-    })\n \n-    const unsubOnBeforeRouteMount = router.subscribe(\n-      'onBeforeRouteMount',\n-      (event) => {\n-        if (event.hrefChanged) {\n-          if (!router.resetNextScroll) {\n-            return\n-          }\n+      router.resetNextScroll = true\n \n-          router.resetNextScroll = true\n-\n-          const restoreKey = getKey(event.toLocation)\n-          let windowRestored = false\n-\n-          for (const cacheKey in cache.state.cached) {\n-            const entry = cache.state.cached[cacheKey]!\n-            const [key, elementSelector] = cacheKey.split(delimiter)\n-            if (key === restoreKey) {\n-              if (elementSelector === windowKey) {\n-                windowRestored = true\n-                window.scrollTo({\n-                  top: entry.scrollY,\n-                  left: entry.scrollX,\n-                  behavior: options?.scrollBehavior,\n-                })\n-              } else if (elementSelector) {\n-                const element = document.querySelector(elementSelector)\n-                if (element) {\n-                  element.scrollLeft = entry.scrollX\n-                  element.scrollTop = entry.scrollY\n-                }\n-              }\n-            }\n-          }\n-\n-          if (!windowRestored) {\n-            window.scrollTo(0, 0)\n-          }\n+      restoreScroll(\n+        storageKey,\n+        getKey(event.toLocation),\n+        options?.scrollBehavior,\n+      )\n+    })\n \n-          cache.set((c) => ({ ...c, next: {} }))\n-          weakScrolledElements = new WeakSet<any>()\n-        }\n-      },\n+    restoreScroll(\n+      storageKey,\n+      getKey(router.latestLocation),\n+      options?.scrollBehavior,\n     )\n \n     return () => {\n-      document.removeEventListener('scroll', onScroll)\n-      unsubOnBeforeLoad()\n-      unsubOnBeforeRouteMount()\n+      unobserveDom()\n+      document.removeEventListener('scroll', throttle(onScroll, 100))\n+      unsubOnResolved()\n     }\n   }, [options?.getKey, router])\n }\n \n export function ScrollRestoration(props: ScrollRestorationOptions) {\n+  const router = useRouter()\n   useScrollRestoration(props)\n-  return null\n+\n+  // if (!router.) {\n+  //   return <script suppressHydrationWarning />\n+  // }\n+\n+  const getKey = props.getKey || defaultGetKey\n+  const userKey = getKey(router.latestLocation)\n+  const resolvedKey =\n+    userKey !== defaultGetKey(router.latestLocation) ? userKey : null\n+\n+  return (\n+    <script\n+      suppressHydrationWarning\n+      dangerouslySetInnerHTML={{\n+        __html: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)});__TSR__.cleanScripts()`,",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1921520125",
        "repo_full_name": "TanStack/router",
        "pr_number": 3191,
        "pr_file": "packages/react-router/src/scroll-restoration.tsx",
        "discussion_id": "1921520125",
        "commented_code": "@@ -87,110 +190,84 @@ export function useScrollRestoration(options?: ScrollRestorationOptions) {\n         }\n       }\n \n-      if (!cache.state.next[elementSelector]) {\n-        cache.set((c) => ({\n-          ...c,\n-          next: {\n-            ...c.next,\n-            [elementSelector]: {\n-              scrollX: NaN,\n-              scrollY: NaN,\n-            },\n-          },\n-        }))\n-      }\n+      const restoreKey = getKey(router.state.location)\n+\n+      cache.set((state) => {\n+        const keyEntry = (state[restoreKey] =\n+          state[restoreKey] || ({} as ScrollRestorationByElement))\n+\n+        const elementEntry = (keyEntry[elementSelector] =\n+          keyEntry[elementSelector] || ({} as ScrollRestorationEntry))\n+\n+        if (elementSelector === 'window') {\n+          elementEntry.scrollX = window.scrollX || 0\n+          elementEntry.scrollY = window.scrollY || 0\n+        } else if (elementSelector) {\n+          const element = document.querySelector(elementSelector)\n+          if (element) {\n+            elementEntry.scrollX = element.scrollLeft || 0\n+            elementEntry.scrollY = element.scrollTop || 0\n+          }\n+        }\n+\n+        return state\n+      })\n     }\n \n+    // Throttle the scroll event to avoid excessive updates\n     if (typeof document !== 'undefined') {\n       document.addEventListener('scroll', onScroll, true)\n     }\n \n-    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n-      if (event.hrefChanged) {\n-        const restoreKey = getKey(event.fromLocation)\n-        for (const elementSelector in cache.state.next) {\n-          const entry = cache.state.next[elementSelector]!\n-          if (elementSelector === windowKey) {\n-            entry.scrollX = window.scrollX || 0\n-            entry.scrollY = window.scrollY || 0\n-          } else if (elementSelector) {\n-            const element = document.querySelector(elementSelector)\n-            entry.scrollX = element?.scrollLeft || 0\n-            entry.scrollY = element?.scrollTop || 0\n-          }\n-\n-          cache.set((c) => {\n-            const next = { ...c.next }\n-            delete next[elementSelector]\n-\n-            return {\n-              ...c,\n-              next,\n-              cached: {\n-                ...c.cached,\n-                [[restoreKey, elementSelector].join(delimiter)]: entry,\n-              },\n-            }\n-          })\n-        }\n+    const unsubOnResolved = router.subscribe('onRendered', (event) => {\n+      if (!router.resetNextScroll) {\n+        return\n       }\n-    })\n \n-    const unsubOnBeforeRouteMount = router.subscribe(\n-      'onBeforeRouteMount',\n-      (event) => {\n-        if (event.hrefChanged) {\n-          if (!router.resetNextScroll) {\n-            return\n-          }\n+      router.resetNextScroll = true\n \n-          router.resetNextScroll = true\n-\n-          const restoreKey = getKey(event.toLocation)\n-          let windowRestored = false\n-\n-          for (const cacheKey in cache.state.cached) {\n-            const entry = cache.state.cached[cacheKey]!\n-            const [key, elementSelector] = cacheKey.split(delimiter)\n-            if (key === restoreKey) {\n-              if (elementSelector === windowKey) {\n-                windowRestored = true\n-                window.scrollTo({\n-                  top: entry.scrollY,\n-                  left: entry.scrollX,\n-                  behavior: options?.scrollBehavior,\n-                })\n-              } else if (elementSelector) {\n-                const element = document.querySelector(elementSelector)\n-                if (element) {\n-                  element.scrollLeft = entry.scrollX\n-                  element.scrollTop = entry.scrollY\n-                }\n-              }\n-            }\n-          }\n-\n-          if (!windowRestored) {\n-            window.scrollTo(0, 0)\n-          }\n+      restoreScroll(\n+        storageKey,\n+        getKey(event.toLocation),\n+        options?.scrollBehavior,\n+      )\n+    })\n \n-          cache.set((c) => ({ ...c, next: {} }))\n-          weakScrolledElements = new WeakSet<any>()\n-        }\n-      },\n+    restoreScroll(\n+      storageKey,\n+      getKey(router.latestLocation),\n+      options?.scrollBehavior,\n     )\n \n     return () => {\n-      document.removeEventListener('scroll', onScroll)\n-      unsubOnBeforeLoad()\n-      unsubOnBeforeRouteMount()\n+      unobserveDom()\n+      document.removeEventListener('scroll', throttle(onScroll, 100))\n+      unsubOnResolved()\n     }\n   }, [options?.getKey, router])\n }\n \n export function ScrollRestoration(props: ScrollRestorationOptions) {\n+  const router = useRouter()\n   useScrollRestoration(props)\n-  return null\n+\n+  // if (!router.) {\n+  //   return <script suppressHydrationWarning />\n+  // }\n+\n+  const getKey = props.getKey || defaultGetKey\n+  const userKey = getKey(router.latestLocation)\n+  const resolvedKey =\n+    userKey !== defaultGetKey(router.latestLocation) ? userKey : null\n+\n+  return (\n+    <script\n+      suppressHydrationWarning\n+      dangerouslySetInnerHTML={{\n+        __html: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)});__TSR__.cleanScripts()`,",
        "comment_created_at": "2025-01-19T10:21:46+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Perhaps this bit should be optionally checked since Start isn't guaranteed to be there?\r\n```suggestion\r\n        __html: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)});__TSR__?.cleanScripts?.()`,\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1931373163",
        "repo_full_name": "TanStack/router",
        "pr_number": 3191,
        "pr_file": "packages/react-router/src/scroll-restoration.tsx",
        "discussion_id": "1921520125",
        "commented_code": "@@ -87,110 +190,84 @@ export function useScrollRestoration(options?: ScrollRestorationOptions) {\n         }\n       }\n \n-      if (!cache.state.next[elementSelector]) {\n-        cache.set((c) => ({\n-          ...c,\n-          next: {\n-            ...c.next,\n-            [elementSelector]: {\n-              scrollX: NaN,\n-              scrollY: NaN,\n-            },\n-          },\n-        }))\n-      }\n+      const restoreKey = getKey(router.state.location)\n+\n+      cache.set((state) => {\n+        const keyEntry = (state[restoreKey] =\n+          state[restoreKey] || ({} as ScrollRestorationByElement))\n+\n+        const elementEntry = (keyEntry[elementSelector] =\n+          keyEntry[elementSelector] || ({} as ScrollRestorationEntry))\n+\n+        if (elementSelector === 'window') {\n+          elementEntry.scrollX = window.scrollX || 0\n+          elementEntry.scrollY = window.scrollY || 0\n+        } else if (elementSelector) {\n+          const element = document.querySelector(elementSelector)\n+          if (element) {\n+            elementEntry.scrollX = element.scrollLeft || 0\n+            elementEntry.scrollY = element.scrollTop || 0\n+          }\n+        }\n+\n+        return state\n+      })\n     }\n \n+    // Throttle the scroll event to avoid excessive updates\n     if (typeof document !== 'undefined') {\n       document.addEventListener('scroll', onScroll, true)\n     }\n \n-    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n-      if (event.hrefChanged) {\n-        const restoreKey = getKey(event.fromLocation)\n-        for (const elementSelector in cache.state.next) {\n-          const entry = cache.state.next[elementSelector]!\n-          if (elementSelector === windowKey) {\n-            entry.scrollX = window.scrollX || 0\n-            entry.scrollY = window.scrollY || 0\n-          } else if (elementSelector) {\n-            const element = document.querySelector(elementSelector)\n-            entry.scrollX = element?.scrollLeft || 0\n-            entry.scrollY = element?.scrollTop || 0\n-          }\n-\n-          cache.set((c) => {\n-            const next = { ...c.next }\n-            delete next[elementSelector]\n-\n-            return {\n-              ...c,\n-              next,\n-              cached: {\n-                ...c.cached,\n-                [[restoreKey, elementSelector].join(delimiter)]: entry,\n-              },\n-            }\n-          })\n-        }\n+    const unsubOnResolved = router.subscribe('onRendered', (event) => {\n+      if (!router.resetNextScroll) {\n+        return\n       }\n-    })\n \n-    const unsubOnBeforeRouteMount = router.subscribe(\n-      'onBeforeRouteMount',\n-      (event) => {\n-        if (event.hrefChanged) {\n-          if (!router.resetNextScroll) {\n-            return\n-          }\n+      router.resetNextScroll = true\n \n-          router.resetNextScroll = true\n-\n-          const restoreKey = getKey(event.toLocation)\n-          let windowRestored = false\n-\n-          for (const cacheKey in cache.state.cached) {\n-            const entry = cache.state.cached[cacheKey]!\n-            const [key, elementSelector] = cacheKey.split(delimiter)\n-            if (key === restoreKey) {\n-              if (elementSelector === windowKey) {\n-                windowRestored = true\n-                window.scrollTo({\n-                  top: entry.scrollY,\n-                  left: entry.scrollX,\n-                  behavior: options?.scrollBehavior,\n-                })\n-              } else if (elementSelector) {\n-                const element = document.querySelector(elementSelector)\n-                if (element) {\n-                  element.scrollLeft = entry.scrollX\n-                  element.scrollTop = entry.scrollY\n-                }\n-              }\n-            }\n-          }\n-\n-          if (!windowRestored) {\n-            window.scrollTo(0, 0)\n-          }\n+      restoreScroll(\n+        storageKey,\n+        getKey(event.toLocation),\n+        options?.scrollBehavior,\n+      )\n+    })\n \n-          cache.set((c) => ({ ...c, next: {} }))\n-          weakScrolledElements = new WeakSet<any>()\n-        }\n-      },\n+    restoreScroll(\n+      storageKey,\n+      getKey(router.latestLocation),\n+      options?.scrollBehavior,\n     )\n \n     return () => {\n-      document.removeEventListener('scroll', onScroll)\n-      unsubOnBeforeLoad()\n-      unsubOnBeforeRouteMount()\n+      unobserveDom()\n+      document.removeEventListener('scroll', throttle(onScroll, 100))\n+      unsubOnResolved()\n     }\n   }, [options?.getKey, router])\n }\n \n export function ScrollRestoration(props: ScrollRestorationOptions) {\n+  const router = useRouter()\n   useScrollRestoration(props)\n-  return null\n+\n+  // if (!router.) {\n+  //   return <script suppressHydrationWarning />\n+  // }\n+\n+  const getKey = props.getKey || defaultGetKey\n+  const userKey = getKey(router.latestLocation)\n+  const resolvedKey =\n+    userKey !== defaultGetKey(router.latestLocation) ? userKey : null\n+\n+  return (\n+    <script\n+      suppressHydrationWarning\n+      dangerouslySetInnerHTML={{\n+        __html: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)});__TSR__.cleanScripts()`,",
        "comment_created_at": "2025-01-28T00:40:27+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "it's also called `__TSR_SSR__` now",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1933330565",
    "pr_number": 3191,
    "pr_file": "packages/react-router/src/scroll-restoration.tsx",
    "created_at": "2025-01-29T06:31:25+00:00",
    "commented_code": "-import * as React from 'react'\n import { functionalUpdate } from '@tanstack/router-core'\n import { useRouter } from './useRouter'\n+import { ScriptOnce } from './ScriptOnce'\n+import type { AnyRouter } from './router'\n import type { NonNullableUpdater, ParsedLocation } from '@tanstack/router-core'\n \n-const useLayoutEffect =\n-  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n+export type ScrollRestorationEntry = { scrollX: number; scrollY: number }\n \n-const windowKey = 'window'\n-const delimiter = '___'\n+export type ScrollRestorationByElement = Record<string, ScrollRestorationEntry>\n \n-let weakScrolledElements = new WeakSet<any>()\n+export type ScrollRestorationByKey = Record<string, ScrollRestorationByElement>\n \n-type CacheValue = Record<string, { scrollX: number; scrollY: number }>\n-type CacheState = {\n-  cached: CacheValue\n-  next: CacheValue\n+export type ScrollRestorationCache = {\n+  state: ScrollRestorationByKey\n+  set: (updater: NonNullableUpdater<ScrollRestorationByKey>) => void\n }\n-\n-type Cache = {\n-  state: CacheState\n-  set: (updater: NonNullableUpdater<CacheState>) => void\n+export type ScrollRestorationOptions = {\n+  getKey?: (location: ParsedLocation) => string\n+  scrollBehavior?: ScrollToOptions['behavior']\n }\n \n+export const storageKey = 'tsr-scroll-restoration-v3'",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1933330565",
        "repo_full_name": "TanStack/router",
        "pr_number": 3191,
        "pr_file": "packages/react-router/src/scroll-restoration.tsx",
        "discussion_id": "1933330565",
        "commented_code": "@@ -1,241 +1,315 @@\n-import * as React from 'react'\n import { functionalUpdate } from '@tanstack/router-core'\n import { useRouter } from './useRouter'\n+import { ScriptOnce } from './ScriptOnce'\n+import type { AnyRouter } from './router'\n import type { NonNullableUpdater, ParsedLocation } from '@tanstack/router-core'\n \n-const useLayoutEffect =\n-  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n+export type ScrollRestorationEntry = { scrollX: number; scrollY: number }\n \n-const windowKey = 'window'\n-const delimiter = '___'\n+export type ScrollRestorationByElement = Record<string, ScrollRestorationEntry>\n \n-let weakScrolledElements = new WeakSet<any>()\n+export type ScrollRestorationByKey = Record<string, ScrollRestorationByElement>\n \n-type CacheValue = Record<string, { scrollX: number; scrollY: number }>\n-type CacheState = {\n-  cached: CacheValue\n-  next: CacheValue\n+export type ScrollRestorationCache = {\n+  state: ScrollRestorationByKey\n+  set: (updater: NonNullableUpdater<ScrollRestorationByKey>) => void\n }\n-\n-type Cache = {\n-  state: CacheState\n-  set: (updater: NonNullableUpdater<CacheState>) => void\n+export type ScrollRestorationOptions = {\n+  getKey?: (location: ParsedLocation) => string\n+  scrollBehavior?: ScrollToOptions['behavior']\n }\n \n+export const storageKey = 'tsr-scroll-restoration-v3'",
        "comment_created_at": "2025-01-29T06:31:25+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "```suggestion\r\n// TODO: Bump `v1` to `v2` when performing the library major bump.\r\nexport const storageKey = 'tsr-scroll-restoration-v1-3'\r\n```\r\n\r\nAnd then in v2, change it to `tsr-scroll-restoration-v2-1`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1985910694",
    "pr_number": 3636,
    "pr_file": "packages/router-devtools/src/index.tsx",
    "created_at": "2025-03-08T01:20:55+00:00",
    "commented_code": "+console.warn(\n+  '[@tanstack/router-devtools] This package has moved to @tanstack/react-router-devtools. Please switch to the new package at your earliest convenience, as this package will be dropped in the next major version release.',\n+)\n+\n export { TanStackRouterDevtools } from './TanStackRouterDevtools'",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1985910694",
        "repo_full_name": "TanStack/router",
        "pr_number": 3636,
        "pr_file": "packages/router-devtools/src/index.tsx",
        "discussion_id": "1985910694",
        "commented_code": "@@ -1,2 +1,6 @@\n+console.warn(\n+  '[@tanstack/router-devtools] This package has moved to @tanstack/react-router-devtools. Please switch to the new package at your earliest convenience, as this package will be dropped in the next major version release.',\n+)\n+\n export { TanStackRouterDevtools } from './TanStackRouterDevtools'",
        "comment_created_at": "2025-03-08T01:20:55+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Has the implementation details (components, utils, etc.) for `@tanstack/router-devtools` not been nuked yet?\r\n\r\n---\r\n\r\nTo retain the same \"available in production\" behaviour, maybe just export a legacy option from `@tanstack/react-router-devtools` and have that be the primary export for `@tanstack/router-devtools`.\r\n\r\nSo, that'd be.\r\n\r\n1. Setup an export as `@tanstack/react-router-devtools/legacy`.\r\n1.1 `packages/react-router-devtools/src/legacy.ts` where the legacy export would retain the same behaviour in deployment as we have now.\r\n1.2 `packages/react-router-devtools/vite.config.ts` to have a separate entry for the legacy entry.\r\n1.3 `packages/react-router-devtools/package.json` to have a separate entry for the legacy entry.\r\n2. `@tanstack/router-devtools` exports the components from `@tanstack/react-router-devtools/legacy`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1985914166",
        "repo_full_name": "TanStack/router",
        "pr_number": 3636,
        "pr_file": "packages/router-devtools/src/index.tsx",
        "discussion_id": "1985910694",
        "commented_code": "@@ -1,2 +1,6 @@\n+console.warn(\n+  '[@tanstack/router-devtools] This package has moved to @tanstack/react-router-devtools. Please switch to the new package at your earliest convenience, as this package will be dropped in the next major version release.',\n+)\n+\n export { TanStackRouterDevtools } from './TanStackRouterDevtools'",
        "comment_created_at": "2025-03-08T01:23:04+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "We just need to maintain the package export for `@tanstack/router-devtools`. The package itself would basically just be proxying out `@tanstack/react-router-devtool/legacy`.\r\n\r\nEssentially, the same as what we are doing for `@tanstack/router-vite-plugin`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1985917415",
        "repo_full_name": "TanStack/router",
        "pr_number": 3636,
        "pr_file": "packages/router-devtools/src/index.tsx",
        "discussion_id": "1985910694",
        "commented_code": "@@ -1,2 +1,6 @@\n+console.warn(\n+  '[@tanstack/router-devtools] This package has moved to @tanstack/react-router-devtools. Please switch to the new package at your earliest convenience, as this package will be dropped in the next major version release.',\n+)\n+\n export { TanStackRouterDevtools } from './TanStackRouterDevtools'",
        "comment_created_at": "2025-03-08T01:30:36+00:00",
        "comment_author": "birkskyum",
        "comment_body": "Having the `@tanstack/router-devtools` \r\n\r\n`export { TanStackRouterDevtoolsInProd as TanStackRouterDevtools } from '@tanstack/react-router-devtools'` \r\n\r\nWill retain the existing  beahvior of showing the devtools in prod environments",
        "pr_file_module": null
      },
      {
        "comment_id": "1985920734",
        "repo_full_name": "TanStack/router",
        "pr_number": 3636,
        "pr_file": "packages/router-devtools/src/index.tsx",
        "discussion_id": "1985910694",
        "commented_code": "@@ -1,2 +1,6 @@\n+console.warn(\n+  '[@tanstack/router-devtools] This package has moved to @tanstack/react-router-devtools. Please switch to the new package at your earliest convenience, as this package will be dropped in the next major version release.',\n+)\n+\n export { TanStackRouterDevtools } from './TanStackRouterDevtools'",
        "comment_created_at": "2025-03-08T01:37:40+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Awesome!\r\n\r\nI just don't want to maintain any implementation in `@tanstack/router-devtools`. It should all just live in `@tanstack/react-router-devtools`.\r\n\r\nThe `@tanstack/router-devtools` would just be a proxy. No implementation.",
        "pr_file_module": null
      },
      {
        "comment_id": "1985923254",
        "repo_full_name": "TanStack/router",
        "pr_number": 3636,
        "pr_file": "packages/router-devtools/src/index.tsx",
        "discussion_id": "1985910694",
        "commented_code": "@@ -1,2 +1,6 @@\n+console.warn(\n+  '[@tanstack/router-devtools] This package has moved to @tanstack/react-router-devtools. Please switch to the new package at your earliest convenience, as this package will be dropped in the next major version release.',\n+)\n+\n export { TanStackRouterDevtools } from './TanStackRouterDevtools'",
        "comment_created_at": "2025-03-08T01:42:28+00:00",
        "comment_author": "birkskyum",
        "comment_body": "I've removed the legacy implementation, so it's just a proxy now, as can be demonstrated by running `/e2e/react-router/basic-react-query`",
        "pr_file_module": null
      }
    ]
  }
]