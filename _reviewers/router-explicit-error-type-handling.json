[
  {
    "discussion_id": "2181760637",
    "pr_number": 4570,
    "pr_file": "packages/router-core/src/router.ts",
    "created_at": "2025-07-03T05:24:30+00:00",
    "commented_code": "...head,\n                           }))\n                         } catch (e) {\n+                          if (\n+                            e instanceof DOMException &&\n+                            e.name === 'AbortError'\n+                          ) {\n+                            const head = await executeHead()\n+                            updateMatch(matchId, (prev) => ({\n+                              ...prev,\n+                              status:\n+                                prev.status === 'pending'\n+                                  ? 'success'\n+                                  : prev.status,\n+                              ...head,\n+                            }))\n+                            return\n+                          }\n+",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2181760637",
        "repo_full_name": "TanStack/router",
        "pr_number": 4570,
        "pr_file": "packages/router-core/src/router.ts",
        "discussion_id": "2181760637",
        "commented_code": "@@ -2511,6 +2511,22 @@ export class RouterCore<\n                             ...head,\n                           }))\n                         } catch (e) {\n+                          if (\n+                            e instanceof DOMException &&\n+                            e.name === 'AbortError'\n+                          ) {\n+                            const head = await executeHead()\n+                            updateMatch(matchId, (prev) => ({\n+                              ...prev,\n+                              status:\n+                                prev.status === 'pending'\n+                                  ? 'success'\n+                                  : prev.status,\n+                              ...head,\n+                            }))\n+                            return\n+                          }\n+",
        "comment_created_at": "2025-07-03T05:24:30+00:00",
        "comment_author": "leesb971204",
        "comment_body": "According to the [documentation](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort), the `abortController.abort()` method throws an `Error` object of type `DOMException` with the name `AbortError`.\r\nWhen this error is thrown during route loading, it is treated as a normal control flow and the route is updated to a valid state accordingly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2181775937",
        "repo_full_name": "TanStack/router",
        "pr_number": 4570,
        "pr_file": "packages/router-core/src/router.ts",
        "discussion_id": "2181760637",
        "commented_code": "@@ -2511,6 +2511,22 @@ export class RouterCore<\n                             ...head,\n                           }))\n                         } catch (e) {\n+                          if (\n+                            e instanceof DOMException &&\n+                            e.name === 'AbortError'\n+                          ) {\n+                            const head = await executeHead()\n+                            updateMatch(matchId, (prev) => ({\n+                              ...prev,\n+                              status:\n+                                prev.status === 'pending'\n+                                  ? 'success'\n+                                  : prev.status,\n+                              ...head,\n+                            }))\n+                            return\n+                          }\n+",
        "comment_created_at": "2025-07-03T05:27:34+00:00",
        "comment_author": "leesb971204",
        "comment_body": "@SeanCassiere \r\n\r\nI noticed you\u2019ve explored similar concerns before(#4531), so I think it would be great to discuss this approach together.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2272381418",
    "pr_number": 4727,
    "pr_file": "packages/router-core/src/route.ts",
    "created_at": "2025-08-13T07:47:27+00:00",
    "commented_code": "reset: () => void\n }\n \n-export type ErrorComponentProps<TError = Error> = {\n-  error: TError\n+export type ErrorComponentProps = {\n+  error: Error",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2272381418",
        "repo_full_name": "TanStack/router",
        "pr_number": 4727,
        "pr_file": "packages/router-core/src/route.ts",
        "discussion_id": "2272381418",
        "commented_code": "@@ -1317,8 +1317,8 @@ export type ErrorRouteProps = {\n   reset: () => void\n }\n \n-export type ErrorComponentProps<TError = Error> = {\n-  error: TError\n+export type ErrorComponentProps = {\n+  error: Error",
        "comment_created_at": "2025-08-13T07:47:27+00:00",
        "comment_author": "leesb971204",
        "comment_body": "Since the scope of the `errorComponent` covers both errors from the `loader` and errors from the component itself, using the `Error` type is appropriate",
        "pr_file_module": null
      },
      {
        "comment_id": "2328820160",
        "repo_full_name": "TanStack/router",
        "pr_number": 4727,
        "pr_file": "packages/router-core/src/route.ts",
        "discussion_id": "2272381418",
        "commented_code": "@@ -1317,8 +1317,8 @@ export type ErrorRouteProps = {\n   reset: () => void\n }\n \n-export type ErrorComponentProps<TError = Error> = {\n-  error: TError\n+export type ErrorComponentProps = {\n+  error: Error",
        "comment_created_at": "2025-09-07T19:46:54+00:00",
        "comment_author": "michaelbull",
        "comment_body": "This seems to undo the work of making it handle throwing of non-errors. What if my loader calls some third-party API that internally does `throw \"Some string\"` or `throw 50`? Loaders can throw more than just `Error`s, and in some situations the user is not in control of what could be thrown.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328892665",
        "repo_full_name": "TanStack/router",
        "pr_number": 4727,
        "pr_file": "packages/router-core/src/route.ts",
        "discussion_id": "2272381418",
        "commented_code": "@@ -1317,8 +1317,8 @@ export type ErrorRouteProps = {\n   reset: () => void\n }\n \n-export type ErrorComponentProps<TError = Error> = {\n-  error: TError\n+export type ErrorComponentProps = {\n+  error: Error",
        "comment_created_at": "2025-09-07T23:35:50+00:00",
        "comment_author": "leesb971204",
        "comment_body": "@michaelbull \r\n\r\nThat\u2019s right. But since in most cases the error is returned as `Error`, I think it makes sense to set the type to `Error` by default, and if needed, the user can manually override the error type using something like declare. Please refer to the [link](https://github.com/TanStack/query/pull/9575#discussion_r2282056463).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217311475",
    "pr_number": 4691,
    "pr_file": "packages/router-core/src/route.ts",
    "created_at": "2025-07-19T12:54:17+00:00",
    "commented_code": "reset: () => void\n }\n \n-export type ErrorComponentProps = {\n-  error: Error\n+export type ErrorComponentProps<TError = Error> = {\n+  error: TError",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217311475",
        "repo_full_name": "TanStack/router",
        "pr_number": 4691,
        "pr_file": "packages/router-core/src/route.ts",
        "discussion_id": "2217311475",
        "commented_code": "@@ -1317,8 +1317,8 @@ export type ErrorRouteProps = {\n   reset: () => void\n }\n \n-export type ErrorComponentProps = {\n-  error: Error\n+export type ErrorComponentProps<TError = Error> = {\n+  error: TError",
        "comment_created_at": "2025-07-19T12:54:17+00:00",
        "comment_author": "leesb971204",
        "comment_body": "This reflects @michaelbull \u2019s suggestion.\r\n\r\nThe change respects the diversity of error objects returned from the backend while setting `Error` as the default type to ensure compatibility with existing code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181564912",
    "pr_number": 4565,
    "pr_file": "packages/router-core/src/recoverableError.ts",
    "created_at": "2025-07-03T03:32:56+00:00",
    "commented_code": "+export const RECOVERABLE_ERROR = 'TSR_RecoverableError'\n+\n+export function isRecoverableError(error: unknown): boolean {\n+  if (error instanceof Error) {\n+    return error.message.includes(RECOVERABLE_ERROR)",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2181564912",
        "repo_full_name": "TanStack/router",
        "pr_number": 4565,
        "pr_file": "packages/router-core/src/recoverableError.ts",
        "discussion_id": "2181564912",
        "commented_code": "@@ -0,0 +1,13 @@\n+export const RECOVERABLE_ERROR = 'TSR_RecoverableError'\n+\n+export function isRecoverableError(error: unknown): boolean {\n+  if (error instanceof Error) {\n+    return error.message.includes(RECOVERABLE_ERROR)",
        "comment_created_at": "2025-07-03T03:32:56+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Maybe make this a more specific? \r\n```\r\nstartsWith(`${RECOVERABLE_ERROR}: `)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1844983977",
    "pr_number": 2781,
    "pr_file": "packages/start/src/client/createServerFn.ts",
    "created_at": "2024-11-16T14:06:41+00:00",
    "commented_code": "...extractedFn,\n           // The extracted function on the server-side calls\n           // this function\n-          __executeServer: (opts: any) =>\n-            executeMiddleware(resolvedMiddleware, 'server', {\n+          __executeServer: (opts: any) => {\n+            const parsedOpts =\n+              opts instanceof FormData ? extractFormDataContext(opts) : opts\n+\n+            return executeMiddleware(resolvedMiddleware, 'server', {\n               ...extractedFn,\n-              ...opts,\n+              ...parsedOpts,\n             }).then((d) => ({\n               // Only send the result and sendContext back to the client\n               result: d.result,\n               context: d.sendContext,\n-            })),\n+            }))\n+          },\n         },\n       ) as any\n     },\n   }\n }\n \n+function extractFormDataContext(formData: FormData) {\n+  const serializedContext = formData.get('__TSR_CONTEXT')\n+  formData.delete('__TSR_CONTEXT')\n+\n+  if (typeof serializedContext !== 'string') {\n+    return {\n+      context: {},\n+      data: formData,\n+    }\n+  }\n+\n+  try {\n+    const context = defaultTransformer.parse(serializedContext)\n+    return {\n+      context,\n+      data: formData,\n+    }\n+  } catch (e) {\n+    return {\n+      data: formData,\n+    }\n+  }",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1844983977",
        "repo_full_name": "TanStack/router",
        "pr_number": 2781,
        "pr_file": "packages/start/src/client/createServerFn.ts",
        "discussion_id": "1844983977",
        "commented_code": "@@ -216,21 +217,49 @@ export function createServerFn<\n           ...extractedFn,\n           // The extracted function on the server-side calls\n           // this function\n-          __executeServer: (opts: any) =>\n-            executeMiddleware(resolvedMiddleware, 'server', {\n+          __executeServer: (opts: any) => {\n+            const parsedOpts =\n+              opts instanceof FormData ? extractFormDataContext(opts) : opts\n+\n+            return executeMiddleware(resolvedMiddleware, 'server', {\n               ...extractedFn,\n-              ...opts,\n+              ...parsedOpts,\n             }).then((d) => ({\n               // Only send the result and sendContext back to the client\n               result: d.result,\n               context: d.sendContext,\n-            })),\n+            }))\n+          },\n         },\n       ) as any\n     },\n   }\n }\n \n+function extractFormDataContext(formData: FormData) {\n+  const serializedContext = formData.get('__TSR_CONTEXT')\n+  formData.delete('__TSR_CONTEXT')\n+\n+  if (typeof serializedContext !== 'string') {\n+    return {\n+      context: {},\n+      data: formData,\n+    }\n+  }\n+\n+  try {\n+    const context = defaultTransformer.parse(serializedContext)\n+    return {\n+      context,\n+      data: formData,\n+    }\n+  } catch (e) {\n+    return {\n+      data: formData,\n+    }\n+  }",
        "comment_created_at": "2024-11-16T14:06:41+00:00",
        "comment_author": "np-13",
        "comment_body": "I need others' opinions on this piece since it allows the request to be processed if the context cannot be parsed. However, I'm not sure if this is the desired behaviour, and we'd rather throw an error on context deserialisation failure.",
        "pr_file_module": null
      }
    ]
  }
]