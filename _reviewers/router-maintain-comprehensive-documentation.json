[
  {
    "discussion_id": "2281140526",
    "pr_number": 4987,
    "pr_file": "packages/router-core/tests/searchParams.test.ts",
    "created_at": "2025-08-18T01:55:56+00:00",
    "commented_code": "+import { describe, expect, test } from 'vitest'\n+import { defaultParseSearch, defaultStringifySearch } from '../src'\n+\n+describe('Search Params serialization and deserialization', () => {\n+  /*\n+   * JSON-compatible objects can be serialized into a string,\n+   * and then deserialized back into the original object.\n+   */\n+  test.each([\n+    [{}, ''],\n+    [{ foo: '' }, '?foo='],\n+    [{ foo: 'bar' }, '?foo=bar'],\n+    [{ foo: 'bar baz' }, '?foo=bar+baz'],\n+    [{ foo: 123 }, '?foo=123'],\n+    [{ foo: '123' }, '?foo=%22123%22'],\n+    [{ foo: true }, '?foo=true'],\n+    [{ foo: 'true' }, '?foo=%22true%22'],\n+    [{ foo: null }, '?foo=null'],\n+    [{ foo: 'null' }, '?foo=%22null%22'],\n+    [{ foo: undefined }, ''],\n+    [{ foo: 'undefined' }, '?foo=undefined'],\n+    [{ foo: {} }, '?foo=%7B%7D'],\n+    [{ foo: '{}' }, '?foo=%22%7B%7D%22'],\n+    [{ foo: [] }, '?foo=%5B%5D'],\n+    [{ foo: '[]' }, '?foo=%22%5B%5D%22'],\n+    [{ foo: [1, 2, 3] }, '?foo=%5B1%2C2%2C3%5D'],\n+    [{ foo: '1,2,3' }, '?foo=1%2C2%2C3'],\n+    [{ foo: { bar: 'baz' } }, '?foo=%7B%22bar%22%3A%22baz%22%7D'],\n+    [{ 0: 1 }, '?0=1'],\n+    [{ 'foo=bar': 1 }, '?foo%3Dbar=1'],\n+    [{ '{}': 1 }, '?%7B%7D=1'],\n+    [{ '': 1 }, '?=1'],\n+    [{ '=': '=' }, '?%3D=%3D'],\n+    [{ '=': '', '': '=' }, '?%3D=&=%3D'],\n+    [{ 'foo=2&bar': 3 }, '?foo%3D2%26bar=3'],\n+    [{ 'foo?': 1 }, '?foo%3F=1'],\n+    [{ foo: 'bar=' }, '?foo=bar%3D'],\n+    [{ foo: '2&bar=3' }, '?foo=2%26bar%3D3'],\n+  ])('isomorphism %j', (input, expected) => {\n+    const str = defaultStringifySearch(input)\n+    expect(str).toEqual(expected)\n+    expect(defaultParseSearch(str)).toEqual(input)\n+  })\n+\n+  test('[edge case] self-reference serializes to \"object Object\"', () => {\n+    const obj = {} as any\n+    obj.self = obj\n+    const str = defaultStringifySearch(obj)\n+    expect(str).toEqual('?self=%5Bobject+Object%5D')\n+    expect(defaultParseSearch(str)).toEqual({ self: '[object Object]' })\n+  })\n+\n+  /*\n+   * It is able to parse strings that could not have come\n+   * from the serializer.\n+   *\n+   * This can be useful because search params can be manipulated\n+   * by human users.\n+   */\n+  test.each([\n+    ['?foo={}', { foo: {} }],\n+    ['?foo=[]', { foo: [] }],\n+    ['?foo=1,2,3', { foo: '1,2,3' }],\n+    ['?foo={\"bar\":\"baz\"}', { foo: { bar: 'baz' } }],\n+    ['?foo=1&foo=2', { foo: [1, 2] }],\n+    ['?foo=\"\"', { foo: '' }],\n+    ['?foo=\"\"\"\"', { foo: '\"\"\"\"' }],\n+    ['?foo=()', { foo: '()' }],\n+    ['?foo=[{}]', { foo: [{}] }],\n+  ])('alien deserialization %s', (input, expected) => {\n+    const obj = defaultParseSearch(input)\n+    expect(obj).toEqual(expected)\n+    expect(defaultStringifySearch(obj)).not.toBe(input)\n+  })\n+\n+  /*\n+   * It can serialize stuff that really shouldn't be passed as input.\n+   * But just in case, this test serves as documentation of \"what would happen\"\n+   * if you did.\n+   */\n+  test('[edge case] inputs that are not primitive objects', () => {\n+    expect(defaultStringifySearch(new Number(99))).toEqual('')\n+    expect(defaultStringifySearch({ foo: new Number(99) })).toEqual('?foo=99')\n+    expect(defaultStringifySearch(new String('foo'))).toEqual('?0=f&1=o&2=o')\n+    expect(defaultStringifySearch(new Promise(() => {}))).toEqual('')\n+    expect(defaultStringifySearch({ foo: new Promise(() => {}) })).toEqual(\n+      '?foo=%7B%7D',\n+    )\n+    expect(defaultStringifySearch([1])).toEqual('?0=1')\n+    const date = new Date()\n+    expect(defaultStringifySearch(date)).toEqual('')\n+    expect(defaultStringifySearch({ foo: date })).toEqual(\n+      `?foo=%22${encodeURIComponent(date.toISOString())}%22`,",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2281140526",
        "repo_full_name": "TanStack/router",
        "pr_number": 4987,
        "pr_file": "packages/router-core/tests/searchParams.test.ts",
        "discussion_id": "2281140526",
        "commented_code": "@@ -0,0 +1,96 @@\n+import { describe, expect, test } from 'vitest'\n+import { defaultParseSearch, defaultStringifySearch } from '../src'\n+\n+describe('Search Params serialization and deserialization', () => {\n+  /*\n+   * JSON-compatible objects can be serialized into a string,\n+   * and then deserialized back into the original object.\n+   */\n+  test.each([\n+    [{}, ''],\n+    [{ foo: '' }, '?foo='],\n+    [{ foo: 'bar' }, '?foo=bar'],\n+    [{ foo: 'bar baz' }, '?foo=bar+baz'],\n+    [{ foo: 123 }, '?foo=123'],\n+    [{ foo: '123' }, '?foo=%22123%22'],\n+    [{ foo: true }, '?foo=true'],\n+    [{ foo: 'true' }, '?foo=%22true%22'],\n+    [{ foo: null }, '?foo=null'],\n+    [{ foo: 'null' }, '?foo=%22null%22'],\n+    [{ foo: undefined }, ''],\n+    [{ foo: 'undefined' }, '?foo=undefined'],\n+    [{ foo: {} }, '?foo=%7B%7D'],\n+    [{ foo: '{}' }, '?foo=%22%7B%7D%22'],\n+    [{ foo: [] }, '?foo=%5B%5D'],\n+    [{ foo: '[]' }, '?foo=%22%5B%5D%22'],\n+    [{ foo: [1, 2, 3] }, '?foo=%5B1%2C2%2C3%5D'],\n+    [{ foo: '1,2,3' }, '?foo=1%2C2%2C3'],\n+    [{ foo: { bar: 'baz' } }, '?foo=%7B%22bar%22%3A%22baz%22%7D'],\n+    [{ 0: 1 }, '?0=1'],\n+    [{ 'foo=bar': 1 }, '?foo%3Dbar=1'],\n+    [{ '{}': 1 }, '?%7B%7D=1'],\n+    [{ '': 1 }, '?=1'],\n+    [{ '=': '=' }, '?%3D=%3D'],\n+    [{ '=': '', '': '=' }, '?%3D=&=%3D'],\n+    [{ 'foo=2&bar': 3 }, '?foo%3D2%26bar=3'],\n+    [{ 'foo?': 1 }, '?foo%3F=1'],\n+    [{ foo: 'bar=' }, '?foo=bar%3D'],\n+    [{ foo: '2&bar=3' }, '?foo=2%26bar%3D3'],\n+  ])('isomorphism %j', (input, expected) => {\n+    const str = defaultStringifySearch(input)\n+    expect(str).toEqual(expected)\n+    expect(defaultParseSearch(str)).toEqual(input)\n+  })\n+\n+  test('[edge case] self-reference serializes to \"object Object\"', () => {\n+    const obj = {} as any\n+    obj.self = obj\n+    const str = defaultStringifySearch(obj)\n+    expect(str).toEqual('?self=%5Bobject+Object%5D')\n+    expect(defaultParseSearch(str)).toEqual({ self: '[object Object]' })\n+  })\n+\n+  /*\n+   * It is able to parse strings that could not have come\n+   * from the serializer.\n+   *\n+   * This can be useful because search params can be manipulated\n+   * by human users.\n+   */\n+  test.each([\n+    ['?foo={}', { foo: {} }],\n+    ['?foo=[]', { foo: [] }],\n+    ['?foo=1,2,3', { foo: '1,2,3' }],\n+    ['?foo={\"bar\":\"baz\"}', { foo: { bar: 'baz' } }],\n+    ['?foo=1&foo=2', { foo: [1, 2] }],\n+    ['?foo=\"\"', { foo: '' }],\n+    ['?foo=\"\"\"\"', { foo: '\"\"\"\"' }],\n+    ['?foo=()', { foo: '()' }],\n+    ['?foo=[{}]', { foo: [{}] }],\n+  ])('alien deserialization %s', (input, expected) => {\n+    const obj = defaultParseSearch(input)\n+    expect(obj).toEqual(expected)\n+    expect(defaultStringifySearch(obj)).not.toBe(input)\n+  })\n+\n+  /*\n+   * It can serialize stuff that really shouldn't be passed as input.\n+   * But just in case, this test serves as documentation of \"what would happen\"\n+   * if you did.\n+   */\n+  test('[edge case] inputs that are not primitive objects', () => {\n+    expect(defaultStringifySearch(new Number(99))).toEqual('')\n+    expect(defaultStringifySearch({ foo: new Number(99) })).toEqual('?foo=99')\n+    expect(defaultStringifySearch(new String('foo'))).toEqual('?0=f&1=o&2=o')\n+    expect(defaultStringifySearch(new Promise(() => {}))).toEqual('')\n+    expect(defaultStringifySearch({ foo: new Promise(() => {}) })).toEqual(\n+      '?foo=%7B%7D',\n+    )\n+    expect(defaultStringifySearch([1])).toEqual('?0=1')\n+    const date = new Date()\n+    expect(defaultStringifySearch(date)).toEqual('')\n+    expect(defaultStringifySearch({ foo: date })).toEqual(\n+      `?foo=%22${encodeURIComponent(date.toISOString())}%22`,",
        "comment_created_at": "2025-08-18T01:55:56+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Similarly, please have the expected value be listed 'in full' as a string. It'd be better for our tests on this to show us exactly what's expected for a certain transformation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2024483002",
    "pr_number": 3914,
    "pr_file": "packages/router-core/src/scroll-restoration.ts",
    "created_at": "2025-04-02T09:45:32+00:00",
    "commented_code": "}\n   })\n }\n+\n+export function handleHashScroll(router: AnyRouter) {",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2024483002",
        "repo_full_name": "TanStack/router",
        "pr_number": 3914,
        "pr_file": "packages/router-core/src/scroll-restoration.ts",
        "discussion_id": "2024483002",
        "commented_code": "@@ -316,3 +316,17 @@ export function setupScrollRestoration(router: AnyRouter, force?: boolean) {\n     }\n   })\n }\n+\n+export function handleHashScroll(router: AnyRouter) {",
        "comment_created_at": "2025-04-02T09:45:32+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Couple of small changes here please:\n\n- Rename to `handleTransitionerHashScroll`\n- Annotate the function with some JSDoc comments marking it as `@internal` with a short description saying that this is to be setup in the `<Transitioner>` component and what it actually does.",
        "pr_file_module": null
      },
      {
        "comment_id": "2024485044",
        "repo_full_name": "TanStack/router",
        "pr_number": 3914,
        "pr_file": "packages/router-core/src/scroll-restoration.ts",
        "discussion_id": "2024483002",
        "commented_code": "@@ -316,3 +316,17 @@ export function setupScrollRestoration(router: AnyRouter, force?: boolean) {\n     }\n   })\n }\n+\n+export function handleHashScroll(router: AnyRouter) {",
        "comment_created_at": "2025-04-02T09:46:45+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Optionally, the rename is not necessary if just the JSDoc comment is there. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1883250260",
    "pr_number": 2996,
    "pr_file": "packages/react-router/src/router.ts",
    "created_at": "2024-12-13T04:00:24+00:00",
    "commented_code": "* @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n    */\n   defaultViewTransition?: boolean | ViewTransitionOptions\n+  /**\n+   * The default `hashChangeScrollIntoView` a route should use if no hashChangeScrollIntoView is provided while navigating\n+   *\n+   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1883250260",
        "repo_full_name": "TanStack/router",
        "pr_number": 2996,
        "pr_file": "packages/react-router/src/router.ts",
        "discussion_id": "1883250260",
        "commented_code": "@@ -313,6 +313,14 @@ export interface RouterOptions<\n    * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n    */\n   defaultViewTransition?: boolean | ViewTransitionOptions\n+  /**\n+   * The default `hashChangeScrollIntoView` a route should use if no hashChangeScrollIntoView is provided while navigating\n+   *\n+   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.",
        "comment_created_at": "2024-12-13T04:00:24+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "The MDN link should also be placed in the markdown files.\r\n\r\n- RouterOptionsType.md\r\n- RouterType.md",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1667492012",
    "pr_number": 1907,
    "pr_file": "packages/react-router/src/router.ts",
    "created_at": "2024-07-06T23:17:02+00:00",
    "commented_code": "err.routerCode = routerCode\n                 firstBadMatchIndex = firstBadMatchIndex ?? index\n-                handleRedirectAndNotFound(match, err)\n+                handleRedirectAndNotFound(getMatch(), err)\n \n                 try {\n                   route.options.onError?.(err)\n                 } catch (errorHandlerErr) {\n                   err = errorHandlerErr\n-                  handleRedirectAndNotFound(match, err)\n+                  handleRedirectAndNotFound(getMatch(), err)\n                 }\n \n-                matches[index] = match = updateMatch(match.id, () => ({\n-                  ...match,\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n                   error: err,\n                   status: 'error',\n                   updatedAt: Date.now(),\n                   abortController: new AbortController(),\n                 }))\n               }\n \n-              if (match.paramsError) {\n-                handleSerialError(match.paramsError, 'PARSE_PARAMS')\n-              }\n+              const runBeforeLoad = async () => {\n+                if (getMatch().beforeLoadPromise) {\n+                  return await getMatch().beforeLoadPromise!\n+                }\n \n-              if (match.searchError) {\n-                handleSerialError(match.searchError, 'VALIDATE_SEARCH')\n-              }\n+                const beforeLoadPromise =\n+                  createControlledPromise<Record<string, any>>()\n \n-              try {\n-                const parentContext =\n-                  parentMatch?.context ?? this.options.context ?? {}\n+                const previousResolve = loadPromise.resolve\n+                loadPromise = createControlledPromise<void>(previousResolve)\n \n-                // Make sure the match has parent context set before going further\n-                matches[index] = match = {\n-                  ...match,\n+                const parentContext = getParentContext()\n+\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n+                  isFetching: 'beforeLoad',\n+                  beforeLoadPromise,\n+                  loadPromise,\n                   routeContext: replaceEqualDeep(\n-                    match.routeContext,\n+                    prev.routeContext,\n                     parentContext,\n                   ),\n-                  context: replaceEqualDeep(match.context, parentContext),\n+                  context: replaceEqualDeep(prev.context, parentContext),\n                   abortController,\n-                }\n+                }))\n+\n+                const { search, params, routeContext, cause } = getMatch()\n \n                 const beforeLoadFnContext = {\n-                  search: match.search,\n+                  search,\n                   abortController,\n-                  params: match.params,\n+                  params,\n                   preload: !!preload,\n-                  context: match.routeContext,\n+                  context: routeContext,\n                   location,\n                   navigate: (opts: any) =>\n                     this.navigate({ ...opts, _fromLocation: location }),\n                   buildLocation: this.buildLocation,\n-                  cause: preload ? 'preload' : match.cause,\n+                  cause: preload ? 'preload' : cause,\n                 }\n \n-                const beforeLoadContext = route.options.beforeLoad\n-                  ? (await route.options.beforeLoad(beforeLoadFnContext)) ?? {}\n-                  : {}\n-\n-                checkLatest()\n+                try {\n+                  const beforeLoadContext =\n+                    (await route.options.beforeLoad?.(beforeLoadFnContext)) ??\n+                    {}\n \n-                if (\n-                  isRedirect(beforeLoadContext) ||\n-                  isNotFound(beforeLoadContext)\n-                ) {\n-                  handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n+                  beforeLoadPromise.resolve(beforeLoadContext)\n+                } catch (err) {\n+                  beforeLoadPromise.reject(err)\n                 }\n \n-                const context = {\n-                  ...parentContext,\n-                  ...beforeLoadContext,\n-                }\n+                // Remove the beforeLoadPromise so future invocations will\n+                // be fresh and not use the cached promise\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n+                  beforeLoadPromise: undefined,\n+                }))\n \n-                matches[index] = match = {\n-                  ...match,\n-                  routeContext: replaceEqualDeep(\n-                    match.routeContext,\n-                    beforeLoadContext,\n-                  ),\n-                  context: replaceEqualDeep(match.context, context),\n-                  abortController,\n+                return await beforeLoadPromise\n+              }\n+\n+              const handleBeforeLoadContext = (\n+                beforeLoadContext: Record<string, any>,\n+              ) => {\n+                try {\n+                  if (\n+                    isRedirect(beforeLoadContext) ||\n+                    isNotFound(beforeLoadContext)\n+                  ) {\n+                    handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n+                  }\n+\n+                  updateMatch(matchId, (prev) => {\n+                    const routeContext = {\n+                      ...prev.routeContext,\n+                      ...beforeLoadContext,\n+                    }\n+\n+                    return {\n+                      ...prev,\n+                      routeContext: replaceEqualDeep(\n+                        prev.routeContext,\n+                        routeContext,\n+                      ),\n+                      context: replaceEqualDeep(prev.context, routeContext),\n+                      abortController,\n+                    }\n+                  })\n+                } catch (err) {\n+                  handleSerialError(err, 'BEFORE_LOAD')\n                 }\n-                updateMatch(match.id, () => match)\n+              }\n+\n+              if (shouldPending) {\n+                // If we might show a pending component, we need to wait for the\n+                // pending promise to resolve before we start showing that state\n+                setTimeout(() => {\n+                  try {\n+                    checkLatest()\n+                    // Update the match and prematurely resolve the loadMatches promise so that\n+                    // the pending component can start rendering\n+                    triggerOnReady()\n+                  } catch {}\n+                }, pendingMs)\n+              }\n+\n+              const { paramsError, searchError } = getMatch()\n+\n+              if (paramsError) {\n+                handleSerialError(paramsError, 'PARSE_PARAMS')\n+              }\n+\n+              if (searchError) {\n+                handleSerialError(searchError, 'VALIDATE_SEARCH')\n+              }\n+\n+              try {",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1667492012",
        "repo_full_name": "TanStack/router",
        "pr_number": 1907,
        "pr_file": "packages/react-router/src/router.ts",
        "discussion_id": "1667492012",
        "commented_code": "@@ -1797,91 +1778,146 @@ export class Router<\n \n                 err.routerCode = routerCode\n                 firstBadMatchIndex = firstBadMatchIndex ?? index\n-                handleRedirectAndNotFound(match, err)\n+                handleRedirectAndNotFound(getMatch(), err)\n \n                 try {\n                   route.options.onError?.(err)\n                 } catch (errorHandlerErr) {\n                   err = errorHandlerErr\n-                  handleRedirectAndNotFound(match, err)\n+                  handleRedirectAndNotFound(getMatch(), err)\n                 }\n \n-                matches[index] = match = updateMatch(match.id, () => ({\n-                  ...match,\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n                   error: err,\n                   status: 'error',\n                   updatedAt: Date.now(),\n                   abortController: new AbortController(),\n                 }))\n               }\n \n-              if (match.paramsError) {\n-                handleSerialError(match.paramsError, 'PARSE_PARAMS')\n-              }\n+              const runBeforeLoad = async () => {\n+                if (getMatch().beforeLoadPromise) {\n+                  return await getMatch().beforeLoadPromise!\n+                }\n \n-              if (match.searchError) {\n-                handleSerialError(match.searchError, 'VALIDATE_SEARCH')\n-              }\n+                const beforeLoadPromise =\n+                  createControlledPromise<Record<string, any>>()\n \n-              try {\n-                const parentContext =\n-                  parentMatch?.context ?? this.options.context ?? {}\n+                const previousResolve = loadPromise.resolve\n+                loadPromise = createControlledPromise<void>(previousResolve)\n \n-                // Make sure the match has parent context set before going further\n-                matches[index] = match = {\n-                  ...match,\n+                const parentContext = getParentContext()\n+\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n+                  isFetching: 'beforeLoad',\n+                  beforeLoadPromise,\n+                  loadPromise,\n                   routeContext: replaceEqualDeep(\n-                    match.routeContext,\n+                    prev.routeContext,\n                     parentContext,\n                   ),\n-                  context: replaceEqualDeep(match.context, parentContext),\n+                  context: replaceEqualDeep(prev.context, parentContext),\n                   abortController,\n-                }\n+                }))\n+\n+                const { search, params, routeContext, cause } = getMatch()\n \n                 const beforeLoadFnContext = {\n-                  search: match.search,\n+                  search,\n                   abortController,\n-                  params: match.params,\n+                  params,\n                   preload: !!preload,\n-                  context: match.routeContext,\n+                  context: routeContext,\n                   location,\n                   navigate: (opts: any) =>\n                     this.navigate({ ...opts, _fromLocation: location }),\n                   buildLocation: this.buildLocation,\n-                  cause: preload ? 'preload' : match.cause,\n+                  cause: preload ? 'preload' : cause,\n                 }\n \n-                const beforeLoadContext = route.options.beforeLoad\n-                  ? (await route.options.beforeLoad(beforeLoadFnContext)) ?? {}\n-                  : {}\n-\n-                checkLatest()\n+                try {\n+                  const beforeLoadContext =\n+                    (await route.options.beforeLoad?.(beforeLoadFnContext)) ??\n+                    {}\n \n-                if (\n-                  isRedirect(beforeLoadContext) ||\n-                  isNotFound(beforeLoadContext)\n-                ) {\n-                  handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n+                  beforeLoadPromise.resolve(beforeLoadContext)\n+                } catch (err) {\n+                  beforeLoadPromise.reject(err)\n                 }\n \n-                const context = {\n-                  ...parentContext,\n-                  ...beforeLoadContext,\n-                }\n+                // Remove the beforeLoadPromise so future invocations will\n+                // be fresh and not use the cached promise\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n+                  beforeLoadPromise: undefined,\n+                }))\n \n-                matches[index] = match = {\n-                  ...match,\n-                  routeContext: replaceEqualDeep(\n-                    match.routeContext,\n-                    beforeLoadContext,\n-                  ),\n-                  context: replaceEqualDeep(match.context, context),\n-                  abortController,\n+                return await beforeLoadPromise\n+              }\n+\n+              const handleBeforeLoadContext = (\n+                beforeLoadContext: Record<string, any>,\n+              ) => {\n+                try {\n+                  if (\n+                    isRedirect(beforeLoadContext) ||\n+                    isNotFound(beforeLoadContext)\n+                  ) {\n+                    handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n+                  }\n+\n+                  updateMatch(matchId, (prev) => {\n+                    const routeContext = {\n+                      ...prev.routeContext,\n+                      ...beforeLoadContext,\n+                    }\n+\n+                    return {\n+                      ...prev,\n+                      routeContext: replaceEqualDeep(\n+                        prev.routeContext,\n+                        routeContext,\n+                      ),\n+                      context: replaceEqualDeep(prev.context, routeContext),\n+                      abortController,\n+                    }\n+                  })\n+                } catch (err) {\n+                  handleSerialError(err, 'BEFORE_LOAD')\n                 }\n-                updateMatch(match.id, () => match)\n+              }\n+\n+              if (shouldPending) {\n+                // If we might show a pending component, we need to wait for the\n+                // pending promise to resolve before we start showing that state\n+                setTimeout(() => {\n+                  try {\n+                    checkLatest()\n+                    // Update the match and prematurely resolve the loadMatches promise so that\n+                    // the pending component can start rendering\n+                    triggerOnReady()\n+                  } catch {}\n+                }, pendingMs)\n+              }\n+\n+              const { paramsError, searchError } = getMatch()\n+\n+              if (paramsError) {\n+                handleSerialError(paramsError, 'PARSE_PARAMS')\n+              }\n+\n+              if (searchError) {\n+                handleSerialError(searchError, 'VALIDATE_SEARCH')\n+              }\n+\n+              try {",
        "comment_created_at": "2024-07-06T23:17:02+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "I'd decorate this with a comment like \"actually fire off the `beforeLoad` callback\", purely for readability for others in the future.",
        "pr_file_module": null
      },
      {
        "comment_id": "1667514747",
        "repo_full_name": "TanStack/router",
        "pr_number": 1907,
        "pr_file": "packages/react-router/src/router.ts",
        "discussion_id": "1667492012",
        "commented_code": "@@ -1797,91 +1778,146 @@ export class Router<\n \n                 err.routerCode = routerCode\n                 firstBadMatchIndex = firstBadMatchIndex ?? index\n-                handleRedirectAndNotFound(match, err)\n+                handleRedirectAndNotFound(getMatch(), err)\n \n                 try {\n                   route.options.onError?.(err)\n                 } catch (errorHandlerErr) {\n                   err = errorHandlerErr\n-                  handleRedirectAndNotFound(match, err)\n+                  handleRedirectAndNotFound(getMatch(), err)\n                 }\n \n-                matches[index] = match = updateMatch(match.id, () => ({\n-                  ...match,\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n                   error: err,\n                   status: 'error',\n                   updatedAt: Date.now(),\n                   abortController: new AbortController(),\n                 }))\n               }\n \n-              if (match.paramsError) {\n-                handleSerialError(match.paramsError, 'PARSE_PARAMS')\n-              }\n+              const runBeforeLoad = async () => {\n+                if (getMatch().beforeLoadPromise) {\n+                  return await getMatch().beforeLoadPromise!\n+                }\n \n-              if (match.searchError) {\n-                handleSerialError(match.searchError, 'VALIDATE_SEARCH')\n-              }\n+                const beforeLoadPromise =\n+                  createControlledPromise<Record<string, any>>()\n \n-              try {\n-                const parentContext =\n-                  parentMatch?.context ?? this.options.context ?? {}\n+                const previousResolve = loadPromise.resolve\n+                loadPromise = createControlledPromise<void>(previousResolve)\n \n-                // Make sure the match has parent context set before going further\n-                matches[index] = match = {\n-                  ...match,\n+                const parentContext = getParentContext()\n+\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n+                  isFetching: 'beforeLoad',\n+                  beforeLoadPromise,\n+                  loadPromise,\n                   routeContext: replaceEqualDeep(\n-                    match.routeContext,\n+                    prev.routeContext,\n                     parentContext,\n                   ),\n-                  context: replaceEqualDeep(match.context, parentContext),\n+                  context: replaceEqualDeep(prev.context, parentContext),\n                   abortController,\n-                }\n+                }))\n+\n+                const { search, params, routeContext, cause } = getMatch()\n \n                 const beforeLoadFnContext = {\n-                  search: match.search,\n+                  search,\n                   abortController,\n-                  params: match.params,\n+                  params,\n                   preload: !!preload,\n-                  context: match.routeContext,\n+                  context: routeContext,\n                   location,\n                   navigate: (opts: any) =>\n                     this.navigate({ ...opts, _fromLocation: location }),\n                   buildLocation: this.buildLocation,\n-                  cause: preload ? 'preload' : match.cause,\n+                  cause: preload ? 'preload' : cause,\n                 }\n \n-                const beforeLoadContext = route.options.beforeLoad\n-                  ? (await route.options.beforeLoad(beforeLoadFnContext)) ?? {}\n-                  : {}\n-\n-                checkLatest()\n+                try {\n+                  const beforeLoadContext =\n+                    (await route.options.beforeLoad?.(beforeLoadFnContext)) ??\n+                    {}\n \n-                if (\n-                  isRedirect(beforeLoadContext) ||\n-                  isNotFound(beforeLoadContext)\n-                ) {\n-                  handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n+                  beforeLoadPromise.resolve(beforeLoadContext)\n+                } catch (err) {\n+                  beforeLoadPromise.reject(err)\n                 }\n \n-                const context = {\n-                  ...parentContext,\n-                  ...beforeLoadContext,\n-                }\n+                // Remove the beforeLoadPromise so future invocations will\n+                // be fresh and not use the cached promise\n+                updateMatch(matchId, (prev) => ({\n+                  ...prev,\n+                  beforeLoadPromise: undefined,\n+                }))\n \n-                matches[index] = match = {\n-                  ...match,\n-                  routeContext: replaceEqualDeep(\n-                    match.routeContext,\n-                    beforeLoadContext,\n-                  ),\n-                  context: replaceEqualDeep(match.context, context),\n-                  abortController,\n+                return await beforeLoadPromise\n+              }\n+\n+              const handleBeforeLoadContext = (\n+                beforeLoadContext: Record<string, any>,\n+              ) => {\n+                try {\n+                  if (\n+                    isRedirect(beforeLoadContext) ||\n+                    isNotFound(beforeLoadContext)\n+                  ) {\n+                    handleSerialError(beforeLoadContext, 'BEFORE_LOAD')\n+                  }\n+\n+                  updateMatch(matchId, (prev) => {\n+                    const routeContext = {\n+                      ...prev.routeContext,\n+                      ...beforeLoadContext,\n+                    }\n+\n+                    return {\n+                      ...prev,\n+                      routeContext: replaceEqualDeep(\n+                        prev.routeContext,\n+                        routeContext,\n+                      ),\n+                      context: replaceEqualDeep(prev.context, routeContext),\n+                      abortController,\n+                    }\n+                  })\n+                } catch (err) {\n+                  handleSerialError(err, 'BEFORE_LOAD')\n                 }\n-                updateMatch(match.id, () => match)\n+              }\n+\n+              if (shouldPending) {\n+                // If we might show a pending component, we need to wait for the\n+                // pending promise to resolve before we start showing that state\n+                setTimeout(() => {\n+                  try {\n+                    checkLatest()\n+                    // Update the match and prematurely resolve the loadMatches promise so that\n+                    // the pending component can start rendering\n+                    triggerOnReady()\n+                  } catch {}\n+                }, pendingMs)\n+              }\n+\n+              const { paramsError, searchError } = getMatch()\n+\n+              if (paramsError) {\n+                handleSerialError(paramsError, 'PARSE_PARAMS')\n+              }\n+\n+              if (searchError) {\n+                handleSerialError(searchError, 'VALIDATE_SEARCH')\n+              }\n+\n+              try {",
        "comment_created_at": "2024-07-07T00:52:19+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Resolved in https://github.com/TanStack/router/pull/1908",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1457992705",
    "pr_number": 1001,
    "pr_file": "packages/react-router/src/router.ts",
    "created_at": "2024-01-18T21:24:57+00:00",
    "commented_code": "Wrap?: (props: { children: any }) => JSX.Element\n   InnerWrap?: (props: { children: any }) => JSX.Element\n   notFoundRoute?: AnyRoute\n+  serializeError?: (err: unknown) => Record<string, any>",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1457992705",
        "repo_full_name": "TanStack/router",
        "pr_number": 1001,
        "pr_file": "packages/react-router/src/router.ts",
        "discussion_id": "1457992705",
        "commented_code": "@@ -125,6 +125,8 @@ export interface RouterOptions<\n   Wrap?: (props: { children: any }) => JSX.Element\n   InnerWrap?: (props: { children: any }) => JSX.Element\n   notFoundRoute?: AnyRoute\n+  serializeError?: (err: unknown) => Record<string, any>",
        "comment_created_at": "2024-01-18T21:24:57+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "please document those new properties in docs/api/router/RouterOptionsType.md",
        "pr_file_module": null
      }
    ]
  }
]