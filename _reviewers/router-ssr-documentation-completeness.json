[
  {
    "discussion_id": "2217881910",
    "pr_number": 4703,
    "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
    "created_at": "2025-07-20T16:39:14+00:00",
    "commented_code": "+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217881910",
        "repo_full_name": "TanStack/router",
        "pr_number": 4703,
        "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
        "discussion_id": "2217881910",
        "commented_code": "@@ -0,0 +1,385 @@\n+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+",
        "comment_created_at": "2025-07-20T16:39:14+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "Can possible add some description to this section as well: \n\n\"When setting up server rendering, we need to ensure that vite builds both a client side and server side bundle. \nOur server and client bundles will be saved to, and served from, dist/server and dist/client respectively.\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217882354",
    "pr_number": 4703,
    "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
    "created_at": "2025-07-20T16:40:47+00:00",
    "commented_code": "+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217882354",
        "repo_full_name": "TanStack/router",
        "pr_number": 4703,
        "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
        "discussion_id": "2217882354",
        "commented_code": "@@ -0,0 +1,385 @@\n+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```",
        "comment_created_at": "2025-07-20T16:40:47+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "Could we align this to fit the examples:\n\n```ts\n// vite.config.ts\nimport path from \"node:path\";\nimport url from \"node:url\";\nimport { tanstackRouter } from \"@tanstack/router-plugin/vite\";\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport type { BuildEnvironmentOptions } from \"vite\";\n\nconst __filename = url.fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// SSR configuration\nconst ssrBuildConfig: BuildEnvironmentOptions = {\n\tssr: true,\n\toutDir: \"dist/server\",\n\tssrEmitAssets: true,\n\tcopyPublicDir: false,\n\temptyOutDir: true,\n\trollupOptions: {\n\t\tinput: path.resolve(__dirname, \"src/entry-server.tsx\"),\n\t\toutput: {\n\t\t\tentryFileNames: \"[name].js\",\n\t\t\tchunkFileNames: \"assets/[name]-[hash].js\",\n\t\t\tassetFileNames: \"assets/[name]-[hash][extname]\",\n\t\t},\n\t},\n};\n\n// Client-specific configuration\nconst clientBuildConfig: BuildEnvironmentOptions = {\n\toutDir: \"dist/client\",\n\temitAssets: true,\n\tcopyPublicDir: true,\n\temptyOutDir: true,\n\trollupOptions: {\n\t\tinput: path.resolve(__dirname, \"src/entry-client.tsx\"),\n\t\toutput: {\n\t\t\tentryFileNames: \"[name].js\",\n\t\t\tchunkFileNames: \"assets/[name]-[hash].js\",\n\t\t\tassetFileNames: \"assets/[name]-[hash][extname]\",\n\t\t},\n\t},\n};\n\n// https://vitejs.dev/config/\nexport default defineConfig((configEnv) => {\n\treturn {\n\t\tplugins: [\n\t\t\ttanstackRouter({ target: \"react\", autoCodeSplitting: true }),\n\t\t\treact(),\n\t\t],\n\t\tbuild: configEnv.isSsrBuild ? ssrBuildConfig : clientBuildConfig,\n\t};\n});\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217882925",
    "pr_number": 4703,
    "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
    "created_at": "2025-07-20T16:42:32+00:00",
    "commented_code": "+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217882925",
        "repo_full_name": "TanStack/router",
        "pr_number": 4703,
        "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
        "discussion_id": "2217882925",
        "commented_code": "@@ -0,0 +1,385 @@\n+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+",
        "comment_created_at": "2025-07-20T16:42:32+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "Following the above point, adding a section for updates to the root route to align the document to the examples:\r\n\r\n### 5. Update our root route\r\n\r\nSince the initial HTML document will be rendered on the server before being sent to the client, we can use the root route to provide all our HTML needs that we would usually include in our index.html.\r\n\r\n```tsx\r\n//src/routes/__root.tsx\r\nimport type { RouterContext } from \"@/routerContext\";\r\nimport {\r\n\tHeadContent,\r\n\tOutlet,\r\n\tcreateRootRouteWithContext,\r\n} from \"@tanstack/react-router\";\r\nimport { TanStackRouterDevtools } from \"@tanstack/react-router-devtools\";\r\nimport appCss from \"../App.css?url\";\r\n\r\nexport const Route = createRootRouteWithContext<RouterContext>()({\r\n\thead: () => ({\r\n\t\tlinks: [\r\n\t\t\t{ rel: \"icon\", href: \"/favicon.ico\" },\r\n\t\t\t{ rel: \"apple-touch-icon\", href: \"/logo192.png\" },\r\n\t\t\t{ rel: \"manifest\", href: \"/manifest.json\" },\r\n\t\t\t{ rel: \"stylesheet\", href: appCss },\r\n\t\t],\r\n\t\tmeta: [\r\n\t\t\t{\r\n\t\t\t\tname: \"theme-color\",\r\n\t\t\t\tcontent: \"#000000\",\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttitle: \"TanStack Router SSR File Based\",\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tcharSet: \"UTF-8\",\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tname: \"viewport\",\r\n\t\t\t\tcontent: \"width=device-width, initial-scale=1.0\",\r\n\t\t\t},\r\n\t\t],\r\n\t\tscripts: [\r\n\t\t\t...(!import.meta.env.PROD\r\n\t\t\t\t? [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype: \"module\",\r\n\t\t\t\t\t\tchildren: `import RefreshRuntime from \"/@react-refresh\"\r\n  \t\t\t\t\t\t\tRefreshRuntime.injectIntoGlobalHook(window)\r\n  \t\t\t\t\t\t\twindow.$RefreshReg$ = () => {}\r\n \t\t\t\t\t\t\twindow.$RefreshSig$ = () => (type) => type\r\n  \t\t\t\t\t\t\twindow.__vite_plugin_react_preamble_installed__ = true`,\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype: \"module\",\r\n\t\t\t\t\t\tsrc: \"/@vite/client\",\r\n\t\t\t\t\t},\r\n\t\t\t\t]\r\n\t\t\t\t: []),\r\n\t\t\t{\r\n\t\t\t\ttype: \"module\",\r\n\t\t\t\tsrc: import.meta.env.PROD\r\n\t\t\t\t\t? \"/entry-client.js\"\r\n\t\t\t\t\t: \"/src/entry-client.tsx\",\r\n\t\t\t},\r\n\t\t],\r\n\t}),\r\n\tcomponent: RootComponent,\r\n});\r\n\r\nfunction RootComponent() {\r\n\treturn (\r\n\t\t<html lang=\"en\">\r\n\t\t\t<head>\r\n\t\t\t\t<HeadContent />\r\n\t\t\t</head>\r\n\t\t\t<body>\r\n\t\t\t\t<Outlet />\r\n\t\t\t\t<TanStackRouterDevtools />\r\n\t\t\t</body>\r\n\t\t</html>\r\n\t);\r\n}\r\n```\r\n\r\nNow we can remove safely index.html and main.tsx\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217883898",
    "pr_number": 4703,
    "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
    "created_at": "2025-07-20T16:46:14+00:00",
    "commented_code": "+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+\n+### 5. Create Express Server\n+\n+```js\n+// server.js\n+import path from 'node:path'\n+import express from 'express'\n+import * as zlib from 'node:zlib'\n+\n+const isProduction = process.env.NODE_ENV === 'production'\n+\n+export async function createServer() {\n+  const app = express()\n+\n+  let vite\n+  if (!isProduction) {\n+    // Development: Use Vite dev server\n+    vite = await (\n+      await import('vite')\n+    ).createServer({\n+      server: { middlewareMode: true },\n+      appType: 'custom',\n+    })\n+    app.use(vite.middlewares)\n+  } else {\n+    // Production: Serve static files and use compression\n+    app.use(\n+      (await import('compression')).default({\n+        brotli: { flush: zlib.constants.BROTLI_OPERATION_FLUSH },\n+        flush: zlib.constants.Z_SYNC_FLUSH,\n+      }),\n+    )\n+    app.use(express.static('./dist/client'))\n+  }\n+\n+  app.use('*', async (req, res) => {\n+    try {\n+      const url = req.originalUrl\n+\n+      // Skip non-route requests\n+      if (path.extname(url) !== '') {\n+        console.warn(`${url} is not valid router path`)\n+        res.status(404).end(`${url} is not valid router path`)\n+        return\n+      }\n+\n+      // Extract head tags from Vite's transformation\n+      let viteHead = ''\n+      if (!isProduction) {\n+        const transformed = await vite.transformIndexHtml(\n+          url,\n+          `<html><head></head><body></body></html>`,\n+        )\n+        viteHead = transformed.substring(\n+          transformed.indexOf('<head>') + 6,\n+          transformed.indexOf('</head>'),\n+        )\n+      }\n+\n+      // Load entry module\n+      const entry = !isProduction\n+        ? await vite.ssrLoadModule('/src/entry-server.tsx')\n+        : await import('./dist/server/entry-server.js')\n+\n+      console.info('Rendering:', url)\n+      await entry.render({ req, res, head: viteHead })\n+    } catch (e) {\n+      !isProduction && vite.ssrFixStacktrace(e)\n+      console.error(e.stack)\n+      res.status(500).end(e.stack)\n+    }\n+  })\n+\n+  return { app, vite }\n+}\n+\n+// Start server\n+if (process.env.NODE_ENV !== 'test') {\n+  createServer().then(({ app }) => {\n+    app.listen(3000, () => {\n+      console.info('Server running at http://localhost:3000')\n+    })\n+  })\n+}\n+```\n+\n+### 6. Update Package Scripts\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"dev\": \"node server.js\",\n+    \"build\": \"npm run build:client && npm run build:server\",\n+    \"build:client\": \"vite build --outDir dist/client\",\n+    \"build:server\": \"vite build --ssr src/entry-server.tsx --outDir dist/server\",",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217883898",
        "repo_full_name": "TanStack/router",
        "pr_number": 4703,
        "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
        "discussion_id": "2217883898",
        "commented_code": "@@ -0,0 +1,385 @@\n+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+\n+### 5. Create Express Server\n+\n+```js\n+// server.js\n+import path from 'node:path'\n+import express from 'express'\n+import * as zlib from 'node:zlib'\n+\n+const isProduction = process.env.NODE_ENV === 'production'\n+\n+export async function createServer() {\n+  const app = express()\n+\n+  let vite\n+  if (!isProduction) {\n+    // Development: Use Vite dev server\n+    vite = await (\n+      await import('vite')\n+    ).createServer({\n+      server: { middlewareMode: true },\n+      appType: 'custom',\n+    })\n+    app.use(vite.middlewares)\n+  } else {\n+    // Production: Serve static files and use compression\n+    app.use(\n+      (await import('compression')).default({\n+        brotli: { flush: zlib.constants.BROTLI_OPERATION_FLUSH },\n+        flush: zlib.constants.Z_SYNC_FLUSH,\n+      }),\n+    )\n+    app.use(express.static('./dist/client'))\n+  }\n+\n+  app.use('*', async (req, res) => {\n+    try {\n+      const url = req.originalUrl\n+\n+      // Skip non-route requests\n+      if (path.extname(url) !== '') {\n+        console.warn(`${url} is not valid router path`)\n+        res.status(404).end(`${url} is not valid router path`)\n+        return\n+      }\n+\n+      // Extract head tags from Vite's transformation\n+      let viteHead = ''\n+      if (!isProduction) {\n+        const transformed = await vite.transformIndexHtml(\n+          url,\n+          `<html><head></head><body></body></html>`,\n+        )\n+        viteHead = transformed.substring(\n+          transformed.indexOf('<head>') + 6,\n+          transformed.indexOf('</head>'),\n+        )\n+      }\n+\n+      // Load entry module\n+      const entry = !isProduction\n+        ? await vite.ssrLoadModule('/src/entry-server.tsx')\n+        : await import('./dist/server/entry-server.js')\n+\n+      console.info('Rendering:', url)\n+      await entry.render({ req, res, head: viteHead })\n+    } catch (e) {\n+      !isProduction && vite.ssrFixStacktrace(e)\n+      console.error(e.stack)\n+      res.status(500).end(e.stack)\n+    }\n+  })\n+\n+  return { app, vite }\n+}\n+\n+// Start server\n+if (process.env.NODE_ENV !== 'test') {\n+  createServer().then(({ app }) => {\n+    app.listen(3000, () => {\n+      console.info('Server running at http://localhost:3000')\n+    })\n+  })\n+}\n+```\n+\n+### 6. Update Package Scripts\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"dev\": \"node server.js\",\n+    \"build\": \"npm run build:client && npm run build:server\",\n+    \"build:client\": \"vite build --outDir dist/client\",\n+    \"build:server\": \"vite build --ssr src/entry-server.tsx --outDir dist/server\",",
        "comment_created_at": "2025-07-20T16:46:14+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "given the change in the vite.config.ts this can be updated to:\n\n\t\t\"build:client\": \"vite build\",\n\t\t\"build:server\": \"vite build --ssr\",",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217884183",
    "pr_number": 4703,
    "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
    "created_at": "2025-07-20T16:47:34+00:00",
    "commented_code": "+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+\n+### 5. Create Express Server\n+\n+```js\n+// server.js\n+import path from 'node:path'\n+import express from 'express'\n+import * as zlib from 'node:zlib'\n+\n+const isProduction = process.env.NODE_ENV === 'production'\n+\n+export async function createServer() {\n+  const app = express()\n+\n+  let vite\n+  if (!isProduction) {\n+    // Development: Use Vite dev server\n+    vite = await (\n+      await import('vite')\n+    ).createServer({\n+      server: { middlewareMode: true },\n+      appType: 'custom',\n+    })\n+    app.use(vite.middlewares)\n+  } else {\n+    // Production: Serve static files and use compression\n+    app.use(\n+      (await import('compression')).default({\n+        brotli: { flush: zlib.constants.BROTLI_OPERATION_FLUSH },\n+        flush: zlib.constants.Z_SYNC_FLUSH,\n+      }),\n+    )\n+    app.use(express.static('./dist/client'))\n+  }\n+\n+  app.use('*', async (req, res) => {\n+    try {\n+      const url = req.originalUrl\n+\n+      // Skip non-route requests\n+      if (path.extname(url) !== '') {\n+        console.warn(`${url} is not valid router path`)\n+        res.status(404).end(`${url} is not valid router path`)\n+        return\n+      }\n+\n+      // Extract head tags from Vite's transformation\n+      let viteHead = ''\n+      if (!isProduction) {\n+        const transformed = await vite.transformIndexHtml(\n+          url,\n+          `<html><head></head><body></body></html>`,\n+        )\n+        viteHead = transformed.substring(\n+          transformed.indexOf('<head>') + 6,\n+          transformed.indexOf('</head>'),\n+        )\n+      }\n+\n+      // Load entry module\n+      const entry = !isProduction\n+        ? await vite.ssrLoadModule('/src/entry-server.tsx')\n+        : await import('./dist/server/entry-server.js')\n+\n+      console.info('Rendering:', url)\n+      await entry.render({ req, res, head: viteHead })\n+    } catch (e) {\n+      !isProduction && vite.ssrFixStacktrace(e)\n+      console.error(e.stack)\n+      res.status(500).end(e.stack)\n+    }\n+  })\n+\n+  return { app, vite }\n+}\n+\n+// Start server\n+if (process.env.NODE_ENV !== 'test') {\n+  createServer().then(({ app }) => {\n+    app.listen(3000, () => {\n+      console.info('Server running at http://localhost:3000')\n+    })\n+  })\n+}\n+```\n+\n+### 6. Update Package Scripts\n+",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217884183",
        "repo_full_name": "TanStack/router",
        "pr_number": 4703,
        "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
        "discussion_id": "2217884183",
        "commented_code": "@@ -0,0 +1,385 @@\n+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+\n+### 5. Create Express Server\n+\n+```js\n+// server.js\n+import path from 'node:path'\n+import express from 'express'\n+import * as zlib from 'node:zlib'\n+\n+const isProduction = process.env.NODE_ENV === 'production'\n+\n+export async function createServer() {\n+  const app = express()\n+\n+  let vite\n+  if (!isProduction) {\n+    // Development: Use Vite dev server\n+    vite = await (\n+      await import('vite')\n+    ).createServer({\n+      server: { middlewareMode: true },\n+      appType: 'custom',\n+    })\n+    app.use(vite.middlewares)\n+  } else {\n+    // Production: Serve static files and use compression\n+    app.use(\n+      (await import('compression')).default({\n+        brotli: { flush: zlib.constants.BROTLI_OPERATION_FLUSH },\n+        flush: zlib.constants.Z_SYNC_FLUSH,\n+      }),\n+    )\n+    app.use(express.static('./dist/client'))\n+  }\n+\n+  app.use('*', async (req, res) => {\n+    try {\n+      const url = req.originalUrl\n+\n+      // Skip non-route requests\n+      if (path.extname(url) !== '') {\n+        console.warn(`${url} is not valid router path`)\n+        res.status(404).end(`${url} is not valid router path`)\n+        return\n+      }\n+\n+      // Extract head tags from Vite's transformation\n+      let viteHead = ''\n+      if (!isProduction) {\n+        const transformed = await vite.transformIndexHtml(\n+          url,\n+          `<html><head></head><body></body></html>`,\n+        )\n+        viteHead = transformed.substring(\n+          transformed.indexOf('<head>') + 6,\n+          transformed.indexOf('</head>'),\n+        )\n+      }\n+\n+      // Load entry module\n+      const entry = !isProduction\n+        ? await vite.ssrLoadModule('/src/entry-server.tsx')\n+        : await import('./dist/server/entry-server.js')\n+\n+      console.info('Rendering:', url)\n+      await entry.render({ req, res, head: viteHead })\n+    } catch (e) {\n+      !isProduction && vite.ssrFixStacktrace(e)\n+      console.error(e.stack)\n+      res.status(500).end(e.stack)\n+    }\n+  })\n+\n+  return { app, vite }\n+}\n+\n+// Start server\n+if (process.env.NODE_ENV !== 'test') {\n+  createServer().then(({ app }) => {\n+    app.listen(3000, () => {\n+      console.info('Server running at http://localhost:3000')\n+    })\n+  })\n+}\n+```\n+\n+### 6. Update Package Scripts\n+",
        "comment_created_at": "2025-07-20T16:47:34+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "Maybe we can add a description here of the various scripts' purpose:\n\n\"The below update ensures that:\n1) During development our express server will serve the app using the vite dev server using vite middleware mode.\n2) Separate build processes are used for client and server bundles. \n3) In production, it will be served over the express server directly.\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217884918",
    "pr_number": 4703,
    "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
    "created_at": "2025-07-20T16:49:51+00:00",
    "commented_code": "+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+\n+### 5. Create Express Server\n+\n+```js\n+// server.js\n+import path from 'node:path'\n+import express from 'express'\n+import * as zlib from 'node:zlib'\n+\n+const isProduction = process.env.NODE_ENV === 'production'\n+\n+export async function createServer() {\n+  const app = express()\n+\n+  let vite\n+  if (!isProduction) {\n+    // Development: Use Vite dev server\n+    vite = await (\n+      await import('vite')\n+    ).createServer({\n+      server: { middlewareMode: true },\n+      appType: 'custom',\n+    })\n+    app.use(vite.middlewares)\n+  } else {\n+    // Production: Serve static files and use compression\n+    app.use(\n+      (await import('compression')).default({\n+        brotli: { flush: zlib.constants.BROTLI_OPERATION_FLUSH },\n+        flush: zlib.constants.Z_SYNC_FLUSH,\n+      }),\n+    )\n+    app.use(express.static('./dist/client'))\n+  }\n+\n+  app.use('*', async (req, res) => {\n+    try {\n+      const url = req.originalUrl\n+\n+      // Skip non-route requests\n+      if (path.extname(url) !== '') {\n+        console.warn(`${url} is not valid router path`)\n+        res.status(404).end(`${url} is not valid router path`)\n+        return\n+      }\n+\n+      // Extract head tags from Vite's transformation\n+      let viteHead = ''\n+      if (!isProduction) {\n+        const transformed = await vite.transformIndexHtml(\n+          url,\n+          `<html><head></head><body></body></html>`,\n+        )\n+        viteHead = transformed.substring(\n+          transformed.indexOf('<head>') + 6,\n+          transformed.indexOf('</head>'),\n+        )\n+      }\n+\n+      // Load entry module\n+      const entry = !isProduction\n+        ? await vite.ssrLoadModule('/src/entry-server.tsx')\n+        : await import('./dist/server/entry-server.js')\n+\n+      console.info('Rendering:', url)\n+      await entry.render({ req, res, head: viteHead })\n+    } catch (e) {\n+      !isProduction && vite.ssrFixStacktrace(e)\n+      console.error(e.stack)\n+      res.status(500).end(e.stack)\n+    }\n+  })\n+\n+  return { app, vite }\n+}\n+\n+// Start server\n+if (process.env.NODE_ENV !== 'test') {\n+  createServer().then(({ app }) => {\n+    app.listen(3000, () => {\n+      console.info('Server running at http://localhost:3000')\n+    })\n+  })\n+}\n+```\n+\n+### 6. Update Package Scripts\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"dev\": \"node server.js\",\n+    \"build\": \"npm run build:client && npm run build:server\",\n+    \"build:client\": \"vite build --outDir dist/client\",\n+    \"build:server\": \"vite build --ssr src/entry-server.tsx --outDir dist/server\",\n+    \"start\": \"NODE_ENV=production node server.js\"\n+  }\n+}\n+```\n+\n+## Streaming SSR\n+\n+Replace `renderRouterToString` with `renderRouterToStream` for better performance:\n+\n+```tsx\n+// src/entry-server.tsx\n+import { renderRouterToStream } from '@tanstack/react-router/ssr/server'\n+\n+const response = await handler(({ request, responseHeaders, router }) =>\n+  renderRouterToStream({\n+    request,\n+    responseHeaders,\n+    router,\n+    children: <RouterServer router={router} />,\n+  }),\n+)\n+```\n+\n+## Common Problems\n+\n+> [!TIP] > **Most of these problems are automatically solved by [TanStack Start](../guide/tanstack-start.md).** The issues below are primarily relevant for manual SSR setups.\n+\n+### React Import Errors\n+\n+**Problem:** `ReferenceError: React is not defined` during SSR\n+\n+**Solution:** Ensure React is properly imported in components:\n+\n+```tsx\n+// In your route components\n+import React from 'react' // Add explicit import\n+import { createFileRoute } from '@tanstack/react-router'\n+\n+export const Route = createFileRoute('/')({\n+  component: () => <div>Hello</div>, // React is now available\n+})\n+```\n+\n+### Hydration Mismatches\n+\n+**Problem:** Client HTML doesn't match server HTML\n+\n+**Solution:** Ensure consistent rendering between server and client:\n+\n+```tsx\n+// Use useIsomorphicLayoutEffect for browser-only effects\n+import { useLayoutEffect, useEffect } from 'react'\n+\n+const useIsomorphicLayoutEffect =\n+  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n+\n+function MyComponent() {\n+  useIsomorphicLayoutEffect(() => {\n+    // Browser-only code\n+  }, [])\n+}\n+```\n+\n+### Bun Runtime Issues\n+\n+**Problem:** `Cannot find module \"react-dom/server\"` with Bun\n+\n+**Solution:** Add Node.js compatibility or use Bun-specific builds:\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"build:bun\": \"bun build --target=bun --outdir=dist/bun src/entry-server.tsx\"\n+  }\n+}\n+```\n+\n+### Module Resolution Errors\n+\n+**Problem:** SSR modules not resolving correctly\n+\n+**Solution:** Configure Vite SSR externals:\n+\n+```ts\n+// vite.config.ts\n+export default defineConfig({\n+  ssr: {\n+    noExternal: [\n+      '@tanstack/react-router',\n+      // Add other packages that need to be bundled\n+    ],\n+    external: [\n+      // Add packages that should remain external\n+    ],\n+  },\n+})\n+```\n+\n+### Build Output Issues\n+\n+**Problem:** Server build missing dependencies\n+\n+**Solution:** Ensure correct Rollup input configuration:\n+\n+```ts\n+// vite.config.ts\n+export default defineConfig({\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+      output: {\n+        entryFileNames: (chunkInfo) => {\n+          return chunkInfo.name === 'server'\n+            ? '[name].js'\n+            : 'assets/[name]-[hash].js'\n+        },\n+      },\n+    },\n+  },\n+})\n+```",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2217884918",
        "repo_full_name": "TanStack/router",
        "pr_number": 4703,
        "pr_file": "docs/router/framework/react/how-to/setup-ssr.md",
        "discussion_id": "2217884918",
        "commented_code": "@@ -0,0 +1,385 @@\n+# How to Set Up Server-Side Rendering (SSR)\n+\n+> [!IMPORTANT] > **[TanStack Start](../guide/tanstack-start.md) is the recommended way to set up SSR** - it provides SSR, streaming, and deployment with zero configuration.\n+>\n+> Use the manual setup below only if you need to integrate with an existing server.\n+\n+## Quick Start with TanStack Start\n+\n+```bash\n+npx create-tsrouter-app@latest my-app --add-ons=start\n+cd my-app\n+npm run dev\n+```\n+\n+## Manual SSR Setup\n+\n+### 1. Create Shared Router Configuration\n+\n+```tsx\n+// src/router.tsx\n+import { createRouter as createTanstackRouter } from '@tanstack/react-router'\n+import { routeTree } from './routeTree.gen'\n+\n+export function createRouter() {\n+  return createTanstackRouter({\n+    routeTree,\n+    context: {\n+      head: '', // For server-side head injection\n+    },\n+    defaultPreload: 'intent',\n+    scrollRestoration: true,\n+  })\n+}\n+\n+declare module '@tanstack/react-router' {\n+  interface Register {\n+    router: ReturnType<typeof createRouter>\n+  }\n+}\n+```\n+\n+### 2. Set Up Server Entry Point\n+\n+```tsx\n+// src/entry-server.tsx\n+import { pipeline } from 'node:stream/promises'\n+import {\n+  RouterServer,\n+  createRequestHandler,\n+  renderRouterToString,\n+} from '@tanstack/react-router/ssr/server'\n+import { createRouter } from './router'\n+import type express from 'express'\n+\n+export async function render({\n+  req,\n+  res,\n+  head = '',\n+}: {\n+  head?: string\n+  req: express.Request\n+  res: express.Response\n+}) {\n+  // Convert Express request to Web API Request\n+  const url = new URL(req.originalUrl || req.url, 'https://localhost:3000').href\n+\n+  const request = new Request(url, {\n+    method: req.method,\n+    headers: (() => {\n+      const headers = new Headers()\n+      for (const [key, value] of Object.entries(req.headers)) {\n+        headers.set(key, value as any)\n+      }\n+      return headers\n+    })(),\n+  })\n+\n+  // Create request handler\n+  const handler = createRequestHandler({\n+    request,\n+    createRouter: () => {\n+      const router = createRouter()\n+\n+      // Inject server context (like head tags from Vite)\n+      router.update({\n+        context: {\n+          ...router.options.context,\n+          head: head,\n+        },\n+      })\n+      return router\n+    },\n+  })\n+\n+  // Render to string (non-streaming)\n+  const response = await handler(({ responseHeaders, router }) =>\n+    renderRouterToString({\n+      responseHeaders,\n+      router,\n+      children: <RouterServer router={router} />,\n+    }),\n+  )\n+\n+  // Convert Web API Response back to Express response\n+  res.statusMessage = response.statusText\n+  res.status(response.status)\n+\n+  response.headers.forEach((value, name) => {\n+    res.setHeader(name, value)\n+  })\n+\n+  // Stream response body\n+  return pipeline(response.body as any, res)\n+}\n+```\n+\n+### 3. Set Up Client Entry Point\n+\n+```tsx\n+// src/entry-client.tsx\n+import { hydrateRoot } from 'react-dom/client'\n+import { RouterClient } from '@tanstack/react-router/ssr/client'\n+import { createRouter } from './router'\n+\n+const router = createRouter()\n+\n+hydrateRoot(document, <RouterClient router={router} />)\n+```\n+\n+### 4. Configure Vite for SSR\n+\n+```ts\n+// vite.config.ts\n+import { defineConfig } from 'vite'\n+import react from '@vitejs/plugin-react'\n+import { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n+\n+export default defineConfig({\n+  plugins: [react(), TanStackRouterVite()],\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+    },\n+  },\n+  ssr: {\n+    noExternal: ['@tanstack/react-router'],\n+  },\n+})\n+```\n+\n+### 5. Create Express Server\n+\n+```js\n+// server.js\n+import path from 'node:path'\n+import express from 'express'\n+import * as zlib from 'node:zlib'\n+\n+const isProduction = process.env.NODE_ENV === 'production'\n+\n+export async function createServer() {\n+  const app = express()\n+\n+  let vite\n+  if (!isProduction) {\n+    // Development: Use Vite dev server\n+    vite = await (\n+      await import('vite')\n+    ).createServer({\n+      server: { middlewareMode: true },\n+      appType: 'custom',\n+    })\n+    app.use(vite.middlewares)\n+  } else {\n+    // Production: Serve static files and use compression\n+    app.use(\n+      (await import('compression')).default({\n+        brotli: { flush: zlib.constants.BROTLI_OPERATION_FLUSH },\n+        flush: zlib.constants.Z_SYNC_FLUSH,\n+      }),\n+    )\n+    app.use(express.static('./dist/client'))\n+  }\n+\n+  app.use('*', async (req, res) => {\n+    try {\n+      const url = req.originalUrl\n+\n+      // Skip non-route requests\n+      if (path.extname(url) !== '') {\n+        console.warn(`${url} is not valid router path`)\n+        res.status(404).end(`${url} is not valid router path`)\n+        return\n+      }\n+\n+      // Extract head tags from Vite's transformation\n+      let viteHead = ''\n+      if (!isProduction) {\n+        const transformed = await vite.transformIndexHtml(\n+          url,\n+          `<html><head></head><body></body></html>`,\n+        )\n+        viteHead = transformed.substring(\n+          transformed.indexOf('<head>') + 6,\n+          transformed.indexOf('</head>'),\n+        )\n+      }\n+\n+      // Load entry module\n+      const entry = !isProduction\n+        ? await vite.ssrLoadModule('/src/entry-server.tsx')\n+        : await import('./dist/server/entry-server.js')\n+\n+      console.info('Rendering:', url)\n+      await entry.render({ req, res, head: viteHead })\n+    } catch (e) {\n+      !isProduction && vite.ssrFixStacktrace(e)\n+      console.error(e.stack)\n+      res.status(500).end(e.stack)\n+    }\n+  })\n+\n+  return { app, vite }\n+}\n+\n+// Start server\n+if (process.env.NODE_ENV !== 'test') {\n+  createServer().then(({ app }) => {\n+    app.listen(3000, () => {\n+      console.info('Server running at http://localhost:3000')\n+    })\n+  })\n+}\n+```\n+\n+### 6. Update Package Scripts\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"dev\": \"node server.js\",\n+    \"build\": \"npm run build:client && npm run build:server\",\n+    \"build:client\": \"vite build --outDir dist/client\",\n+    \"build:server\": \"vite build --ssr src/entry-server.tsx --outDir dist/server\",\n+    \"start\": \"NODE_ENV=production node server.js\"\n+  }\n+}\n+```\n+\n+## Streaming SSR\n+\n+Replace `renderRouterToString` with `renderRouterToStream` for better performance:\n+\n+```tsx\n+// src/entry-server.tsx\n+import { renderRouterToStream } from '@tanstack/react-router/ssr/server'\n+\n+const response = await handler(({ request, responseHeaders, router }) =>\n+  renderRouterToStream({\n+    request,\n+    responseHeaders,\n+    router,\n+    children: <RouterServer router={router} />,\n+  }),\n+)\n+```\n+\n+## Common Problems\n+\n+> [!TIP] > **Most of these problems are automatically solved by [TanStack Start](../guide/tanstack-start.md).** The issues below are primarily relevant for manual SSR setups.\n+\n+### React Import Errors\n+\n+**Problem:** `ReferenceError: React is not defined` during SSR\n+\n+**Solution:** Ensure React is properly imported in components:\n+\n+```tsx\n+// In your route components\n+import React from 'react' // Add explicit import\n+import { createFileRoute } from '@tanstack/react-router'\n+\n+export const Route = createFileRoute('/')({\n+  component: () => <div>Hello</div>, // React is now available\n+})\n+```\n+\n+### Hydration Mismatches\n+\n+**Problem:** Client HTML doesn't match server HTML\n+\n+**Solution:** Ensure consistent rendering between server and client:\n+\n+```tsx\n+// Use useIsomorphicLayoutEffect for browser-only effects\n+import { useLayoutEffect, useEffect } from 'react'\n+\n+const useIsomorphicLayoutEffect =\n+  typeof window !== 'undefined' ? useLayoutEffect : useEffect\n+\n+function MyComponent() {\n+  useIsomorphicLayoutEffect(() => {\n+    // Browser-only code\n+  }, [])\n+}\n+```\n+\n+### Bun Runtime Issues\n+\n+**Problem:** `Cannot find module \"react-dom/server\"` with Bun\n+\n+**Solution:** Add Node.js compatibility or use Bun-specific builds:\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"build:bun\": \"bun build --target=bun --outdir=dist/bun src/entry-server.tsx\"\n+  }\n+}\n+```\n+\n+### Module Resolution Errors\n+\n+**Problem:** SSR modules not resolving correctly\n+\n+**Solution:** Configure Vite SSR externals:\n+\n+```ts\n+// vite.config.ts\n+export default defineConfig({\n+  ssr: {\n+    noExternal: [\n+      '@tanstack/react-router',\n+      // Add other packages that need to be bundled\n+    ],\n+    external: [\n+      // Add packages that should remain external\n+    ],\n+  },\n+})\n+```\n+\n+### Build Output Issues\n+\n+**Problem:** Server build missing dependencies\n+\n+**Solution:** Ensure correct Rollup input configuration:\n+\n+```ts\n+// vite.config.ts\n+export default defineConfig({\n+  build: {\n+    rollupOptions: {\n+      input: {\n+        main: './index.html',\n+        server: './src/entry-server.tsx',\n+      },\n+      output: {\n+        entryFileNames: (chunkInfo) => {\n+          return chunkInfo.name === 'server'\n+            ? '[name].js'\n+            : 'assets/[name]-[hash].js'\n+        },\n+      },\n+    },\n+  },\n+})\n+```",
        "comment_created_at": "2025-07-20T16:49:51+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "given above vite.config.ts change:\n\n```ts\n// vite.config.ts\n\n// SSR configuration\nconst ssrBuildConfig: BuildEnvironmentOptions = {\n    // server specific config is specified here \n\trollupOptions: {\n\t\tinput: path.resolve(__dirname, \"src/entry-server.tsx\"),\n\t\toutput: {\n\t\t\tentryFileNames: \"[name].js\",\n\t\t\tchunkFileNames: \"assets/[name]-[hash].js\",\n\t\t\tassetFileNames: \"assets/[name]-[hash][extname]\",\n\t\t},\n\t},\n};\n\n// Client-specific configuration\nconst clientBuildConfig: BuildEnvironmentOptions = {\n    // client specific config is specified here\n\trollupOptions: {\n\t\tinput: path.resolve(__dirname, \"src/entry-client.tsx\"),\n\t\toutput: {\n\t\t\tentryFileNames: \"[name].js\",\n\t\t\tchunkFileNames: \"assets/[name]-[hash].js\",\n\t\t\tassetFileNames: \"assets/[name]-[hash][extname]\",\n\t\t},\n\t},\n};\n\nexport default defineConfig((configEnv) => {\n\treturn {\n\t\t// global config is specified here\n\t\tbuild: configEnv.isSsrBuild ? ssrBuildConfig : clientBuildConfig,\n\t};\n});\n\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174922736",
    "pr_number": 4305,
    "pr_file": "docs/start/framework/react/integrate-better-auth.md",
    "created_at": "2025-06-30T12:08:08+00:00",
    "commented_code": "+---\n+id: integrate-better-auth\n+title: Integrate Better Auth\n+---\n+\n+> [!IMPORTANT]\n+> This guide is based on the upcoming work in the `alpha` branch of **TanStack Start**. We are actively working on exciting new features, and this guide will be updated soon.\n+\n+This guide provides a step-by-step process to integrate [Better Auth](https://better-auth.com) with **TanStack Start**. We respect the powerful features of Better Auth and aim to make this implementation as smooth as possible.\n+\n+## Step-by-Step\n+\n+This step-by-step guide provides an overview of how to integrate Better Auth with TanStack Start using a starter template. The goal is to help you understand the basic steps involved in the implementation process so you can adapt them to your specific project needs.\n+\n+### Prerequisites\n+\n+Before we begin, this guide assumes your project structure looks like this:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+Alternatively, you can follow along by cloning the following [starter template](https://github.com/nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start):\n+\n+```sh\n+npx gitpick nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start better-start\n+```\n+\n+This structure or starter is a basic TanStack Start application, which we will integrate with TanStack Start.\n+\n+![Image](https://github.com/user-attachments/assets/322f37b9-1af1-4082-bc88-56d270d684c5)\n+\n+### 1. Install Required Dependencies\n+\n+```sh\n+npm i better-auth drizzle-orm postgres\n+npm i -D drizzle-kit\n+```\n+\n+### 2. Configure Environment Variables\n+\n+```txt\n+# .env\n+\n+BETTER_AUTH_URL=http://localhost:3000\n+# can be generated using `npx nanoid`\n+BETTER_AUTH_SECRET=\n+# can be generated using `npx pglaunch`\n+POSTGRES_URL=\n+\n+GITHUB_CLIENT_ID=\n+GITHUB_CLIENT_SECRET=\n+```\n+\n+<!-- CAN CALLOUT TO SPONSER LIKE NEON FOR POSTGRES IN PRODUCTION -->\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 3. Configure Drizzle ORM\n+\n+```ts\n+// drizzle.config.ts\n+\n+import { defineConfig } from 'drizzle-kit'\n+\n+export default defineConfig({\n+  dialect: 'postgresql',\n+  dbCredentials: {\n+    url: process.env.POSTGRES_URL!,\n+  },\n+  schema: 'src/db/schema',\n+  out: 'src/db/drizzle',\n+})\n+```\n+\n+```ts\n+// src/db/index.ts\n+\n+import { drizzle, type PostgresJsDatabase } from 'drizzle-orm/postgres-js'\n+import postgres from 'postgres'\n+\n+declare global {\n+  var db: PostgresJsDatabase\n+}\n+\n+let db: PostgresJsDatabase\n+\n+if (process.env.NODE_ENV === 'production') {\n+  db = drizzle({\n+    client: postgres(process.env.POSTGRES_URL!, {\n+      ssl: {\n+        rejectUnauthorized: true,\n+      },\n+    }),\n+  })\n+} else {\n+  if (!global.db) {\n+    global.db = drizzle({\n+      client: postgres(process.env.POSTGRES_URL!),\n+    })\n+  }\n+  db = global.db\n+}\n+\n+export { db }\n+```\n+\n+```ts\n+// src/db/schema/auth.ts\n+\n+import { boolean, pgTable, text, timestamp } from 'drizzle-orm/pg-core'\n+\n+export const user = pgTable('user', {\n+  id: text('id').primaryKey(),\n+  name: text('name').notNull(),\n+  email: text('email').notNull().unique(),\n+  emailVerified: boolean('email_verified')\n+    .$defaultFn(() => false)\n+    .notNull(),\n+  image: text('image'),\n+  createdAt: timestamp('created_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+  updatedAt: timestamp('updated_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+})\n+\n+export const session = pgTable('session', {\n+  id: text('id').primaryKey(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  token: text('token').notNull().unique(),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+  ipAddress: text('ip_address'),\n+  userAgent: text('user_agent'),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+})\n+\n+export const account = pgTable('account', {\n+  id: text('id').primaryKey(),\n+  accountId: text('account_id').notNull(),\n+  providerId: text('provider_id').notNull(),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+  accessToken: text('access_token'),\n+  refreshToken: text('refresh_token'),\n+  idToken: text('id_token'),\n+  accessTokenExpiresAt: timestamp('access_token_expires_at'),\n+  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),\n+  scope: text('scope'),\n+  password: text('password'),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+})\n+\n+export const verification = pgTable('verification', {\n+  id: text('id').primaryKey(),\n+  identifier: text('identifier').notNull(),\n+  value: text('value').notNull(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  createdAt: timestamp('created_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+  updatedAt: timestamp('updated_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+})\n+```\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env\n+\u251c\u2500\u2500 drizzle.config.ts // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u251c\u2500\u2500 db/\n+    \u2502   \u251c\u2500\u2500 index.ts // [!code ++]\n+    \u2502   \u2514\u2500\u2500 schema/\n+    \u2502       \u2514\u2500\u2500 auth.ts // [!code ++]\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 4. Configure Better Auth\n+\n+```ts\n+// src/lib/auth/index.ts\n+\n+import { db } from '@/db'\n+import { account, session, user, verification } from '@/db/schema/auth'\n+import { betterAuth } from 'better-auth'\n+import { drizzleAdapter } from 'better-auth/adapters/drizzle'\n+import { reactStartCookies } from 'better-auth/react-start'\n+\n+export const auth = betterAuth({\n+  database: drizzleAdapter(db, {\n+    provider: 'pg',\n+    schema: {\n+      user,\n+      session,\n+      account,\n+      verification,\n+    },\n+  }),\n+  socialProviders: {\n+    github: {\n+      clientId: process.env.GITHUB_CLIENT_ID!,\n+      clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n+    },\n+  },\n+  plugins: [reactStartCookies()],\n+})\n+```\n+\n+```ts\n+// src/lib/auth/client.ts\n+\n+import { createAuthClient } from 'better-auth/react'\n+\n+export const { signIn, signOut, useSession } = createAuthClient()\n+```\n+\n+```ts\n+// src/routes/api/auth/$.ts\n+\n+import { auth } from '@/lib/auth'\n+\n+export const ServerRoute = createServerFileRoute().methods({",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2174922736",
        "repo_full_name": "TanStack/router",
        "pr_number": 4305,
        "pr_file": "docs/start/framework/react/integrate-better-auth.md",
        "discussion_id": "2174922736",
        "commented_code": "@@ -0,0 +1,489 @@\n+---\n+id: integrate-better-auth\n+title: Integrate Better Auth\n+---\n+\n+> [!IMPORTANT]\n+> This guide is based on the upcoming work in the `alpha` branch of **TanStack Start**. We are actively working on exciting new features, and this guide will be updated soon.\n+\n+This guide provides a step-by-step process to integrate [Better Auth](https://better-auth.com) with **TanStack Start**. We respect the powerful features of Better Auth and aim to make this implementation as smooth as possible.\n+\n+## Step-by-Step\n+\n+This step-by-step guide provides an overview of how to integrate Better Auth with TanStack Start using a starter template. The goal is to help you understand the basic steps involved in the implementation process so you can adapt them to your specific project needs.\n+\n+### Prerequisites\n+\n+Before we begin, this guide assumes your project structure looks like this:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+Alternatively, you can follow along by cloning the following [starter template](https://github.com/nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start):\n+\n+```sh\n+npx gitpick nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start better-start\n+```\n+\n+This structure or starter is a basic TanStack Start application, which we will integrate with TanStack Start.\n+\n+![Image](https://github.com/user-attachments/assets/322f37b9-1af1-4082-bc88-56d270d684c5)\n+\n+### 1. Install Required Dependencies\n+\n+```sh\n+npm i better-auth drizzle-orm postgres\n+npm i -D drizzle-kit\n+```\n+\n+### 2. Configure Environment Variables\n+\n+```txt\n+# .env\n+\n+BETTER_AUTH_URL=http://localhost:3000\n+# can be generated using `npx nanoid`\n+BETTER_AUTH_SECRET=\n+# can be generated using `npx pglaunch`\n+POSTGRES_URL=\n+\n+GITHUB_CLIENT_ID=\n+GITHUB_CLIENT_SECRET=\n+```\n+\n+<!-- CAN CALLOUT TO SPONSER LIKE NEON FOR POSTGRES IN PRODUCTION -->\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 3. Configure Drizzle ORM\n+\n+```ts\n+// drizzle.config.ts\n+\n+import { defineConfig } from 'drizzle-kit'\n+\n+export default defineConfig({\n+  dialect: 'postgresql',\n+  dbCredentials: {\n+    url: process.env.POSTGRES_URL!,\n+  },\n+  schema: 'src/db/schema',\n+  out: 'src/db/drizzle',\n+})\n+```\n+\n+```ts\n+// src/db/index.ts\n+\n+import { drizzle, type PostgresJsDatabase } from 'drizzle-orm/postgres-js'\n+import postgres from 'postgres'\n+\n+declare global {\n+  var db: PostgresJsDatabase\n+}\n+\n+let db: PostgresJsDatabase\n+\n+if (process.env.NODE_ENV === 'production') {\n+  db = drizzle({\n+    client: postgres(process.env.POSTGRES_URL!, {\n+      ssl: {\n+        rejectUnauthorized: true,\n+      },\n+    }),\n+  })\n+} else {\n+  if (!global.db) {\n+    global.db = drizzle({\n+      client: postgres(process.env.POSTGRES_URL!),\n+    })\n+  }\n+  db = global.db\n+}\n+\n+export { db }\n+```\n+\n+```ts\n+// src/db/schema/auth.ts\n+\n+import { boolean, pgTable, text, timestamp } from 'drizzle-orm/pg-core'\n+\n+export const user = pgTable('user', {\n+  id: text('id').primaryKey(),\n+  name: text('name').notNull(),\n+  email: text('email').notNull().unique(),\n+  emailVerified: boolean('email_verified')\n+    .$defaultFn(() => false)\n+    .notNull(),\n+  image: text('image'),\n+  createdAt: timestamp('created_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+  updatedAt: timestamp('updated_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+})\n+\n+export const session = pgTable('session', {\n+  id: text('id').primaryKey(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  token: text('token').notNull().unique(),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+  ipAddress: text('ip_address'),\n+  userAgent: text('user_agent'),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+})\n+\n+export const account = pgTable('account', {\n+  id: text('id').primaryKey(),\n+  accountId: text('account_id').notNull(),\n+  providerId: text('provider_id').notNull(),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+  accessToken: text('access_token'),\n+  refreshToken: text('refresh_token'),\n+  idToken: text('id_token'),\n+  accessTokenExpiresAt: timestamp('access_token_expires_at'),\n+  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),\n+  scope: text('scope'),\n+  password: text('password'),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+})\n+\n+export const verification = pgTable('verification', {\n+  id: text('id').primaryKey(),\n+  identifier: text('identifier').notNull(),\n+  value: text('value').notNull(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  createdAt: timestamp('created_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+  updatedAt: timestamp('updated_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+})\n+```\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env\n+\u251c\u2500\u2500 drizzle.config.ts // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u251c\u2500\u2500 db/\n+    \u2502   \u251c\u2500\u2500 index.ts // [!code ++]\n+    \u2502   \u2514\u2500\u2500 schema/\n+    \u2502       \u2514\u2500\u2500 auth.ts // [!code ++]\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 4. Configure Better Auth\n+\n+```ts\n+// src/lib/auth/index.ts\n+\n+import { db } from '@/db'\n+import { account, session, user, verification } from '@/db/schema/auth'\n+import { betterAuth } from 'better-auth'\n+import { drizzleAdapter } from 'better-auth/adapters/drizzle'\n+import { reactStartCookies } from 'better-auth/react-start'\n+\n+export const auth = betterAuth({\n+  database: drizzleAdapter(db, {\n+    provider: 'pg',\n+    schema: {\n+      user,\n+      session,\n+      account,\n+      verification,\n+    },\n+  }),\n+  socialProviders: {\n+    github: {\n+      clientId: process.env.GITHUB_CLIENT_ID!,\n+      clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n+    },\n+  },\n+  plugins: [reactStartCookies()],\n+})\n+```\n+\n+```ts\n+// src/lib/auth/client.ts\n+\n+import { createAuthClient } from 'better-auth/react'\n+\n+export const { signIn, signOut, useSession } = createAuthClient()\n+```\n+\n+```ts\n+// src/routes/api/auth/$.ts\n+\n+import { auth } from '@/lib/auth'\n+\n+export const ServerRoute = createServerFileRoute().methods({",
        "comment_created_at": "2025-06-30T12:08:08+00:00",
        "comment_author": "max-programming",
        "comment_body": "The `createServerFileRoute` function should have the server route path in it\r\n\r\n```suggestion\r\nexport const ServerRoute = createServerFileRoute('/api/auth/$').methods({\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2210825065",
        "repo_full_name": "TanStack/router",
        "pr_number": 4305,
        "pr_file": "docs/start/framework/react/integrate-better-auth.md",
        "discussion_id": "2174922736",
        "commented_code": "@@ -0,0 +1,489 @@\n+---\n+id: integrate-better-auth\n+title: Integrate Better Auth\n+---\n+\n+> [!IMPORTANT]\n+> This guide is based on the upcoming work in the `alpha` branch of **TanStack Start**. We are actively working on exciting new features, and this guide will be updated soon.\n+\n+This guide provides a step-by-step process to integrate [Better Auth](https://better-auth.com) with **TanStack Start**. We respect the powerful features of Better Auth and aim to make this implementation as smooth as possible.\n+\n+## Step-by-Step\n+\n+This step-by-step guide provides an overview of how to integrate Better Auth with TanStack Start using a starter template. The goal is to help you understand the basic steps involved in the implementation process so you can adapt them to your specific project needs.\n+\n+### Prerequisites\n+\n+Before we begin, this guide assumes your project structure looks like this:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+Alternatively, you can follow along by cloning the following [starter template](https://github.com/nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start):\n+\n+```sh\n+npx gitpick nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start better-start\n+```\n+\n+This structure or starter is a basic TanStack Start application, which we will integrate with TanStack Start.\n+\n+![Image](https://github.com/user-attachments/assets/322f37b9-1af1-4082-bc88-56d270d684c5)\n+\n+### 1. Install Required Dependencies\n+\n+```sh\n+npm i better-auth drizzle-orm postgres\n+npm i -D drizzle-kit\n+```\n+\n+### 2. Configure Environment Variables\n+\n+```txt\n+# .env\n+\n+BETTER_AUTH_URL=http://localhost:3000\n+# can be generated using `npx nanoid`\n+BETTER_AUTH_SECRET=\n+# can be generated using `npx pglaunch`\n+POSTGRES_URL=\n+\n+GITHUB_CLIENT_ID=\n+GITHUB_CLIENT_SECRET=\n+```\n+\n+<!-- CAN CALLOUT TO SPONSER LIKE NEON FOR POSTGRES IN PRODUCTION -->\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 3. Configure Drizzle ORM\n+\n+```ts\n+// drizzle.config.ts\n+\n+import { defineConfig } from 'drizzle-kit'\n+\n+export default defineConfig({\n+  dialect: 'postgresql',\n+  dbCredentials: {\n+    url: process.env.POSTGRES_URL!,\n+  },\n+  schema: 'src/db/schema',\n+  out: 'src/db/drizzle',\n+})\n+```\n+\n+```ts\n+// src/db/index.ts\n+\n+import { drizzle, type PostgresJsDatabase } from 'drizzle-orm/postgres-js'\n+import postgres from 'postgres'\n+\n+declare global {\n+  var db: PostgresJsDatabase\n+}\n+\n+let db: PostgresJsDatabase\n+\n+if (process.env.NODE_ENV === 'production') {\n+  db = drizzle({\n+    client: postgres(process.env.POSTGRES_URL!, {\n+      ssl: {\n+        rejectUnauthorized: true,\n+      },\n+    }),\n+  })\n+} else {\n+  if (!global.db) {\n+    global.db = drizzle({\n+      client: postgres(process.env.POSTGRES_URL!),\n+    })\n+  }\n+  db = global.db\n+}\n+\n+export { db }\n+```\n+\n+```ts\n+// src/db/schema/auth.ts\n+\n+import { boolean, pgTable, text, timestamp } from 'drizzle-orm/pg-core'\n+\n+export const user = pgTable('user', {\n+  id: text('id').primaryKey(),\n+  name: text('name').notNull(),\n+  email: text('email').notNull().unique(),\n+  emailVerified: boolean('email_verified')\n+    .$defaultFn(() => false)\n+    .notNull(),\n+  image: text('image'),\n+  createdAt: timestamp('created_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+  updatedAt: timestamp('updated_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+})\n+\n+export const session = pgTable('session', {\n+  id: text('id').primaryKey(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  token: text('token').notNull().unique(),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+  ipAddress: text('ip_address'),\n+  userAgent: text('user_agent'),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+})\n+\n+export const account = pgTable('account', {\n+  id: text('id').primaryKey(),\n+  accountId: text('account_id').notNull(),\n+  providerId: text('provider_id').notNull(),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+  accessToken: text('access_token'),\n+  refreshToken: text('refresh_token'),\n+  idToken: text('id_token'),\n+  accessTokenExpiresAt: timestamp('access_token_expires_at'),\n+  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),\n+  scope: text('scope'),\n+  password: text('password'),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+})\n+\n+export const verification = pgTable('verification', {\n+  id: text('id').primaryKey(),\n+  identifier: text('identifier').notNull(),\n+  value: text('value').notNull(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  createdAt: timestamp('created_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+  updatedAt: timestamp('updated_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+})\n+```\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env\n+\u251c\u2500\u2500 drizzle.config.ts // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u251c\u2500\u2500 db/\n+    \u2502   \u251c\u2500\u2500 index.ts // [!code ++]\n+    \u2502   \u2514\u2500\u2500 schema/\n+    \u2502       \u2514\u2500\u2500 auth.ts // [!code ++]\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 4. Configure Better Auth\n+\n+```ts\n+// src/lib/auth/index.ts\n+\n+import { db } from '@/db'\n+import { account, session, user, verification } from '@/db/schema/auth'\n+import { betterAuth } from 'better-auth'\n+import { drizzleAdapter } from 'better-auth/adapters/drizzle'\n+import { reactStartCookies } from 'better-auth/react-start'\n+\n+export const auth = betterAuth({\n+  database: drizzleAdapter(db, {\n+    provider: 'pg',\n+    schema: {\n+      user,\n+      session,\n+      account,\n+      verification,\n+    },\n+  }),\n+  socialProviders: {\n+    github: {\n+      clientId: process.env.GITHUB_CLIENT_ID!,\n+      clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n+    },\n+  },\n+  plugins: [reactStartCookies()],\n+})\n+```\n+\n+```ts\n+// src/lib/auth/client.ts\n+\n+import { createAuthClient } from 'better-auth/react'\n+\n+export const { signIn, signOut, useSession } = createAuthClient()\n+```\n+\n+```ts\n+// src/routes/api/auth/$.ts\n+\n+import { auth } from '@/lib/auth'\n+\n+export const ServerRoute = createServerFileRoute().methods({",
        "comment_created_at": "2025-07-16T15:49:37+00:00",
        "comment_author": "nrjdalal",
        "comment_body": "should be before, not in alpha I guess",
        "pr_file_module": null
      },
      {
        "comment_id": "2211012908",
        "repo_full_name": "TanStack/router",
        "pr_number": 4305,
        "pr_file": "docs/start/framework/react/integrate-better-auth.md",
        "discussion_id": "2174922736",
        "commented_code": "@@ -0,0 +1,489 @@\n+---\n+id: integrate-better-auth\n+title: Integrate Better Auth\n+---\n+\n+> [!IMPORTANT]\n+> This guide is based on the upcoming work in the `alpha` branch of **TanStack Start**. We are actively working on exciting new features, and this guide will be updated soon.\n+\n+This guide provides a step-by-step process to integrate [Better Auth](https://better-auth.com) with **TanStack Start**. We respect the powerful features of Better Auth and aim to make this implementation as smooth as possible.\n+\n+## Step-by-Step\n+\n+This step-by-step guide provides an overview of how to integrate Better Auth with TanStack Start using a starter template. The goal is to help you understand the basic steps involved in the implementation process so you can adapt them to your specific project needs.\n+\n+### Prerequisites\n+\n+Before we begin, this guide assumes your project structure looks like this:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+Alternatively, you can follow along by cloning the following [starter template](https://github.com/nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start):\n+\n+```sh\n+npx gitpick nrjdalal/awesome-templates/tree/main/tanstack-apps/tanstack-start better-start\n+```\n+\n+This structure or starter is a basic TanStack Start application, which we will integrate with TanStack Start.\n+\n+![Image](https://github.com/user-attachments/assets/322f37b9-1af1-4082-bc88-56d270d684c5)\n+\n+### 1. Install Required Dependencies\n+\n+```sh\n+npm i better-auth drizzle-orm postgres\n+npm i -D drizzle-kit\n+```\n+\n+### 2. Configure Environment Variables\n+\n+```txt\n+# .env\n+\n+BETTER_AUTH_URL=http://localhost:3000\n+# can be generated using `npx nanoid`\n+BETTER_AUTH_SECRET=\n+# can be generated using `npx pglaunch`\n+POSTGRES_URL=\n+\n+GITHUB_CLIENT_ID=\n+GITHUB_CLIENT_SECRET=\n+```\n+\n+<!-- CAN CALLOUT TO SPONSER LIKE NEON FOR POSTGRES IN PRODUCTION -->\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 3. Configure Drizzle ORM\n+\n+```ts\n+// drizzle.config.ts\n+\n+import { defineConfig } from 'drizzle-kit'\n+\n+export default defineConfig({\n+  dialect: 'postgresql',\n+  dbCredentials: {\n+    url: process.env.POSTGRES_URL!,\n+  },\n+  schema: 'src/db/schema',\n+  out: 'src/db/drizzle',\n+})\n+```\n+\n+```ts\n+// src/db/index.ts\n+\n+import { drizzle, type PostgresJsDatabase } from 'drizzle-orm/postgres-js'\n+import postgres from 'postgres'\n+\n+declare global {\n+  var db: PostgresJsDatabase\n+}\n+\n+let db: PostgresJsDatabase\n+\n+if (process.env.NODE_ENV === 'production') {\n+  db = drizzle({\n+    client: postgres(process.env.POSTGRES_URL!, {\n+      ssl: {\n+        rejectUnauthorized: true,\n+      },\n+    }),\n+  })\n+} else {\n+  if (!global.db) {\n+    global.db = drizzle({\n+      client: postgres(process.env.POSTGRES_URL!),\n+    })\n+  }\n+  db = global.db\n+}\n+\n+export { db }\n+```\n+\n+```ts\n+// src/db/schema/auth.ts\n+\n+import { boolean, pgTable, text, timestamp } from 'drizzle-orm/pg-core'\n+\n+export const user = pgTable('user', {\n+  id: text('id').primaryKey(),\n+  name: text('name').notNull(),\n+  email: text('email').notNull().unique(),\n+  emailVerified: boolean('email_verified')\n+    .$defaultFn(() => false)\n+    .notNull(),\n+  image: text('image'),\n+  createdAt: timestamp('created_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+  updatedAt: timestamp('updated_at')\n+    .$defaultFn(() => /* @__PURE__ */ new Date())\n+    .notNull(),\n+})\n+\n+export const session = pgTable('session', {\n+  id: text('id').primaryKey(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  token: text('token').notNull().unique(),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+  ipAddress: text('ip_address'),\n+  userAgent: text('user_agent'),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+})\n+\n+export const account = pgTable('account', {\n+  id: text('id').primaryKey(),\n+  accountId: text('account_id').notNull(),\n+  providerId: text('provider_id').notNull(),\n+  userId: text('user_id')\n+    .notNull()\n+    .references(() => user.id, { onDelete: 'cascade' }),\n+  accessToken: text('access_token'),\n+  refreshToken: text('refresh_token'),\n+  idToken: text('id_token'),\n+  accessTokenExpiresAt: timestamp('access_token_expires_at'),\n+  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),\n+  scope: text('scope'),\n+  password: text('password'),\n+  createdAt: timestamp('created_at').notNull(),\n+  updatedAt: timestamp('updated_at').notNull(),\n+})\n+\n+export const verification = pgTable('verification', {\n+  id: text('id').primaryKey(),\n+  identifier: text('identifier').notNull(),\n+  value: text('value').notNull(),\n+  expiresAt: timestamp('expires_at').notNull(),\n+  createdAt: timestamp('created_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+  updatedAt: timestamp('updated_at').$defaultFn(\n+    () => /* @__PURE__ */ new Date(),\n+  ),\n+})\n+```\n+\n+Updated project structure:\n+\n+```txt\n+.\n+\u251c\u2500\u2500 .env\n+\u251c\u2500\u2500 drizzle.config.ts // [!code ++]\n+\u251c\u2500\u2500 package.json\n+\u251c\u2500\u2500 README.md\n+\u251c\u2500\u2500 tsconfig.json\n+\u251c\u2500\u2500 vite.config.ts\n+\u2514\u2500\u2500 src/\n+    \u251c\u2500\u2500 router.tsx\n+    \u251c\u2500\u2500 db/\n+    \u2502   \u251c\u2500\u2500 index.ts // [!code ++]\n+    \u2502   \u2514\u2500\u2500 schema/\n+    \u2502       \u2514\u2500\u2500 auth.ts // [!code ++]\n+    \u2514\u2500\u2500 routes/\n+        \u251c\u2500\u2500 __root.tsx\n+        \u251c\u2500\u2500 globals.css\n+        \u2514\u2500\u2500 index.tsx\n+```\n+\n+### 4. Configure Better Auth\n+\n+```ts\n+// src/lib/auth/index.ts\n+\n+import { db } from '@/db'\n+import { account, session, user, verification } from '@/db/schema/auth'\n+import { betterAuth } from 'better-auth'\n+import { drizzleAdapter } from 'better-auth/adapters/drizzle'\n+import { reactStartCookies } from 'better-auth/react-start'\n+\n+export const auth = betterAuth({\n+  database: drizzleAdapter(db, {\n+    provider: 'pg',\n+    schema: {\n+      user,\n+      session,\n+      account,\n+      verification,\n+    },\n+  }),\n+  socialProviders: {\n+    github: {\n+      clientId: process.env.GITHUB_CLIENT_ID!,\n+      clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n+    },\n+  },\n+  plugins: [reactStartCookies()],\n+})\n+```\n+\n+```ts\n+// src/lib/auth/client.ts\n+\n+import { createAuthClient } from 'better-auth/react'\n+\n+export const { signIn, signOut, useSession } = createAuthClient()\n+```\n+\n+```ts\n+// src/routes/api/auth/$.ts\n+\n+import { auth } from '@/lib/auth'\n+\n+export const ServerRoute = createServerFileRoute().methods({",
        "comment_created_at": "2025-07-16T17:06:33+00:00",
        "comment_author": "max-programming",
        "comment_body": "Currently this is how server routes (previously api routes) are defined. I don't know why the docs page for server routes does not have this but it acts the same way like normal routes as it updates the routeTree file",
        "pr_file_module": null
      }
    ]
  }
]