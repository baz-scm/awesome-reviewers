[
  {
    "discussion_id": "2366232687",
    "pr_number": 5176,
    "pr_file": "packages/router-core/src/path.ts",
    "created_at": "2025-09-21T13:31:51+00:00",
    "commented_code": "// For optional params without prefix/suffix, we need to check if the current\n           // base segment should match this optional param or a later route segment\n \n-          // Look ahead to see if there's a later route segment that matches the current base segment\n           let shouldMatchOptional = true\n+          const remainingOptionals = optionalCount - processedOptionals - 1 > 0\n+\n+          // consider last route segment might be index route and any prior optionals that was not matched\n+          const remainingRouteSegmentLength =\n+            (routeSegments.slice(-1)[0]?.value === '/'\n+              ? routeSegments.length - 1\n+              : routeSegments.length) - routeIndex\n+\n+          const remainingRequiredRouteSegmentCount =\n+            remainingRouteSegmentLength - (optionalCount - processedOptionals)\n+          const remainingBaseSegmentCount = baseSegments.length - baseIndex\n+\n+          // Look ahead to see if there's a later route segment that matches the current base segment\n           for (\n             let lookAhead = routeIndex + 1;\n             lookAhead < routeSegments.length;\n             lookAhead++\n           ) {\n             const futureRouteSegment = routeSegments[lookAhead]\n-            if (\n-              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n-              futureRouteSegment.value === baseSegment.value\n-            ) {\n-              // The current base segment matches a future pathname segment,\n-              // so we should skip this optional parameter\n-              shouldMatchOptional = false\n+\n+            // where the next segment is a required path name, we can break early.\n+            // either the current base segment matches a future pathname segment,\n+            // in which case we should skip this optional parameter,\n+            // or the url is invalid\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {\n+              if (\n+                caseSensitive\n+                  ? futureRouteSegment.value === baseSegment.value\n+                  : futureRouteSegment.value.toLowerCase() ===\n+                    baseSegment.value.toLowerCase()\n+              ) {\n+                // so we should skip this optional parameter\n+                shouldMatchOptional = false\n+              }\n+              break\n+            }\n+\n+            // where consecutive optional params are used, we can break early.\n+            // preference is given to the first optional param\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n+              if (\n+                remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount\n+              ) {\n+                shouldMatchOptional = false\n+              }\n               break\n             }\n \n-            // If we encounter a required param or wildcard, stop looking ahead\n+            // this if is not required for the rest of the logic, but it's useful to know what type of future segment we're looking at'\n             if (\n               futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n               futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n             ) {\n-              if (baseSegments.length < routeSegments.length) {\n-                shouldMatchOptional = false\n+              const followingRouteSegment = routeSegments[lookAhead + 1]\n+\n+              let isMatchedFurtherDown = false\n+\n+              // since we know there are remaining optionals, we look to the segment following the next.\n+              // if further segments are required paths, then we can possibly match further optionals based on the url pattern. to do this, we match the remaining paths\n+              // if all that follows are wildcards/required params and/or optionals params we continue matching on a first-case basis, and optionals further down are unmatched.\n+              if (\n+                remainingOptionals &&\n+                followingRouteSegment &&\n+                (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME ||\n+                  (followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM &&\n+                    (followingRouteSegment.prefixSegment ||\n+                      followingRouteSegment.suffixSegment)))\n+              ) {\n+                const remainingRouteSegments = routeSegments.slice(\n+                  lookAhead + 1,\n+                )\n+\n+                const remainingRouteSegmentLength =\n+                  remainingRouteSegments.slice(-1)[0]?.value === '/'\n+                    ? remainingRouteSegments.length - 1\n+                    : remainingRouteSegments.length\n+\n+                const remainingBaseSegments = baseSegments.slice(baseIndex + 1)\n+\n+                isMatchedFurtherDown =\n+                  remainingRouteSegmentLength ===\n+                    remainingBaseSegments.length &&\n+                  isMatch(\n+                    remainingBaseSegments,\n+                    remainingRouteSegments,\n+                    { ...params },",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2366232687",
        "repo_full_name": "TanStack/router",
        "pr_number": 5176,
        "pr_file": "packages/router-core/src/path.ts",
        "discussion_id": "2366232687",
        "commented_code": "@@ -796,33 +805,111 @@ function isMatch(\n           // For optional params without prefix/suffix, we need to check if the current\n           // base segment should match this optional param or a later route segment\n \n-          // Look ahead to see if there's a later route segment that matches the current base segment\n           let shouldMatchOptional = true\n+          const remainingOptionals = optionalCount - processedOptionals - 1 > 0\n+\n+          // consider last route segment might be index route and any prior optionals that was not matched\n+          const remainingRouteSegmentLength =\n+            (routeSegments.slice(-1)[0]?.value === '/'\n+              ? routeSegments.length - 1\n+              : routeSegments.length) - routeIndex\n+\n+          const remainingRequiredRouteSegmentCount =\n+            remainingRouteSegmentLength - (optionalCount - processedOptionals)\n+          const remainingBaseSegmentCount = baseSegments.length - baseIndex\n+\n+          // Look ahead to see if there's a later route segment that matches the current base segment\n           for (\n             let lookAhead = routeIndex + 1;\n             lookAhead < routeSegments.length;\n             lookAhead++\n           ) {\n             const futureRouteSegment = routeSegments[lookAhead]\n-            if (\n-              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n-              futureRouteSegment.value === baseSegment.value\n-            ) {\n-              // The current base segment matches a future pathname segment,\n-              // so we should skip this optional parameter\n-              shouldMatchOptional = false\n+\n+            // where the next segment is a required path name, we can break early.\n+            // either the current base segment matches a future pathname segment,\n+            // in which case we should skip this optional parameter,\n+            // or the url is invalid\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {\n+              if (\n+                caseSensitive\n+                  ? futureRouteSegment.value === baseSegment.value\n+                  : futureRouteSegment.value.toLowerCase() ===\n+                    baseSegment.value.toLowerCase()\n+              ) {\n+                // so we should skip this optional parameter\n+                shouldMatchOptional = false\n+              }\n+              break\n+            }\n+\n+            // where consecutive optional params are used, we can break early.\n+            // preference is given to the first optional param\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n+              if (\n+                remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount\n+              ) {\n+                shouldMatchOptional = false\n+              }\n               break\n             }\n \n-            // If we encounter a required param or wildcard, stop looking ahead\n+            // this if is not required for the rest of the logic, but it's useful to know what type of future segment we're looking at'\n             if (\n               futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n               futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n             ) {\n-              if (baseSegments.length < routeSegments.length) {\n-                shouldMatchOptional = false\n+              const followingRouteSegment = routeSegments[lookAhead + 1]\n+\n+              let isMatchedFurtherDown = false\n+\n+              // since we know there are remaining optionals, we look to the segment following the next.\n+              // if further segments are required paths, then we can possibly match further optionals based on the url pattern. to do this, we match the remaining paths\n+              // if all that follows are wildcards/required params and/or optionals params we continue matching on a first-case basis, and optionals further down are unmatched.\n+              if (\n+                remainingOptionals &&\n+                followingRouteSegment &&\n+                (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME ||\n+                  (followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM &&\n+                    (followingRouteSegment.prefixSegment ||\n+                      followingRouteSegment.suffixSegment)))\n+              ) {\n+                const remainingRouteSegments = routeSegments.slice(\n+                  lookAhead + 1,\n+                )\n+\n+                const remainingRouteSegmentLength =\n+                  remainingRouteSegments.slice(-1)[0]?.value === '/'\n+                    ? remainingRouteSegments.length - 1\n+                    : remainingRouteSegments.length\n+\n+                const remainingBaseSegments = baseSegments.slice(baseIndex + 1)\n+\n+                isMatchedFurtherDown =\n+                  remainingRouteSegmentLength ===\n+                    remainingBaseSegments.length &&\n+                  isMatch(\n+                    remainingBaseSegments,\n+                    remainingRouteSegments,\n+                    { ...params },",
        "comment_created_at": "2025-09-21T13:31:51+00:00",
        "comment_author": "Sheraff",
        "comment_body": "I don't think it needs to inherit params\n```suggestion\n                    {},\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2366236337",
        "repo_full_name": "TanStack/router",
        "pr_number": 5176,
        "pr_file": "packages/router-core/src/path.ts",
        "discussion_id": "2366232687",
        "commented_code": "@@ -796,33 +805,111 @@ function isMatch(\n           // For optional params without prefix/suffix, we need to check if the current\n           // base segment should match this optional param or a later route segment\n \n-          // Look ahead to see if there's a later route segment that matches the current base segment\n           let shouldMatchOptional = true\n+          const remainingOptionals = optionalCount - processedOptionals - 1 > 0\n+\n+          // consider last route segment might be index route and any prior optionals that was not matched\n+          const remainingRouteSegmentLength =\n+            (routeSegments.slice(-1)[0]?.value === '/'\n+              ? routeSegments.length - 1\n+              : routeSegments.length) - routeIndex\n+\n+          const remainingRequiredRouteSegmentCount =\n+            remainingRouteSegmentLength - (optionalCount - processedOptionals)\n+          const remainingBaseSegmentCount = baseSegments.length - baseIndex\n+\n+          // Look ahead to see if there's a later route segment that matches the current base segment\n           for (\n             let lookAhead = routeIndex + 1;\n             lookAhead < routeSegments.length;\n             lookAhead++\n           ) {\n             const futureRouteSegment = routeSegments[lookAhead]\n-            if (\n-              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n-              futureRouteSegment.value === baseSegment.value\n-            ) {\n-              // The current base segment matches a future pathname segment,\n-              // so we should skip this optional parameter\n-              shouldMatchOptional = false\n+\n+            // where the next segment is a required path name, we can break early.\n+            // either the current base segment matches a future pathname segment,\n+            // in which case we should skip this optional parameter,\n+            // or the url is invalid\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {\n+              if (\n+                caseSensitive\n+                  ? futureRouteSegment.value === baseSegment.value\n+                  : futureRouteSegment.value.toLowerCase() ===\n+                    baseSegment.value.toLowerCase()\n+              ) {\n+                // so we should skip this optional parameter\n+                shouldMatchOptional = false\n+              }\n+              break\n+            }\n+\n+            // where consecutive optional params are used, we can break early.\n+            // preference is given to the first optional param\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n+              if (\n+                remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount\n+              ) {\n+                shouldMatchOptional = false\n+              }\n               break\n             }\n \n-            // If we encounter a required param or wildcard, stop looking ahead\n+            // this if is not required for the rest of the logic, but it's useful to know what type of future segment we're looking at'\n             if (\n               futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n               futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n             ) {\n-              if (baseSegments.length < routeSegments.length) {\n-                shouldMatchOptional = false\n+              const followingRouteSegment = routeSegments[lookAhead + 1]\n+\n+              let isMatchedFurtherDown = false\n+\n+              // since we know there are remaining optionals, we look to the segment following the next.\n+              // if further segments are required paths, then we can possibly match further optionals based on the url pattern. to do this, we match the remaining paths\n+              // if all that follows are wildcards/required params and/or optionals params we continue matching on a first-case basis, and optionals further down are unmatched.\n+              if (\n+                remainingOptionals &&\n+                followingRouteSegment &&\n+                (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME ||\n+                  (followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM &&\n+                    (followingRouteSegment.prefixSegment ||\n+                      followingRouteSegment.suffixSegment)))\n+              ) {\n+                const remainingRouteSegments = routeSegments.slice(\n+                  lookAhead + 1,\n+                )\n+\n+                const remainingRouteSegmentLength =\n+                  remainingRouteSegments.slice(-1)[0]?.value === '/'\n+                    ? remainingRouteSegments.length - 1\n+                    : remainingRouteSegments.length\n+\n+                const remainingBaseSegments = baseSegments.slice(baseIndex + 1)\n+\n+                isMatchedFurtherDown =\n+                  remainingRouteSegmentLength ===\n+                    remainingBaseSegments.length &&\n+                  isMatch(\n+                    remainingBaseSegments,\n+                    remainingRouteSegments,\n+                    { ...params },",
        "comment_created_at": "2025-09-21T13:41:08+00:00",
        "comment_author": "nlynzaad",
        "comment_body": "params gets modified in isMatch when the match is found, for this here we only want to confirm a match exists and don't want it to mutate the params, hence the spread.",
        "pr_file_module": null
      },
      {
        "comment_id": "2366238422",
        "repo_full_name": "TanStack/router",
        "pr_number": 5176,
        "pr_file": "packages/router-core/src/path.ts",
        "discussion_id": "2366232687",
        "commented_code": "@@ -796,33 +805,111 @@ function isMatch(\n           // For optional params without prefix/suffix, we need to check if the current\n           // base segment should match this optional param or a later route segment\n \n-          // Look ahead to see if there's a later route segment that matches the current base segment\n           let shouldMatchOptional = true\n+          const remainingOptionals = optionalCount - processedOptionals - 1 > 0\n+\n+          // consider last route segment might be index route and any prior optionals that was not matched\n+          const remainingRouteSegmentLength =\n+            (routeSegments.slice(-1)[0]?.value === '/'\n+              ? routeSegments.length - 1\n+              : routeSegments.length) - routeIndex\n+\n+          const remainingRequiredRouteSegmentCount =\n+            remainingRouteSegmentLength - (optionalCount - processedOptionals)\n+          const remainingBaseSegmentCount = baseSegments.length - baseIndex\n+\n+          // Look ahead to see if there's a later route segment that matches the current base segment\n           for (\n             let lookAhead = routeIndex + 1;\n             lookAhead < routeSegments.length;\n             lookAhead++\n           ) {\n             const futureRouteSegment = routeSegments[lookAhead]\n-            if (\n-              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n-              futureRouteSegment.value === baseSegment.value\n-            ) {\n-              // The current base segment matches a future pathname segment,\n-              // so we should skip this optional parameter\n-              shouldMatchOptional = false\n+\n+            // where the next segment is a required path name, we can break early.\n+            // either the current base segment matches a future pathname segment,\n+            // in which case we should skip this optional parameter,\n+            // or the url is invalid\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {\n+              if (\n+                caseSensitive\n+                  ? futureRouteSegment.value === baseSegment.value\n+                  : futureRouteSegment.value.toLowerCase() ===\n+                    baseSegment.value.toLowerCase()\n+              ) {\n+                // so we should skip this optional parameter\n+                shouldMatchOptional = false\n+              }\n+              break\n+            }\n+\n+            // where consecutive optional params are used, we can break early.\n+            // preference is given to the first optional param\n+            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n+              if (\n+                remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount\n+              ) {\n+                shouldMatchOptional = false\n+              }\n               break\n             }\n \n-            // If we encounter a required param or wildcard, stop looking ahead\n+            // this if is not required for the rest of the logic, but it's useful to know what type of future segment we're looking at'\n             if (\n               futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n               futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n             ) {\n-              if (baseSegments.length < routeSegments.length) {\n-                shouldMatchOptional = false\n+              const followingRouteSegment = routeSegments[lookAhead + 1]\n+\n+              let isMatchedFurtherDown = false\n+\n+              // since we know there are remaining optionals, we look to the segment following the next.\n+              // if further segments are required paths, then we can possibly match further optionals based on the url pattern. to do this, we match the remaining paths\n+              // if all that follows are wildcards/required params and/or optionals params we continue matching on a first-case basis, and optionals further down are unmatched.\n+              if (\n+                remainingOptionals &&\n+                followingRouteSegment &&\n+                (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME ||\n+                  (followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM &&\n+                    (followingRouteSegment.prefixSegment ||\n+                      followingRouteSegment.suffixSegment)))\n+              ) {\n+                const remainingRouteSegments = routeSegments.slice(\n+                  lookAhead + 1,\n+                )\n+\n+                const remainingRouteSegmentLength =\n+                  remainingRouteSegments.slice(-1)[0]?.value === '/'\n+                    ? remainingRouteSegments.length - 1\n+                    : remainingRouteSegments.length\n+\n+                const remainingBaseSegments = baseSegments.slice(baseIndex + 1)\n+\n+                isMatchedFurtherDown =\n+                  remainingRouteSegmentLength ===\n+                    remainingBaseSegments.length &&\n+                  isMatch(\n+                    remainingBaseSegments,\n+                    remainingRouteSegments,\n+                    { ...params },",
        "comment_created_at": "2025-09-21T13:46:49+00:00",
        "comment_author": "Sheraff",
        "comment_body": "but it's never reading from it either right? So if we're not gonna use it, and it doesn't need it, why spread at all? Why not just pass in an empty object?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2380806517",
    "pr_number": 5201,
    "pr_file": "packages/router-core/src/router.ts",
    "created_at": "2025-09-26T04:05:38+00:00",
    "commented_code": "clearExpiredCache = () => {\n     // This is where all of the garbage collection magic happens\n     const filter = (d: MakeRouteMatch<TRouteTree>) => {\n-      const route = this.looseRoutesById[d.routeId]!\n+      const route = this.looseRoutesById[d.routeId]",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2380806517",
        "repo_full_name": "TanStack/router",
        "pr_number": 5201,
        "pr_file": "packages/router-core/src/router.ts",
        "discussion_id": "2380806517",
        "commented_code": "@@ -2259,9 +2259,9 @@ export class RouterCore<\n   clearExpiredCache = () => {\n     // This is where all of the garbage collection magic happens\n     const filter = (d: MakeRouteMatch<TRouteTree>) => {\n-      const route = this.looseRoutesById[d.routeId]!\n+      const route = this.looseRoutesById[d.routeId]\n ",
        "comment_created_at": "2025-09-26T04:05:38+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "should we not just return here if route is undefined?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2094564951",
    "pr_number": 4203,
    "pr_file": "packages/router-plugin/src/core/router-generator-plugin.ts",
    "created_at": "2025-05-18T15:59:16+00:00",
    "commented_code": "const PLUGIN_NAME = 'unplugin:router-generator'\n \n export const unpluginRouterGeneratorFactory: UnpluginFactory<\n-  Partial<Config> | undefined\n+  ConfigOptions | undefined\n > = (options = {}) => {\n   let ROOT: string = process.cwd()\n   let userConfig = options as Config",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "2094564951",
        "repo_full_name": "TanStack/router",
        "pr_number": 4203,
        "pr_file": "packages/router-plugin/src/core/router-generator-plugin.ts",
        "discussion_id": "2094564951",
        "commented_code": "@@ -15,7 +15,7 @@ const setLock = (bool: boolean) => {\n const PLUGIN_NAME = 'unplugin:router-generator'\n \n export const unpluginRouterGeneratorFactory: UnpluginFactory<\n-  Partial<Config> | undefined\n+  ConfigOptions | undefined\n > = (options = {}) => {\n   let ROOT: string = process.cwd()\n   let userConfig = options as Config",
        "comment_created_at": "2025-05-18T15:59:16+00:00",
        "comment_author": "RMHonor",
        "comment_body": "This type casting here is risky, `Config` is the `z.output` type, which will contain defined properties due to the default option, but what's being passed it hasn't been parsed by Zod yet.\r\n\r\nFor example, `userConfig.routesDirectory` may not have been defined yet, so the usage on L24-26 is unsafe.\r\n\r\nThere is some complexity here, because we can't immediately parse the provided schema, as there may be later config retrieved from a `tsr.config.ts` file ([here](https://github.com/TanStack/router/blob/main/packages/router-generator/src/config.ts#L60)), and the default values would override anything provided in the config file",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1679733752",
    "pr_number": 1969,
    "pr_file": "packages/react-router/src/utils.ts",
    "created_at": "2024-07-16T16:38:38+00:00",
    "commented_code": "return Array.isArray(value) && value.length === Object.keys(value).length\n }\n \n+/**\n+ * This function will remove all undefined values from an object.\n+ * It will also remove any undefined values from nested objects.\n+ * It will not remove undefined values from arrays.\n+ */\n+export function deepRemoveUndefinedFromObject<T>(obj: T): T {",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1679733752",
        "repo_full_name": "TanStack/router",
        "pr_number": 1969,
        "pr_file": "packages/react-router/src/utils.ts",
        "discussion_id": "1679733752",
        "commented_code": "@@ -209,6 +209,32 @@ export function isPlainArray(value: unknown): value is Array<unknown> {\n   return Array.isArray(value) && value.length === Object.keys(value).length\n }\n \n+/**\n+ * This function will remove all undefined values from an object.\n+ * It will also remove any undefined values from nested objects.\n+ * It will not remove undefined values from arrays.\n+ */\n+export function deepRemoveUndefinedFromObject<T>(obj: T): T {",
        "comment_created_at": "2024-07-16T16:38:38+00:00",
        "comment_author": "schiller-manuel",
        "comment_body": "can we, instead of adding this function, enhance `deepEqual` to ignore properties that are explicitly set to `undefined`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1679965076",
        "repo_full_name": "TanStack/router",
        "pr_number": 1969,
        "pr_file": "packages/react-router/src/utils.ts",
        "discussion_id": "1679733752",
        "commented_code": "@@ -209,6 +209,32 @@ export function isPlainArray(value: unknown): value is Array<unknown> {\n   return Array.isArray(value) && value.length === Object.keys(value).length\n }\n \n+/**\n+ * This function will remove all undefined values from an object.\n+ * It will also remove any undefined values from nested objects.\n+ * It will not remove undefined values from arrays.\n+ */\n+export function deepRemoveUndefinedFromObject<T>(obj: T): T {",
        "comment_created_at": "2024-07-16T19:27:26+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "I assume you mean only for object properties yes? Not to strip out `undefined` as an array value, only as an object value, when comparing `[undefined, 'foo', { a: undefined }]` with `['foo', undefined, { a: undefined }]`.\r\n\r\nI was hesitant to make such changes to the `deepEqual` function itself since that'd have an impact on the `router.matchRoute` and `router.commitLocation` methods, especially without understanding the conditions in which `undefined` would get either pass or fail the function.\r\n\r\nIt's why I introduced that function since it explicitly does a single job and has a narrow impact area (only the link component).",
        "pr_file_module": null
      },
      {
        "comment_id": "1680190487",
        "repo_full_name": "TanStack/router",
        "pr_number": 1969,
        "pr_file": "packages/react-router/src/utils.ts",
        "discussion_id": "1679733752",
        "commented_code": "@@ -209,6 +209,32 @@ export function isPlainArray(value: unknown): value is Array<unknown> {\n   return Array.isArray(value) && value.length === Object.keys(value).length\n }\n \n+/**\n+ * This function will remove all undefined values from an object.\n+ * It will also remove any undefined values from nested objects.\n+ * It will not remove undefined values from arrays.\n+ */\n+export function deepRemoveUndefinedFromObject<T>(obj: T): T {",
        "comment_created_at": "2024-07-17T00:02:44+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "@schiller-manuel thoughts on having the `deepEqual` function internally call the `deepRemoveUndefinedFromObject` function on both its inputs `a` and `b`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1680201385",
        "repo_full_name": "TanStack/router",
        "pr_number": 1969,
        "pr_file": "packages/react-router/src/utils.ts",
        "discussion_id": "1679733752",
        "commented_code": "@@ -209,6 +209,32 @@ export function isPlainArray(value: unknown): value is Array<unknown> {\n   return Array.isArray(value) && value.length === Object.keys(value).length\n }\n \n+/**\n+ * This function will remove all undefined values from an object.\n+ * It will also remove any undefined values from nested objects.\n+ * It will not remove undefined values from arrays.\n+ */\n+export function deepRemoveUndefinedFromObject<T>(obj: T): T {",
        "comment_created_at": "2024-07-17T00:24:03+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "Yup, that's what'll work best here. I'll beef up those tests for the `deepRemoveUndefinedFromObject` function and push this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1692450876",
    "pr_number": 2027,
    "pr_file": "packages/react-router/src/path.ts",
    "created_at": "2024-07-26T03:47:11+00:00",
    "commented_code": "}\n \n export function joinPaths(paths: Array<string | undefined>) {\n-  return cleanPath(paths.filter(Boolean).join('/'))\n+  return cleanPath(\n+    paths\n+      .filter((val) => {",
    "repo_full_name": "TanStack/router",
    "discussion_comments": [
      {
        "comment_id": "1692450876",
        "repo_full_name": "TanStack/router",
        "pr_number": 2027,
        "pr_file": "packages/react-router/src/path.ts",
        "discussion_id": "1692450876",
        "commented_code": "@@ -8,7 +8,13 @@ export interface Segment {\n }\n \n export function joinPaths(paths: Array<string | undefined>) {\n-  return cleanPath(paths.filter(Boolean).join('/'))\n+  return cleanPath(\n+    paths\n+      .filter((val) => {",
        "comment_created_at": "2024-07-26T03:47:11+00:00",
        "comment_author": "SeanCassiere",
        "comment_body": "This `Boolean` filtering was causing falsy number values (like `0`, `-1`, etc...) to be excluded from the joined path.\r\n\r\nThis ripples out into the router logic, where all the right routes don't get matched since the pathname it's using for checking will be incomplete or in some cases even outright incorrect.",
        "pr_file_module": null
      }
    ]
  }
]