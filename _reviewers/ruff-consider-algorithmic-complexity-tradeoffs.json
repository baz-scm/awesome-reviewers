[
  {
    "discussion_id": "2183627064",
    "pr_number": 19130,
    "pr_file": "crates/ty_python_semantic/src/types.rs",
    "created_at": "2025-07-03T19:37:49+00:00",
    "commented_code": "}\n     }\n \n+    pub(crate) fn into_callable(self, db: &'db dyn Db) -> Option<Type<'db>> {\n+        match self {\n+            Type::Callable(_) => Some(self),\n+\n+            Type::Dynamic(_) => Some(CallableType::single(\n+                db,\n+                Signature::new(Parameters::object(db), Some(self)),\n+            )),\n+\n+            Type::FunctionLiteral(function_literal) => {\n+                Some(function_literal.into_callable_type(db))\n+            }\n+            Type::BoundMethod(bound_method) => Some(bound_method.into_callable_type(db)),\n+\n+            Type::NominalInstance(_) | Type::ProtocolInstance(_) => {\n+                let call_symbol = self\n+                    .member_lookup_with_policy(\n+                        db,\n+                        Name::new_static(\"__call__\"),\n+                        MemberLookupPolicy::NO_INSTANCE_FALLBACK,\n+                    )\n+                    .place;\n+\n+                if let Place::Type(ty, Boundness::Bound) = call_symbol {\n+                    ty.into_callable(db)\n+                } else {\n+                    None\n+                }\n+            }\n+            Type::ClassLiteral(class_literal) => {\n+                Some(ClassType::NonGeneric(class_literal).into_callable(db))\n+            }\n+\n+            Type::GenericAlias(alias) => Some(ClassType::Generic(alias).into_callable(db)),\n+\n+            Type::SubclassOf(subclass_of_ty) => subclass_of_ty\n+                .subclass_of()\n+                .into_class()\n+                .map(|class| class.into_callable(db))\n+                .unwrap_or_else(|| KnownClass::Type.to_instance(db))\n+                .into_callable(db),\n+\n+            Type::Union(union) => {\n+                let callable_types: Vec<_> = union\n+                    .elements(db)\n+                    .iter()\n+                    .map(|ty| ty.into_callable(db))\n+                    .collect();\n+\n+                if callable_types.iter().any(Option::is_none) {\n+                    None\n+                } else {\n+                    Some(UnionType::from_elements(\n+                        db,\n+                        callable_types.into_iter().map(|ty| ty.unwrap()),\n+                    ))\n+                }\n+            }",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2183627064",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19130,
        "pr_file": "crates/ty_python_semantic/src/types.rs",
        "discussion_id": "2183627064",
        "commented_code": "@@ -1186,6 +1186,68 @@ impl<'db> Type<'db> {\n         }\n     }\n \n+    pub(crate) fn into_callable(self, db: &'db dyn Db) -> Option<Type<'db>> {\n+        match self {\n+            Type::Callable(_) => Some(self),\n+\n+            Type::Dynamic(_) => Some(CallableType::single(\n+                db,\n+                Signature::new(Parameters::object(db), Some(self)),\n+            )),\n+\n+            Type::FunctionLiteral(function_literal) => {\n+                Some(function_literal.into_callable_type(db))\n+            }\n+            Type::BoundMethod(bound_method) => Some(bound_method.into_callable_type(db)),\n+\n+            Type::NominalInstance(_) | Type::ProtocolInstance(_) => {\n+                let call_symbol = self\n+                    .member_lookup_with_policy(\n+                        db,\n+                        Name::new_static(\"__call__\"),\n+                        MemberLookupPolicy::NO_INSTANCE_FALLBACK,\n+                    )\n+                    .place;\n+\n+                if let Place::Type(ty, Boundness::Bound) = call_symbol {\n+                    ty.into_callable(db)\n+                } else {\n+                    None\n+                }\n+            }\n+            Type::ClassLiteral(class_literal) => {\n+                Some(ClassType::NonGeneric(class_literal).into_callable(db))\n+            }\n+\n+            Type::GenericAlias(alias) => Some(ClassType::Generic(alias).into_callable(db)),\n+\n+            Type::SubclassOf(subclass_of_ty) => subclass_of_ty\n+                .subclass_of()\n+                .into_class()\n+                .map(|class| class.into_callable(db))\n+                .unwrap_or_else(|| KnownClass::Type.to_instance(db))\n+                .into_callable(db),\n+\n+            Type::Union(union) => {\n+                let callable_types: Vec<_> = union\n+                    .elements(db)\n+                    .iter()\n+                    .map(|ty| ty.into_callable(db))\n+                    .collect();\n+\n+                if callable_types.iter().any(Option::is_none) {\n+                    None\n+                } else {\n+                    Some(UnionType::from_elements(\n+                        db,\n+                        callable_types.into_iter().map(|ty| ty.unwrap()),\n+                    ))\n+                }\n+            }",
        "comment_created_at": "2025-07-03T19:37:49+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "```suggestion\r\n            Type::Union(union) => union.try_map(db, |element| element.into_callable(db)),\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165271479",
    "pr_number": 18713,
    "pr_file": "crates/ty_python_semantic/src/types.rs",
    "created_at": "2025-06-25T01:46:48+00:00",
    "commented_code": "}\n }\n \n+impl std::iter::FromIterator<Self> for TypeVarVariance {\n+    fn from_iter<T: IntoIterator<Item = Self>>(iter: T) -> Self {\n+        use std::ops::ControlFlow;\n+        // TODO: use `into_value` when control_flow_into_value is stable\n+        let (ControlFlow::Break(variance) | ControlFlow::Continue(variance)) = iter\n+            .into_iter()\n+            .try_fold(TypeVarVariance::Bivariant, |acc, variance| {\n+                let infimum = acc.join(variance);\n+                match infimum {\n+                    // short circuit at top\n+                    TypeVarVariance::Invariant => ControlFlow::Break(infimum),\n+                    TypeVarVariance::Bivariant\n+                    | TypeVarVariance::Covariant\n+                    | TypeVarVariance::Contravariant => ControlFlow::Continue(infimum),\n+                }\n+            });",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2165271479",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18713,
        "pr_file": "crates/ty_python_semantic/src/types.rs",
        "discussion_id": "2165271479",
        "commented_code": "@@ -6169,6 +6391,26 @@ impl TypeVarVariance {\n     }\n }\n \n+impl std::iter::FromIterator<Self> for TypeVarVariance {\n+    fn from_iter<T: IntoIterator<Item = Self>>(iter: T) -> Self {\n+        use std::ops::ControlFlow;\n+        // TODO: use `into_value` when control_flow_into_value is stable\n+        let (ControlFlow::Break(variance) | ControlFlow::Continue(variance)) = iter\n+            .into_iter()\n+            .try_fold(TypeVarVariance::Bivariant, |acc, variance| {\n+                let infimum = acc.join(variance);\n+                match infimum {\n+                    // short circuit at top\n+                    TypeVarVariance::Invariant => ControlFlow::Break(infimum),\n+                    TypeVarVariance::Bivariant\n+                    | TypeVarVariance::Covariant\n+                    | TypeVarVariance::Contravariant => ControlFlow::Continue(infimum),\n+                }\n+            });",
        "comment_created_at": "2025-06-25T01:46:48+00:00",
        "comment_author": "dcreager",
        "comment_body": "The short-circuiting behavior here isn't semantically important, is it? Will we be folding over large enough iterators for it to be important from a performance standpoint? I feel like a simple non-short-circuiting `fold` will be much easier to understand.",
        "pr_file_module": null
      },
      {
        "comment_id": "2173554781",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18713,
        "pr_file": "crates/ty_python_semantic/src/types.rs",
        "discussion_id": "2165271479",
        "commented_code": "@@ -6169,6 +6391,26 @@ impl TypeVarVariance {\n     }\n }\n \n+impl std::iter::FromIterator<Self> for TypeVarVariance {\n+    fn from_iter<T: IntoIterator<Item = Self>>(iter: T) -> Self {\n+        use std::ops::ControlFlow;\n+        // TODO: use `into_value` when control_flow_into_value is stable\n+        let (ControlFlow::Break(variance) | ControlFlow::Continue(variance)) = iter\n+            .into_iter()\n+            .try_fold(TypeVarVariance::Bivariant, |acc, variance| {\n+                let infimum = acc.join(variance);\n+                match infimum {\n+                    // short circuit at top\n+                    TypeVarVariance::Invariant => ControlFlow::Break(infimum),\n+                    TypeVarVariance::Bivariant\n+                    | TypeVarVariance::Covariant\n+                    | TypeVarVariance::Contravariant => ControlFlow::Continue(infimum),\n+                }\n+            });",
        "comment_created_at": "2025-06-28T23:46:44+00:00",
        "comment_author": "ericmarkmartin",
        "comment_body": "It's definitely not semantically important, just a performance optimization.\n\nI do actually think this one is worth it: suppose we have a class where there's an early invariant occurrence (this is actually relatively common, as any mutable instance member would be). The short-circuit here saves us traversing the entire rest of the class members. If the class references other classes, or even a mutual recursive class, this could save us a lot of work (especially since in the latter case, we're not truly linear due to how salsa handles Fixpoint iterations).\n\nWe actually do something similar in [reachability analysis][reachability-analysis] where we short-circuit with the same trick.\n\n[reachability-analysis]: https://github.com/astral-sh/ruff/blob/9218bf72ad84f56f48c3cca985be8565ae1600e7/crates/ty_python_semantic/src/semantic_index/reachability_constraints.rs#L628",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2176467272",
    "pr_number": 18996,
    "pr_file": "crates/ty_python_semantic/src/types/call/bind.rs",
    "created_at": "2025-07-01T05:35:25+00:00",
    "commented_code": "signature: &'a Signature<'db>,\n         arguments: &'a CallArguments<'a>,\n         argument_types: &'a [Type<'db>],\n-        argument_parameters: &'a [Option<usize>],\n+        argument_parameters: &'a [SmallVec<[usize; 1]>],",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2176467272",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18996,
        "pr_file": "crates/ty_python_semantic/src/types/call/bind.rs",
        "discussion_id": "2176467272",
        "commented_code": "@@ -1933,7 +1957,7 @@ impl<'a, 'db> ArgumentTypeChecker<'a, 'db> {\n         signature: &'a Signature<'db>,\n         arguments: &'a CallArguments<'a>,\n         argument_types: &'a [Type<'db>],\n-        argument_parameters: &'a [Option<usize>],\n+        argument_parameters: &'a [SmallVec<[usize; 1]>],",
        "comment_created_at": "2025-07-01T05:35:25+00:00",
        "comment_author": "dhruvmanila",
        "comment_body": "nit: At this point I think we're using this pattern in multiple places. Do you think it might be useful to use something like https://docs.rs/vec1/1.12.1/vec1/smallvec_v1/index.html ?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2170972828",
    "pr_number": 18961,
    "pr_file": "crates/ruff_linter/src/rules/pylint/settings.rs",
    "created_at": "2025-06-27T07:10:24+00:00",
    "commented_code": "use std::fmt;\n \n use crate::display_settings;\n+use ruff_cache::{CacheKey, CacheKeyHasher};\n use ruff_macros::CacheKey;\n-use ruff_python_ast::{ExprNumberLiteral, LiteralExpressionRef, Number};\n+use ruff_python_ast::{\n+    ExprBytesLiteral, ExprNumberLiteral, ExprStringLiteral, LiteralExpressionRef, Number,\n+};\n+use std::hash::Hasher;\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+#[serde(untagged)]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub enum AllowedValue {\n+    String(String),\n+    Int(i64),\n+    Float(f64),\n+    Complex { real: f64, imag: f64 },\n+    Bytes(Vec<u8>),\n+}\n+\n+impl AllowedValue {\n+    pub fn try_from_literal_expr(literal_expr: LiteralExpressionRef<'_>) -> Option<Self> {\n+        match literal_expr {\n+            LiteralExpressionRef::StringLiteral(ExprStringLiteral { value, .. }) => {\n+                Some(AllowedValue::String(value.to_str().to_string()))\n+            }\n+            LiteralExpressionRef::NumberLiteral(ExprNumberLiteral { value, .. }) => match value {\n+                Number::Float(f) => Some(AllowedValue::Float(*f)),\n+                Number::Int(i) => i.as_i64().map(AllowedValue::Int),\n+                Number::Complex { real, imag } => Some(AllowedValue::Complex {\n+                    real: *real,\n+                    imag: *imag,\n+                }),\n+            },\n+            LiteralExpressionRef::BytesLiteral(ExprBytesLiteral { value, .. }) => {\n+                Some(AllowedValue::Bytes(value.bytes().collect()))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl PartialEq for AllowedValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (AllowedValue::String(a), AllowedValue::String(b)) => a == b,\n+            (AllowedValue::Int(a), AllowedValue::Int(b)) => a == b,\n+            (AllowedValue::Bytes(a), AllowedValue::Bytes(b)) => a == b,\n+            // dealing with floating point precision issues\n+            (AllowedValue::Float(a), AllowedValue::Float(b)) => a.to_bits() == b.to_bits(),\n+            (\n+                AllowedValue::Complex { real: r1, imag: i1 },\n+                AllowedValue::Complex { real: r2, imag: i2 },\n+            ) => r1.to_bits() == r2.to_bits() && i1.to_bits() == i2.to_bits(),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Eq for AllowedValue {}\n+\n+impl CacheKey for AllowedValue {\n+    fn cache_key(&self, state: &mut CacheKeyHasher) {\n+        match self {\n+            AllowedValue::String(s) => {\n+                state.write_usize(0);\n+                s.cache_key(state);\n+            }\n+            AllowedValue::Int(i) => {\n+                state.write_usize(1);\n+                i.cache_key(state);\n+            }\n+            AllowedValue::Bytes(b) => {\n+                state.write_usize(3);\n+                b.cache_key(state);\n+            }\n+            // dealing with floating point precision issues for deterministic caching\n+            AllowedValue::Float(f) => {\n+                state.write_usize(4);\n+                f.to_bits().cache_key(state);\n+            }\n+            AllowedValue::Complex { real, imag } => {\n+                state.write_usize(5);\n+                real.to_bits().cache_key(state);\n+                imag.to_bits().cache_key(state);\n+            }\n+        }\n+    }\n+}",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2170972828",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18961,
        "pr_file": "crates/ruff_linter/src/rules/pylint/settings.rs",
        "discussion_id": "2170972828",
        "commented_code": "@@ -5,8 +5,132 @@ use serde::{Deserialize, Serialize};\n use std::fmt;\n \n use crate::display_settings;\n+use ruff_cache::{CacheKey, CacheKeyHasher};\n use ruff_macros::CacheKey;\n-use ruff_python_ast::{ExprNumberLiteral, LiteralExpressionRef, Number};\n+use ruff_python_ast::{\n+    ExprBytesLiteral, ExprNumberLiteral, ExprStringLiteral, LiteralExpressionRef, Number,\n+};\n+use std::hash::Hasher;\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+#[serde(untagged)]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub enum AllowedValue {\n+    String(String),\n+    Int(i64),\n+    Float(f64),\n+    Complex { real: f64, imag: f64 },\n+    Bytes(Vec<u8>),\n+}\n+\n+impl AllowedValue {\n+    pub fn try_from_literal_expr(literal_expr: LiteralExpressionRef<'_>) -> Option<Self> {\n+        match literal_expr {\n+            LiteralExpressionRef::StringLiteral(ExprStringLiteral { value, .. }) => {\n+                Some(AllowedValue::String(value.to_str().to_string()))\n+            }\n+            LiteralExpressionRef::NumberLiteral(ExprNumberLiteral { value, .. }) => match value {\n+                Number::Float(f) => Some(AllowedValue::Float(*f)),\n+                Number::Int(i) => i.as_i64().map(AllowedValue::Int),\n+                Number::Complex { real, imag } => Some(AllowedValue::Complex {\n+                    real: *real,\n+                    imag: *imag,\n+                }),\n+            },\n+            LiteralExpressionRef::BytesLiteral(ExprBytesLiteral { value, .. }) => {\n+                Some(AllowedValue::Bytes(value.bytes().collect()))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl PartialEq for AllowedValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (AllowedValue::String(a), AllowedValue::String(b)) => a == b,\n+            (AllowedValue::Int(a), AllowedValue::Int(b)) => a == b,\n+            (AllowedValue::Bytes(a), AllowedValue::Bytes(b)) => a == b,\n+            // dealing with floating point precision issues\n+            (AllowedValue::Float(a), AllowedValue::Float(b)) => a.to_bits() == b.to_bits(),\n+            (\n+                AllowedValue::Complex { real: r1, imag: i1 },\n+                AllowedValue::Complex { real: r2, imag: i2 },\n+            ) => r1.to_bits() == r2.to_bits() && i1.to_bits() == i2.to_bits(),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Eq for AllowedValue {}\n+\n+impl CacheKey for AllowedValue {\n+    fn cache_key(&self, state: &mut CacheKeyHasher) {\n+        match self {\n+            AllowedValue::String(s) => {\n+                state.write_usize(0);\n+                s.cache_key(state);\n+            }\n+            AllowedValue::Int(i) => {\n+                state.write_usize(1);\n+                i.cache_key(state);\n+            }\n+            AllowedValue::Bytes(b) => {\n+                state.write_usize(3);\n+                b.cache_key(state);\n+            }\n+            // dealing with floating point precision issues for deterministic caching\n+            AllowedValue::Float(f) => {\n+                state.write_usize(4);\n+                f.to_bits().cache_key(state);\n+            }\n+            AllowedValue::Complex { real, imag } => {\n+                state.write_usize(5);\n+                real.to_bits().cache_key(state);\n+                imag.to_bits().cache_key(state);\n+            }\n+        }\n+    }\n+}",
        "comment_created_at": "2025-06-27T07:10:24+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "You can simplify these implementations by creating an `AllowedFloatValue` struct and implement `Eq` and `CacheKey` for that struct only. You can then derive `CacheKey` and `PartialEq` on the enum",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2158800457",
    "pr_number": 18600,
    "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
    "created_at": "2025-06-20T12:02:34+00:00",
    "commented_code": "+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2158800457",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T12:02:34+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "This means that we iterate over a tuple's fixed elements twice when constructing it: once in the `TupleType` construction, and once here. We could probably avoid iterating over the tuple twice by doing this check in `VariableLengthTuple::mixed()` and `FixedLengthTuple::from_elements()`, then change this check here into a `debug_assert!()` that ensures that the inner constructors upheld the invariant.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159370264",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T16:50:25+00:00",
        "comment_author": "dcreager",
        "comment_body": "> by doing this check in `VariableLengthTuple::mixed()` and `FixedLengthTuple::from_elements()`\r\n\r\nThe issue with that is that there will be some tuple specs (for unpacking and splatting) where I think we _don't_ want to collapse a tuple containing `Never` into `Never` itself.  I don't anticipate tuples will be large enough to make that double iteration an bottleneck.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159396684",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T17:09:18+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "> The issue with that is that there will be some tuple specs (for unpacking and splatting) where I think we _don't_ want to collapse a tuple containing `Never` into `Never` itself.\r\n\r\nhmm... do you have any examples? :-)",
        "pr_file_module": null
      },
      {
        "comment_id": "2159436490",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T17:40:25+00:00",
        "comment_author": "dcreager",
        "comment_body": "[Here](https://github.com/astral-sh/ruff/blob/45cd117ea4a361db9041304462bca7b8be7a8a80/crates/ty_python_semantic/src/types/unpacker.rs#L281-L310) is where we're building up a new tuple spec (but not a tuple type) during unpacking. Right now that only works on fixed-length tuples, but in a later PR I want to extend that to support mixed tuples as well, and use that whole machinery for splatting. We'd use tuple specs to describe the positional parameters and arguments, and I wanted to be able to retain the information about which particular params/args are `Never` without having to collapse the whole thing down to a single `Never`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159442789",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T17:45:59+00:00",
        "comment_author": "dcreager",
        "comment_body": "Or put another way, `Tuple` (the Rust type) will not only be used to represent instances of `tuple` (the Python type). That might have been too implicit in this PR? I can add some clarifying documentation about that point if so.\r\n\r\n(I've been using \"tuple spec\" in my comments to mean \"a sequence of types, which might have a homogeneous variable-length bit in the middle\". A `tuple` instance is _one_ of the things that is described by a tuple spec, but not the only one. We do want the \"collapse the `Never`s\" behavior for `tuple` instances, but (I contend) that's not universally true of tuple specs.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2159445381",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T17:48:20+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "Ahh, thanks, that makese sense! I guess the only quibbles I have in that case are that you could maybe adjust the docstrings for `FixedLengthTuple` and `VariableLengthTuple` -- i.e., since `FixedLengthTuple` (intentionally!) does not uphold all the invariants maintained by `TupleType`, the first sentence is not _really_ accurate:\r\n\r\n> /// A fixed-length tuple.\r\n\r\nIt would be _more_ accurate to say \"Inner data for a fixed-length tuple.\" And maybe explicitly call out in the docstring that not all invariants we maintain for `TupleType` are maintained by this inner struct?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159446988",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T17:49:42+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "oops, I posted my response before seeing your second comment. Yes, some clarifying docs would be great! And maybe it would even be good to rename your `Tuple` struct to `TupleSpec`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159524857",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158800457",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }",
        "comment_created_at": "2025-06-20T18:56:33+00:00",
        "comment_author": "dcreager",
        "comment_body": "\r\n\r\n> Yes, some clarifying docs would be great! And maybe it would even be good to rename your `Tuple` struct to `TupleSpec`?\r\n\r\nDone",
        "pr_file_module": null
      }
    ]
  }
]