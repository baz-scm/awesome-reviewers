[
  {
    "discussion_id": "2180485929",
    "pr_number": 19041,
    "pr_file": "crates/ty_server/src/server/api/traits.rs",
    "created_at": "2025-07-02T16:22:48+00:00",
    "commented_code": "client: &Client,\n         params: <<Self as RequestHandler>::RequestType as Request>::Params,\n     ) -> super::Result<<<Self as RequestHandler>::RequestType as Request>::Result>;\n+}\n \n-    fn salsa_cancellation_error() -> lsp_server::ResponseError {\n-        lsp_server::ResponseError {\n-            code: lsp_server::ErrorCode::ContentModified as i32,\n-            message: \"content modified\".to_string(),\n-            data: None,\n-        }\n-    }\n+/// A request handler that can be run on a background thread.\n+pub(super) trait BackgroundRequestHandler: RetriableRequestHandler {\n+    fn run(\n+        snapshot: WorkspaceSnapshot,\n+        client: &Client,\n+        params: <<Self as RequestHandler>::RequestType as Request>::Params,\n+    ) -> super::Result<<<Self as RequestHandler>::RequestType as Request>::Result>;",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2180485929",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19041,
        "pr_file": "crates/ty_server/src/server/api/traits.rs",
        "discussion_id": "2180485929",
        "commented_code": "@@ -40,14 +53,15 @@ pub(super) trait BackgroundDocumentRequestHandler: RequestHandler {\n         client: &Client,\n         params: <<Self as RequestHandler>::RequestType as Request>::Params,\n     ) -> super::Result<<<Self as RequestHandler>::RequestType as Request>::Result>;\n+}\n \n-    fn salsa_cancellation_error() -> lsp_server::ResponseError {\n-        lsp_server::ResponseError {\n-            code: lsp_server::ErrorCode::ContentModified as i32,\n-            message: \"content modified\".to_string(),\n-            data: None,\n-        }\n-    }\n+/// A request handler that can be run on a background thread.\n+pub(super) trait BackgroundRequestHandler: RetriableRequestHandler {\n+    fn run(\n+        snapshot: WorkspaceSnapshot,\n+        client: &Client,\n+        params: <<Self as RequestHandler>::RequestType as Request>::Params,\n+    ) -> super::Result<<<Self as RequestHandler>::RequestType as Request>::Result>;",
        "comment_created_at": "2025-07-02T16:22:48+00:00",
        "comment_author": "BurntSushi",
        "comment_body": "One thing I'd find helpful here is some prose (perhaps on the module doc) that briefly explains the traits here and how they're connected.\r\n\r\nIf you think this code is going to be heavily refactored soon, then it might not make sense to add docs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2181780493",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19041,
        "pr_file": "crates/ty_server/src/server/api/traits.rs",
        "discussion_id": "2180485929",
        "commented_code": "@@ -40,14 +53,15 @@ pub(super) trait BackgroundDocumentRequestHandler: RequestHandler {\n         client: &Client,\n         params: <<Self as RequestHandler>::RequestType as Request>::Params,\n     ) -> super::Result<<<Self as RequestHandler>::RequestType as Request>::Result>;\n+}\n \n-    fn salsa_cancellation_error() -> lsp_server::ResponseError {\n-        lsp_server::ResponseError {\n-            code: lsp_server::ErrorCode::ContentModified as i32,\n-            message: \"content modified\".to_string(),\n-            data: None,\n-        }\n-    }\n+/// A request handler that can be run on a background thread.\n+pub(super) trait BackgroundRequestHandler: RetriableRequestHandler {\n+    fn run(\n+        snapshot: WorkspaceSnapshot,\n+        client: &Client,\n+        params: <<Self as RequestHandler>::RequestType as Request>::Params,\n+    ) -> super::Result<<<Self as RequestHandler>::RequestType as Request>::Result>;",
        "comment_created_at": "2025-07-03T05:28:25+00:00",
        "comment_author": "dhruvmanila",
        "comment_body": "Definitely! Most of this stuff is currently in my and Micha's mind but it would be useful to have it written down. I'll prioritize it soon as there are now more people who'll be working on the server.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2176600281",
    "pr_number": 18948,
    "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
    "created_at": "2025-07-01T07:05:37+00:00",
    "commented_code": "//! that adds that \"collapse `Never`\" behavior, whereas [`TupleSpec`] allows you to add any element\n //! types, including `Never`.)\n \n+use std::borrow::Borrow;\n+use std::cmp::Ordering;\n+use std::hash::Hash;\n+\n use itertools::{Either, EitherOrBoth, Itertools};\n \n use crate::types::class::{ClassType, KnownClass};\n-use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::types::{\n+    Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionBuilder, UnionType,\n+};\n use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n use crate::{Db, FxOrderSet};\n \n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub(crate) enum TupleLength {\n+    Fixed(usize),\n+    Variable(usize, usize),\n+}",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2176600281",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18948,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2176600281",
        "commented_code": "@@ -16,17 +16,71 @@\n //! that adds that \"collapse `Never`\" behavior, whereas [`TupleSpec`] allows you to add any element\n //! types, including `Never`.)\n \n+use std::borrow::Borrow;\n+use std::cmp::Ordering;\n+use std::hash::Hash;\n+\n use itertools::{Either, EitherOrBoth, Itertools};\n \n use crate::types::class::{ClassType, KnownClass};\n-use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::types::{\n+    Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionBuilder, UnionType,\n+};\n use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n use crate::{Db, FxOrderSet};\n \n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub(crate) enum TupleLength {\n+    Fixed(usize),\n+    Variable(usize, usize),\n+}",
        "comment_created_at": "2025-07-01T07:05:37+00:00",
        "comment_author": "dhruvmanila",
        "comment_body": "nit: it might be useful to document what these `usize`s are, especially the ones in `Variable` variant or just a reference to `VariableLengthTuple` to indicate that these are the length of `prefix` and `suffix` respectively",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163200562",
    "pr_number": 18799,
    "pr_file": "crates/ty_python_semantic/src/types.rs",
    "created_at": "2025-06-24T07:45:13+00:00",
    "commented_code": "}\n     }\n \n+    /// Return true if this is a type that is always fully static (has no dynamic part; represents\n+    /// a single set of possible values.)",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2163200562",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18799,
        "pr_file": "crates/ty_python_semantic/src/types.rs",
        "discussion_id": "2163200562",
        "commented_code": "@@ -1166,11 +1165,73 @@ impl<'db> Type<'db> {\n         }\n     }\n \n+    /// Return true if this is a type that is always fully static (has no dynamic part; represents\n+    /// a single set of possible values.)",
        "comment_created_at": "2025-06-24T07:45:13+00:00",
        "comment_author": "sharkdp",
        "comment_body": "If I understand the intention here correctly, should this maybe have a comment similar to \"this function may have false negatives, but should not have false positives\"?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162427100",
    "pr_number": 18864,
    "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
    "created_at": "2025-06-23T19:56:54+00:00",
    "commented_code": "/// class C(A, B): ...\n     /// ```\n     ///\n-    /// ## Known problems\n-    /// Dynamic (not tuple or string literal) `__slots__` are not checked.\n-    /// Additionally, classes inheriting from built-in classes with implicit layouts\n-    /// like `str` or `int` are also not checked.\n+    /// An \"instance layout conflict\" can also be caused by attempting to use\n+    /// multiple inheritance with two builtin classes, due to the way that these\n+    /// classes are special-cased by the CPython interpreter:\n     ///\n-    /// ```pycon\n-    /// >>> hasattr(int, \"__slots__\")\n-    /// False\n-    /// >>> hasattr(str, \"__slots__\")\n-    /// False\n-    /// >>> class A(int, str): ...\n-    /// Traceback (most recent call last):\n-    ///   File \"<python-input-0>\", line 1, in <module>\n-    ///     class A(int, str): ...\n-    /// TypeError: multiple bases have instance lay-out conflict\n+    /// ```python\n+    /// class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n     /// ```\n-    pub(crate) static INCOMPATIBLE_SLOTS = {\n-        summary: \"detects class definitions whose MRO has conflicting `__slots__`\",\n+    ///\n+    /// ## Known problems\n+    /// Classes that have \"dynamic\" definitions of `__slots__` (definitions do not consist\n+    /// of string literals, or tuples of string literals) are not currently considered solid\n+    /// bases by ty.\n+    ///\n+    /// Additionally, this check is not exhaustive: many C extensions (including several in\n+    /// the standard library) define classes that are considered \"solid bases\" at runtime.\n+    /// Since it is impossible to represent this fact in stub files, having a full knowledge\n+    /// of these classes would be impossible; ty only hard-codes a number of known cases.",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2162427100",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18864,
        "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
        "discussion_id": "2162427100",
        "commented_code": "@@ -346,24 +349,25 @@ declare_lint! {\n     /// class C(A, B): ...\n     /// ```\n     ///\n-    /// ## Known problems\n-    /// Dynamic (not tuple or string literal) `__slots__` are not checked.\n-    /// Additionally, classes inheriting from built-in classes with implicit layouts\n-    /// like `str` or `int` are also not checked.\n+    /// An \"instance layout conflict\" can also be caused by attempting to use\n+    /// multiple inheritance with two builtin classes, due to the way that these\n+    /// classes are special-cased by the CPython interpreter:\n     ///\n-    /// ```pycon\n-    /// >>> hasattr(int, \"__slots__\")\n-    /// False\n-    /// >>> hasattr(str, \"__slots__\")\n-    /// False\n-    /// >>> class A(int, str): ...\n-    /// Traceback (most recent call last):\n-    ///   File \"<python-input-0>\", line 1, in <module>\n-    ///     class A(int, str): ...\n-    /// TypeError: multiple bases have instance lay-out conflict\n+    /// ```python\n+    /// class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n     /// ```\n-    pub(crate) static INCOMPATIBLE_SLOTS = {\n-        summary: \"detects class definitions whose MRO has conflicting `__slots__`\",\n+    ///\n+    /// ## Known problems\n+    /// Classes that have \"dynamic\" definitions of `__slots__` (definitions do not consist\n+    /// of string literals, or tuples of string literals) are not currently considered solid\n+    /// bases by ty.\n+    ///\n+    /// Additionally, this check is not exhaustive: many C extensions (including several in\n+    /// the standard library) define classes that are considered \"solid bases\" at runtime.\n+    /// Since it is impossible to represent this fact in stub files, having a full knowledge\n+    /// of these classes would be impossible; ty only hard-codes a number of known cases.",
        "comment_created_at": "2025-06-23T19:56:54+00:00",
        "comment_author": "carljm",
        "comment_body": "Proposed edit to avoid the term \"solid base\" in user-facing documentation:\r\n\r\n```suggestion\r\n    /// Additionally, this check is not exhaustive: many C extensions (including several in\r\n    /// the standard library) define classes whose instances have an extended memory\r\n    /// layout, and thus can't be multiply-inherited with other such classes.\r\n    /// Since we don't currently represent this fact in stub files, having a full knowledge\r\n    /// of these classes would be impossible; ty only hard-codes a number of known cases.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2162525100",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18864,
        "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
        "discussion_id": "2162427100",
        "commented_code": "@@ -346,24 +349,25 @@ declare_lint! {\n     /// class C(A, B): ...\n     /// ```\n     ///\n-    /// ## Known problems\n-    /// Dynamic (not tuple or string literal) `__slots__` are not checked.\n-    /// Additionally, classes inheriting from built-in classes with implicit layouts\n-    /// like `str` or `int` are also not checked.\n+    /// An \"instance layout conflict\" can also be caused by attempting to use\n+    /// multiple inheritance with two builtin classes, due to the way that these\n+    /// classes are special-cased by the CPython interpreter:\n     ///\n-    /// ```pycon\n-    /// >>> hasattr(int, \"__slots__\")\n-    /// False\n-    /// >>> hasattr(str, \"__slots__\")\n-    /// False\n-    /// >>> class A(int, str): ...\n-    /// Traceback (most recent call last):\n-    ///   File \"<python-input-0>\", line 1, in <module>\n-    ///     class A(int, str): ...\n-    /// TypeError: multiple bases have instance lay-out conflict\n+    /// ```python\n+    /// class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n     /// ```\n-    pub(crate) static INCOMPATIBLE_SLOTS = {\n-        summary: \"detects class definitions whose MRO has conflicting `__slots__`\",\n+    ///\n+    /// ## Known problems\n+    /// Classes that have \"dynamic\" definitions of `__slots__` (definitions do not consist\n+    /// of string literals, or tuples of string literals) are not currently considered solid\n+    /// bases by ty.\n+    ///\n+    /// Additionally, this check is not exhaustive: many C extensions (including several in\n+    /// the standard library) define classes that are considered \"solid bases\" at runtime.\n+    /// Since it is impossible to represent this fact in stub files, having a full knowledge\n+    /// of these classes would be impossible; ty only hard-codes a number of known cases.",
        "comment_created_at": "2025-06-23T21:00:49+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "This is better than what I have, thanks! I'll apply a variant of it.\r\n\r\nI'm not sure that talking about an \"extended memory layout\" is _significantly_ more user-friendly than talking about a \"solid base\", though. I think few Python users think deeply about how their instances are laid out in memory; sort of the point of the language is that you shouldn't have to care most of the time. _I_ certainly don't think about this kind of thing most of the time when I'm writing Python.\r\n\r\nThe fundamental problem is that this is really a place where CPython leaks implementation details to end users and doesn't really document it properly anywhere. (If only we had a CPython core developer or two around here who could engage upstream and push for improvements there, right?! 😆)",
        "pr_file_module": null
      },
      {
        "comment_id": "2162590766",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18864,
        "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
        "discussion_id": "2162427100",
        "commented_code": "@@ -346,24 +349,25 @@ declare_lint! {\n     /// class C(A, B): ...\n     /// ```\n     ///\n-    /// ## Known problems\n-    /// Dynamic (not tuple or string literal) `__slots__` are not checked.\n-    /// Additionally, classes inheriting from built-in classes with implicit layouts\n-    /// like `str` or `int` are also not checked.\n+    /// An \"instance layout conflict\" can also be caused by attempting to use\n+    /// multiple inheritance with two builtin classes, due to the way that these\n+    /// classes are special-cased by the CPython interpreter:\n     ///\n-    /// ```pycon\n-    /// >>> hasattr(int, \"__slots__\")\n-    /// False\n-    /// >>> hasattr(str, \"__slots__\")\n-    /// False\n-    /// >>> class A(int, str): ...\n-    /// Traceback (most recent call last):\n-    ///   File \"<python-input-0>\", line 1, in <module>\n-    ///     class A(int, str): ...\n-    /// TypeError: multiple bases have instance lay-out conflict\n+    /// ```python\n+    /// class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n     /// ```\n-    pub(crate) static INCOMPATIBLE_SLOTS = {\n-        summary: \"detects class definitions whose MRO has conflicting `__slots__`\",\n+    ///\n+    /// ## Known problems\n+    /// Classes that have \"dynamic\" definitions of `__slots__` (definitions do not consist\n+    /// of string literals, or tuples of string literals) are not currently considered solid\n+    /// bases by ty.\n+    ///\n+    /// Additionally, this check is not exhaustive: many C extensions (including several in\n+    /// the standard library) define classes that are considered \"solid bases\" at runtime.\n+    /// Since it is impossible to represent this fact in stub files, having a full knowledge\n+    /// of these classes would be impossible; ty only hard-codes a number of known cases.",
        "comment_created_at": "2025-06-23T21:53:47+00:00",
        "comment_author": "carljm",
        "comment_body": "> The fundamental problem is that this is really a place where CPython leaks implementation details to end users and doesn't really document it properly anywhere.\r\n\r\nI agree with this.\r\n\r\n> I'm not sure that talking about an \"extended memory layout\" is _significantly_ more user-friendly than talking about a \"solid base\", though.\r\n\r\nBut I don't agree with this. I think talking about memory layouts _is_ significantly better.\r\n\r\nFor those users who don't understand or care to think about the underlying implementation details, I'll grant that both terms are equally gobbledygook that they'll just have to take our word for. I'm not sure we can do much better than that, for this category of user, given the \"fundamental problem\" you mentioned.\r\n\r\nBut there are a significant number of Python users who _do_ have systems programming experience (Micha, for example :) ), or are interested in learning about underlying Python implementation details, and making our diagnostics useful to those users matters as well. And for those users (assuming they haven't worked in the CPython codebase specifically), talking about \"solid bases\" will still be gobbledygook that doesn't even give useful Google search results, whereas talking about incompatible memory layouts will make sense and give them a good hook for googling and further exploration of the problem.\r\n\r\nAlso, the diagnostic itself is called `[instance-layout-conflict]`, so we may as well stick to a single way of describing it.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2162606944",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18864,
        "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
        "discussion_id": "2162427100",
        "commented_code": "@@ -346,24 +349,25 @@ declare_lint! {\n     /// class C(A, B): ...\n     /// ```\n     ///\n-    /// ## Known problems\n-    /// Dynamic (not tuple or string literal) `__slots__` are not checked.\n-    /// Additionally, classes inheriting from built-in classes with implicit layouts\n-    /// like `str` or `int` are also not checked.\n+    /// An \"instance layout conflict\" can also be caused by attempting to use\n+    /// multiple inheritance with two builtin classes, due to the way that these\n+    /// classes are special-cased by the CPython interpreter:\n     ///\n-    /// ```pycon\n-    /// >>> hasattr(int, \"__slots__\")\n-    /// False\n-    /// >>> hasattr(str, \"__slots__\")\n-    /// False\n-    /// >>> class A(int, str): ...\n-    /// Traceback (most recent call last):\n-    ///   File \"<python-input-0>\", line 1, in <module>\n-    ///     class A(int, str): ...\n-    /// TypeError: multiple bases have instance lay-out conflict\n+    /// ```python\n+    /// class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n     /// ```\n-    pub(crate) static INCOMPATIBLE_SLOTS = {\n-        summary: \"detects class definitions whose MRO has conflicting `__slots__`\",\n+    ///\n+    /// ## Known problems\n+    /// Classes that have \"dynamic\" definitions of `__slots__` (definitions do not consist\n+    /// of string literals, or tuples of string literals) are not currently considered solid\n+    /// bases by ty.\n+    ///\n+    /// Additionally, this check is not exhaustive: many C extensions (including several in\n+    /// the standard library) define classes that are considered \"solid bases\" at runtime.\n+    /// Since it is impossible to represent this fact in stub files, having a full knowledge\n+    /// of these classes would be impossible; ty only hard-codes a number of known cases.",
        "comment_created_at": "2025-06-23T22:09:21+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "Right, I agree that your wording is better here, for all the reasons you mentioned! I just wish we didn't have to talk about \"solid bases\" _or_ \"extended memory layouts\" since, if this type checker is successful, my experience from triaging mypy issues suggests we'll have lots of users who are new to programming in general :-)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2125915934",
    "pr_number": 18445,
    "pr_file": "crates/ty_python_semantic/src/types/class.rs",
    "created_at": "2025-06-04T07:46:20+00:00",
    "commented_code": "/// ## Note\n     /// Only call this function from queries in the same file or your\n     /// query depends on the AST of another file (bad!).\n-    fn node(self, db: &'db dyn Db) -> &'db ast::StmtClassDef {\n-        self.body_scope(db).node(db).expect_class()\n+    fn node<'ast>(self, db: &'db dyn Db, module: &'ast ParsedModuleRef) -> &'ast ast::StmtClassDef {",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2125915934",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18445,
        "pr_file": "crates/ty_python_semantic/src/types/class.rs",
        "discussion_id": "2125915934",
        "commented_code": "@@ -758,14 +760,16 @@ impl<'db> ClassLiteral<'db> {\n     /// ## Note\n     /// Only call this function from queries in the same file or your\n     /// query depends on the AST of another file (bad!).\n-    fn node(self, db: &'db dyn Db) -> &'db ast::StmtClassDef {\n-        self.body_scope(db).node(db).expect_class()\n+    fn node<'ast>(self, db: &'db dyn Db, module: &'ast ParsedModuleRef) -> &'ast ast::StmtClassDef {",
        "comment_created_at": "2025-06-04T07:46:20+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "It's probably a bit excessive to document this everywhere but we should document it at least for `AstNodeRef` that the method panics if `module` belongs to a different file.",
        "pr_file_module": null
      }
    ]
  }
]