[
  {
    "discussion_id": "2173458569",
    "pr_number": 19008,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/import/dunder_import.md",
    "created_at": "2025-06-28T17:43:10+00:00",
    "commented_code": null,
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2173458569",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19008,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/import/dunder_import.md",
        "discussion_id": "2173458569",
        "commented_code": null,
        "comment_created_at": "2025-06-28T17:43:10+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "I don't think this test file should be in the `import/` subdirectory. It doesn't have anything to do with our behaviour regarding import resolution; it demonstrates our special-casing of two standard-library functions. I think this folder would be a better fit; it's where most of our tests for our other special-cased functions are (`getatt_static`, etc.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2173468778",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19008,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/import/dunder_import.md",
        "discussion_id": "2173458569",
        "commented_code": null,
        "comment_created_at": "2025-06-28T17:56:25+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "er, sorry for the garbled review comment there. I meant to link to this folder as the one I think this test file should go in: https://github.com/astral-sh/ruff/tree/main/crates/ty_python_semantic/resources/mdtest/call",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2138647559",
    "pr_number": 18594,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/top_materialization.md",
    "created_at": "2025-06-10T19:41:44+00:00",
    "commented_code": "+# Top materialization\n+\n+The top materialization or upper bound materialization of a type is the most general form of that\n+type which is fully static.\n+\n+More concretely, `T'`, the top materialization of `T`, is the type `T` with all occurrences of `Any`\n+and `Unknown` replaced as follows:\n+\n+- In covariant position, it's replaced with `object`\n+- In contravariant position, it's replaced with `Never`\n+- In invariant position, it's replaced with an unresolved type variable\n+\n+For an invariant position, it should actually be replaced with a `forall T. list[T]`, but this is\n+not representable in our type system, so we use an unresolved type variable instead.\n+\n+## Replacement rules\n+\n+```py\n+from typing import Any, Callable\n+from ty_extensions import Unknown, top_materialization\n+\n+# Covariant position\n+reveal_type(top_materialization(Any))  # revealed: object\n+reveal_type(top_materialization(Unknown))  # revealed: object\n+\n+# Contravariant position\n+reveal_type(top_materialization(Callable[[Any], None]))  # revealed: (Never, /) -> None\n+\n+# Invariant position\n+reveal_type(top_materialization(list[Any]))  # revealed: list[T]\n+```\n+\n+## Fully static types\n+\n+The top materialization is mainly useful for gradual types, so any fully static type would remain\n+unchanged.\n+\n+```py\n+from typing import Any, Literal\n+from ty_extensions import TypeOf, top_materialization\n+\n+reveal_type(top_materialization(int))  # revealed: int\n+reveal_type(top_materialization(Literal[1]))  # revealed: Literal[1]\n+reveal_type(top_materialization(Literal[True]))  # revealed: Literal[True]\n+reveal_type(top_materialization(Literal[\"abc\"]))  # revealed: Literal[\"abc\"]\n+reveal_type(top_materialization(int | str))  # revealed: int | str\n+```\n+\n+Function literals are fully static types, so they remain unchanged even though the signature might\n+have `Any` in it.\n+\n+```py\n+def function(x: Any) -> None: ...\n+\n+class A:\n+    def method(self, x: Any) -> None: ...\n+\n+reveal_type(top_materialization(TypeOf[function]))  # revealed: def function(x: Any) -> None\n+reveal_type(top_materialization(TypeOf[A().method]))  # revealed: bound method A.method(x: Any) -> None\n+```\n+\n+## Tuple\n+\n+All positions in a tuple are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(tuple[Any, int]))  # revealed: tuple[object, int]\n+reveal_type(top_materialization(tuple[Unknown, int]))  # revealed: tuple[object, int]\n+reveal_type(top_materialization(tuple[Any, int, Unknown]))  # revealed: tuple[object, int, object]\n+```\n+\n+Except for when the tuple itself is in a contravariant position, then all positions in the tuple\n+inherit the contravariant position.\n+\n+```py\n+from typing import Callable\n+\n+# revealed: (Never, Never, /) -> None\n+reveal_type(top_materialization(Callable[[tuple[Any, int], tuple[str, Unknown]], None]))\n+```\n+\n+And, similarly for an invariant position.\n+\n+```py\n+reveal_type(top_materialization(list[tuple[Any, int]]))  # revealed: list[tuple[T, int]]\n+reveal_type(top_materialization(list[tuple[str, Unknown]]))  # revealed: list[tuple[str, T]]\n+reveal_type(top_materialization(list[tuple[Any, int, Unknown]]))  # revealed: list[tuple[T, int, T]]\n+```\n+\n+## Union\n+\n+All positions in a union are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(Any | int))  # revealed: object\n+reveal_type(top_materialization(Unknown | int))  # revealed: object\n+reveal_type(top_materialization(int | str | Any))  # revealed: object\n+```\n+\n+Except for when the union itself is in a contravariant position, then all positions in the union\n+inherit the contravariant position.\n+\n+```py\n+from typing import Callable\n+\n+# revealed: (int, str, /) -> None\n+reveal_type(top_materialization(Callable[[Any | int, str | Unknown], None]))\n+```\n+\n+And, similarly for an invariant position.\n+\n+```py\n+reveal_type(top_materialization(list[Any | int]))  # revealed: list[T | int]\n+reveal_type(top_materialization(list[str | Unknown]))  # revealed: list[str | T]\n+reveal_type(top_materialization(list[Any | int | Unknown]))  # revealed: list[T | int]\n+```\n+\n+## Intersection\n+\n+All positions in an intersection are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Intersection, Unknown, top_materialization\n+\n+reveal_type(top_materialization(Intersection[Any, int]))  # revealed: int\n+\n+# Here, the top materialization of `Any | int` is `object` and the intersection of it with tuple\n+# revealed: tuple[str, object]\n+reveal_type(top_materialization(Intersection[Any | int, tuple[str, Unknown]]))\n+\n+reveal_type(top_materialization(Intersection[list[Any], list[int]]))  # revealed: list[T] & list[int]\n+```\n+\n+## Negation (via `Not`)\n+\n+All positions in a negation are contravariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Not, Unknown, top_materialization\n+\n+# ~Any is still Any, so the top materialization is object\n+reveal_type(top_materialization(Not[Any]))  # revealed: object\n+\n+# tuple[Any, int] is in a contravariant position, so the\n+# top materialization is Never and the negation of it\n+# revealed: object\n+reveal_type(top_materialization(Not[tuple[Any, int]]))\n+```\n+\n+## `type`\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(type[Any]))  # revealed: type\n+reveal_type(top_materialization(type[Unknown]))  # revealed: type\n+reveal_type(top_materialization(type[int | Any]))  # revealed: type\n+```\n+\n+## Type variables\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+```py\n+from typing import Any, TypeVar\n+from ty_extensions import TypeOf, Unknown, top_materialization, is_fully_static, static_assert\n+\n+def bounded_by_gradual[T: Any](t: T) -> None:\n+    static_assert(not is_fully_static(T))\n+    static_assert(is_fully_static(TypeOf[top_materialization(T)]))\n+\n+def constrained_by_gradual[T: (int, Any)](t: T) -> None:\n+    static_assert(not is_fully_static(T))\n+    static_assert(is_fully_static(TypeOf[top_materialization(T)]))\n+```\n+\n+## Generics\n+\n+For generics, the top materialization depends on whether the type variable is covariant or\n+contravariant.\n+\n+```py\n+from typing import Any, Generic, TypeVar\n+from ty_extensions import top_materialization\n+\n+T = TypeVar(\"T\")\n+T_co = TypeVar(\"T_co\", covariant=True)\n+T_contra = TypeVar(\"T_contra\", contravariant=True)\n+\n+class GenericInvariant(Generic[T]):\n+    pass\n+\n+class GenericCovariant(Generic[T_co]):\n+    pass\n+\n+class GenericContravariant(Generic[T_contra]):\n+    pass\n+\n+reveal_type(top_materialization(GenericInvariant[Any]))  # revealed: GenericInvariant[T]\n+reveal_type(top_materialization(GenericCovariant[Any]))  # revealed: GenericCovariant[object]\n+reveal_type(top_materialization(GenericContravariant[Any]))  # revealed: GenericContravariant[Never]\n+```\n+\n+## Callable",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2138647559",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18594,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/top_materialization.md",
        "discussion_id": "2138647559",
        "commented_code": "@@ -0,0 +1,233 @@\n+# Top materialization\n+\n+The top materialization or upper bound materialization of a type is the most general form of that\n+type which is fully static.\n+\n+More concretely, `T'`, the top materialization of `T`, is the type `T` with all occurrences of `Any`\n+and `Unknown` replaced as follows:\n+\n+- In covariant position, it's replaced with `object`\n+- In contravariant position, it's replaced with `Never`\n+- In invariant position, it's replaced with an unresolved type variable\n+\n+For an invariant position, it should actually be replaced with a `forall T. list[T]`, but this is\n+not representable in our type system, so we use an unresolved type variable instead.\n+\n+## Replacement rules\n+\n+```py\n+from typing import Any, Callable\n+from ty_extensions import Unknown, top_materialization\n+\n+# Covariant position\n+reveal_type(top_materialization(Any))  # revealed: object\n+reveal_type(top_materialization(Unknown))  # revealed: object\n+\n+# Contravariant position\n+reveal_type(top_materialization(Callable[[Any], None]))  # revealed: (Never, /) -> None\n+\n+# Invariant position\n+reveal_type(top_materialization(list[Any]))  # revealed: list[T]\n+```\n+\n+## Fully static types\n+\n+The top materialization is mainly useful for gradual types, so any fully static type would remain\n+unchanged.\n+\n+```py\n+from typing import Any, Literal\n+from ty_extensions import TypeOf, top_materialization\n+\n+reveal_type(top_materialization(int))  # revealed: int\n+reveal_type(top_materialization(Literal[1]))  # revealed: Literal[1]\n+reveal_type(top_materialization(Literal[True]))  # revealed: Literal[True]\n+reveal_type(top_materialization(Literal[\"abc\"]))  # revealed: Literal[\"abc\"]\n+reveal_type(top_materialization(int | str))  # revealed: int | str\n+```\n+\n+Function literals are fully static types, so they remain unchanged even though the signature might\n+have `Any` in it.\n+\n+```py\n+def function(x: Any) -> None: ...\n+\n+class A:\n+    def method(self, x: Any) -> None: ...\n+\n+reveal_type(top_materialization(TypeOf[function]))  # revealed: def function(x: Any) -> None\n+reveal_type(top_materialization(TypeOf[A().method]))  # revealed: bound method A.method(x: Any) -> None\n+```\n+\n+## Tuple\n+\n+All positions in a tuple are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(tuple[Any, int]))  # revealed: tuple[object, int]\n+reveal_type(top_materialization(tuple[Unknown, int]))  # revealed: tuple[object, int]\n+reveal_type(top_materialization(tuple[Any, int, Unknown]))  # revealed: tuple[object, int, object]\n+```\n+\n+Except for when the tuple itself is in a contravariant position, then all positions in the tuple\n+inherit the contravariant position.\n+\n+```py\n+from typing import Callable\n+\n+# revealed: (Never, Never, /) -> None\n+reveal_type(top_materialization(Callable[[tuple[Any, int], tuple[str, Unknown]], None]))\n+```\n+\n+And, similarly for an invariant position.\n+\n+```py\n+reveal_type(top_materialization(list[tuple[Any, int]]))  # revealed: list[tuple[T, int]]\n+reveal_type(top_materialization(list[tuple[str, Unknown]]))  # revealed: list[tuple[str, T]]\n+reveal_type(top_materialization(list[tuple[Any, int, Unknown]]))  # revealed: list[tuple[T, int, T]]\n+```\n+\n+## Union\n+\n+All positions in a union are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(Any | int))  # revealed: object\n+reveal_type(top_materialization(Unknown | int))  # revealed: object\n+reveal_type(top_materialization(int | str | Any))  # revealed: object\n+```\n+\n+Except for when the union itself is in a contravariant position, then all positions in the union\n+inherit the contravariant position.\n+\n+```py\n+from typing import Callable\n+\n+# revealed: (int, str, /) -> None\n+reveal_type(top_materialization(Callable[[Any | int, str | Unknown], None]))\n+```\n+\n+And, similarly for an invariant position.\n+\n+```py\n+reveal_type(top_materialization(list[Any | int]))  # revealed: list[T | int]\n+reveal_type(top_materialization(list[str | Unknown]))  # revealed: list[str | T]\n+reveal_type(top_materialization(list[Any | int | Unknown]))  # revealed: list[T | int]\n+```\n+\n+## Intersection\n+\n+All positions in an intersection are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Intersection, Unknown, top_materialization\n+\n+reveal_type(top_materialization(Intersection[Any, int]))  # revealed: int\n+\n+# Here, the top materialization of `Any | int` is `object` and the intersection of it with tuple\n+# revealed: tuple[str, object]\n+reveal_type(top_materialization(Intersection[Any | int, tuple[str, Unknown]]))\n+\n+reveal_type(top_materialization(Intersection[list[Any], list[int]]))  # revealed: list[T] & list[int]\n+```\n+\n+## Negation (via `Not`)\n+\n+All positions in a negation are contravariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Not, Unknown, top_materialization\n+\n+# ~Any is still Any, so the top materialization is object\n+reveal_type(top_materialization(Not[Any]))  # revealed: object\n+\n+# tuple[Any, int] is in a contravariant position, so the\n+# top materialization is Never and the negation of it\n+# revealed: object\n+reveal_type(top_materialization(Not[tuple[Any, int]]))\n+```\n+\n+## `type`\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(type[Any]))  # revealed: type\n+reveal_type(top_materialization(type[Unknown]))  # revealed: type\n+reveal_type(top_materialization(type[int | Any]))  # revealed: type\n+```\n+\n+## Type variables\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+```py\n+from typing import Any, TypeVar\n+from ty_extensions import TypeOf, Unknown, top_materialization, is_fully_static, static_assert\n+\n+def bounded_by_gradual[T: Any](t: T) -> None:\n+    static_assert(not is_fully_static(T))\n+    static_assert(is_fully_static(TypeOf[top_materialization(T)]))\n+\n+def constrained_by_gradual[T: (int, Any)](t: T) -> None:\n+    static_assert(not is_fully_static(T))\n+    static_assert(is_fully_static(TypeOf[top_materialization(T)]))\n+```\n+\n+## Generics\n+\n+For generics, the top materialization depends on whether the type variable is covariant or\n+contravariant.\n+\n+```py\n+from typing import Any, Generic, TypeVar\n+from ty_extensions import top_materialization\n+\n+T = TypeVar(\"T\")\n+T_co = TypeVar(\"T_co\", covariant=True)\n+T_contra = TypeVar(\"T_contra\", contravariant=True)\n+\n+class GenericInvariant(Generic[T]):\n+    pass\n+\n+class GenericCovariant(Generic[T_co]):\n+    pass\n+\n+class GenericContravariant(Generic[T_contra]):\n+    pass\n+\n+reveal_type(top_materialization(GenericInvariant[Any]))  # revealed: GenericInvariant[T]\n+reveal_type(top_materialization(GenericCovariant[Any]))  # revealed: GenericCovariant[object]\n+reveal_type(top_materialization(GenericContravariant[Any]))  # revealed: GenericContravariant[Never]\n+```\n+\n+## Callable",
        "comment_created_at": "2025-06-10T19:41:44+00:00",
        "comment_author": "carljm",
        "comment_body": "Nit: I might put this section much further up (like above tuples), because many of the other sections rely on using callable arguments to create a contravariant context.",
        "pr_file_module": null
      },
      {
        "comment_id": "2139105256",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18594,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/top_materialization.md",
        "discussion_id": "2138647559",
        "commented_code": "@@ -0,0 +1,233 @@\n+# Top materialization\n+\n+The top materialization or upper bound materialization of a type is the most general form of that\n+type which is fully static.\n+\n+More concretely, `T'`, the top materialization of `T`, is the type `T` with all occurrences of `Any`\n+and `Unknown` replaced as follows:\n+\n+- In covariant position, it's replaced with `object`\n+- In contravariant position, it's replaced with `Never`\n+- In invariant position, it's replaced with an unresolved type variable\n+\n+For an invariant position, it should actually be replaced with a `forall T. list[T]`, but this is\n+not representable in our type system, so we use an unresolved type variable instead.\n+\n+## Replacement rules\n+\n+```py\n+from typing import Any, Callable\n+from ty_extensions import Unknown, top_materialization\n+\n+# Covariant position\n+reveal_type(top_materialization(Any))  # revealed: object\n+reveal_type(top_materialization(Unknown))  # revealed: object\n+\n+# Contravariant position\n+reveal_type(top_materialization(Callable[[Any], None]))  # revealed: (Never, /) -> None\n+\n+# Invariant position\n+reveal_type(top_materialization(list[Any]))  # revealed: list[T]\n+```\n+\n+## Fully static types\n+\n+The top materialization is mainly useful for gradual types, so any fully static type would remain\n+unchanged.\n+\n+```py\n+from typing import Any, Literal\n+from ty_extensions import TypeOf, top_materialization\n+\n+reveal_type(top_materialization(int))  # revealed: int\n+reveal_type(top_materialization(Literal[1]))  # revealed: Literal[1]\n+reveal_type(top_materialization(Literal[True]))  # revealed: Literal[True]\n+reveal_type(top_materialization(Literal[\"abc\"]))  # revealed: Literal[\"abc\"]\n+reveal_type(top_materialization(int | str))  # revealed: int | str\n+```\n+\n+Function literals are fully static types, so they remain unchanged even though the signature might\n+have `Any` in it.\n+\n+```py\n+def function(x: Any) -> None: ...\n+\n+class A:\n+    def method(self, x: Any) -> None: ...\n+\n+reveal_type(top_materialization(TypeOf[function]))  # revealed: def function(x: Any) -> None\n+reveal_type(top_materialization(TypeOf[A().method]))  # revealed: bound method A.method(x: Any) -> None\n+```\n+\n+## Tuple\n+\n+All positions in a tuple are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(tuple[Any, int]))  # revealed: tuple[object, int]\n+reveal_type(top_materialization(tuple[Unknown, int]))  # revealed: tuple[object, int]\n+reveal_type(top_materialization(tuple[Any, int, Unknown]))  # revealed: tuple[object, int, object]\n+```\n+\n+Except for when the tuple itself is in a contravariant position, then all positions in the tuple\n+inherit the contravariant position.\n+\n+```py\n+from typing import Callable\n+\n+# revealed: (Never, Never, /) -> None\n+reveal_type(top_materialization(Callable[[tuple[Any, int], tuple[str, Unknown]], None]))\n+```\n+\n+And, similarly for an invariant position.\n+\n+```py\n+reveal_type(top_materialization(list[tuple[Any, int]]))  # revealed: list[tuple[T, int]]\n+reveal_type(top_materialization(list[tuple[str, Unknown]]))  # revealed: list[tuple[str, T]]\n+reveal_type(top_materialization(list[tuple[Any, int, Unknown]]))  # revealed: list[tuple[T, int, T]]\n+```\n+\n+## Union\n+\n+All positions in a union are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(Any | int))  # revealed: object\n+reveal_type(top_materialization(Unknown | int))  # revealed: object\n+reveal_type(top_materialization(int | str | Any))  # revealed: object\n+```\n+\n+Except for when the union itself is in a contravariant position, then all positions in the union\n+inherit the contravariant position.\n+\n+```py\n+from typing import Callable\n+\n+# revealed: (int, str, /) -> None\n+reveal_type(top_materialization(Callable[[Any | int, str | Unknown], None]))\n+```\n+\n+And, similarly for an invariant position.\n+\n+```py\n+reveal_type(top_materialization(list[Any | int]))  # revealed: list[T | int]\n+reveal_type(top_materialization(list[str | Unknown]))  # revealed: list[str | T]\n+reveal_type(top_materialization(list[Any | int | Unknown]))  # revealed: list[T | int]\n+```\n+\n+## Intersection\n+\n+All positions in an intersection are covariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Intersection, Unknown, top_materialization\n+\n+reveal_type(top_materialization(Intersection[Any, int]))  # revealed: int\n+\n+# Here, the top materialization of `Any | int` is `object` and the intersection of it with tuple\n+# revealed: tuple[str, object]\n+reveal_type(top_materialization(Intersection[Any | int, tuple[str, Unknown]]))\n+\n+reveal_type(top_materialization(Intersection[list[Any], list[int]]))  # revealed: list[T] & list[int]\n+```\n+\n+## Negation (via `Not`)\n+\n+All positions in a negation are contravariant.\n+\n+```py\n+from typing import Any\n+from ty_extensions import Not, Unknown, top_materialization\n+\n+# ~Any is still Any, so the top materialization is object\n+reveal_type(top_materialization(Not[Any]))  # revealed: object\n+\n+# tuple[Any, int] is in a contravariant position, so the\n+# top materialization is Never and the negation of it\n+# revealed: object\n+reveal_type(top_materialization(Not[tuple[Any, int]]))\n+```\n+\n+## `type`\n+\n+```py\n+from typing import Any\n+from ty_extensions import Unknown, top_materialization\n+\n+reveal_type(top_materialization(type[Any]))  # revealed: type\n+reveal_type(top_materialization(type[Unknown]))  # revealed: type\n+reveal_type(top_materialization(type[int | Any]))  # revealed: type\n+```\n+\n+## Type variables\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+```py\n+from typing import Any, TypeVar\n+from ty_extensions import TypeOf, Unknown, top_materialization, is_fully_static, static_assert\n+\n+def bounded_by_gradual[T: Any](t: T) -> None:\n+    static_assert(not is_fully_static(T))\n+    static_assert(is_fully_static(TypeOf[top_materialization(T)]))\n+\n+def constrained_by_gradual[T: (int, Any)](t: T) -> None:\n+    static_assert(not is_fully_static(T))\n+    static_assert(is_fully_static(TypeOf[top_materialization(T)]))\n+```\n+\n+## Generics\n+\n+For generics, the top materialization depends on whether the type variable is covariant or\n+contravariant.\n+\n+```py\n+from typing import Any, Generic, TypeVar\n+from ty_extensions import top_materialization\n+\n+T = TypeVar(\"T\")\n+T_co = TypeVar(\"T_co\", covariant=True)\n+T_contra = TypeVar(\"T_contra\", contravariant=True)\n+\n+class GenericInvariant(Generic[T]):\n+    pass\n+\n+class GenericCovariant(Generic[T_co]):\n+    pass\n+\n+class GenericContravariant(Generic[T_contra]):\n+    pass\n+\n+reveal_type(top_materialization(GenericInvariant[Any]))  # revealed: GenericInvariant[T]\n+reveal_type(top_materialization(GenericCovariant[Any]))  # revealed: GenericCovariant[object]\n+reveal_type(top_materialization(GenericContravariant[Any]))  # revealed: GenericContravariant[Never]\n+```\n+\n+## Callable",
        "comment_created_at": "2025-06-11T03:03:43+00:00",
        "comment_author": "dhruvmanila",
        "comment_body": "Yeah, that makes sense.",
        "pr_file_module": null
      }
    ]
  }
]