[
  {
    "discussion_id": "2165246729",
    "pr_number": 18713,
    "pr_file": "crates/ty_python_semantic/src/types.rs",
    "created_at": "2025-06-25T01:24:41+00:00",
    "commented_code": "Place::bound(Type::Never).into()\n }\n \n+pub(crate) trait VarianceInferable<'db>: Sized {",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2165246729",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18713,
        "pr_file": "crates/ty_python_semantic/src/types.rs",
        "discussion_id": "2165246729",
        "commented_code": "@@ -284,6 +284,81 @@ fn class_lookup_cycle_initial<'db>(\n     Place::bound(Type::Never).into()\n }\n \n+pub(crate) trait VarianceInferable<'db>: Sized {",
        "comment_created_at": "2025-06-25T01:24:41+00:00",
        "comment_author": "dcreager",
        "comment_body": "We are (starting to) try to cut back on the size of this file. Could you move the new variance-related stuff into a new `types/variance.rs` submodule?",
        "pr_file_module": null
      },
      {
        "comment_id": "2173551744",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18713,
        "pr_file": "crates/ty_python_semantic/src/types.rs",
        "discussion_id": "2165246729",
        "commented_code": "@@ -284,6 +284,81 @@ fn class_lookup_cycle_initial<'db>(\n     Place::bound(Type::Never).into()\n }\n \n+pub(crate) trait VarianceInferable<'db>: Sized {",
        "comment_created_at": "2025-06-28T23:24:56+00:00",
        "comment_author": "ericmarkmartin",
        "comment_body": "Would you move all the trait impls too?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182245444",
    "pr_number": 19108,
    "pr_file": "crates/ty_server/src/server/api/requests/semantic_tokens.rs",
    "created_at": "2025-07-03T08:57:14+00:00",
    "commented_code": "+use std::borrow::Cow;\n+\n+use crate::DocumentSnapshot;\n+use crate::document::PositionExt;\n+use crate::server::api::traits::{BackgroundDocumentRequestHandler, RequestHandler};\n+use crate::session::client::Client;\n+use lsp_types::{\n+    SemanticToken, SemanticTokens, SemanticTokensParams, SemanticTokensRangeParams,\n+    SemanticTokensRangeResult, SemanticTokensResult, Url,\n+};\n+use ruff_db::source::{line_index, source_text};\n+use ruff_text_size::{TextLen, TextRange};\n+use ty_ide::semantic_tokens;\n+use ty_project::ProjectDatabase;\n+\n+/// Common logic for generating semantic tokens, either for full document or a specific range.\n+/// If no range is provided, the entire file is processed.\n+fn generate_semantic_tokens(\n+    db: &ProjectDatabase,\n+    file: ruff_db::files::File,\n+    range: Option<TextRange>,\n+) -> Option<Vec<SemanticToken>> {\n+    let source = source_text(db, file);\n+    let line_index = line_index(db, file);\n+\n+    let requested_range = range.unwrap_or_else(|| TextRange::new(0.into(), source.text_len()));\n+    let semantic_token_data = semantic_tokens(db, file, requested_range);\n+\n+    let semantic_token_data = semantic_token_data?;\n+\n+    // Convert semantic tokens to LSP format with delta encoding\n+    // Sort tokens by position to ensure proper delta encoding\n+    // This prevents integer underflow when computing deltas for out-of-order tokens\n+    let mut sorted_tokens = semantic_token_data.tokens;\n+    sorted_tokens.sort_by_key(|token| token.range.start());\n+\n+    // Convert semantic tokens to LSP format\n+    let mut lsp_tokens = Vec::new();\n+    let mut prev_line = 0u32;\n+    let mut prev_start = 0u32;\n+\n+    for token in sorted_tokens {\n+        let start_position = line_index.line_column(token.range.start(), &source);\n+        let line = u32::try_from(start_position.line.to_zero_indexed()).unwrap_or(u32::MAX);\n+        let character = u32::try_from(start_position.column.to_zero_indexed()).unwrap_or(u32::MAX);\n+        let length = token.range.len().to_u32();\n+        let token_type = token.token_type as u32;\n+        let token_modifiers = token\n+            .modifiers\n+            .iter()\n+            .fold(0u32, |acc, modifier| acc | (1 << (*modifier as u32)));\n+\n+        // LSP semantic tokens are encoded as deltas\n+        let delta_line = line - prev_line;\n+        let delta_start = if delta_line == 0 {\n+            character - prev_start\n+        } else {\n+            character\n+        };\n+\n+        lsp_tokens.push(SemanticToken {\n+            delta_line,\n+            delta_start,\n+            length,\n+            token_type,\n+            token_modifiers_bitset: token_modifiers,\n+        });\n+\n+        prev_line = line;\n+        prev_start = character;\n+    }\n+\n+    Some(lsp_tokens)\n+}\n+\n+pub(crate) struct SemanticTokensRequestHandler;\n+\n+impl RequestHandler for SemanticTokensRequestHandler {\n+    type RequestType = lsp_types::request::SemanticTokensFullRequest;\n+}\n+\n+impl BackgroundDocumentRequestHandler for SemanticTokensRequestHandler {",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2182245444",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19108,
        "pr_file": "crates/ty_server/src/server/api/requests/semantic_tokens.rs",
        "discussion_id": "2182245444",
        "commented_code": "@@ -0,0 +1,165 @@\n+use std::borrow::Cow;\n+\n+use crate::DocumentSnapshot;\n+use crate::document::PositionExt;\n+use crate::server::api::traits::{BackgroundDocumentRequestHandler, RequestHandler};\n+use crate::session::client::Client;\n+use lsp_types::{\n+    SemanticToken, SemanticTokens, SemanticTokensParams, SemanticTokensRangeParams,\n+    SemanticTokensRangeResult, SemanticTokensResult, Url,\n+};\n+use ruff_db::source::{line_index, source_text};\n+use ruff_text_size::{TextLen, TextRange};\n+use ty_ide::semantic_tokens;\n+use ty_project::ProjectDatabase;\n+\n+/// Common logic for generating semantic tokens, either for full document or a specific range.\n+/// If no range is provided, the entire file is processed.\n+fn generate_semantic_tokens(\n+    db: &ProjectDatabase,\n+    file: ruff_db::files::File,\n+    range: Option<TextRange>,\n+) -> Option<Vec<SemanticToken>> {\n+    let source = source_text(db, file);\n+    let line_index = line_index(db, file);\n+\n+    let requested_range = range.unwrap_or_else(|| TextRange::new(0.into(), source.text_len()));\n+    let semantic_token_data = semantic_tokens(db, file, requested_range);\n+\n+    let semantic_token_data = semantic_token_data?;\n+\n+    // Convert semantic tokens to LSP format with delta encoding\n+    // Sort tokens by position to ensure proper delta encoding\n+    // This prevents integer underflow when computing deltas for out-of-order tokens\n+    let mut sorted_tokens = semantic_token_data.tokens;\n+    sorted_tokens.sort_by_key(|token| token.range.start());\n+\n+    // Convert semantic tokens to LSP format\n+    let mut lsp_tokens = Vec::new();\n+    let mut prev_line = 0u32;\n+    let mut prev_start = 0u32;\n+\n+    for token in sorted_tokens {\n+        let start_position = line_index.line_column(token.range.start(), &source);\n+        let line = u32::try_from(start_position.line.to_zero_indexed()).unwrap_or(u32::MAX);\n+        let character = u32::try_from(start_position.column.to_zero_indexed()).unwrap_or(u32::MAX);\n+        let length = token.range.len().to_u32();\n+        let token_type = token.token_type as u32;\n+        let token_modifiers = token\n+            .modifiers\n+            .iter()\n+            .fold(0u32, |acc, modifier| acc | (1 << (*modifier as u32)));\n+\n+        // LSP semantic tokens are encoded as deltas\n+        let delta_line = line - prev_line;\n+        let delta_start = if delta_line == 0 {\n+            character - prev_start\n+        } else {\n+            character\n+        };\n+\n+        lsp_tokens.push(SemanticToken {\n+            delta_line,\n+            delta_start,\n+            length,\n+            token_type,\n+            token_modifiers_bitset: token_modifiers,\n+        });\n+\n+        prev_line = line;\n+        prev_start = character;\n+    }\n+\n+    Some(lsp_tokens)\n+}\n+\n+pub(crate) struct SemanticTokensRequestHandler;\n+\n+impl RequestHandler for SemanticTokensRequestHandler {\n+    type RequestType = lsp_types::request::SemanticTokensFullRequest;\n+}\n+\n+impl BackgroundDocumentRequestHandler for SemanticTokensRequestHandler {",
        "comment_created_at": "2025-07-03T08:57:14+00:00",
        "comment_author": "dhruvmanila",
        "comment_body": "The convention that we've established is to keep each handler corresponding to either a request or notification to be in a single file. Do you mind moving either the `SemanticTokensRequestHandler` or `SemanticTokensRangeRequestHandler` in a separate file? We can use a common `crates/ty_server/src/server/api/semantic_tokens.rs` file to contain the `generate_semantic_tokens` function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168914788",
    "pr_number": 18956,
    "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
    "created_at": "2025-06-26T12:09:47+00:00",
    "commented_code": "diagnostic.sub(subdiagnostic);\n }\n \n+/// Format a list of elements as a human-readable enumeration.\n+///\n+/// Encloses every element in backticks (`1`, `2` and `3`).\n+pub(crate) fn format_enumeration<I, IT, D>(elements: I) -> String",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2168914788",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18956,
        "pr_file": "crates/ty_python_semantic/src/types/diagnostic.rs",
        "discussion_id": "2168914788",
        "commented_code": "@@ -2012,6 +2013,30 @@ pub(crate) fn report_instance_layout_conflict(\n     diagnostic.sub(subdiagnostic);\n }\n \n+/// Format a list of elements as a human-readable enumeration.\n+///\n+/// Encloses every element in backticks (`1`, `2` and `3`).\n+pub(crate) fn format_enumeration<I, IT, D>(elements: I) -> String",
        "comment_created_at": "2025-06-26T12:09:47+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "Possibly https://github.com/astral-sh/ruff/blob/main/crates/ty_python_semantic/src/util/diagnostics.rs might be a better home for this helper, since it doesn't have much to do with _types_ specifically?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2158836368",
    "pr_number": 18600,
    "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
    "created_at": "2025-06-20T12:21:45+00:00",
    "commented_code": "+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }\n+        Self::Tuple(tuple)\n+    }\n+}\n+\n+impl<'db> TupleType<'db> {\n+    pub(crate) fn empty(db: &'db dyn Db) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(FixedLengthTuple::empty())),\n+        )\n+    }\n+\n+    pub(crate) fn from_elements(\n+        db: &'db dyn Db,\n+        types: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+    ) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(FixedLengthTuple::from_elements(types))),\n+        )\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn mixed(\n+        db: &'db dyn Db,\n+        prefix: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+        variable: Type<'db>,\n+        suffix: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+    ) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(\n+                db,\n+                Tuple::from(VariableLengthTuple::mixed(prefix, variable, suffix)),\n+            ),\n+        )\n+    }\n+\n+    pub(crate) fn homogeneous(db: &'db dyn Db, element: Type<'db>) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(VariableLengthTuple::homogeneous(element))),\n+        )\n+    }\n+\n+    pub(crate) fn to_class_type(self, db: &'db dyn Db) -> Option<ClassType<'db>> {\n+        KnownClass::Tuple\n+            .try_to_class_literal(db)\n+            .and_then(|class_literal| match class_literal.generic_context(db) {\n+                None => Some(ClassType::NonGeneric(class_literal)),\n+                Some(generic_context) if generic_context.variables(db).len() != 1 => None,\n+                Some(generic_context) => Some(\n+                    class_literal\n+                        .apply_specialization(db, |_| generic_context.specialize_tuple(db, self)),\n+                ),\n+            })\n+    }\n+\n+    /// Return a normalized version of `self`.\n+    ///\n+    /// See [`Type::normalized`] for more details.\n+    #[must_use]\n+    pub(crate) fn normalized(self, db: &'db dyn Db) -> Self {\n+        TupleType::new(db, self.tuple(db).normalized(db))\n+    }\n+\n+    pub(crate) fn materialize(self, db: &'db dyn Db, variance: TypeVarVariance) -> Self {\n+        TupleType::new(db, self.tuple(db).materialize(db, variance))\n+    }\n+\n+    pub(crate) fn apply_type_mapping<'a>(\n+        self,\n+        db: &'db dyn Db,\n+        type_mapping: &TypeMapping<'a, 'db>,\n+    ) -> Self {\n+        TupleType::new(db, self.tuple(db).apply_type_mapping(db, type_mapping))\n+    }\n+\n+    pub(crate) fn find_legacy_typevars(\n+        self,\n+        db: &'db dyn Db,\n+        typevars: &mut FxOrderSet<TypeVarInstance<'db>>,\n+    ) {\n+        self.tuple(db).find_legacy_typevars(db, typevars);\n+    }\n+\n+    pub(crate) fn has_relation_to(\n+        self,\n+        db: &'db dyn Db,\n+        other: Self,\n+        relation: TypeRelation,\n+    ) -> bool {\n+        self.tuple(db)\n+            .has_relation_to(db, other.tuple(db), relation)\n+    }\n+\n+    pub(crate) fn is_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_equivalent_to(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_gradual_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_gradual_equivalent_to(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_disjoint_from(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_disjoint_from(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_fully_static(self, db: &'db dyn Db) -> bool {\n+        self.tuple(db).is_fully_static(db)\n+    }\n+\n+    pub(crate) fn is_single_valued(self, db: &'db dyn Db) -> bool {\n+        self.tuple(db).is_single_valued(db)\n+    }\n+}\n+\n+/// A fixed-length tuple.\n+#[derive(Clone, Debug, Default, Eq, Hash, PartialEq, salsa::Update)]\n+pub struct FixedLengthTuple<'db>(Vec<Type<'db>>);\n+\n+impl<'db> FixedLengthTuple<'db> {\n+    pub(crate) fn empty() -> Self {\n+        Self::default()\n+    }\n+\n+    pub(crate) fn with_capacity(capacity: usize) -> Self {\n+        Self(Vec::with_capacity(capacity))\n+    }\n+\n+    pub(crate) fn from_elements(elements: impl IntoIterator<Item = impl Into<Type<'db>>>) -> Self {\n+        Self(elements.into_iter().map(Into::into).collect())\n+    }\n+\n+    pub(crate) fn as_slice(&self) -> &[Type<'db>] {\n+        &self.0\n+    }\n+\n+    pub(crate) fn fixed_elements(&self) -> impl Iterator<Item = Type<'db>> + '_ {\n+        self.0.iter().copied()\n+    }\n+\n+    pub(crate) fn all_elements(&self) -> impl Iterator<Item = Type<'db>> + '_ {\n+        self.0.iter().copied()\n+    }",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2158836368",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158836368",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }\n+        Self::Tuple(tuple)\n+    }\n+}\n+\n+impl<'db> TupleType<'db> {\n+    pub(crate) fn empty(db: &'db dyn Db) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(FixedLengthTuple::empty())),\n+        )\n+    }\n+\n+    pub(crate) fn from_elements(\n+        db: &'db dyn Db,\n+        types: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+    ) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(FixedLengthTuple::from_elements(types))),\n+        )\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn mixed(\n+        db: &'db dyn Db,\n+        prefix: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+        variable: Type<'db>,\n+        suffix: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+    ) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(\n+                db,\n+                Tuple::from(VariableLengthTuple::mixed(prefix, variable, suffix)),\n+            ),\n+        )\n+    }\n+\n+    pub(crate) fn homogeneous(db: &'db dyn Db, element: Type<'db>) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(VariableLengthTuple::homogeneous(element))),\n+        )\n+    }\n+\n+    pub(crate) fn to_class_type(self, db: &'db dyn Db) -> Option<ClassType<'db>> {\n+        KnownClass::Tuple\n+            .try_to_class_literal(db)\n+            .and_then(|class_literal| match class_literal.generic_context(db) {\n+                None => Some(ClassType::NonGeneric(class_literal)),\n+                Some(generic_context) if generic_context.variables(db).len() != 1 => None,\n+                Some(generic_context) => Some(\n+                    class_literal\n+                        .apply_specialization(db, |_| generic_context.specialize_tuple(db, self)),\n+                ),\n+            })\n+    }\n+\n+    /// Return a normalized version of `self`.\n+    ///\n+    /// See [`Type::normalized`] for more details.\n+    #[must_use]\n+    pub(crate) fn normalized(self, db: &'db dyn Db) -> Self {\n+        TupleType::new(db, self.tuple(db).normalized(db))\n+    }\n+\n+    pub(crate) fn materialize(self, db: &'db dyn Db, variance: TypeVarVariance) -> Self {\n+        TupleType::new(db, self.tuple(db).materialize(db, variance))\n+    }\n+\n+    pub(crate) fn apply_type_mapping<'a>(\n+        self,\n+        db: &'db dyn Db,\n+        type_mapping: &TypeMapping<'a, 'db>,\n+    ) -> Self {\n+        TupleType::new(db, self.tuple(db).apply_type_mapping(db, type_mapping))\n+    }\n+\n+    pub(crate) fn find_legacy_typevars(\n+        self,\n+        db: &'db dyn Db,\n+        typevars: &mut FxOrderSet<TypeVarInstance<'db>>,\n+    ) {\n+        self.tuple(db).find_legacy_typevars(db, typevars);\n+    }\n+\n+    pub(crate) fn has_relation_to(\n+        self,\n+        db: &'db dyn Db,\n+        other: Self,\n+        relation: TypeRelation,\n+    ) -> bool {\n+        self.tuple(db)\n+            .has_relation_to(db, other.tuple(db), relation)\n+    }\n+\n+    pub(crate) fn is_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_equivalent_to(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_gradual_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_gradual_equivalent_to(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_disjoint_from(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_disjoint_from(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_fully_static(self, db: &'db dyn Db) -> bool {\n+        self.tuple(db).is_fully_static(db)\n+    }\n+\n+    pub(crate) fn is_single_valued(self, db: &'db dyn Db) -> bool {\n+        self.tuple(db).is_single_valued(db)\n+    }\n+}\n+\n+/// A fixed-length tuple.\n+#[derive(Clone, Debug, Default, Eq, Hash, PartialEq, salsa::Update)]\n+pub struct FixedLengthTuple<'db>(Vec<Type<'db>>);\n+\n+impl<'db> FixedLengthTuple<'db> {\n+    pub(crate) fn empty() -> Self {\n+        Self::default()\n+    }\n+\n+    pub(crate) fn with_capacity(capacity: usize) -> Self {\n+        Self(Vec::with_capacity(capacity))\n+    }\n+\n+    pub(crate) fn from_elements(elements: impl IntoIterator<Item = impl Into<Type<'db>>>) -> Self {\n+        Self(elements.into_iter().map(Into::into).collect())\n+    }\n+\n+    pub(crate) fn as_slice(&self) -> &[Type<'db>] {\n+        &self.0\n+    }\n+\n+    pub(crate) fn fixed_elements(&self) -> impl Iterator<Item = Type<'db>> + '_ {\n+        self.0.iter().copied()\n+    }\n+\n+    pub(crate) fn all_elements(&self) -> impl Iterator<Item = Type<'db>> + '_ {\n+        self.0.iter().copied()\n+    }",
        "comment_created_at": "2025-06-20T12:21:45+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "it feels a bit silly to have two methods that do exactly the same thing -- can't we merge `fixed_elements()` and `all_elements()` into a single `elements()` method? It feels self-evident that they will return the same thing for a `FixedLengthTuple` instance \ud83d\ude06\r\n\r\ncould we also maybe rename `as_slice()` to `elements_slice()`, to more clearly indicate that it returns a slice of the underlying elements?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159377117",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/src/types/tuple.rs",
        "discussion_id": "2158836368",
        "commented_code": "@@ -0,0 +1,819 @@\n+//! Defines types for describing fixed- and variable-length tuples.\n+//!\n+//! At runtime, a Python tuple is a fixed-length immutable list of values. There is no restriction\n+//! on the types of the elements of a tuple value. In the type system, we want to model both\n+//! \"heterogeneous\" tuples that have elements of a fixed sequence of specific types, and\n+//! \"homogenous\" tuples that have an unknown number of elements of the same single type. And in\n+//! fact, we want to model tuples that are a combination of the two, with a heterogeneous prefix\n+//! and/or suffix, and a homogeneous portion of unknown length in between those.\n+\n+use itertools::Either;\n+\n+use crate::types::class::{ClassType, KnownClass};\n+use crate::types::{Type, TypeMapping, TypeRelation, TypeVarInstance, TypeVarVariance, UnionType};\n+use crate::util::subscript::{Nth, OutOfBoundsError, PyIndex, PySlice, StepSizeZeroError};\n+use crate::{Db, FxOrderSet};\n+\n+/// # Ordering\n+/// Ordering is based on the tuple's salsa-assigned id and not on its elements.\n+/// The id may change between runs, or when the tuple was garbage collected and recreated.\n+#[salsa::interned(debug)]\n+#[derive(PartialOrd, Ord)]\n+pub struct TupleType<'db> {\n+    #[returns(ref)]\n+    pub(crate) tuple: Tuple<'db>,\n+}\n+\n+impl<'db> Type<'db> {\n+    pub(crate) fn tuple(db: &'db dyn Db, tuple: TupleType<'db>) -> Self {\n+        // If a fixed-length (i.e., mandatory) element of the tuple is `Never`, then it's not\n+        // possible to instantiate the tuple as a whole. (This is not true of the variable-length\n+        // portion of the tuple, since it can contain no elements.)\n+        if tuple.tuple(db).fixed_elements().any(|ty| ty.is_never()) {\n+            return Type::Never;\n+        }\n+        Self::Tuple(tuple)\n+    }\n+}\n+\n+impl<'db> TupleType<'db> {\n+    pub(crate) fn empty(db: &'db dyn Db) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(FixedLengthTuple::empty())),\n+        )\n+    }\n+\n+    pub(crate) fn from_elements(\n+        db: &'db dyn Db,\n+        types: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+    ) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(FixedLengthTuple::from_elements(types))),\n+        )\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn mixed(\n+        db: &'db dyn Db,\n+        prefix: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+        variable: Type<'db>,\n+        suffix: impl IntoIterator<Item = impl Into<Type<'db>>>,\n+    ) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(\n+                db,\n+                Tuple::from(VariableLengthTuple::mixed(prefix, variable, suffix)),\n+            ),\n+        )\n+    }\n+\n+    pub(crate) fn homogeneous(db: &'db dyn Db, element: Type<'db>) -> Type<'db> {\n+        Type::tuple(\n+            db,\n+            TupleType::new(db, Tuple::from(VariableLengthTuple::homogeneous(element))),\n+        )\n+    }\n+\n+    pub(crate) fn to_class_type(self, db: &'db dyn Db) -> Option<ClassType<'db>> {\n+        KnownClass::Tuple\n+            .try_to_class_literal(db)\n+            .and_then(|class_literal| match class_literal.generic_context(db) {\n+                None => Some(ClassType::NonGeneric(class_literal)),\n+                Some(generic_context) if generic_context.variables(db).len() != 1 => None,\n+                Some(generic_context) => Some(\n+                    class_literal\n+                        .apply_specialization(db, |_| generic_context.specialize_tuple(db, self)),\n+                ),\n+            })\n+    }\n+\n+    /// Return a normalized version of `self`.\n+    ///\n+    /// See [`Type::normalized`] for more details.\n+    #[must_use]\n+    pub(crate) fn normalized(self, db: &'db dyn Db) -> Self {\n+        TupleType::new(db, self.tuple(db).normalized(db))\n+    }\n+\n+    pub(crate) fn materialize(self, db: &'db dyn Db, variance: TypeVarVariance) -> Self {\n+        TupleType::new(db, self.tuple(db).materialize(db, variance))\n+    }\n+\n+    pub(crate) fn apply_type_mapping<'a>(\n+        self,\n+        db: &'db dyn Db,\n+        type_mapping: &TypeMapping<'a, 'db>,\n+    ) -> Self {\n+        TupleType::new(db, self.tuple(db).apply_type_mapping(db, type_mapping))\n+    }\n+\n+    pub(crate) fn find_legacy_typevars(\n+        self,\n+        db: &'db dyn Db,\n+        typevars: &mut FxOrderSet<TypeVarInstance<'db>>,\n+    ) {\n+        self.tuple(db).find_legacy_typevars(db, typevars);\n+    }\n+\n+    pub(crate) fn has_relation_to(\n+        self,\n+        db: &'db dyn Db,\n+        other: Self,\n+        relation: TypeRelation,\n+    ) -> bool {\n+        self.tuple(db)\n+            .has_relation_to(db, other.tuple(db), relation)\n+    }\n+\n+    pub(crate) fn is_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_equivalent_to(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_gradual_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_gradual_equivalent_to(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_disjoint_from(self, db: &'db dyn Db, other: Self) -> bool {\n+        self.tuple(db).is_disjoint_from(db, other.tuple(db))\n+    }\n+\n+    pub(crate) fn is_fully_static(self, db: &'db dyn Db) -> bool {\n+        self.tuple(db).is_fully_static(db)\n+    }\n+\n+    pub(crate) fn is_single_valued(self, db: &'db dyn Db) -> bool {\n+        self.tuple(db).is_single_valued(db)\n+    }\n+}\n+\n+/// A fixed-length tuple.\n+#[derive(Clone, Debug, Default, Eq, Hash, PartialEq, salsa::Update)]\n+pub struct FixedLengthTuple<'db>(Vec<Type<'db>>);\n+\n+impl<'db> FixedLengthTuple<'db> {\n+    pub(crate) fn empty() -> Self {\n+        Self::default()\n+    }\n+\n+    pub(crate) fn with_capacity(capacity: usize) -> Self {\n+        Self(Vec::with_capacity(capacity))\n+    }\n+\n+    pub(crate) fn from_elements(elements: impl IntoIterator<Item = impl Into<Type<'db>>>) -> Self {\n+        Self(elements.into_iter().map(Into::into).collect())\n+    }\n+\n+    pub(crate) fn as_slice(&self) -> &[Type<'db>] {\n+        &self.0\n+    }\n+\n+    pub(crate) fn fixed_elements(&self) -> impl Iterator<Item = Type<'db>> + '_ {\n+        self.0.iter().copied()\n+    }\n+\n+    pub(crate) fn all_elements(&self) -> impl Iterator<Item = Type<'db>> + '_ {\n+        self.0.iter().copied()\n+    }",
        "comment_created_at": "2025-06-20T16:55:56+00:00",
        "comment_author": "dcreager",
        "comment_body": "Done! I had the two copies so that both tuple variants has methods that aligned, but that's not really necessary",
        "pr_file_module": null
      }
    ]
  }
]