[
  {
    "discussion_id": "2131274220",
    "pr_number": 18392,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/type.md",
    "created_at": "2025-06-06T01:30:00+00:00",
    "commented_code": "def _[T](x: A | B):\n     if type(x) is A[str]:\n-        reveal_type(x)  # revealed: (A[int] & A[Unknown]) | (B & A[Unknown])\n+        # TODO: previous was revealed: (A[int] & A[Unknown]) | (B & A[Unknown])",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2131274220",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18392,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/type.md",
        "discussion_id": "2131274220",
        "commented_code": "@@ -127,7 +127,8 @@ class B: ...\n \n def _[T](x: A | B):\n     if type(x) is A[str]:\n-        reveal_type(x)  # revealed: (A[int] & A[Unknown]) | (B & A[Unknown])\n+        # TODO: previous was revealed: (A[int] & A[Unknown]) | (B & A[Unknown])",
        "comment_created_at": "2025-06-06T01:30:00+00:00",
        "comment_author": "carljm",
        "comment_body": "I think the conclusion that this is unreachable code is actually correct -- `type(x)` will never return a `GenericAlias` at runtime, so `type(x) is A[str]` can never be true, only `type(x) is A` can be.\r\n\r\nThis test probably warrants some expansion, but it doesn't need to happen in this PR. We have an issue open for improving how we handle narrowing against generic types.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2139681022",
    "pr_number": 18621,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/type.md",
    "created_at": "2025-06-11T09:39:49+00:00",
    "commented_code": "def _[T](x: A | B):\n     if type(x) is A[str]:\n-        reveal_type(x)  # revealed: (A[int] & A[Unknown]) | (B & A[Unknown])\n+        reveal_type(x)  # revealed: Never",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2139681022",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18621,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/type.md",
        "discussion_id": "2139681022",
        "commented_code": "@@ -127,7 +127,7 @@ class B: ...\n \n def _[T](x: A | B):\n     if type(x) is A[str]:\n-        reveal_type(x)  # revealed: (A[int] & A[Unknown]) | (B & A[Unknown])\n+        reveal_type(x)  # revealed: Never",
        "comment_created_at": "2025-06-11T09:39:49+00:00",
        "comment_author": "sharkdp",
        "comment_body": "See https://github.com/astral-sh/ruff/pull/18392/files#r2131274220",
        "pr_file_module": null
      },
      {
        "comment_id": "2151210234",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18621,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/type.md",
        "discussion_id": "2139681022",
        "commented_code": "@@ -127,7 +127,7 @@ class B: ...\n \n def _[T](x: A | B):\n     if type(x) is A[str]:\n-        reveal_type(x)  # revealed: (A[int] & A[Unknown]) | (B & A[Unknown])\n+        reveal_type(x)  # revealed: Never",
        "comment_created_at": "2025-06-17T02:43:39+00:00",
        "comment_author": "carljm",
        "comment_body": "```suggestion\r\n        # `type()` never returns a generic alias, so `type(x)` cannot be `A[str]`\r\n        reveal_type(x)  # revealed: Never\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140872161",
    "pr_number": 18589,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md",
    "created_at": "2025-06-11T18:59:05+00:00",
    "commented_code": "f3(obj)\n ```\n \n+## `TypeGuard` and `TypeIs`\n+\n+`TypeGuard[...]` and `TypeIs[...]` are always assignable to `bool`.\n+\n+```py\n+from ty_extensions import Unknown, is_assignable_to, static_assert\n+from typing_extensions import Any, TypeGuard, TypeIs\n+\n+static_assert(is_assignable_to(TypeGuard[Unknown], bool))\n+static_assert(is_assignable_to(TypeIs[Any], bool))",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2140872161",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18589,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md",
        "discussion_id": "2140872161",
        "commented_code": "@@ -871,4 +871,16 @@ def g3(obj: Foo[tuple[A]]):\n     f3(obj)\n ```\n \n+## `TypeGuard` and `TypeIs`\n+\n+`TypeGuard[...]` and `TypeIs[...]` are always assignable to `bool`.\n+\n+```py\n+from ty_extensions import Unknown, is_assignable_to, static_assert\n+from typing_extensions import Any, TypeGuard, TypeIs\n+\n+static_assert(is_assignable_to(TypeGuard[Unknown], bool))\n+static_assert(is_assignable_to(TypeIs[Any], bool))",
        "comment_created_at": "2025-06-11T18:59:05+00:00",
        "comment_author": "carljm",
        "comment_body": "These tests are good -- let's also add tests showing them not assignable to some other arbitrary type. It's always good to have both positive and negative tests, to demonstrate that the positive ones are passing for the right reason (not e.g. because we are just always treating it as dynamic, which actually is the case for TypeGuard still)\r\n```suggestion\r\nstatic_assert(is_assignable_to(TypeGuard[Unknown], bool))\r\nstatic_assert(is_assignable_to(TypeIs[Any], bool))\r\n\r\n# TODO no error\r\nstatic_assert(not is_assignable_to(TypeGuard[Unknown], str))  # error: [static-assert-error]\r\nstatic_assert(not is_assignable_to(TypeIs[Any], str))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2097566461",
    "pr_number": 18041,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
    "created_at": "2025-05-20T10:07:45+00:00",
    "commented_code": "+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2097566461",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2097566461",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+",
        "comment_created_at": "2025-05-20T10:07:45+00:00",
        "comment_author": "sharkdp",
        "comment_body": "Maybe:\r\n```suggestion\r\n\r\n# Make sure that we infer the narrowed type for eager\r\n# scopes (class, comprehension) and the non-narrowed\r\n# public type for lazy scopes (function)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2097575346",
    "pr_number": 18041,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
    "created_at": "2025-05-20T10:12:32+00:00",
    "commented_code": "+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+\n+class C:\n+    reveal_type(a.x)  # revealed: Literal[0]\n+\n+[reveal_type(a.x) for _ in range(1)]  # revealed: Literal[0]\n+\n+def _():\n+    reveal_type(a.x)  # revealed: Unknown | int | None\n+```\n+\n+### Do not narrow the type of a `property` by assignment\n+\n+```py\n+class C:\n+    def __init__(self):\n+        self._x: int = 0\n+\n+    @property\n+    def x(self) -> int:\n+        return self._x\n+\n+    @x.setter\n+    def x(self, value: int) -> None:\n+        self._x = abs(value)\n+\n+c = C()\n+c.x = -1\n+# Don't infer `c.x` to be `Literal[-1]`\n+reveal_type(c.x)  # revealed: int\n+```\n+\n+### Do not narrow the type of a descriptor by assignment\n+\n+```py\n+class Descriptor:\n+    def __get__(self, instance: object, owner: type) -> int:\n+        return 1\n+\n+    def __set__(self, instance: object, value: int) -> None:\n+        pass\n+\n+class C:\n+    desc: Descriptor = Descriptor()\n+\n+c = C()\n+c.desc = -1\n+# Don't infer `c.desc` to be `Literal[-1]`\n+reveal_type(c.desc)  # revealed: int\n+```\n+\n+## Subscript\n+\n+### Basic\n+\n+Type narrowing based on assignment to a subscript expression is generally unsound, because\n+`__getitem__`/`__setitem__` of a user-defined class does not guarantee that the passed value is\n+stored and can be retrieved as is. Currently, we only perform assignment-based narrowing on a few",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2097575346",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2097575346",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+\n+class C:\n+    reveal_type(a.x)  # revealed: Literal[0]\n+\n+[reveal_type(a.x) for _ in range(1)]  # revealed: Literal[0]\n+\n+def _():\n+    reveal_type(a.x)  # revealed: Unknown | int | None\n+```\n+\n+### Do not narrow the type of a `property` by assignment\n+\n+```py\n+class C:\n+    def __init__(self):\n+        self._x: int = 0\n+\n+    @property\n+    def x(self) -> int:\n+        return self._x\n+\n+    @x.setter\n+    def x(self, value: int) -> None:\n+        self._x = abs(value)\n+\n+c = C()\n+c.x = -1\n+# Don't infer `c.x` to be `Literal[-1]`\n+reveal_type(c.x)  # revealed: int\n+```\n+\n+### Do not narrow the type of a descriptor by assignment\n+\n+```py\n+class Descriptor:\n+    def __get__(self, instance: object, owner: type) -> int:\n+        return 1\n+\n+    def __set__(self, instance: object, value: int) -> None:\n+        pass\n+\n+class C:\n+    desc: Descriptor = Descriptor()\n+\n+c = C()\n+c.desc = -1\n+# Don't infer `c.desc` to be `Literal[-1]`\n+reveal_type(c.desc)  # revealed: int\n+```\n+\n+## Subscript\n+\n+### Basic\n+\n+Type narrowing based on assignment to a subscript expression is generally unsound, because\n+`__getitem__`/`__setitem__` of a user-defined class does not guarantee that the passed value is\n+stored and can be retrieved as is. Currently, we only perform assignment-based narrowing on a few",
        "comment_created_at": "2025-05-20T10:12:32+00:00",
        "comment_author": "sharkdp",
        "comment_body": "Maybe something like this, to make it a bit more clear?\r\n\r\n```suggestion\r\narbitrary `__getitem__`/`__setitem__` methods on a class do not necessarily guarantee that the passed-in value\r\nfor `__setitem__` is stored and can be retrieved unmodified via `__getitem__`. Therefore, we currently only perform assignment-based narrowing on a few\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2097580163",
    "pr_number": 18041,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
    "created_at": "2025-05-20T10:15:30+00:00",
    "commented_code": "+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+\n+class C:\n+    reveal_type(a.x)  # revealed: Literal[0]\n+\n+[reveal_type(a.x) for _ in range(1)]  # revealed: Literal[0]\n+\n+def _():\n+    reveal_type(a.x)  # revealed: Unknown | int | None\n+```\n+\n+### Do not narrow the type of a `property` by assignment\n+\n+```py\n+class C:\n+    def __init__(self):\n+        self._x: int = 0\n+\n+    @property\n+    def x(self) -> int:\n+        return self._x\n+\n+    @x.setter\n+    def x(self, value: int) -> None:\n+        self._x = abs(value)\n+\n+c = C()\n+c.x = -1\n+# Don't infer `c.x` to be `Literal[-1]`\n+reveal_type(c.x)  # revealed: int\n+```\n+\n+### Do not narrow the type of a descriptor by assignment\n+\n+```py\n+class Descriptor:\n+    def __get__(self, instance: object, owner: type) -> int:\n+        return 1\n+\n+    def __set__(self, instance: object, value: int) -> None:\n+        pass\n+\n+class C:\n+    desc: Descriptor = Descriptor()\n+\n+c = C()\n+c.desc = -1\n+# Don't infer `c.desc` to be `Literal[-1]`\n+reveal_type(c.desc)  # revealed: int\n+```\n+\n+## Subscript\n+\n+### Basic\n+\n+Type narrowing based on assignment to a subscript expression is generally unsound, because\n+`__getitem__`/`__setitem__` of a user-defined class does not guarantee that the passed value is\n+stored and can be retrieved as is. Currently, we only perform assignment-based narrowing on a few\n+built-in classes (`list`, `dict`, `bytesarray`, `TypedDict` and `collections` types) and their\n+subclasses where we are confident that this kind of narrowing can be performed soundly. This is the\n+same approach as pyright.\n+\n+```py\n+from typing import TypedDict\n+from collections import ChainMap, defaultdict\n+\n+l: list[int | None] = [None]\n+l[0] = 0\n+d: dict[int, int] = {1: 1}\n+d[0] = 0\n+b: bytearray = bytearray(b\"abc\")\n+b[0] = 0\n+dd: defaultdict[int, int] = defaultdict(int)\n+dd[0] = 0\n+cm: ChainMap[int, int] = ChainMap({1: 1}, {0: 0})\n+cm[0] = 0\n+# TODO: should be ChainMap[int, int]\n+reveal_type(cm)  # revealed: ChainMap[Unknown, Unknown]\n+\n+reveal_type(l[0])  # revealed: Literal[0]\n+reveal_type(d[0])  # revealed: Literal[0]\n+reveal_type(b[0])  # revealed: Literal[0]\n+reveal_type(dd[0])  # revealed: Literal[0]\n+# TODO: should be Literal[0]\n+reveal_type(cm[0])  # revealed: Unknown\n+\n+class C:\n+    reveal_type(l[0])  # revealed: Literal[0]\n+    reveal_type(d[0])  # revealed: Literal[0]\n+    reveal_type(b[0])  # revealed: Literal[0]\n+    reveal_type(dd[0])  # revealed: Literal[0]\n+    # TODO\n+    reveal_type(cm[0])  # revealed: Unknown\n+\n+[reveal_type(l[0]) for _ in range(1)]  # revealed: Literal[0]\n+[reveal_type(d[0]) for _ in range(1)]  # revealed: Literal[0]\n+[reveal_type(b[0]) for _ in range(1)]  # revealed: Literal[0]\n+[reveal_type(dd[0]) for _ in range(1)]  # revealed: Literal[0]\n+# TODO\n+[reveal_type(cm[0]) for _ in range(1)]  # revealed: Unknown\n+\n+def _():\n+    reveal_type(l[0])  # revealed: int | None\n+    reveal_type(d[0])  # revealed: int\n+    reveal_type(b[0])  # revealed: int\n+    reveal_type(dd[0])  # revealed: int\n+    reveal_type(cm[0])  # revealed: int\n+\n+class D(TypedDict):\n+    x: int\n+    label: str\n+\n+td = D(x=1, label=\"a\")\n+td[\"x\"] = 0\n+# TODO: should be Literal[0]\n+reveal_type(td[\"x\"])  # revealed: @Todo(TypedDict)\n+```\n+\n+### Do not narrow the result type of a customized subscript by assignment",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2097580163",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2097580163",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+\n+class C:\n+    reveal_type(a.x)  # revealed: Literal[0]\n+\n+[reveal_type(a.x) for _ in range(1)]  # revealed: Literal[0]\n+\n+def _():\n+    reveal_type(a.x)  # revealed: Unknown | int | None\n+```\n+\n+### Do not narrow the type of a `property` by assignment\n+\n+```py\n+class C:\n+    def __init__(self):\n+        self._x: int = 0\n+\n+    @property\n+    def x(self) -> int:\n+        return self._x\n+\n+    @x.setter\n+    def x(self, value: int) -> None:\n+        self._x = abs(value)\n+\n+c = C()\n+c.x = -1\n+# Don't infer `c.x` to be `Literal[-1]`\n+reveal_type(c.x)  # revealed: int\n+```\n+\n+### Do not narrow the type of a descriptor by assignment\n+\n+```py\n+class Descriptor:\n+    def __get__(self, instance: object, owner: type) -> int:\n+        return 1\n+\n+    def __set__(self, instance: object, value: int) -> None:\n+        pass\n+\n+class C:\n+    desc: Descriptor = Descriptor()\n+\n+c = C()\n+c.desc = -1\n+# Don't infer `c.desc` to be `Literal[-1]`\n+reveal_type(c.desc)  # revealed: int\n+```\n+\n+## Subscript\n+\n+### Basic\n+\n+Type narrowing based on assignment to a subscript expression is generally unsound, because\n+`__getitem__`/`__setitem__` of a user-defined class does not guarantee that the passed value is\n+stored and can be retrieved as is. Currently, we only perform assignment-based narrowing on a few\n+built-in classes (`list`, `dict`, `bytesarray`, `TypedDict` and `collections` types) and their\n+subclasses where we are confident that this kind of narrowing can be performed soundly. This is the\n+same approach as pyright.\n+\n+```py\n+from typing import TypedDict\n+from collections import ChainMap, defaultdict\n+\n+l: list[int | None] = [None]\n+l[0] = 0\n+d: dict[int, int] = {1: 1}\n+d[0] = 0\n+b: bytearray = bytearray(b\"abc\")\n+b[0] = 0\n+dd: defaultdict[int, int] = defaultdict(int)\n+dd[0] = 0\n+cm: ChainMap[int, int] = ChainMap({1: 1}, {0: 0})\n+cm[0] = 0\n+# TODO: should be ChainMap[int, int]\n+reveal_type(cm)  # revealed: ChainMap[Unknown, Unknown]\n+\n+reveal_type(l[0])  # revealed: Literal[0]\n+reveal_type(d[0])  # revealed: Literal[0]\n+reveal_type(b[0])  # revealed: Literal[0]\n+reveal_type(dd[0])  # revealed: Literal[0]\n+# TODO: should be Literal[0]\n+reveal_type(cm[0])  # revealed: Unknown\n+\n+class C:\n+    reveal_type(l[0])  # revealed: Literal[0]\n+    reveal_type(d[0])  # revealed: Literal[0]\n+    reveal_type(b[0])  # revealed: Literal[0]\n+    reveal_type(dd[0])  # revealed: Literal[0]\n+    # TODO\n+    reveal_type(cm[0])  # revealed: Unknown\n+\n+[reveal_type(l[0]) for _ in range(1)]  # revealed: Literal[0]\n+[reveal_type(d[0]) for _ in range(1)]  # revealed: Literal[0]\n+[reveal_type(b[0]) for _ in range(1)]  # revealed: Literal[0]\n+[reveal_type(dd[0]) for _ in range(1)]  # revealed: Literal[0]\n+# TODO\n+[reveal_type(cm[0]) for _ in range(1)]  # revealed: Unknown\n+\n+def _():\n+    reveal_type(l[0])  # revealed: int | None\n+    reveal_type(d[0])  # revealed: int\n+    reveal_type(b[0])  # revealed: int\n+    reveal_type(dd[0])  # revealed: int\n+    reveal_type(cm[0])  # revealed: int\n+\n+class D(TypedDict):\n+    x: int\n+    label: str\n+\n+td = D(x=1, label=\"a\")\n+td[\"x\"] = 0\n+# TODO: should be Literal[0]\n+reveal_type(td[\"x\"])  # revealed: @Todo(TypedDict)\n+```\n+\n+### Do not narrow the result type of a customized subscript by assignment",
        "comment_created_at": "2025-05-20T10:15:30+00:00",
        "comment_author": "sharkdp",
        "comment_body": "Maybe\r\n```suggestion\r\n### No narrowing for custom classes with arbitrary `__getitem__` / `__setitem__`\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2098794579",
    "pr_number": 18041,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
    "created_at": "2025-05-20T20:20:21+00:00",
    "commented_code": "+# Narrowing by assignment",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2098794579",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2098794579",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment",
        "comment_created_at": "2025-05-20T20:20:21+00:00",
        "comment_author": "carljm",
        "comment_body": "Here is a test case we should include, in some form:\r\n\r\n```py\r\nclass C:\r\n    attr: str | None\r\n\r\nc = C()\r\nreveal_type(c.attr)  # str | None\r\nc.attr = \"foo\"\r\nreveal_type(c.attr)  # Literal[\"foo\"]\r\nc = C()\r\nreveal_type(c.attr)  # should be str | None, not Literal[\"foo\"]\r\n```\r\n\r\nCurrently in this PR the last line reveals `Literal[\"foo\"]`, but it should reveal `str | None`. Re-definitions of a name/symbol need to somehow \"reset\" definitions of attributes/subscripts of that name. (And this must also apply recursively to expressions; e.g. a re-assignment of `c.x` must \"clear\" any narrowing of `c.x[0]`, etc.)\r\n\r\nI haven't reviewed enough of this PR yet to have a sense of how difficult that will be to add. If it's very easy, maybe we should do it in this PR. If it's doable but not a small change, maybe the test should be added with a TODO, and then addressed in a follow-up PR. If it's not clear how it can be integrated into this approach (that would surprise me), then we may need to reconsider the approach?",
        "pr_file_module": null
      },
      {
        "comment_id": "2100883656",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2098794579",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment",
        "comment_created_at": "2025-05-21T18:03:17+00:00",
        "comment_author": "mtshiba",
        "comment_body": "I thought that when the name `c` is shadowed, we could assume that the definitions for `c.attr`, etc. are also shadowed together, but handling in different scopes is more complicated.\r\n\r\n```python\r\nc = C()\r\nc.attr = \"foo\"\r\n\r\nclass D:\r\n    if False:\r\n        c = C()\r\n    reveal_type(c.attr)  # revealed: Literal[\"foo\"]\r\n\r\n    if True: # or ambiguous\r\n        c = C()\r\n    reveal_type(c.attr)  # revealed: str | None\r\n```\r\n\r\nSince there is no definition of `c.attr` in scope `D`, we look at the definition in the outer scope. However, whether the definition of `c.attr` (of the global scope) is visible actually depends on whether the definition of `c` in scope `D` is visible. Should `bindings_by_use` additionally hold this information?",
        "pr_file_module": null
      },
      {
        "comment_id": "2100903165",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2098794579",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment",
        "comment_created_at": "2025-05-21T18:16:47+00:00",
        "comment_author": "carljm",
        "comment_body": "Do we need additional information in `bindings_by_use` to handle this? Or do we instead need to adjust the order of lookups, so that if there is no visible binding for `c.attr` in the local scope, we look for a binding of `c` in the local scope, and only if that is possibly unbound do we climb up to the enclosing scope to find a binding of `c.attr` or `c`. That seems like the lookup order that better reflects the correct semantics. If `c` is bound locally we don't care about the type of `c.attr` in an enclosing scope.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2098820164",
    "pr_number": 18041,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
    "created_at": "2025-05-20T20:31:47+00:00",
    "commented_code": "+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+\n+class C:\n+    reveal_type(a.x)  # revealed: Literal[0]\n+\n+[reveal_type(a.x) for _ in range(1)]  # revealed: Literal[0]\n+\n+def _():\n+    reveal_type(a.x)  # revealed: Unknown | int | None\n+```\n+\n+### Do not narrow the type of a `property` by assignment\n+\n+```py\n+class C:\n+    def __init__(self):\n+        self._x: int = 0\n+\n+    @property\n+    def x(self) -> int:\n+        return self._x\n+\n+    @x.setter\n+    def x(self, value: int) -> None:\n+        self._x = abs(value)\n+\n+c = C()\n+c.x = -1\n+# Don't infer `c.x` to be `Literal[-1]`\n+reveal_type(c.x)  # revealed: int\n+```\n+\n+### Do not narrow the type of a descriptor by assignment\n+\n+```py\n+class Descriptor:\n+    def __get__(self, instance: object, owner: type) -> int:\n+        return 1\n+\n+    def __set__(self, instance: object, value: int) -> None:\n+        pass\n+\n+class C:\n+    desc: Descriptor = Descriptor()\n+\n+c = C()\n+c.desc = -1\n+# Don't infer `c.desc` to be `Literal[-1]`\n+reveal_type(c.desc)  # revealed: int\n+```\n+\n+## Subscript\n+\n+### Basic\n+\n+Type narrowing based on assignment to a subscript expression is generally unsound, because\n+`__getitem__`/`__setitem__` of a user-defined class does not guarantee that the passed value is\n+stored and can be retrieved as is. Currently, we only perform assignment-based narrowing on a few\n+built-in classes (`list`, `dict`, `bytesarray`, `TypedDict` and `collections` types) and their\n+subclasses where we are confident that this kind of narrowing can be performed soundly. This is the\n+same approach as pyright.\n+\n+```py\n+from typing import TypedDict\n+from collections import ChainMap, defaultdict\n+\n+l: list[int | None] = [None]\n+l[0] = 0\n+d: dict[int, int] = {1: 1}\n+d[0] = 0\n+b: bytearray = bytearray(b\"abc\")\n+b[0] = 0\n+dd: defaultdict[int, int] = defaultdict(int)\n+dd[0] = 0\n+cm: ChainMap[int, int] = ChainMap({1: 1}, {0: 0})\n+cm[0] = 0\n+# TODO: should be ChainMap[int, int]\n+reveal_type(cm)  # revealed: ChainMap[Unknown, Unknown]\n+\n+reveal_type(l[0])  # revealed: Literal[0]\n+reveal_type(d[0])  # revealed: Literal[0]\n+reveal_type(b[0])  # revealed: Literal[0]\n+reveal_type(dd[0])  # revealed: Literal[0]\n+# TODO: should be Literal[0]\n+reveal_type(cm[0])  # revealed: Unknown\n+\n+class C:\n+    reveal_type(l[0])  # revealed: Literal[0]\n+    reveal_type(d[0])  # revealed: Literal[0]\n+    reveal_type(b[0])  # revealed: Literal[0]\n+    reveal_type(dd[0])  # revealed: Literal[0]\n+    # TODO",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2098820164",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18041,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
        "discussion_id": "2098820164",
        "commented_code": "@@ -0,0 +1,177 @@\n+# Narrowing by assignment\n+\n+## Attribute\n+\n+### Basic\n+\n+```py\n+class A:\n+    x: int | None = None\n+\n+a = A()\n+a.x = 0\n+\n+reveal_type(a.x)  # revealed: Literal[0]\n+\n+class C:\n+    reveal_type(a.x)  # revealed: Literal[0]\n+\n+[reveal_type(a.x) for _ in range(1)]  # revealed: Literal[0]\n+\n+def _():\n+    reveal_type(a.x)  # revealed: Unknown | int | None\n+```\n+\n+### Do not narrow the type of a `property` by assignment\n+\n+```py\n+class C:\n+    def __init__(self):\n+        self._x: int = 0\n+\n+    @property\n+    def x(self) -> int:\n+        return self._x\n+\n+    @x.setter\n+    def x(self, value: int) -> None:\n+        self._x = abs(value)\n+\n+c = C()\n+c.x = -1\n+# Don't infer `c.x` to be `Literal[-1]`\n+reveal_type(c.x)  # revealed: int\n+```\n+\n+### Do not narrow the type of a descriptor by assignment\n+\n+```py\n+class Descriptor:\n+    def __get__(self, instance: object, owner: type) -> int:\n+        return 1\n+\n+    def __set__(self, instance: object, value: int) -> None:\n+        pass\n+\n+class C:\n+    desc: Descriptor = Descriptor()\n+\n+c = C()\n+c.desc = -1\n+# Don't infer `c.desc` to be `Literal[-1]`\n+reveal_type(c.desc)  # revealed: int\n+```\n+\n+## Subscript\n+\n+### Basic\n+\n+Type narrowing based on assignment to a subscript expression is generally unsound, because\n+`__getitem__`/`__setitem__` of a user-defined class does not guarantee that the passed value is\n+stored and can be retrieved as is. Currently, we only perform assignment-based narrowing on a few\n+built-in classes (`list`, `dict`, `bytesarray`, `TypedDict` and `collections` types) and their\n+subclasses where we are confident that this kind of narrowing can be performed soundly. This is the\n+same approach as pyright.\n+\n+```py\n+from typing import TypedDict\n+from collections import ChainMap, defaultdict\n+\n+l: list[int | None] = [None]\n+l[0] = 0\n+d: dict[int, int] = {1: 1}\n+d[0] = 0\n+b: bytearray = bytearray(b\"abc\")\n+b[0] = 0\n+dd: defaultdict[int, int] = defaultdict(int)\n+dd[0] = 0\n+cm: ChainMap[int, int] = ChainMap({1: 1}, {0: 0})\n+cm[0] = 0\n+# TODO: should be ChainMap[int, int]\n+reveal_type(cm)  # revealed: ChainMap[Unknown, Unknown]\n+\n+reveal_type(l[0])  # revealed: Literal[0]\n+reveal_type(d[0])  # revealed: Literal[0]\n+reveal_type(b[0])  # revealed: Literal[0]\n+reveal_type(dd[0])  # revealed: Literal[0]\n+# TODO: should be Literal[0]\n+reveal_type(cm[0])  # revealed: Unknown\n+\n+class C:\n+    reveal_type(l[0])  # revealed: Literal[0]\n+    reveal_type(d[0])  # revealed: Literal[0]\n+    reveal_type(b[0])  # revealed: Literal[0]\n+    reveal_type(dd[0])  # revealed: Literal[0]\n+    # TODO",
        "comment_created_at": "2025-05-20T20:31:47+00:00",
        "comment_author": "carljm",
        "comment_body": "I know it feels repetitive, but I think we should aim to make each TODO comment clear in isolation; makes the \"fix\" PR easier to review.\r\n```suggestion\r\n    # TODO: should be Literal[0]\r\n```",
        "pr_file_module": null
      }
    ]
  }
]