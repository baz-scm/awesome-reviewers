[
  {
    "discussion_id": "2132241645",
    "pr_number": 17281,
    "pr_file": "crates/ruff_linter/resources/test/fixtures/ruff/RUF062_1.py",
    "created_at": "2025-06-06T13:51:18+00:00",
    "commented_code": "+import contextlib\n+\n+# (1) Invalid: Variable number of yields based on conditions\n+@contextlib.contextmanager\n+def conditional_yields(condition):\n+    yield \"first\"\n+    if condition:\n+        yield \"conditional\"  # RUF060\n+\n+# (2) Invalid(joint): Multiple nested context managers\n+def outer_function():\n+    @contextlib.contextmanager\n+    def inner_context_manager():  # This is fine, one yield\n+        yield \"inner value\"\n+\n+    @contextlib.contextmanager\n+    def another_inner_cm():\n+        yield \"first\"\n+        yield \"second\"  # RUF060\n+\n+# (3) Invalid: else yields after try yields\n+@contextlib.contextmanager\n+def invalid_try_else_finally():\n+    try:\n+        yield \"first\"\n+    except Exception:\n+        pass\n+    else:\n+        yield \"second\" #RUF060\n+    print(\"done\")\n+\n+# (4) Invalid: Multiple yields in the same match arm\n+@contextlib.contextmanager\n+def invalid_match_same_case(value):\n+    match value:\n+        case \"a\":\n+            yield \"one\"\n+            yield \"two\"  # RUF060\n+        case _:\n+            yield \"default\"\n+\n+# (5) Invalid: Yield in a loop (always ambiguous)\n+@contextlib.contextmanager\n+def invalid_yield_in_loop():\n+    for i in range(3):\n+        yield i  # RUF060",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2132241645",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 17281,
        "pr_file": "crates/ruff_linter/resources/test/fixtures/ruff/RUF062_1.py",
        "discussion_id": "2132241645",
        "commented_code": "@@ -0,0 +1,162 @@\n+import contextlib\n+\n+# (1) Invalid: Variable number of yields based on conditions\n+@contextlib.contextmanager\n+def conditional_yields(condition):\n+    yield \"first\"\n+    if condition:\n+        yield \"conditional\"  # RUF060\n+\n+# (2) Invalid(joint): Multiple nested context managers\n+def outer_function():\n+    @contextlib.contextmanager\n+    def inner_context_manager():  # This is fine, one yield\n+        yield \"inner value\"\n+\n+    @contextlib.contextmanager\n+    def another_inner_cm():\n+        yield \"first\"\n+        yield \"second\"  # RUF060\n+\n+# (3) Invalid: else yields after try yields\n+@contextlib.contextmanager\n+def invalid_try_else_finally():\n+    try:\n+        yield \"first\"\n+    except Exception:\n+        pass\n+    else:\n+        yield \"second\" #RUF060\n+    print(\"done\")\n+\n+# (4) Invalid: Multiple yields in the same match arm\n+@contextlib.contextmanager\n+def invalid_match_same_case(value):\n+    match value:\n+        case \"a\":\n+            yield \"one\"\n+            yield \"two\"  # RUF060\n+        case _:\n+            yield \"default\"\n+\n+# (5) Invalid: Yield in a loop (always ambiguous)\n+@contextlib.contextmanager\n+def invalid_yield_in_loop():\n+    for i in range(3):\n+        yield i  # RUF060",
        "comment_created_at": "2025-06-06T13:51:18+00:00",
        "comment_author": "ntBre",
        "comment_body": "The one case where this might be valid is if the `yield` is followed by an unconditional `break` or `return`. Does the rule handle that case? `return` seemed well handled in the valid cases, but I don't remember seeing `break`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2141994355",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 17281,
        "pr_file": "crates/ruff_linter/resources/test/fixtures/ruff/RUF062_1.py",
        "discussion_id": "2132241645",
        "commented_code": "@@ -0,0 +1,162 @@\n+import contextlib\n+\n+# (1) Invalid: Variable number of yields based on conditions\n+@contextlib.contextmanager\n+def conditional_yields(condition):\n+    yield \"first\"\n+    if condition:\n+        yield \"conditional\"  # RUF060\n+\n+# (2) Invalid(joint): Multiple nested context managers\n+def outer_function():\n+    @contextlib.contextmanager\n+    def inner_context_manager():  # This is fine, one yield\n+        yield \"inner value\"\n+\n+    @contextlib.contextmanager\n+    def another_inner_cm():\n+        yield \"first\"\n+        yield \"second\"  # RUF060\n+\n+# (3) Invalid: else yields after try yields\n+@contextlib.contextmanager\n+def invalid_try_else_finally():\n+    try:\n+        yield \"first\"\n+    except Exception:\n+        pass\n+    else:\n+        yield \"second\" #RUF060\n+    print(\"done\")\n+\n+# (4) Invalid: Multiple yields in the same match arm\n+@contextlib.contextmanager\n+def invalid_match_same_case(value):\n+    match value:\n+        case \"a\":\n+            yield \"one\"\n+            yield \"two\"  # RUF060\n+        case _:\n+            yield \"default\"\n+\n+# (5) Invalid: Yield in a loop (always ambiguous)\n+@contextlib.contextmanager\n+def invalid_yield_in_loop():\n+    for i in range(3):\n+        yield i  # RUF060",
        "comment_created_at": "2025-06-12T07:59:35+00:00",
        "comment_author": "maxmynter",
        "comment_body": "It's not yet. I will add handling and tests for `break`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132254009",
    "pr_number": 17281,
    "pr_file": "crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py",
    "created_at": "2025-06-06T13:58:19+00:00",
    "commented_code": "+import contextlib\n+\n+# (1) Valid: Single yield in a context manager\n+@contextlib.contextmanager\n+def valid_context_manager():\n+    print(\"Setting up\")\n+    yield \"value\"\n+    print(\"Cleaning up\")\n+\n+# (2) Valid: Single yield_from in a context manager\n+@contextlib.contextmanager\n+def valid_yield_from_context_manager():\n+    print(\"Setting up\")\n+    yield from [\"value\"]\n+    print(\"Cleaning up\")\n+\n+# (3) Valid: Single yield in a context manager with nested function\n+@contextlib.contextmanager\n+def valid_with_nested():\n+    print(\"Setting up\")\n+\n+    def nested_func():\n+        yield \"nested yield\"  # yield OK, nested function\n+        yield \"multiple yields in nested OK too\"\n+\n+    yield \"value\"\n+    print(\"Cleaning up\")\n+\n+# (4) Valid: Using contextmanager with async\n+@contextlib.asynccontextmanager\n+async def valid_async_context_manager():\n+    print(\"Setting up async\")\n+    yield \"async value\"\n+    print(\"Cleaning up async\")\n+\n+# (5) Valid: No decorator\n+def not_a_context_manager():\n+    yield \"first\"\n+    yield \"second\"\n+\n+# (6) Valid: Different decorator\n+@staticmethod\n+def different_decorator():\n+    yield \"first\"\n+    yield \"second\"\n+\n+# (7) Valid: Context manager with a class\n+class ValidClass:\n+    @contextlib.contextmanager\n+    def valid_method(self):\n+        print(\"Setting up\")\n+        yield \"value\"\n+        print(\"Cleaning up\")\n+\n+# (8) Valid: Multiple yields in mutually exclusive branches\n+@contextlib.contextmanager\n+def valid_conditional_yield(condition):\n+    print(\"Setting up\")\n+    if condition:\n+        yield \"for condition\"\n+    else:\n+        yield \"for else condition\"\n+    print(\"Cleaning up\")\n+\n+# (9) Valid: Only one yield executes per run\n+@contextlib.contextmanager\n+def valid_try_else_finally():\n+    try:\n+        pass\n+    except Exception:\n+        yield \"in except\"\n+    else:\n+        yield \"in else\"\n+    print(\"done\")\n+\n+# (10) Valid: Yields in mutually exclusive match arms\n+@contextlib.contextmanager\n+def valid_match_yields(value):\n+    match value:\n+        case \"a\":\n+            yield \"from a\"\n+        case \"b\":\n+            yield \"from b\"\n+        case _:\n+            yield \"from default\"\n+\n+# (11) Valid: Multiple yields in a nested function\n+@contextlib.contextmanager\n+def valid_nested_function():\n+    def inner():\n+        yield \"inner one\"\n+        yield \"inner two\"\n+    yield \"outer\"\n+\n+# (12) Valid: Using contextmanager as a variable name followed by direct call\n+contextmanager = lambda f: f\n+@contextmanager\n+def not_really_context_manager():\n+    yield \"first\"\n+    yield \"second\"  # This is not a violation since it's not the real contextmanager\n+\n+# (13) Valid: Multiple excepts that each yield\n+@contextlib.contextmanager\n+def multiple_except_yields():\n+    try:\n+        pass\n+    except ValueError:\n+        yield \"val error\"\n+    except TypeError:\n+        yield \"type error\"\n+\n+# (14) Valid: each arm yields once\n+@contextlib.contextmanager\n+def valid_multiple_elifs():\n+    if 1 == 3:\n+        yield \"never this\"\n+    elif 1 == 2:\n+        yield \"this doesn't\"\n+    elif 2 == 2:\n+        yield \"this does\"\n+    else:\n+        yield \"This would if reached\"\n+\n+# (15) Valid: Yield in else of for loop\n+@contextlib.contextmanager\n+def for_loop_with_else():\n+    for i in range(3):\n+        pass\n+    else:\n+        yield\n+\n+# (16) Valid: Yield in else of while loop\n+@contextlib.contextmanager\n+def while_loop_with_else():\n+    x = 1\n+    while x < 3:\n+        x += 1\n+    yield\n+\n+# (17) Valid: Yield after loop\n+@contextlib.contextmanager\n+def for_loop():\n+    for i in range(3):\n+        pass\n+    yield\n+\n+# (18) Valid: Yield after loop\n+@contextlib.contextmanager\n+def while_loop():\n+    x = 1\n+    while x < 3:\n+        x += 1\n+    else:\n+        yield\n+\n+# (19) Valid: Multiple yield in control flow path guarded by return\n+@contextlib.contextmanager\n+def valid_yield_with_unreachable_return(value):\n+    print(\"Setting up\")\n+    if value:\n+        yield \"value\"\n+        return\n+    yield \"never reached\"\n+\n+# (20) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_yield_finally_return(value):\n+    print(\"Setting up\")\n+    if value:\n+        try:\n+            yield \"try value\"\n+        finally:\n+            print(\"Cleaning up\")\n+            return\n+    yield \"later yield\"\n+\n+# (21) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_except_yield_finally_return():\n+    def is_true():\n+        # Need this to avoid unreachable last yield\n+        return True\n+    print(\"Setting up\")\n+    if is_true():\n+        try:\n+            raise\n+        except:\n+            yield\n+        finally:\n+            print(\"Cleaning up\")\n+            return\n+    yield \"later yield\"\n+\n+\n+# (22) Valid: Return in try guards second yield\n+@contextlib.contextmanager\n+def valid_try_except_with_return():\n+    try:\n+        yield \"in try\"\n+        return\n+    except Exception:\n+        pass\n+    yield\n+\n+# (23) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_multi_except_yield(value):\n+    if value:\n+        try:\n+            pass\n+        except ValueError:\n+            yield \"value error\"\n+            return\n+        except TypeError:\n+            yield \"type error\"\n+            return\n+        except Exception:\n+            pass\n+        else:\n+            yield\n+            return\n+    yield\n+\n+# (24) Valid: Try-except-else with returns\n+@contextlib.contextmanager\n+def valid_try_except_else_with_returns(value):\n+    if value:\n+        try:\n+            pass\n+        except Exception:\n+            yield \"in except\"\n+            return\n+        else:\n+            yield \"in else\"\n+            return\n+    yield\n+\n+# (25) Valid: Nested ifs with returns\n+@contextlib.contextmanager\n+def valid_nested_ifs_with_returns(value, another_value):\n+    if value:\n+        if not another_value:\n+            yield\n+            return\n+        else:\n+            yield\n+            return\n+    elif value and 2 == 1 :\n+        if 1 == 1:\n+            yield\n+        else:\n+            yield\n+        return\n+    else:\n+        if 1 == 1:\n+            yield\n+            return\n+        else:\n+            pass\n+\n+    yield\n+\n+# (26) Valid: Returns guard from last yield in match\n+@contextlib.contextmanager\n+def valid_match_with_returns(value):\n+    match value:\n+        case 2:\n+            yield\n+            return\n+        case 3:\n+            yield\n+            return\n+        case _:\n+            pass\n+    yield\n+\n+# (27) Valid: Complex nesting with returns in some branches\n+@contextlib.contextmanager\n+def valid_complex_nesting_with_returns(value):\n+    if value:\n+        try:\n+            if 1 + 1:\n+                yield\n+                return\n+            else:\n+                try:\n+                    yield\n+                except Exception:\n+                    yield\n+                    return\n+        finally:\n+            if 1 == 2:\n+                return\n+            print(\"Cleanup without c\")\n+    else:\n+        yield \"path 4\"\n+\n+# (28) Valid: Yields in exclusive branches of try/except\n+# Rule assumes failure in try before `yield`\n+@contextlib.contextmanager\n+def valid_try_except_yields():\n+    print(\"Setting up\")\n+    try:\n+        yield \"try yield\"\n+    except Exception:\n+        yield \"except yield\"\n+    print(\"Cleaning up\")\n+\n+# (29) Valid: Multiple yields in nested\n+# Rule assumes failure in try before `yield`\n+@contextlib.contextmanager\n+def nested_try_except():\n+    try:\n+        try:\n+            yield \"outer try, inner try\"\n+        except ValueError:\n+            yield \"outer try, inner except\"  # RUF060\n+    except Exception:\n+        yield \"outer except\"  # RUF060",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2132254009",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 17281,
        "pr_file": "crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py",
        "discussion_id": "2132254009",
        "commented_code": "@@ -0,0 +1,350 @@\n+import contextlib\n+\n+# (1) Valid: Single yield in a context manager\n+@contextlib.contextmanager\n+def valid_context_manager():\n+    print(\"Setting up\")\n+    yield \"value\"\n+    print(\"Cleaning up\")\n+\n+# (2) Valid: Single yield_from in a context manager\n+@contextlib.contextmanager\n+def valid_yield_from_context_manager():\n+    print(\"Setting up\")\n+    yield from [\"value\"]\n+    print(\"Cleaning up\")\n+\n+# (3) Valid: Single yield in a context manager with nested function\n+@contextlib.contextmanager\n+def valid_with_nested():\n+    print(\"Setting up\")\n+\n+    def nested_func():\n+        yield \"nested yield\"  # yield OK, nested function\n+        yield \"multiple yields in nested OK too\"\n+\n+    yield \"value\"\n+    print(\"Cleaning up\")\n+\n+# (4) Valid: Using contextmanager with async\n+@contextlib.asynccontextmanager\n+async def valid_async_context_manager():\n+    print(\"Setting up async\")\n+    yield \"async value\"\n+    print(\"Cleaning up async\")\n+\n+# (5) Valid: No decorator\n+def not_a_context_manager():\n+    yield \"first\"\n+    yield \"second\"\n+\n+# (6) Valid: Different decorator\n+@staticmethod\n+def different_decorator():\n+    yield \"first\"\n+    yield \"second\"\n+\n+# (7) Valid: Context manager with a class\n+class ValidClass:\n+    @contextlib.contextmanager\n+    def valid_method(self):\n+        print(\"Setting up\")\n+        yield \"value\"\n+        print(\"Cleaning up\")\n+\n+# (8) Valid: Multiple yields in mutually exclusive branches\n+@contextlib.contextmanager\n+def valid_conditional_yield(condition):\n+    print(\"Setting up\")\n+    if condition:\n+        yield \"for condition\"\n+    else:\n+        yield \"for else condition\"\n+    print(\"Cleaning up\")\n+\n+# (9) Valid: Only one yield executes per run\n+@contextlib.contextmanager\n+def valid_try_else_finally():\n+    try:\n+        pass\n+    except Exception:\n+        yield \"in except\"\n+    else:\n+        yield \"in else\"\n+    print(\"done\")\n+\n+# (10) Valid: Yields in mutually exclusive match arms\n+@contextlib.contextmanager\n+def valid_match_yields(value):\n+    match value:\n+        case \"a\":\n+            yield \"from a\"\n+        case \"b\":\n+            yield \"from b\"\n+        case _:\n+            yield \"from default\"\n+\n+# (11) Valid: Multiple yields in a nested function\n+@contextlib.contextmanager\n+def valid_nested_function():\n+    def inner():\n+        yield \"inner one\"\n+        yield \"inner two\"\n+    yield \"outer\"\n+\n+# (12) Valid: Using contextmanager as a variable name followed by direct call\n+contextmanager = lambda f: f\n+@contextmanager\n+def not_really_context_manager():\n+    yield \"first\"\n+    yield \"second\"  # This is not a violation since it's not the real contextmanager\n+\n+# (13) Valid: Multiple excepts that each yield\n+@contextlib.contextmanager\n+def multiple_except_yields():\n+    try:\n+        pass\n+    except ValueError:\n+        yield \"val error\"\n+    except TypeError:\n+        yield \"type error\"\n+\n+# (14) Valid: each arm yields once\n+@contextlib.contextmanager\n+def valid_multiple_elifs():\n+    if 1 == 3:\n+        yield \"never this\"\n+    elif 1 == 2:\n+        yield \"this doesn't\"\n+    elif 2 == 2:\n+        yield \"this does\"\n+    else:\n+        yield \"This would if reached\"\n+\n+# (15) Valid: Yield in else of for loop\n+@contextlib.contextmanager\n+def for_loop_with_else():\n+    for i in range(3):\n+        pass\n+    else:\n+        yield\n+\n+# (16) Valid: Yield in else of while loop\n+@contextlib.contextmanager\n+def while_loop_with_else():\n+    x = 1\n+    while x < 3:\n+        x += 1\n+    yield\n+\n+# (17) Valid: Yield after loop\n+@contextlib.contextmanager\n+def for_loop():\n+    for i in range(3):\n+        pass\n+    yield\n+\n+# (18) Valid: Yield after loop\n+@contextlib.contextmanager\n+def while_loop():\n+    x = 1\n+    while x < 3:\n+        x += 1\n+    else:\n+        yield\n+\n+# (19) Valid: Multiple yield in control flow path guarded by return\n+@contextlib.contextmanager\n+def valid_yield_with_unreachable_return(value):\n+    print(\"Setting up\")\n+    if value:\n+        yield \"value\"\n+        return\n+    yield \"never reached\"\n+\n+# (20) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_yield_finally_return(value):\n+    print(\"Setting up\")\n+    if value:\n+        try:\n+            yield \"try value\"\n+        finally:\n+            print(\"Cleaning up\")\n+            return\n+    yield \"later yield\"\n+\n+# (21) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_except_yield_finally_return():\n+    def is_true():\n+        # Need this to avoid unreachable last yield\n+        return True\n+    print(\"Setting up\")\n+    if is_true():\n+        try:\n+            raise\n+        except:\n+            yield\n+        finally:\n+            print(\"Cleaning up\")\n+            return\n+    yield \"later yield\"\n+\n+\n+# (22) Valid: Return in try guards second yield\n+@contextlib.contextmanager\n+def valid_try_except_with_return():\n+    try:\n+        yield \"in try\"\n+        return\n+    except Exception:\n+        pass\n+    yield\n+\n+# (23) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_multi_except_yield(value):\n+    if value:\n+        try:\n+            pass\n+        except ValueError:\n+            yield \"value error\"\n+            return\n+        except TypeError:\n+            yield \"type error\"\n+            return\n+        except Exception:\n+            pass\n+        else:\n+            yield\n+            return\n+    yield\n+\n+# (24) Valid: Try-except-else with returns\n+@contextlib.contextmanager\n+def valid_try_except_else_with_returns(value):\n+    if value:\n+        try:\n+            pass\n+        except Exception:\n+            yield \"in except\"\n+            return\n+        else:\n+            yield \"in else\"\n+            return\n+    yield\n+\n+# (25) Valid: Nested ifs with returns\n+@contextlib.contextmanager\n+def valid_nested_ifs_with_returns(value, another_value):\n+    if value:\n+        if not another_value:\n+            yield\n+            return\n+        else:\n+            yield\n+            return\n+    elif value and 2 == 1 :\n+        if 1 == 1:\n+            yield\n+        else:\n+            yield\n+        return\n+    else:\n+        if 1 == 1:\n+            yield\n+            return\n+        else:\n+            pass\n+\n+    yield\n+\n+# (26) Valid: Returns guard from last yield in match\n+@contextlib.contextmanager\n+def valid_match_with_returns(value):\n+    match value:\n+        case 2:\n+            yield\n+            return\n+        case 3:\n+            yield\n+            return\n+        case _:\n+            pass\n+    yield\n+\n+# (27) Valid: Complex nesting with returns in some branches\n+@contextlib.contextmanager\n+def valid_complex_nesting_with_returns(value):\n+    if value:\n+        try:\n+            if 1 + 1:\n+                yield\n+                return\n+            else:\n+                try:\n+                    yield\n+                except Exception:\n+                    yield\n+                    return\n+        finally:\n+            if 1 == 2:\n+                return\n+            print(\"Cleanup without c\")\n+    else:\n+        yield \"path 4\"\n+\n+# (28) Valid: Yields in exclusive branches of try/except\n+# Rule assumes failure in try before `yield`\n+@contextlib.contextmanager\n+def valid_try_except_yields():\n+    print(\"Setting up\")\n+    try:\n+        yield \"try yield\"\n+    except Exception:\n+        yield \"except yield\"\n+    print(\"Cleaning up\")\n+\n+# (29) Valid: Multiple yields in nested\n+# Rule assumes failure in try before `yield`\n+@contextlib.contextmanager\n+def nested_try_except():\n+    try:\n+        try:\n+            yield \"outer try, inner try\"\n+        except ValueError:\n+            yield \"outer try, inner except\"  # RUF060\n+    except Exception:\n+        yield \"outer except\"  # RUF060",
        "comment_created_at": "2025-06-06T13:58:19+00:00",
        "comment_author": "ntBre",
        "comment_body": "So are these cases *not* valid anymore? I came back up here to ask after reading the invalid cases below, which look very similar. And now I'm seeing the `# RUF060` comments here which indicate to me that these cause errors.",
        "pr_file_module": null
      },
      {
        "comment_id": "2142019523",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 17281,
        "pr_file": "crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py",
        "discussion_id": "2132254009",
        "commented_code": "@@ -0,0 +1,350 @@\n+import contextlib\n+\n+# (1) Valid: Single yield in a context manager\n+@contextlib.contextmanager\n+def valid_context_manager():\n+    print(\"Setting up\")\n+    yield \"value\"\n+    print(\"Cleaning up\")\n+\n+# (2) Valid: Single yield_from in a context manager\n+@contextlib.contextmanager\n+def valid_yield_from_context_manager():\n+    print(\"Setting up\")\n+    yield from [\"value\"]\n+    print(\"Cleaning up\")\n+\n+# (3) Valid: Single yield in a context manager with nested function\n+@contextlib.contextmanager\n+def valid_with_nested():\n+    print(\"Setting up\")\n+\n+    def nested_func():\n+        yield \"nested yield\"  # yield OK, nested function\n+        yield \"multiple yields in nested OK too\"\n+\n+    yield \"value\"\n+    print(\"Cleaning up\")\n+\n+# (4) Valid: Using contextmanager with async\n+@contextlib.asynccontextmanager\n+async def valid_async_context_manager():\n+    print(\"Setting up async\")\n+    yield \"async value\"\n+    print(\"Cleaning up async\")\n+\n+# (5) Valid: No decorator\n+def not_a_context_manager():\n+    yield \"first\"\n+    yield \"second\"\n+\n+# (6) Valid: Different decorator\n+@staticmethod\n+def different_decorator():\n+    yield \"first\"\n+    yield \"second\"\n+\n+# (7) Valid: Context manager with a class\n+class ValidClass:\n+    @contextlib.contextmanager\n+    def valid_method(self):\n+        print(\"Setting up\")\n+        yield \"value\"\n+        print(\"Cleaning up\")\n+\n+# (8) Valid: Multiple yields in mutually exclusive branches\n+@contextlib.contextmanager\n+def valid_conditional_yield(condition):\n+    print(\"Setting up\")\n+    if condition:\n+        yield \"for condition\"\n+    else:\n+        yield \"for else condition\"\n+    print(\"Cleaning up\")\n+\n+# (9) Valid: Only one yield executes per run\n+@contextlib.contextmanager\n+def valid_try_else_finally():\n+    try:\n+        pass\n+    except Exception:\n+        yield \"in except\"\n+    else:\n+        yield \"in else\"\n+    print(\"done\")\n+\n+# (10) Valid: Yields in mutually exclusive match arms\n+@contextlib.contextmanager\n+def valid_match_yields(value):\n+    match value:\n+        case \"a\":\n+            yield \"from a\"\n+        case \"b\":\n+            yield \"from b\"\n+        case _:\n+            yield \"from default\"\n+\n+# (11) Valid: Multiple yields in a nested function\n+@contextlib.contextmanager\n+def valid_nested_function():\n+    def inner():\n+        yield \"inner one\"\n+        yield \"inner two\"\n+    yield \"outer\"\n+\n+# (12) Valid: Using contextmanager as a variable name followed by direct call\n+contextmanager = lambda f: f\n+@contextmanager\n+def not_really_context_manager():\n+    yield \"first\"\n+    yield \"second\"  # This is not a violation since it's not the real contextmanager\n+\n+# (13) Valid: Multiple excepts that each yield\n+@contextlib.contextmanager\n+def multiple_except_yields():\n+    try:\n+        pass\n+    except ValueError:\n+        yield \"val error\"\n+    except TypeError:\n+        yield \"type error\"\n+\n+# (14) Valid: each arm yields once\n+@contextlib.contextmanager\n+def valid_multiple_elifs():\n+    if 1 == 3:\n+        yield \"never this\"\n+    elif 1 == 2:\n+        yield \"this doesn't\"\n+    elif 2 == 2:\n+        yield \"this does\"\n+    else:\n+        yield \"This would if reached\"\n+\n+# (15) Valid: Yield in else of for loop\n+@contextlib.contextmanager\n+def for_loop_with_else():\n+    for i in range(3):\n+        pass\n+    else:\n+        yield\n+\n+# (16) Valid: Yield in else of while loop\n+@contextlib.contextmanager\n+def while_loop_with_else():\n+    x = 1\n+    while x < 3:\n+        x += 1\n+    yield\n+\n+# (17) Valid: Yield after loop\n+@contextlib.contextmanager\n+def for_loop():\n+    for i in range(3):\n+        pass\n+    yield\n+\n+# (18) Valid: Yield after loop\n+@contextlib.contextmanager\n+def while_loop():\n+    x = 1\n+    while x < 3:\n+        x += 1\n+    else:\n+        yield\n+\n+# (19) Valid: Multiple yield in control flow path guarded by return\n+@contextlib.contextmanager\n+def valid_yield_with_unreachable_return(value):\n+    print(\"Setting up\")\n+    if value:\n+        yield \"value\"\n+        return\n+    yield \"never reached\"\n+\n+# (20) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_yield_finally_return(value):\n+    print(\"Setting up\")\n+    if value:\n+        try:\n+            yield \"try value\"\n+        finally:\n+            print(\"Cleaning up\")\n+            return\n+    yield \"later yield\"\n+\n+# (21) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_except_yield_finally_return():\n+    def is_true():\n+        # Need this to avoid unreachable last yield\n+        return True\n+    print(\"Setting up\")\n+    if is_true():\n+        try:\n+            raise\n+        except:\n+            yield\n+        finally:\n+            print(\"Cleaning up\")\n+            return\n+    yield \"later yield\"\n+\n+\n+# (22) Valid: Return in try guards second yield\n+@contextlib.contextmanager\n+def valid_try_except_with_return():\n+    try:\n+        yield \"in try\"\n+        return\n+    except Exception:\n+        pass\n+    yield\n+\n+# (23) Valid: Return in finally guards second yield\n+@contextlib.contextmanager\n+def valid_try_multi_except_yield(value):\n+    if value:\n+        try:\n+            pass\n+        except ValueError:\n+            yield \"value error\"\n+            return\n+        except TypeError:\n+            yield \"type error\"\n+            return\n+        except Exception:\n+            pass\n+        else:\n+            yield\n+            return\n+    yield\n+\n+# (24) Valid: Try-except-else with returns\n+@contextlib.contextmanager\n+def valid_try_except_else_with_returns(value):\n+    if value:\n+        try:\n+            pass\n+        except Exception:\n+            yield \"in except\"\n+            return\n+        else:\n+            yield \"in else\"\n+            return\n+    yield\n+\n+# (25) Valid: Nested ifs with returns\n+@contextlib.contextmanager\n+def valid_nested_ifs_with_returns(value, another_value):\n+    if value:\n+        if not another_value:\n+            yield\n+            return\n+        else:\n+            yield\n+            return\n+    elif value and 2 == 1 :\n+        if 1 == 1:\n+            yield\n+        else:\n+            yield\n+        return\n+    else:\n+        if 1 == 1:\n+            yield\n+            return\n+        else:\n+            pass\n+\n+    yield\n+\n+# (26) Valid: Returns guard from last yield in match\n+@contextlib.contextmanager\n+def valid_match_with_returns(value):\n+    match value:\n+        case 2:\n+            yield\n+            return\n+        case 3:\n+            yield\n+            return\n+        case _:\n+            pass\n+    yield\n+\n+# (27) Valid: Complex nesting with returns in some branches\n+@contextlib.contextmanager\n+def valid_complex_nesting_with_returns(value):\n+    if value:\n+        try:\n+            if 1 + 1:\n+                yield\n+                return\n+            else:\n+                try:\n+                    yield\n+                except Exception:\n+                    yield\n+                    return\n+        finally:\n+            if 1 == 2:\n+                return\n+            print(\"Cleanup without c\")\n+    else:\n+        yield \"path 4\"\n+\n+# (28) Valid: Yields in exclusive branches of try/except\n+# Rule assumes failure in try before `yield`\n+@contextlib.contextmanager\n+def valid_try_except_yields():\n+    print(\"Setting up\")\n+    try:\n+        yield \"try yield\"\n+    except Exception:\n+        yield \"except yield\"\n+    print(\"Cleaning up\")\n+\n+# (29) Valid: Multiple yields in nested\n+# Rule assumes failure in try before `yield`\n+@contextlib.contextmanager\n+def nested_try_except():\n+    try:\n+        try:\n+            yield \"outer try, inner try\"\n+        except ValueError:\n+            yield \"outer try, inner except\"  # RUF060\n+    except Exception:\n+        yield \"outer except\"  # RUF060",
        "comment_created_at": "2025-06-12T08:12:19+00:00",
        "comment_author": "maxmynter",
        "comment_body": "The heuristic of this rule assumes that an error in a `try/except` occurs before the yield statement. Thus it's assumes the data flow and thus yield accumulation to either follow `try->else->finally` or `except->finally`.\r\n\r\nTherefore this is valid but those two aren't: \r\n\r\n```python\r\n# (15) Invalid: Unguarded yield in finally\r\n@contextlib.contextmanager\r\ndef yield_in_finally():\r\n    try:\r\n        yield\r\n    except:\r\n        pass\r\n    else:\r\n        return\r\n    finally:\r\n        yield\r\n\r\n# (16) Invalid: No returning except accumulates yields\r\n@contextlib.contextmanager\r\ndef yield_in_no_return_except():\r\n    try:\r\n        pass\r\n    except:\r\n        yield\r\n    else:\r\n        yield\r\n        return\r\n    yield\r\n``` \r\n\r\nI agree about the comments though. They are stale. An earlier version of the rule was also accumulating `yields` in the full `try->except->else->finally` path. But this had changes in the ecosystem tests for cases like these: \r\n```python\r\ntry:\r\n     some_flaky_setup()\r\n     yield \"success\"\r\nexcept CommonFlakinessError:\r\n    yield \"alternative\"\r\n```\r\nTherefore I moved this from invalid to valid cases. The same is true for the 3 succeeding test cases. I removed all the stale `#RUF060` comments there too.\r\n\r\nI think in the context of a contextmanager it makes sense, that the error prone code preceds the `yield` and we only count `yield`s in the abovementioned path.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]