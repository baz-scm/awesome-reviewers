[
  {
    "discussion_id": "2181426686",
    "pr_number": 19112,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/scopes/nonlocal.md",
    "created_at": "2025-07-03T02:26:18+00:00",
    "commented_code": "def h():\n             reveal_type(x)  # revealed: Unknown | Literal[1]\n ```\n+\n+## The `nonlocal` keyword\n+\n+```py\n+def f():\n+    x = 1\n+    def g():\n+        x += 1  # error: [unresolved-reference]\n+```\n+\n+Without the `nonlocal` keyword, `x += 1` (or `x = x + 1` or `x = foo(x)`) is not allowed in an inner\n+scope like this. It might look like it would read the outer `x` and write to the inner `x`, but it\n+actually tries to read the not-yet-initialized inner `x` and raises `UnboundLocalError` at runtime.",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2181426686",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 19112,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/scopes/nonlocal.md",
        "discussion_id": "2181426686",
        "commented_code": "@@ -43,3 +43,64 @@ def f():\n         def h():\n             reveal_type(x)  # revealed: Unknown | Literal[1]\n ```\n+\n+## The `nonlocal` keyword\n+\n+```py\n+def f():\n+    x = 1\n+    def g():\n+        x += 1  # error: [unresolved-reference]\n+```\n+\n+Without the `nonlocal` keyword, `x += 1` (or `x = x + 1` or `x = foo(x)`) is not allowed in an inner\n+scope like this. It might look like it would read the outer `x` and write to the inner `x`, but it\n+actually tries to read the not-yet-initialized inner `x` and raises `UnboundLocalError` at runtime.",
        "comment_created_at": "2025-07-03T02:26:18+00:00",
        "comment_author": "carljm",
        "comment_body": "Our typical style in mdtests is to put the prose description before the test snippet it describes (often ending the paragraph with a colon to indicate \"here's the code demonstrating this\"), not after the code snippet.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163080387",
    "pr_number": 18799,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md",
    "created_at": "2025-06-24T06:37:26+00:00",
    "commented_code": null,
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2163080387",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18799,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md",
        "discussion_id": "2163080387",
        "commented_code": null,
        "comment_created_at": "2025-06-24T06:37:26+00:00",
        "comment_author": "sharkdp",
        "comment_body": "I think it would be great if this file could be merged with `is_equivalent_to.md`, as a follow-up. Could probably also be a contributor task. Looks like there is quite a bit of duplication.",
        "pr_file_module": null
      },
      {
        "comment_id": "2164502890",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18799,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md",
        "discussion_id": "2163080387",
        "commented_code": null,
        "comment_created_at": "2025-06-24T17:01:39+00:00",
        "comment_author": "carljm",
        "comment_body": "I just went ahead and did this, it wasn't very hard.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159704693",
    "pr_number": 18600,
    "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md",
    "created_at": "2025-06-20T21:53:43+00:00",
    "commented_code": "static_assert(not is_assignable_to(tuple[int, int], tuple[str, ...]))\n ```\n \n+## Assignability of two mixed tuple types\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+```py\n+from typing import Literal, Any, Sequence\n+from ty_extensions import static_assert, is_assignable_to, Not, AlwaysFalsy\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+```\n+\n+## Assignability of the gradual tuple\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+As a special case, `tuple[Any, ...]` is a gradual tuple type, which is assignable to every tuple of\n+any length.",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2159704693",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md",
        "discussion_id": "2159704693",
        "commented_code": "@@ -330,6 +340,218 @@ static_assert(is_assignable_to(tuple[()], Sequence[int]))\n static_assert(not is_assignable_to(tuple[int, int], tuple[str, ...]))\n ```\n \n+## Assignability of two mixed tuple types\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+```py\n+from typing import Literal, Any, Sequence\n+from ty_extensions import static_assert, is_assignable_to, Not, AlwaysFalsy\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+```\n+\n+## Assignability of the gradual tuple\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+As a special case, `tuple[Any, ...]` is a gradual tuple type, which is assignable to every tuple of\n+any length.",
        "comment_created_at": "2025-06-20T21:53:43+00:00",
        "comment_author": "AlexWaygood",
        "comment_body": "it would be great to link to the specific parts of the spec that describe this special case, so that it's obvious to future readers of this test why it exists (https://typing.python.org/en/latest/spec/glossary.html#term-gradual-form, https://typing.python.org/en/latest/spec/tuples.html#tuple-type-form)",
        "pr_file_module": null
      },
      {
        "comment_id": "2159708984",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18600,
        "pr_file": "crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md",
        "discussion_id": "2159704693",
        "commented_code": "@@ -330,6 +340,218 @@ static_assert(is_assignable_to(tuple[()], Sequence[int]))\n static_assert(not is_assignable_to(tuple[int, int], tuple[str, ...]))\n ```\n \n+## Assignability of two mixed tuple types\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+```py\n+from typing import Literal, Any, Sequence\n+from ty_extensions import static_assert, is_assignable_to, Not, AlwaysFalsy\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], *tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...], Literal[10]],\n+    )\n+)\n+static_assert(\n+    is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[*tuple[int, ...]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], Literal[2], *tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[Literal[1], *tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...], Literal[9], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...], Literal[10]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+static_assert(\n+    not is_assignable_to(\n+        tuple[*tuple[int, ...]],\n+        tuple[Literal[1], Literal[2], *tuple[int, ...], Literal[9], Literal[10]],\n+    )\n+)\n+```\n+\n+## Assignability of the gradual tuple\n+\n+```toml\n+[environment]\n+python-version = \"3.12\"\n+```\n+\n+As a special case, `tuple[Any, ...]` is a gradual tuple type, which is assignable to every tuple of\n+any length.",
        "comment_created_at": "2025-06-20T22:00:19+00:00",
        "comment_author": "dcreager",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  }
]