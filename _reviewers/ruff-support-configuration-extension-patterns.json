[
  {
    "discussion_id": "2114649842",
    "pr_number": 18148,
    "pr_file": "crates/ruff_workspace/src/options.rs",
    "created_at": "2025-05-29T19:52:59+00:00",
    "commented_code": "}\n }\n \n+/// Options for the `refurb` plugin\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize, OptionsMetadata, CombineOptions,\n+)]\n+#[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub struct RefurbOptions {\n+    /// Define a list of classes. If a class `C` is a subclass of only classes in this list,\n+    /// `refurb` will allow `C` to explicitly set its metaclass to `abc.ABCMeta`, instead of\n+    /// insisting on inheriting from `abc.ABC` instead.\n+    ///\n+    /// This is useful for classes that validate their base-classes at runtime.\n+    ///\n+    /// For example, if `SpecialBaseClass` is in the list, while `OtherBaseClass`\n+    /// is not:\n+    ///\n+    /// ```python\n+    /// class MyClass1(SpecialBaseClass, metaclass=abc.ABCMeta):  # this is allowed\n+    ///    pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, metaclass=abc.ABCMeta):  # this will be linted\n+    ///     pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, abc.ABC):  # instead this is the way to go\n+    ///     pass\n+    /// ```\n+    ///\n+    /// Expects to receive a list of fully-qualified names (e.g., `typing.Protocol`, rather than\n+    /// `Protocol`).\n+    #[option(\n+        default = r#\"[\"typing.Protocol\", \"typing_extensions.Protocol\"]\"#,\n+        value_type = \"list[str]\",\n+        example = r#\"allow-abc-meta-bases = [\"my_package.SpecialBaseClass\"]\"#",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2114649842",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18148,
        "pr_file": "crates/ruff_workspace/src/options.rs",
        "discussion_id": "2114649842",
        "commented_code": "@@ -3384,6 +3388,55 @@ impl PyUpgradeOptions {\n     }\n }\n \n+/// Options for the `refurb` plugin\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize, OptionsMetadata, CombineOptions,\n+)]\n+#[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub struct RefurbOptions {\n+    /// Define a list of classes. If a class `C` is a subclass of only classes in this list,\n+    /// `refurb` will allow `C` to explicitly set its metaclass to `abc.ABCMeta`, instead of\n+    /// insisting on inheriting from `abc.ABC` instead.\n+    ///\n+    /// This is useful for classes that validate their base-classes at runtime.\n+    ///\n+    /// For example, if `SpecialBaseClass` is in the list, while `OtherBaseClass`\n+    /// is not:\n+    ///\n+    /// ```python\n+    /// class MyClass1(SpecialBaseClass, metaclass=abc.ABCMeta):  # this is allowed\n+    ///    pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, metaclass=abc.ABCMeta):  # this will be linted\n+    ///     pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, abc.ABC):  # instead this is the way to go\n+    ///     pass\n+    /// ```\n+    ///\n+    /// Expects to receive a list of fully-qualified names (e.g., `typing.Protocol`, rather than\n+    /// `Protocol`).\n+    #[option(\n+        default = r#\"[\"typing.Protocol\", \"typing_extensions.Protocol\"]\"#,\n+        value_type = \"list[str]\",\n+        example = r#\"allow-abc-meta-bases = [\"my_package.SpecialBaseClass\"]\"#",
        "comment_created_at": "2025-05-29T19:52:59+00:00",
        "comment_author": "ntBre",
        "comment_body": "One thing to note here, which might be fine, is that this example will remove `typing.Protocol` and `typing_extensions.Protocol` from the list, so users will have to include those manually when modifying this. We often include an `extend_*` variant of the settings to get around this, but maybe that's overkill in this situation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2116480509",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18148,
        "pr_file": "crates/ruff_workspace/src/options.rs",
        "discussion_id": "2114649842",
        "commented_code": "@@ -3384,6 +3388,55 @@ impl PyUpgradeOptions {\n     }\n }\n \n+/// Options for the `refurb` plugin\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize, OptionsMetadata, CombineOptions,\n+)]\n+#[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub struct RefurbOptions {\n+    /// Define a list of classes. If a class `C` is a subclass of only classes in this list,\n+    /// `refurb` will allow `C` to explicitly set its metaclass to `abc.ABCMeta`, instead of\n+    /// insisting on inheriting from `abc.ABC` instead.\n+    ///\n+    /// This is useful for classes that validate their base-classes at runtime.\n+    ///\n+    /// For example, if `SpecialBaseClass` is in the list, while `OtherBaseClass`\n+    /// is not:\n+    ///\n+    /// ```python\n+    /// class MyClass1(SpecialBaseClass, metaclass=abc.ABCMeta):  # this is allowed\n+    ///    pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, metaclass=abc.ABCMeta):  # this will be linted\n+    ///     pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, abc.ABC):  # instead this is the way to go\n+    ///     pass\n+    /// ```\n+    ///\n+    /// Expects to receive a list of fully-qualified names (e.g., `typing.Protocol`, rather than\n+    /// `Protocol`).\n+    #[option(\n+        default = r#\"[\"typing.Protocol\", \"typing_extensions.Protocol\"]\"#,\n+        value_type = \"list[str]\",\n+        example = r#\"allow-abc-meta-bases = [\"my_package.SpecialBaseClass\"]\"#",
        "comment_created_at": "2025-05-30T19:01:43+00:00",
        "comment_author": "robsdedude",
        "comment_body": "I'm happy to implement the extend approach, if you prefer to have it. I don't expect it to take very long to do. \r\n\r\n 1. Do you want me to?\r\n 2. If yes, should the extend config co-exist with the full list config that I've added? If yes to this as well, when both configs are given, I assume they should be merged?",
        "pr_file_module": null
      },
      {
        "comment_id": "2122858572",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18148,
        "pr_file": "crates/ruff_workspace/src/options.rs",
        "discussion_id": "2114649842",
        "commented_code": "@@ -3384,6 +3388,55 @@ impl PyUpgradeOptions {\n     }\n }\n \n+/// Options for the `refurb` plugin\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize, OptionsMetadata, CombineOptions,\n+)]\n+#[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub struct RefurbOptions {\n+    /// Define a list of classes. If a class `C` is a subclass of only classes in this list,\n+    /// `refurb` will allow `C` to explicitly set its metaclass to `abc.ABCMeta`, instead of\n+    /// insisting on inheriting from `abc.ABC` instead.\n+    ///\n+    /// This is useful for classes that validate their base-classes at runtime.\n+    ///\n+    /// For example, if `SpecialBaseClass` is in the list, while `OtherBaseClass`\n+    /// is not:\n+    ///\n+    /// ```python\n+    /// class MyClass1(SpecialBaseClass, metaclass=abc.ABCMeta):  # this is allowed\n+    ///    pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, metaclass=abc.ABCMeta):  # this will be linted\n+    ///     pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, abc.ABC):  # instead this is the way to go\n+    ///     pass\n+    /// ```\n+    ///\n+    /// Expects to receive a list of fully-qualified names (e.g., `typing.Protocol`, rather than\n+    /// `Protocol`).\n+    #[option(\n+        default = r#\"[\"typing.Protocol\", \"typing_extensions.Protocol\"]\"#,\n+        value_type = \"list[str]\",\n+        example = r#\"allow-abc-meta-bases = [\"my_package.SpecialBaseClass\"]\"#",
        "comment_created_at": "2025-06-03T06:39:01+00:00",
        "comment_author": "robsdedude",
        "comment_body": "I added an extension option.",
        "pr_file_module": null
      },
      {
        "comment_id": "2124028198",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18148,
        "pr_file": "crates/ruff_workspace/src/options.rs",
        "discussion_id": "2114649842",
        "commented_code": "@@ -3384,6 +3388,55 @@ impl PyUpgradeOptions {\n     }\n }\n \n+/// Options for the `refurb` plugin\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize, OptionsMetadata, CombineOptions,\n+)]\n+#[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n+#[cfg_attr(feature = \"schemars\", derive(schemars::JsonSchema))]\n+pub struct RefurbOptions {\n+    /// Define a list of classes. If a class `C` is a subclass of only classes in this list,\n+    /// `refurb` will allow `C` to explicitly set its metaclass to `abc.ABCMeta`, instead of\n+    /// insisting on inheriting from `abc.ABC` instead.\n+    ///\n+    /// This is useful for classes that validate their base-classes at runtime.\n+    ///\n+    /// For example, if `SpecialBaseClass` is in the list, while `OtherBaseClass`\n+    /// is not:\n+    ///\n+    /// ```python\n+    /// class MyClass1(SpecialBaseClass, metaclass=abc.ABCMeta):  # this is allowed\n+    ///    pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, metaclass=abc.ABCMeta):  # this will be linted\n+    ///     pass\n+    ///\n+    ///\n+    /// class MyClass2(OtherBaseClass, abc.ABC):  # instead this is the way to go\n+    ///     pass\n+    /// ```\n+    ///\n+    /// Expects to receive a list of fully-qualified names (e.g., `typing.Protocol`, rather than\n+    /// `Protocol`).\n+    #[option(\n+        default = r#\"[\"typing.Protocol\", \"typing_extensions.Protocol\"]\"#,\n+        value_type = \"list[str]\",\n+        example = r#\"allow-abc-meta-bases = [\"my_package.SpecialBaseClass\"]\"#",
        "comment_created_at": "2025-06-03T14:27:35+00:00",
        "comment_author": "ntBre",
        "comment_body": "Sorry my suggestion was a bit vague, I just didn't have strong feelings either way. I think it does make sense to have the extend version for convenience!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2124048806",
    "pr_number": 18148,
    "pr_file": "crates/ruff_linter/src/rules/refurb/settings.rs",
    "created_at": "2025-06-03T14:32:54+00:00",
    "commented_code": "#[derive(Debug, Clone, CacheKey)]\n pub struct Settings {\n     pub allow_abc_meta_bases: FxHashSet<String>,\n+    pub extend_abc_meta_bases: FxHashSet<String>,",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2124048806",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18148,
        "pr_file": "crates/ruff_linter/src/rules/refurb/settings.rs",
        "discussion_id": "2124048806",
        "commented_code": "@@ -17,12 +17,14 @@ pub fn default_allow_abc_meta_bases() -> FxHashSet<String> {\n #[derive(Debug, Clone, CacheKey)]\n pub struct Settings {\n     pub allow_abc_meta_bases: FxHashSet<String>,\n+    pub extend_abc_meta_bases: FxHashSet<String>,",
        "comment_created_at": "2025-06-03T14:32:54+00:00",
        "comment_author": "ntBre",
        "comment_body": "This is kind of minor, but I think we usually go ahead and combine the settings at this point. For example:\r\n\r\nhttps://github.com/astral-sh/ruff/blob/87a15f7e4cf328e6485cee98960d19f51a955ef4/crates/ruff_workspace/src/options.rs#L1457-L1468\r\n\r\nThat should simplify the check a bit in the rule itself.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154631985",
    "pr_number": 18391,
    "pr_file": "crates/ruff_linter/src/linter.rs",
    "created_at": "2025-06-18T13:35:19+00:00",
    "commented_code": "RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2154631985",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-18T13:35:19+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "Could we account for `per_file_ignores` inside `report_diagnostic` instead of doing this post-filtering here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2155784889",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T00:44:57+00:00",
        "comment_author": "ntBre",
        "comment_body": "Yeah, I guess we could check it in `report_diagnostic`, but that would be another case that would require returning an `Option<DiagnosticGuard>` right?\r\n\r\nIt looks like we could also just apply the per-file ignores to the `LinterSettings` at the top of `check_path` (or possibly even earlier). This changes one RUF100 snapshot from\r\n\r\n```\r\n        0       \u2502-RUF100_2.py:1:19: RUF100 [*] Unused `noqa` directive (unused: `F401`)\r\n              0 \u2502+RUF100_2.py:1:19: RUF100 [*] Unused `noqa` directive (non-enabled: `F401`)\r\n```\r\n\r\nbut I think `non-enabled` is actually more correct. All of the other tests pass.",
        "pr_file_module": null
      },
      {
        "comment_id": "2156509268",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T09:00:03+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "Ah right, we don't return `Option` today. But yes, I think we could just apply it to the `LinterSettings`!",
        "pr_file_module": null
      },
      {
        "comment_id": "2157085989",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T13:54:00+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "Not only would this be more correct, it should also be faster because we can skip the rules entirely. I'm not sure if we want to change how we construct `LinterSettings` (we probably shouldn't if it requires a deep clone). But checking the rule set as resolved for this file inside `is_enabled` definetely makes sense",
        "pr_file_module": null
      },
      {
        "comment_id": "2157124577",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T14:11:30+00:00",
        "comment_author": "ntBre",
        "comment_body": "Yeah I'm playing with this a bit today. It's easy enough to apply the per-file ignores at the top of `check_path`, but it does look like it needs a deep clone. I tried just cloning the rules table, but some of the nested calls expect the value on `settings` to be updated too.\r\n\r\nMaybe we could have a wrapper around `LinterSettings` that is bound to a single path, or something like that. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2157141804",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T14:18:34+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "> I tried just cloning the rules table, but some of the nested calls expect the value on settings to be updated too.\r\n\r\nUhm, that's annoying. could we refactor those calls or are there simply too many/are hard to find?",
        "pr_file_module": null
      },
      {
        "comment_id": "2157188895",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T14:41:24+00:00",
        "comment_author": "ntBre",
        "comment_body": "\"Some\" might have been a bit of an understatement. I think every, or nearly every, place we currently check if rules are enabled uses `settings.rules.enabled`, so it would be a pretty big refactor (making `LinterSettings::rules` private \"only\" causes 88 compilation errors, so maybe it's not _every_ rule). I guess I'd end up touching all of those call sites with a wrapper too, though. I was picturing something like this:\r\n\r\n```rust\r\nstruct ResolvedLinterSettings<'a> {\r\n    settings: &'a LinterSettings,\r\n    per_file_ignores: RuleSet,\r\n}\r\n\r\nimpl<'a> ResolvedLinterSettings<'a> {\r\n    fn new(settings: &'a LinterSettings, path: &Path) -> Self {\r\n        Self { settings, per_file_ignores: fs::ignores_from_path(path, &settings.per_file_ignores) }\r\n    }\r\n\r\n    fn enabled(&self, rule: Rule) -> bool {\r\n        self.settings.rules.enabled(rule) && !self.per_file_ignores.contains(rule)\r\n    }\r\n}\r\n```\r\n\r\nor I guess cloning `self.settings.rules.enabled` and combining it with `per_file_ignores` more eagerly.\r\n\r\nDo you like that idea, or would you prefer trying to pass down the updated rules table?",
        "pr_file_module": null
      },
      {
        "comment_id": "2157195630",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T14:44:02+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "Oh you're right. I thought we added a `checker` (or `context`) `is_rule_enabled` method but it seems everyone just calls `settings.rule.enabled` directly :( But given that there are only 74 references, this might not be too bad to refactor (and we now have the right place to add the methnod -> LintContext)",
        "pr_file_module": null
      },
      {
        "comment_id": "2157204755",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18391,
        "pr_file": "crates/ruff_linter/src/linter.rs",
        "discussion_id": "2154631985",
        "commented_code": "@@ -390,9 +389,12 @@ pub fn check_path(\n         RuleSet::empty()\n     };\n     if !per_file_ignores.is_empty() {\n-        diagnostics\n-            .as_mut_vec()\n-            .retain(|diagnostic| !per_file_ignores.contains(diagnostic.rule()));\n+        diagnostics.as_mut_vec().retain(|diagnostic| {\n+            diagnostic\n+                .noqa_code()\n+                .and_then(|code| code.rule())\n+                .is_none_or(|rule| !per_file_ignores.contains(rule))",
        "comment_created_at": "2025-06-19T14:47:51+00:00",
        "comment_author": "ntBre",
        "comment_body": "Oh that's true. I was worried about passing a `Path` everywhere, but if we can encapsulate it in the checker or context, that should work well. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2139887422",
    "pr_number": 18623,
    "pr_file": "crates/ruff_server/src/session/options.rs",
    "created_at": "2025-06-11T11:22:54+00:00",
    "commented_code": "+use std::{path::PathBuf, str::FromStr as _};\n+\n+use lsp_types::Url;\n+use rustc_hash::FxHashMap;\n+use serde::Deserialize;\n+use serde_json::{Map, Value};\n+\n+use ruff_linter::{RuleSelector, line_width::LineLength, rule_selector::ParseError};\n+\n+use crate::session::settings::{\n+    ClientSettings, EditorSettings, GlobalClientSettings, ResolvedConfiguration,\n+};\n+\n+pub(crate) type WorkspaceOptionsMap = FxHashMap<Url, ClientOptions>;\n+\n+/// Determines how multiple conflicting configurations should be resolved - in this\n+/// case, the configuration from the client settings and configuration from local\n+/// `.toml` files (aka 'workspace' configuration).\n+#[derive(Clone, Copy, Debug, Deserialize, Default, PartialEq, Eq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) enum ConfigurationPreference {\n+    /// Configuration set in the editor takes priority over configuration set in `.toml` files.\n+    #[default]\n+    EditorFirst,\n+    /// Configuration set in `.toml` files takes priority over configuration set in the editor.\n+    FilesystemFirst,\n+    /// `.toml` files are ignored completely, and only the editor configuration is used.\n+    EditorOnly,\n+}\n+\n+/// A direct representation of of `configuration` schema within the client settings.\n+#[derive(Clone, Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(untagged)]\n+pub(super) enum ClientConfiguration {\n+    /// A path to a configuration file.\n+    String(String),\n+    /// An object containing the configuration options.\n+    Object(Map<String, Value>),\n+}\n+\n+#[derive(Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct GlobalOptions {\n+    #[serde(flatten)]\n+    client: ClientOptions,\n+\n+    // These settings are only needed for tracing, and are only read from the global configuration.\n+    // These will not be in the resolved settings.\n+    #[serde(flatten)]\n+    pub(crate) tracing: TracingOptions,\n+}\n+\n+impl GlobalOptions {\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        self.client.set_preview(preview);\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn client(&self) -> &ClientOptions {\n+        &self.client\n+    }\n+\n+    pub fn into_settings(self) -> GlobalClientSettings {\n+        GlobalClientSettings {\n+            options: self.client,\n+            settings: std::cell::OnceCell::default(),\n+        }\n+    }\n+}\n+\n+/// This is a direct representation of the settings schema sent by the client.\n+#[derive(Clone, Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ClientOptions {\n+    configuration: Option<ClientConfiguration>,\n+    fix_all: Option<bool>,\n+    organize_imports: Option<bool>,\n+    lint: Option<LintOptions>,\n+    format: Option<FormatOptions>,\n+    code_action: Option<CodeActionOptions>,\n+    exclude: Option<Vec<String>>,\n+    line_length: Option<LineLength>,\n+    configuration_preference: Option<ConfigurationPreference>,\n+\n+    /// If `true` or [`None`], show syntax errors as diagnostics.\n+    ///\n+    /// This is useful when using Ruff with other language servers, allowing the user to refer\n+    /// to syntax errors from only one source.\n+    show_syntax_errors: Option<bool>,\n+}\n+\n+impl ClientOptions {\n+    /// Resolves the options.\n+    ///\n+    /// Returns `Ok` if all options are valid. Otherwise, returns `Err` with the partially resolved settings\n+    /// (ignoring any invalid settings). Error messages about the invalid settings are logged with tracing.\n+    #[expect(\n+        clippy::result_large_err,\n+        reason = \"The error is as large as the Ok variant\"\n+    )]\n+    pub(crate) fn into_settings(self) -> Result<ClientSettings, ClientSettings> {\n+        let code_action = self.code_action.unwrap_or_default();\n+        let lint = self.lint.unwrap_or_default();\n+        let format = self.format.unwrap_or_default();\n+        let mut contains_invalid_settings = false;\n+\n+        let configuration = self.configuration.and_then(|configuration| {\n+            match ResolvedConfiguration::try_from(configuration) {\n+                Ok(configuration) => Some(configuration),\n+                Err(err) => {\n+                    tracing::error!(\"Failed to load settings from `configuration`: {err}\");\n+                    contains_invalid_settings = true;\n+                    None\n+                }\n+            }\n+        });\n+\n+        let editor_settings = EditorSettings {\n+            configuration,\n+            lint_preview: lint.preview,\n+            format_preview: format.preview,\n+            select: lint.select.and_then(|select| {\n+                Self::resolve_rules(\n+                    &select,\n+                    RuleSelectorKey::Select,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            extend_select: lint.extend_select.and_then(|select| {\n+                Self::resolve_rules(\n+                    &select,\n+                    RuleSelectorKey::ExtendSelect,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            ignore: lint.ignore.and_then(|ignore| {\n+                Self::resolve_rules(\n+                    &ignore,\n+                    RuleSelectorKey::Ignore,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            exclude: self.exclude.clone(),\n+            line_length: self.line_length,\n+            configuration_preference: self.configuration_preference.unwrap_or_default(),\n+        };\n+\n+        let resolved = ClientSettings {\n+            editor_settings,\n+            fix_all: self.fix_all.unwrap_or(true),\n+            organize_imports: self.organize_imports.unwrap_or(true),\n+            lint_enable: lint.enable.unwrap_or(true),\n+            disable_rule_comment_enable: code_action\n+                .disable_rule_comment\n+                .and_then(|disable| disable.enable)\n+                .unwrap_or(true),\n+            fix_violation_enable: code_action\n+                .fix_violation\n+                .and_then(|fix| fix.enable)\n+                .unwrap_or(true),\n+\n+            show_syntax_errors: self.show_syntax_errors.unwrap_or(true),\n+        };\n+\n+        if contains_invalid_settings {\n+            Err(resolved)\n+        } else {\n+            Ok(resolved)\n+        }\n+    }\n+\n+    fn resolve_rules(\n+        rules: &[String],\n+        key: RuleSelectorKey,\n+        contains_invalid_settings: &mut bool,\n+    ) -> Option<Vec<RuleSelector>> {\n+        let (mut known, mut unknown) = (vec![], vec![]);\n+        for rule in rules {\n+            match RuleSelector::from_str(rule) {\n+                Ok(selector) => known.push(selector),\n+                Err(ParseError::Unknown(_)) => unknown.push(rule),\n+            }\n+        }\n+        if !unknown.is_empty() {\n+            *contains_invalid_settings = true;\n+            tracing::error!(\"Unknown rule selectors found in `{key}`: {unknown:?}\");\n+        }\n+        if known.is_empty() { None } else { Some(known) }\n+    }\n+\n+    /// Update the preview flag for the linter and the formatter with the given value.\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        match self.lint.as_mut() {\n+            None => self.lint = Some(LintOptions::default().with_preview(preview)),\n+            Some(lint) => lint.set_preview(preview),\n+        }\n+        match self.format.as_mut() {\n+            None => self.format = Some(FormatOptions::default().with_preview(preview)),\n+            Some(format) => format.set_preview(preview),\n+        }\n+    }\n+}\n+\n+impl Combine for ClientOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.configuration.combine_with(other.configuration);\n+        self.fix_all.combine_with(other.fix_all);\n+        self.organize_imports.combine_with(other.organize_imports);\n+        self.lint.combine_with(other.lint);\n+        self.format.combine_with(other.format);\n+        self.code_action.combine_with(other.code_action);\n+        self.exclude.combine_with(other.exclude);\n+        self.line_length.combine_with(other.line_length);\n+        self.configuration_preference\n+            .combine_with(other.configuration_preference);\n+        self.show_syntax_errors\n+            .combine_with(other.show_syntax_errors);\n+    }\n+}\n+\n+/// Settings needed to initialize tracing. These will only be\n+/// read from the global configuration.\n+#[derive(Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct TracingOptions {\n+    pub(crate) log_level: Option<crate::logging::LogLevel>,\n+    /// Path to the log file - tildes and environment variables are supported.\n+    pub(crate) log_file: Option<PathBuf>,\n+}\n+\n+/// This is a direct representation of the workspace settings schema,\n+/// which inherits the schema of [`ClientSettings`] and adds extra fields\n+/// to describe the workspace it applies to.\n+#[derive(Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct WorkspaceOptions {\n+    #[serde(flatten)]\n+    options: ClientOptions,\n+    workspace: Url,\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct LintOptions {\n+    enable: Option<bool>,\n+    preview: Option<bool>,\n+    select: Option<Vec<String>>,\n+    extend_select: Option<Vec<String>>,\n+    ignore: Option<Vec<String>>,\n+}\n+\n+impl LintOptions {\n+    fn with_preview(mut self, preview: bool) -> LintOptions {\n+        self.preview = Some(preview);\n+        self\n+    }\n+\n+    fn set_preview(&mut self, preview: bool) {\n+        self.preview = Some(preview);\n+    }\n+}\n+\n+impl Combine for LintOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.enable.combine_with(other.enable);\n+        self.preview.combine_with(other.preview);\n+        self.select.combine_with(other.select);\n+        self.extend_select.combine_with(other.extend_select);\n+        self.ignore.combine_with(other.ignore);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct FormatOptions {\n+    preview: Option<bool>,\n+}\n+\n+impl Combine for FormatOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.preview.combine_with(other.preview);\n+    }\n+}\n+\n+impl FormatOptions {\n+    fn with_preview(mut self, preview: bool) -> FormatOptions {\n+        self.preview = Some(preview);\n+        self\n+    }\n+\n+    fn set_preview(&mut self, preview: bool) {\n+        self.preview = Some(preview);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct CodeActionOptions {\n+    disable_rule_comment: Option<CodeActionParameters>,\n+    fix_violation: Option<CodeActionParameters>,\n+}\n+\n+impl Combine for CodeActionOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.disable_rule_comment\n+            .combine_with(other.disable_rule_comment);\n+        self.fix_violation.combine_with(other.fix_violation);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct CodeActionParameters {\n+    enable: Option<bool>,\n+}\n+\n+impl Combine for CodeActionParameters {\n+    fn combine_with(&mut self, other: Self) {\n+        self.enable.combine_with(other.enable);\n+    }\n+}\n+\n+/// This is the exact schema for initialization options sent in by the client\n+/// during initialization.\n+#[derive(Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(untagged)]\n+enum InitializationOptions {\n+    #[serde(rename_all = \"camelCase\")]\n+    HasWorkspaces {\n+        #[serde(rename = \"globalSettings\")]\n+        global: GlobalOptions,\n+        #[serde(rename = \"settings\")]\n+        workspace: Vec<WorkspaceOptions>,\n+    },\n+    GlobalOnly {\n+        #[serde(default)]\n+        settings: GlobalOptions,\n+    },\n+}\n+\n+impl Default for InitializationOptions {\n+    fn default() -> Self {\n+        Self::GlobalOnly {\n+            settings: GlobalOptions::default(),\n+        }\n+    }\n+}\n+\n+/// Built from the initialization options provided by the client.\n+#[derive(Debug)]\n+pub(crate) struct AllOptions {\n+    pub(crate) global: GlobalOptions,\n+    /// If this is `None`, the client only passed in global settings.\n+    pub(crate) workspace: Option<WorkspaceOptionsMap>,\n+}\n+\n+impl AllOptions {\n+    /// Initializes the controller from the serialized initialization options.\n+    /// This fails if `options` are not valid initialization options.\n+    pub(crate) fn from_value(options: serde_json::Value) -> Self {\n+        Self::from_init_options(\n+            serde_json::from_value(options)\n+                .map_err(|err| {\n+                    tracing::error!(\"Failed to deserialize initialization options: {err}. Falling back to default client settings...\");\n+                    show_err_msg!(\"Ruff received invalid client settings - falling back to default client settings.\");\n+                })\n+                .unwrap_or_default(),\n+        )\n+    }\n+\n+    /// Update the preview flag for both the global and all workspace settings.\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        self.global.set_preview(preview);\n+        if let Some(workspace_settings) = self.workspace.as_mut() {\n+            for settings in workspace_settings.values_mut() {\n+                settings.set_preview(preview);\n+            }\n+        }\n+    }\n+\n+    fn from_init_options(options: InitializationOptions) -> Self {\n+        let (global_settings, workspace_settings) = match options {\n+            InitializationOptions::GlobalOnly { settings } => (settings, None),\n+            InitializationOptions::HasWorkspaces {\n+                global: global_settings,\n+                workspace: workspace_settings,\n+            } => (global_settings, Some(workspace_settings)),\n+        };\n+\n+        Self {\n+            global: global_settings,\n+            workspace: workspace_settings.map(|workspace_settings| {\n+                workspace_settings\n+                    .into_iter()\n+                    .map(|settings| (settings.workspace, settings.options))\n+                    .collect()\n+            }),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum RuleSelectorKey {\n+    Select,\n+    ExtendSelect,\n+    Ignore,\n+}\n+\n+impl std::fmt::Display for RuleSelectorKey {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            RuleSelectorKey::Select => f.write_str(\"lint.select\"),\n+            RuleSelectorKey::ExtendSelect => f.write_str(\"lint.extendSelect\"),\n+            RuleSelectorKey::Ignore => f.write_str(\"lint.ignore\"),\n+        }\n+    }\n+}\n+\n+pub(crate) trait Combine {\n+    #[must_use]\n+    fn combine(mut self, other: Self) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.combine_with(other);\n+        self\n+    }\n+\n+    fn combine_with(&mut self, other: Self);\n+}",
    "repo_full_name": "astral-sh/ruff",
    "discussion_comments": [
      {
        "comment_id": "2139887422",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18623,
        "pr_file": "crates/ruff_server/src/session/options.rs",
        "discussion_id": "2139887422",
        "commented_code": "@@ -0,0 +1,1003 @@\n+use std::{path::PathBuf, str::FromStr as _};\n+\n+use lsp_types::Url;\n+use rustc_hash::FxHashMap;\n+use serde::Deserialize;\n+use serde_json::{Map, Value};\n+\n+use ruff_linter::{RuleSelector, line_width::LineLength, rule_selector::ParseError};\n+\n+use crate::session::settings::{\n+    ClientSettings, EditorSettings, GlobalClientSettings, ResolvedConfiguration,\n+};\n+\n+pub(crate) type WorkspaceOptionsMap = FxHashMap<Url, ClientOptions>;\n+\n+/// Determines how multiple conflicting configurations should be resolved - in this\n+/// case, the configuration from the client settings and configuration from local\n+/// `.toml` files (aka 'workspace' configuration).\n+#[derive(Clone, Copy, Debug, Deserialize, Default, PartialEq, Eq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) enum ConfigurationPreference {\n+    /// Configuration set in the editor takes priority over configuration set in `.toml` files.\n+    #[default]\n+    EditorFirst,\n+    /// Configuration set in `.toml` files takes priority over configuration set in the editor.\n+    FilesystemFirst,\n+    /// `.toml` files are ignored completely, and only the editor configuration is used.\n+    EditorOnly,\n+}\n+\n+/// A direct representation of of `configuration` schema within the client settings.\n+#[derive(Clone, Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(untagged)]\n+pub(super) enum ClientConfiguration {\n+    /// A path to a configuration file.\n+    String(String),\n+    /// An object containing the configuration options.\n+    Object(Map<String, Value>),\n+}\n+\n+#[derive(Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct GlobalOptions {\n+    #[serde(flatten)]\n+    client: ClientOptions,\n+\n+    // These settings are only needed for tracing, and are only read from the global configuration.\n+    // These will not be in the resolved settings.\n+    #[serde(flatten)]\n+    pub(crate) tracing: TracingOptions,\n+}\n+\n+impl GlobalOptions {\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        self.client.set_preview(preview);\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn client(&self) -> &ClientOptions {\n+        &self.client\n+    }\n+\n+    pub fn into_settings(self) -> GlobalClientSettings {\n+        GlobalClientSettings {\n+            options: self.client,\n+            settings: std::cell::OnceCell::default(),\n+        }\n+    }\n+}\n+\n+/// This is a direct representation of the settings schema sent by the client.\n+#[derive(Clone, Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ClientOptions {\n+    configuration: Option<ClientConfiguration>,\n+    fix_all: Option<bool>,\n+    organize_imports: Option<bool>,\n+    lint: Option<LintOptions>,\n+    format: Option<FormatOptions>,\n+    code_action: Option<CodeActionOptions>,\n+    exclude: Option<Vec<String>>,\n+    line_length: Option<LineLength>,\n+    configuration_preference: Option<ConfigurationPreference>,\n+\n+    /// If `true` or [`None`], show syntax errors as diagnostics.\n+    ///\n+    /// This is useful when using Ruff with other language servers, allowing the user to refer\n+    /// to syntax errors from only one source.\n+    show_syntax_errors: Option<bool>,\n+}\n+\n+impl ClientOptions {\n+    /// Resolves the options.\n+    ///\n+    /// Returns `Ok` if all options are valid. Otherwise, returns `Err` with the partially resolved settings\n+    /// (ignoring any invalid settings). Error messages about the invalid settings are logged with tracing.\n+    #[expect(\n+        clippy::result_large_err,\n+        reason = \"The error is as large as the Ok variant\"\n+    )]\n+    pub(crate) fn into_settings(self) -> Result<ClientSettings, ClientSettings> {\n+        let code_action = self.code_action.unwrap_or_default();\n+        let lint = self.lint.unwrap_or_default();\n+        let format = self.format.unwrap_or_default();\n+        let mut contains_invalid_settings = false;\n+\n+        let configuration = self.configuration.and_then(|configuration| {\n+            match ResolvedConfiguration::try_from(configuration) {\n+                Ok(configuration) => Some(configuration),\n+                Err(err) => {\n+                    tracing::error!(\"Failed to load settings from `configuration`: {err}\");\n+                    contains_invalid_settings = true;\n+                    None\n+                }\n+            }\n+        });\n+\n+        let editor_settings = EditorSettings {\n+            configuration,\n+            lint_preview: lint.preview,\n+            format_preview: format.preview,\n+            select: lint.select.and_then(|select| {\n+                Self::resolve_rules(\n+                    &select,\n+                    RuleSelectorKey::Select,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            extend_select: lint.extend_select.and_then(|select| {\n+                Self::resolve_rules(\n+                    &select,\n+                    RuleSelectorKey::ExtendSelect,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            ignore: lint.ignore.and_then(|ignore| {\n+                Self::resolve_rules(\n+                    &ignore,\n+                    RuleSelectorKey::Ignore,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            exclude: self.exclude.clone(),\n+            line_length: self.line_length,\n+            configuration_preference: self.configuration_preference.unwrap_or_default(),\n+        };\n+\n+        let resolved = ClientSettings {\n+            editor_settings,\n+            fix_all: self.fix_all.unwrap_or(true),\n+            organize_imports: self.organize_imports.unwrap_or(true),\n+            lint_enable: lint.enable.unwrap_or(true),\n+            disable_rule_comment_enable: code_action\n+                .disable_rule_comment\n+                .and_then(|disable| disable.enable)\n+                .unwrap_or(true),\n+            fix_violation_enable: code_action\n+                .fix_violation\n+                .and_then(|fix| fix.enable)\n+                .unwrap_or(true),\n+\n+            show_syntax_errors: self.show_syntax_errors.unwrap_or(true),\n+        };\n+\n+        if contains_invalid_settings {\n+            Err(resolved)\n+        } else {\n+            Ok(resolved)\n+        }\n+    }\n+\n+    fn resolve_rules(\n+        rules: &[String],\n+        key: RuleSelectorKey,\n+        contains_invalid_settings: &mut bool,\n+    ) -> Option<Vec<RuleSelector>> {\n+        let (mut known, mut unknown) = (vec![], vec![]);\n+        for rule in rules {\n+            match RuleSelector::from_str(rule) {\n+                Ok(selector) => known.push(selector),\n+                Err(ParseError::Unknown(_)) => unknown.push(rule),\n+            }\n+        }\n+        if !unknown.is_empty() {\n+            *contains_invalid_settings = true;\n+            tracing::error!(\"Unknown rule selectors found in `{key}`: {unknown:?}\");\n+        }\n+        if known.is_empty() { None } else { Some(known) }\n+    }\n+\n+    /// Update the preview flag for the linter and the formatter with the given value.\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        match self.lint.as_mut() {\n+            None => self.lint = Some(LintOptions::default().with_preview(preview)),\n+            Some(lint) => lint.set_preview(preview),\n+        }\n+        match self.format.as_mut() {\n+            None => self.format = Some(FormatOptions::default().with_preview(preview)),\n+            Some(format) => format.set_preview(preview),\n+        }\n+    }\n+}\n+\n+impl Combine for ClientOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.configuration.combine_with(other.configuration);\n+        self.fix_all.combine_with(other.fix_all);\n+        self.organize_imports.combine_with(other.organize_imports);\n+        self.lint.combine_with(other.lint);\n+        self.format.combine_with(other.format);\n+        self.code_action.combine_with(other.code_action);\n+        self.exclude.combine_with(other.exclude);\n+        self.line_length.combine_with(other.line_length);\n+        self.configuration_preference\n+            .combine_with(other.configuration_preference);\n+        self.show_syntax_errors\n+            .combine_with(other.show_syntax_errors);\n+    }\n+}\n+\n+/// Settings needed to initialize tracing. These will only be\n+/// read from the global configuration.\n+#[derive(Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct TracingOptions {\n+    pub(crate) log_level: Option<crate::logging::LogLevel>,\n+    /// Path to the log file - tildes and environment variables are supported.\n+    pub(crate) log_file: Option<PathBuf>,\n+}\n+\n+/// This is a direct representation of the workspace settings schema,\n+/// which inherits the schema of [`ClientSettings`] and adds extra fields\n+/// to describe the workspace it applies to.\n+#[derive(Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct WorkspaceOptions {\n+    #[serde(flatten)]\n+    options: ClientOptions,\n+    workspace: Url,\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct LintOptions {\n+    enable: Option<bool>,\n+    preview: Option<bool>,\n+    select: Option<Vec<String>>,\n+    extend_select: Option<Vec<String>>,\n+    ignore: Option<Vec<String>>,\n+}\n+\n+impl LintOptions {\n+    fn with_preview(mut self, preview: bool) -> LintOptions {\n+        self.preview = Some(preview);\n+        self\n+    }\n+\n+    fn set_preview(&mut self, preview: bool) {\n+        self.preview = Some(preview);\n+    }\n+}\n+\n+impl Combine for LintOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.enable.combine_with(other.enable);\n+        self.preview.combine_with(other.preview);\n+        self.select.combine_with(other.select);\n+        self.extend_select.combine_with(other.extend_select);\n+        self.ignore.combine_with(other.ignore);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct FormatOptions {\n+    preview: Option<bool>,\n+}\n+\n+impl Combine for FormatOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.preview.combine_with(other.preview);\n+    }\n+}\n+\n+impl FormatOptions {\n+    fn with_preview(mut self, preview: bool) -> FormatOptions {\n+        self.preview = Some(preview);\n+        self\n+    }\n+\n+    fn set_preview(&mut self, preview: bool) {\n+        self.preview = Some(preview);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct CodeActionOptions {\n+    disable_rule_comment: Option<CodeActionParameters>,\n+    fix_violation: Option<CodeActionParameters>,\n+}\n+\n+impl Combine for CodeActionOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.disable_rule_comment\n+            .combine_with(other.disable_rule_comment);\n+        self.fix_violation.combine_with(other.fix_violation);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct CodeActionParameters {\n+    enable: Option<bool>,\n+}\n+\n+impl Combine for CodeActionParameters {\n+    fn combine_with(&mut self, other: Self) {\n+        self.enable.combine_with(other.enable);\n+    }\n+}\n+\n+/// This is the exact schema for initialization options sent in by the client\n+/// during initialization.\n+#[derive(Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(untagged)]\n+enum InitializationOptions {\n+    #[serde(rename_all = \"camelCase\")]\n+    HasWorkspaces {\n+        #[serde(rename = \"globalSettings\")]\n+        global: GlobalOptions,\n+        #[serde(rename = \"settings\")]\n+        workspace: Vec<WorkspaceOptions>,\n+    },\n+    GlobalOnly {\n+        #[serde(default)]\n+        settings: GlobalOptions,\n+    },\n+}\n+\n+impl Default for InitializationOptions {\n+    fn default() -> Self {\n+        Self::GlobalOnly {\n+            settings: GlobalOptions::default(),\n+        }\n+    }\n+}\n+\n+/// Built from the initialization options provided by the client.\n+#[derive(Debug)]\n+pub(crate) struct AllOptions {\n+    pub(crate) global: GlobalOptions,\n+    /// If this is `None`, the client only passed in global settings.\n+    pub(crate) workspace: Option<WorkspaceOptionsMap>,\n+}\n+\n+impl AllOptions {\n+    /// Initializes the controller from the serialized initialization options.\n+    /// This fails if `options` are not valid initialization options.\n+    pub(crate) fn from_value(options: serde_json::Value) -> Self {\n+        Self::from_init_options(\n+            serde_json::from_value(options)\n+                .map_err(|err| {\n+                    tracing::error!(\"Failed to deserialize initialization options: {err}. Falling back to default client settings...\");\n+                    show_err_msg!(\"Ruff received invalid client settings - falling back to default client settings.\");\n+                })\n+                .unwrap_or_default(),\n+        )\n+    }\n+\n+    /// Update the preview flag for both the global and all workspace settings.\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        self.global.set_preview(preview);\n+        if let Some(workspace_settings) = self.workspace.as_mut() {\n+            for settings in workspace_settings.values_mut() {\n+                settings.set_preview(preview);\n+            }\n+        }\n+    }\n+\n+    fn from_init_options(options: InitializationOptions) -> Self {\n+        let (global_settings, workspace_settings) = match options {\n+            InitializationOptions::GlobalOnly { settings } => (settings, None),\n+            InitializationOptions::HasWorkspaces {\n+                global: global_settings,\n+                workspace: workspace_settings,\n+            } => (global_settings, Some(workspace_settings)),\n+        };\n+\n+        Self {\n+            global: global_settings,\n+            workspace: workspace_settings.map(|workspace_settings| {\n+                workspace_settings\n+                    .into_iter()\n+                    .map(|settings| (settings.workspace, settings.options))\n+                    .collect()\n+            }),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum RuleSelectorKey {\n+    Select,\n+    ExtendSelect,\n+    Ignore,\n+}\n+\n+impl std::fmt::Display for RuleSelectorKey {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            RuleSelectorKey::Select => f.write_str(\"lint.select\"),\n+            RuleSelectorKey::ExtendSelect => f.write_str(\"lint.extendSelect\"),\n+            RuleSelectorKey::Ignore => f.write_str(\"lint.ignore\"),\n+        }\n+    }\n+}\n+\n+pub(crate) trait Combine {\n+    #[must_use]\n+    fn combine(mut self, other: Self) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.combine_with(other);\n+        self\n+    }\n+\n+    fn combine_with(&mut self, other: Self);\n+}",
        "comment_created_at": "2025-06-11T11:22:54+00:00",
        "comment_author": "MichaReiser",
        "comment_body": "It's a bit unfortunate that this is now our third version of `Combine`. I tried to use Ruff's `CombineOptions` but had to realise that the server's combine logic is closer to ty's but also inconsistent. Making it impossible to use either ty's nor Ruff's implementation\r\n\r\n* Unlike Ruff, the server deeply merges options. E.g., setting `lint` in the workspace settings doesn't override all `lint` settings from the global settings.\r\n* Unlike ty, the server doesn't merge vectors. \r\n* The server was inconsistent about how to handle `.configuration`: Before, it tried to resolve the field from the workspace, but it fell back to the `configuration` field from the global settings if, e.g., the file didn't exist. Now, we'll use the `configuration` value from the workspace without falling back to the global settings `configuration` if the server fails to resolve the configuration. This seems more correct in my view (and consistent with how we handle configurations in other places)",
        "pr_file_module": null
      },
      {
        "comment_id": "2142054498",
        "repo_full_name": "astral-sh/ruff",
        "pr_number": 18623,
        "pr_file": "crates/ruff_server/src/session/options.rs",
        "discussion_id": "2139887422",
        "commented_code": "@@ -0,0 +1,1003 @@\n+use std::{path::PathBuf, str::FromStr as _};\n+\n+use lsp_types::Url;\n+use rustc_hash::FxHashMap;\n+use serde::Deserialize;\n+use serde_json::{Map, Value};\n+\n+use ruff_linter::{RuleSelector, line_width::LineLength, rule_selector::ParseError};\n+\n+use crate::session::settings::{\n+    ClientSettings, EditorSettings, GlobalClientSettings, ResolvedConfiguration,\n+};\n+\n+pub(crate) type WorkspaceOptionsMap = FxHashMap<Url, ClientOptions>;\n+\n+/// Determines how multiple conflicting configurations should be resolved - in this\n+/// case, the configuration from the client settings and configuration from local\n+/// `.toml` files (aka 'workspace' configuration).\n+#[derive(Clone, Copy, Debug, Deserialize, Default, PartialEq, Eq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) enum ConfigurationPreference {\n+    /// Configuration set in the editor takes priority over configuration set in `.toml` files.\n+    #[default]\n+    EditorFirst,\n+    /// Configuration set in `.toml` files takes priority over configuration set in the editor.\n+    FilesystemFirst,\n+    /// `.toml` files are ignored completely, and only the editor configuration is used.\n+    EditorOnly,\n+}\n+\n+/// A direct representation of of `configuration` schema within the client settings.\n+#[derive(Clone, Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(untagged)]\n+pub(super) enum ClientConfiguration {\n+    /// A path to a configuration file.\n+    String(String),\n+    /// An object containing the configuration options.\n+    Object(Map<String, Value>),\n+}\n+\n+#[derive(Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct GlobalOptions {\n+    #[serde(flatten)]\n+    client: ClientOptions,\n+\n+    // These settings are only needed for tracing, and are only read from the global configuration.\n+    // These will not be in the resolved settings.\n+    #[serde(flatten)]\n+    pub(crate) tracing: TracingOptions,\n+}\n+\n+impl GlobalOptions {\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        self.client.set_preview(preview);\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn client(&self) -> &ClientOptions {\n+        &self.client\n+    }\n+\n+    pub fn into_settings(self) -> GlobalClientSettings {\n+        GlobalClientSettings {\n+            options: self.client,\n+            settings: std::cell::OnceCell::default(),\n+        }\n+    }\n+}\n+\n+/// This is a direct representation of the settings schema sent by the client.\n+#[derive(Clone, Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ClientOptions {\n+    configuration: Option<ClientConfiguration>,\n+    fix_all: Option<bool>,\n+    organize_imports: Option<bool>,\n+    lint: Option<LintOptions>,\n+    format: Option<FormatOptions>,\n+    code_action: Option<CodeActionOptions>,\n+    exclude: Option<Vec<String>>,\n+    line_length: Option<LineLength>,\n+    configuration_preference: Option<ConfigurationPreference>,\n+\n+    /// If `true` or [`None`], show syntax errors as diagnostics.\n+    ///\n+    /// This is useful when using Ruff with other language servers, allowing the user to refer\n+    /// to syntax errors from only one source.\n+    show_syntax_errors: Option<bool>,\n+}\n+\n+impl ClientOptions {\n+    /// Resolves the options.\n+    ///\n+    /// Returns `Ok` if all options are valid. Otherwise, returns `Err` with the partially resolved settings\n+    /// (ignoring any invalid settings). Error messages about the invalid settings are logged with tracing.\n+    #[expect(\n+        clippy::result_large_err,\n+        reason = \"The error is as large as the Ok variant\"\n+    )]\n+    pub(crate) fn into_settings(self) -> Result<ClientSettings, ClientSettings> {\n+        let code_action = self.code_action.unwrap_or_default();\n+        let lint = self.lint.unwrap_or_default();\n+        let format = self.format.unwrap_or_default();\n+        let mut contains_invalid_settings = false;\n+\n+        let configuration = self.configuration.and_then(|configuration| {\n+            match ResolvedConfiguration::try_from(configuration) {\n+                Ok(configuration) => Some(configuration),\n+                Err(err) => {\n+                    tracing::error!(\"Failed to load settings from `configuration`: {err}\");\n+                    contains_invalid_settings = true;\n+                    None\n+                }\n+            }\n+        });\n+\n+        let editor_settings = EditorSettings {\n+            configuration,\n+            lint_preview: lint.preview,\n+            format_preview: format.preview,\n+            select: lint.select.and_then(|select| {\n+                Self::resolve_rules(\n+                    &select,\n+                    RuleSelectorKey::Select,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            extend_select: lint.extend_select.and_then(|select| {\n+                Self::resolve_rules(\n+                    &select,\n+                    RuleSelectorKey::ExtendSelect,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            ignore: lint.ignore.and_then(|ignore| {\n+                Self::resolve_rules(\n+                    &ignore,\n+                    RuleSelectorKey::Ignore,\n+                    &mut contains_invalid_settings,\n+                )\n+            }),\n+            exclude: self.exclude.clone(),\n+            line_length: self.line_length,\n+            configuration_preference: self.configuration_preference.unwrap_or_default(),\n+        };\n+\n+        let resolved = ClientSettings {\n+            editor_settings,\n+            fix_all: self.fix_all.unwrap_or(true),\n+            organize_imports: self.organize_imports.unwrap_or(true),\n+            lint_enable: lint.enable.unwrap_or(true),\n+            disable_rule_comment_enable: code_action\n+                .disable_rule_comment\n+                .and_then(|disable| disable.enable)\n+                .unwrap_or(true),\n+            fix_violation_enable: code_action\n+                .fix_violation\n+                .and_then(|fix| fix.enable)\n+                .unwrap_or(true),\n+\n+            show_syntax_errors: self.show_syntax_errors.unwrap_or(true),\n+        };\n+\n+        if contains_invalid_settings {\n+            Err(resolved)\n+        } else {\n+            Ok(resolved)\n+        }\n+    }\n+\n+    fn resolve_rules(\n+        rules: &[String],\n+        key: RuleSelectorKey,\n+        contains_invalid_settings: &mut bool,\n+    ) -> Option<Vec<RuleSelector>> {\n+        let (mut known, mut unknown) = (vec![], vec![]);\n+        for rule in rules {\n+            match RuleSelector::from_str(rule) {\n+                Ok(selector) => known.push(selector),\n+                Err(ParseError::Unknown(_)) => unknown.push(rule),\n+            }\n+        }\n+        if !unknown.is_empty() {\n+            *contains_invalid_settings = true;\n+            tracing::error!(\"Unknown rule selectors found in `{key}`: {unknown:?}\");\n+        }\n+        if known.is_empty() { None } else { Some(known) }\n+    }\n+\n+    /// Update the preview flag for the linter and the formatter with the given value.\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        match self.lint.as_mut() {\n+            None => self.lint = Some(LintOptions::default().with_preview(preview)),\n+            Some(lint) => lint.set_preview(preview),\n+        }\n+        match self.format.as_mut() {\n+            None => self.format = Some(FormatOptions::default().with_preview(preview)),\n+            Some(format) => format.set_preview(preview),\n+        }\n+    }\n+}\n+\n+impl Combine for ClientOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.configuration.combine_with(other.configuration);\n+        self.fix_all.combine_with(other.fix_all);\n+        self.organize_imports.combine_with(other.organize_imports);\n+        self.lint.combine_with(other.lint);\n+        self.format.combine_with(other.format);\n+        self.code_action.combine_with(other.code_action);\n+        self.exclude.combine_with(other.exclude);\n+        self.line_length.combine_with(other.line_length);\n+        self.configuration_preference\n+            .combine_with(other.configuration_preference);\n+        self.show_syntax_errors\n+            .combine_with(other.show_syntax_errors);\n+    }\n+}\n+\n+/// Settings needed to initialize tracing. These will only be\n+/// read from the global configuration.\n+#[derive(Debug, Deserialize, Default)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+pub(crate) struct TracingOptions {\n+    pub(crate) log_level: Option<crate::logging::LogLevel>,\n+    /// Path to the log file - tildes and environment variables are supported.\n+    pub(crate) log_file: Option<PathBuf>,\n+}\n+\n+/// This is a direct representation of the workspace settings schema,\n+/// which inherits the schema of [`ClientSettings`] and adds extra fields\n+/// to describe the workspace it applies to.\n+#[derive(Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct WorkspaceOptions {\n+    #[serde(flatten)]\n+    options: ClientOptions,\n+    workspace: Url,\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct LintOptions {\n+    enable: Option<bool>,\n+    preview: Option<bool>,\n+    select: Option<Vec<String>>,\n+    extend_select: Option<Vec<String>>,\n+    ignore: Option<Vec<String>>,\n+}\n+\n+impl LintOptions {\n+    fn with_preview(mut self, preview: bool) -> LintOptions {\n+        self.preview = Some(preview);\n+        self\n+    }\n+\n+    fn set_preview(&mut self, preview: bool) {\n+        self.preview = Some(preview);\n+    }\n+}\n+\n+impl Combine for LintOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.enable.combine_with(other.enable);\n+        self.preview.combine_with(other.preview);\n+        self.select.combine_with(other.select);\n+        self.extend_select.combine_with(other.extend_select);\n+        self.ignore.combine_with(other.ignore);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct FormatOptions {\n+    preview: Option<bool>,\n+}\n+\n+impl Combine for FormatOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.preview.combine_with(other.preview);\n+    }\n+}\n+\n+impl FormatOptions {\n+    fn with_preview(mut self, preview: bool) -> FormatOptions {\n+        self.preview = Some(preview);\n+        self\n+    }\n+\n+    fn set_preview(&mut self, preview: bool) {\n+        self.preview = Some(preview);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct CodeActionOptions {\n+    disable_rule_comment: Option<CodeActionParameters>,\n+    fix_violation: Option<CodeActionParameters>,\n+}\n+\n+impl Combine for CodeActionOptions {\n+    fn combine_with(&mut self, other: Self) {\n+        self.disable_rule_comment\n+            .combine_with(other.disable_rule_comment);\n+        self.fix_violation.combine_with(other.fix_violation);\n+    }\n+}\n+\n+#[derive(Clone, Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(rename_all = \"camelCase\")]\n+struct CodeActionParameters {\n+    enable: Option<bool>,\n+}\n+\n+impl Combine for CodeActionParameters {\n+    fn combine_with(&mut self, other: Self) {\n+        self.enable.combine_with(other.enable);\n+    }\n+}\n+\n+/// This is the exact schema for initialization options sent in by the client\n+/// during initialization.\n+#[derive(Debug, Deserialize)]\n+#[cfg_attr(test, derive(PartialEq, Eq))]\n+#[serde(untagged)]\n+enum InitializationOptions {\n+    #[serde(rename_all = \"camelCase\")]\n+    HasWorkspaces {\n+        #[serde(rename = \"globalSettings\")]\n+        global: GlobalOptions,\n+        #[serde(rename = \"settings\")]\n+        workspace: Vec<WorkspaceOptions>,\n+    },\n+    GlobalOnly {\n+        #[serde(default)]\n+        settings: GlobalOptions,\n+    },\n+}\n+\n+impl Default for InitializationOptions {\n+    fn default() -> Self {\n+        Self::GlobalOnly {\n+            settings: GlobalOptions::default(),\n+        }\n+    }\n+}\n+\n+/// Built from the initialization options provided by the client.\n+#[derive(Debug)]\n+pub(crate) struct AllOptions {\n+    pub(crate) global: GlobalOptions,\n+    /// If this is `None`, the client only passed in global settings.\n+    pub(crate) workspace: Option<WorkspaceOptionsMap>,\n+}\n+\n+impl AllOptions {\n+    /// Initializes the controller from the serialized initialization options.\n+    /// This fails if `options` are not valid initialization options.\n+    pub(crate) fn from_value(options: serde_json::Value) -> Self {\n+        Self::from_init_options(\n+            serde_json::from_value(options)\n+                .map_err(|err| {\n+                    tracing::error!(\"Failed to deserialize initialization options: {err}. Falling back to default client settings...\");\n+                    show_err_msg!(\"Ruff received invalid client settings - falling back to default client settings.\");\n+                })\n+                .unwrap_or_default(),\n+        )\n+    }\n+\n+    /// Update the preview flag for both the global and all workspace settings.\n+    pub(crate) fn set_preview(&mut self, preview: bool) {\n+        self.global.set_preview(preview);\n+        if let Some(workspace_settings) = self.workspace.as_mut() {\n+            for settings in workspace_settings.values_mut() {\n+                settings.set_preview(preview);\n+            }\n+        }\n+    }\n+\n+    fn from_init_options(options: InitializationOptions) -> Self {\n+        let (global_settings, workspace_settings) = match options {\n+            InitializationOptions::GlobalOnly { settings } => (settings, None),\n+            InitializationOptions::HasWorkspaces {\n+                global: global_settings,\n+                workspace: workspace_settings,\n+            } => (global_settings, Some(workspace_settings)),\n+        };\n+\n+        Self {\n+            global: global_settings,\n+            workspace: workspace_settings.map(|workspace_settings| {\n+                workspace_settings\n+                    .into_iter()\n+                    .map(|settings| (settings.workspace, settings.options))\n+                    .collect()\n+            }),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum RuleSelectorKey {\n+    Select,\n+    ExtendSelect,\n+    Ignore,\n+}\n+\n+impl std::fmt::Display for RuleSelectorKey {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            RuleSelectorKey::Select => f.write_str(\"lint.select\"),\n+            RuleSelectorKey::ExtendSelect => f.write_str(\"lint.extendSelect\"),\n+            RuleSelectorKey::Ignore => f.write_str(\"lint.ignore\"),\n+        }\n+    }\n+}\n+\n+pub(crate) trait Combine {\n+    #[must_use]\n+    fn combine(mut self, other: Self) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.combine_with(other);\n+        self\n+    }\n+\n+    fn combine_with(&mut self, other: Self);\n+}",
        "comment_created_at": "2025-06-12T08:30:02+00:00",
        "comment_author": "dhruvmanila",
        "comment_body": "Yeah, there are two parts to settings resolution in the server:\r\n1. The server needs to pick the value from either the global or the workspace setting.\r\n2. Combine the options from different sources like inline configuration / configuration file and the editor settings\r\n\r\nIn (1), this split between the global and workspace mainly exists in VS Code and is one of the reason I want to move us away from this model and pull the settings for a workspace from the client directly so that the client gives us the final value that we need to use and the only thing we need to do is (2).\r\n\r\n> * The server was inconsistent about how to handle `.configuration`: Before, it tried to resolve the field from the workspace, but it fell back to the `configuration` field from the global settings if, e.g., the file didn't exist. Now, we'll use the `configuration` value from the workspace without falling back to the global settings `configuration` if the server fails to resolve the configuration. This seems more correct in my view (and consistent with how we handle configurations in other places)\r\n\r\nYeah, I agree.",
        "pr_file_module": null
      }
    ]
  }
]