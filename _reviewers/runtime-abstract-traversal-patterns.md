---
title: Abstract traversal patterns
description: When implementing algorithms that operate on complex data structures
  (trees, graphs, dominator structures), abstract the traversal mechanism from the
  operation performed at each node. Use visitor patterns or callbacks to separate
  concerns, making algorithms more maintainable and reusable.
repository: dotnet/runtime
label: Algorithms
language: C++
comments_count: 5
repository_stars: 16578
---

When implementing algorithms that operate on complex data structures (trees, graphs, dominator structures), abstract the traversal mechanism from the operation performed at each node. Use visitor patterns or callbacks to separate concerns, making algorithms more maintainable and reusable.

For example, instead of directly traversing a data structure and performing operations:

```cpp
// Tightly coupled approach
void ScaleLoopBlocks(BasicBlock* begBlk, BasicBlock* endBlk)
{
    for (BasicBlock* const curBlk : BasicBlockRangeList(begBlk, endBlk))
    {
        // Direct operations on curBlk mixed with traversal logic
        if (curBlk->hasProfileWeight()) continue;
        if (curBlk->isRunRarely()) continue;
        if (!m_reachabilitySets->GetDfsTree()->Contains(curBlk)) continue;
        
        // More operations...
    }
}
```

Abstract the traversal pattern to separate it from node operations:

```cpp
// Decoupled approach
void ScaleLoopBlocks(FlowGraphNaturalLoop* loop)
{
    loop->VisitLoopBlocks([&](BasicBlock* curBlk) -> BasicBlockVisit {
        if (curBlk->hasProfileWeight()) return BasicBlockVisit::Continue;
        if (curBlk->isRunRarely()) return BasicBlockVisit::Continue;
        
        // Operations on curBlk without traversal concerns
        
        return BasicBlockVisit::Continue;
    });
}
```

This approach offers several benefits:
1. Traversal logic is centralized and maintained in one place
2. Algorithm implementations become clearer and more focused
3. Traversal strategies can be optimized independently
4. Testing becomes easier with separated concerns
5. Reuse becomes natural for similar algorithms on the same structures


[
  {
    "discussion_id": "2115487628",
    "pr_number": 116120,
    "pr_file": "src/coreclr/jit/optimizer.cpp",
    "created_at": "2025-05-30T09:19:05+00:00",
    "commented_code": "//         64 -- double loop nesting\n//        512 -- triple loop nesting\n//\nvoid Compiler::optScaleLoopBlocks(BasicBlock* begBlk, BasicBlock* endBlk)\nvoid Compiler::optScaleLoopBlocks(FlowGraphNaturalLoop* loop)\n{\n    noway_assert(begBlk->bbNum <= endBlk->bbNum);\n    noway_assert(begBlk->isLoopHead());\n    noway_assert(m_reachabilitySets->CanReach(begBlk, endBlk));\n    noway_assert(!opts.MinOpts());\n\n#ifdef DEBUG\n    if (verbose)\n    {\n        printf(\"\\nMarking a loop from \" FMT_BB \" to \" FMT_BB, begBlk->bbNum, endBlk->bbNum);\n    }\n#endif\n\n    // Build list of back edges for block begBlk.\n    FlowEdge* backedgeList = nullptr;\n\n    for (BasicBlock* const predBlock : begBlk->PredBlocks())\n    {\n        // Is this a back edge?\n        if (predBlock->bbNum >= begBlk->bbNum)\n        {\n            backedgeList = new (this, CMK_FlowEdge) FlowEdge(predBlock, begBlk, backedgeList);\n\n#if MEASURE_BLOCK_SIZE\n            genFlowNodeCnt += 1;\n            genFlowNodeSize += sizeof(FlowEdge);\n#endif // MEASURE_BLOCK_SIZE\n        }\n    }\n\n    // At least one backedge must have been found (the one from endBlk).\n    noway_assert(backedgeList);\n\n    auto reportBlockWeight = [&](BasicBlock* blk, const char* message) {\n#ifdef DEBUG\n        if (verbose)\n        {\n            printf(\"\\n    \" FMT_BB \"(wt=\" FMT_WT \")%s\", blk->bbNum, blk->getBBWeight(this), message);\n        }\n#endif // DEBUG\n    };\n    loop->VisitLoopBlocks([&](BasicBlock* curBlk) -> BasicBlockVisit {\n        auto reportBlockWeight = [&](const char* message) {\n            DBEXEC(verbose,\n                   printf(\"\\n    \" FMT_BB \"(wt=\" FMT_WT \")%s\", curBlk->bbNum, curBlk->getBBWeight(this), message));\n        };\n\n    for (BasicBlock* const curBlk : BasicBlockRangeList(begBlk, endBlk))\n    {\n        // Don't change the block weight if it came from profile data.\n        if (curBlk->hasProfileWeight() && fgHaveProfileWeights())\n        {\n            reportBlockWeight(curBlk, \"; unchanged: has profile weight\");\n            continue;\n            reportBlockWeight(\"; unchanged: has profile weight\");\n            return BasicBlockVisit::Continue;\n        }\n\n        // Don't change the block weight if it's known to be rarely run.\n        if (curBlk->isRunRarely())\n        {\n            reportBlockWeight(curBlk, \"; unchanged: run rarely\");\n            continue;\n        }\n\n        // Don't change the block weight if it's unreachable.\n        if (!m_reachabilitySets->GetDfsTree()->Contains(curBlk))\n        {\n            reportBlockWeight(curBlk, \"; unchanged: unreachable\");\n            continue;\n            reportBlockWeight(\"; unchanged: run rarely\");\n            return BasicBlockVisit::Continue;\n        }\n\n        // For curBlk to be part of a loop that starts at begBlk, curBlk must be reachable from begBlk and\n        // (since this is a loop) begBlk must likewise be reachable from curBlk.\n        // If `curBlk` reaches any of the back edge blocks we set `reachable`.\n        // If `curBlk` dominates any of the back edge blocks we set `dominates`.\n        bool reachable = false;\n        bool dominates = false;\n\n        if (m_reachabilitySets->CanReach(curBlk, begBlk) && m_reachabilitySets->CanReach(begBlk, curBlk))\n        for (FlowEdge* const backEdge : loop->BackEdges())\n        {\n            // If `curBlk` reaches any of the back edge blocks we set `reachable`.\n            // If `curBlk` dominates any of the back edge blocks we set `dominates`.\n            bool reachable = false;\n            bool dominates = false;\n\n            for (FlowEdge* tmp = backedgeList; tmp != nullptr; tmp = tmp->getNextPredEdge())\n            {\n                BasicBlock* backedge = tmp->getSourceBlock();\n\n                reachable |= m_reachabilitySets->CanReach(curBlk, backedge);\n                dominates |= m_domTree->Dominates(curBlk, backedge);\n            BasicBlock* backEdgeSource = backEdge->getSourceBlock();\n\n                if (dominates && reachable)\n                {\n                    // No need to keep looking; we've already found all the info we need.\n                    break;\n                }\n            }\n            reachable |= m_reachabilitySets->CanReach(curBlk, backEdgeSource);",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2115487628",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116120,
        "pr_file": "src/coreclr/jit/optimizer.cpp",
        "discussion_id": "2115487628",
        "commented_code": "@@ -179,124 +177,69 @@ PhaseStatus Compiler::optSetBlockWeights()\n //         64 -- double loop nesting\n //        512 -- triple loop nesting\n //\n-void Compiler::optScaleLoopBlocks(BasicBlock* begBlk, BasicBlock* endBlk)\n+void Compiler::optScaleLoopBlocks(FlowGraphNaturalLoop* loop)\n {\n-    noway_assert(begBlk->bbNum <= endBlk->bbNum);\n-    noway_assert(begBlk->isLoopHead());\n-    noway_assert(m_reachabilitySets->CanReach(begBlk, endBlk));\n-    noway_assert(!opts.MinOpts());\n-\n-#ifdef DEBUG\n-    if (verbose)\n-    {\n-        printf(\"\\nMarking a loop from \" FMT_BB \" to \" FMT_BB, begBlk->bbNum, endBlk->bbNum);\n-    }\n-#endif\n-\n-    // Build list of back edges for block begBlk.\n-    FlowEdge* backedgeList = nullptr;\n-\n-    for (BasicBlock* const predBlock : begBlk->PredBlocks())\n-    {\n-        // Is this a back edge?\n-        if (predBlock->bbNum >= begBlk->bbNum)\n-        {\n-            backedgeList = new (this, CMK_FlowEdge) FlowEdge(predBlock, begBlk, backedgeList);\n-\n-#if MEASURE_BLOCK_SIZE\n-            genFlowNodeCnt += 1;\n-            genFlowNodeSize += sizeof(FlowEdge);\n-#endif // MEASURE_BLOCK_SIZE\n-        }\n-    }\n-\n-    // At least one backedge must have been found (the one from endBlk).\n-    noway_assert(backedgeList);\n-\n-    auto reportBlockWeight = [&](BasicBlock* blk, const char* message) {\n-#ifdef DEBUG\n-        if (verbose)\n-        {\n-            printf(\"\\n    \" FMT_BB \"(wt=\" FMT_WT \")%s\", blk->bbNum, blk->getBBWeight(this), message);\n-        }\n-#endif // DEBUG\n-    };\n+    loop->VisitLoopBlocks([&](BasicBlock* curBlk) -> BasicBlockVisit {\n+        auto reportBlockWeight = [&](const char* message) {\n+            DBEXEC(verbose,\n+                   printf(\"\\n    \" FMT_BB \"(wt=\" FMT_WT \")%s\", curBlk->bbNum, curBlk->getBBWeight(this), message));\n+        };\n \n-    for (BasicBlock* const curBlk : BasicBlockRangeList(begBlk, endBlk))\n-    {\n         // Don't change the block weight if it came from profile data.\n         if (curBlk->hasProfileWeight() && fgHaveProfileWeights())\n         {\n-            reportBlockWeight(curBlk, \"; unchanged: has profile weight\");\n-            continue;\n+            reportBlockWeight(\"; unchanged: has profile weight\");\n+            return BasicBlockVisit::Continue;\n         }\n \n         // Don't change the block weight if it's known to be rarely run.\n         if (curBlk->isRunRarely())\n         {\n-            reportBlockWeight(curBlk, \"; unchanged: run rarely\");\n-            continue;\n-        }\n-\n-        // Don't change the block weight if it's unreachable.\n-        if (!m_reachabilitySets->GetDfsTree()->Contains(curBlk))\n-        {\n-            reportBlockWeight(curBlk, \"; unchanged: unreachable\");\n-            continue;\n+            reportBlockWeight(\"; unchanged: run rarely\");\n+            return BasicBlockVisit::Continue;\n         }\n \n-        // For curBlk to be part of a loop that starts at begBlk, curBlk must be reachable from begBlk and\n-        // (since this is a loop) begBlk must likewise be reachable from curBlk.\n+        // If `curBlk` reaches any of the back edge blocks we set `reachable`.\n+        // If `curBlk` dominates any of the back edge blocks we set `dominates`.\n+        bool reachable = false;\n+        bool dominates = false;\n \n-        if (m_reachabilitySets->CanReach(curBlk, begBlk) && m_reachabilitySets->CanReach(begBlk, curBlk))\n+        for (FlowEdge* const backEdge : loop->BackEdges())\n         {\n-            // If `curBlk` reaches any of the back edge blocks we set `reachable`.\n-            // If `curBlk` dominates any of the back edge blocks we set `dominates`.\n-            bool reachable = false;\n-            bool dominates = false;\n-\n-            for (FlowEdge* tmp = backedgeList; tmp != nullptr; tmp = tmp->getNextPredEdge())\n-            {\n-                BasicBlock* backedge = tmp->getSourceBlock();\n-\n-                reachable |= m_reachabilitySets->CanReach(curBlk, backedge);\n-                dominates |= m_domTree->Dominates(curBlk, backedge);\n+            BasicBlock* backEdgeSource = backEdge->getSourceBlock();\n \n-                if (dominates && reachable)\n-                {\n-                    // No need to keep looking; we've already found all the info we need.\n-                    break;\n-                }\n-            }\n+            reachable |= m_reachabilitySets->CanReach(curBlk, backEdgeSource);",
        "comment_created_at": "2025-05-30T09:19:05+00:00",
        "comment_author": "jakobbotsch",
        "comment_body": "I'm curious what the diffs are if you consider `reachable` here to be always true?\r\n\r\nAll loop blocks can reach all other loop blocks, so conceptually this would always be true... Except that reachability sets do not consider EH flow, so there is still going to be a small difference.",
        "pr_file_module": null
      },
      {
        "comment_id": "2116473984",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116120,
        "pr_file": "src/coreclr/jit/optimizer.cpp",
        "discussion_id": "2115487628",
        "commented_code": "@@ -179,124 +177,69 @@ PhaseStatus Compiler::optSetBlockWeights()\n //         64 -- double loop nesting\n //        512 -- triple loop nesting\n //\n-void Compiler::optScaleLoopBlocks(BasicBlock* begBlk, BasicBlock* endBlk)\n+void Compiler::optScaleLoopBlocks(FlowGraphNaturalLoop* loop)\n {\n-    noway_assert(begBlk->bbNum <= endBlk->bbNum);\n-    noway_assert(begBlk->isLoopHead());\n-    noway_assert(m_reachabilitySets->CanReach(begBlk, endBlk));\n-    noway_assert(!opts.MinOpts());\n-\n-#ifdef DEBUG\n-    if (verbose)\n-    {\n-        printf(\"\\nMarking a loop from \" FMT_BB \" to \" FMT_BB, begBlk->bbNum, endBlk->bbNum);\n-    }\n-#endif\n-\n-    // Build list of back edges for block begBlk.\n-    FlowEdge* backedgeList = nullptr;\n-\n-    for (BasicBlock* const predBlock : begBlk->PredBlocks())\n-    {\n-        // Is this a back edge?\n-        if (predBlock->bbNum >= begBlk->bbNum)\n-        {\n-            backedgeList = new (this, CMK_FlowEdge) FlowEdge(predBlock, begBlk, backedgeList);\n-\n-#if MEASURE_BLOCK_SIZE\n-            genFlowNodeCnt += 1;\n-            genFlowNodeSize += sizeof(FlowEdge);\n-#endif // MEASURE_BLOCK_SIZE\n-        }\n-    }\n-\n-    // At least one backedge must have been found (the one from endBlk).\n-    noway_assert(backedgeList);\n-\n-    auto reportBlockWeight = [&](BasicBlock* blk, const char* message) {\n-#ifdef DEBUG\n-        if (verbose)\n-        {\n-            printf(\"\\n    \" FMT_BB \"(wt=\" FMT_WT \")%s\", blk->bbNum, blk->getBBWeight(this), message);\n-        }\n-#endif // DEBUG\n-    };\n+    loop->VisitLoopBlocks([&](BasicBlock* curBlk) -> BasicBlockVisit {\n+        auto reportBlockWeight = [&](const char* message) {\n+            DBEXEC(verbose,\n+                   printf(\"\\n    \" FMT_BB \"(wt=\" FMT_WT \")%s\", curBlk->bbNum, curBlk->getBBWeight(this), message));\n+        };\n \n-    for (BasicBlock* const curBlk : BasicBlockRangeList(begBlk, endBlk))\n-    {\n         // Don't change the block weight if it came from profile data.\n         if (curBlk->hasProfileWeight() && fgHaveProfileWeights())\n         {\n-            reportBlockWeight(curBlk, \"; unchanged: has profile weight\");\n-            continue;\n+            reportBlockWeight(\"; unchanged: has profile weight\");\n+            return BasicBlockVisit::Continue;\n         }\n \n         // Don't change the block weight if it's known to be rarely run.\n         if (curBlk->isRunRarely())\n         {\n-            reportBlockWeight(curBlk, \"; unchanged: run rarely\");\n-            continue;\n-        }\n-\n-        // Don't change the block weight if it's unreachable.\n-        if (!m_reachabilitySets->GetDfsTree()->Contains(curBlk))\n-        {\n-            reportBlockWeight(curBlk, \"; unchanged: unreachable\");\n-            continue;\n+            reportBlockWeight(\"; unchanged: run rarely\");\n+            return BasicBlockVisit::Continue;\n         }\n \n-        // For curBlk to be part of a loop that starts at begBlk, curBlk must be reachable from begBlk and\n-        // (since this is a loop) begBlk must likewise be reachable from curBlk.\n+        // If `curBlk` reaches any of the back edge blocks we set `reachable`.\n+        // If `curBlk` dominates any of the back edge blocks we set `dominates`.\n+        bool reachable = false;\n+        bool dominates = false;\n \n-        if (m_reachabilitySets->CanReach(curBlk, begBlk) && m_reachabilitySets->CanReach(begBlk, curBlk))\n+        for (FlowEdge* const backEdge : loop->BackEdges())\n         {\n-            // If `curBlk` reaches any of the back edge blocks we set `reachable`.\n-            // If `curBlk` dominates any of the back edge blocks we set `dominates`.\n-            bool reachable = false;\n-            bool dominates = false;\n-\n-            for (FlowEdge* tmp = backedgeList; tmp != nullptr; tmp = tmp->getNextPredEdge())\n-            {\n-                BasicBlock* backedge = tmp->getSourceBlock();\n-\n-                reachable |= m_reachabilitySets->CanReach(curBlk, backedge);\n-                dominates |= m_domTree->Dominates(curBlk, backedge);\n+            BasicBlock* backEdgeSource = backEdge->getSourceBlock();\n \n-                if (dominates && reachable)\n-                {\n-                    // No need to keep looking; we've already found all the info we need.\n-                    break;\n-                }\n-            }\n+            reachable |= m_reachabilitySets->CanReach(curBlk, backEdgeSource);",
        "comment_created_at": "2025-05-30T18:57:17+00:00",
        "comment_author": "amanasifkhalid",
        "comment_body": "Right, I initially avoided this change to minimize the first round of diffs, but the diffs against this PR are small enough that we might as well include them here:\r\n\r\nDiffs are based on <span style=\"color:#1460aa\">2,723,124</span> contexts (<span style=\"color:#1460aa\">1,064,836</span> MinOpts, <span style=\"color:#1460aa\">1,658,288</span> FullOpts).\r\n\r\n<span style=\"color:#d35400\">MISSED</span> contexts: <span style=\"color:#d35400\">166 (0.01%)</span>\r\n\r\n\r\n<details>\r\n<summary>Overall (<span style=\"color:green\">-310</span> bytes)</summary>\r\n<div style=\"margin-left:1em\">\r\n\r\n|Collection|Base size (bytes)|Diff size (bytes)|PerfScore in Diffs\r\n|---|--:|--:|--:|\r\n|benchmarks.run.windows.x64.checked.mch|12,261,026|<span style=\"color:green\">-40</span>|<span style=\"color:red\">+13.36%</span>|\r\n|benchmarks.run_pgo_optrepeat.windows.x64.checked.mch|11,699,861|<span style=\"color:green\">-25</span>|<span style=\"color:red\">+12.94%</span>|\r\n|coreclr_tests.run.windows.x64.checked.mch|418,321,055|<span style=\"color:green\">-105</span>|<span style=\"color:red\">+90.25%</span>|\r\n|libraries.crossgen2.windows.x64.checked.mch|38,561,432|<span style=\"color:red\">+26</span>|<span style=\"color:red\">+137.62%</span>|\r\n|libraries.pmi.windows.x64.checked.mch|58,333,813|<span style=\"color:green\">-133</span>|<span style=\"color:red\">+180.81%</span>|\r\n|libraries_tests_no_tiered_compilation.run.windows.x64.Release.mch|155,319,820|<span style=\"color:green\">-46</span>|<span style=\"color:red\">+203.67%</span>|\r\n|realworld.run.windows.x64.checked.mch|11,730,662|<span style=\"color:red\">+14</span>|<span style=\"color:red\">+15.73%</span>|\r\n|smoke_tests.nativeaot.windows.x64.checked.mch|5,067,801|<span style=\"color:green\">-1</span>|<span style=\"color:red\">+25.14%</span>|\r\n\r\n\r\n</div></details>\r\n\r\n<details>\r\n<summary>FullOpts (<span style=\"color:green\">-310</span> bytes)</summary>\r\n<div style=\"margin-left:1em\">\r\n\r\n|Collection|Base size (bytes)|Diff size (bytes)|PerfScore in Diffs\r\n|---|--:|--:|--:|\r\n|benchmarks.run.windows.x64.checked.mch|12,260,324|<span style=\"color:green\">-40</span>|<span style=\"color:red\">+13.36%</span>|\r\n|benchmarks.run_pgo_optrepeat.windows.x64.checked.mch|11,699,183|<span style=\"color:green\">-25</span>|<span style=\"color:red\">+12.94%</span>|\r\n|coreclr_tests.run.windows.x64.checked.mch|129,087,953|<span style=\"color:green\">-105</span>|<span style=\"color:red\">+90.25%</span>|\r\n|libraries.crossgen2.windows.x64.checked.mch|38,559,781|<span style=\"color:red\">+26</span>|<span style=\"color:red\">+137.62%</span>|\r\n|libraries.pmi.windows.x64.checked.mch|58,221,028|<span style=\"color:green\">-133</span>|<span style=\"color:red\">+180.81%</span>|\r\n|libraries_tests_no_tiered_compilation.run.windows.x64.Release.mch|144,273,582|<span style=\"color:green\">-46</span>|<span style=\"color:red\">+203.67%</span>|\r\n|realworld.run.windows.x64.checked.mch|11,505,783|<span style=\"color:red\">+14</span>|<span style=\"color:red\">+15.73%</span>|\r\n|smoke_tests.nativeaot.windows.x64.checked.mch|5,066,658|<span style=\"color:green\">-1</span>|<span style=\"color:red\">+25.14%</span>|\r\n\r\n\r\n</div></details>\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1835106150",
    "pr_number": 109656,
    "pr_file": "src/coreclr/jit/flowgraph.cpp",
    "created_at": "2024-11-08T22:10:20+00:00",
    "commented_code": "}\n#endif\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::IntersectPostdom:\n//   Find common IPDom parent, much like least common ancestor.\n//\n// Parameters:\n//   finger1 - A basic block that might share IPDom ancestor with finger2.\n//   finger2 - A basic block that might share IPDom ancestor with finger1.\n//\n// Returns:\n//   A basic block whose IPDom is the postdominator for finger1 and finger2, or else\n//   nullptr. This may be called while immediate postdominators are being computed,\n//   and if the input values are members of the same loop (each reachable from\n//   the other), then one may not yet have its immediate postdominator computed\n//   when we are attempting to find the immediate postdominator of the other. So a\n//   nullptr return value means that the the two inputs are in a cycle, not\n//   that they don't have a common postdominator ancestor.\n//\n// Remarks:\n//   See \"A simple, fast dominance algorithm\" by Keith D. Cooper, Timothy J.\n//   Harvey, Ken Kennedy.\n//\nBasicBlock* FlowGraphPostDominatorTree::IntersectPostdom(BasicBlock* finger1, BasicBlock* finger2)\n{\n    while (finger1 != finger2)\n    {\n        if ((finger1 == nullptr) || (finger2 == nullptr))\n        {\n            return nullptr;\n        }\n        while ((finger1 != nullptr) && (finger1->bbReversePostorderNum < finger2->bbReversePostorderNum))\n        {\n            finger1 = finger1->bbIPDom;\n        }\n        if (finger1 == nullptr)\n        {\n            return nullptr;\n        }\n        while ((finger2 != nullptr) && (finger2->bbReversePostorderNum < finger1->bbReversePostorderNum))\n        {\n            finger2 = finger2->bbIPDom;\n        }\n    }\n    return finger1;\n}\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::Intersect:\n//   See FlowGraphPostominatorTree::IntersectPostdom\n//\nBasicBlock* FlowGraphPostDominatorTree::Intersect(BasicBlock* block1, BasicBlock* block2)\n{\n    return IntersectPostdom(block1, block2);\n}\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::PostDominates:\n//   Check if node \"postDominator\" is an ancestor of node \"postDominated\".\n//\n// Parameters:\n//   postDominator - Node that may postdominate\n//   postDominated - Node that may be postdominated\n//\n// Returns:\n//   True \"postDominator\" postdominates \"postDominated\".\n//\nbool FlowGraphPostDominatorTree::PostDominates(BasicBlock* postDominator, BasicBlock* postDominated)\n{\n    assert(m_reverseDfsTree->Contains(postDominator) && m_reverseDfsTree->Contains(postDominated));\n\n    // What we want to ask here is basically if A is in the middle of the path\n    // from B to the root (the entry node) in the postdominator tree. Turns out\n    // that can be translated as:\n    //\n    //   A dom B <-> preorder(A) <= preorder(B) && postorder(A) >= postorder(B)\n    //\n    // where the equality holds when you ask if A postdominates itself.\n    //\n    return (m_preorderNum[postDominator->bbReversePostorderNum] <=\n            m_preorderNum[postDominated->bbReversePostorderNum]) &&\n           (m_postorderNum[postDominator->bbReversePostorderNum] >=\n            m_postorderNum[postDominated->bbReversePostorderNum]);\n}\n\n#ifdef DEBUG\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::Dump: Dump a textual representation of the postdominator\n// tree.\n//\nvoid FlowGraphPostDominatorTree::Dump()\n{\n    Compiler* comp = m_reverseDfsTree->GetCompiler();\n\n    for (BasicBlock* block : comp->Blocks())\n    {\n        if (!m_reverseDfsTree->Contains(block) || (m_domTree[block->bbReversePostorderNum].firstChild == nullptr))\n            continue;\n\n        printf(FMT_BB \" : \", block->bbNum);\n        for (BasicBlock* child = m_domTree[block->bbReversePostorderNum].firstChild; child != nullptr;\n             child             = m_domTree[child->bbReversePostorderNum].nextSibling)\n        {\n            printf(FMT_BB \" \", child->bbNum);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n}\n#endif\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::Build: Compute the dominator tree for the blocks in\n// the DFS tree.\n//\n// Parameters:\n//   reverseDfsTree - reverse DFS tree.\n//\n// Returns:\n//   Data structure representing postdominator tree. Immediate postdominators are\n//   marked directly into the BasicBlock structures, in the bbIPDom field, so\n//   multiple instances cannot be simultaneously used.\n//\n// Remarks:\n//   As a precondition it is required that the reverse flow graph has a unique root.\n//   This is handled by the reverse DFS tree via its pseudo block.\n//\nFlowGraphPostDominatorTree* FlowGraphPostDominatorTree::Build(const FlowGraphReverseDfsTree* reverseDfsTree)\n{\n    Compiler*         comp       = reverseDfsTree->GetCompiler();\n    BasicBlock**      postOrder  = reverseDfsTree->GetPostOrder();\n    unsigned          count      = reverseDfsTree->GetPostOrderCount();\n    BasicBlock* const pseudoExit = reverseDfsTree->PseudoExit();\n\n    pseudoExit->bbIPDom = nullptr;\n\n    // First compute immediate postdominators.\n    unsigned numIters = 0;\n    bool     changed  = true;\n    while (changed)\n    {\n        changed = false;\n\n        // In reverse post order, except for the entry block (count - 1 is entry BB).\n        for (unsigned i = count - 1; i > 0; i--)\n        {\n            unsigned    poNum = i - 1;\n            BasicBlock* block = postOrder[poNum];\n\n            // Intersect Postdom, if computed, for all successors\n            BasicBlock* bbIPDom = nullptr;\n\n            auto visitSucc = [=, &bbIPDom](BasicBlock* succ) {\n                if (!reverseDfsTree->Contains(succ))\n                {\n                    // Unreachable succ...?\n                    return;\n                }\n\n                if ((numIters <= 0) && (succ->bbReversePostorderNum <= poNum))",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "1835106150",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 109656,
        "pr_file": "src/coreclr/jit/flowgraph.cpp",
        "discussion_id": "1835106150",
        "commented_code": "@@ -6787,6 +6894,398 @@ void FlowGraphDominanceFrontiers::Dump()\n }\n #endif\n \n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::IntersectPostdom:\n+//   Find common IPDom parent, much like least common ancestor.\n+//\n+// Parameters:\n+//   finger1 - A basic block that might share IPDom ancestor with finger2.\n+//   finger2 - A basic block that might share IPDom ancestor with finger1.\n+//\n+// Returns:\n+//   A basic block whose IPDom is the postdominator for finger1 and finger2, or else\n+//   nullptr. This may be called while immediate postdominators are being computed,\n+//   and if the input values are members of the same loop (each reachable from\n+//   the other), then one may not yet have its immediate postdominator computed\n+//   when we are attempting to find the immediate postdominator of the other. So a\n+//   nullptr return value means that the the two inputs are in a cycle, not\n+//   that they don't have a common postdominator ancestor.\n+//\n+// Remarks:\n+//   See \"A simple, fast dominance algorithm\" by Keith D. Cooper, Timothy J.\n+//   Harvey, Ken Kennedy.\n+//\n+BasicBlock* FlowGraphPostDominatorTree::IntersectPostdom(BasicBlock* finger1, BasicBlock* finger2)\n+{\n+    while (finger1 != finger2)\n+    {\n+        if ((finger1 == nullptr) || (finger2 == nullptr))\n+        {\n+            return nullptr;\n+        }\n+        while ((finger1 != nullptr) && (finger1->bbReversePostorderNum < finger2->bbReversePostorderNum))\n+        {\n+            finger1 = finger1->bbIPDom;\n+        }\n+        if (finger1 == nullptr)\n+        {\n+            return nullptr;\n+        }\n+        while ((finger2 != nullptr) && (finger2->bbReversePostorderNum < finger1->bbReversePostorderNum))\n+        {\n+            finger2 = finger2->bbIPDom;\n+        }\n+    }\n+    return finger1;\n+}\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Intersect:\n+//   See FlowGraphPostominatorTree::IntersectPostdom\n+//\n+BasicBlock* FlowGraphPostDominatorTree::Intersect(BasicBlock* block1, BasicBlock* block2)\n+{\n+    return IntersectPostdom(block1, block2);\n+}\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::PostDominates:\n+//   Check if node \"postDominator\" is an ancestor of node \"postDominated\".\n+//\n+// Parameters:\n+//   postDominator - Node that may postdominate\n+//   postDominated - Node that may be postdominated\n+//\n+// Returns:\n+//   True \"postDominator\" postdominates \"postDominated\".\n+//\n+bool FlowGraphPostDominatorTree::PostDominates(BasicBlock* postDominator, BasicBlock* postDominated)\n+{\n+    assert(m_reverseDfsTree->Contains(postDominator) && m_reverseDfsTree->Contains(postDominated));\n+\n+    // What we want to ask here is basically if A is in the middle of the path\n+    // from B to the root (the entry node) in the postdominator tree. Turns out\n+    // that can be translated as:\n+    //\n+    //   A dom B <-> preorder(A) <= preorder(B) && postorder(A) >= postorder(B)\n+    //\n+    // where the equality holds when you ask if A postdominates itself.\n+    //\n+    return (m_preorderNum[postDominator->bbReversePostorderNum] <=\n+            m_preorderNum[postDominated->bbReversePostorderNum]) &&\n+           (m_postorderNum[postDominator->bbReversePostorderNum] >=\n+            m_postorderNum[postDominated->bbReversePostorderNum]);\n+}\n+\n+#ifdef DEBUG\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Dump: Dump a textual representation of the postdominator\n+// tree.\n+//\n+void FlowGraphPostDominatorTree::Dump()\n+{\n+    Compiler* comp = m_reverseDfsTree->GetCompiler();\n+\n+    for (BasicBlock* block : comp->Blocks())\n+    {\n+        if (!m_reverseDfsTree->Contains(block) || (m_domTree[block->bbReversePostorderNum].firstChild == nullptr))\n+            continue;\n+\n+        printf(FMT_BB \" : \", block->bbNum);\n+        for (BasicBlock* child = m_domTree[block->bbReversePostorderNum].firstChild; child != nullptr;\n+             child             = m_domTree[child->bbReversePostorderNum].nextSibling)\n+        {\n+            printf(FMT_BB \" \", child->bbNum);\n+        }\n+        printf(\"\\n\");\n+    }\n+\n+    printf(\"\\n\");\n+}\n+#endif\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Build: Compute the dominator tree for the blocks in\n+// the DFS tree.\n+//\n+// Parameters:\n+//   reverseDfsTree - reverse DFS tree.\n+//\n+// Returns:\n+//   Data structure representing postdominator tree. Immediate postdominators are\n+//   marked directly into the BasicBlock structures, in the bbIPDom field, so\n+//   multiple instances cannot be simultaneously used.\n+//\n+// Remarks:\n+//   As a precondition it is required that the reverse flow graph has a unique root.\n+//   This is handled by the reverse DFS tree via its pseudo block.\n+//\n+FlowGraphPostDominatorTree* FlowGraphPostDominatorTree::Build(const FlowGraphReverseDfsTree* reverseDfsTree)\n+{\n+    Compiler*         comp       = reverseDfsTree->GetCompiler();\n+    BasicBlock**      postOrder  = reverseDfsTree->GetPostOrder();\n+    unsigned          count      = reverseDfsTree->GetPostOrderCount();\n+    BasicBlock* const pseudoExit = reverseDfsTree->PseudoExit();\n+\n+    pseudoExit->bbIPDom = nullptr;\n+\n+    // First compute immediate postdominators.\n+    unsigned numIters = 0;\n+    bool     changed  = true;\n+    while (changed)\n+    {\n+        changed = false;\n+\n+        // In reverse post order, except for the entry block (count - 1 is entry BB).\n+        for (unsigned i = count - 1; i > 0; i--)\n+        {\n+            unsigned    poNum = i - 1;\n+            BasicBlock* block = postOrder[poNum];\n+\n+            // Intersect Postdom, if computed, for all successors\n+            BasicBlock* bbIPDom = nullptr;\n+\n+            auto visitSucc = [=, &bbIPDom](BasicBlock* succ) {\n+                if (!reverseDfsTree->Contains(succ))\n+                {\n+                    // Unreachable succ...?\n+                    return;\n+                }\n+\n+                if ((numIters <= 0) && (succ->bbReversePostorderNum <= poNum))",
        "comment_created_at": "2024-11-08T22:10:20+00:00",
        "comment_author": "kunalspathak",
        "comment_body": "I did not understand the meaning of check `numIters <= 0`. It is unsigned, so it will be `>= 0`. Perhaps this should be `numIters == 0`? I see similar thing in `FlowGraphDominatorTree::Build` too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1835169207",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 109656,
        "pr_file": "src/coreclr/jit/flowgraph.cpp",
        "discussion_id": "1835106150",
        "commented_code": "@@ -6787,6 +6894,398 @@ void FlowGraphDominanceFrontiers::Dump()\n }\n #endif\n \n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::IntersectPostdom:\n+//   Find common IPDom parent, much like least common ancestor.\n+//\n+// Parameters:\n+//   finger1 - A basic block that might share IPDom ancestor with finger2.\n+//   finger2 - A basic block that might share IPDom ancestor with finger1.\n+//\n+// Returns:\n+//   A basic block whose IPDom is the postdominator for finger1 and finger2, or else\n+//   nullptr. This may be called while immediate postdominators are being computed,\n+//   and if the input values are members of the same loop (each reachable from\n+//   the other), then one may not yet have its immediate postdominator computed\n+//   when we are attempting to find the immediate postdominator of the other. So a\n+//   nullptr return value means that the the two inputs are in a cycle, not\n+//   that they don't have a common postdominator ancestor.\n+//\n+// Remarks:\n+//   See \"A simple, fast dominance algorithm\" by Keith D. Cooper, Timothy J.\n+//   Harvey, Ken Kennedy.\n+//\n+BasicBlock* FlowGraphPostDominatorTree::IntersectPostdom(BasicBlock* finger1, BasicBlock* finger2)\n+{\n+    while (finger1 != finger2)\n+    {\n+        if ((finger1 == nullptr) || (finger2 == nullptr))\n+        {\n+            return nullptr;\n+        }\n+        while ((finger1 != nullptr) && (finger1->bbReversePostorderNum < finger2->bbReversePostorderNum))\n+        {\n+            finger1 = finger1->bbIPDom;\n+        }\n+        if (finger1 == nullptr)\n+        {\n+            return nullptr;\n+        }\n+        while ((finger2 != nullptr) && (finger2->bbReversePostorderNum < finger1->bbReversePostorderNum))\n+        {\n+            finger2 = finger2->bbIPDom;\n+        }\n+    }\n+    return finger1;\n+}\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Intersect:\n+//   See FlowGraphPostominatorTree::IntersectPostdom\n+//\n+BasicBlock* FlowGraphPostDominatorTree::Intersect(BasicBlock* block1, BasicBlock* block2)\n+{\n+    return IntersectPostdom(block1, block2);\n+}\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::PostDominates:\n+//   Check if node \"postDominator\" is an ancestor of node \"postDominated\".\n+//\n+// Parameters:\n+//   postDominator - Node that may postdominate\n+//   postDominated - Node that may be postdominated\n+//\n+// Returns:\n+//   True \"postDominator\" postdominates \"postDominated\".\n+//\n+bool FlowGraphPostDominatorTree::PostDominates(BasicBlock* postDominator, BasicBlock* postDominated)\n+{\n+    assert(m_reverseDfsTree->Contains(postDominator) && m_reverseDfsTree->Contains(postDominated));\n+\n+    // What we want to ask here is basically if A is in the middle of the path\n+    // from B to the root (the entry node) in the postdominator tree. Turns out\n+    // that can be translated as:\n+    //\n+    //   A dom B <-> preorder(A) <= preorder(B) && postorder(A) >= postorder(B)\n+    //\n+    // where the equality holds when you ask if A postdominates itself.\n+    //\n+    return (m_preorderNum[postDominator->bbReversePostorderNum] <=\n+            m_preorderNum[postDominated->bbReversePostorderNum]) &&\n+           (m_postorderNum[postDominator->bbReversePostorderNum] >=\n+            m_postorderNum[postDominated->bbReversePostorderNum]);\n+}\n+\n+#ifdef DEBUG\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Dump: Dump a textual representation of the postdominator\n+// tree.\n+//\n+void FlowGraphPostDominatorTree::Dump()\n+{\n+    Compiler* comp = m_reverseDfsTree->GetCompiler();\n+\n+    for (BasicBlock* block : comp->Blocks())\n+    {\n+        if (!m_reverseDfsTree->Contains(block) || (m_domTree[block->bbReversePostorderNum].firstChild == nullptr))\n+            continue;\n+\n+        printf(FMT_BB \" : \", block->bbNum);\n+        for (BasicBlock* child = m_domTree[block->bbReversePostorderNum].firstChild; child != nullptr;\n+             child             = m_domTree[child->bbReversePostorderNum].nextSibling)\n+        {\n+            printf(FMT_BB \" \", child->bbNum);\n+        }\n+        printf(\"\\n\");\n+    }\n+\n+    printf(\"\\n\");\n+}\n+#endif\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Build: Compute the dominator tree for the blocks in\n+// the DFS tree.\n+//\n+// Parameters:\n+//   reverseDfsTree - reverse DFS tree.\n+//\n+// Returns:\n+//   Data structure representing postdominator tree. Immediate postdominators are\n+//   marked directly into the BasicBlock structures, in the bbIPDom field, so\n+//   multiple instances cannot be simultaneously used.\n+//\n+// Remarks:\n+//   As a precondition it is required that the reverse flow graph has a unique root.\n+//   This is handled by the reverse DFS tree via its pseudo block.\n+//\n+FlowGraphPostDominatorTree* FlowGraphPostDominatorTree::Build(const FlowGraphReverseDfsTree* reverseDfsTree)\n+{\n+    Compiler*         comp       = reverseDfsTree->GetCompiler();\n+    BasicBlock**      postOrder  = reverseDfsTree->GetPostOrder();\n+    unsigned          count      = reverseDfsTree->GetPostOrderCount();\n+    BasicBlock* const pseudoExit = reverseDfsTree->PseudoExit();\n+\n+    pseudoExit->bbIPDom = nullptr;\n+\n+    // First compute immediate postdominators.\n+    unsigned numIters = 0;\n+    bool     changed  = true;\n+    while (changed)\n+    {\n+        changed = false;\n+\n+        // In reverse post order, except for the entry block (count - 1 is entry BB).\n+        for (unsigned i = count - 1; i > 0; i--)\n+        {\n+            unsigned    poNum = i - 1;\n+            BasicBlock* block = postOrder[poNum];\n+\n+            // Intersect Postdom, if computed, for all successors\n+            BasicBlock* bbIPDom = nullptr;\n+\n+            auto visitSucc = [=, &bbIPDom](BasicBlock* succ) {\n+                if (!reverseDfsTree->Contains(succ))\n+                {\n+                    // Unreachable succ...?\n+                    return;\n+                }\n+\n+                if ((numIters <= 0) && (succ->bbReversePostorderNum <= poNum))",
        "comment_created_at": "2024-11-09T00:10:00+00:00",
        "comment_author": "jakobbotsch",
        "comment_body": "Yes, they are equivalent (I for some reason usually write this check in this way)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1835169433",
    "pr_number": 109656,
    "pr_file": "src/coreclr/jit/flowgraph.cpp",
    "created_at": "2024-11-09T00:10:37+00:00",
    "commented_code": "}\n#endif\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::IntersectPostdom:\n//   Find common IPDom parent, much like least common ancestor.\n//\n// Parameters:\n//   finger1 - A basic block that might share IPDom ancestor with finger2.\n//   finger2 - A basic block that might share IPDom ancestor with finger1.\n//\n// Returns:\n//   A basic block whose IPDom is the postdominator for finger1 and finger2, or else\n//   nullptr. This may be called while immediate postdominators are being computed,\n//   and if the input values are members of the same loop (each reachable from\n//   the other), then one may not yet have its immediate postdominator computed\n//   when we are attempting to find the immediate postdominator of the other. So a\n//   nullptr return value means that the the two inputs are in a cycle, not\n//   that they don't have a common postdominator ancestor.\n//\n// Remarks:\n//   See \"A simple, fast dominance algorithm\" by Keith D. Cooper, Timothy J.\n//   Harvey, Ken Kennedy.\n//\nBasicBlock* FlowGraphPostDominatorTree::IntersectPostdom(BasicBlock* finger1, BasicBlock* finger2)\n{\n    while (finger1 != finger2)\n    {\n        if ((finger1 == nullptr) || (finger2 == nullptr))\n        {\n            return nullptr;\n        }\n        while ((finger1 != nullptr) && (finger1->bbReversePostorderNum < finger2->bbReversePostorderNum))\n        {\n            finger1 = finger1->bbIPDom;\n        }\n        if (finger1 == nullptr)\n        {\n            return nullptr;\n        }\n        while ((finger2 != nullptr) && (finger2->bbReversePostorderNum < finger1->bbReversePostorderNum))\n        {\n            finger2 = finger2->bbIPDom;\n        }\n    }\n    return finger1;\n}\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::Intersect:\n//   See FlowGraphPostominatorTree::IntersectPostdom\n//\nBasicBlock* FlowGraphPostDominatorTree::Intersect(BasicBlock* block1, BasicBlock* block2)\n{\n    return IntersectPostdom(block1, block2);\n}\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::PostDominates:\n//   Check if node \"postDominator\" is an ancestor of node \"postDominated\".\n//\n// Parameters:\n//   postDominator - Node that may postdominate\n//   postDominated - Node that may be postdominated\n//\n// Returns:\n//   True \"postDominator\" postdominates \"postDominated\".\n//\nbool FlowGraphPostDominatorTree::PostDominates(BasicBlock* postDominator, BasicBlock* postDominated)\n{\n    assert(m_reverseDfsTree->Contains(postDominator) && m_reverseDfsTree->Contains(postDominated));\n\n    // What we want to ask here is basically if A is in the middle of the path\n    // from B to the root (the entry node) in the postdominator tree. Turns out\n    // that can be translated as:\n    //\n    //   A dom B <-> preorder(A) <= preorder(B) && postorder(A) >= postorder(B)\n    //\n    // where the equality holds when you ask if A postdominates itself.\n    //\n    return (m_preorderNum[postDominator->bbReversePostorderNum] <=\n            m_preorderNum[postDominated->bbReversePostorderNum]) &&\n           (m_postorderNum[postDominator->bbReversePostorderNum] >=\n            m_postorderNum[postDominated->bbReversePostorderNum]);\n}\n\n#ifdef DEBUG\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::Dump: Dump a textual representation of the postdominator\n// tree.\n//\nvoid FlowGraphPostDominatorTree::Dump()\n{\n    Compiler* comp = m_reverseDfsTree->GetCompiler();\n\n    for (BasicBlock* block : comp->Blocks())\n    {\n        if (!m_reverseDfsTree->Contains(block) || (m_domTree[block->bbReversePostorderNum].firstChild == nullptr))\n            continue;\n\n        printf(FMT_BB \" : \", block->bbNum);\n        for (BasicBlock* child = m_domTree[block->bbReversePostorderNum].firstChild; child != nullptr;\n             child             = m_domTree[child->bbReversePostorderNum].nextSibling)\n        {\n            printf(FMT_BB \" \", child->bbNum);\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"\\n\");\n}\n#endif\n\n//------------------------------------------------------------------------\n// FlowGraphPostDominatorTree::Build: Compute the dominator tree for the blocks in\n// the DFS tree.\n//\n// Parameters:\n//   reverseDfsTree - reverse DFS tree.\n//\n// Returns:\n//   Data structure representing postdominator tree. Immediate postdominators are\n//   marked directly into the BasicBlock structures, in the bbIPDom field, so\n//   multiple instances cannot be simultaneously used.\n//\n// Remarks:\n//   As a precondition it is required that the reverse flow graph has a unique root.\n//   This is handled by the reverse DFS tree via its pseudo block.\n//\nFlowGraphPostDominatorTree* FlowGraphPostDominatorTree::Build(const FlowGraphReverseDfsTree* reverseDfsTree)\n{\n    Compiler*         comp       = reverseDfsTree->GetCompiler();\n    BasicBlock**      postOrder  = reverseDfsTree->GetPostOrder();\n    unsigned          count      = reverseDfsTree->GetPostOrderCount();\n    BasicBlock* const pseudoExit = reverseDfsTree->PseudoExit();\n\n    pseudoExit->bbIPDom = nullptr;\n\n    // First compute immediate postdominators.\n    unsigned numIters = 0;\n    bool     changed  = true;\n    while (changed)\n    {\n        changed = false;\n\n        // In reverse post order, except for the entry block (count - 1 is entry BB).\n        for (unsigned i = count - 1; i > 0; i--)\n        {\n            unsigned    poNum = i - 1;\n            BasicBlock* block = postOrder[poNum];\n\n            // Intersect Postdom, if computed, for all successors\n            BasicBlock* bbIPDom = nullptr;\n\n            auto visitSucc = [=, &bbIPDom](BasicBlock* succ) {\n                if (!reverseDfsTree->Contains(succ))\n                {\n                    // Unreachable succ...?\n                    return;\n                }\n\n                if ((numIters <= 0) && (succ->bbReversePostorderNum <= poNum))\n                {\n                    return;\n                }\n\n                if (bbIPDom == nullptr)\n                {\n                    bbIPDom = succ;\n                }\n                else\n                {\n                    bbIPDom = IntersectPostdom(bbIPDom, succ);\n                }\n            };\n\n            // Look for flow graph exit points. These have the pseudo exit as successor.\n            // Hopefully the set is small and the pred search is cheap.\n            //\n            FlowEdge* const pseudoExitEdge = comp->fgGetPredForBlock(pseudoExit, block);\n\n            if (pseudoExitEdge != nullptr)\n            {\n                // This is an actual or implicit flow graph exit.\n                //\n                visitSucc(reverseDfsTree->PseudoExit());\n            }\n\n            // Now process the regular successors.\n            //\n            // Note \"infinite loop\" blocks will have both an exit\n            // successor and regular successors.\n            //\n            for (BasicBlock* const succ : block->Succs(comp))",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "1835169433",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 109656,
        "pr_file": "src/coreclr/jit/flowgraph.cpp",
        "discussion_id": "1835169433",
        "commented_code": "@@ -6787,6 +6894,398 @@ void FlowGraphDominanceFrontiers::Dump()\n }\n #endif\n \n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::IntersectPostdom:\n+//   Find common IPDom parent, much like least common ancestor.\n+//\n+// Parameters:\n+//   finger1 - A basic block that might share IPDom ancestor with finger2.\n+//   finger2 - A basic block that might share IPDom ancestor with finger1.\n+//\n+// Returns:\n+//   A basic block whose IPDom is the postdominator for finger1 and finger2, or else\n+//   nullptr. This may be called while immediate postdominators are being computed,\n+//   and if the input values are members of the same loop (each reachable from\n+//   the other), then one may not yet have its immediate postdominator computed\n+//   when we are attempting to find the immediate postdominator of the other. So a\n+//   nullptr return value means that the the two inputs are in a cycle, not\n+//   that they don't have a common postdominator ancestor.\n+//\n+// Remarks:\n+//   See \"A simple, fast dominance algorithm\" by Keith D. Cooper, Timothy J.\n+//   Harvey, Ken Kennedy.\n+//\n+BasicBlock* FlowGraphPostDominatorTree::IntersectPostdom(BasicBlock* finger1, BasicBlock* finger2)\n+{\n+    while (finger1 != finger2)\n+    {\n+        if ((finger1 == nullptr) || (finger2 == nullptr))\n+        {\n+            return nullptr;\n+        }\n+        while ((finger1 != nullptr) && (finger1->bbReversePostorderNum < finger2->bbReversePostorderNum))\n+        {\n+            finger1 = finger1->bbIPDom;\n+        }\n+        if (finger1 == nullptr)\n+        {\n+            return nullptr;\n+        }\n+        while ((finger2 != nullptr) && (finger2->bbReversePostorderNum < finger1->bbReversePostorderNum))\n+        {\n+            finger2 = finger2->bbIPDom;\n+        }\n+    }\n+    return finger1;\n+}\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Intersect:\n+//   See FlowGraphPostominatorTree::IntersectPostdom\n+//\n+BasicBlock* FlowGraphPostDominatorTree::Intersect(BasicBlock* block1, BasicBlock* block2)\n+{\n+    return IntersectPostdom(block1, block2);\n+}\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::PostDominates:\n+//   Check if node \"postDominator\" is an ancestor of node \"postDominated\".\n+//\n+// Parameters:\n+//   postDominator - Node that may postdominate\n+//   postDominated - Node that may be postdominated\n+//\n+// Returns:\n+//   True \"postDominator\" postdominates \"postDominated\".\n+//\n+bool FlowGraphPostDominatorTree::PostDominates(BasicBlock* postDominator, BasicBlock* postDominated)\n+{\n+    assert(m_reverseDfsTree->Contains(postDominator) && m_reverseDfsTree->Contains(postDominated));\n+\n+    // What we want to ask here is basically if A is in the middle of the path\n+    // from B to the root (the entry node) in the postdominator tree. Turns out\n+    // that can be translated as:\n+    //\n+    //   A dom B <-> preorder(A) <= preorder(B) && postorder(A) >= postorder(B)\n+    //\n+    // where the equality holds when you ask if A postdominates itself.\n+    //\n+    return (m_preorderNum[postDominator->bbReversePostorderNum] <=\n+            m_preorderNum[postDominated->bbReversePostorderNum]) &&\n+           (m_postorderNum[postDominator->bbReversePostorderNum] >=\n+            m_postorderNum[postDominated->bbReversePostorderNum]);\n+}\n+\n+#ifdef DEBUG\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Dump: Dump a textual representation of the postdominator\n+// tree.\n+//\n+void FlowGraphPostDominatorTree::Dump()\n+{\n+    Compiler* comp = m_reverseDfsTree->GetCompiler();\n+\n+    for (BasicBlock* block : comp->Blocks())\n+    {\n+        if (!m_reverseDfsTree->Contains(block) || (m_domTree[block->bbReversePostorderNum].firstChild == nullptr))\n+            continue;\n+\n+        printf(FMT_BB \" : \", block->bbNum);\n+        for (BasicBlock* child = m_domTree[block->bbReversePostorderNum].firstChild; child != nullptr;\n+             child             = m_domTree[child->bbReversePostorderNum].nextSibling)\n+        {\n+            printf(FMT_BB \" \", child->bbNum);\n+        }\n+        printf(\"\\n\");\n+    }\n+\n+    printf(\"\\n\");\n+}\n+#endif\n+\n+//------------------------------------------------------------------------\n+// FlowGraphPostDominatorTree::Build: Compute the dominator tree for the blocks in\n+// the DFS tree.\n+//\n+// Parameters:\n+//   reverseDfsTree - reverse DFS tree.\n+//\n+// Returns:\n+//   Data structure representing postdominator tree. Immediate postdominators are\n+//   marked directly into the BasicBlock structures, in the bbIPDom field, so\n+//   multiple instances cannot be simultaneously used.\n+//\n+// Remarks:\n+//   As a precondition it is required that the reverse flow graph has a unique root.\n+//   This is handled by the reverse DFS tree via its pseudo block.\n+//\n+FlowGraphPostDominatorTree* FlowGraphPostDominatorTree::Build(const FlowGraphReverseDfsTree* reverseDfsTree)\n+{\n+    Compiler*         comp       = reverseDfsTree->GetCompiler();\n+    BasicBlock**      postOrder  = reverseDfsTree->GetPostOrder();\n+    unsigned          count      = reverseDfsTree->GetPostOrderCount();\n+    BasicBlock* const pseudoExit = reverseDfsTree->PseudoExit();\n+\n+    pseudoExit->bbIPDom = nullptr;\n+\n+    // First compute immediate postdominators.\n+    unsigned numIters = 0;\n+    bool     changed  = true;\n+    while (changed)\n+    {\n+        changed = false;\n+\n+        // In reverse post order, except for the entry block (count - 1 is entry BB).\n+        for (unsigned i = count - 1; i > 0; i--)\n+        {\n+            unsigned    poNum = i - 1;\n+            BasicBlock* block = postOrder[poNum];\n+\n+            // Intersect Postdom, if computed, for all successors\n+            BasicBlock* bbIPDom = nullptr;\n+\n+            auto visitSucc = [=, &bbIPDom](BasicBlock* succ) {\n+                if (!reverseDfsTree->Contains(succ))\n+                {\n+                    // Unreachable succ...?\n+                    return;\n+                }\n+\n+                if ((numIters <= 0) && (succ->bbReversePostorderNum <= poNum))\n+                {\n+                    return;\n+                }\n+\n+                if (bbIPDom == nullptr)\n+                {\n+                    bbIPDom = succ;\n+                }\n+                else\n+                {\n+                    bbIPDom = IntersectPostdom(bbIPDom, succ);\n+                }\n+            };\n+\n+            // Look for flow graph exit points. These have the pseudo exit as successor.\n+            // Hopefully the set is small and the pred search is cheap.\n+            //\n+            FlowEdge* const pseudoExitEdge = comp->fgGetPredForBlock(pseudoExit, block);\n+\n+            if (pseudoExitEdge != nullptr)\n+            {\n+                // This is an actual or implicit flow graph exit.\n+                //\n+                visitSucc(reverseDfsTree->PseudoExit());\n+            }\n+\n+            // Now process the regular successors.\n+            //\n+            // Note \"infinite loop\" blocks will have both an exit\n+            // successor and regular successors.\n+            //\n+            for (BasicBlock* const succ : block->Succs(comp))",
        "comment_created_at": "2024-11-09T00:10:37+00:00",
        "comment_author": "jakobbotsch",
        "comment_body": "This should use `BasicBlock::VisitAllSuccs` to model things faithfully",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178429312",
    "pr_number": 116983,
    "pr_file": "src/coreclr/jit/rationalize.cpp",
    "created_at": "2025-07-01T20:03:30+00:00",
    "commented_code": "}\n#endif // FEATURE_HW_INTRINSICS\n\n//\n// Post-order rewriting for HW Intrinsics\n//\n#if defined(FEATURE_HW_INTRINSICS)\n// RewriteHWIntrinsic: Rewrite a hwintrinsic node\n//\n// Arguments:\n//    use     - A pointer to the hwintrinsic node\n//    parents - A reference to tree walk data providing the context\n//\nvoid Rationalizer::RewriteHWIntrinsic(GenTree** use, Compiler::GenTreeStack& parents)\n{\n    GenTreeHWIntrinsic* node = (*use)->AsHWIntrinsic();\n\n    // Intrinsics should have already been rewritten back into user calls.\n    assert(!node->IsUserCall());\n\n    NamedIntrinsic intrinsic = node->GetHWIntrinsicId();\n\n    switch (intrinsic)\n    {\n#if defined(TARGET_XARCH)\n        case NI_AVX512_BlendVariableMask:\n        {\n            RewriteHWIntrinsicBlendv(use, parents);\n            break;\n        }\n\n        case NI_AVX512_ConvertMaskToVector:\n        case NI_AVX512_MoveMask:\n        {\n            RewriteHWIntrinsicMaskOp(use, parents);\n            break;\n        }\n#endif // TARGET_XARCH\n\n        default:\n        {\n            break;\n        }\n    }\n}\n\n#if defined(TARGET_XARCH)\n//----------------------------------------------------------------------------------------------\n// RewriteHWIntrinsicBlendv: Rewrites a hwintrinsic blendv operation\n//\n// Arguments:\n//    use     - A pointer to the hwintrinsic node\n//    parents - A reference to tree walk data providing the context\n//\nvoid Rationalizer::RewriteHWIntrinsicBlendv(GenTree** use, Compiler::GenTreeStack& parents)\n{\n    GenTreeHWIntrinsic* node = (*use)->AsHWIntrinsic();\n\n    // We normalize all comparisons to be of TYP_MASK on import. However, if we\n    // get to rationalization and we cannot take advantage of embedded masking\n    // then we want to rewrite things to just directly produce TYP_SIMD instead.\n\n    NamedIntrinsic intrinsic       = node->GetHWIntrinsicId();\n    var_types      retType         = node->TypeGet();\n    CorInfoType    simdBaseJitType = node->GetSimdBaseJitType();\n    var_types      simdBaseType    = node->GetSimdBaseType();\n    unsigned       simdSize        = node->GetSimdSize();\n\n    if (simdSize == 64)\n    {\n        return;\n    }\n\n    GenTree* op2 = node->Op(2);\n\n    // We're in the post-order visit and are traversing in execution order, so\n    // everything between op2 and node will have already been rewritten to LIR\n    // form and doing the IsInvariantInRange check is safe. This allows us to\n    // catch cases where something is embedded masking compatible but where we\n    // could never actually contain it and so we want to rewrite it to the non-mask\n    // variant\n    SideEffectSet scratchSideEffects;\n\n    if (Lowering::IsInvariantInRange(op2, node, comp, scratchSideEffects))\n    {\n        unsigned    tgtMaskSize        = simdSize / genTypeSize(simdBaseType);\n        CorInfoType tgtSimdBaseJitType = CORINFO_TYPE_UNDEF;\n\n        if (op2->isEmbeddedMaskingCompatible(comp, tgtMaskSize, tgtSimdBaseJitType))\n        {\n            // We are going to utilize the embedded mask, so we don't need to rewrite. However,\n            // we want to fixup the simdBaseJitType here since it simplifies lowering and allows\n            // both embedded broadcast and the mask to be live simultaneously.\n\n            if (tgtSimdBaseJitType != CORINFO_TYPE_UNDEF)\n            {\n                op2->AsHWIntrinsic()->SetSimdBaseJitType(tgtSimdBaseJitType);\n            }\n            return;\n        }\n    }",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2178429312",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116983,
        "pr_file": "src/coreclr/jit/rationalize.cpp",
        "discussion_id": "2178429312",
        "commented_code": "@@ -573,6 +576,737 @@ void Rationalizer::RewriteHWIntrinsicAsUserCall(GenTree** use, ArrayStack<GenTre\n }\n #endif // FEATURE_HW_INTRINSICS\n \n+//\n+// Post-order rewriting for HW Intrinsics\n+//\n+#if defined(FEATURE_HW_INTRINSICS)\n+// RewriteHWIntrinsic: Rewrite a hwintrinsic node\n+//\n+// Arguments:\n+//    use     - A pointer to the hwintrinsic node\n+//    parents - A reference to tree walk data providing the context\n+//\n+void Rationalizer::RewriteHWIntrinsic(GenTree** use, Compiler::GenTreeStack& parents)\n+{\n+    GenTreeHWIntrinsic* node = (*use)->AsHWIntrinsic();\n+\n+    // Intrinsics should have already been rewritten back into user calls.\n+    assert(!node->IsUserCall());\n+\n+    NamedIntrinsic intrinsic = node->GetHWIntrinsicId();\n+\n+    switch (intrinsic)\n+    {\n+#if defined(TARGET_XARCH)\n+        case NI_AVX512_BlendVariableMask:\n+        {\n+            RewriteHWIntrinsicBlendv(use, parents);\n+            break;\n+        }\n+\n+        case NI_AVX512_ConvertMaskToVector:\n+        case NI_AVX512_MoveMask:\n+        {\n+            RewriteHWIntrinsicMaskOp(use, parents);\n+            break;\n+        }\n+#endif // TARGET_XARCH\n+\n+        default:\n+        {\n+            break;\n+        }\n+    }\n+}\n+\n+#if defined(TARGET_XARCH)\n+//----------------------------------------------------------------------------------------------\n+// RewriteHWIntrinsicBlendv: Rewrites a hwintrinsic blendv operation\n+//\n+// Arguments:\n+//    use     - A pointer to the hwintrinsic node\n+//    parents - A reference to tree walk data providing the context\n+//\n+void Rationalizer::RewriteHWIntrinsicBlendv(GenTree** use, Compiler::GenTreeStack& parents)\n+{\n+    GenTreeHWIntrinsic* node = (*use)->AsHWIntrinsic();\n+\n+    // We normalize all comparisons to be of TYP_MASK on import. However, if we\n+    // get to rationalization and we cannot take advantage of embedded masking\n+    // then we want to rewrite things to just directly produce TYP_SIMD instead.\n+\n+    NamedIntrinsic intrinsic       = node->GetHWIntrinsicId();\n+    var_types      retType         = node->TypeGet();\n+    CorInfoType    simdBaseJitType = node->GetSimdBaseJitType();\n+    var_types      simdBaseType    = node->GetSimdBaseType();\n+    unsigned       simdSize        = node->GetSimdSize();\n+\n+    if (simdSize == 64)\n+    {\n+        return;\n+    }\n+\n+    GenTree* op2 = node->Op(2);\n+\n+    // We're in the post-order visit and are traversing in execution order, so\n+    // everything between op2 and node will have already been rewritten to LIR\n+    // form and doing the IsInvariantInRange check is safe. This allows us to\n+    // catch cases where something is embedded masking compatible but where we\n+    // could never actually contain it and so we want to rewrite it to the non-mask\n+    // variant\n+    SideEffectSet scratchSideEffects;\n+\n+    if (Lowering::IsInvariantInRange(op2, node, comp, scratchSideEffects))\n+    {\n+        unsigned    tgtMaskSize        = simdSize / genTypeSize(simdBaseType);\n+        CorInfoType tgtSimdBaseJitType = CORINFO_TYPE_UNDEF;\n+\n+        if (op2->isEmbeddedMaskingCompatible(comp, tgtMaskSize, tgtSimdBaseJitType))\n+        {\n+            // We are going to utilize the embedded mask, so we don't need to rewrite. However,\n+            // we want to fixup the simdBaseJitType here since it simplifies lowering and allows\n+            // both embedded broadcast and the mask to be live simultaneously.\n+\n+            if (tgtSimdBaseJitType != CORINFO_TYPE_UNDEF)\n+            {\n+                op2->AsHWIntrinsic()->SetSimdBaseJitType(tgtSimdBaseJitType);\n+            }\n+            return;\n+        }\n+    }",
        "comment_created_at": "2025-07-01T20:03:30+00:00",
        "comment_author": "tannergooding",
        "comment_body": "This was the cleanest/easiest way I could think of to do this.\r\n\r\nThe general idea is that we have several transforms we want to make to LIR before containment happens (because containment complicates these transforms). However, since we're in LIR form for these nodes at this point, we need to make sure the transform is safe to do.\r\n\r\nAn alternative would be to add a `pre` pass for lowering then do a separate `post` pass for containment, but that feels like a bigger/bulkier/riskier change.\r\n\r\nThere are some other transforms that would be nice to move \"here\" longer term, like the sequential `insertps` operation folding we do; or the recognizing of `AND(x, NOT(y))` we do; neither of which we want to do in HIR because it breaks or massively complicates other optimizations (like folding and operation negation) that we do.\r\n\r\nI'd be happy to make this a separate pass for .NET 11, if we feel that is better. But for .NET 10 I think this is a less risky approach.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172981156",
    "pr_number": 117110,
    "pr_file": "src/coreclr/interpreter/compiler.cpp",
    "created_at": "2025-06-27T23:41:33+00:00",
    "commented_code": "case CORINFO_FIELD_STATIC_ADDRESS:\n        case CORINFO_FIELD_STATIC_RVA_ADDRESS:\n        {\n            if (pFieldInfo->fieldFlags |= CORINFO_FLG_FIELD_INITCLASS)",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2172981156",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117110,
        "pr_file": "src/coreclr/interpreter/compiler.cpp",
        "discussion_id": "2172981156",
        "commented_code": "@@ -3079,6 +3079,13 @@ void InterpCompiler::EmitStaticFieldAddress(CORINFO_FIELD_INFO *pFieldInfo, CORI\n         case CORINFO_FIELD_STATIC_ADDRESS:\n         case CORINFO_FIELD_STATIC_RVA_ADDRESS:\n         {\n+            if (pFieldInfo->fieldFlags |= CORINFO_FLG_FIELD_INITCLASS)",
        "comment_created_at": "2025-06-27T23:41:33+00:00",
        "comment_author": "Copilot",
        "comment_body": "This uses `|=` (assignment) instead of `&` to test the `CORINFO_FLG_FIELD_INITCLASS` flag, which both mutates `fieldFlags` and always evaluates true. Change it to `if ((pFieldInfo->fieldFlags & CORINFO_FLG_FIELD_INITCLASS) != 0)`.\n```suggestion\n            if ((pFieldInfo->fieldFlags & CORINFO_FLG_FIELD_INITCLASS) != 0)\n```",
        "pr_file_module": null
      }
    ]
  }
]
