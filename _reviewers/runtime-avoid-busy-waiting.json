[
  {
    "discussion_id": "2178380980",
    "pr_number": 117105,
    "pr_file": "src/libraries/System.Diagnostics.Process/tests/ProcessTests.cs",
    "created_at": "2025-07-01T19:29:25+00:00",
    "commented_code": "}\n        }\n\n        [ConditionalTheory(typeof(RemoteExecutor), nameof(RemoteExecutor.IsSupported))]\n        [InlineData(PosixSignal.SIGTSTP)]\n        [InlineData(PosixSignal.SIGTTOU)]\n        [InlineData(PosixSignal.SIGTTIN)]\n        [InlineData(PosixSignal.SIGWINCH)]\n        [InlineData(PosixSignal.SIGCONT)]\n        [InlineData(PosixSignal.SIGCHLD)]\n        [InlineData(PosixSignal.SIGTERM)]\n        [InlineData(PosixSignal.SIGQUIT)]\n        [InlineData(PosixSignal.SIGINT)]\n        [InlineData(PosixSignal.SIGHUP)]\n        [InlineData((PosixSignal)3)] // SIGQUIT\n        [InlineData((PosixSignal)15)] // SIGTERM\n        public void TestCreateNewProcessGroup_HandlerReceivesExpectedSignal(PosixSignal signal)\n        {\n            const string PosixSignalRegistrationCreatedMessage = \"PosixSignalRegistration created...\";\n\n            if (OperatingSystem.IsWindows() && signal is not (PosixSignal.SIGINT or PosixSignal.SIGQUIT))\n            {\n                throw new SkipTestException(\"GenerateConsoleCtrlEvent does not support sending this signal.\");\n            }\n\n            var remoteInvokeOptions = new RemoteInvokeOptions { CheckExitCode = false };\n            remoteInvokeOptions.StartInfo.RedirectStandardOutput = true;\n            if (OperatingSystem.IsWindows())\n            {\n                remoteInvokeOptions.StartInfo.CreateNewProcessGroup = true;\n            }\n\n            using RemoteInvokeHandle remoteHandle = RemoteExecutor.Invoke(\n                (signalStr) =>\n                {\n                    PosixSignal expectedSignal = Enum.Parse<PosixSignal>(signalStr);\n                    bool receivedSignal = false;\n                    ReEnableCtrlCHandlerIfNeeded(expectedSignal);\n\n                    using PosixSignalRegistration p = PosixSignalRegistration.Create(expectedSignal, (ctx) =>\n                    {\n                        Assert.Equal(expectedSignal, ctx.Signal);\n                        receivedSignal = true;\n                        ctx.Cancel = true;\n                    });\n\n                    Console.WriteLine(PosixSignalRegistrationCreatedMessage);\n\n                    while (!receivedSignal) ;",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2178380980",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117105,
        "pr_file": "src/libraries/System.Diagnostics.Process/tests/ProcessTests.cs",
        "discussion_id": "2178380980",
        "commented_code": "@@ -80,6 +81,69 @@ private void AssertNonZeroAllZeroDarwin(long value)\n             }\n         }\n \n+        [ConditionalTheory(typeof(RemoteExecutor), nameof(RemoteExecutor.IsSupported))]\n+        [InlineData(PosixSignal.SIGTSTP)]\n+        [InlineData(PosixSignal.SIGTTOU)]\n+        [InlineData(PosixSignal.SIGTTIN)]\n+        [InlineData(PosixSignal.SIGWINCH)]\n+        [InlineData(PosixSignal.SIGCONT)]\n+        [InlineData(PosixSignal.SIGCHLD)]\n+        [InlineData(PosixSignal.SIGTERM)]\n+        [InlineData(PosixSignal.SIGQUIT)]\n+        [InlineData(PosixSignal.SIGINT)]\n+        [InlineData(PosixSignal.SIGHUP)]\n+        [InlineData((PosixSignal)3)] // SIGQUIT\n+        [InlineData((PosixSignal)15)] // SIGTERM\n+        public void TestCreateNewProcessGroup_HandlerReceivesExpectedSignal(PosixSignal signal)\n+        {\n+            const string PosixSignalRegistrationCreatedMessage = \"PosixSignalRegistration created...\";\n+\n+            if (OperatingSystem.IsWindows() && signal is not (PosixSignal.SIGINT or PosixSignal.SIGQUIT))\n+            {\n+                throw new SkipTestException(\"GenerateConsoleCtrlEvent does not support sending this signal.\");\n+            }\n+\n+            var remoteInvokeOptions = new RemoteInvokeOptions { CheckExitCode = false };\n+            remoteInvokeOptions.StartInfo.RedirectStandardOutput = true;\n+            if (OperatingSystem.IsWindows())\n+            {\n+                remoteInvokeOptions.StartInfo.CreateNewProcessGroup = true;\n+            }\n+\n+            using RemoteInvokeHandle remoteHandle = RemoteExecutor.Invoke(\n+                (signalStr) =>\n+                {\n+                    PosixSignal expectedSignal = Enum.Parse<PosixSignal>(signalStr);\n+                    bool receivedSignal = false;\n+                    ReEnableCtrlCHandlerIfNeeded(expectedSignal);\n+\n+                    using PosixSignalRegistration p = PosixSignalRegistration.Create(expectedSignal, (ctx) =>\n+                    {\n+                        Assert.Equal(expectedSignal, ctx.Signal);\n+                        receivedSignal = true;\n+                        ctx.Cancel = true;\n+                    });\n+\n+                    Console.WriteLine(PosixSignalRegistrationCreatedMessage);\n+\n+                    while (!receivedSignal) ;",
        "comment_created_at": "2025-07-01T19:29:25+00:00",
        "comment_author": "Copilot",
        "comment_body": "The busy-wait loop spins the CPU continuously. Consider using a synchronization primitive (e.g. `ManualResetEventSlim`) or at least inserting `Thread.Sleep(1)` (or `Thread.Yield()`) inside the loop to reduce CPU usage.\n```suggestion\n                    while (!receivedSignal)\n                    {\n                        Thread.Sleep(1);\n                    }\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180534267",
    "pr_number": 117148,
    "pr_file": "src/libraries/System.IO.FileSystem.Watcher/src/System/IO/FileSystemWatcher.Linux.cs",
    "created_at": "2025-07-02T16:47:54+00:00",
    "commented_code": "catch { return null; }\n        }\n\n        /// <summary>\n        /// Maps the FileSystemWatcher's NotifyFilters enumeration to the\n        /// corresponding Interop.Sys.NotifyEvents values.\n        /// </summary>\n        /// <param name=\"filters\">The filters provided the by user.</param>\n        /// <returns>The corresponding NotifyEvents values to use with inotify.</returns>\n        private static Interop.Sys.NotifyEvents TranslateFilters(NotifyFilters filters)\n        private sealed class INotify\n        {\n            Interop.Sys.NotifyEvents result = 0;\n\n            // We always include a few special inotify watch values that configure\n            // the watch's behavior.\n            result |=\n                Interop.Sys.NotifyEvents.IN_ONLYDIR |     // we only allow watches on directories\n                Interop.Sys.NotifyEvents.IN_EXCL_UNLINK;  // we want to stop monitoring unlinked files\n\n            // For the Created and Deleted events, we need to always\n            // register for the created/deleted inotify events, regardless\n            // of the supplied filters values. We explicitly don't include IN_DELETE_SELF.\n            // The Windows implementation doesn't include notifications for the root directory,\n            // and having this for subdirectories results in duplicate notifications, one from\n            // the parent and one from self.\n            result |=\n                Interop.Sys.NotifyEvents.IN_CREATE |\n                Interop.Sys.NotifyEvents.IN_DELETE;\n\n            // For the Changed event, which inotify events we subscribe to\n            // are based on the NotifyFilters supplied.\n            const NotifyFilters filtersForAccess =\n                NotifyFilters.LastAccess;\n            const NotifyFilters filtersForModify =\n                NotifyFilters.LastAccess |\n                NotifyFilters.LastWrite |\n                NotifyFilters.Security |\n                NotifyFilters.Size;\n            const NotifyFilters filtersForAttrib =\n                NotifyFilters.Attributes |\n                NotifyFilters.CreationTime |\n                NotifyFilters.LastAccess |\n                NotifyFilters.LastWrite |\n                NotifyFilters.Security |\n                NotifyFilters.Size;\n            if ((filters & filtersForAccess) != 0)\n            {\n                result |= Interop.Sys.NotifyEvents.IN_ACCESS;\n            }\n            if ((filters & filtersForModify) != 0)\n            {\n                result |= Interop.Sys.NotifyEvents.IN_MODIFY;\n            }\n            if ((filters & filtersForAttrib) != 0)\n            {\n                result |= Interop.Sys.NotifyEvents.IN_ATTRIB;\n            }\n            // Guards the watchers of the inotify instance.\n            public static readonly object s_watchersLock = new();\n\n            // For the Rename event, we'll register for the corresponding move inotify events if the\n            // caller's NotifyFilters asks for notifications related to names.\n            const NotifyFilters filtersForMoved =\n                NotifyFilters.FileName |\n                NotifyFilters.DirectoryName;\n            if ((filters & filtersForMoved) != 0)\n            private static INotify? s_currentInotify;\n\n            public static Watcher? StartWatcher(FileSystemWatcher fsw)\n            {\n                result |=\n                    Interop.Sys.NotifyEvents.IN_MOVED_FROM |\n                    Interop.Sys.NotifyEvents.IN_MOVED_TO;\n            }\n                Watcher watcher;\n                lock (s_watchersLock)\n                {\n                    // If there is no running instance, start one.\n                    if (s_currentInotify is null || s_currentInotify.IsStopped)\n                    {\n                        INotify inotify = new(s_watchersLock);\n                        inotify.Start();",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2180534267",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117148,
        "pr_file": "src/libraries/System.IO.FileSystem.Watcher/src/System/IO/FileSystemWatcher.Linux.cs",
        "discussion_id": "2180534267",
        "commented_code": "@@ -147,656 +104,784 @@ private void FinalizeDispose()\n             catch { return null; }\n         }\n \n-        /// <summary>\n-        /// Maps the FileSystemWatcher's NotifyFilters enumeration to the\n-        /// corresponding Interop.Sys.NotifyEvents values.\n-        /// </summary>\n-        /// <param name=\"filters\">The filters provided the by user.</param>\n-        /// <returns>The corresponding NotifyEvents values to use with inotify.</returns>\n-        private static Interop.Sys.NotifyEvents TranslateFilters(NotifyFilters filters)\n+        private sealed class INotify\n         {\n-            Interop.Sys.NotifyEvents result = 0;\n-\n-            // We always include a few special inotify watch values that configure\n-            // the watch's behavior.\n-            result |=\n-                Interop.Sys.NotifyEvents.IN_ONLYDIR |     // we only allow watches on directories\n-                Interop.Sys.NotifyEvents.IN_EXCL_UNLINK;  // we want to stop monitoring unlinked files\n-\n-            // For the Created and Deleted events, we need to always\n-            // register for the created/deleted inotify events, regardless\n-            // of the supplied filters values. We explicitly don't include IN_DELETE_SELF.\n-            // The Windows implementation doesn't include notifications for the root directory,\n-            // and having this for subdirectories results in duplicate notifications, one from\n-            // the parent and one from self.\n-            result |=\n-                Interop.Sys.NotifyEvents.IN_CREATE |\n-                Interop.Sys.NotifyEvents.IN_DELETE;\n-\n-            // For the Changed event, which inotify events we subscribe to\n-            // are based on the NotifyFilters supplied.\n-            const NotifyFilters filtersForAccess =\n-                NotifyFilters.LastAccess;\n-            const NotifyFilters filtersForModify =\n-                NotifyFilters.LastAccess |\n-                NotifyFilters.LastWrite |\n-                NotifyFilters.Security |\n-                NotifyFilters.Size;\n-            const NotifyFilters filtersForAttrib =\n-                NotifyFilters.Attributes |\n-                NotifyFilters.CreationTime |\n-                NotifyFilters.LastAccess |\n-                NotifyFilters.LastWrite |\n-                NotifyFilters.Security |\n-                NotifyFilters.Size;\n-            if ((filters & filtersForAccess) != 0)\n-            {\n-                result |= Interop.Sys.NotifyEvents.IN_ACCESS;\n-            }\n-            if ((filters & filtersForModify) != 0)\n-            {\n-                result |= Interop.Sys.NotifyEvents.IN_MODIFY;\n-            }\n-            if ((filters & filtersForAttrib) != 0)\n-            {\n-                result |= Interop.Sys.NotifyEvents.IN_ATTRIB;\n-            }\n+            // Guards the watchers of the inotify instance.\n+            public static readonly object s_watchersLock = new();\n \n-            // For the Rename event, we'll register for the corresponding move inotify events if the\n-            // caller's NotifyFilters asks for notifications related to names.\n-            const NotifyFilters filtersForMoved =\n-                NotifyFilters.FileName |\n-                NotifyFilters.DirectoryName;\n-            if ((filters & filtersForMoved) != 0)\n+            private static INotify? s_currentInotify;\n+\n+            public static Watcher? StartWatcher(FileSystemWatcher fsw)\n             {\n-                result |=\n-                    Interop.Sys.NotifyEvents.IN_MOVED_FROM |\n-                    Interop.Sys.NotifyEvents.IN_MOVED_TO;\n-            }\n+                Watcher watcher;\n+                lock (s_watchersLock)\n+                {\n+                    // If there is no running instance, start one.\n+                    if (s_currentInotify is null || s_currentInotify.IsStopped)\n+                    {\n+                        INotify inotify = new(s_watchersLock);\n+                        inotify.Start();",
        "comment_created_at": "2025-07-02T16:47:54+00:00",
        "comment_author": "adamsitnik",
        "comment_body": "Right here we are in a situation where we have created new `INotify` with the `INotifyInit`, and we call `INotify.Start` which creates a new background thread that starts processing the events in a loop:\r\n\r\nhttps://github.com/dotnet/runtime/blob/3cb75b023f945216f52ad70b76b6786b6473aa3d/src/libraries/System.IO.FileSystem.Watcher/src/System/IO/FileSystemWatcher.Linux.cs#L208\r\n\r\nAre we not going to hit the following condition?\r\n\r\nhttps://github.com/dotnet/runtime/blob/3cb75b023f945216f52ad70b76b6786b6473aa3d/src/libraries/System.IO.FileSystem.Watcher/src/System/IO/FileSystemWatcher.Linux.cs#L504-L507\r\n\r\nI would expect the call to `Start` after a call to `s_currentInotify.CreateWatcherCore(fsw);`",
        "pr_file_module": null
      },
      {
        "comment_id": "2180638777",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117148,
        "pr_file": "src/libraries/System.IO.FileSystem.Watcher/src/System/IO/FileSystemWatcher.Linux.cs",
        "discussion_id": "2180534267",
        "commented_code": "@@ -147,656 +104,784 @@ private void FinalizeDispose()\n             catch { return null; }\n         }\n \n-        /// <summary>\n-        /// Maps the FileSystemWatcher's NotifyFilters enumeration to the\n-        /// corresponding Interop.Sys.NotifyEvents values.\n-        /// </summary>\n-        /// <param name=\"filters\">The filters provided the by user.</param>\n-        /// <returns>The corresponding NotifyEvents values to use with inotify.</returns>\n-        private static Interop.Sys.NotifyEvents TranslateFilters(NotifyFilters filters)\n+        private sealed class INotify\n         {\n-            Interop.Sys.NotifyEvents result = 0;\n-\n-            // We always include a few special inotify watch values that configure\n-            // the watch's behavior.\n-            result |=\n-                Interop.Sys.NotifyEvents.IN_ONLYDIR |     // we only allow watches on directories\n-                Interop.Sys.NotifyEvents.IN_EXCL_UNLINK;  // we want to stop monitoring unlinked files\n-\n-            // For the Created and Deleted events, we need to always\n-            // register for the created/deleted inotify events, regardless\n-            // of the supplied filters values. We explicitly don't include IN_DELETE_SELF.\n-            // The Windows implementation doesn't include notifications for the root directory,\n-            // and having this for subdirectories results in duplicate notifications, one from\n-            // the parent and one from self.\n-            result |=\n-                Interop.Sys.NotifyEvents.IN_CREATE |\n-                Interop.Sys.NotifyEvents.IN_DELETE;\n-\n-            // For the Changed event, which inotify events we subscribe to\n-            // are based on the NotifyFilters supplied.\n-            const NotifyFilters filtersForAccess =\n-                NotifyFilters.LastAccess;\n-            const NotifyFilters filtersForModify =\n-                NotifyFilters.LastAccess |\n-                NotifyFilters.LastWrite |\n-                NotifyFilters.Security |\n-                NotifyFilters.Size;\n-            const NotifyFilters filtersForAttrib =\n-                NotifyFilters.Attributes |\n-                NotifyFilters.CreationTime |\n-                NotifyFilters.LastAccess |\n-                NotifyFilters.LastWrite |\n-                NotifyFilters.Security |\n-                NotifyFilters.Size;\n-            if ((filters & filtersForAccess) != 0)\n-            {\n-                result |= Interop.Sys.NotifyEvents.IN_ACCESS;\n-            }\n-            if ((filters & filtersForModify) != 0)\n-            {\n-                result |= Interop.Sys.NotifyEvents.IN_MODIFY;\n-            }\n-            if ((filters & filtersForAttrib) != 0)\n-            {\n-                result |= Interop.Sys.NotifyEvents.IN_ATTRIB;\n-            }\n+            // Guards the watchers of the inotify instance.\n+            public static readonly object s_watchersLock = new();\n \n-            // For the Rename event, we'll register for the corresponding move inotify events if the\n-            // caller's NotifyFilters asks for notifications related to names.\n-            const NotifyFilters filtersForMoved =\n-                NotifyFilters.FileName |\n-                NotifyFilters.DirectoryName;\n-            if ((filters & filtersForMoved) != 0)\n+            private static INotify? s_currentInotify;\n+\n+            public static Watcher? StartWatcher(FileSystemWatcher fsw)\n             {\n-                result |=\n-                    Interop.Sys.NotifyEvents.IN_MOVED_FROM |\n-                    Interop.Sys.NotifyEvents.IN_MOVED_TO;\n-            }\n+                Watcher watcher;\n+                lock (s_watchersLock)\n+                {\n+                    // If there is no running instance, start one.\n+                    if (s_currentInotify is null || s_currentInotify.IsStopped)\n+                    {\n+                        INotify inotify = new(s_watchersLock);\n+                        inotify.Start();",
        "comment_created_at": "2025-07-02T17:46:06+00:00",
        "comment_author": "tmds",
        "comment_body": "The `watchersLock` is held in `StartWatcher` until we've tried to add a watch.\r\n\r\nThen when the thread start method runs, it obtains the lock (therefore: waiting for `StartWatcher`) to check if a watch was effectively added. This causes the thread to stop in the unlikely case where we failed to add a watch for the FSW's base path.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178823934",
    "pr_number": 117223,
    "pr_file": "src/libraries/System.Private.CoreLib/src/System/Threading/Volatile.cs",
    "created_at": "2025-07-02T01:51:58+00:00",
    "commented_code": "// The runtime may replace these implementations with more efficient ones in some cases.\n        // In coreclr, for example, see importercalls.cpp.\n\n        #region Boolean\n        private struct VolatileBoolean { public volatile bool Value; }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static bool Read(ref readonly bool location) =>\n            Unsafe.As<bool, VolatileBoolean>(ref Unsafe.AsRef(in location)).Value;\n        public static bool Read(ref readonly bool location)\n        {\n            bool value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref bool location, bool value) =>\n            Unsafe.As<bool, VolatileBoolean>(ref location).Value = value;\n        #endregion\n\n        #region Byte\n        private struct VolatileByte { public volatile byte Value; }\n        public static void Write(ref bool location, bool value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static byte Read(ref readonly byte location) =>\n            Unsafe.As<byte, VolatileByte>(ref Unsafe.AsRef(in location)).Value;\n        public static byte Read(ref readonly byte location)\n        {\n            byte value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref byte location, byte value) =>\n            Unsafe.As<byte, VolatileByte>(ref location).Value = value;\n        #endregion\n        public static void Write(ref byte location, byte value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        #region Double\n        [Intrinsic]\n        [NonVersionable]\n        public static double Read(ref readonly double location)\n        {\n            long result = Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location)));\n            return BitConverter.Int64BitsToDouble(result);\n        }\n        public static double Read(ref readonly double location) =>\n            BitConverter.Int64BitsToDouble(Read(ref Unsafe.BitCast<double, long>(location)));\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref double location, double value) =>\n            Write(ref Unsafe.As<double, long>(ref location), BitConverter.DoubleToInt64Bits(value));\n        #endregion\n\n        #region Int16\n        private struct VolatileInt16 { public volatile short Value; }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static short Read(ref readonly short location) =>\n            Unsafe.As<short, VolatileInt16>(ref Unsafe.AsRef(in location)).Value;\n        public static short Read(ref readonly short location)\n        {\n            short value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref short location, short value) =>\n            Unsafe.As<short, VolatileInt16>(ref location).Value = value;\n        #endregion\n\n        #region Int32\n        private struct VolatileInt32 { public volatile int Value; }\n        public static void Write(ref short location, short value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static int Read(ref readonly int location) =>\n            Unsafe.As<int, VolatileInt32>(ref Unsafe.AsRef(in location)).Value;\n        public static int Read(ref readonly int location)\n        {\n            int value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref int location, int value) =>\n            Unsafe.As<int, VolatileInt32>(ref location).Value = value;\n        #endregion\n        public static void Write(ref int location, int value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        #region Int64\n        [Intrinsic]\n        [NonVersionable]\n        public static long Read(ref readonly long location) =>\n        public static long Read(ref readonly long location)\n        {\n#if TARGET_64BIT\n            (long)Unsafe.As<long, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n            long value = location;\n            ReadBarrier();\n            return value;\n#else\n            // On 32-bit machines, we use Interlocked, since an ordinary volatile read would not be atomic.\n            Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n            return Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2178823934",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117223,
        "pr_file": "src/libraries/System.Private.CoreLib/src/System/Threading/Volatile.cs",
        "discussion_id": "2178823934",
        "commented_code": "@@ -13,176 +13,202 @@ public static class Volatile\n         // The runtime may replace these implementations with more efficient ones in some cases.\n         // In coreclr, for example, see importercalls.cpp.\n \n-        #region Boolean\n-        private struct VolatileBoolean { public volatile bool Value; }\n-\n         [Intrinsic]\n         [NonVersionable]\n-        public static bool Read(ref readonly bool location) =>\n-            Unsafe.As<bool, VolatileBoolean>(ref Unsafe.AsRef(in location)).Value;\n+        public static bool Read(ref readonly bool location)\n+        {\n+            bool value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref bool location, bool value) =>\n-            Unsafe.As<bool, VolatileBoolean>(ref location).Value = value;\n-        #endregion\n-\n-        #region Byte\n-        private struct VolatileByte { public volatile byte Value; }\n+        public static void Write(ref bool location, bool value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static byte Read(ref readonly byte location) =>\n-            Unsafe.As<byte, VolatileByte>(ref Unsafe.AsRef(in location)).Value;\n+        public static byte Read(ref readonly byte location)\n+        {\n+            byte value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref byte location, byte value) =>\n-            Unsafe.As<byte, VolatileByte>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref byte location, byte value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region Double\n         [Intrinsic]\n         [NonVersionable]\n-        public static double Read(ref readonly double location)\n-        {\n-            long result = Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location)));\n-            return BitConverter.Int64BitsToDouble(result);\n-        }\n+        public static double Read(ref readonly double location) =>\n+            BitConverter.Int64BitsToDouble(Read(ref Unsafe.BitCast<double, long>(location)));\n \n         [Intrinsic]\n         [NonVersionable]\n         public static void Write(ref double location, double value) =>\n             Write(ref Unsafe.As<double, long>(ref location), BitConverter.DoubleToInt64Bits(value));\n-        #endregion\n-\n-        #region Int16\n-        private struct VolatileInt16 { public volatile short Value; }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static short Read(ref readonly short location) =>\n-            Unsafe.As<short, VolatileInt16>(ref Unsafe.AsRef(in location)).Value;\n+        public static short Read(ref readonly short location)\n+        {\n+            short value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref short location, short value) =>\n-            Unsafe.As<short, VolatileInt16>(ref location).Value = value;\n-        #endregion\n-\n-        #region Int32\n-        private struct VolatileInt32 { public volatile int Value; }\n+        public static void Write(ref short location, short value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static int Read(ref readonly int location) =>\n-            Unsafe.As<int, VolatileInt32>(ref Unsafe.AsRef(in location)).Value;\n+        public static int Read(ref readonly int location)\n+        {\n+            int value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref int location, int value) =>\n-            Unsafe.As<int, VolatileInt32>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref int location, int value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region Int64\n         [Intrinsic]\n         [NonVersionable]\n-        public static long Read(ref readonly long location) =>\n+        public static long Read(ref readonly long location)\n+        {\n #if TARGET_64BIT\n-            (long)Unsafe.As<long, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n+            long value = location;\n+            ReadBarrier();\n+            return value;\n #else\n             // On 32-bit machines, we use Interlocked, since an ordinary volatile read would not be atomic.\n-            Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n+            return Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);",
        "comment_created_at": "2025-07-02T01:51:58+00:00",
        "comment_author": "tannergooding",
        "comment_body": "I know this is existing, but this is a bug/memory safety violation.\r\n\r\nConsider the case where `location` refers to actually immutable memory. In such a case, `Volatile.Read` should succeed, but in actuality, `CompareExchange` will end up writing `0` in the case the value is actually `0`, which will cause an AV.",
        "pr_file_module": null
      },
      {
        "comment_id": "2178930023",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117223,
        "pr_file": "src/libraries/System.Private.CoreLib/src/System/Threading/Volatile.cs",
        "discussion_id": "2178823934",
        "commented_code": "@@ -13,176 +13,202 @@ public static class Volatile\n         // The runtime may replace these implementations with more efficient ones in some cases.\n         // In coreclr, for example, see importercalls.cpp.\n \n-        #region Boolean\n-        private struct VolatileBoolean { public volatile bool Value; }\n-\n         [Intrinsic]\n         [NonVersionable]\n-        public static bool Read(ref readonly bool location) =>\n-            Unsafe.As<bool, VolatileBoolean>(ref Unsafe.AsRef(in location)).Value;\n+        public static bool Read(ref readonly bool location)\n+        {\n+            bool value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref bool location, bool value) =>\n-            Unsafe.As<bool, VolatileBoolean>(ref location).Value = value;\n-        #endregion\n-\n-        #region Byte\n-        private struct VolatileByte { public volatile byte Value; }\n+        public static void Write(ref bool location, bool value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static byte Read(ref readonly byte location) =>\n-            Unsafe.As<byte, VolatileByte>(ref Unsafe.AsRef(in location)).Value;\n+        public static byte Read(ref readonly byte location)\n+        {\n+            byte value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref byte location, byte value) =>\n-            Unsafe.As<byte, VolatileByte>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref byte location, byte value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region Double\n         [Intrinsic]\n         [NonVersionable]\n-        public static double Read(ref readonly double location)\n-        {\n-            long result = Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location)));\n-            return BitConverter.Int64BitsToDouble(result);\n-        }\n+        public static double Read(ref readonly double location) =>\n+            BitConverter.Int64BitsToDouble(Read(ref Unsafe.BitCast<double, long>(location)));\n \n         [Intrinsic]\n         [NonVersionable]\n         public static void Write(ref double location, double value) =>\n             Write(ref Unsafe.As<double, long>(ref location), BitConverter.DoubleToInt64Bits(value));\n-        #endregion\n-\n-        #region Int16\n-        private struct VolatileInt16 { public volatile short Value; }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static short Read(ref readonly short location) =>\n-            Unsafe.As<short, VolatileInt16>(ref Unsafe.AsRef(in location)).Value;\n+        public static short Read(ref readonly short location)\n+        {\n+            short value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref short location, short value) =>\n-            Unsafe.As<short, VolatileInt16>(ref location).Value = value;\n-        #endregion\n-\n-        #region Int32\n-        private struct VolatileInt32 { public volatile int Value; }\n+        public static void Write(ref short location, short value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static int Read(ref readonly int location) =>\n-            Unsafe.As<int, VolatileInt32>(ref Unsafe.AsRef(in location)).Value;\n+        public static int Read(ref readonly int location)\n+        {\n+            int value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref int location, int value) =>\n-            Unsafe.As<int, VolatileInt32>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref int location, int value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region Int64\n         [Intrinsic]\n         [NonVersionable]\n-        public static long Read(ref readonly long location) =>\n+        public static long Read(ref readonly long location)\n+        {\n #if TARGET_64BIT\n-            (long)Unsafe.As<long, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n+            long value = location;\n+            ReadBarrier();\n+            return value;\n #else\n             // On 32-bit machines, we use Interlocked, since an ordinary volatile read would not be atomic.\n-            Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n+            return Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);",
        "comment_created_at": "2025-07-02T03:36:31+00:00",
        "comment_author": "jkotas",
        "comment_body": "Yes, somebody tried really hard to make `Volatile.Read` for 64-bit values atomic on x86, and this is the price that was paid for it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180093674",
    "pr_number": 117223,
    "pr_file": "src/libraries/System.Private.CoreLib/src/System/Threading/Volatile.cs",
    "created_at": "2025-07-02T13:38:28+00:00",
    "commented_code": "// The runtime may replace these implementations with more efficient ones in some cases.\n        // In coreclr, for example, see importercalls.cpp.\n\n        #region Boolean\n        private struct VolatileBoolean { public volatile bool Value; }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static bool Read(ref readonly bool location) =>\n            Unsafe.As<bool, VolatileBoolean>(ref Unsafe.AsRef(in location)).Value;\n        public static bool Read(ref readonly bool location)\n        {\n            bool value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref bool location, bool value) =>\n            Unsafe.As<bool, VolatileBoolean>(ref location).Value = value;\n        #endregion\n\n        #region Byte\n        private struct VolatileByte { public volatile byte Value; }\n        public static void Write(ref bool location, bool value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static byte Read(ref readonly byte location) =>\n            Unsafe.As<byte, VolatileByte>(ref Unsafe.AsRef(in location)).Value;\n        public static byte Read(ref readonly byte location)\n        {\n            byte value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref byte location, byte value) =>\n            Unsafe.As<byte, VolatileByte>(ref location).Value = value;\n        #endregion\n        public static void Write(ref byte location, byte value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        #region Double\n        [Intrinsic]\n        [NonVersionable]\n        public static double Read(ref readonly double location)\n        {\n            long result = Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location)));\n            return BitConverter.Int64BitsToDouble(result);\n        }\n        public static double Read(ref readonly double location) =>\n            // Delegate to long overload to ensure atomicity on 32-bit platforms.\n            BitConverter.Int64BitsToDouble(Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location))));\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref double location, double value) =>\n            // Delegate to long overload to ensure atomicity on 32-bit platforms.\n            Write(ref Unsafe.As<double, long>(ref location), BitConverter.DoubleToInt64Bits(value));\n        #endregion\n\n        #region Int16\n        private struct VolatileInt16 { public volatile short Value; }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static short Read(ref readonly short location) =>\n            Unsafe.As<short, VolatileInt16>(ref Unsafe.AsRef(in location)).Value;\n        public static short Read(ref readonly short location)\n        {\n            short value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref short location, short value) =>\n            Unsafe.As<short, VolatileInt16>(ref location).Value = value;\n        #endregion\n\n        #region Int32\n        private struct VolatileInt32 { public volatile int Value; }\n        public static void Write(ref short location, short value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static int Read(ref readonly int location) =>\n            Unsafe.As<int, VolatileInt32>(ref Unsafe.AsRef(in location)).Value;\n        public static int Read(ref readonly int location)\n        {\n            int value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref int location, int value) =>\n            Unsafe.As<int, VolatileInt32>(ref location).Value = value;\n        #endregion\n        public static void Write(ref int location, int value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        #region Int64\n        [Intrinsic]\n        [NonVersionable]\n        public static long Read(ref readonly long location) =>\n        public static long Read(ref readonly long location)\n        {\n#if TARGET_64BIT\n            (long)Unsafe.As<long, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n            long value = location;\n            ReadBarrier();\n            return value;\n#else\n            // On 32-bit machines, we use Interlocked, since an ordinary volatile read would not be atomic.\n            Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n            // On 32-bit, we use Interlocked, since an ordinary volatile read would not be atomic.\n            return Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n#endif\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref long location, long value) =>\n        public static void Write(ref long location, long value)\n        {\n#if TARGET_64BIT\n            Unsafe.As<long, VolatileIntPtr>(ref location).Value = (nint)value;\n            WriteBarrier();\n            location = value;\n#else\n            // On 32-bit, we use Interlocked, since an ordinary volatile write would not be atomic.\n            Interlocked.Exchange(ref location, value);\n#endif\n        #endregion\n\n        #region IntPtr\n        private struct VolatileIntPtr { public volatile IntPtr Value; }\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static IntPtr Read(ref readonly IntPtr location) =>\n            Unsafe.As<IntPtr, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n        public static IntPtr Read(ref readonly IntPtr location)\n        {\n            IntPtr value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref IntPtr location, IntPtr value) =>\n            Unsafe.As<IntPtr, VolatileIntPtr>(ref location).Value = value;\n        #endregion\n\n        #region SByte\n        private struct VolatileSByte { public volatile sbyte Value; }\n        public static void Write(ref IntPtr location, IntPtr value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static sbyte Read(ref readonly sbyte location) =>\n            Unsafe.As<sbyte, VolatileSByte>(ref Unsafe.AsRef(in location)).Value;\n        public static sbyte Read(ref readonly sbyte location)\n        {\n            sbyte value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref sbyte location, sbyte value) =>\n            Unsafe.As<sbyte, VolatileSByte>(ref location).Value = value;\n        #endregion\n\n        #region Single\n        private struct VolatileSingle { public volatile float Value; }\n        public static void Write(ref sbyte location, sbyte value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static float Read(ref readonly float location) =>\n            Unsafe.As<float, VolatileSingle>(ref Unsafe.AsRef(in location)).Value;\n        public static float Read(ref readonly float location)\n        {\n            float value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref float location, float value) =>\n            Unsafe.As<float, VolatileSingle>(ref location).Value = value;\n        #endregion\n\n        #region UInt16\n        private struct VolatileUInt16 { public volatile ushort Value; }\n        public static void Write(ref float location, float value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static ushort Read(ref readonly ushort location) =>\n            Unsafe.As<ushort, VolatileUInt16>(ref Unsafe.AsRef(in location)).Value;\n        public static ushort Read(ref readonly ushort location)\n        {\n            ushort value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref ushort location, ushort value) =>\n            Unsafe.As<ushort, VolatileUInt16>(ref location).Value = value;\n        #endregion\n\n        #region UInt32\n        private struct VolatileUInt32 { public volatile uint Value; }\n        public static void Write(ref ushort location, ushort value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static uint Read(ref readonly uint location) =>\n            Unsafe.As<uint, VolatileUInt32>(ref Unsafe.AsRef(in location)).Value;\n        public static uint Read(ref readonly uint location)\n        {\n            uint value = location;\n            ReadBarrier();\n            return value;\n        }\n\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static void Write(ref uint location, uint value) =>\n            Unsafe.As<uint, VolatileUInt32>(ref location).Value = value;\n        #endregion\n        public static void Write(ref uint location, uint value)\n        {\n            WriteBarrier();\n            location = value;\n        }\n\n        #region UInt64\n        [CLSCompliant(false)]\n        [Intrinsic]\n        [NonVersionable]\n        public static ulong Read(ref readonly ulong location) =>\n            // Delegate to long overload to ensure atomicity on 32-bit platforms.\n            (ulong)Read(ref Unsafe.As<ulong, long>(ref Unsafe.AsRef(in location)));",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2180093674",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117223,
        "pr_file": "src/libraries/System.Private.CoreLib/src/System/Threading/Volatile.cs",
        "discussion_id": "2180093674",
        "commented_code": "@@ -13,221 +13,255 @@ public static class Volatile\n         // The runtime may replace these implementations with more efficient ones in some cases.\n         // In coreclr, for example, see importercalls.cpp.\n \n-        #region Boolean\n-        private struct VolatileBoolean { public volatile bool Value; }\n-\n         [Intrinsic]\n         [NonVersionable]\n-        public static bool Read(ref readonly bool location) =>\n-            Unsafe.As<bool, VolatileBoolean>(ref Unsafe.AsRef(in location)).Value;\n+        public static bool Read(ref readonly bool location)\n+        {\n+            bool value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref bool location, bool value) =>\n-            Unsafe.As<bool, VolatileBoolean>(ref location).Value = value;\n-        #endregion\n-\n-        #region Byte\n-        private struct VolatileByte { public volatile byte Value; }\n+        public static void Write(ref bool location, bool value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static byte Read(ref readonly byte location) =>\n-            Unsafe.As<byte, VolatileByte>(ref Unsafe.AsRef(in location)).Value;\n+        public static byte Read(ref readonly byte location)\n+        {\n+            byte value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref byte location, byte value) =>\n-            Unsafe.As<byte, VolatileByte>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref byte location, byte value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region Double\n         [Intrinsic]\n         [NonVersionable]\n-        public static double Read(ref readonly double location)\n-        {\n-            long result = Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location)));\n-            return BitConverter.Int64BitsToDouble(result);\n-        }\n+        public static double Read(ref readonly double location) =>\n+            // Delegate to long overload to ensure atomicity on 32-bit platforms.\n+            BitConverter.Int64BitsToDouble(Read(ref Unsafe.As<double, long>(ref Unsafe.AsRef(in location))));\n \n         [Intrinsic]\n         [NonVersionable]\n         public static void Write(ref double location, double value) =>\n+            // Delegate to long overload to ensure atomicity on 32-bit platforms.\n             Write(ref Unsafe.As<double, long>(ref location), BitConverter.DoubleToInt64Bits(value));\n-        #endregion\n-\n-        #region Int16\n-        private struct VolatileInt16 { public volatile short Value; }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static short Read(ref readonly short location) =>\n-            Unsafe.As<short, VolatileInt16>(ref Unsafe.AsRef(in location)).Value;\n+        public static short Read(ref readonly short location)\n+        {\n+            short value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref short location, short value) =>\n-            Unsafe.As<short, VolatileInt16>(ref location).Value = value;\n-        #endregion\n-\n-        #region Int32\n-        private struct VolatileInt32 { public volatile int Value; }\n+        public static void Write(ref short location, short value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static int Read(ref readonly int location) =>\n-            Unsafe.As<int, VolatileInt32>(ref Unsafe.AsRef(in location)).Value;\n+        public static int Read(ref readonly int location)\n+        {\n+            int value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref int location, int value) =>\n-            Unsafe.As<int, VolatileInt32>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref int location, int value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region Int64\n         [Intrinsic]\n         [NonVersionable]\n-        public static long Read(ref readonly long location) =>\n+        public static long Read(ref readonly long location)\n+        {\n #if TARGET_64BIT\n-            (long)Unsafe.As<long, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n+            long value = location;\n+            ReadBarrier();\n+            return value;\n #else\n-            // On 32-bit machines, we use Interlocked, since an ordinary volatile read would not be atomic.\n-            Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n+            // On 32-bit, we use Interlocked, since an ordinary volatile read would not be atomic.\n+            return Interlocked.CompareExchange(ref Unsafe.AsRef(in location), 0, 0);\n #endif\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref long location, long value) =>\n+        public static void Write(ref long location, long value)\n+        {\n #if TARGET_64BIT\n-            Unsafe.As<long, VolatileIntPtr>(ref location).Value = (nint)value;\n+            WriteBarrier();\n+            location = value;\n #else\n             // On 32-bit, we use Interlocked, since an ordinary volatile write would not be atomic.\n             Interlocked.Exchange(ref location, value);\n #endif\n-        #endregion\n-\n-        #region IntPtr\n-        private struct VolatileIntPtr { public volatile IntPtr Value; }\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static IntPtr Read(ref readonly IntPtr location) =>\n-            Unsafe.As<IntPtr, VolatileIntPtr>(ref Unsafe.AsRef(in location)).Value;\n+        public static IntPtr Read(ref readonly IntPtr location)\n+        {\n+            IntPtr value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref IntPtr location, IntPtr value) =>\n-            Unsafe.As<IntPtr, VolatileIntPtr>(ref location).Value = value;\n-        #endregion\n-\n-        #region SByte\n-        private struct VolatileSByte { public volatile sbyte Value; }\n+        public static void Write(ref IntPtr location, IntPtr value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n-        public static sbyte Read(ref readonly sbyte location) =>\n-            Unsafe.As<sbyte, VolatileSByte>(ref Unsafe.AsRef(in location)).Value;\n+        public static sbyte Read(ref readonly sbyte location)\n+        {\n+            sbyte value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref sbyte location, sbyte value) =>\n-            Unsafe.As<sbyte, VolatileSByte>(ref location).Value = value;\n-        #endregion\n-\n-        #region Single\n-        private struct VolatileSingle { public volatile float Value; }\n+        public static void Write(ref sbyte location, sbyte value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static float Read(ref readonly float location) =>\n-            Unsafe.As<float, VolatileSingle>(ref Unsafe.AsRef(in location)).Value;\n+        public static float Read(ref readonly float location)\n+        {\n+            float value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref float location, float value) =>\n-            Unsafe.As<float, VolatileSingle>(ref location).Value = value;\n-        #endregion\n-\n-        #region UInt16\n-        private struct VolatileUInt16 { public volatile ushort Value; }\n+        public static void Write(ref float location, float value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n-        public static ushort Read(ref readonly ushort location) =>\n-            Unsafe.As<ushort, VolatileUInt16>(ref Unsafe.AsRef(in location)).Value;\n+        public static ushort Read(ref readonly ushort location)\n+        {\n+            ushort value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref ushort location, ushort value) =>\n-            Unsafe.As<ushort, VolatileUInt16>(ref location).Value = value;\n-        #endregion\n-\n-        #region UInt32\n-        private struct VolatileUInt32 { public volatile uint Value; }\n+        public static void Write(ref ushort location, ushort value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n-        public static uint Read(ref readonly uint location) =>\n-            Unsafe.As<uint, VolatileUInt32>(ref Unsafe.AsRef(in location)).Value;\n+        public static uint Read(ref readonly uint location)\n+        {\n+            uint value = location;\n+            ReadBarrier();\n+            return value;\n+        }\n \n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n-        public static void Write(ref uint location, uint value) =>\n-            Unsafe.As<uint, VolatileUInt32>(ref location).Value = value;\n-        #endregion\n+        public static void Write(ref uint location, uint value)\n+        {\n+            WriteBarrier();\n+            location = value;\n+        }\n \n-        #region UInt64\n         [CLSCompliant(false)]\n         [Intrinsic]\n         [NonVersionable]\n         public static ulong Read(ref readonly ulong location) =>\n+            // Delegate to long overload to ensure atomicity on 32-bit platforms.\n             (ulong)Read(ref Unsafe.As<ulong, long>(ref Unsafe.AsRef(in location)));",
        "comment_created_at": "2025-07-02T13:38:28+00:00",
        "comment_author": "tannergooding",
        "comment_body": "We can't for double, but we could remove the unsafe code here for `ulong` by following the same pattern that uses `Interlocked.CompareExchange` and `Interlocked.Exchange` under the ifdef.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2109150951",
    "pr_number": 116010,
    "pr_file": "src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/ThunkPool.cs",
    "created_at": "2025-05-27T13:09:22+00:00",
    "commented_code": "_allocatedBlocks = new AllocatedBlock();\n\n            IntPtr thunkStubsBlock;\n            lock (this)\n            {",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2109150951",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116010,
        "pr_file": "src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/ThunkPool.cs",
        "discussion_id": "2109150951",
        "commented_code": "@@ -87,11 +87,7 @@ private unsafe ThunksHeap(IntPtr commonStubAddress)\n \n             _allocatedBlocks = new AllocatedBlock();\n \n-            IntPtr thunkStubsBlock;\n-            lock (this)\n-            {",
        "comment_created_at": "2025-05-27T13:09:22+00:00",
        "comment_author": "MichalStrehovsky",
        "comment_body": "I was scratching my head about this - we're in a constructor. Nobody else can have `this`",
        "pr_file_module": null
      },
      {
        "comment_id": "2109209106",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116010,
        "pr_file": "src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/ThunkPool.cs",
        "discussion_id": "2109150951",
        "commented_code": "@@ -87,11 +87,7 @@ private unsafe ThunksHeap(IntPtr commonStubAddress)\n \n             _allocatedBlocks = new AllocatedBlock();\n \n-            IntPtr thunkStubsBlock;\n-            lock (this)\n-            {",
        "comment_created_at": "2025-05-27T13:32:57+00:00",
        "comment_author": "filipnavara",
        "comment_body": "That's obviously wrong, but also `GetNewThunksBlock` doesn't seem to be thread-safe, so perhaps the intention was to protect multiple simultaneous calls to that?",
        "pr_file_module": null
      },
      {
        "comment_id": "2113312756",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116010,
        "pr_file": "src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/ThunkPool.cs",
        "discussion_id": "2109150951",
        "commented_code": "@@ -87,11 +87,7 @@ private unsafe ThunksHeap(IntPtr commonStubAddress)\n \n             _allocatedBlocks = new AllocatedBlock();\n \n-            IntPtr thunkStubsBlock;\n-            lock (this)\n-            {",
        "comment_created_at": "2025-05-29T06:38:25+00:00",
        "comment_author": "filipnavara",
        "comment_body": "If we are not addressing this, should we open a follow-up issue? (or did I miss some mechanism that is making the static variable access thread safe?)",
        "pr_file_module": null
      },
      {
        "comment_id": "2113753196",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116010,
        "pr_file": "src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/ThunkPool.cs",
        "discussion_id": "2109150951",
        "commented_code": "@@ -87,11 +87,7 @@ private unsafe ThunksHeap(IntPtr commonStubAddress)\n \n             _allocatedBlocks = new AllocatedBlock();\n \n-            IntPtr thunkStubsBlock;\n-            lock (this)\n-            {",
        "comment_created_at": "2025-05-29T11:24:55+00:00",
        "comment_author": "MichalStrehovsky",
        "comment_body": "I'm not a fan of doing more within a PR than what's needed and this is orthogonal. Filed #116089.",
        "pr_file_module": null
      }
    ]
  }
]