---
title: Constant-time cryptographic validation
description: Always use constant-time comparison methods when validating cryptographic
  values to prevent timing side-channel attacks. Operations like comparing authentication
  tags, MACs, hashes, or any security-sensitive values should use dedicated APIs such
  as `CryptographicOperations.FixedTimeEquals()` rather than standard equality operators
  or methods.
repository: dotnet/runtime
label: Security
language: C#
comments_count: 1
repository_stars: 16578
---

Always use constant-time comparison methods when validating cryptographic values to prevent timing side-channel attacks. Operations like comparing authentication tags, MACs, hashes, or any security-sensitive values should use dedicated APIs such as `CryptographicOperations.FixedTimeEquals()` rather than standard equality operators or methods.

Example:
```csharp
// INSECURE: Vulnerable to timing attacks
if (header != 0xA65959A6UL)
    throw new CryptographicException();

// SECURE: Use constant-time comparison
uint err = (uint)(header) ^ 0xA65959A6U;
// Aggregate other validation results with bitwise OR
err |= pad & ~0x7;
// ...
if (err != 0)
    throw new CryptographicException();
```

For larger data structures or byte sequences:
```csharp
// INSECURE: String equality is not constant-time
if (computedTag == expectedTag)
    return true;

// SECURE: Use crypto-specific APIs
return CryptographicOperations.FixedTimeEquals(
    computedTag.AsSpan(), 
    expectedTag.AsSpan());
```

This practice is especially important for operations that verify authentication tags, decrypt ciphertexts, or validate signatures, where timing differences could reveal information about secret values to attackers.


[
  {
    "discussion_id": "2176155539",
    "pr_number": 117181,
    "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
    "created_at": "2025-06-30T23:53:10+00:00",
    "commented_code": "return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n        }\n\n        /// <summary>\n        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n        ///   Algorithm for the specified plaintext length.\n        /// </summary>\n        /// <param name=\"plaintextLengthInBytes\">\n        ///   The length of the plaintext to be wrapped, in bytes.\n        /// </param>\n        /// <returns>\n        ///   The padded length of the key wrap for the specified plaintext.\n        /// </returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\">\n        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n        /// </exception>\n        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n        {\n            if (plaintextLengthInBytes <= 0)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(plaintextLengthInBytes),\n                    \"Plaintext length must be positive.\");\n            }\n\n            checked\n            {\n                int blocks = (plaintextLengthInBytes + 7) / 8;\n                return (blocks + 1) * 8;\n            }\n        }\n\n        /// <summary>\n        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"plaintext\">The data to wrap.</param>\n        /// <returns>The wrapped data.</returns>\n        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n        {\n            ArgumentNullException.ThrowIfNull(plaintext);\n\n            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n        }\n\n        /// <summary>\n        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"plaintext\">The data to wrap.</param>\n        /// <returns>The wrapped data.</returns>\n        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n        {\n            if (plaintext.IsEmpty)\n                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n\n            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n            byte[] output = new byte[outputLength];\n            EncryptKeyWrapPaddedCore(plaintext, output);\n            return output;\n        }\n\n        /// <summary>\n        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n        ///   writing the result to a specified buffer.\n        /// </summary>\n        /// <param name=\"plaintext\">The data to wrap.</param>\n        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n        /// <exception cref=\"ArgumentException\">\n        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n        ///   <para>-or-</para>\n        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n        /// </exception>\n        /// <exception cref=\"CryptographicException\">\n        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n        ///   <para>-or-</para>\n        ///   <para>An error occurred during the cryptographic operation.</para>\n        /// </exception>\n        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n        {\n            if (plaintext.IsEmpty)\n                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n\n            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n\n            if (destination.Length != requiredLength)\n            {\n                throw new ArgumentException(\n                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n                    nameof(destination));\n            }\n\n            if (plaintext.Overlaps(destination))\n            {\n                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n            }\n\n            EncryptKeyWrapPaddedCore(plaintext, destination);\n        }\n\n        /// <summary>\n        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"ciphertext\">The data to unwrap.</param>\n        /// <returns>The unwrapped key.</returns>\n        /// <exception cref=\"ArgumentNullException\">\n        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n        /// </exception>\n        /// <exception cref=\"ArgumentException\">\n        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n        ///   to the output of the Key Wrap with Padding algorithm.\n        /// </exception>\n        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n        {\n            ArgumentNullException.ThrowIfNull(ciphertext);\n\n            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n        }\n\n        /// <summary>\n        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"ciphertext\">The data to unwrap.</param>\n        /// <returns>The unwrapped key.</returns>\n        /// <exception cref=\"ArgumentException\">\n        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n        ///   to the output of the Key Wrap with Padding algorithm.\n        /// </exception>\n        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n        {\n            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n\n            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n            {\n                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n                return lease.Span.Slice(0, written).ToArray();\n            }\n        }\n\n        /// <summary>\n        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"ciphertext\">The data to unwrap.</param>\n        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n        /// <returns>The number of bytes in the unwrapped key.</returns>\n        /// <exception cref=\"ArgumentException\">\n        ///   <para>\n        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n        ///     to the output of the Key Wrap with Padding algorithm.\n        ///   </para>\n        ///   <para>-or-</para>\n        ///   <para>\n        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n        ///     too short to hold the unwrapped key.\n        ///   </para>\n        /// </exception>\n        /// <exception cref=\"CryptographicException\">\n        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n        ///   <para>-or-</para>\n        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n        ///   <para>-or-</para>\n        ///   <para>An error occurred during the cryptographic operation.</para>\n        /// </exception>\n        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n        {\n            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n\n            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n            {\n                return bytesWritten;\n            }\n\n            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n        }\n\n        /// <summary>\n        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n        ///   AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"ciphertext\">The data to unwrap.</param>\n        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n        /// <param name=\"bytesWritten\">\n        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n        ///   This parameter is treated as uninitialized.\n        /// </param>\n        /// <returns>\n        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n        ///   otherwise, <see langword=\"false\" />.\n        /// </returns>\n        /// <exception cref=\"ArgumentNullException\">\n        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n        /// </exception>\n        /// <exception cref=\"ArgumentException\">\n        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n        ///   to the output of the Key Wrap with Padding algorithm.\n        /// </exception>\n        /// <exception cref=\"CryptographicException\">\n        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n        ///   <para>-or-</para>\n        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n        ///   <para>-or-</para>\n        ///   <para>An error occurred during the cryptographic operation.</para>\n        /// </exception>\n        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n        {\n            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n\n            int maxOutput = ciphertext.Length - 8;\n            int minOutput = maxOutput - 7;\n\n            if (destination.Length < minOutput)\n            {\n                bytesWritten = 0;\n                return false;\n            }\n\n            if (destination.Length > maxOutput)\n            {\n                destination = destination.Slice(0, maxOutput);\n            }\n\n            if (ciphertext.Overlaps(destination))\n            {\n                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n            }\n\n            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n            bool rented = !lease.Span.Overlaps(destination);\n\n            try\n            {\n                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n\n                if (written < minOutput || written > maxOutput)\n                {\n                    // The override has violated the rules of the algorithm.\n                    throw new CryptographicException();\n                }\n\n                if (written > destination.Length)\n                {\n                    bytesWritten = 0;\n                    return false;\n                }\n\n                if (rented)\n                {\n                    lease.Span.Slice(0, written).CopyTo(destination);\n                }\n\n                // If destination was long enough, and we didn't rent,\n                // our software implementation will guarantee that\n                // destination is cleared beyond the written length\n                // (because that had to be empty, or zeros for padding).\n                //\n                // An override might only copy 0..written into destination,\n                // so unconditionally clear the remainder of destination so\n                // it is consistent across rented/unrented base/derived.\n                destination.Slice(written).Clear();\n\n                bytesWritten = written;\n                return true;\n            }\n            catch\n            {\n                // It's only important to clear destination if it was not rented...\n                // but rather than have some exceptions clear it, and some not, always clear.`\n                CryptographicOperations.ZeroMemory(destination);\n                throw;\n            }\n            finally\n            {\n                lease.Dispose();\n            }\n        }\n\n        /// <summary>\n        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n        /// </summary>\n        /// <param name=\"source\">The data to unwrap.</param>\n        /// <param name=\"destination\">\n        ///   The buffer to receive the unwrapped key.\n        ///   </param>\n        /// <returns>The number of bytes in the unwrapped key.</returns>\n        /// <exception cref=\"CryptographicException\">\n        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n        ///   <para>-or-</para>\n        ///   <para>An error occurred during the cryptographic operation.</para>\n        /// </exception>\n        /// <remarks>\n        ///   <para>\n        ///     When called by the base class,\n        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n        ///   </para>\n        ///   <para>\n        ///     When called by the base class,\n        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n        ///     so any valid value will always fit.\n        ///   </para>\n        /// </remarks>\n        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n        {\n            ulong iv;\n\n            if (source.Length == 16)\n            {\n                Span<byte> decrypt = stackalloc byte[16];\n                DecryptEcb(source, decrypt, PaddingMode.None);\n                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n                decrypt.Slice(8).CopyTo(destination);\n            }\n            else\n            {\n                iv = Rfc3394Unwrap(source, destination);\n            }\n\n            uint len = (uint)iv;\n            ulong header = iv >> 32;\n            int slen = (int)len;\n\n            // Only 0..7 padding bytes are allowed.\n            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n            // If len == maxOutput, pad is 0, which is valid.\n            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n            // If len is any lower than that, then pad is more than 7, which is invalid.\n            int maxOutput = source.Length - 8;\n            uint pad = (uint)maxOutput - len;\n\n            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2176155539",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117181,
        "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
        "discussion_id": "2176155539",
        "commented_code": "@@ -33,6 +35,470 @@ protected Aes()\n             return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n         }\n \n+        /// <summary>\n+        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n+        ///   Algorithm for the specified plaintext length.\n+        /// </summary>\n+        /// <param name=\"plaintextLengthInBytes\">\n+        ///   The length of the plaintext to be wrapped, in bytes.\n+        /// </param>\n+        /// <returns>\n+        ///   The padded length of the key wrap for the specified plaintext.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentOutOfRangeException\">\n+        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n+        /// </exception>\n+        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n+        {\n+            if (plaintextLengthInBytes <= 0)\n+            {\n+                throw new ArgumentOutOfRangeException(\n+                    nameof(plaintextLengthInBytes),\n+                    \"Plaintext length must be positive.\");\n+            }\n+\n+            checked\n+            {\n+                int blocks = (plaintextLengthInBytes + 7) / 8;\n+                return (blocks + 1) * 8;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n+        {\n+            ArgumentNullException.ThrowIfNull(plaintext);\n+\n+            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n+            byte[] output = new byte[outputLength];\n+            EncryptKeyWrapPaddedCore(plaintext, output);\n+            return output;\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n+        ///   writing the result to a specified buffer.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n+        ///   <para>-or-</para>\n+        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n+        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n+\n+            if (destination.Length != requiredLength)\n+            {\n+                throw new ArgumentException(\n+                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n+                    nameof(destination));\n+            }\n+\n+            if (plaintext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            EncryptKeyWrapPaddedCore(plaintext, destination);\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n+        {\n+            ArgumentNullException.ThrowIfNull(ciphertext);\n+\n+            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n+            {\n+                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n+                return lease.Span.Slice(0, written).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para>\n+        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///     to the output of the Key Wrap with Padding algorithm.\n+        ///   </para>\n+        ///   <para>-or-</para>\n+        ///   <para>\n+        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n+        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n+        ///     too short to hold the unwrapped key.\n+        ///   </para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n+            {\n+                return bytesWritten;\n+            }\n+\n+            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n+        }\n+\n+        /// <summary>\n+        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n+        ///   AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <param name=\"bytesWritten\">\n+        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n+        ///   This parameter is treated as uninitialized.\n+        /// </param>\n+        /// <returns>\n+        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n+        ///   otherwise, <see langword=\"false\" />.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            int maxOutput = ciphertext.Length - 8;\n+            int minOutput = maxOutput - 7;\n+\n+            if (destination.Length < minOutput)\n+            {\n+                bytesWritten = 0;\n+                return false;\n+            }\n+\n+            if (destination.Length > maxOutput)\n+            {\n+                destination = destination.Slice(0, maxOutput);\n+            }\n+\n+            if (ciphertext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n+            bool rented = !lease.Span.Overlaps(destination);\n+\n+            try\n+            {\n+                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n+\n+                if (written < minOutput || written > maxOutput)\n+                {\n+                    // The override has violated the rules of the algorithm.\n+                    throw new CryptographicException();\n+                }\n+\n+                if (written > destination.Length)\n+                {\n+                    bytesWritten = 0;\n+                    return false;\n+                }\n+\n+                if (rented)\n+                {\n+                    lease.Span.Slice(0, written).CopyTo(destination);\n+                }\n+\n+                // If destination was long enough, and we didn't rent,\n+                // our software implementation will guarantee that\n+                // destination is cleared beyond the written length\n+                // (because that had to be empty, or zeros for padding).\n+                //\n+                // An override might only copy 0..written into destination,\n+                // so unconditionally clear the remainder of destination so\n+                // it is consistent across rented/unrented base/derived.\n+                destination.Slice(written).Clear();\n+\n+                bytesWritten = written;\n+                return true;\n+            }\n+            catch\n+            {\n+                // It's only important to clear destination if it was not rented...\n+                // but rather than have some exceptions clear it, and some not, always clear.`\n+                CryptographicOperations.ZeroMemory(destination);\n+                throw;\n+            }\n+            finally\n+            {\n+                lease.Dispose();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"source\">The data to unwrap.</param>\n+        /// <param name=\"destination\">\n+        ///   The buffer to receive the unwrapped key.\n+        ///   </param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <remarks>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n+        ///   </para>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n+        ///     so any valid value will always fit.\n+        ///   </para>\n+        /// </remarks>\n+        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n+        {\n+            ulong iv;\n+\n+            if (source.Length == 16)\n+            {\n+                Span<byte> decrypt = stackalloc byte[16];\n+                DecryptEcb(source, decrypt, PaddingMode.None);\n+                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n+                decrypt.Slice(8).CopyTo(destination);\n+            }\n+            else\n+            {\n+                iv = Rfc3394Unwrap(source, destination);\n+            }\n+\n+            uint len = (uint)iv;\n+            ulong header = iv >> 32;\n+            int slen = (int)len;\n+\n+            // Only 0..7 padding bytes are allowed.\n+            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n+            // If len == maxOutput, pad is 0, which is valid.\n+            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n+            // If len is any lower than that, then pad is more than 7, which is invalid.\n+            int maxOutput = source.Length - 8;\n+            uint pad = (uint)maxOutput - len;\n+\n+            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
        "comment_created_at": "2025-06-30T23:53:10+00:00",
        "comment_author": "vcsjones",
        "comment_body": "Should this do a MemoryMarshal to convert the unsigned longs to `ReadOnlySpan<byte>` and use `CryptographicOperations.FixedTimesEqual`? I don't think comparing two 64-bit integers is guaranteed to be a fixed time op on 32-bit platforms.",
        "pr_file_module": null
      },
      {
        "comment_id": "2176194310",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117181,
        "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
        "discussion_id": "2176155539",
        "commented_code": "@@ -33,6 +35,470 @@ protected Aes()\n             return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n         }\n \n+        /// <summary>\n+        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n+        ///   Algorithm for the specified plaintext length.\n+        /// </summary>\n+        /// <param name=\"plaintextLengthInBytes\">\n+        ///   The length of the plaintext to be wrapped, in bytes.\n+        /// </param>\n+        /// <returns>\n+        ///   The padded length of the key wrap for the specified plaintext.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentOutOfRangeException\">\n+        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n+        /// </exception>\n+        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n+        {\n+            if (plaintextLengthInBytes <= 0)\n+            {\n+                throw new ArgumentOutOfRangeException(\n+                    nameof(plaintextLengthInBytes),\n+                    \"Plaintext length must be positive.\");\n+            }\n+\n+            checked\n+            {\n+                int blocks = (plaintextLengthInBytes + 7) / 8;\n+                return (blocks + 1) * 8;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n+        {\n+            ArgumentNullException.ThrowIfNull(plaintext);\n+\n+            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n+            byte[] output = new byte[outputLength];\n+            EncryptKeyWrapPaddedCore(plaintext, output);\n+            return output;\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n+        ///   writing the result to a specified buffer.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n+        ///   <para>-or-</para>\n+        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n+        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n+\n+            if (destination.Length != requiredLength)\n+            {\n+                throw new ArgumentException(\n+                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n+                    nameof(destination));\n+            }\n+\n+            if (plaintext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            EncryptKeyWrapPaddedCore(plaintext, destination);\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n+        {\n+            ArgumentNullException.ThrowIfNull(ciphertext);\n+\n+            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n+            {\n+                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n+                return lease.Span.Slice(0, written).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para>\n+        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///     to the output of the Key Wrap with Padding algorithm.\n+        ///   </para>\n+        ///   <para>-or-</para>\n+        ///   <para>\n+        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n+        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n+        ///     too short to hold the unwrapped key.\n+        ///   </para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n+            {\n+                return bytesWritten;\n+            }\n+\n+            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n+        }\n+\n+        /// <summary>\n+        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n+        ///   AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <param name=\"bytesWritten\">\n+        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n+        ///   This parameter is treated as uninitialized.\n+        /// </param>\n+        /// <returns>\n+        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n+        ///   otherwise, <see langword=\"false\" />.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            int maxOutput = ciphertext.Length - 8;\n+            int minOutput = maxOutput - 7;\n+\n+            if (destination.Length < minOutput)\n+            {\n+                bytesWritten = 0;\n+                return false;\n+            }\n+\n+            if (destination.Length > maxOutput)\n+            {\n+                destination = destination.Slice(0, maxOutput);\n+            }\n+\n+            if (ciphertext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n+            bool rented = !lease.Span.Overlaps(destination);\n+\n+            try\n+            {\n+                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n+\n+                if (written < minOutput || written > maxOutput)\n+                {\n+                    // The override has violated the rules of the algorithm.\n+                    throw new CryptographicException();\n+                }\n+\n+                if (written > destination.Length)\n+                {\n+                    bytesWritten = 0;\n+                    return false;\n+                }\n+\n+                if (rented)\n+                {\n+                    lease.Span.Slice(0, written).CopyTo(destination);\n+                }\n+\n+                // If destination was long enough, and we didn't rent,\n+                // our software implementation will guarantee that\n+                // destination is cleared beyond the written length\n+                // (because that had to be empty, or zeros for padding).\n+                //\n+                // An override might only copy 0..written into destination,\n+                // so unconditionally clear the remainder of destination so\n+                // it is consistent across rented/unrented base/derived.\n+                destination.Slice(written).Clear();\n+\n+                bytesWritten = written;\n+                return true;\n+            }\n+            catch\n+            {\n+                // It's only important to clear destination if it was not rented...\n+                // but rather than have some exceptions clear it, and some not, always clear.`\n+                CryptographicOperations.ZeroMemory(destination);\n+                throw;\n+            }\n+            finally\n+            {\n+                lease.Dispose();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"source\">The data to unwrap.</param>\n+        /// <param name=\"destination\">\n+        ///   The buffer to receive the unwrapped key.\n+        ///   </param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <remarks>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n+        ///   </para>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n+        ///     so any valid value will always fit.\n+        ///   </para>\n+        /// </remarks>\n+        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n+        {\n+            ulong iv;\n+\n+            if (source.Length == 16)\n+            {\n+                Span<byte> decrypt = stackalloc byte[16];\n+                DecryptEcb(source, decrypt, PaddingMode.None);\n+                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n+                decrypt.Slice(8).CopyTo(destination);\n+            }\n+            else\n+            {\n+                iv = Rfc3394Unwrap(source, destination);\n+            }\n+\n+            uint len = (uint)iv;\n+            ulong header = iv >> 32;\n+            int slen = (int)len;\n+\n+            // Only 0..7 padding bytes are allowed.\n+            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n+            // If len == maxOutput, pad is 0, which is valid.\n+            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n+            // If len is any lower than that, then pad is more than 7, which is invalid.\n+            int maxOutput = source.Length - 8;\n+            uint pad = (uint)maxOutput - len;\n+\n+            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
        "comment_created_at": "2025-07-01T00:49:11+00:00",
        "comment_author": "vcsjones",
        "comment_body": "(Or maybe some other architecture don't do it at all like certain RISC-V profiles or whatever). My earlier comment about bitness doesn't actually matter.",
        "pr_file_module": null
      },
      {
        "comment_id": "2176219829",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117181,
        "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
        "discussion_id": "2176155539",
        "commented_code": "@@ -33,6 +35,470 @@ protected Aes()\n             return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n         }\n \n+        /// <summary>\n+        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n+        ///   Algorithm for the specified plaintext length.\n+        /// </summary>\n+        /// <param name=\"plaintextLengthInBytes\">\n+        ///   The length of the plaintext to be wrapped, in bytes.\n+        /// </param>\n+        /// <returns>\n+        ///   The padded length of the key wrap for the specified plaintext.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentOutOfRangeException\">\n+        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n+        /// </exception>\n+        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n+        {\n+            if (plaintextLengthInBytes <= 0)\n+            {\n+                throw new ArgumentOutOfRangeException(\n+                    nameof(plaintextLengthInBytes),\n+                    \"Plaintext length must be positive.\");\n+            }\n+\n+            checked\n+            {\n+                int blocks = (plaintextLengthInBytes + 7) / 8;\n+                return (blocks + 1) * 8;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n+        {\n+            ArgumentNullException.ThrowIfNull(plaintext);\n+\n+            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n+            byte[] output = new byte[outputLength];\n+            EncryptKeyWrapPaddedCore(plaintext, output);\n+            return output;\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n+        ///   writing the result to a specified buffer.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n+        ///   <para>-or-</para>\n+        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n+        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n+\n+            if (destination.Length != requiredLength)\n+            {\n+                throw new ArgumentException(\n+                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n+                    nameof(destination));\n+            }\n+\n+            if (plaintext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            EncryptKeyWrapPaddedCore(plaintext, destination);\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n+        {\n+            ArgumentNullException.ThrowIfNull(ciphertext);\n+\n+            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n+            {\n+                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n+                return lease.Span.Slice(0, written).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para>\n+        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///     to the output of the Key Wrap with Padding algorithm.\n+        ///   </para>\n+        ///   <para>-or-</para>\n+        ///   <para>\n+        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n+        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n+        ///     too short to hold the unwrapped key.\n+        ///   </para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n+            {\n+                return bytesWritten;\n+            }\n+\n+            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n+        }\n+\n+        /// <summary>\n+        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n+        ///   AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <param name=\"bytesWritten\">\n+        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n+        ///   This parameter is treated as uninitialized.\n+        /// </param>\n+        /// <returns>\n+        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n+        ///   otherwise, <see langword=\"false\" />.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            int maxOutput = ciphertext.Length - 8;\n+            int minOutput = maxOutput - 7;\n+\n+            if (destination.Length < minOutput)\n+            {\n+                bytesWritten = 0;\n+                return false;\n+            }\n+\n+            if (destination.Length > maxOutput)\n+            {\n+                destination = destination.Slice(0, maxOutput);\n+            }\n+\n+            if (ciphertext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n+            bool rented = !lease.Span.Overlaps(destination);\n+\n+            try\n+            {\n+                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n+\n+                if (written < minOutput || written > maxOutput)\n+                {\n+                    // The override has violated the rules of the algorithm.\n+                    throw new CryptographicException();\n+                }\n+\n+                if (written > destination.Length)\n+                {\n+                    bytesWritten = 0;\n+                    return false;\n+                }\n+\n+                if (rented)\n+                {\n+                    lease.Span.Slice(0, written).CopyTo(destination);\n+                }\n+\n+                // If destination was long enough, and we didn't rent,\n+                // our software implementation will guarantee that\n+                // destination is cleared beyond the written length\n+                // (because that had to be empty, or zeros for padding).\n+                //\n+                // An override might only copy 0..written into destination,\n+                // so unconditionally clear the remainder of destination so\n+                // it is consistent across rented/unrented base/derived.\n+                destination.Slice(written).Clear();\n+\n+                bytesWritten = written;\n+                return true;\n+            }\n+            catch\n+            {\n+                // It's only important to clear destination if it was not rented...\n+                // but rather than have some exceptions clear it, and some not, always clear.`\n+                CryptographicOperations.ZeroMemory(destination);\n+                throw;\n+            }\n+            finally\n+            {\n+                lease.Dispose();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"source\">The data to unwrap.</param>\n+        /// <param name=\"destination\">\n+        ///   The buffer to receive the unwrapped key.\n+        ///   </param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <remarks>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n+        ///   </para>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n+        ///     so any valid value will always fit.\n+        ///   </para>\n+        /// </remarks>\n+        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n+        {\n+            ulong iv;\n+\n+            if (source.Length == 16)\n+            {\n+                Span<byte> decrypt = stackalloc byte[16];\n+                DecryptEcb(source, decrypt, PaddingMode.None);\n+                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n+                decrypt.Slice(8).CopyTo(destination);\n+            }\n+            else\n+            {\n+                iv = Rfc3394Unwrap(source, destination);\n+            }\n+\n+            uint len = (uint)iv;\n+            ulong header = iv >> 32;\n+            int slen = (int)len;\n+\n+            // Only 0..7 padding bytes are allowed.\n+            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n+            // If len == maxOutput, pad is 0, which is valid.\n+            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n+            // If len is any lower than that, then pad is more than 7, which is invalid.\n+            int maxOutput = source.Length - 8;\n+            uint pad = (uint)maxOutput - len;\n+\n+            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
        "comment_created_at": "2025-07-01T01:22:36+00:00",
        "comment_author": "bartonjs",
        "comment_body": "Since the header is only 32 bits, if we think this needs to be constant time, then the verification can probably be written in terms of uint.\r\n\r\nuint err = (uint)(header) ^ 0xA65959A6U;\r\nerr |= pad & ~0x7;\r\n// Something clever with selecting only the bottom 3 bits of `pad`'s worth of the buffer and XOR against zero, or it into err\r\n\r\nThen fail if err != 0.\r\n\r\nI thought about doing it as fixed time, but given the layering of KW, it feels hard to abuse it.  OpenSSL, FWIW, doesn't bother with fixed time:  https://github.com/openssl/openssl/blob/b3161bd9a9329be3d6bf6b29a06835e2721898bb/crypto/modes/wrap128.c#L295-L330",
        "pr_file_module": null
      },
      {
        "comment_id": "2176246670",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117181,
        "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
        "discussion_id": "2176155539",
        "commented_code": "@@ -33,6 +35,470 @@ protected Aes()\n             return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n         }\n \n+        /// <summary>\n+        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n+        ///   Algorithm for the specified plaintext length.\n+        /// </summary>\n+        /// <param name=\"plaintextLengthInBytes\">\n+        ///   The length of the plaintext to be wrapped, in bytes.\n+        /// </param>\n+        /// <returns>\n+        ///   The padded length of the key wrap for the specified plaintext.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentOutOfRangeException\">\n+        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n+        /// </exception>\n+        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n+        {\n+            if (plaintextLengthInBytes <= 0)\n+            {\n+                throw new ArgumentOutOfRangeException(\n+                    nameof(plaintextLengthInBytes),\n+                    \"Plaintext length must be positive.\");\n+            }\n+\n+            checked\n+            {\n+                int blocks = (plaintextLengthInBytes + 7) / 8;\n+                return (blocks + 1) * 8;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n+        {\n+            ArgumentNullException.ThrowIfNull(plaintext);\n+\n+            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n+            byte[] output = new byte[outputLength];\n+            EncryptKeyWrapPaddedCore(plaintext, output);\n+            return output;\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n+        ///   writing the result to a specified buffer.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n+        ///   <para>-or-</para>\n+        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n+        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n+\n+            if (destination.Length != requiredLength)\n+            {\n+                throw new ArgumentException(\n+                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n+                    nameof(destination));\n+            }\n+\n+            if (plaintext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            EncryptKeyWrapPaddedCore(plaintext, destination);\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n+        {\n+            ArgumentNullException.ThrowIfNull(ciphertext);\n+\n+            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n+            {\n+                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n+                return lease.Span.Slice(0, written).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para>\n+        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///     to the output of the Key Wrap with Padding algorithm.\n+        ///   </para>\n+        ///   <para>-or-</para>\n+        ///   <para>\n+        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n+        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n+        ///     too short to hold the unwrapped key.\n+        ///   </para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n+            {\n+                return bytesWritten;\n+            }\n+\n+            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n+        }\n+\n+        /// <summary>\n+        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n+        ///   AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <param name=\"bytesWritten\">\n+        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n+        ///   This parameter is treated as uninitialized.\n+        /// </param>\n+        /// <returns>\n+        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n+        ///   otherwise, <see langword=\"false\" />.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            int maxOutput = ciphertext.Length - 8;\n+            int minOutput = maxOutput - 7;\n+\n+            if (destination.Length < minOutput)\n+            {\n+                bytesWritten = 0;\n+                return false;\n+            }\n+\n+            if (destination.Length > maxOutput)\n+            {\n+                destination = destination.Slice(0, maxOutput);\n+            }\n+\n+            if (ciphertext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n+            bool rented = !lease.Span.Overlaps(destination);\n+\n+            try\n+            {\n+                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n+\n+                if (written < minOutput || written > maxOutput)\n+                {\n+                    // The override has violated the rules of the algorithm.\n+                    throw new CryptographicException();\n+                }\n+\n+                if (written > destination.Length)\n+                {\n+                    bytesWritten = 0;\n+                    return false;\n+                }\n+\n+                if (rented)\n+                {\n+                    lease.Span.Slice(0, written).CopyTo(destination);\n+                }\n+\n+                // If destination was long enough, and we didn't rent,\n+                // our software implementation will guarantee that\n+                // destination is cleared beyond the written length\n+                // (because that had to be empty, or zeros for padding).\n+                //\n+                // An override might only copy 0..written into destination,\n+                // so unconditionally clear the remainder of destination so\n+                // it is consistent across rented/unrented base/derived.\n+                destination.Slice(written).Clear();\n+\n+                bytesWritten = written;\n+                return true;\n+            }\n+            catch\n+            {\n+                // It's only important to clear destination if it was not rented...\n+                // but rather than have some exceptions clear it, and some not, always clear.`\n+                CryptographicOperations.ZeroMemory(destination);\n+                throw;\n+            }\n+            finally\n+            {\n+                lease.Dispose();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"source\">The data to unwrap.</param>\n+        /// <param name=\"destination\">\n+        ///   The buffer to receive the unwrapped key.\n+        ///   </param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <remarks>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n+        ///   </para>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n+        ///     so any valid value will always fit.\n+        ///   </para>\n+        /// </remarks>\n+        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n+        {\n+            ulong iv;\n+\n+            if (source.Length == 16)\n+            {\n+                Span<byte> decrypt = stackalloc byte[16];\n+                DecryptEcb(source, decrypt, PaddingMode.None);\n+                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n+                decrypt.Slice(8).CopyTo(destination);\n+            }\n+            else\n+            {\n+                iv = Rfc3394Unwrap(source, destination);\n+            }\n+\n+            uint len = (uint)iv;\n+            ulong header = iv >> 32;\n+            int slen = (int)len;\n+\n+            // Only 0..7 padding bytes are allowed.\n+            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n+            // If len == maxOutput, pad is 0, which is valid.\n+            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n+            // If len is any lower than that, then pad is more than 7, which is invalid.\n+            int maxOutput = source.Length - 8;\n+            uint pad = (uint)maxOutput - len;\n+\n+            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
        "comment_created_at": "2025-07-01T01:56:11+00:00",
        "comment_author": "vcsjones",
        "comment_body": "`CRYPTO_memcmp` is fixed-time. What am I missing?",
        "pr_file_module": null
      },
      {
        "comment_id": "2176284703",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117181,
        "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
        "discussion_id": "2176155539",
        "commented_code": "@@ -33,6 +35,470 @@ protected Aes()\n             return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n         }\n \n+        /// <summary>\n+        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n+        ///   Algorithm for the specified plaintext length.\n+        /// </summary>\n+        /// <param name=\"plaintextLengthInBytes\">\n+        ///   The length of the plaintext to be wrapped, in bytes.\n+        /// </param>\n+        /// <returns>\n+        ///   The padded length of the key wrap for the specified plaintext.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentOutOfRangeException\">\n+        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n+        /// </exception>\n+        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n+        {\n+            if (plaintextLengthInBytes <= 0)\n+            {\n+                throw new ArgumentOutOfRangeException(\n+                    nameof(plaintextLengthInBytes),\n+                    \"Plaintext length must be positive.\");\n+            }\n+\n+            checked\n+            {\n+                int blocks = (plaintextLengthInBytes + 7) / 8;\n+                return (blocks + 1) * 8;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n+        {\n+            ArgumentNullException.ThrowIfNull(plaintext);\n+\n+            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n+            byte[] output = new byte[outputLength];\n+            EncryptKeyWrapPaddedCore(plaintext, output);\n+            return output;\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n+        ///   writing the result to a specified buffer.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n+        ///   <para>-or-</para>\n+        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n+        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n+\n+            if (destination.Length != requiredLength)\n+            {\n+                throw new ArgumentException(\n+                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n+                    nameof(destination));\n+            }\n+\n+            if (plaintext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            EncryptKeyWrapPaddedCore(plaintext, destination);\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n+        {\n+            ArgumentNullException.ThrowIfNull(ciphertext);\n+\n+            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n+            {\n+                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n+                return lease.Span.Slice(0, written).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para>\n+        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///     to the output of the Key Wrap with Padding algorithm.\n+        ///   </para>\n+        ///   <para>-or-</para>\n+        ///   <para>\n+        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n+        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n+        ///     too short to hold the unwrapped key.\n+        ///   </para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n+            {\n+                return bytesWritten;\n+            }\n+\n+            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n+        }\n+\n+        /// <summary>\n+        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n+        ///   AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <param name=\"bytesWritten\">\n+        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n+        ///   This parameter is treated as uninitialized.\n+        /// </param>\n+        /// <returns>\n+        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n+        ///   otherwise, <see langword=\"false\" />.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            int maxOutput = ciphertext.Length - 8;\n+            int minOutput = maxOutput - 7;\n+\n+            if (destination.Length < minOutput)\n+            {\n+                bytesWritten = 0;\n+                return false;\n+            }\n+\n+            if (destination.Length > maxOutput)\n+            {\n+                destination = destination.Slice(0, maxOutput);\n+            }\n+\n+            if (ciphertext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n+            bool rented = !lease.Span.Overlaps(destination);\n+\n+            try\n+            {\n+                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n+\n+                if (written < minOutput || written > maxOutput)\n+                {\n+                    // The override has violated the rules of the algorithm.\n+                    throw new CryptographicException();\n+                }\n+\n+                if (written > destination.Length)\n+                {\n+                    bytesWritten = 0;\n+                    return false;\n+                }\n+\n+                if (rented)\n+                {\n+                    lease.Span.Slice(0, written).CopyTo(destination);\n+                }\n+\n+                // If destination was long enough, and we didn't rent,\n+                // our software implementation will guarantee that\n+                // destination is cleared beyond the written length\n+                // (because that had to be empty, or zeros for padding).\n+                //\n+                // An override might only copy 0..written into destination,\n+                // so unconditionally clear the remainder of destination so\n+                // it is consistent across rented/unrented base/derived.\n+                destination.Slice(written).Clear();\n+\n+                bytesWritten = written;\n+                return true;\n+            }\n+            catch\n+            {\n+                // It's only important to clear destination if it was not rented...\n+                // but rather than have some exceptions clear it, and some not, always clear.`\n+                CryptographicOperations.ZeroMemory(destination);\n+                throw;\n+            }\n+            finally\n+            {\n+                lease.Dispose();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"source\">The data to unwrap.</param>\n+        /// <param name=\"destination\">\n+        ///   The buffer to receive the unwrapped key.\n+        ///   </param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <remarks>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n+        ///   </para>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n+        ///     so any valid value will always fit.\n+        ///   </para>\n+        /// </remarks>\n+        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n+        {\n+            ulong iv;\n+\n+            if (source.Length == 16)\n+            {\n+                Span<byte> decrypt = stackalloc byte[16];\n+                DecryptEcb(source, decrypt, PaddingMode.None);\n+                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n+                decrypt.Slice(8).CopyTo(destination);\n+            }\n+            else\n+            {\n+                iv = Rfc3394Unwrap(source, destination);\n+            }\n+\n+            uint len = (uint)iv;\n+            ulong header = iv >> 32;\n+            int slen = (int)len;\n+\n+            // Only 0..7 padding bytes are allowed.\n+            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n+            // If len == maxOutput, pad is 0, which is valid.\n+            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n+            // If len is any lower than that, then pad is more than 7, which is invalid.\n+            int maxOutput = source.Length - 8;\n+            uint pad = (uint)maxOutput - len;\n+\n+            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
        "comment_created_at": "2025-07-01T02:21:03+00:00",
        "comment_author": "vcsjones",
        "comment_body": "My general intuition here is that since this basically serves as an authentication tag. See SP800-38F. Not constant time checking the \"tag\" feels off.",
        "pr_file_module": null
      },
      {
        "comment_id": "2177972821",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 117181,
        "pr_file": "src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/Aes.cs",
        "discussion_id": "2176155539",
        "commented_code": "@@ -33,6 +35,470 @@ protected Aes()\n             return (Aes?)CryptoConfig.CreateFromName(algorithmName);\n         }\n \n+        /// <summary>\n+        ///   Computes the output length of the IETF RFC 5649 AES Key Wrap with Padding\n+        ///   Algorithm for the specified plaintext length.\n+        /// </summary>\n+        /// <param name=\"plaintextLengthInBytes\">\n+        ///   The length of the plaintext to be wrapped, in bytes.\n+        /// </param>\n+        /// <returns>\n+        ///   The padded length of the key wrap for the specified plaintext.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentOutOfRangeException\">\n+        ///   <paramref name=\"plaintextLengthInBytes\"/> is less than or equal to zero.\n+        /// </exception>\n+        public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes)\n+        {\n+            if (plaintextLengthInBytes <= 0)\n+            {\n+                throw new ArgumentOutOfRangeException(\n+                    nameof(plaintextLengthInBytes),\n+                    \"Plaintext length must be positive.\");\n+            }\n+\n+            checked\n+            {\n+                int blocks = (plaintextLengthInBytes + 7) / 8;\n+                return (blocks + 1) * 8;\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentNullException\"><paramref name=\"plaintext\"/> is <see langword=\"null\" />.</exception>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(byte[] plaintext)\n+        {\n+            ArgumentNullException.ThrowIfNull(plaintext);\n+\n+            return EncryptKeyWrapPadded(new ReadOnlySpan<byte>(plaintext));\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <returns>The wrapped data.</returns>\n+        /// <exception cref=\"ArgumentException\"><paramref name=\"plaintext\"/> is empty.</exception>\n+        /// <exception cref=\"CryptographicException\">An error occurred during the cryptographic operation.</exception>\n+        public byte[] EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int outputLength = GetKeyWrapPaddedLength(plaintext.Length);\n+            byte[] output = new byte[outputLength];\n+            EncryptKeyWrapPaddedCore(plaintext, output);\n+            return output;\n+        }\n+\n+        /// <summary>\n+        ///   Wraps a key using the IETF RFC 5649 AES Key Wrap with Padding algorithm,\n+        ///   writing the result to a specified buffer.\n+        /// </summary>\n+        /// <param name=\"plaintext\">The data to wrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the wrapped data.</param>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para><paramref name=\"plaintext\"/> is empty.</para>\n+        ///   <para>-or-</para>\n+        ///   <para><paramref name=\"destination\"/> is not precisely sized.</para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"plaintext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <seealso cref=\"GetKeyWrapPaddedLength\"/>\n+        public void EncryptKeyWrapPadded(ReadOnlySpan<byte> plaintext, Span<byte> destination)\n+        {\n+            if (plaintext.IsEmpty)\n+                throw new ArgumentException(SR.Arg_EmptySpan, nameof(plaintext));\n+\n+            int requiredLength = GetKeyWrapPaddedLength(plaintext.Length);\n+\n+            if (destination.Length != requiredLength)\n+            {\n+                throw new ArgumentException(\n+                    SR.Format(SR.Argument_DestinationImprecise, requiredLength),\n+                    nameof(destination));\n+            }\n+\n+            if (plaintext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            EncryptKeyWrapPaddedCore(plaintext, destination);\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"Array.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(byte[] ciphertext)\n+        {\n+            ArgumentNullException.ThrowIfNull(ciphertext);\n+\n+            return DecryptKeyWrapPadded(new ReadOnlySpan<byte>(ciphertext));\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <returns>The unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        public byte[] DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            using (CryptoPoolLease lease = CryptoPoolLease.Rent(ciphertext.Length - 8, skipClear: true))\n+            {\n+                int written = DecryptKeyWrapPadded(ciphertext, lease.Span);\n+                return lease.Span.Slice(0, written).ToArray();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <para>\n+        ///     <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///     to the output of the Key Wrap with Padding algorithm.\n+        ///   </para>\n+        ///   <para>-or-</para>\n+        ///   <para>\n+        ///     <paramref name=\"destination\"/> has a <see cref=\"Span{T}.Length\"/> that is\n+        ///     more than 16 bytes shorter than <paramref name=\"ciphertext\"/>, thus guaranteed\n+        ///     too short to hold the unwrapped key.\n+        ///   </para>\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public int DecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            if (TryDecryptKeyWrapPadded(ciphertext, destination, out int bytesWritten))\n+            {\n+                return bytesWritten;\n+            }\n+\n+            throw new ArgumentException(SR.Argument_DestinationTooShort, nameof(destination));\n+        }\n+\n+        /// <summary>\n+        ///   Attempts to unwrap a key that was wrapped using the IETF RFC 5649\n+        ///   AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"ciphertext\">The data to unwrap.</param>\n+        /// <param name=\"destination\">The buffer to receive the unwrapped key.</param>\n+        /// <param name=\"bytesWritten\">\n+        ///   When this method returns, contains the number of bytes written to <paramref name=\"destination\"/>.\n+        ///   This parameter is treated as uninitialized.\n+        /// </param>\n+        /// <returns>\n+        ///   <see langword=\"true\" /> if <paramref name=\"destination\"/> is long enough to receive the unwrapped key;\n+        ///   otherwise, <see langword=\"false\" />.\n+        /// </returns>\n+        /// <exception cref=\"ArgumentNullException\">\n+        ///   <paramref name=\"ciphertext\"/> is <see langword=\"null\" />.\n+        /// </exception>\n+        /// <exception cref=\"ArgumentException\">\n+        ///   <paramref name=\"ciphertext\"/> has a <see cref=\"ReadOnlySpan{T}.Length\"/> that does not correspond\n+        ///   to the output of the Key Wrap with Padding algorithm.\n+        /// </exception>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para><paramref name=\"ciphertext\"/> and <paramref name=\"destination\"/> overlap.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        public bool TryDecryptKeyWrapPadded(ReadOnlySpan<byte> ciphertext, Span<byte> destination, out int bytesWritten)\n+        {\n+            if (ciphertext.Length < 16 || ciphertext.Length % 8 != 0)\n+                throw new ArgumentException(SR.Cryptography_KeyWrap_InvalidLength, nameof(ciphertext));\n+\n+            int maxOutput = ciphertext.Length - 8;\n+            int minOutput = maxOutput - 7;\n+\n+            if (destination.Length < minOutput)\n+            {\n+                bytesWritten = 0;\n+                return false;\n+            }\n+\n+            if (destination.Length > maxOutput)\n+            {\n+                destination = destination.Slice(0, maxOutput);\n+            }\n+\n+            if (ciphertext.Overlaps(destination))\n+            {\n+                throw new CryptographicException(SR.Cryptography_OverlappingBuffers);\n+            }\n+\n+            CryptoPoolLease lease = CryptoPoolLease.RentConditionally(maxOutput, destination, skipClearIfNotRented: true);\n+            bool rented = !lease.Span.Overlaps(destination);\n+\n+            try\n+            {\n+                int written = DecryptKeyWrapPaddedCore(ciphertext, lease.Span);\n+\n+                if (written < minOutput || written > maxOutput)\n+                {\n+                    // The override has violated the rules of the algorithm.\n+                    throw new CryptographicException();\n+                }\n+\n+                if (written > destination.Length)\n+                {\n+                    bytesWritten = 0;\n+                    return false;\n+                }\n+\n+                if (rented)\n+                {\n+                    lease.Span.Slice(0, written).CopyTo(destination);\n+                }\n+\n+                // If destination was long enough, and we didn't rent,\n+                // our software implementation will guarantee that\n+                // destination is cleared beyond the written length\n+                // (because that had to be empty, or zeros for padding).\n+                //\n+                // An override might only copy 0..written into destination,\n+                // so unconditionally clear the remainder of destination so\n+                // it is consistent across rented/unrented base/derived.\n+                destination.Slice(written).Clear();\n+\n+                bytesWritten = written;\n+                return true;\n+            }\n+            catch\n+            {\n+                // It's only important to clear destination if it was not rented...\n+                // but rather than have some exceptions clear it, and some not, always clear.`\n+                CryptographicOperations.ZeroMemory(destination);\n+                throw;\n+            }\n+            finally\n+            {\n+                lease.Dispose();\n+            }\n+        }\n+\n+        /// <summary>\n+        ///   Unwraps a key that was wrapped using the IETF RFC 5649 AES Key Wrap with Padding algorithm.\n+        /// </summary>\n+        /// <param name=\"source\">The data to unwrap.</param>\n+        /// <param name=\"destination\">\n+        ///   The buffer to receive the unwrapped key.\n+        ///   </param>\n+        /// <returns>The number of bytes in the unwrapped key.</returns>\n+        /// <exception cref=\"CryptographicException\">\n+        ///   <para>The unwrap algorithm failed to unwrap the ciphertext.</para>\n+        ///   <para>-or-</para>\n+        ///   <para>An error occurred during the cryptographic operation.</para>\n+        /// </exception>\n+        /// <remarks>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"source\"/> is pre-validated to be at least 16 bytes long and a multiple of 8 bytes.\n+        ///   </para>\n+        ///   <para>\n+        ///     When called by the base class,\n+        ///     <paramref name=\"destination\"/> will always be exactly 8 bytes shorter than <paramref name=\"source\"/>,\n+        ///     so any valid value will always fit.\n+        ///   </para>\n+        /// </remarks>\n+        protected virtual int DecryptKeyWrapPaddedCore(ReadOnlySpan<byte> source, Span<byte> destination)\n+        {\n+            ulong iv;\n+\n+            if (source.Length == 16)\n+            {\n+                Span<byte> decrypt = stackalloc byte[16];\n+                DecryptEcb(source, decrypt, PaddingMode.None);\n+                iv = BinaryPrimitives.ReadUInt64BigEndian(decrypt);\n+                decrypt.Slice(8).CopyTo(destination);\n+            }\n+            else\n+            {\n+                iv = Rfc3394Unwrap(source, destination);\n+            }\n+\n+            uint len = (uint)iv;\n+            ulong header = iv >> 32;\n+            int slen = (int)len;\n+\n+            // Only 0..7 padding bytes are allowed.\n+            // If len > maxOutput, that was \"negative\" padding, which is a large positive uint, so \"more than 7\".\n+            // If len == maxOutput, pad is 0, which is valid.\n+            // If len < maxOutput by less than 8, then pad is in the range 0..7, which is valid.\n+            // If len is any lower than that, then pad is more than 7, which is invalid.\n+            int maxOutput = source.Length - 8;\n+            uint pad = (uint)maxOutput - len;\n+\n+            if (header != 0xA65959A6UL || pad > 7 || destination.Slice(slen).IndexOfAnyExcept((byte)0) >= 0)",
        "comment_created_at": "2025-07-01T15:55:16+00:00",
        "comment_author": "bartonjs",
        "comment_body": "OK, so you mean just on the A65959A6 part.  My reference to OSSL source is that they don't hide the difference between that being wrong, the padding count being out of bounds, or any padding bytes not being 0x00.\r\n\r\nSwitched the header comparison to use `uint`, so now it's a single instruction on 32-bit platforms as well as 64-bit.",
        "pr_file_module": null
      }
    ]
  }
]
