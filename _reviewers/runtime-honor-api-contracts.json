[
  {
    "discussion_id": "2159692964",
    "pr_number": 116555,
    "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
    "created_at": "2025-06-20T21:40:20+00:00",
    "commented_code": "﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text;\nusing ILLink.Shared.TrimAnalysis;\nusing Mono.Cecil;\nusing Mono.CompilerServices.SymbolWriter;\nusing Mono.Linker.Steps;\n\nusing CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n\nnamespace Mono.Linker\n{\n\tsealed class TypeMapHandler\n\t{\n\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n\n\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n\n\t\t// [source type: [type map group: custom attributes]]\n\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n\n\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n\t\t// [type map group: custom attributes]\n\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n\n\t\tLinkContext _context = null!;\n\t\tMarkStep _markStep = null!;\n\n\t\tpublic TypeMapHandler ()\n\t\t{\n\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n\t\t}\n\n\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n\t\t{\n\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n\t\t\t\t\tGenericArguments: [_]\n\t\t\t\t}) {\n\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n\t\t\t\t}\n\n\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n\t\t\t\t\t// Invalid attribute, skip it.\n\t\t\t\t\t// Let the runtime handle the failure.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n\t\t\t}\n\n\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n\t\t}\n\n\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n\t\t{\n\t\t\t_context = context;\n\t\t\t_markStep = markStep;\n\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n\t\t}\n\n\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n\t\t{\n\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tforeach (var entry in pendingEntries) {\n\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n\t\t\t}\n\t\t}\n\n\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n\t\t{\n\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tforeach (var entry in pendingEntries) {\n\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n\t\t\t}\n\t\t}\n\n\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n\t\t{\n\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n\n\t\t\t// Mark the target type as instantiated\n\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n\t\t}\n\n\t\tpublic void ProcessType (TypeDefinition definition)\n\t\t{\n\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n\t\t}\n\n\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n\t\t{\n\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n\n\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n\t\t\t\t\t\tforeach (var attr in attributes) {\n\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue.AddRange (attributes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n\t\t{\n\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n\t\t}\n\n\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n\t\t{\n\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2159692964",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-06-20T21:40:20+00:00",
        "comment_author": "sbomer",
        "comment_body": "This comment doesn't seem to match the check",
        "pr_file_module": null
      },
      {
        "comment_id": "2159708993",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-06-20T22:00:20+00:00",
        "comment_author": "sbomer",
        "comment_body": "Currently it looks like the two forms of the external type map attribute both use the same logic for `trimTarget` and `target` - is that intentional? My understanding was that the `trimTarget` variant was supposed to be the only one that participates in the conditional logic, and the `(string, Type target)` variant was supposed to be kept whether or not the `target` type is otherwise marked.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159720349",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-06-20T22:17:06+00:00",
        "comment_author": "jkoritzinsky",
        "comment_body": "I implemented it in this way with the NativeAOT implementation and updated the design doc (commited in that PR) with the adjusted rule.\r\n\r\nI believe that with the expanded rules for including `trimTarget` entries, it's impossible to tell the difference in a correctly-written app if the `(string, Type)` overload always preserves or only does when the `Type` is marked.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159745621",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-06-20T22:58:35+00:00",
        "comment_author": "sbomer",
        "comment_body": "If there's an instance of the `(string, Type)` attribute with an otherwise unused type, I am expecting the external type mapping to contain this entry. Whereas for an instance of the `(string, Type target, Type trimTarget)` overload with an otherwise unused trimTarget, I expect it not to contain this entry. Is that right? @AaronRobinsonMSFT",
        "pr_file_module": null
      },
      {
        "comment_id": "2177783511",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-07-01T14:37:41+00:00",
        "comment_author": "AaronRobinsonMSFT",
        "comment_body": "> Whereas for an instance of the (string, Type target, Type trimTarget) overload with an otherwise unused trimTarget, I expect it not to contain this entry. Is that right? @AaronRobinsonMSFT\r\n\r\n@sbomer Yes, this is the expectation. The non-`trimTarget` overload was added as an escape hatch and is expected to retain the entry. At least that was the plan when we designed this.\r\n\r\n> I implemented it in this way with the NativeAOT implementation and updated the design doc (commited in that PR) with the adjusted rule.\r\n\r\n@jkoritzinsky Did you consult anyone on this point? I don't recall a discussion and the unconditional inclusion was the last discussion point if I recall.",
        "pr_file_module": null
      },
      {
        "comment_id": "2177881233",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-07-01T15:18:23+00:00",
        "comment_author": "jkoritzinsky",
        "comment_body": "I don't recall other than the update in the design doc in my prior PR. (I assumed PR approval meant it was okay.) I'll fix up the design doc and update the implementations.",
        "pr_file_module": null
      },
      {
        "comment_id": "2178155692",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116555,
        "pr_file": "src/tools/illink/src/linker/Linker/TypeMapHandler.cs",
        "discussion_id": "2159692964",
        "commented_code": "@@ -0,0 +1,215 @@\n+﻿// Copyright (c) .NET Foundation and contributors. All rights reserved.\n+// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.Text;\n+using ILLink.Shared.TrimAnalysis;\n+using Mono.Cecil;\n+using Mono.CompilerServices.SymbolWriter;\n+using Mono.Linker.Steps;\n+\n+using CustomAttributeWithOrigin = (Mono.Cecil.CustomAttribute Attribute, Mono.Cecil.AssemblyDefinition Origin);\n+\n+namespace Mono.Linker\n+{\n+\tsealed class TypeMapHandler\n+\t{\n+\t\treadonly TypeMapResolver _lazyTypeMapResolver;\n+\n+\t\t// [trim target: [type map group: custom attributes with assembly origin]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedExternalTypeMapEntries = [];\n+\n+\t\t// [source type: [type map group: custom attributes]]\n+\t\treadonly Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> _unmarkedProxyTypeMapEntries = [];\n+\n+\t\t// CustomAttributes that we want to mark when the type mapping APIs are used.\n+\t\t// [type map group: custom attributes]\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingExternalTypeMapEntries = [];\n+\t\tDictionary<TypeReference, List<CustomAttributeWithOrigin>> _pendingProxyTypeMapEntries = [];\n+\t\tHashSet<TypeReference> _referencedExternalTypeMaps = [];\n+\t\tHashSet<TypeReference> _referencedProxyTypeMaps = [];\n+\n+\t\tLinkContext _context = null!;\n+\t\tMarkStep _markStep = null!;\n+\n+\t\tpublic TypeMapHandler ()\n+\t\t{\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (new HashSet<AssemblyNameReference>());\n+\t\t}\n+\n+\t\tpublic TypeMapHandler (AssemblyDefinition entryPointAssembly)\n+\t\t{\n+\t\t\tHashSet<AssemblyNameReference> assemblies = [AssemblyNameReference.Parse (entryPointAssembly.FullName)];\n+\t\t\tforeach (var attr in entryPointAssembly.CustomAttributes) {\n+\t\t\t\tif (attr.AttributeType is not GenericInstanceType {\n+\t\t\t\t\tNamespace: \"System.Runtime.InteropServices\",\n+\t\t\t\t\tGenericArguments: [_]\n+\t\t\t\t}) {\n+\t\t\t\t\tcontinue; // Only interested in System.Runtime.InteropServices attributes\n+\t\t\t\t}\n+\n+\t\t\t\tif (attr.AttributeType.Name != \"TypeMapAssemblyTarget`1\"\n+\t\t\t\t\t|| attr.ConstructorArguments[0].Value is not string str) {\n+\t\t\t\t\t// Invalid attribute, skip it.\n+\t\t\t\t\t// Let the runtime handle the failure.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tassemblies.Add (AssemblyNameReference.Parse(str));\n+\t\t\t}\n+\n+\t\t\t_lazyTypeMapResolver = new TypeMapResolver (assemblies);\n+\t\t}\n+\n+\t\tpublic void Initialize (LinkContext context, MarkStep markStep)\n+\t\t{\n+\t\t\t_context = context;\n+\t\t\t_markStep = markStep;\n+\t\t\t_lazyTypeMapResolver.Resolve (context, this);\n+\t\t}\n+\n+\t\tpublic void ProcessExternalTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedExternalTypeMaps.Add(typeMapGroup);\n+\t\t\tif (!_pendingExternalTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessProxyTypeMapGroupSeen (MethodDefinition callingMethod, TypeReference typeMapGroup)\n+\t\t{\n+\t\t\t_referencedProxyTypeMaps.Add (typeMapGroup);\n+\t\t\tif (!_pendingProxyTypeMapEntries.Remove (typeMapGroup, out List<CustomAttributeWithOrigin>? pendingEntries)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\tforeach (var entry in pendingEntries) {\n+\t\t\t\tMarkTypeMapAttribute (entry, new DependencyInfo (DependencyKind.TypeMapEntry, callingMethod));\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid MarkTypeMapAttribute (CustomAttributeWithOrigin entry, DependencyInfo info)\n+\t\t{\n+\t\t\t_markStep.MarkCustomAttribute (entry.Attribute, info, new MessageOrigin (entry.Origin));\n+\n+\t\t\t// Mark the target type as instantiated\n+\t\t\tTypeReference targetType = (TypeReference) entry.Attribute.ConstructorArguments[1].Value;\n+\t\t\tif (targetType is not null && _context.Resolve (targetType) is TypeDefinition targetTypeDef)\n+\t\t\t\t_context.Annotations.MarkInstantiated (targetTypeDef);\n+\t\t}\n+\n+\t\tpublic void ProcessType (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedExternalTypeMapEntries, _referencedExternalTypeMaps, _pendingExternalTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid RecordTargetTypeSeen (TypeDefinition targetType, Dictionary<TypeDefinition, Dictionary<TypeReference, List<CustomAttributeWithOrigin>>> unmarkedTypeMapAttributes, HashSet<TypeReference> referenceTypeMapGroups, Dictionary<TypeReference, List<CustomAttributeWithOrigin>> typeMapAttributesPendingUniverseMarking)\n+\t\t{\n+\t\t\tif (unmarkedTypeMapAttributes.Remove (targetType, out Dictionary<TypeReference, List<CustomAttributeWithOrigin>>? entries)) {\n+\t\t\t\tforeach (var (typeMapGroup, attributes) in entries) {\n+\n+\t\t\t\t\tif (referenceTypeMapGroups.Contains (typeMapGroup)) {\n+\t\t\t\t\t\tforeach (var attr in attributes) {\n+\t\t\t\t\t\t\tMarkTypeMapAttribute (attr, new DependencyInfo (DependencyKind.TypeMapEntry, targetType));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (!typeMapAttributesPendingUniverseMarking.TryGetValue (typeMapGroup, out List<CustomAttributeWithOrigin>? value)) {\n+\t\t\t\t\t\ttypeMapAttributesPendingUniverseMarking[typeMapGroup] = [.. attributes];\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tvalue.AddRange (attributes);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void ProcessInstantiated (TypeDefinition definition)\n+\t\t{\n+\t\t\tRecordTargetTypeSeen (definition, _unmarkedProxyTypeMapEntries, _referencedProxyTypeMaps, _pendingProxyTypeMapEntries);\n+\t\t}\n+\n+\t\tvoid AddExternalTypeMapEntry (TypeReference group, CustomAttributeWithOrigin attr)\n+\t\t{\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, _, { Value: TypeReference trimTarget }]) {\n+\t\t\t\tRecordTypeMapEntry (attr, group, trimTarget, _unmarkedExternalTypeMapEntries);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (attr.Attribute.ConstructorArguments is [_, { Value: TypeReference target }]) {\n+\t\t\t\t// This is a TypeMapAssemblyTargetAttribute, which has a single type argument.",
        "comment_created_at": "2025-07-01T17:17:24+00:00",
        "comment_author": "jkoritzinsky",
        "comment_body": "Fixed the ILLink and NAOT implementations (as well as the design doc).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1491416713",
    "pr_number": 98510,
    "pr_file": "src/libraries/System.Private.CoreLib/src/System/Numerics/INumber.cs",
    "created_at": "2024-02-15T18:05:25+00:00",
    "commented_code": "{\n            if (value != TSelf.Zero)\n            {\n                if (TSelf.IsNaN(value))\n                {\n                    ThrowHelper.ThrowArithmeticException(SR.Arithmetic_NaN);\n                }",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "1491416713",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 98510,
        "pr_file": "src/libraries/System.Private.CoreLib/src/System/Numerics/INumber.cs",
        "discussion_id": "1491416713",
        "commented_code": "@@ -160,6 +165,10 @@ static virtual int Sign(TSelf value)\n         {\n             if (value != TSelf.Zero)\n             {\n+                if (TSelf.IsNaN(value))\n+                {\n+                    ThrowHelper.ThrowArithmeticException(SR.Arithmetic_NaN);\n+                }",
        "comment_created_at": "2024-02-15T18:05:25+00:00",
        "comment_author": "tannergooding",
        "comment_body": "Sign is supposed to throw for NaN (unlike CopySign which does not). It's a historical behavior/contract of the API.",
        "pr_file_module": null
      }
    ]
  }
]