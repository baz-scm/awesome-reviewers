---
title: Use utility macros
description: Use predefined utility macros for common operations instead of repeating
  manual calculations throughout your code. This improves readability, consistency,
  and reduces the likelihood of errors in calculations.
repository: dotnet/runtime
label: Code Style
language: C
comments_count: 2
repository_stars: 16578
---

Use predefined utility macros for common operations instead of repeating manual calculations throughout your code. This improves readability, consistency, and reduces the likelihood of errors in calculations.

For example, instead of manually calculating array sizes:

```c
// Don't do this
if (wcsncmp(path, DevicePathPrefix, sizeof(DevicePathPrefix) / sizeof(WCHAR) - 1) == 0)
    return NULL;

// Do this instead
if (wcsncmp(path, DevicePathPrefix, STRING_SIZE(DevicePathPrefix) - 1) == 0)
    return NULL;
```

Check for existing utility macros in your project (such as `ARRAY_SIZE`, `STRING_SIZE` in util.h) before writing common calculations. This practice ensures consistent implementation across the codebase and makes future maintenance easier by centralizing any changes needed to these calculation patterns.


[
  {
    "discussion_id": "2114411150",
    "pr_number": 116096,
    "pr_file": "src/native/minipal/file.c",
    "created_at": "2025-05-29T17:20:27+00:00",
    "commented_code": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n#include <stdint.h>\n#include <minipal/file.h>\n\n#ifdef TARGET_WINDOWS\n#include <Windows.h>\n\n#define ExtendedPrefix L\"\\\\\\\\?\\\\\"\n#define DevicePathPrefix L\"\\\\\\\\.\\\\\"\n#define UNCExtendedPathPrefix L\"\\\\\\\\?\\\\UNC\\\\\"\n#define UNCPathPrefix L\"\\\\\\\\\"\n#define DIRECTORY_SEPARATOR_CHAR L'\\\\'\n#define ALT_DIRECTORY_SEPARATOR_CHAR L'/'\n#define VOLUME_SEPARATOR_CHAR L':'\n\nstatic bool IsDirectorySeparator(WCHAR ch)\n{\n    return (ch == DIRECTORY_SEPARATOR_CHAR) || (ch == ALT_DIRECTORY_SEPARATOR_CHAR);\n}\n\nstatic bool IsPathNotFullyQualified(WCHAR* path)\n{\n    // Relative here means it could be relative to current directory on the relevant drive\n    // NOTE: Relative segments ( \\..\\) are not considered relative\n    // Returns true if the path specified is relative to the current drive or working directory.\n    // Returns false if the path is fixed to a specific drive or UNC path.  This method does no\n    // validation of the path (URIs will be returned as relative as a result).\n    // Handles paths that use the alternate directory separator.  It is a frequent mistake to\n    // assume that rooted paths (Path.IsPathRooted) are not relative.  This isn't the case.\n\n    if ((path[0] == L'\\0') || (path[1] == L'\\0'))\n    {\n        return true;  // It isn't fixed, it must be relative.  There is no way to specify a fixed path with one character (or less).\n    }\n\n    if (IsDirectorySeparator(path[0]))\n    {\n        return !IsDirectorySeparator(path[1]); // There is no valid way to specify a relative path with two initial slashes\n    }\n    \n    return !((wcslen(path) >= 3)           //The only way to specify a fixed path that doesn't begin with two slashes is the drive, colon, slash format- i.e. \"C:\\\"\n            && (path[1] == VOLUME_SEPARATOR_CHAR)\n            && IsDirectorySeparator(path[2]));\n}\n\n// Returns newly allocated path if needs to expand the path, or NULL if no need.\n// The normalization examples are :\n//  C:\\foo\\<long>\\bar   => \\\\?\\C:\\foo\\<long>\\bar\n//  \\\\server\\<long>\\bar => \\\\?\\UNC\\server\\<long>\\bar\nstatic WCHAR* NormalizePath(const WCHAR* path)\n{\n    if (path[0] == L'\\0')\n        return NULL;\n\n    if (wcsncmp(path, DevicePathPrefix, sizeof(DevicePathPrefix) / sizeof(WCHAR) - 1) == 0)",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2114411150",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116096,
        "pr_file": "src/native/minipal/file.c",
        "discussion_id": "2114411150",
        "commented_code": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#include <stdint.h>\n+#include <minipal/file.h>\n+\n+#ifdef TARGET_WINDOWS\n+#include <Windows.h>\n+\n+#define ExtendedPrefix L\"\\\\\\\\?\\\\\"\n+#define DevicePathPrefix L\"\\\\\\\\.\\\\\"\n+#define UNCExtendedPathPrefix L\"\\\\\\\\?\\\\UNC\\\\\"\n+#define UNCPathPrefix L\"\\\\\\\\\"\n+#define DIRECTORY_SEPARATOR_CHAR L'\\\\'\n+#define ALT_DIRECTORY_SEPARATOR_CHAR L'/'\n+#define VOLUME_SEPARATOR_CHAR L':'\n+\n+static bool IsDirectorySeparator(WCHAR ch)\n+{\n+    return (ch == DIRECTORY_SEPARATOR_CHAR) || (ch == ALT_DIRECTORY_SEPARATOR_CHAR);\n+}\n+\n+static bool IsPathNotFullyQualified(WCHAR* path)\n+{\n+    // Relative here means it could be relative to current directory on the relevant drive\n+    // NOTE: Relative segments ( \\..\\) are not considered relative\n+    // Returns true if the path specified is relative to the current drive or working directory.\n+    // Returns false if the path is fixed to a specific drive or UNC path.  This method does no\n+    // validation of the path (URIs will be returned as relative as a result).\n+    // Handles paths that use the alternate directory separator.  It is a frequent mistake to\n+    // assume that rooted paths (Path.IsPathRooted) are not relative.  This isn't the case.\n+\n+    if ((path[0] == L'\\0') || (path[1] == L'\\0'))\n+    {\n+        return true;  // It isn't fixed, it must be relative.  There is no way to specify a fixed path with one character (or less).\n+    }\n+\n+    if (IsDirectorySeparator(path[0]))\n+    {\n+        return !IsDirectorySeparator(path[1]); // There is no valid way to specify a relative path with two initial slashes\n+    }\n+    \n+    return !((wcslen(path) >= 3)           //The only way to specify a fixed path that doesn't begin with two slashes is the drive, colon, slash format- i.e. \"C:\\\"\n+            && (path[1] == VOLUME_SEPARATOR_CHAR)\n+            && IsDirectorySeparator(path[2]));\n+}\n+\n+// Returns newly allocated path if needs to expand the path, or NULL if no need.\n+// The normalization examples are :\n+//  C:\\foo\\<long>\\bar   => \\\\?\\C:\\foo\\<long>\\bar\n+//  \\\\server\\<long>\\bar => \\\\?\\UNC\\server\\<long>\\bar\n+static WCHAR* NormalizePath(const WCHAR* path)\n+{\n+    if (path[0] == L'\\0')\n+        return NULL;\n+\n+    if (wcsncmp(path, DevicePathPrefix, sizeof(DevicePathPrefix) / sizeof(WCHAR) - 1) == 0)",
        "comment_created_at": "2025-05-29T17:20:27+00:00",
        "comment_author": "AaronRobinsonMSFT",
        "comment_body": "`util.h` under `minipal` has a number of macros to use here (for example, `ARRAY_SIZE`, `STRING_SIZE`).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2114401248",
    "pr_number": 116096,
    "pr_file": "src/native/minipal/file.c",
    "created_at": "2025-05-29T17:14:44+00:00",
    "commented_code": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n#include <stdint.h>\n#include <minipal/file.h>\n\n#ifdef TARGET_WINDOWS\n#include <Windows.h>\n\n#define ExtendedPrefix L\"\\\\\\\\?\\\\\"\n#define DevicePathPrefix L\"\\\\\\\\.\\\\\"\n#define UNCExtendedPathPrefix L\"\\\\\\\\?\\\\UNC\\\\\"\n#define UNCPathPrefix L\"\\\\\\\\\"\n#define DIRECTORY_SEPARATOR_CHAR L'\\\\'\n#define ALT_DIRECTORY_SEPARATOR_CHAR L'/'\n#define VOLUME_SEPARATOR_CHAR L':'\n\nstatic bool IsDirectorySeparator(WCHAR ch)\n{\n    return (ch == DIRECTORY_SEPARATOR_CHAR) || (ch == ALT_DIRECTORY_SEPARATOR_CHAR);\n}\n\nstatic bool IsPathNotFullyQualified(WCHAR* path)\n{\n    // Relative here means it could be relative to current directory on the relevant drive\n    // NOTE: Relative segments ( \\..\\) are not considered relative\n    // Returns true if the path specified is relative to the current drive or working directory.\n    // Returns false if the path is fixed to a specific drive or UNC path.  This method does no\n    // validation of the path (URIs will be returned as relative as a result).\n    // Handles paths that use the alternate directory separator.  It is a frequent mistake to\n    // assume that rooted paths (Path.IsPathRooted) are not relative.  This isn't the case.\n\n    if ((path[0] == L'\\0') || (path[1] == L'\\0'))\n    {\n        return true;  // It isn't fixed, it must be relative.  There is no way to specify a fixed path with one character (or less).\n    }\n\n    if (IsDirectorySeparator(path[0]))\n    {\n        return !IsDirectorySeparator(path[1]); // There is no valid way to specify a relative path with two initial slashes\n    }\n    \n    return !((wcslen(path) >= 3)           //The only way to specify a fixed path that doesn't begin with two slashes is the drive, colon, slash format- i.e. \"C:\\\"\n            && (path[1] == VOLUME_SEPARATOR_CHAR)\n            && IsDirectorySeparator(path[2]));\n}\n\n// Returns newly allocated path if needs to expand the path, or NULL if no need.\n// The normalization examples are :\n//  C:\\foo\\<long>\\bar   => \\\\?\\C:\\foo\\<long>\\bar\n//  \\\\server\\<long>\\bar => \\\\?\\UNC\\server\\<long>\\bar\nstatic WCHAR* NormalizePath(const WCHAR* path)\n{\n    if (path[0] == L'\\0')\n        return NULL;\n\n    if (wcsncmp(path, DevicePathPrefix, sizeof(DevicePathPrefix) / sizeof(WCHAR) - 1) == 0)\n        return NULL;\n\n    if (wcsncmp(path, ExtendedPrefix, sizeof(ExtendedPrefix) / sizeof(WCHAR) - 1) == 0)\n        return NULL;\n\n    if (wcsncmp(path, UNCExtendedPathPrefix, sizeof(UNCExtendedPathPrefix) / sizeof(WCHAR) - 1) == 0)\n        return NULL;\n\n    size_t length = wcslen(path);\n\n    if (!IsPathNotFullyQualified(path) && length < MAX_PATH)\n        return NULL;\n    \n    // Now the path will be normalized\n\n    size_t prefixLength = sizeof(ExtendedPrefix) / sizeof(WCHAR) - 1;\n    size_t bufferLength = length + prefixLength + 1;\n    WCHAR* buffer = (WCHAR*)malloc(bufferLength * sizeof(WCHAR));\n\n    if (!buffer)\n        return NULL;\n\n    DWORD retSize = GetFullPathNameW(path, (DWORD)(bufferLength - prefixLength), buffer + prefixLength, NULL);\n\n    if (retSize > bufferLength - prefixLength)\n    {\n        free(buffer);\n        bufferLength = retSize + prefixLength;\n        buffer = (WCHAR*)malloc(bufferLength * sizeof(WCHAR));\n\n        if (!buffer)\n            return NULL;\n\n        retSize = GetFullPathNameW(path, (DWORD)(bufferLength - prefixLength), buffer + prefixLength, NULL);\n    }\n\n    if (retSize <= 0)\n    {\n        free(buffer);\n        return NULL;\n    }\n\n    memcpy(buffer, ExtendedPrefix, bufferLength * sizeof(WCHAR));\n\n    return buffer;\n}\n#else // TARGET_WINDOWS\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <minipal/utf8.h>\n#include <minipal/strings.h>\n\n#if HAVE_STAT64\n#define stat_ stat64\n#define fstat_ fstat64\n#define lstat_ lstat64\n#else /* HAVE_STAT64 */\n#define stat_ stat\n#define fstat_ fstat\n#define lstat_ lstat\n#endif  /* HAVE_STAT64 */\n\n/* Magic number explanation:\n\n   To 1970:\n   Both epochs are Gregorian. 1970 - 1601 = 369. Assuming a leap\n   year every four years, 369 / 4 = 92. However, 1700, 1800, and 1900\n   were NOT leap years, so 89 leap years, 280 non-leap years.\n   89 * 366 + 280 * 365 = 134774 days between epochs. Of course\n   60 * 60 * 24 = 86400 seconds per day, so 134774 * 86400 =\n   11644473600 = SECS_BETWEEN_1601_AND_1970_EPOCHS.\n\n   To 2001:\n   Again, both epochs are Gregorian. 2001 - 1601 = 400. Assuming a leap\n   year every four years, 400 / 4 = 100. However, 1700, 1800, and 1900\n   were NOT leap years (2000 was because it was divisible by 400), so\n   97 leap years, 303 non-leap years.\n   97 * 366 + 303 * 365 = 146097 days between epochs. 146097 * 86400 =\n   12622780800 = SECS_BETWEEN_1601_AND_2001_EPOCHS.\n\n   This result is also confirmed in the MSDN documentation on how\n   to convert a time_t value to a win32 FILETIME.\n*/\nstatic const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;\nstatic const int64_t SECS_TO_100NS = 10000000; /* 10^7 */\n\nstatic uint64_t UnixTimeToWin32FileTime(struct timespec ts)\n{\n    return (uint64_t)(((int64_t)ts.tv_sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS +\n        (ts.tv_nsec / 100));\n}\n\n#endif // TARGET_WINDOWS\n\nbool minipal_file_get_attributes_utf16(const char16_t* path, minipal_file_attr_t* attributes)\n{\n#ifdef TARGET_WINDOWS\n    if (!path || !attributes)\n        return false;\n\n    WCHAR* extendedPath = NormalizePath(path);\n    if (extendedPath)\n        path = extendedPath;\n\n    WIN32_FILE_ATTRIBUTE_DATA faData;\n    bool ret = GetFileAttributesExW(path, GetFileExInfoStandard, &faData);",
    "repo_full_name": "dotnet/runtime",
    "discussion_comments": [
      {
        "comment_id": "2114401248",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116096,
        "pr_file": "src/native/minipal/file.c",
        "discussion_id": "2114401248",
        "commented_code": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#include <stdint.h>\n+#include <minipal/file.h>\n+\n+#ifdef TARGET_WINDOWS\n+#include <Windows.h>\n+\n+#define ExtendedPrefix L\"\\\\\\\\?\\\\\"\n+#define DevicePathPrefix L\"\\\\\\\\.\\\\\"\n+#define UNCExtendedPathPrefix L\"\\\\\\\\?\\\\UNC\\\\\"\n+#define UNCPathPrefix L\"\\\\\\\\\"\n+#define DIRECTORY_SEPARATOR_CHAR L'\\\\'\n+#define ALT_DIRECTORY_SEPARATOR_CHAR L'/'\n+#define VOLUME_SEPARATOR_CHAR L':'\n+\n+static bool IsDirectorySeparator(WCHAR ch)\n+{\n+    return (ch == DIRECTORY_SEPARATOR_CHAR) || (ch == ALT_DIRECTORY_SEPARATOR_CHAR);\n+}\n+\n+static bool IsPathNotFullyQualified(WCHAR* path)\n+{\n+    // Relative here means it could be relative to current directory on the relevant drive\n+    // NOTE: Relative segments ( \\..\\) are not considered relative\n+    // Returns true if the path specified is relative to the current drive or working directory.\n+    // Returns false if the path is fixed to a specific drive or UNC path.  This method does no\n+    // validation of the path (URIs will be returned as relative as a result).\n+    // Handles paths that use the alternate directory separator.  It is a frequent mistake to\n+    // assume that rooted paths (Path.IsPathRooted) are not relative.  This isn't the case.\n+\n+    if ((path[0] == L'\\0') || (path[1] == L'\\0'))\n+    {\n+        return true;  // It isn't fixed, it must be relative.  There is no way to specify a fixed path with one character (or less).\n+    }\n+\n+    if (IsDirectorySeparator(path[0]))\n+    {\n+        return !IsDirectorySeparator(path[1]); // There is no valid way to specify a relative path with two initial slashes\n+    }\n+    \n+    return !((wcslen(path) >= 3)           //The only way to specify a fixed path that doesn't begin with two slashes is the drive, colon, slash format- i.e. \"C:\\\"\n+            && (path[1] == VOLUME_SEPARATOR_CHAR)\n+            && IsDirectorySeparator(path[2]));\n+}\n+\n+// Returns newly allocated path if needs to expand the path, or NULL if no need.\n+// The normalization examples are :\n+//  C:\\foo\\<long>\\bar   => \\\\?\\C:\\foo\\<long>\\bar\n+//  \\\\server\\<long>\\bar => \\\\?\\UNC\\server\\<long>\\bar\n+static WCHAR* NormalizePath(const WCHAR* path)\n+{\n+    if (path[0] == L'\\0')\n+        return NULL;\n+\n+    if (wcsncmp(path, DevicePathPrefix, sizeof(DevicePathPrefix) / sizeof(WCHAR) - 1) == 0)\n+        return NULL;\n+\n+    if (wcsncmp(path, ExtendedPrefix, sizeof(ExtendedPrefix) / sizeof(WCHAR) - 1) == 0)\n+        return NULL;\n+\n+    if (wcsncmp(path, UNCExtendedPathPrefix, sizeof(UNCExtendedPathPrefix) / sizeof(WCHAR) - 1) == 0)\n+        return NULL;\n+\n+    size_t length = wcslen(path);\n+\n+    if (!IsPathNotFullyQualified(path) && length < MAX_PATH)\n+        return NULL;\n+    \n+    // Now the path will be normalized\n+\n+    size_t prefixLength = sizeof(ExtendedPrefix) / sizeof(WCHAR) - 1;\n+    size_t bufferLength = length + prefixLength + 1;\n+    WCHAR* buffer = (WCHAR*)malloc(bufferLength * sizeof(WCHAR));\n+\n+    if (!buffer)\n+        return NULL;\n+\n+    DWORD retSize = GetFullPathNameW(path, (DWORD)(bufferLength - prefixLength), buffer + prefixLength, NULL);\n+\n+    if (retSize > bufferLength - prefixLength)\n+    {\n+        free(buffer);\n+        bufferLength = retSize + prefixLength;\n+        buffer = (WCHAR*)malloc(bufferLength * sizeof(WCHAR));\n+\n+        if (!buffer)\n+            return NULL;\n+\n+        retSize = GetFullPathNameW(path, (DWORD)(bufferLength - prefixLength), buffer + prefixLength, NULL);\n+    }\n+\n+    if (retSize <= 0)\n+    {\n+        free(buffer);\n+        return NULL;\n+    }\n+\n+    memcpy(buffer, ExtendedPrefix, bufferLength * sizeof(WCHAR));\n+\n+    return buffer;\n+}\n+#else // TARGET_WINDOWS\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <stdlib.h>\n+#include <minipal/utf8.h>\n+#include <minipal/strings.h>\n+\n+#if HAVE_STAT64\n+#define stat_ stat64\n+#define fstat_ fstat64\n+#define lstat_ lstat64\n+#else /* HAVE_STAT64 */\n+#define stat_ stat\n+#define fstat_ fstat\n+#define lstat_ lstat\n+#endif  /* HAVE_STAT64 */\n+\n+/* Magic number explanation:\n+\n+   To 1970:\n+   Both epochs are Gregorian. 1970 - 1601 = 369. Assuming a leap\n+   year every four years, 369 / 4 = 92. However, 1700, 1800, and 1900\n+   were NOT leap years, so 89 leap years, 280 non-leap years.\n+   89 * 366 + 280 * 365 = 134774 days between epochs. Of course\n+   60 * 60 * 24 = 86400 seconds per day, so 134774 * 86400 =\n+   11644473600 = SECS_BETWEEN_1601_AND_1970_EPOCHS.\n+\n+   To 2001:\n+   Again, both epochs are Gregorian. 2001 - 1601 = 400. Assuming a leap\n+   year every four years, 400 / 4 = 100. However, 1700, 1800, and 1900\n+   were NOT leap years (2000 was because it was divisible by 400), so\n+   97 leap years, 303 non-leap years.\n+   97 * 366 + 303 * 365 = 146097 days between epochs. 146097 * 86400 =\n+   12622780800 = SECS_BETWEEN_1601_AND_2001_EPOCHS.\n+\n+   This result is also confirmed in the MSDN documentation on how\n+   to convert a time_t value to a win32 FILETIME.\n+*/\n+static const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;\n+static const int64_t SECS_TO_100NS = 10000000; /* 10^7 */\n+\n+static uint64_t UnixTimeToWin32FileTime(struct timespec ts)\n+{\n+    return (uint64_t)(((int64_t)ts.tv_sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS +\n+        (ts.tv_nsec / 100));\n+}\n+\n+#endif // TARGET_WINDOWS\n+\n+bool minipal_file_get_attributes_utf16(const char16_t* path, minipal_file_attr_t* attributes)\n+{\n+#ifdef TARGET_WINDOWS\n+    if (!path || !attributes)\n+        return false;\n+\n+    WCHAR* extendedPath = NormalizePath(path);\n+    if (extendedPath)\n+        path = extendedPath;\n+\n+    WIN32_FILE_ATTRIBUTE_DATA faData;\n+    bool ret = GetFileAttributesExW(path, GetFileExInfoStandard, &faData);",
        "comment_created_at": "2025-05-29T17:14:44+00:00",
        "comment_author": "AaronRobinsonMSFT",
        "comment_body": "```suggestion\r\n    BOOL ret = ::GetFileAttributesExW(path, GetFileExInfoStandard, &faData);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2115005465",
        "repo_full_name": "dotnet/runtime",
        "pr_number": 116096,
        "pr_file": "src/native/minipal/file.c",
        "discussion_id": "2114401248",
        "commented_code": "@@ -0,0 +1,198 @@\n+// Licensed to the .NET Foundation under one or more agreements.\n+// The .NET Foundation licenses this file to you under the MIT license.\n+\n+#include <stdint.h>\n+#include <minipal/file.h>\n+\n+#ifdef TARGET_WINDOWS\n+#include <Windows.h>\n+\n+#define ExtendedPrefix L\"\\\\\\\\?\\\\\"\n+#define DevicePathPrefix L\"\\\\\\\\.\\\\\"\n+#define UNCExtendedPathPrefix L\"\\\\\\\\?\\\\UNC\\\\\"\n+#define UNCPathPrefix L\"\\\\\\\\\"\n+#define DIRECTORY_SEPARATOR_CHAR L'\\\\'\n+#define ALT_DIRECTORY_SEPARATOR_CHAR L'/'\n+#define VOLUME_SEPARATOR_CHAR L':'\n+\n+static bool IsDirectorySeparator(WCHAR ch)\n+{\n+    return (ch == DIRECTORY_SEPARATOR_CHAR) || (ch == ALT_DIRECTORY_SEPARATOR_CHAR);\n+}\n+\n+static bool IsPathNotFullyQualified(WCHAR* path)\n+{\n+    // Relative here means it could be relative to current directory on the relevant drive\n+    // NOTE: Relative segments ( \\..\\) are not considered relative\n+    // Returns true if the path specified is relative to the current drive or working directory.\n+    // Returns false if the path is fixed to a specific drive or UNC path.  This method does no\n+    // validation of the path (URIs will be returned as relative as a result).\n+    // Handles paths that use the alternate directory separator.  It is a frequent mistake to\n+    // assume that rooted paths (Path.IsPathRooted) are not relative.  This isn't the case.\n+\n+    if ((path[0] == L'\\0') || (path[1] == L'\\0'))\n+    {\n+        return true;  // It isn't fixed, it must be relative.  There is no way to specify a fixed path with one character (or less).\n+    }\n+\n+    if (IsDirectorySeparator(path[0]))\n+    {\n+        return !IsDirectorySeparator(path[1]); // There is no valid way to specify a relative path with two initial slashes\n+    }\n+    \n+    return !((wcslen(path) >= 3)           //The only way to specify a fixed path that doesn't begin with two slashes is the drive, colon, slash format- i.e. \"C:\\\"\n+            && (path[1] == VOLUME_SEPARATOR_CHAR)\n+            && IsDirectorySeparator(path[2]));\n+}\n+\n+// Returns newly allocated path if needs to expand the path, or NULL if no need.\n+// The normalization examples are :\n+//  C:\\foo\\<long>\\bar   => \\\\?\\C:\\foo\\<long>\\bar\n+//  \\\\server\\<long>\\bar => \\\\?\\UNC\\server\\<long>\\bar\n+static WCHAR* NormalizePath(const WCHAR* path)\n+{\n+    if (path[0] == L'\\0')\n+        return NULL;\n+\n+    if (wcsncmp(path, DevicePathPrefix, sizeof(DevicePathPrefix) / sizeof(WCHAR) - 1) == 0)\n+        return NULL;\n+\n+    if (wcsncmp(path, ExtendedPrefix, sizeof(ExtendedPrefix) / sizeof(WCHAR) - 1) == 0)\n+        return NULL;\n+\n+    if (wcsncmp(path, UNCExtendedPathPrefix, sizeof(UNCExtendedPathPrefix) / sizeof(WCHAR) - 1) == 0)\n+        return NULL;\n+\n+    size_t length = wcslen(path);\n+\n+    if (!IsPathNotFullyQualified(path) && length < MAX_PATH)\n+        return NULL;\n+    \n+    // Now the path will be normalized\n+\n+    size_t prefixLength = sizeof(ExtendedPrefix) / sizeof(WCHAR) - 1;\n+    size_t bufferLength = length + prefixLength + 1;\n+    WCHAR* buffer = (WCHAR*)malloc(bufferLength * sizeof(WCHAR));\n+\n+    if (!buffer)\n+        return NULL;\n+\n+    DWORD retSize = GetFullPathNameW(path, (DWORD)(bufferLength - prefixLength), buffer + prefixLength, NULL);\n+\n+    if (retSize > bufferLength - prefixLength)\n+    {\n+        free(buffer);\n+        bufferLength = retSize + prefixLength;\n+        buffer = (WCHAR*)malloc(bufferLength * sizeof(WCHAR));\n+\n+        if (!buffer)\n+            return NULL;\n+\n+        retSize = GetFullPathNameW(path, (DWORD)(bufferLength - prefixLength), buffer + prefixLength, NULL);\n+    }\n+\n+    if (retSize <= 0)\n+    {\n+        free(buffer);\n+        return NULL;\n+    }\n+\n+    memcpy(buffer, ExtendedPrefix, bufferLength * sizeof(WCHAR));\n+\n+    return buffer;\n+}\n+#else // TARGET_WINDOWS\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <stdlib.h>\n+#include <minipal/utf8.h>\n+#include <minipal/strings.h>\n+\n+#if HAVE_STAT64\n+#define stat_ stat64\n+#define fstat_ fstat64\n+#define lstat_ lstat64\n+#else /* HAVE_STAT64 */\n+#define stat_ stat\n+#define fstat_ fstat\n+#define lstat_ lstat\n+#endif  /* HAVE_STAT64 */\n+\n+/* Magic number explanation:\n+\n+   To 1970:\n+   Both epochs are Gregorian. 1970 - 1601 = 369. Assuming a leap\n+   year every four years, 369 / 4 = 92. However, 1700, 1800, and 1900\n+   were NOT leap years, so 89 leap years, 280 non-leap years.\n+   89 * 366 + 280 * 365 = 134774 days between epochs. Of course\n+   60 * 60 * 24 = 86400 seconds per day, so 134774 * 86400 =\n+   11644473600 = SECS_BETWEEN_1601_AND_1970_EPOCHS.\n+\n+   To 2001:\n+   Again, both epochs are Gregorian. 2001 - 1601 = 400. Assuming a leap\n+   year every four years, 400 / 4 = 100. However, 1700, 1800, and 1900\n+   were NOT leap years (2000 was because it was divisible by 400), so\n+   97 leap years, 303 non-leap years.\n+   97 * 366 + 303 * 365 = 146097 days between epochs. 146097 * 86400 =\n+   12622780800 = SECS_BETWEEN_1601_AND_2001_EPOCHS.\n+\n+   This result is also confirmed in the MSDN documentation on how\n+   to convert a time_t value to a win32 FILETIME.\n+*/\n+static const int64_t SECS_BETWEEN_1601_AND_1970_EPOCHS = 11644473600LL;\n+static const int64_t SECS_TO_100NS = 10000000; /* 10^7 */\n+\n+static uint64_t UnixTimeToWin32FileTime(struct timespec ts)\n+{\n+    return (uint64_t)(((int64_t)ts.tv_sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS +\n+        (ts.tv_nsec / 100));\n+}\n+\n+#endif // TARGET_WINDOWS\n+\n+bool minipal_file_get_attributes_utf16(const char16_t* path, minipal_file_attr_t* attributes)\n+{\n+#ifdef TARGET_WINDOWS\n+    if (!path || !attributes)\n+        return false;\n+\n+    WCHAR* extendedPath = NormalizePath(path);\n+    if (extendedPath)\n+        path = extendedPath;\n+\n+    WIN32_FILE_ATTRIBUTE_DATA faData;\n+    bool ret = GetFileAttributesExW(path, GetFileExInfoStandard, &faData);",
        "comment_created_at": "2025-05-30T01:48:52+00:00",
        "comment_author": "huoyaoyuan",
        "comment_body": "`::` is C++ syntax and not available in C.\r\n\r\nI'm not sure whether `bool` from `stdbool.h` can convert fine from `BOOL`. Maybe `!!` is required.\r\n\r\nThe whole implementation may be removed per https://github.com/dotnet/runtime/pull/116096#discussion_r2114134664, so it may not be worthy to review it now.",
        "pr_file_module": null
      }
    ]
  }
]
