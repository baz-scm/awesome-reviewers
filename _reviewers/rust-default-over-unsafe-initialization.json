[
  {
    "discussion_id": "2223654712",
    "pr_number": 143838,
    "pr_file": "library/std/src/sys/net/connection/uefi/tcp4.rs",
    "created_at": "2025-07-22T19:32:23+00:00",
    "commented_code": "if r.is_error() { Err(crate::io::Error::from_raw_os_error(r.as_usize())) } else { Ok(()) }\n     }\n \n+    pub(crate) fn get_mode_data(&self) -> io::Result<tcp4::ConfigData> {\n+        // Using MaybeUninit::uninit() generates a Page Fault Here\n+        let mut config_data: MaybeUninit<tcp4::ConfigData> = MaybeUninit::zeroed();",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2223654712",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143838,
        "pr_file": "library/std/src/sys/net/connection/uefi/tcp4.rs",
        "discussion_id": "2223654712",
        "commented_code": "@@ -67,6 +68,29 @@ impl Tcp4 {\n         if r.is_error() { Err(crate::io::Error::from_raw_os_error(r.as_usize())) } else { Ok(()) }\n     }\n \n+    pub(crate) fn get_mode_data(&self) -> io::Result<tcp4::ConfigData> {\n+        // Using MaybeUninit::uninit() generates a Page Fault Here\n+        let mut config_data: MaybeUninit<tcp4::ConfigData> = MaybeUninit::zeroed();",
        "comment_created_at": "2025-07-22T19:32:23+00:00",
        "comment_author": "nicholasbishop",
        "comment_body": "nit: Could you use [`ConfigData::default()`](https://docs.rs/r-efi/latest/r_efi/protocols/tcp4/struct.ConfigData.html#impl-Default-for-ConfigData) here instead of `MaybeUninit`? Slightly simpler, and then the `unsafe` `assume_init` isn't needed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224353063",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143838,
        "pr_file": "library/std/src/sys/net/connection/uefi/tcp4.rs",
        "discussion_id": "2223654712",
        "commented_code": "@@ -67,6 +68,29 @@ impl Tcp4 {\n         if r.is_error() { Err(crate::io::Error::from_raw_os_error(r.as_usize())) } else { Ok(()) }\n     }\n \n+    pub(crate) fn get_mode_data(&self) -> io::Result<tcp4::ConfigData> {\n+        // Using MaybeUninit::uninit() generates a Page Fault Here\n+        let mut config_data: MaybeUninit<tcp4::ConfigData> = MaybeUninit::zeroed();",
        "comment_created_at": "2025-07-23T05:02:06+00:00",
        "comment_author": "Ayush1325",
        "comment_body": "Well, isn't `MaybeUninit` designed to be used in such cases?",
        "pr_file_module": null
      },
      {
        "comment_id": "2224412675",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143838,
        "pr_file": "library/std/src/sys/net/connection/uefi/tcp4.rs",
        "discussion_id": "2223654712",
        "commented_code": "@@ -67,6 +68,29 @@ impl Tcp4 {\n         if r.is_error() { Err(crate::io::Error::from_raw_os_error(r.as_usize())) } else { Ok(()) }\n     }\n \n+    pub(crate) fn get_mode_data(&self) -> io::Result<tcp4::ConfigData> {\n+        // Using MaybeUninit::uninit() generates a Page Fault Here\n+        let mut config_data: MaybeUninit<tcp4::ConfigData> = MaybeUninit::zeroed();",
        "comment_created_at": "2025-07-23T05:39:18+00:00",
        "comment_author": "nicholasbishop",
        "comment_body": "Yes, but it should only be used if necessary for performance. I wouldn't think that's a concern here, so I'd rather have simpler code and one fewer unsafe blocks.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224432593",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143838,
        "pr_file": "library/std/src/sys/net/connection/uefi/tcp4.rs",
        "discussion_id": "2223654712",
        "commented_code": "@@ -67,6 +68,29 @@ impl Tcp4 {\n         if r.is_error() { Err(crate::io::Error::from_raw_os_error(r.as_usize())) } else { Ok(()) }\n     }\n \n+    pub(crate) fn get_mode_data(&self) -> io::Result<tcp4::ConfigData> {\n+        // Using MaybeUninit::uninit() generates a Page Fault Here\n+        let mut config_data: MaybeUninit<tcp4::ConfigData> = MaybeUninit::zeroed();",
        "comment_created_at": "2025-07-23T05:49:13+00:00",
        "comment_author": "tgross35",
        "comment_body": "> Well, isn't `MaybeUninit` designed to be used in such cases?\n\nTechnically yes it works here, but if there's a better option that reduces `unsafe` then there isn't any reason not to use it.\n\nWith `MaybeUninit::zeroed()` and later calling `assume_init()`, the assumption is made that zero is a valid bitpattern for all fields that `(*protocol).get_mode_data` doesn't overwrite. This is a nontrivial interaction and really be in a `SAFETY` comment. Also apparently `get_mode_data` expects at least partially initialized data if there is a page fault with `uninit` (presumably trying to read the pointer if nonnull?).\n\nIf you use `default()` then all these assumptions can go away. It's also more robust against adding/changing fields across a crate version bump.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224449490",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143838,
        "pr_file": "library/std/src/sys/net/connection/uefi/tcp4.rs",
        "discussion_id": "2223654712",
        "commented_code": "@@ -67,6 +68,29 @@ impl Tcp4 {\n         if r.is_error() { Err(crate::io::Error::from_raw_os_error(r.as_usize())) } else { Ok(()) }\n     }\n \n+    pub(crate) fn get_mode_data(&self) -> io::Result<tcp4::ConfigData> {\n+        // Using MaybeUninit::uninit() generates a Page Fault Here\n+        let mut config_data: MaybeUninit<tcp4::ConfigData> = MaybeUninit::zeroed();",
        "comment_created_at": "2025-07-23T05:54:23+00:00",
        "comment_author": "Ayush1325",
        "comment_body": "Ok, switched to using default. Also tested on ovmf.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2121747541",
    "pr_number": 141260,
    "pr_file": "tests/ui/precondition-checks/read_volatile.rs",
    "created_at": "2025-06-02T17:20:00+00:00",
    "commented_code": "//@ run-fail\n //@ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes\n //@ error-pattern: unsafe precondition(s) violated: ptr::read_volatile requires\n-//@ revisions: null misaligned\n+//@ revisions: misaligned\n \n #![allow(invalid_null_arguments)]",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2121747541",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 141260,
        "pr_file": "tests/ui/precondition-checks/read_volatile.rs",
        "discussion_id": "2121747541",
        "commented_code": "@@ -1,7 +1,7 @@\n //@ run-fail\n //@ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes\n //@ error-pattern: unsafe precondition(s) violated: ptr::read_volatile requires\n-//@ revisions: null misaligned\n+//@ revisions: misaligned\n \n #![allow(invalid_null_arguments)]",
        "comment_created_at": "2025-06-02T17:20:00+00:00",
        "comment_author": "LuigiPiucco",
        "comment_body": "I just noticed the line above. I assume it's unused now, since there is no longer a null argument, and if so, I'll remove it. But more importantly, does this mean there is still a check enabled by default that prevents the null usage? I think it may be related to the source snippet below.\r\n\r\nhttps://github.com/rust-lang/rust/blob/2398bd60ef526e686a38a299cc2fa991d8b3c33e/compiler/rustc_lint/src/ptr_nulls.rs#L160-L175\r\n\r\nShould I remove `read_volatile`/`write_volatile`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2126790777",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 141260,
        "pr_file": "tests/ui/precondition-checks/read_volatile.rs",
        "discussion_id": "2121747541",
        "commented_code": "@@ -1,7 +1,7 @@\n //@ run-fail\n //@ compile-flags: -Copt-level=3 -Cdebug-assertions=no -Zub-checks=yes\n //@ error-pattern: unsafe precondition(s) violated: ptr::read_volatile requires\n-//@ revisions: null misaligned\n+//@ revisions: misaligned\n \n #![allow(invalid_null_arguments)]",
        "comment_created_at": "2025-06-04T14:43:06+00:00",
        "comment_author": "RalfJung",
        "comment_body": "Yes, the lint should stop firing on the volatile methods.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203373021",
    "pr_number": 143598,
    "pr_file": "library/std/src/sys/pal/windows/compat.rs",
    "created_at": "2025-07-13T12:23:05+00:00",
    "commented_code": "/// Relies on the functions being pre-loaded elsewhere.\n #[cfg(target_vendor = \"win7\")]\n macro_rules! compat_fn_optional {\n-    ($(\n+    (pub static $module:ident: &CStr = $name:expr; $(\n         $(#[$meta:meta])*\n         $vis:vis fn $symbol:ident($($argname:ident: $argtype:ty),*) $(-> $rettype:ty)?;\n     )+) => (\n+        pub static $module: &CStr = $name;\n         $(\n             pub mod $symbol {\n                 #[allow(unused_imports)]\n                 use super::*;\n                 use crate::ffi::c_void;\n                 use crate::mem;\n-                use crate::ptr::{self, NonNull};\n+                use crate::ptr;\n                 use crate::sync::atomic::{Atomic, AtomicPtr, Ordering};\n+                use crate::sys::compat::Module;\n \n-                pub(in crate::sys) static PTR: Atomic<*mut c_void> = AtomicPtr::new(ptr::null_mut());\n+                const NOT_FOUND: *mut c_void = ptr::null_mut();\n+                const NOT_LOADED: *mut c_void = ptr::without_provenance_mut(usize::MAX);\n+\n+                pub(in crate::sys) static PTR: Atomic<*mut c_void> = AtomicPtr::new(NOT_LOADED);\n \n                 type F = unsafe extern \"system\" fn($($argtype),*) $(-> $rettype)?;\n \n-                #[inline(always)]\n+                fn load_from_module(module: Option<Module>) -> Option<F> {\n+                    unsafe {\n+                        static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n+                        if let Some(f) = module.and_then(|m| m.proc_address(SYMBOL_NAME)) {\n+                            PTR.store(f.as_ptr(), Ordering::Relaxed);\n+                            Some(mem::transmute(f))\n+                        } else {\n+                            PTR.store(NOT_FOUND, Ordering::Relaxed);\n+                            None\n+                        }\n+                    }\n+                }\n+\n                 pub fn option() -> Option<F> {\n-                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| unsafe { mem::transmute(f) })\n+                    match PTR.load(Ordering::Relaxed) {\n+                        NOT_FOUND => None,\n+                        NOT_LOADED => load_from_module(unsafe { Module::new($module) }),\n+                        f => Some(unsafe { mem::transmute(f) })",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2203373021",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143598,
        "pr_file": "library/std/src/sys/pal/windows/compat.rs",
        "discussion_id": "2203373021",
        "commented_code": "@@ -201,26 +156,47 @@ macro_rules! compat_fn_with_fallback {\n /// Relies on the functions being pre-loaded elsewhere.\n #[cfg(target_vendor = \"win7\")]\n macro_rules! compat_fn_optional {\n-    ($(\n+    (pub static $module:ident: &CStr = $name:expr; $(\n         $(#[$meta:meta])*\n         $vis:vis fn $symbol:ident($($argname:ident: $argtype:ty),*) $(-> $rettype:ty)?;\n     )+) => (\n+        pub static $module: &CStr = $name;\n         $(\n             pub mod $symbol {\n                 #[allow(unused_imports)]\n                 use super::*;\n                 use crate::ffi::c_void;\n                 use crate::mem;\n-                use crate::ptr::{self, NonNull};\n+                use crate::ptr;\n                 use crate::sync::atomic::{Atomic, AtomicPtr, Ordering};\n+                use crate::sys::compat::Module;\n \n-                pub(in crate::sys) static PTR: Atomic<*mut c_void> = AtomicPtr::new(ptr::null_mut());\n+                const NOT_FOUND: *mut c_void = ptr::null_mut();\n+                const NOT_LOADED: *mut c_void = ptr::without_provenance_mut(usize::MAX);\n+\n+                pub(in crate::sys) static PTR: Atomic<*mut c_void> = AtomicPtr::new(NOT_LOADED);\n \n                 type F = unsafe extern \"system\" fn($($argtype),*) $(-> $rettype)?;\n \n-                #[inline(always)]\n+                fn load_from_module(module: Option<Module>) -> Option<F> {\n+                    unsafe {\n+                        static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n+                        if let Some(f) = module.and_then(|m| m.proc_address(SYMBOL_NAME)) {\n+                            PTR.store(f.as_ptr(), Ordering::Relaxed);\n+                            Some(mem::transmute(f))\n+                        } else {\n+                            PTR.store(NOT_FOUND, Ordering::Relaxed);\n+                            None\n+                        }\n+                    }\n+                }\n+\n                 pub fn option() -> Option<F> {\n-                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| unsafe { mem::transmute(f) })\n+                    match PTR.load(Ordering::Relaxed) {\n+                        NOT_FOUND => None,\n+                        NOT_LOADED => load_from_module(unsafe { Module::new($module) }),\n+                        f => Some(unsafe { mem::transmute(f) })",
        "comment_created_at": "2025-07-13T12:23:05+00:00",
        "comment_author": "Mark-Simulacrum",
        "comment_body": "nit: could you add a safety comment on the transmutes? (In particular describing why the Option transmute is OK)",
        "pr_file_module": null
      }
    ]
  }
]