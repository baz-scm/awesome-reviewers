[
  {
    "discussion_id": "2224782823",
    "pr_number": 144022,
    "pr_file": "library/std/src/sync/nonpoison/mutex.rs",
    "created_at": "2025-07-23T08:19:51+00:00",
    "commented_code": "+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::mem::{self, ManuallyDrop};\n+use crate::ops::{Deref, DerefMut};\n+use crate::ptr::NonNull;\n+use crate::sync::nonpoison::{TryLockResult, WouldBlock};\n+use crate::sys::sync as sys;\n+\n+/// A mutual exclusion primitive useful for protecting shared data that does not keep track of\n+/// lock poisoning.\n+///\n+/// For more information about mutexes, check out the documentation for the poisoning variant of\n+/// this lock (which can be found at [`poison::Mutex`]).\n+///\n+/// [`poison::Mutex`]: crate::sync::poison::Mutex\n+///\n+/// # Examples",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2224782823",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144022,
        "pr_file": "library/std/src/sync/nonpoison/mutex.rs",
        "discussion_id": "2224782823",
        "commented_code": "@@ -0,0 +1,697 @@\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::mem::{self, ManuallyDrop};\n+use crate::ops::{Deref, DerefMut};\n+use crate::ptr::NonNull;\n+use crate::sync::nonpoison::{TryLockResult, WouldBlock};\n+use crate::sys::sync as sys;\n+\n+/// A mutual exclusion primitive useful for protecting shared data that does not keep track of\n+/// lock poisoning.\n+///\n+/// For more information about mutexes, check out the documentation for the poisoning variant of\n+/// this lock (which can be found at [`poison::Mutex`]).\n+///\n+/// [`poison::Mutex`]: crate::sync::poison::Mutex\n+///\n+/// # Examples",
        "comment_created_at": "2025-07-23T08:19:51+00:00",
        "comment_author": "tgross35",
        "comment_body": "I think the documentation here should be slim, e.g. just an intro paragraph and a single example that ideally showcases the different behavior from the poison version. This helps avoid having to keep docs in sync in two places (especially while unstable).\n\nSo all examples except for the one showing nonpanicking behavior can probably be dropped, then either update the above \"For more information about mutexes...\" sentence to also mention examples, or add something like \"See [`poison::Mutex`] for more usage examples\".",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2134817723",
    "pr_number": 135975,
    "pr_file": "library/alloc/src/vec/mod.rs",
    "created_at": "2025-06-08T20:20:50+00:00",
    "commented_code": "Ok(())\n     }\n \n+    /// Appends an element to the back of a collection, returning a reference to it.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity exceeds `isize::MAX` _bytes_.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(push_mut)]\n+    ///\n+    /// # #[allow(unused)]\n+    /// #[derive(PartialEq, Eq, Debug)]\n+    /// struct Item { identifier: &'static str, count: usize }\n+    ///\n+    /// impl Default for Item {\n+    ///     fn default() -> Self {\n+    ///         return Self { identifier: \"stone\", count: 64 }\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut items = vec![];\n+    ///\n+    /// // We can mutate the just-pushed value without having to fetch it again\n+    /// for count in [15, 35, 61] {\n+    ///     let item = items.push_mut(Item::default());\n+    ///     item.count = count;\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     items,\n+    ///     [Item { identifier: \"stone\", count: 15 }, Item { identifier: \"stone\", count: 35 }, Item { identifier: \"stone\", count: 61 }]\n+    /// );",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2134817723",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 135975,
        "pr_file": "library/alloc/src/vec/mod.rs",
        "discussion_id": "2134817723",
        "commented_code": "@@ -2503,6 +2503,104 @@ impl<T, A: Allocator> Vec<T, A> {\n         Ok(())\n     }\n \n+    /// Appends an element to the back of a collection, returning a reference to it.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity exceeds `isize::MAX` _bytes_.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(push_mut)]\n+    ///\n+    /// # #[allow(unused)]\n+    /// #[derive(PartialEq, Eq, Debug)]\n+    /// struct Item { identifier: &'static str, count: usize }\n+    ///\n+    /// impl Default for Item {\n+    ///     fn default() -> Self {\n+    ///         return Self { identifier: \"stone\", count: 64 }\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut items = vec![];\n+    ///\n+    /// // We can mutate the just-pushed value without having to fetch it again\n+    /// for count in [15, 35, 61] {\n+    ///     let item = items.push_mut(Item::default());\n+    ///     item.count = count;\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     items,\n+    ///     [Item { identifier: \"stone\", count: 15 }, Item { identifier: \"stone\", count: 35 }, Item { identifier: \"stone\", count: 61 }]\n+    /// );",
        "comment_created_at": "2025-06-08T20:20:50+00:00",
        "comment_author": "ibraheemdev",
        "comment_body": "This example is quite long. Documentation examples should generally be short and to the point.\r\n```suggestion\r\n    /// #![feature(push_mut)]\r\n    ///\r\n    /// let mut vec = vec![1, 2];\r\n    /// let last = vec.push(3);\r\n    /// assert_eq!(vec, [1, 2, 3]);\r\n    /// *last = 4;\r\n    /// assert_eq!(vec, [1, 2, 4]);\r\n    /// ```\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2146379397",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 135975,
        "pr_file": "library/alloc/src/vec/mod.rs",
        "discussion_id": "2134817723",
        "commented_code": "@@ -2503,6 +2503,104 @@ impl<T, A: Allocator> Vec<T, A> {\n         Ok(())\n     }\n \n+    /// Appends an element to the back of a collection, returning a reference to it.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity exceeds `isize::MAX` _bytes_.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(push_mut)]\n+    ///\n+    /// # #[allow(unused)]\n+    /// #[derive(PartialEq, Eq, Debug)]\n+    /// struct Item { identifier: &'static str, count: usize }\n+    ///\n+    /// impl Default for Item {\n+    ///     fn default() -> Self {\n+    ///         return Self { identifier: \"stone\", count: 64 }\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut items = vec![];\n+    ///\n+    /// // We can mutate the just-pushed value without having to fetch it again\n+    /// for count in [15, 35, 61] {\n+    ///     let item = items.push_mut(Item::default());\n+    ///     item.count = count;\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     items,\n+    ///     [Item { identifier: \"stone\", count: 15 }, Item { identifier: \"stone\", count: 35 }, Item { identifier: \"stone\", count: 61 }]\n+    /// );",
        "comment_created_at": "2025-06-14T02:23:40+00:00",
        "comment_author": "balt-dev",
        "comment_body": "I think I overcompensated for the last feedback. Oops.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218950747",
    "pr_number": 144236,
    "pr_file": "library/core/src/mem/drop_guard.rs",
    "created_at": "2025-07-21T11:42:30+00:00",
    "commented_code": "+use crate::mem::ManuallyDrop;\n+use crate::ops::{Deref, DerefMut};\n+use crate::ptr;\n+\n+/// Wrap a value and run a closure when dropped.\n+///\n+/// This is useful for quickly creating desructors inline.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// # #![allow(unused)]\n+/// use std::mem::DropGuard;\n+///\n+/// {\n+///     // Create a new guard around a string that will\n+///     // print its value when dropped.\n+///     let s = String::from(\"Chashu likes tuna\");\n+///     let mut s = DropGuard::new(s, |s| println!(\"{s}\"));\n+///\n+///     // Modify the string contained in the guard.\n+///     s.push_str(\"!!!\");\n+///\n+///     // The guard will be dropped here, printing:\n+///     // \"Chashu likes tuna!!!\"\n+/// }\n+/// ```\n+#[unstable(feature = \"drop_guard\", issue = \"none\")]\n+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct DropGuard<T, F>\n+where\n+    F: FnOnce(T),\n+{\n+    inner: ManuallyDrop<T>,\n+    f: ManuallyDrop<F>,\n+}\n+\n+impl<T, F> DropGuard<T, F>\n+where\n+    F: FnOnce(T),\n+{\n+    /// Create a new instance of `DropGuard`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// use std::mem::DropGuard;\n+    ///\n+    /// let value = String::from(\"Chashu likes tuna\");\n+    /// let guard = DropGuard::new(value, |s| println!(\"{s}\"));\n+    /// ```\n+    #[unstable(feature = \"drop_guard\", issue = \"none\")]\n+    pub fn new(inner: T, f: F) -> Self {\n+        Self { inner: ManuallyDrop::new(inner), f: ManuallyDrop::new(f) }\n+    }\n+\n+    /// Consumes the `Guard`, returning the wrapped value.\n+    ///\n+    /// This will not execute the closure. This is implemented as a static\n+    /// method to prevent any potential conflicts with any other methods called\n+    /// `into_inner` from the `Deref` and `DerefMut` impls.\n+    ///\n+    /// It is typically preferred to call this function instead of `mem::forget`\n+    /// because it will appropriately de-initialize the closure stored in the\n+    /// `DropGuard` before returning the stored value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// use std::mem::DropGuard;\n+    ///\n+    /// let value = String::from(\"Nori likes chicken\");\n+    /// let guard = DropGuard::new(value, |s| println!(\"{s}\"));\n+    /// assert_eq!(Guard::into_inner(guard), \"Nori likes chicken\");\n+    /// ```\n+    #[unstable(feature = \"drop_guard\", issue = \"none\")]\n+    #[inline]\n+    pub fn into_inner(guard: Self) -> T {\n+        // Implementation note: this is the same approach that scopeguard takes.",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2218950747",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144236,
        "pr_file": "library/core/src/mem/drop_guard.rs",
        "discussion_id": "2218950747",
        "commented_code": "@@ -0,0 +1,166 @@\n+use crate::mem::ManuallyDrop;\n+use crate::ops::{Deref, DerefMut};\n+use crate::ptr;\n+\n+/// Wrap a value and run a closure when dropped.\n+///\n+/// This is useful for quickly creating desructors inline.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// # #![allow(unused)]\n+/// use std::mem::DropGuard;\n+///\n+/// {\n+///     // Create a new guard around a string that will\n+///     // print its value when dropped.\n+///     let s = String::from(\"Chashu likes tuna\");\n+///     let mut s = DropGuard::new(s, |s| println!(\"{s}\"));\n+///\n+///     // Modify the string contained in the guard.\n+///     s.push_str(\"!!!\");\n+///\n+///     // The guard will be dropped here, printing:\n+///     // \"Chashu likes tuna!!!\"\n+/// }\n+/// ```\n+#[unstable(feature = \"drop_guard\", issue = \"none\")]\n+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct DropGuard<T, F>\n+where\n+    F: FnOnce(T),\n+{\n+    inner: ManuallyDrop<T>,\n+    f: ManuallyDrop<F>,\n+}\n+\n+impl<T, F> DropGuard<T, F>\n+where\n+    F: FnOnce(T),\n+{\n+    /// Create a new instance of `DropGuard`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// use std::mem::DropGuard;\n+    ///\n+    /// let value = String::from(\"Chashu likes tuna\");\n+    /// let guard = DropGuard::new(value, |s| println!(\"{s}\"));\n+    /// ```\n+    #[unstable(feature = \"drop_guard\", issue = \"none\")]\n+    pub fn new(inner: T, f: F) -> Self {\n+        Self { inner: ManuallyDrop::new(inner), f: ManuallyDrop::new(f) }\n+    }\n+\n+    /// Consumes the `Guard`, returning the wrapped value.\n+    ///\n+    /// This will not execute the closure. This is implemented as a static\n+    /// method to prevent any potential conflicts with any other methods called\n+    /// `into_inner` from the `Deref` and `DerefMut` impls.\n+    ///\n+    /// It is typically preferred to call this function instead of `mem::forget`\n+    /// because it will appropriately de-initialize the closure stored in the\n+    /// `DropGuard` before returning the stored value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// use std::mem::DropGuard;\n+    ///\n+    /// let value = String::from(\"Nori likes chicken\");\n+    /// let guard = DropGuard::new(value, |s| println!(\"{s}\"));\n+    /// assert_eq!(Guard::into_inner(guard), \"Nori likes chicken\");\n+    /// ```\n+    #[unstable(feature = \"drop_guard\", issue = \"none\")]\n+    #[inline]\n+    pub fn into_inner(guard: Self) -> T {\n+        // Implementation note: this is the same approach that scopeguard takes.",
        "comment_created_at": "2025-07-21T11:42:30+00:00",
        "comment_author": "lukaslueg",
        "comment_body": "personal drive-by comment: future readers of this comment are probably not aware if `scopeguard` refers to a crate, a core-module, or a type somewhere in core/std. IMHO this comment should either be left out entirely or moved to a mod-level comment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217328119",
    "pr_number": 144091,
    "pr_file": "library/alloc/src/boxed.rs",
    "created_at": "2025-07-19T14:06:27+00:00",
    "commented_code": "/// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2217328119",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144091,
        "pr_file": "library/alloc/src/boxed.rs",
        "discussion_id": "2217328119",
        "commented_code": "@@ -358,7 +356,6 @@ impl<T> Box<T> {\n     /// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]",
        "comment_created_at": "2025-07-19T14:06:27+00:00",
        "comment_author": "Mark-Simulacrum",
        "comment_body": "Hm, are these just stale comments? I'm a bit confused why we're deleting these in *this* PR...",
        "pr_file_module": null
      },
      {
        "comment_id": "2217501584",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144091,
        "pr_file": "library/alloc/src/boxed.rs",
        "discussion_id": "2217328119",
        "commented_code": "@@ -358,7 +356,6 @@ impl<T> Box<T> {\n     /// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]",
        "comment_created_at": "2025-07-19T23:24:11+00:00",
        "comment_author": "thaliaarchi",
        "comment_body": "These comments weren't updated when `new_zeroed_alloc` was split out of `new_uninit`, so half of them (e.g., `try_new_zeroed`) should be removed by this stabilization. Since the other half are already stable, but are closely related, it seems reasonable to fix them here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2225006567",
    "pr_number": 144167,
    "pr_file": "library/core/src/ops/range.rs",
    "created_at": "2025-07-23T09:47:00+00:00",
    "commented_code": "}\n }\n \n+/// This impl intentionally does not have `T: ?Sized` due to type inference issues.\n+// see https://github.com/rust-lang/rust/pull/61584 for discussion of those issues\n+///\n+/// If you need to use this impl where `T` is unsized,\n+/// consider using the `RangeBounds` impl for a 2-tuple of [`Bound<&T>`][Bound],\n+/// e.g. replace `start..` with `(Bound::Included(start), Bound::Unbounded)`.",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2225006567",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144167,
        "pr_file": "library/core/src/ops/range.rs",
        "discussion_id": "2225006567",
        "commented_code": "@@ -1141,6 +1141,12 @@ impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n     }\n }\n \n+/// This impl intentionally does not have `T: ?Sized` due to type inference issues.\n+// see https://github.com/rust-lang/rust/pull/61584 for discussion of those issues\n+///\n+/// If you need to use this impl where `T` is unsized,\n+/// consider using the `RangeBounds` impl for a 2-tuple of [`Bound<&T>`][Bound],\n+/// e.g. replace `start..` with `(Bound::Included(start), Bound::Unbounded)`.",
        "comment_created_at": "2025-07-23T09:47:00+00:00",
        "comment_author": "tgross35",
        "comment_body": "Few small nits/thoughts:\n\n* I don't think the \"due to type inference issues\" part needs to be in public docs. That reasoning is a bit of an internal detail, I think it's fine to just make the whole first sentence a non-doc comment.\n* Maybe \"impl\" -> \"implementation\" for prose\n* `e.g.` -> `i.e.` probably works because it's showing a pattern rather than a specific example\n* Looks like the paragraph needs a rewrap (100 chars)",
        "pr_file_module": null
      },
      {
        "comment_id": "2226646175",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144167,
        "pr_file": "library/core/src/ops/range.rs",
        "discussion_id": "2225006567",
        "commented_code": "@@ -1141,6 +1141,12 @@ impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n     }\n }\n \n+/// This impl intentionally does not have `T: ?Sized` due to type inference issues.\n+// see https://github.com/rust-lang/rust/pull/61584 for discussion of those issues\n+///\n+/// If you need to use this impl where `T` is unsized,\n+/// consider using the `RangeBounds` impl for a 2-tuple of [`Bound<&T>`][Bound],\n+/// e.g. replace `start..` with `(Bound::Included(start), Bound::Unbounded)`.",
        "comment_created_at": "2025-07-23T20:42:59+00:00",
        "comment_author": "zachs18",
        "comment_body": "* Okay, I've made that part a non-doc comment, and made it not mention the reasoning, just link to it.\r\n* :+1:\r\n* :+1:\r\n* The longest of the added lines in the source is ~86 characters; do you mean the length in the rendered docs?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2187111513",
    "pr_number": 143416,
    "pr_file": "compiler/rustc_expand/src/mbe/quoted.rs",
    "created_at": "2025-07-05T11:24:17+00:00",
    "commented_code": "result\n }\n \n+/// Takes a `tokenstream::TokenTree` and returns a `self::TokenTree`. Like `parse`, but for a\n+/// single token tree.\n+///\n+/// # Parameters\n+///\n+/// - `input`: a token tree to parse.\n+/// - `part`: same as [parse].\n+/// - `sess`: the parsing session. Any errors will be emitted to this session.\n+/// - `node_id`: the NodeId of the macro we are parsing.\n+/// - `features`: language features so we can do feature gating.\n+///\n+/// # Returns\n+///\n+/// A `self::TokenTree`. There may also be some errors emitted to `sess`.",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2187111513",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143416,
        "pr_file": "compiler/rustc_expand/src/mbe/quoted.rs",
        "discussion_id": "2187111513",
        "commented_code": "@@ -152,6 +152,34 @@ pub(super) fn parse(\n     result\n }\n \n+/// Takes a `tokenstream::TokenTree` and returns a `self::TokenTree`. Like `parse`, but for a\n+/// single token tree.\n+///\n+/// # Parameters\n+///\n+/// - `input`: a token tree to parse.\n+/// - `part`: same as [parse].\n+/// - `sess`: the parsing session. Any errors will be emitted to this session.\n+/// - `node_id`: the NodeId of the macro we are parsing.\n+/// - `features`: language features so we can do feature gating.\n+///\n+/// # Returns\n+///\n+/// A `self::TokenTree`. There may also be some errors emitted to `sess`.",
        "comment_created_at": "2025-07-05T11:24:17+00:00",
        "comment_author": "nnethercote",
        "comment_body": "TBH, I think this comment is overkill, especially given that  `parse` is so well documented. I think you can cut the \"Parameters\" and \"Returns\" lists.",
        "pr_file_module": null
      },
      {
        "comment_id": "2187836549",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143416,
        "pr_file": "compiler/rustc_expand/src/mbe/quoted.rs",
        "discussion_id": "2187111513",
        "commented_code": "@@ -152,6 +152,34 @@ pub(super) fn parse(\n     result\n }\n \n+/// Takes a `tokenstream::TokenTree` and returns a `self::TokenTree`. Like `parse`, but for a\n+/// single token tree.\n+///\n+/// # Parameters\n+///\n+/// - `input`: a token tree to parse.\n+/// - `part`: same as [parse].\n+/// - `sess`: the parsing session. Any errors will be emitted to this session.\n+/// - `node_id`: the NodeId of the macro we are parsing.\n+/// - `features`: language features so we can do feature gating.\n+///\n+/// # Returns\n+///\n+/// A `self::TokenTree`. There may also be some errors emitted to `sess`.",
        "comment_created_at": "2025-07-05T23:21:15+00:00",
        "comment_author": "joshtriplett",
        "comment_body": "I kinda figured it was as well, but I was making `parse` no longer `pub`, and I assumed there should be a clear comment on the `pub` function. I'll pare it down a bit.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1896149708",
    "pr_number": 134663,
    "pr_file": "library/std/src/sync/nonpoison/mutex.rs",
    "created_at": "2024-12-23T21:53:57+00:00",
    "commented_code": "+#[cfg(all(test, not(any(target_os = \"emscripten\", target_os = \"wasi\"))))]\n+mod tests;\n+\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::mem::ManuallyDrop;\n+use crate::ops::{Deref, DerefMut};\n+use crate::ptr::NonNull;\n+use crate::sys::sync as sys;\n+\n+/// A mutual exclusion primitive useful for protecting shared data",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "1896149708",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 134663,
        "pr_file": "library/std/src/sync/nonpoison/mutex.rs",
        "discussion_id": "1896149708",
        "commented_code": "@@ -0,0 +1,616 @@\n+#[cfg(all(test, not(any(target_os = \"emscripten\", target_os = \"wasi\"))))]\n+mod tests;\n+\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::mem::ManuallyDrop;\n+use crate::ops::{Deref, DerefMut};\n+use crate::ptr::NonNull;\n+use crate::sys::sync as sys;\n+\n+/// A mutual exclusion primitive useful for protecting shared data",
        "comment_created_at": "2024-12-23T21:53:57+00:00",
        "comment_author": "tgross35",
        "comment_body": "The docs for this one could probably just have a single example and then suggest looking at `std::sync::poison::Mutex` for more, so that we don't have the detailed documentation repeated in multiple locations. Also make sure the doctests are using the right type here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126817691",
    "pr_number": 141260,
    "pr_file": "library/core/src/ptr/mod.rs",
    "created_at": "2025-06-04T14:54:56+00:00",
    "commented_code": "}\n }\n \n-/// Performs a volatile read of the value from `src` without moving it. This\n-/// leaves the memory in `src` unchanged.\n-///\n-/// Volatile operations are intended to act on I/O memory, and are guaranteed\n-/// to not be elided or reordered by the compiler across other volatile\n-/// operations.\n-///\n-/// # Notes\n-///\n-/// Rust does not currently have a rigorously and formally defined memory model,\n-/// so the precise semantics of what \"volatile\" means here is subject to change\n-/// over time. That being said, the semantics will almost always end up pretty\n-/// similar to [C11's definition of volatile][c11].\n-///\n-/// The compiler shouldn't change the relative order or number of volatile\n-/// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n-/// and may be ignored.\n+/// Performs a volatile read of the value from `src` without moving it.\n+///\n+/// Rust does not currently have a rigorously and formally defined memory model, so the precise\n+/// semantics of what \"volatile\" means here is subject to change over time. That being said, the\n+/// semantics will almost always end up pretty similar to [C11's definition of volatile][c11].",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2126817691",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 141260,
        "pr_file": "library/core/src/ptr/mod.rs",
        "discussion_id": "2126817691",
        "commented_code": "@@ -2021,54 +2026,68 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n     }\n }\n \n-/// Performs a volatile read of the value from `src` without moving it. This\n-/// leaves the memory in `src` unchanged.\n-///\n-/// Volatile operations are intended to act on I/O memory, and are guaranteed\n-/// to not be elided or reordered by the compiler across other volatile\n-/// operations.\n-///\n-/// # Notes\n-///\n-/// Rust does not currently have a rigorously and formally defined memory model,\n-/// so the precise semantics of what \"volatile\" means here is subject to change\n-/// over time. That being said, the semantics will almost always end up pretty\n-/// similar to [C11's definition of volatile][c11].\n-///\n-/// The compiler shouldn't change the relative order or number of volatile\n-/// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n-/// and may be ignored.\n+/// Performs a volatile read of the value from `src` without moving it.\n+///\n+/// Rust does not currently have a rigorously and formally defined memory model, so the precise\n+/// semantics of what \"volatile\" means here is subject to change over time. That being said, the\n+/// semantics will almost always end up pretty similar to [C11's definition of volatile][c11].",
        "comment_created_at": "2025-06-04T14:54:56+00:00",
        "comment_author": "RalfJung",
        "comment_body": "I wonder if we still need this paragraph. The next paragraph says basically as much as C says, after all.\r\n\r\n@rust-lang/opsem what do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "2155899180",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 141260,
        "pr_file": "library/core/src/ptr/mod.rs",
        "discussion_id": "2126817691",
        "commented_code": "@@ -2021,54 +2026,68 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n     }\n }\n \n-/// Performs a volatile read of the value from `src` without moving it. This\n-/// leaves the memory in `src` unchanged.\n-///\n-/// Volatile operations are intended to act on I/O memory, and are guaranteed\n-/// to not be elided or reordered by the compiler across other volatile\n-/// operations.\n-///\n-/// # Notes\n-///\n-/// Rust does not currently have a rigorously and formally defined memory model,\n-/// so the precise semantics of what \"volatile\" means here is subject to change\n-/// over time. That being said, the semantics will almost always end up pretty\n-/// similar to [C11's definition of volatile][c11].\n-///\n-/// The compiler shouldn't change the relative order or number of volatile\n-/// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n-/// and may be ignored.\n+/// Performs a volatile read of the value from `src` without moving it.\n+///\n+/// Rust does not currently have a rigorously and formally defined memory model, so the precise\n+/// semantics of what \"volatile\" means here is subject to change over time. That being said, the\n+/// semantics will almost always end up pretty similar to [C11's definition of volatile][c11].",
        "comment_created_at": "2025-06-19T02:07:36+00:00",
        "comment_author": "RalfJung",
        "comment_body": "If nobody else has an opinion, I'd say please remove this paragraph.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2108130825",
    "pr_number": 138907,
    "pr_file": "src/librustdoc/clean/types.rs",
    "created_at": "2025-05-27T04:23:39+00:00",
    "commented_code": ".flatten()\n }\n \n+#[derive(Clone, Debug)]\n+pub(crate) struct CfgInfo {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2108130825",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 138907,
        "pr_file": "src/librustdoc/clean/types.rs",
        "discussion_id": "2108130825",
        "commented_code": "@@ -1011,14 +988,85 @@ pub(crate) fn hir_attr_lists<'a, I: IntoIterator<Item = &'a hir::Attribute>>(\n         .flatten()\n }\n \n+#[derive(Clone, Debug)]\n+pub(crate) struct CfgInfo {",
        "comment_created_at": "2025-05-27T04:23:39+00:00",
        "comment_author": "Manishearth",
        "comment_body": "nit: document each field",
        "pr_file_module": null
      }
    ]
  }
]