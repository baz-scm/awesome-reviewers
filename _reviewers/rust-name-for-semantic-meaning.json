[
  {
    "discussion_id": "2219713717",
    "pr_number": 144239,
    "pr_file": "compiler/rustc_parse/src/lexer/mod.rs",
    "created_at": "2025-07-21T16:40:49+00:00",
    "commented_code": "};\n     let res = lexer.lex_token_trees(/* is_delimited */ false);\n \n-    let mut unmatched_delims: Vec<_> = lexer\n-        .diag_info\n-        .unmatched_delims\n-        .into_iter()\n-        .filter_map(|unmatched_delim| make_unclosed_delims_error(unmatched_delim, psess))\n-        .collect();\n+    let unmatched_delims: Vec<_> =",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2219713717",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144239,
        "pr_file": "compiler/rustc_parse/src/lexer/mod.rs",
        "discussion_id": "2219713717",
        "commented_code": "@@ -71,12 +71,8 @@ pub(crate) fn lex_token_trees<'psess, 'src>(\n     };\n     let res = lexer.lex_token_trees(/* is_delimited */ false);\n \n-    let mut unmatched_delims: Vec<_> = lexer\n-        .diag_info\n-        .unmatched_delims\n-        .into_iter()\n-        .filter_map(|unmatched_delim| make_unclosed_delims_error(unmatched_delim, psess))\n-        .collect();\n+    let unmatched_delims: Vec<_> =",
        "comment_created_at": "2025-07-21T16:40:49+00:00",
        "comment_author": "fee1-dead",
        "comment_body": "rename to `mismatched_closing_delims`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2108785853",
    "pr_number": 140794,
    "pr_file": "compiler/rustc_session/src/session.rs",
    "created_at": "2025-05-27T10:08:12+00:00",
    "commented_code": "}\n \n pub trait LintStoreMarker: Any + DynSync + DynSend {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2108785853",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 140794,
        "pr_file": "compiler/rustc_session/src/session.rs",
        "discussion_id": "2108785853",
        "commented_code": "@@ -139,7 +139,8 @@ pub struct CompilerIO {\n }\n \n pub trait LintStoreMarker: Any + DynSync + DynSend {",
        "comment_created_at": "2025-05-27T10:08:12+00:00",
        "comment_author": "davidtwco",
        "comment_body": "this may be better named `LintStore` now that it has a method",
        "pr_file_module": null
      },
      {
        "comment_id": "2116578946",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 140794,
        "pr_file": "compiler/rustc_session/src/session.rs",
        "discussion_id": "2108785853",
        "commented_code": "@@ -139,7 +139,8 @@ pub struct CompilerIO {\n }\n \n pub trait LintStoreMarker: Any + DynSync + DynSend {",
        "comment_created_at": "2025-05-30T20:17:12+00:00",
        "comment_author": "karolzwolak",
        "comment_body": "True, but I can't really think of any good name here. I guess `ErasedLintStore` maybe would be better? I agree that it shouldn't be a marker if it has a method.",
        "pr_file_module": null
      },
      {
        "comment_id": "2116676207",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 140794,
        "pr_file": "compiler/rustc_session/src/session.rs",
        "discussion_id": "2108785853",
        "commented_code": "@@ -139,7 +139,8 @@ pub struct CompilerIO {\n }\n \n pub trait LintStoreMarker: Any + DynSync + DynSend {",
        "comment_created_at": "2025-05-30T21:16:29+00:00",
        "comment_author": "Centri3",
        "comment_body": "Just my 2c, I usually use and see something like `DynLintStore`",
        "pr_file_module": null
      },
      {
        "comment_id": "2118989916",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 140794,
        "pr_file": "compiler/rustc_session/src/session.rs",
        "discussion_id": "2108785853",
        "commented_code": "@@ -139,7 +139,8 @@ pub struct CompilerIO {\n }\n \n pub trait LintStoreMarker: Any + DynSync + DynSend {",
        "comment_created_at": "2025-06-01T10:15:03+00:00",
        "comment_author": "karolzwolak",
        "comment_body": "Thanks, `DynLintStore` it is.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216315484",
    "pr_number": 143906,
    "pr_file": "src/tools/miri/src/math.rs",
    "created_at": "2025-07-18T15:16:42+00:00",
    "commented_code": "apply_random_float_error(ecx, val, err_scale)\n }\n \n-/// Applies a random 16ULP floating point error to `val` and returns the new value.\n+/// Applies a random ULP floating point error to `val` and returns the new value.\n+/// So if you want an X ULP error, `ulp_exponent` should be log2(X).\n+///\n /// Will fail if `val` is not a floating point number.\n pub(crate) fn apply_random_float_error_to_imm<'tcx>(\n     ecx: &mut MiriInterpCx<'tcx>,\n     val: ImmTy<'tcx>,\n     ulp_exponent: u32,\n ) -> InterpResult<'tcx, ImmTy<'tcx>> {\n+    let this = ecx.eval_context_mut();\n     let scalar = val.to_scalar_int()?;\n     let res: ScalarInt = match val.layout.ty.kind() {\n         ty::Float(FloatTy::F16) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f16(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f16(), ulp_exponent).into(),\n         ty::Float(FloatTy::F32) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f32(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f32(), ulp_exponent).into(),\n         ty::Float(FloatTy::F64) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f64(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f64(), ulp_exponent).into(),\n         ty::Float(FloatTy::F128) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f128(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f128(), ulp_exponent).into(),\n         _ => bug!(\"intrinsic called with non-float input type\"),\n     };\n \n     interp_ok(ImmTy::from_scalar_int(res, val.layout))\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub(crate) fn clamp_float_value<S: Semantics>(\n+    intrinsic_name: &str,\n+    val: IeeeFloat<S>,\n+) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg(), pi_over_2),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg(), one),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero, two),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        _ => val,\n+    }\n+}\n+\n+/// For the intrinsics:\n+/// - sinf32, sinf64, sinhf, sinh\n+/// - cosf32, cosf64, coshf, cosh\n+/// - tanhf, tanh, atanf, atan, atan2f, atan2\n+/// - expf32, expf64, exp2f32, exp2f64\n+/// - logf32, logf64, log2f32, log2f64, log10f32, log10f64\n+/// - powf32, powf64\n+/// - erff, erf, erfcf, erfc\n+/// - hypotf, hypot\n+///\n+/// # Return\n+///\n+/// Returns `Some(output)` if the `intrinsic` results in a defined fixed `output` specified in the C standard\n+/// (specifically, C23 annex F.10)  when given `args` as arguments. Outputs that are unaffected by a relative error\n+/// (such as INF and zero) are not handled here, they are assumed to be handled by the underlying\n+/// implementation. Returns `None` if no specific value is guaranteed.\n+///\n+/// # Note\n+///\n+/// For `powf*` operations of the form:\n+///\n+/// - `(SNaN)^(\u00b10)`\n+/// - `1^(SNaN)`\n+///\n+/// The result is implementation-defined:\n+/// - musl returns for both `1.0`\n+/// - glibc returns for both `NaN`\n+///\n+/// This discrepancy exists because SNaN handling is not consistently defined across platforms,\n+/// and the C standard leaves behavior for SNaNs unspecified.\n+///\n+/// Miri chooses to adhere to both implementations and returns either one of them non-deterministically.\n+pub(crate) fn fixed_float_value<S: Semantics>(\n+    ecx: &mut MiriInterpCx<'_>,\n+    intrinsic_name: &str,\n+    args: &[IeeeFloat<S>],\n+) -> Option<IeeeFloat<S>>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let this = ecx.eval_context_mut();\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let three = IeeeFloat::<S>::three();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+    let pi_over_4 = (pi_over_2 / two).value;\n+\n+    Some(match (intrinsic_name, args) {\n+        // cos(\u00b10) and cosh(\u00b10)= 1\n+        (\"cosf32\" | \"cosf64\" | \"coshf\" | \"cosh\", [input]) if input.is_zero() => one,\n+\n+        // e^0 = 1\n+        (\"expf32\" | \"expf64\" | \"exp2f32\" | \"exp2f64\", [input]) if input.is_zero() => one,\n+\n+        // tanh(\u00b1INF) = \u00b11\n+        (\"tanhf\" | \"tanh\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // atan(\u00b1INF) = \u00b1\u03c0/2\n+        (\"atanf\" | \"atan\", [input]) if input.is_infinite() => pi_over_2.copy_sign(*input),\n+\n+        // erf(\u00b1INF) = \u00b11\n+        (\"erff\" | \"erf\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // erfc(-INF) = 2\n+        (\"erfcf\" | \"erfc\", [input]) if input.is_neg_infinity() => (one + one).value,\n+\n+        // hypot(x, \u00b10) = abs(x), if x is not a NaN.\n+        (\"_hypotf\" | \"hypotf\" | \"_hypot\" | \"hypot\", [x, y]) if !x.is_nan() && y.is_zero() =>\n+            x.abs(),\n+\n+        // atan2(\u00b10,\u22120) = \u00b1\u03c0.\n+        // atan2(\u00b10, y) = \u00b1\u03c0 for y < 0.\n+        // Must check for non NaN because `y.is_negative()` also applies to NaN.\n+        (\"atan2f\" | \"atan2\", [x, y]) if (x.is_zero() && (y.is_negative() && !y.is_nan())) =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(\u00b1x,\u2212\u221e) = \u00b1\u03c0 for finite x > 0.\n+        (\"atan2f\" | \"atan2\", [x, y])\n+            if (!x.is_zero() && !x.is_infinite()) && y.is_neg_infinity() =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(x, \u00b10) = \u2212\u03c0/2 for x < 0.\n+        // atan2(x, \u00b10) =  \u03c0/2 for x > 0.\n+        // REVIEW: Above is from C23, do we simplify this to the following?\n+        // atan2(\u00b1x, 0) = \u00b1\u03c0/2 if x is non-zero",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2216315484",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143906,
        "pr_file": "src/tools/miri/src/math.rs",
        "discussion_id": "2216315484",
        "commented_code": "@@ -50,29 +53,251 @@ pub(crate) fn apply_random_float_error_ulp<F: rustc_apfloat::Float>(\n     apply_random_float_error(ecx, val, err_scale)\n }\n \n-/// Applies a random 16ULP floating point error to `val` and returns the new value.\n+/// Applies a random ULP floating point error to `val` and returns the new value.\n+/// So if you want an X ULP error, `ulp_exponent` should be log2(X).\n+///\n /// Will fail if `val` is not a floating point number.\n pub(crate) fn apply_random_float_error_to_imm<'tcx>(\n     ecx: &mut MiriInterpCx<'tcx>,\n     val: ImmTy<'tcx>,\n     ulp_exponent: u32,\n ) -> InterpResult<'tcx, ImmTy<'tcx>> {\n+    let this = ecx.eval_context_mut();\n     let scalar = val.to_scalar_int()?;\n     let res: ScalarInt = match val.layout.ty.kind() {\n         ty::Float(FloatTy::F16) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f16(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f16(), ulp_exponent).into(),\n         ty::Float(FloatTy::F32) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f32(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f32(), ulp_exponent).into(),\n         ty::Float(FloatTy::F64) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f64(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f64(), ulp_exponent).into(),\n         ty::Float(FloatTy::F128) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f128(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f128(), ulp_exponent).into(),\n         _ => bug!(\"intrinsic called with non-float input type\"),\n     };\n \n     interp_ok(ImmTy::from_scalar_int(res, val.layout))\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub(crate) fn clamp_float_value<S: Semantics>(\n+    intrinsic_name: &str,\n+    val: IeeeFloat<S>,\n+) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg(), pi_over_2),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg(), one),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero, two),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        _ => val,\n+    }\n+}\n+\n+/// For the intrinsics:\n+/// - sinf32, sinf64, sinhf, sinh\n+/// - cosf32, cosf64, coshf, cosh\n+/// - tanhf, tanh, atanf, atan, atan2f, atan2\n+/// - expf32, expf64, exp2f32, exp2f64\n+/// - logf32, logf64, log2f32, log2f64, log10f32, log10f64\n+/// - powf32, powf64\n+/// - erff, erf, erfcf, erfc\n+/// - hypotf, hypot\n+///\n+/// # Return\n+///\n+/// Returns `Some(output)` if the `intrinsic` results in a defined fixed `output` specified in the C standard\n+/// (specifically, C23 annex F.10)  when given `args` as arguments. Outputs that are unaffected by a relative error\n+/// (such as INF and zero) are not handled here, they are assumed to be handled by the underlying\n+/// implementation. Returns `None` if no specific value is guaranteed.\n+///\n+/// # Note\n+///\n+/// For `powf*` operations of the form:\n+///\n+/// - `(SNaN)^(\u00b10)`\n+/// - `1^(SNaN)`\n+///\n+/// The result is implementation-defined:\n+/// - musl returns for both `1.0`\n+/// - glibc returns for both `NaN`\n+///\n+/// This discrepancy exists because SNaN handling is not consistently defined across platforms,\n+/// and the C standard leaves behavior for SNaNs unspecified.\n+///\n+/// Miri chooses to adhere to both implementations and returns either one of them non-deterministically.\n+pub(crate) fn fixed_float_value<S: Semantics>(\n+    ecx: &mut MiriInterpCx<'_>,\n+    intrinsic_name: &str,\n+    args: &[IeeeFloat<S>],\n+) -> Option<IeeeFloat<S>>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let this = ecx.eval_context_mut();\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let three = IeeeFloat::<S>::three();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+    let pi_over_4 = (pi_over_2 / two).value;\n+\n+    Some(match (intrinsic_name, args) {\n+        // cos(\u00b10) and cosh(\u00b10)= 1\n+        (\"cosf32\" | \"cosf64\" | \"coshf\" | \"cosh\", [input]) if input.is_zero() => one,\n+\n+        // e^0 = 1\n+        (\"expf32\" | \"expf64\" | \"exp2f32\" | \"exp2f64\", [input]) if input.is_zero() => one,\n+\n+        // tanh(\u00b1INF) = \u00b11\n+        (\"tanhf\" | \"tanh\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // atan(\u00b1INF) = \u00b1\u03c0/2\n+        (\"atanf\" | \"atan\", [input]) if input.is_infinite() => pi_over_2.copy_sign(*input),\n+\n+        // erf(\u00b1INF) = \u00b11\n+        (\"erff\" | \"erf\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // erfc(-INF) = 2\n+        (\"erfcf\" | \"erfc\", [input]) if input.is_neg_infinity() => (one + one).value,\n+\n+        // hypot(x, \u00b10) = abs(x), if x is not a NaN.\n+        (\"_hypotf\" | \"hypotf\" | \"_hypot\" | \"hypot\", [x, y]) if !x.is_nan() && y.is_zero() =>\n+            x.abs(),\n+\n+        // atan2(\u00b10,\u22120) = \u00b1\u03c0.\n+        // atan2(\u00b10, y) = \u00b1\u03c0 for y < 0.\n+        // Must check for non NaN because `y.is_negative()` also applies to NaN.\n+        (\"atan2f\" | \"atan2\", [x, y]) if (x.is_zero() && (y.is_negative() && !y.is_nan())) =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(\u00b1x,\u2212\u221e) = \u00b1\u03c0 for finite x > 0.\n+        (\"atan2f\" | \"atan2\", [x, y])\n+            if (!x.is_zero() && !x.is_infinite()) && y.is_neg_infinity() =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(x, \u00b10) = \u2212\u03c0/2 for x < 0.\n+        // atan2(x, \u00b10) =  \u03c0/2 for x > 0.\n+        // REVIEW: Above is from C23, do we simplify this to the following?\n+        // atan2(\u00b1x, 0) = \u00b1\u03c0/2 if x is non-zero",
        "comment_created_at": "2025-07-18T15:16:42+00:00",
        "comment_author": "RalfJung",
        "comment_body": "I don't understand the question. What is `\u00b1x` even supposed to mean?",
        "pr_file_module": null
      },
      {
        "comment_id": "2216489362",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143906,
        "pr_file": "src/tools/miri/src/math.rs",
        "discussion_id": "2216315484",
        "commented_code": "@@ -50,29 +53,251 @@ pub(crate) fn apply_random_float_error_ulp<F: rustc_apfloat::Float>(\n     apply_random_float_error(ecx, val, err_scale)\n }\n \n-/// Applies a random 16ULP floating point error to `val` and returns the new value.\n+/// Applies a random ULP floating point error to `val` and returns the new value.\n+/// So if you want an X ULP error, `ulp_exponent` should be log2(X).\n+///\n /// Will fail if `val` is not a floating point number.\n pub(crate) fn apply_random_float_error_to_imm<'tcx>(\n     ecx: &mut MiriInterpCx<'tcx>,\n     val: ImmTy<'tcx>,\n     ulp_exponent: u32,\n ) -> InterpResult<'tcx, ImmTy<'tcx>> {\n+    let this = ecx.eval_context_mut();\n     let scalar = val.to_scalar_int()?;\n     let res: ScalarInt = match val.layout.ty.kind() {\n         ty::Float(FloatTy::F16) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f16(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f16(), ulp_exponent).into(),\n         ty::Float(FloatTy::F32) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f32(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f32(), ulp_exponent).into(),\n         ty::Float(FloatTy::F64) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f64(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f64(), ulp_exponent).into(),\n         ty::Float(FloatTy::F128) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f128(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f128(), ulp_exponent).into(),\n         _ => bug!(\"intrinsic called with non-float input type\"),\n     };\n \n     interp_ok(ImmTy::from_scalar_int(res, val.layout))\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub(crate) fn clamp_float_value<S: Semantics>(\n+    intrinsic_name: &str,\n+    val: IeeeFloat<S>,\n+) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg(), pi_over_2),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg(), one),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero, two),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        _ => val,\n+    }\n+}\n+\n+/// For the intrinsics:\n+/// - sinf32, sinf64, sinhf, sinh\n+/// - cosf32, cosf64, coshf, cosh\n+/// - tanhf, tanh, atanf, atan, atan2f, atan2\n+/// - expf32, expf64, exp2f32, exp2f64\n+/// - logf32, logf64, log2f32, log2f64, log10f32, log10f64\n+/// - powf32, powf64\n+/// - erff, erf, erfcf, erfc\n+/// - hypotf, hypot\n+///\n+/// # Return\n+///\n+/// Returns `Some(output)` if the `intrinsic` results in a defined fixed `output` specified in the C standard\n+/// (specifically, C23 annex F.10)  when given `args` as arguments. Outputs that are unaffected by a relative error\n+/// (such as INF and zero) are not handled here, they are assumed to be handled by the underlying\n+/// implementation. Returns `None` if no specific value is guaranteed.\n+///\n+/// # Note\n+///\n+/// For `powf*` operations of the form:\n+///\n+/// - `(SNaN)^(\u00b10)`\n+/// - `1^(SNaN)`\n+///\n+/// The result is implementation-defined:\n+/// - musl returns for both `1.0`\n+/// - glibc returns for both `NaN`\n+///\n+/// This discrepancy exists because SNaN handling is not consistently defined across platforms,\n+/// and the C standard leaves behavior for SNaNs unspecified.\n+///\n+/// Miri chooses to adhere to both implementations and returns either one of them non-deterministically.\n+pub(crate) fn fixed_float_value<S: Semantics>(\n+    ecx: &mut MiriInterpCx<'_>,\n+    intrinsic_name: &str,\n+    args: &[IeeeFloat<S>],\n+) -> Option<IeeeFloat<S>>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let this = ecx.eval_context_mut();\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let three = IeeeFloat::<S>::three();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+    let pi_over_4 = (pi_over_2 / two).value;\n+\n+    Some(match (intrinsic_name, args) {\n+        // cos(\u00b10) and cosh(\u00b10)= 1\n+        (\"cosf32\" | \"cosf64\" | \"coshf\" | \"cosh\", [input]) if input.is_zero() => one,\n+\n+        // e^0 = 1\n+        (\"expf32\" | \"expf64\" | \"exp2f32\" | \"exp2f64\", [input]) if input.is_zero() => one,\n+\n+        // tanh(\u00b1INF) = \u00b11\n+        (\"tanhf\" | \"tanh\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // atan(\u00b1INF) = \u00b1\u03c0/2\n+        (\"atanf\" | \"atan\", [input]) if input.is_infinite() => pi_over_2.copy_sign(*input),\n+\n+        // erf(\u00b1INF) = \u00b11\n+        (\"erff\" | \"erf\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // erfc(-INF) = 2\n+        (\"erfcf\" | \"erfc\", [input]) if input.is_neg_infinity() => (one + one).value,\n+\n+        // hypot(x, \u00b10) = abs(x), if x is not a NaN.\n+        (\"_hypotf\" | \"hypotf\" | \"_hypot\" | \"hypot\", [x, y]) if !x.is_nan() && y.is_zero() =>\n+            x.abs(),\n+\n+        // atan2(\u00b10,\u22120) = \u00b1\u03c0.\n+        // atan2(\u00b10, y) = \u00b1\u03c0 for y < 0.\n+        // Must check for non NaN because `y.is_negative()` also applies to NaN.\n+        (\"atan2f\" | \"atan2\", [x, y]) if (x.is_zero() && (y.is_negative() && !y.is_nan())) =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(\u00b1x,\u2212\u221e) = \u00b1\u03c0 for finite x > 0.\n+        (\"atan2f\" | \"atan2\", [x, y])\n+            if (!x.is_zero() && !x.is_infinite()) && y.is_neg_infinity() =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(x, \u00b10) = \u2212\u03c0/2 for x < 0.\n+        // atan2(x, \u00b10) =  \u03c0/2 for x > 0.\n+        // REVIEW: Above is from C23, do we simplify this to the following?\n+        // atan2(\u00b1x, 0) = \u00b1\u03c0/2 if x is non-zero",
        "comment_created_at": "2025-07-18T16:53:29+00:00",
        "comment_author": "LorrensP-2158466",
        "comment_body": "If `x` is positive, it should return `+pi/2`.\r\nIf `x` is negative, it should return `-pi/2`. \r\n\r\nThe C standard uses this format (\u00b1 -> \u00b1) quite often, but here `x` can't be zero, so it chose to split the definition. And I copied that, as you can see in the other arms.\r\n\r\nBut I'd like to keep the comment 1 line long if possible, and here it is possible.",
        "pr_file_module": null
      },
      {
        "comment_id": "2217256305",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143906,
        "pr_file": "src/tools/miri/src/math.rs",
        "discussion_id": "2216315484",
        "commented_code": "@@ -50,29 +53,251 @@ pub(crate) fn apply_random_float_error_ulp<F: rustc_apfloat::Float>(\n     apply_random_float_error(ecx, val, err_scale)\n }\n \n-/// Applies a random 16ULP floating point error to `val` and returns the new value.\n+/// Applies a random ULP floating point error to `val` and returns the new value.\n+/// So if you want an X ULP error, `ulp_exponent` should be log2(X).\n+///\n /// Will fail if `val` is not a floating point number.\n pub(crate) fn apply_random_float_error_to_imm<'tcx>(\n     ecx: &mut MiriInterpCx<'tcx>,\n     val: ImmTy<'tcx>,\n     ulp_exponent: u32,\n ) -> InterpResult<'tcx, ImmTy<'tcx>> {\n+    let this = ecx.eval_context_mut();\n     let scalar = val.to_scalar_int()?;\n     let res: ScalarInt = match val.layout.ty.kind() {\n         ty::Float(FloatTy::F16) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f16(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f16(), ulp_exponent).into(),\n         ty::Float(FloatTy::F32) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f32(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f32(), ulp_exponent).into(),\n         ty::Float(FloatTy::F64) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f64(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f64(), ulp_exponent).into(),\n         ty::Float(FloatTy::F128) =>\n-            apply_random_float_error_ulp(ecx, scalar.to_f128(), ulp_exponent).into(),\n+            apply_random_float_error_ulp(this, scalar.to_f128(), ulp_exponent).into(),\n         _ => bug!(\"intrinsic called with non-float input type\"),\n     };\n \n     interp_ok(ImmTy::from_scalar_int(res, val.layout))\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub(crate) fn clamp_float_value<S: Semantics>(\n+    intrinsic_name: &str,\n+    val: IeeeFloat<S>,\n+) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg(), pi_over_2),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg(), one),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero, two),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        _ => val,\n+    }\n+}\n+\n+/// For the intrinsics:\n+/// - sinf32, sinf64, sinhf, sinh\n+/// - cosf32, cosf64, coshf, cosh\n+/// - tanhf, tanh, atanf, atan, atan2f, atan2\n+/// - expf32, expf64, exp2f32, exp2f64\n+/// - logf32, logf64, log2f32, log2f64, log10f32, log10f64\n+/// - powf32, powf64\n+/// - erff, erf, erfcf, erfc\n+/// - hypotf, hypot\n+///\n+/// # Return\n+///\n+/// Returns `Some(output)` if the `intrinsic` results in a defined fixed `output` specified in the C standard\n+/// (specifically, C23 annex F.10)  when given `args` as arguments. Outputs that are unaffected by a relative error\n+/// (such as INF and zero) are not handled here, they are assumed to be handled by the underlying\n+/// implementation. Returns `None` if no specific value is guaranteed.\n+///\n+/// # Note\n+///\n+/// For `powf*` operations of the form:\n+///\n+/// - `(SNaN)^(\u00b10)`\n+/// - `1^(SNaN)`\n+///\n+/// The result is implementation-defined:\n+/// - musl returns for both `1.0`\n+/// - glibc returns for both `NaN`\n+///\n+/// This discrepancy exists because SNaN handling is not consistently defined across platforms,\n+/// and the C standard leaves behavior for SNaNs unspecified.\n+///\n+/// Miri chooses to adhere to both implementations and returns either one of them non-deterministically.\n+pub(crate) fn fixed_float_value<S: Semantics>(\n+    ecx: &mut MiriInterpCx<'_>,\n+    intrinsic_name: &str,\n+    args: &[IeeeFloat<S>],\n+) -> Option<IeeeFloat<S>>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let this = ecx.eval_context_mut();\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let three = IeeeFloat::<S>::three();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = (pi / two).value;\n+    let pi_over_4 = (pi_over_2 / two).value;\n+\n+    Some(match (intrinsic_name, args) {\n+        // cos(\u00b10) and cosh(\u00b10)= 1\n+        (\"cosf32\" | \"cosf64\" | \"coshf\" | \"cosh\", [input]) if input.is_zero() => one,\n+\n+        // e^0 = 1\n+        (\"expf32\" | \"expf64\" | \"exp2f32\" | \"exp2f64\", [input]) if input.is_zero() => one,\n+\n+        // tanh(\u00b1INF) = \u00b11\n+        (\"tanhf\" | \"tanh\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // atan(\u00b1INF) = \u00b1\u03c0/2\n+        (\"atanf\" | \"atan\", [input]) if input.is_infinite() => pi_over_2.copy_sign(*input),\n+\n+        // erf(\u00b1INF) = \u00b11\n+        (\"erff\" | \"erf\", [input]) if input.is_infinite() => one.copy_sign(*input),\n+\n+        // erfc(-INF) = 2\n+        (\"erfcf\" | \"erfc\", [input]) if input.is_neg_infinity() => (one + one).value,\n+\n+        // hypot(x, \u00b10) = abs(x), if x is not a NaN.\n+        (\"_hypotf\" | \"hypotf\" | \"_hypot\" | \"hypot\", [x, y]) if !x.is_nan() && y.is_zero() =>\n+            x.abs(),\n+\n+        // atan2(\u00b10,\u22120) = \u00b1\u03c0.\n+        // atan2(\u00b10, y) = \u00b1\u03c0 for y < 0.\n+        // Must check for non NaN because `y.is_negative()` also applies to NaN.\n+        (\"atan2f\" | \"atan2\", [x, y]) if (x.is_zero() && (y.is_negative() && !y.is_nan())) =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(\u00b1x,\u2212\u221e) = \u00b1\u03c0 for finite x > 0.\n+        (\"atan2f\" | \"atan2\", [x, y])\n+            if (!x.is_zero() && !x.is_infinite()) && y.is_neg_infinity() =>\n+            pi.copy_sign(*x),\n+\n+        // atan2(x, \u00b10) = \u2212\u03c0/2 for x < 0.\n+        // atan2(x, \u00b10) =  \u03c0/2 for x > 0.\n+        // REVIEW: Above is from C23, do we simplify this to the following?\n+        // atan2(\u00b1x, 0) = \u00b1\u03c0/2 if x is non-zero",
        "comment_created_at": "2025-07-19T09:30:58+00:00",
        "comment_author": "RalfJung",
        "comment_body": "> The C standard uses this format (\u00b1 -> \u00b1) quite often, \r\n\r\nAll the other times you use it, it was `\u00b1const`. I find its use with a variable `x` much less clear, and it seems like C23 also doesn't do that, so let's not.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2185775573",
    "pr_number": 143431,
    "pr_file": "compiler/rustc_trait_selection/src/error_reporting/traits/suggestions.rs",
    "created_at": "2025-07-04T16:47:00+00:00",
    "commented_code": "ty::ClauseKind::Trait(trait_pred) => {\n                             let def_id = trait_pred.def_id();\n                             let visible_item = if let Some(local) = def_id.as_local() {\n-                                // Check for local traits being reachable.\n-                                let vis = &tcx.resolutions(()).effective_visibilities;\n-                                // Account for non-`pub` traits in the root of the local crate.\n-                                let is_locally_reachable = tcx.parent(def_id).is_crate_root();\n-                                vis.is_reachable(local) || is_locally_reachable\n+                                let ty = trait_pred.self_ty();\n+                                if let Some(id) = ty.def_id_for_ty_in_cycle() {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2185775573",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143431,
        "pr_file": "compiler/rustc_trait_selection/src/error_reporting/traits/suggestions.rs",
        "discussion_id": "2185775573",
        "commented_code": "@@ -2775,11 +2776,20 @@ impl<'a, 'tcx> TypeErrCtxt<'a, 'tcx> {\n                         ty::ClauseKind::Trait(trait_pred) => {\n                             let def_id = trait_pred.def_id();\n                             let visible_item = if let Some(local) = def_id.as_local() {\n-                                // Check for local traits being reachable.\n-                                let vis = &tcx.resolutions(()).effective_visibilities;\n-                                // Account for non-`pub` traits in the root of the local crate.\n-                                let is_locally_reachable = tcx.parent(def_id).is_crate_root();\n-                                vis.is_reachable(local) || is_locally_reachable\n+                                let ty = trait_pred.self_ty();\n+                                if let Some(id) = ty.def_id_for_ty_in_cycle() {",
        "comment_created_at": "2025-07-04T16:47:00+00:00",
        "comment_author": "compiler-errors",
        "comment_body": "Also, please give `id` a better name; we already have `def_id` in scope.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2196874281",
    "pr_number": 143641,
    "pr_file": "src/bootstrap/src/core/build_steps/tool.rs",
    "created_at": "2025-07-10T07:41:30+00:00",
    "commented_code": "#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub struct LlvmBitcodeLinker {\n-    pub build_compiler: Compiler,\n-    pub target: TargetSelection,\n+    build_compiler: Compiler,\n+    target: TargetSelection,\n+}\n+\n+impl LlvmBitcodeLinker {\n+    /// Returns `LlvmBitcodeLinker` that should be **used** by the passed compiler.\n+    pub fn for_compiler(builder: &Builder<'_>, target_compiler: Compiler) -> Self {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2196874281",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143641,
        "pr_file": "src/bootstrap/src/core/build_steps/tool.rs",
        "discussion_id": "2196874281",
        "commented_code": "@@ -1159,8 +1159,21 @@ impl Step for RustAnalyzerProcMacroSrv {\n \n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub struct LlvmBitcodeLinker {\n-    pub build_compiler: Compiler,\n-    pub target: TargetSelection,\n+    build_compiler: Compiler,\n+    target: TargetSelection,\n+}\n+\n+impl LlvmBitcodeLinker {\n+    /// Returns `LlvmBitcodeLinker` that should be **used** by the passed compiler.\n+    pub fn for_compiler(builder: &Builder<'_>, target_compiler: Compiler) -> Self {",
        "comment_created_at": "2025-07-10T07:41:30+00:00",
        "comment_author": "jieyouxu",
        "comment_body": "Suggestion: `for_use_by_compiler`?",
        "pr_file_module": null
      }
    ]
  }
]