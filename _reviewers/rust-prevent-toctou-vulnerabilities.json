[
  {
    "discussion_id": "2118856674",
    "pr_number": 141847,
    "pr_file": "library/std/src/fs.rs",
    "created_at": "2025-06-01T08:01:48+00:00",
    "commented_code": "//! filesystem. All methods in this module represent cross-platform filesystem\n //! operations. Extra platform-specific functionality can be found in the\n //! extension traits of `std::os::$platform`.\n+//!\n+//! # Time of Check to Time of Use (TOCTOU)\n+//!\n+//! Many filesystem operations are subject to a race condition known as \"Time of Check to Time of Use\"\n+//! (TOCTOU). This occurs when a program checks a condition (like file existence or permissions)\n+//! and then uses the result of that check to make a decision, but the condition may have changed\n+//! between the check and the use.\n+//!\n+//! For example, checking if a file exists and then creating it if it doesn't is vulnerable to\n+//! TOCTOU - another process could create the file between your check and creation attempt.\n+//!\n+//! Be aware that metadata operations (like [`metadata`] or [`symlink_metadata`]) may be affected by\n+//! changes made by other processes.\n+//!\n+//! To avoid TOCTOU issues:\n+//! - Use atomic operations when possible (like [`File::create_new`] instead of checking existence then creating)\n+//! - Keep file handles open for the duration of operations\n+//! - Use file locking when appropriate",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2118856674",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 141847,
        "pr_file": "library/std/src/fs.rs",
        "discussion_id": "2118856674",
        "commented_code": "@@ -4,6 +4,26 @@\n //! filesystem. All methods in this module represent cross-platform filesystem\n //! operations. Extra platform-specific functionality can be found in the\n //! extension traits of `std::os::$platform`.\n+//!\n+//! # Time of Check to Time of Use (TOCTOU)\n+//!\n+//! Many filesystem operations are subject to a race condition known as \"Time of Check to Time of Use\"\n+//! (TOCTOU). This occurs when a program checks a condition (like file existence or permissions)\n+//! and then uses the result of that check to make a decision, but the condition may have changed\n+//! between the check and the use.\n+//!\n+//! For example, checking if a file exists and then creating it if it doesn't is vulnerable to\n+//! TOCTOU - another process could create the file between your check and creation attempt.\n+//!\n+//! Be aware that metadata operations (like [`metadata`] or [`symlink_metadata`]) may be affected by\n+//! changes made by other processes.\n+//!\n+//! To avoid TOCTOU issues:\n+//! - Use atomic operations when possible (like [`File::create_new`] instead of checking existence then creating)\n+//! - Keep file handles open for the duration of operations\n+//! - Use file locking when appropriate",
        "comment_created_at": "2025-06-01T08:01:48+00:00",
        "comment_author": "ChrisDenton",
        "comment_body": "I don't think locking should be mentioned here. Locks are advisory on many platforms and even on systems where they're not there can be ways to bypass them. They're useful for cooperative processes but don't necessarily guard against malicious ones.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2120639054",
    "pr_number": 141847,
    "pr_file": "library/std/src/fs.rs",
    "created_at": "2025-06-02T09:58:19+00:00",
    "commented_code": "//! filesystem. All methods in this module represent cross-platform filesystem\n //! operations. Extra platform-specific functionality can be found in the\n //! extension traits of `std::os::$platform`.\n+//!\n+//! # Time of Check to Time of Use (TOCTOU)\n+//!\n+//! Many filesystem operations are subject to a race condition known as \"Time of Check to Time of Use\"\n+//! (TOCTOU). This occurs when a program checks a condition (like file existence or permissions)\n+//! and then uses the result of that check to make a decision, but the condition may have changed\n+//! between the check and the use.\n+//!\n+//! For example, checking if a file exists and then creating it if it doesn't is vulnerable to\n+//! TOCTOU - another process could create the file between your check and creation attempt.\n+//!\n+//! Another example is with symbolic links: when removing a directory, if another process replaces\n+//! the directory with a symbolic link between the check and the removal operation, the removal\n+//! might affect the wrong location. This is why operations like [`remove_dir_all`] need to use\n+//! atomic operations to prevent such race conditions.\n+//!\n+//! To avoid TOCTOU issues:\n+//! - Be aware that metadata operations (like [`metadata`] or [`symlink_metadata`]) may be affected by\n+//! changes made by other processes.\n+//! - Use atomic operations when possible (like [`File::create_new`] instead of checking existence then creating).\n+//! - Keep file open for the duration of operations.",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2120639054",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 141847,
        "pr_file": "library/std/src/fs.rs",
        "discussion_id": "2120639054",
        "commented_code": "@@ -4,6 +4,27 @@\n //! filesystem. All methods in this module represent cross-platform filesystem\n //! operations. Extra platform-specific functionality can be found in the\n //! extension traits of `std::os::$platform`.\n+//!\n+//! # Time of Check to Time of Use (TOCTOU)\n+//!\n+//! Many filesystem operations are subject to a race condition known as \"Time of Check to Time of Use\"\n+//! (TOCTOU). This occurs when a program checks a condition (like file existence or permissions)\n+//! and then uses the result of that check to make a decision, but the condition may have changed\n+//! between the check and the use.\n+//!\n+//! For example, checking if a file exists and then creating it if it doesn't is vulnerable to\n+//! TOCTOU - another process could create the file between your check and creation attempt.\n+//!\n+//! Another example is with symbolic links: when removing a directory, if another process replaces\n+//! the directory with a symbolic link between the check and the removal operation, the removal\n+//! might affect the wrong location. This is why operations like [`remove_dir_all`] need to use\n+//! atomic operations to prevent such race conditions.\n+//!\n+//! To avoid TOCTOU issues:\n+//! - Be aware that metadata operations (like [`metadata`] or [`symlink_metadata`]) may be affected by\n+//! changes made by other processes.\n+//! - Use atomic operations when possible (like [`File::create_new`] instead of checking existence then creating).\n+//! - Keep file open for the duration of operations.",
        "comment_created_at": "2025-06-02T09:58:19+00:00",
        "comment_author": "xizheyin",
        "comment_body": "Here,\r\n1. first explain *what is `TOCTOU`*\r\n2. present two examples including `create` and `remove_dir_all`, from simple to complex.\r\n3. give three notes to try to avoid `TOCTOU`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169868382",
    "pr_number": 142924,
    "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
    "created_at": "2025-06-26T19:55:58+00:00",
    "commented_code": "+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2169868382",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T19:55:58+00:00",
        "comment_author": "RalfJung",
        "comment_body": "So, uh, do all of these `npx` invocations basically mean \"download random JS from the web and run it locally\"? Without any kind of lockfile ensuring integrity of the download? That seems... bad? Definitely not something I want to see happen on my dev machine.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169879370",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:01:30+00:00",
        "comment_author": "yotamofek",
        "comment_body": "Well, `npx` will first look for an `eslint` installed with `npm install [-g]`, but otherwise yeah. See #142902 (which I intend to get to, but am waiting for this PR to be merged first, since it will probably conflict with the PR I'll open for that).",
        "pr_file_module": null
      },
      {
        "comment_id": "2169880909",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:02:43+00:00",
        "comment_author": "yotamofek",
        "comment_body": "I mean, `npm install eslint@some.specific.version && npx eslint` is the same as `npx eslint@some.specific.version`,\r\nin the sense that without a `package-lock.json` file (and an `--frozen` flag, I think?) both will run a certain version of `eslint`, but might run any semver-compatible version of the direct and transient deps.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169886671",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:06:07+00:00",
        "comment_author": "RalfJung",
        "comment_body": "Yeah, I don't think we should do any of that without *explicit* consent from the user. Running arbitrary code without integrity checks is a complete no-go.\r\n\r\nAlso, as far as I can see the commands here don't do the `@some-version` part.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169893490",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:09:53+00:00",
        "comment_author": "RalfJung",
        "comment_body": "> See https://github.com/rust-lang/rust/issues/142902 (which I intend to get to, but am waiting for this PR to be merged first, since it will probably conflict with the PR I'll open for that).\r\n\r\nI think it is crucial that we start having proper lockfiles *before* we do do any sort of remote code execution from npm.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169909277",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:18:00+00:00",
        "comment_author": "yotamofek",
        "comment_body": "> Yeah, I don't think we should do any of that without _explicit_ consent from the user. Running arbitrary code without integrity checks is a complete no-go.\r\n\r\nWell, at least this PR will make the `eslint` check opt-in and not just might-be-opted-in-if-you-happen-to-have-a-specific-eslint-version-installed.\r\n\r\n> \r\n> Also, as far as I can see the commands here don't do the `@some-version` part.\r\n\r\nYeah, but since `npx` won't be invoked unless the correct (i.e. rustc-repo-specified) version of `eslint` is installed, it has the same effect.\r\n\r\n> I think it is crucial that we start having proper lockfiles before we do do any sort of remote code execution from npm.\r\n\r\nI'm not disagreeing, or down-playing the hazard here, but I just want to point out that this PR is merely moving this code around and asking the user to opt-in to it.\r\n\r\nThe state right now, before this PR, is that running `tidy` will ask you to run `npm install eslint@some-version`, and then will run that version of `eslint` the next time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169914180",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:19:43+00:00",
        "comment_author": "yotamofek",
        "comment_body": "We *could* say \"oh well, we asked the user to run install some npm package without a `package-lock.json` and he did, now that's his problem\", but otherwise whether we check if that version is already installed and then run it with `npx`, or just run it with `npx eslint@that-version` doesn't make that much of a difference IMHO.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169915885",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:20:19+00:00",
        "comment_author": "yotamofek",
        "comment_body": "Given the current state of things, not running the version check with `npm` just makes `tidy` a bit faster for whoever is already opting in to the `eslint` check, with this PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169956305",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:35:29+00:00",
        "comment_author": "RalfJung",
        "comment_body": "> The state right now, before this PR, is that running tidy will ask you to run npm install eslint@some-version, and then will run that version of eslint the next time.\r\n\r\nThat is a way of asking for explicit consent, and very different from running `npm install` on the user's behalf.\r\n\r\n> Yeah, but since npx won't be invoked unless the correct (i.e. rustc-repo-specified) version of eslint is installed, it has the same effect.\r\n\r\nThat is because of the check which you [suggested](https://github.com/rust-lang/rust/pull/142924#discussion_r2169821683) could be removed, right? Also, this comment here is attached to something doing `npx tsc`, not eslint, so -- I don't follow.\r\n\r\n> whether we check if that version is already installed and then run it with npx, or just run it with npx eslint@that-version doesn't make that much of a difference IMHO.\r\n\r\nIt makes a huge difference whether you ask the user to do something vs whether you just do it without asking them. Asking for consent is different from just assuming consent!",
        "pr_file_module": null
      },
      {
        "comment_id": "2169968559",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:42:49+00:00",
        "comment_author": "RalfJung",
        "comment_body": "> The state right now, before this PR, is that running tidy will ask you to run npm install eslint@some-version, and then will run that version of eslint the next time.\r\n\r\nI would say the state before the PR is that tidy asks me to install eslint, and then I just don't do that, and everything is fine. I don't touch the JS files in this repo anyway, so I will happily ignore tidy's warning.\r\n\r\nIf even with this PR eslint is only run if it is already installed, then why use `npx` at all? Without a lockfile I feel like every single `npx` invocation needs a comment explaining why this is *not* remote code execution without integrity checks but just running something the user has already installed -- which defeats the entire purpose of `npx` as I understand it (but I may well misunderstand it, I am not familiar with the JS ecosystem).",
        "pr_file_module": null
      },
      {
        "comment_id": "2169971102",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:44:18+00:00",
        "comment_author": "yotamofek",
        "comment_body": "> That is because of the check which you https://github.com/rust-lang/rust/pull/142924#discussion_r2169821683 could be removed, right? Also, this comment here is attached to something doing npx tsc, not eslint, so -- I don't follow.\r\n\r\nOh woops, completely missed that this was a different `npx` invocation. Sorry about the confusion! So yeah, the versoin of `tsc` that `npx` will run here is completely arbitrary (`tsc` and all its transitive dependencies).\r\n\r\n> It makes a huge difference whether you ask the user to do something vs whether you just do it without asking them. Asking for consent is different from just assuming consent!\r\n\r\nAbsolutely. I just meant that asking for consent does not absolve \"us\" (as in, the rustc repo) from also including a `package-lock.json` file so that the user is downloading/installing, either implicitly or explicitly, a pre-determined set of packages that won't change just because some `left-pad` maintainer decided to release a new patch version of his npm package.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169972866",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:45:34+00:00",
        "comment_author": "yotamofek",
        "comment_body": "If we had that, I think that a comment about what it means to run `--extra-checks=eslint` would suffice, in terms of getting the user's permission to run `npx install --frozen eslint` (not sure if `--frozen` is the correct flag but consider it pseudo-shell)",
        "pr_file_module": null
      },
      {
        "comment_id": "2169980765",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142924,
        "pr_file": "src/tools/tidy/src/ext_tool_checks/rustdoc_js.rs",
        "discussion_id": "2169868382",
        "commented_code": "@@ -0,0 +1,142 @@\n+//! Tidy check to ensure that rustdoc templates didn't forget a `{# #}` to strip extra whitespace\n+//! characters.\n+\n+use std::ffi::OsStr;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use ignore::DirEntry;\n+\n+use crate::walk::walk_no_read;\n+\n+fn rustdoc_js_files(librustdoc_path: &Path) -> Vec<PathBuf> {\n+    let mut files = Vec::new();\n+    walk_no_read(\n+        &[&librustdoc_path.join(\"html/static/js\")],\n+        |path, is_dir| is_dir || !path.extension().is_some_and(|ext| ext == OsStr::new(\"js\")),\n+        &mut |path: &DirEntry| {\n+            files.push(path.path().into());\n+        },\n+    );\n+    return files;\n+}\n+\n+fn run_eslint(args: &[PathBuf], config_folder: PathBuf) -> Result<(), super::Error> {\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"eslint\")\n+        .arg(\"-c\")\n+        .arg(config_folder.join(\".eslintrc.js\"))\n+        .args(args)\n+        .spawn()?;\n+    match child.wait() {\n+        Ok(exit_status) => {\n+            if exit_status.success() {\n+                return Ok(());\n+            }\n+            Err(super::Error::FailedCheck(\"eslint command failed\"))\n+        }\n+        Err(error) => Err(super::Error::Generic(format!(\"eslint command failed: {error:?}\"))),\n+    }\n+}\n+\n+fn get_eslint_version_inner(global: bool) -> Option<String> {\n+    let mut command = Command::new(\"npm\");\n+    command.arg(\"list\").arg(\"--parseable\").arg(\"--long\").arg(\"--depth=0\");\n+    if global {\n+        command.arg(\"--global\");\n+    }\n+    let output = command.output().ok()?;\n+    let lines = String::from_utf8_lossy(&output.stdout);\n+    lines.lines().find_map(|l| l.split(':').nth(1)?.strip_prefix(\"eslint@\")).map(|v| v.to_owned())\n+}\n+\n+fn get_eslint_version() -> Option<String> {\n+    get_eslint_version_inner(false).or_else(|| get_eslint_version_inner(true))\n+}\n+\n+pub(super) fn lint(\n+    librustdoc_path: &Path,\n+    tools_path: &Path,\n+    src_path: &Path,\n+) -> Result<(), super::Error> {\n+    let eslint_version_path =\n+        src_path.join(\"ci/docker/host-x86_64/mingw-check-tidy/eslint.version\");\n+    let eslint_version = match std::fs::read_to_string(&eslint_version_path) {\n+        Ok(version) => version.trim().to_string(),\n+        Err(error) => {\n+            eprintln!(\"failed to read `{}`: {error:?}\", eslint_version_path.display());\n+            return Err(error.into());\n+        }\n+    };\n+    // Having the correct `eslint` version installed via `npm` isn't strictly necessary, since we're invoking it via `npx`,\n+    // but this check allows the vast majority that is not working on the rustdoc frontend to avoid the penalty of running\n+    // `eslint` in tidy. See also: https://github.com/rust-lang/rust/pull/142851\n+    match get_eslint_version() {\n+        Some(version) => {\n+            if version != eslint_version {\n+                // unfortunatly we can't use `Error::Version` here becuse `str::trim` isn't const and\n+                // Version::required must be a static str\n+                return Err(super::Error::Generic(format!(\n+                    \"\u26a0\ufe0f Installed version of eslint (`{version}`) is different than the \\\n+                     one used in the CI (`{eslint_version}`)\\n\\\n+                    You can install this version using `npm update eslint` or by using \\\n+                    `npm install eslint@{eslint_version}`\\n\n+\"\n+                )));\n+            }\n+        }\n+        None => {\n+            //eprintln!(\"`eslint` doesn't seem to be installed. Skipping tidy check for JS files.\");\n+            //eprintln!(\"You can install it using `npm install eslint@{eslint_version}`\");\n+            return Err(super::Error::MissingReq(\n+                \"eslint\",\n+                \"js lint checks\",\n+                Some(format!(\"You can install it using `npm install eslint@{eslint_version}`\")),\n+            ));\n+        }\n+    }\n+    let files_to_check = rustdoc_js_files(librustdoc_path);\n+    println!(\"Running eslint on rustdoc JS files\");\n+    run_eslint(&files_to_check, librustdoc_path.join(\"html/static\"))?;\n+\n+    run_eslint(&[tools_path.join(\"rustdoc-js/tester.js\")], tools_path.join(\"rustdoc-js\"))?;\n+    run_eslint(&[tools_path.join(\"rustdoc-gui/tester.js\")], tools_path.join(\"rustdoc-gui\"))?;\n+    Ok(())\n+}\n+\n+pub(super) fn typecheck(librustdoc_path: &Path) -> Result<(), super::Error> {\n+    // use npx to ensure correct version\n+    let mut child = Command::new(\"npx\")\n+        .arg(\"tsc\")\n+        .arg(\"-p\")\n+        .arg(librustdoc_path.join(\"html/static/js/tsconfig.json\"))\n+        .spawn()?;",
        "comment_created_at": "2025-06-26T20:49:05+00:00",
        "comment_author": "yotamofek",
        "comment_body": "> > The state right now, before this PR, is that running tidy will ask you to run npm install eslint@some-version, and then will run that version of eslint the next time.\r\n> \r\n> I would say the state before the PR is that tidy asks me to install eslint, and then I just don't do that, and everything is fine. I don't touch the JS files in this repo anyway, so I will happily ignore tidy's warning.\r\n> \r\n> If even with this PR eslint is only run if it is already installed, then why use `npx` at all? Without a lockfile I feel like every single `npx` invocation needs a comment explaining why this is _not_ remote code execution without integrity checks but just running something the user has already installed -- which defeats the entire purpose of `npx` as I understand it (but I may well misunderstand it, I am not familiar with the JS ecosystem).\r\n\r\nOh yeah, absolutely. Having the user run `npm install` and then running `npx` doesn't make a lot of sense. I was suggesting just doing the latter, but I agree that it might be better to just do the former (and then run it with `npm run` instead of `npx`).\r\n\r\n(sorry for the multiple comments, I didn't see that you had already replied when I posted my previous ones)",
        "pr_file_module": null
      }
    ]
  }
]