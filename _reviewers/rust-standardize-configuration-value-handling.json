[
  {
    "discussion_id": "2223437642",
    "pr_number": 144317,
    "pr_file": "src/tools/tidy/src/main.rs",
    "created_at": "2025-07-22T18:14:35+00:00",
    "commented_code": "let concurrency: NonZeroUsize =\n         FromStr::from_str(&env::args().nth(4).expect(\"need concurrency\"))\n             .expect(\"concurrency must be a number\");\n+    let npm: PathBuf = env::args_os().nth(5).expect(\"need name/path of npm command\").into();",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2223437642",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144317,
        "pr_file": "src/tools/tidy/src/main.rs",
        "discussion_id": "2223437642",
        "commented_code": "@@ -29,6 +29,7 @@ fn main() {\n     let concurrency: NonZeroUsize =\n         FromStr::from_str(&env::args().nth(4).expect(\"need concurrency\"))\n             .expect(\"concurrency must be a number\");\n+    let npm: PathBuf = env::args_os().nth(5).expect(\"need name/path of npm command\").into();",
        "comment_created_at": "2025-07-22T18:14:35+00:00",
        "comment_author": "Kobzol",
        "comment_body": "We might want to think about using clap here soon... :laughing:",
        "pr_file_module": null
      },
      {
        "comment_id": "2223454175",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144317,
        "pr_file": "src/tools/tidy/src/main.rs",
        "discussion_id": "2223437642",
        "commented_code": "@@ -29,6 +29,7 @@ fn main() {\n     let concurrency: NonZeroUsize =\n         FromStr::from_str(&env::args().nth(4).expect(\"need concurrency\"))\n             .expect(\"concurrency must be a number\");\n+    let npm: PathBuf = env::args_os().nth(5).expect(\"need name/path of npm command\").into();",
        "comment_created_at": "2025-07-22T18:22:13+00:00",
        "comment_author": "lolbinarycat",
        "comment_body": "If we're going to refactor how bootstrap passes args to internal tools, I would prefer we use something more type-safe and typo-safe than manually serializing and deserializing args at every process boundary, especially considering these tools aren't really meant to be called directly.\r\n\r\nmy immediate thought would be putting some types into `build_helper` which get serialized into json blobs that get passed to tools and deserialized. I actually tried doing this in a limited form with compiletest all the way back in #135653, trying to reduce the amount of code that has to be kept in sync on both sides.",
        "pr_file_module": null
      },
      {
        "comment_id": "2223480116",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144317,
        "pr_file": "src/tools/tidy/src/main.rs",
        "discussion_id": "2223437642",
        "commented_code": "@@ -29,6 +29,7 @@ fn main() {\n     let concurrency: NonZeroUsize =\n         FromStr::from_str(&env::args().nth(4).expect(\"need concurrency\"))\n             .expect(\"concurrency must be a number\");\n+    let npm: PathBuf = env::args_os().nth(5).expect(\"need name/path of npm command\").into();",
        "comment_created_at": "2025-07-22T18:33:10+00:00",
        "comment_author": "Kobzol",
        "comment_body": "I don't know if some people don't use tidy or compiletest outside of bootstrap :shrug: But if not, then yeah, we might make the interface be more machine processing friendly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217327956",
    "pr_number": 144091,
    "pr_file": "compiler/rustc_index/src/lib.rs",
    "created_at": "2025-07-19T14:05:33+00:00",
    "commented_code": "// tidy-alphabetical-start\n+#![cfg_attr(all(feature = \"nightly\", bootstrap), feature(new_zeroed_alloc))]",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2217327956",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144091,
        "pr_file": "compiler/rustc_index/src/lib.rs",
        "discussion_id": "2217327956",
        "commented_code": "@@ -1,9 +1,9 @@\n // tidy-alphabetical-start\n+#![cfg_attr(all(feature = \"nightly\", bootstrap), feature(new_zeroed_alloc))]",
        "comment_created_at": "2025-07-19T14:05:33+00:00",
        "comment_author": "Mark-Simulacrum",
        "comment_body": "This doesn't seem right to me. I'd expect just cfg(bootstrap) here -- presumably, once this is released/used via nightly feature gate this PR would have already landed and so the feature isn't needed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2042150738",
    "pr_number": 139316,
    "pr_file": "compiler/rustc_errors/src/emitter.rs",
    "created_at": "2025-04-14T13:32:41+00:00",
    "commented_code": ".map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        path.to_string_lossy().contains(\".cargo/registry/src/\")\n+            || path.to_string_lossy().contains(\".rustup/toolchains/\")",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2042150738",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2042150738",
        "commented_code": "@@ -3532,3 +3540,13 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        path.to_string_lossy().contains(\".cargo/registry/src/\")\n+            || path.to_string_lossy().contains(\".rustup/toolchains/\")",
        "comment_created_at": "2025-04-14T13:32:41+00:00",
        "comment_author": "fmease",
        "comment_body": "Hard-coding these paths is not an option, it's too fragile and couples us too tightly to Cargo and rustup. Re. fragile: The user may reconfigure these paths via the environment variables `CARGO_HOME` and `RUSTUP_HOME`, respectively, for example (and I don't know if they differ by operation system (e.g., Windows)).\r\n\r\nI'll have a think later about what alternatives there might be (maybe the sysroot path, \u2026). ",
        "pr_file_module": null
      },
      {
        "comment_id": "2042209418",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2042150738",
        "commented_code": "@@ -3532,3 +3540,13 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        path.to_string_lossy().contains(\".cargo/registry/src/\")\n+            || path.to_string_lossy().contains(\".rustup/toolchains/\")",
        "comment_created_at": "2025-04-14T14:01:49+00:00",
        "comment_author": "xizheyin",
        "comment_body": "Yeah, I'm parsing CARGO_HOME and RUSTUP_HOME with environment variables for now, and using Pathbuf to manage paths and avoid platform dependencies. There doesn't seem to be any difference between the different platforms?\r\n\r\nReference:\r\n1. Rustup Book: https://rust-lang.github.io/rustup/environment-variables.html#environment-variables\r\n2. Cargo Book: https://doc.rust-lang.org/cargo/reference/environment-variables.html\r\n\r\nWe can think about whether there are other situations that have been overlooked.",
        "pr_file_module": null
      },
      {
        "comment_id": "2042366553",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2042150738",
        "commented_code": "@@ -3532,3 +3540,13 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        path.to_string_lossy().contains(\".cargo/registry/src/\")\n+            || path.to_string_lossy().contains(\".rustup/toolchains/\")",
        "comment_created_at": "2025-04-14T15:14:38+00:00",
        "comment_author": "xizheyin",
        "comment_body": "I also added support for sysroot.\r\nhttps://github.com/rust-lang/rust/blob/c580c498a1fe144d7c5b2dfc7faab1a229aa288b/src/bootstrap/src/bin/rustc.rs#L58",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070124074",
    "pr_number": 139316,
    "pr_file": "compiler/rustc_errors/src/emitter.rs",
    "created_at": "2025-05-01T10:13:57+00:00",
    "commented_code": ".map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        // use env variable to get path, avoid hardcode\n+        // use platform independent path\n+\n+        let cargo_home = match std::env::var(\"CARGO_HOME\") {\n+            Ok(dir) => std::path::PathBuf::from(dir),\n+            Err(_) => {\n+                if let Ok(home) = std::env::var(\"HOME\") {\n+                    std::path::PathBuf::from(home).join(\".cargo\")\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2070124074",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2070124074",
        "commented_code": "@@ -3532,3 +3540,47 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        // use env variable to get path, avoid hardcode\n+        // use platform independent path\n+\n+        let cargo_home = match std::env::var(\"CARGO_HOME\") {\n+            Ok(dir) => std::path::PathBuf::from(dir),\n+            Err(_) => {\n+                if let Ok(home) = std::env::var(\"HOME\") {\n+                    std::path::PathBuf::from(home).join(\".cargo\")\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };",
        "comment_created_at": "2025-05-01T10:13:57+00:00",
        "comment_author": "jieyouxu",
        "comment_body": "Discussion: this feels really iffy to me, that we're querying so many env vars. E.g. I think on Windows, `HOME` isn't even set. This also magically encodes directory structures that are not guaranteed to remain the same (rustup, cargo, sysroot directory layouts). See for instance #135278 and #135501. Note that this also can't account for remapped paths or devirtualizing of `/rustc/$hash`, I think.",
        "pr_file_module": null
      },
      {
        "comment_id": "2070144440",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2070124074",
        "commented_code": "@@ -3532,3 +3540,47 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        // use env variable to get path, avoid hardcode\n+        // use platform independent path\n+\n+        let cargo_home = match std::env::var(\"CARGO_HOME\") {\n+            Ok(dir) => std::path::PathBuf::from(dir),\n+            Err(_) => {\n+                if let Ok(home) = std::env::var(\"HOME\") {\n+                    std::path::PathBuf::from(home).join(\".cargo\")\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };",
        "comment_created_at": "2025-05-01T10:45:13+00:00",
        "comment_author": "fmease",
        "comment_body": "Yeah, for sure. This isn't the approach we should be taking. When I mentioned `RUSTUP_HOME` and `CARGO_HOME` in a previous review comment, I intended to *dissuade* the author from implementing this kind of approach by demonstrating the fragile nature, the amount of hacks/assumptions and unnecessary coupling to downstream tools.\r\n\r\nI haven't re-reviewed yet because I need to think about a non-hacky approach but I first wanted to investigate things.",
        "pr_file_module": null
      },
      {
        "comment_id": "2070146634",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2070124074",
        "commented_code": "@@ -3532,3 +3540,47 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        // use env variable to get path, avoid hardcode\n+        // use platform independent path\n+\n+        let cargo_home = match std::env::var(\"CARGO_HOME\") {\n+            Ok(dir) => std::path::PathBuf::from(dir),\n+            Err(_) => {\n+                if let Ok(home) = std::env::var(\"HOME\") {\n+                    std::path::PathBuf::from(home).join(\".cargo\")\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };",
        "comment_created_at": "2025-05-01T10:48:46+00:00",
        "comment_author": "jieyouxu",
        "comment_body": "Yeah, that's the feeling I had from reading the previous review comments. I mostly wrote my own comment to prevent myself from forgetting \ud83d\ude06 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2075055993",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 139316,
        "pr_file": "compiler/rustc_errors/src/emitter.rs",
        "discussion_id": "2070124074",
        "commented_code": "@@ -3532,3 +3540,47 @@ pub(crate) fn should_show_source_code(\n         .map(|path| ignored_directories.iter().all(|dir| !path.starts_with(dir)))\n         .unwrap_or(true)\n }\n+\n+fn is_external_library(sm: &SourceMap, span: Span) -> bool {\n+    let filename = sm.span_to_filename(span);\n+    if let Some(path) = filename.into_local_path() {\n+        // use env variable to get path, avoid hardcode\n+        // use platform independent path\n+\n+        let cargo_home = match std::env::var(\"CARGO_HOME\") {\n+            Ok(dir) => std::path::PathBuf::from(dir),\n+            Err(_) => {\n+                if let Ok(home) = std::env::var(\"HOME\") {\n+                    std::path::PathBuf::from(home).join(\".cargo\")\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };",
        "comment_created_at": "2025-05-06T09:11:29+00:00",
        "comment_author": "xizheyin",
        "comment_body": "I probably understand. I'm not familiar with this section and may need to investigate further. Are there any other resources I can refer to?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215965116",
    "pr_number": 144126,
    "pr_file": "src/bootstrap/src/core/builder/tests.rs",
    "created_at": "2025-07-18T12:47:42+00:00",
    "commented_code": "#[test]\n     fn doc_core_no_std_target() {\n         let ctx = TestCtx::new();\n-        insta::assert_snapshot!(\n-            ctx.config(\"doc\")\n-                .path(\"core\")\n-                .override_target_no_std(&host_target())\n-                .render_steps(), @r\"\n-        [build] llvm <host>\n-        [build] rustc 0 <host> -> rustc 1 <host>\n-        [build] rustdoc 0 <host>\n-        [doc] std 1 <host> crates=[core]\n-        \");\n+        if host_target() == \"x86_64-unknown-linux-gnu\" {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2215965116",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144126,
        "pr_file": "src/bootstrap/src/core/builder/tests.rs",
        "discussion_id": "2215965116",
        "commented_code": "@@ -1631,31 +1631,59 @@ mod snapshot {\n     #[test]\n     fn doc_core_no_std_target() {\n         let ctx = TestCtx::new();\n-        insta::assert_snapshot!(\n-            ctx.config(\"doc\")\n-                .path(\"core\")\n-                .override_target_no_std(&host_target())\n-                .render_steps(), @r\"\n-        [build] llvm <host>\n-        [build] rustc 0 <host> -> rustc 1 <host>\n-        [build] rustdoc 0 <host>\n-        [doc] std 1 <host> crates=[core]\n-        \");\n+        if host_target() == \"x86_64-unknown-linux-gnu\" {",
        "comment_created_at": "2025-07-18T12:47:42+00:00",
        "comment_author": "Kobzol",
        "comment_body": "Hmm, I don't like this. Let's figure out a different way to do this. Because the config hardcodes the name of a specific target, we'll have to generalize that somehow. For example, we can create a function that will return a list of targets for which we opt into LLD by default. Then in tests, we'll have a `#[cfg(test)]` version of that function, which will temporarily allow a test to override this set of targets.\r\n\r\nThen we should implement explicit tests that will override the LLD opt in target list and check that bootstrap behaves correctly, i.e. disables the opt in if external LLVM config is provided and if LLD is disabled in the config.",
        "pr_file_module": null
      },
      {
        "comment_id": "2217844296",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144126,
        "pr_file": "src/bootstrap/src/core/builder/tests.rs",
        "discussion_id": "2215965116",
        "commented_code": "@@ -1631,31 +1631,59 @@ mod snapshot {\n     #[test]\n     fn doc_core_no_std_target() {\n         let ctx = TestCtx::new();\n-        insta::assert_snapshot!(\n-            ctx.config(\"doc\")\n-                .path(\"core\")\n-                .override_target_no_std(&host_target())\n-                .render_steps(), @r\"\n-        [build] llvm <host>\n-        [build] rustc 0 <host> -> rustc 1 <host>\n-        [build] rustdoc 0 <host>\n-        [doc] std 1 <host> crates=[core]\n-        \");\n+        if host_target() == \"x86_64-unknown-linux-gnu\" {",
        "comment_created_at": "2025-07-20T14:30:33+00:00",
        "comment_author": "Shourya742",
        "comment_body": "Agreed. For now, I've added default_lld_opt_in_targets with the default target explicitly set, and made it return an empty list in tests so that the existing test continues to work as-is. Let me know what you think.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178713897",
    "pr_number": 134006,
    "pr_file": "src/tools/tidy/src/ext_tool_checks.rs",
    "created_at": "2025-07-01T23:21:35+00:00",
    "commented_code": "if status.success() { Ok(()) } else { Err(Error::FailedCheck(\"shellcheck\")) }\n }\n \n+/// Check that spellchecker is installed then run it at the given path\n+fn spellcheck_runner(args: &[&str]) -> Result<(), Error> {\n+    match Command::new(\"typos\").arg(\"--version\").status() {\n+        Ok(_) => (),\n+        Err(e) if e.kind() == io::ErrorKind::NotFound => {\n+            return Err(Error::MissingReq(\n+                \"typos\",\n+                \"spellcheck file checks\",\n+                // sync version with .github/workflows/ci.yml\n+                Some(\"install tool via `cargo install typos-cli@1.34.0`\".to_owned()),",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2178713897",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 134006,
        "pr_file": "src/tools/tidy/src/ext_tool_checks.rs",
        "discussion_id": "2178713897",
        "commented_code": "@@ -491,6 +514,25 @@ fn shellcheck_runner(args: &[&OsStr]) -> Result<(), Error> {\n     if status.success() { Ok(()) } else { Err(Error::FailedCheck(\"shellcheck\")) }\n }\n \n+/// Check that spellchecker is installed then run it at the given path\n+fn spellcheck_runner(args: &[&str]) -> Result<(), Error> {\n+    match Command::new(\"typos\").arg(\"--version\").status() {\n+        Ok(_) => (),\n+        Err(e) if e.kind() == io::ErrorKind::NotFound => {\n+            return Err(Error::MissingReq(\n+                \"typos\",\n+                \"spellcheck file checks\",\n+                // sync version with .github/workflows/ci.yml\n+                Some(\"install tool via `cargo install typos-cli@1.34.0`\".to_owned()),",
        "comment_created_at": "2025-07-01T23:21:35+00:00",
        "comment_author": "nnethercote",
        "comment_body": "Does it have to be v1.34.0? Would it make more sense to omit the version number? Seems like \"the latest version\" would be better.",
        "pr_file_module": null
      },
      {
        "comment_id": "2178715846",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 134006,
        "pr_file": "src/tools/tidy/src/ext_tool_checks.rs",
        "discussion_id": "2178713897",
        "commented_code": "@@ -491,6 +514,25 @@ fn shellcheck_runner(args: &[&OsStr]) -> Result<(), Error> {\n     if status.success() { Ok(()) } else { Err(Error::FailedCheck(\"shellcheck\")) }\n }\n \n+/// Check that spellchecker is installed then run it at the given path\n+fn spellcheck_runner(args: &[&str]) -> Result<(), Error> {\n+    match Command::new(\"typos\").arg(\"--version\").status() {\n+        Ok(_) => (),\n+        Err(e) if e.kind() == io::ErrorKind::NotFound => {\n+            return Err(Error::MissingReq(\n+                \"typos\",\n+                \"spellcheck file checks\",\n+                // sync version with .github/workflows/ci.yml\n+                Some(\"install tool via `cargo install typos-cli@1.34.0`\".to_owned()),",
        "comment_created_at": "2025-07-01T23:24:34+00:00",
        "comment_author": "nnethercote",
        "comment_body": "And s/ci.yml/spellcheck.yml/, as above.",
        "pr_file_module": null
      },
      {
        "comment_id": "2180788012",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 134006,
        "pr_file": "src/tools/tidy/src/ext_tool_checks.rs",
        "discussion_id": "2178713897",
        "commented_code": "@@ -491,6 +514,25 @@ fn shellcheck_runner(args: &[&OsStr]) -> Result<(), Error> {\n     if status.success() { Ok(()) } else { Err(Error::FailedCheck(\"shellcheck\")) }\n }\n \n+/// Check that spellchecker is installed then run it at the given path\n+fn spellcheck_runner(args: &[&str]) -> Result<(), Error> {\n+    match Command::new(\"typos\").arg(\"--version\").status() {\n+        Ok(_) => (),\n+        Err(e) if e.kind() == io::ErrorKind::NotFound => {\n+            return Err(Error::MissingReq(\n+                \"typos\",\n+                \"spellcheck file checks\",\n+                // sync version with .github/workflows/ci.yml\n+                Some(\"install tool via `cargo install typos-cli@1.34.0`\".to_owned()),",
        "comment_created_at": "2025-07-02T19:04:29+00:00",
        "comment_author": "klensy",
        "comment_body": "I've added commit with check that ensures that correct version is installed. In case if version differs, output from local check and CI will diverge (which is bad). This should probably be not fatal error in case if people have different version for whatever case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215281216",
    "pr_number": 143928,
    "pr_file": "src/tools/opt-dist/src/main.rs",
    "created_at": "2025-07-18T07:46:51+00:00",
    "commented_code": "// Stage 2: Gather LLVM PGO profiles\n     // Here we build a PGO instrumented LLVM, reusing the previously PGO optimized rustc.\n     // Then we use the instrumented LLVM to gather LLVM PGO profiles.\n-    let llvm_pgo_profile = timer.section(\"Stage 2 (LLVM PGO)\", |stage| {\n-        // Remove the previous, uninstrumented build of LLVM.\n-        clear_llvm_files(env)?;\n+    let llvm_pgo_profile = if env.build_llvm() {\n+        timer.section(\"Stage 2 (LLVM PGO)\", |stage| {\n+            // Remove the previous, uninstrumented build of LLVM.\n+            clear_llvm_files(env)?;\n \n-        let llvm_profile_dir_root = env.artifact_dir().join(\"llvm-pgo\");\n+            let llvm_profile_dir_root = env.artifact_dir().join(\"llvm-pgo\");\n \n-        stage.section(\"Build PGO instrumented LLVM\", |section| {\n-            Bootstrap::build(env)\n-                .llvm_pgo_instrument(&llvm_profile_dir_root)\n-                .avoid_rustc_rebuild()\n-                .run(section)\n-        })?;\n+            stage.section(\"Build PGO instrumented LLVM\", |section| {\n+                Bootstrap::build(env)\n+                    .llvm_pgo_instrument(&llvm_profile_dir_root)\n+                    .avoid_rustc_rebuild()\n+                    .run(section)\n+            })?;\n \n-        let profile = stage\n-            .section(\"Gather profiles\", |_| gather_llvm_profiles(env, &llvm_profile_dir_root))?;\n+            let profile = stage.section(\"Gather profiles\", |_| {\n+                gather_llvm_profiles(env, &llvm_profile_dir_root)\n+            })?;\n \n-        print_free_disk_space()?;\n+            print_free_disk_space()?;\n \n-        // Proactively delete the instrumented artifacts, to avoid using them by accident in\n-        // follow-up stages.\n-        clear_llvm_files(env)?;\n+            // Proactively delete the instrumented artifacts, to avoid using them by accident in\n+            // follow-up stages.\n+            clear_llvm_files(env)?;\n \n-        Ok(profile)\n-    })?;\n+            Ok(Some(profile))\n+        })?\n+    } else {\n+        None\n+    };\n \n-    let bolt_profiles = if env.use_bolt() {\n+    let bolt_profiles = if env.build_llvm() && env.use_bolt() {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2215281216",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143928,
        "pr_file": "src/tools/opt-dist/src/main.rs",
        "discussion_id": "2215281216",
        "commented_code": "@@ -255,32 +263,37 @@ fn execute_pipeline(\n     // Stage 2: Gather LLVM PGO profiles\n     // Here we build a PGO instrumented LLVM, reusing the previously PGO optimized rustc.\n     // Then we use the instrumented LLVM to gather LLVM PGO profiles.\n-    let llvm_pgo_profile = timer.section(\"Stage 2 (LLVM PGO)\", |stage| {\n-        // Remove the previous, uninstrumented build of LLVM.\n-        clear_llvm_files(env)?;\n+    let llvm_pgo_profile = if env.build_llvm() {\n+        timer.section(\"Stage 2 (LLVM PGO)\", |stage| {\n+            // Remove the previous, uninstrumented build of LLVM.\n+            clear_llvm_files(env)?;\n \n-        let llvm_profile_dir_root = env.artifact_dir().join(\"llvm-pgo\");\n+            let llvm_profile_dir_root = env.artifact_dir().join(\"llvm-pgo\");\n \n-        stage.section(\"Build PGO instrumented LLVM\", |section| {\n-            Bootstrap::build(env)\n-                .llvm_pgo_instrument(&llvm_profile_dir_root)\n-                .avoid_rustc_rebuild()\n-                .run(section)\n-        })?;\n+            stage.section(\"Build PGO instrumented LLVM\", |section| {\n+                Bootstrap::build(env)\n+                    .llvm_pgo_instrument(&llvm_profile_dir_root)\n+                    .avoid_rustc_rebuild()\n+                    .run(section)\n+            })?;\n \n-        let profile = stage\n-            .section(\"Gather profiles\", |_| gather_llvm_profiles(env, &llvm_profile_dir_root))?;\n+            let profile = stage.section(\"Gather profiles\", |_| {\n+                gather_llvm_profiles(env, &llvm_profile_dir_root)\n+            })?;\n \n-        print_free_disk_space()?;\n+            print_free_disk_space()?;\n \n-        // Proactively delete the instrumented artifacts, to avoid using them by accident in\n-        // follow-up stages.\n-        clear_llvm_files(env)?;\n+            // Proactively delete the instrumented artifacts, to avoid using them by accident in\n+            // follow-up stages.\n+            clear_llvm_files(env)?;\n \n-        Ok(profile)\n-    })?;\n+            Ok(Some(profile))\n+        })?\n+    } else {\n+        None\n+    };\n \n-    let bolt_profiles = if env.use_bolt() {\n+    let bolt_profiles = if env.build_llvm() && env.use_bolt() {",
        "comment_created_at": "2025-07-18T07:46:51+00:00",
        "comment_author": "Kobzol",
        "comment_body": "This disables BOLT for rustc if you don't build LLVM. I don't suppose many people will need that exact scenario, but we should still support it, otherwise `build_llvm` is a misleading name.",
        "pr_file_module": null
      },
      {
        "comment_id": "2215319407",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143928,
        "pr_file": "src/tools/opt-dist/src/main.rs",
        "discussion_id": "2215281216",
        "commented_code": "@@ -255,32 +263,37 @@ fn execute_pipeline(\n     // Stage 2: Gather LLVM PGO profiles\n     // Here we build a PGO instrumented LLVM, reusing the previously PGO optimized rustc.\n     // Then we use the instrumented LLVM to gather LLVM PGO profiles.\n-    let llvm_pgo_profile = timer.section(\"Stage 2 (LLVM PGO)\", |stage| {\n-        // Remove the previous, uninstrumented build of LLVM.\n-        clear_llvm_files(env)?;\n+    let llvm_pgo_profile = if env.build_llvm() {\n+        timer.section(\"Stage 2 (LLVM PGO)\", |stage| {\n+            // Remove the previous, uninstrumented build of LLVM.\n+            clear_llvm_files(env)?;\n \n-        let llvm_profile_dir_root = env.artifact_dir().join(\"llvm-pgo\");\n+            let llvm_profile_dir_root = env.artifact_dir().join(\"llvm-pgo\");\n \n-        stage.section(\"Build PGO instrumented LLVM\", |section| {\n-            Bootstrap::build(env)\n-                .llvm_pgo_instrument(&llvm_profile_dir_root)\n-                .avoid_rustc_rebuild()\n-                .run(section)\n-        })?;\n+            stage.section(\"Build PGO instrumented LLVM\", |section| {\n+                Bootstrap::build(env)\n+                    .llvm_pgo_instrument(&llvm_profile_dir_root)\n+                    .avoid_rustc_rebuild()\n+                    .run(section)\n+            })?;\n \n-        let profile = stage\n-            .section(\"Gather profiles\", |_| gather_llvm_profiles(env, &llvm_profile_dir_root))?;\n+            let profile = stage.section(\"Gather profiles\", |_| {\n+                gather_llvm_profiles(env, &llvm_profile_dir_root)\n+            })?;\n \n-        print_free_disk_space()?;\n+            print_free_disk_space()?;\n \n-        // Proactively delete the instrumented artifacts, to avoid using them by accident in\n-        // follow-up stages.\n-        clear_llvm_files(env)?;\n+            // Proactively delete the instrumented artifacts, to avoid using them by accident in\n+            // follow-up stages.\n+            clear_llvm_files(env)?;\n \n-        Ok(profile)\n-    })?;\n+            Ok(Some(profile))\n+        })?\n+    } else {\n+        None\n+    };\n \n-    let bolt_profiles = if env.use_bolt() {\n+    let bolt_profiles = if env.build_llvm() && env.use_bolt() {",
        "comment_created_at": "2025-07-18T08:02:04+00:00",
        "comment_author": "ognevny",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  }
]