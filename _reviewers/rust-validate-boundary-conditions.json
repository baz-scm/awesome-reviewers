[
  {
    "discussion_id": "2225772931",
    "pr_number": 144363,
    "pr_file": "library/core/src/any.rs",
    "created_at": "2025-07-23T14:22:32+00:00",
    "commented_code": "pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2225772931",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T14:22:32+00:00",
        "comment_author": "oli-obk",
        "comment_body": "does the `Any` bound actually prevent anything?\r\n\r\nWe'll need some ui tests that actually error when `downcast_trait` gets mis-used.\r\n\r\nSome general test ideas:\r\n\r\n* passing a `dyn Trait` for the `T` where `U` is also `dyn Trait`\r\n* passing a `dyn UnrelatedTrait` for `T` when `U` is `dyn Trait`\r\n* using a not dyn-safe trait for `U`\r\n* using a `dyn Trait<AssocTy = u32>` when the type only implements `Trait<AssocTy = bool>`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2225894248",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T15:05:26+00:00",
        "comment_author": "compiler-errors",
        "comment_body": "Also: Test out:\r\n* downcasting from two disjoint supertrait impls (`trait Foo<T, U>: Super<T> + Super<U>`). \r\n* Downcasting when the type doesn't implement an `Auto` trait.\r\n\r\nThis is also I think still unsound because we don't (and cannot) enforce that the lifetime in the input and output are equal. This should allow you to unsoundly cast `dyn Foo + 'a` to `dyn Foo + 'static`, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2225915250",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T15:13:14+00:00",
        "comment_author": "theemathas",
        "comment_body": "The 'static bound maybe prevents potential unsoundness.",
        "pr_file_module": null
      },
      {
        "comment_id": "2225920400",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T15:15:04+00:00",
        "comment_author": "compiler-errors",
        "comment_body": "Oh, then that really limits the usefulness of this intrinsic as an alternative to specialization as noted in the tracking issue \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2226063452",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T16:07:40+00:00",
        "comment_author": "ivarflakstad",
        "comment_body": "As @oli-obk noted in another comment the intrinsic doesn't necessarily need `'static`, but `downcast_trait*` does.",
        "pr_file_module": null
      },
      {
        "comment_id": "2226068631",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T16:10:10+00:00",
        "comment_author": "RalfJung",
        "comment_body": "`Any` seems entirely unnecessary though. And putting this in the `any` module is really confusing since unlike everything else in `any`, it only works on statically-known types, not on runtime-dynamic types.\r\n\r\nUnfortunately I don't know a better place off the top of my head either, but the docs and the tracking issue should point this out very clearly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2226098994",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T16:24:59+00:00",
        "comment_author": "oli-obk",
        "comment_body": "`type_name` is in `any` and does not have an `Any`",
        "pr_file_module": null
      },
      {
        "comment_id": "2226104878",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T16:28:00+00:00",
        "comment_author": "RalfJung",
        "comment_body": "Hm, yeah, that is kind of similar... but the existing `downcast` is not, not at all.",
        "pr_file_module": null
      },
      {
        "comment_id": "2226423833",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144363,
        "pr_file": "library/core/src/any.rs",
        "discussion_id": "2225772931",
        "commented_code": "@@ -896,3 +896,41 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait<\n+    T: Any + 'static,\n+    U: ptr::Pointee<Metadata = ptr::DynMetadata<U>> + ?Sized + 'static,\n+>(\n+    t: &T,\n+) -> Option<&U> {\n+    let vtable: Option<ptr::DynMetadata<U>> = const { intrinsics::vtable_for::<T, U>() };\n+    match vtable {\n+        Some(dyn_metadata) => {\n+            let pointer = ptr::from_raw_parts(t, dyn_metadata);\n+            Some(unsafe { &*pointer })\n+        }\n+        None => None,\n+    }\n+}\n+\n+#[allow(missing_docs)]\n+#[must_use]\n+#[unstable(feature = \"downcast_trait\", issue = \"144361\")]\n+pub const fn downcast_trait_mut<\n+    T: Any + 'static,",
        "comment_created_at": "2025-07-23T19:09:50+00:00",
        "comment_author": "ivarflakstad",
        "comment_body": "Doesn't really warrant a new module either, right? Even with `type_name`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2204325078",
    "pr_number": 116707,
    "pr_file": "compiler/rustc_middle/src/mir/consts.rs",
    "created_at": "2025-07-14T09:17:23+00:00",
    "commented_code": "// Non-empty slice, must have memory. We know this is a relative pointer.\n                 let (inner_prov, offset) =\n                     ptr.into_pointer_or_addr().ok()?.prov_and_relative_offset();\n-                let data = tcx.global_alloc(inner_prov.alloc_id()).unwrap_memory();\n-                (data, offset.bytes(), offset.bytes() + len)\n+                (inner_prov.alloc_id(), offset.bytes(), offset.bytes() + len)",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2204325078",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 116707,
        "pr_file": "compiler/rustc_middle/src/mir/consts.rs",
        "discussion_id": "2204325078",
        "commented_code": "@@ -170,26 +171,29 @@ impl<'tcx> ConstValue<'tcx> {\n                 // Non-empty slice, must have memory. We know this is a relative pointer.\n                 let (inner_prov, offset) =\n                     ptr.into_pointer_or_addr().ok()?.prov_and_relative_offset();\n-                let data = tcx.global_alloc(inner_prov.alloc_id()).unwrap_memory();\n-                (data, offset.bytes(), offset.bytes() + len)\n+                (inner_prov.alloc_id(), offset.bytes(), offset.bytes() + len)",
        "comment_created_at": "2025-07-14T09:17:23+00:00",
        "comment_author": "RalfJung",
        "comment_body": "```suggestion\r\n                (inner_prov.alloc_id(), offset.bytes(), len)\r\n```\r\nI think? You rename the variable to `len` but didn't adjust the logic here, it seems.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218543841",
    "pr_number": 144232,
    "pr_file": "compiler/rustc_codegen_ssa/src/mir/block.rs",
    "created_at": "2025-07-21T08:44:08+00:00",
    "commented_code": "}\n         };\n \n+        if tail {\n+            bx.tail_call(fn_ty, fn_attrs, fn_abi, fn_ptr, llargs, self.funclet(fx), instance);\n+            for &(tmp, size) in lifetime_ends_after_call {\n+                bx.lifetime_end(tmp, size);\n+            }",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2218543841",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144232,
        "pr_file": "compiler/rustc_codegen_ssa/src/mir/block.rs",
        "discussion_id": "2218543841",
        "commented_code": "@@ -221,6 +222,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         };\n \n+        if tail {\n+            bx.tail_call(fn_ty, fn_attrs, fn_abi, fn_ptr, llargs, self.funclet(fx), instance);\n+            for &(tmp, size) in lifetime_ends_after_call {\n+                bx.lifetime_end(tmp, size);\n+            }",
        "comment_created_at": "2025-07-21T08:44:08+00:00",
        "comment_author": "tmiasko",
        "comment_body": "`lifetime_end` after a musttail call will create ill-formed LLVM IR: \"the call must immediately precede a ret instruction, or a pointer bitcast followed by a ret instruction\".\r\n\r\nIt also hints at more fundamental challenge. Arguments using `PassMode::Indirect` are passed as pointers to stack allocations which will be deallocated by `musttail` call.\r\n\r\nPerhaps it would make more sense to `bug!` in the situation, until `PassMode::Indirect` arguments are actually supported.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2219707935",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144232,
        "pr_file": "compiler/rustc_codegen_ssa/src/mir/block.rs",
        "discussion_id": "2218543841",
        "commented_code": "@@ -221,6 +222,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         };\n \n+        if tail {\n+            bx.tail_call(fn_ty, fn_attrs, fn_abi, fn_ptr, llargs, self.funclet(fx), instance);\n+            for &(tmp, size) in lifetime_ends_after_call {\n+                bx.lifetime_end(tmp, size);\n+            }",
        "comment_created_at": "2025-07-21T16:38:20+00:00",
        "comment_author": "xacrimon",
        "comment_body": "Yep, after consulting some LLVM-knowledge friends this checks out. I've fixed this now.",
        "pr_file_module": null
      },
      {
        "comment_id": "2219914129",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144232,
        "pr_file": "compiler/rustc_codegen_ssa/src/mir/block.rs",
        "discussion_id": "2218543841",
        "commented_code": "@@ -221,6 +222,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         };\n \n+        if tail {\n+            bx.tail_call(fn_ty, fn_attrs, fn_abi, fn_ptr, llargs, self.funclet(fx), instance);\n+            for &(tmp, size) in lifetime_ends_after_call {\n+                bx.lifetime_end(tmp, size);\n+            }",
        "comment_created_at": "2025-07-21T18:09:37+00:00",
        "comment_author": "xacrimon",
        "comment_body": "Wouldn't the indirect argument only be deallocated whenever the last tail call returns though, thereby preventing this problem?",
        "pr_file_module": null
      },
      {
        "comment_id": "2219933618",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144232,
        "pr_file": "compiler/rustc_codegen_ssa/src/mir/block.rs",
        "discussion_id": "2218543841",
        "commented_code": "@@ -221,6 +222,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         };\n \n+        if tail {\n+            bx.tail_call(fn_ty, fn_attrs, fn_abi, fn_ptr, llargs, self.funclet(fx), instance);\n+            for &(tmp, size) in lifetime_ends_after_call {\n+                bx.lifetime_end(tmp, size);\n+            }",
        "comment_created_at": "2025-07-21T18:19:44+00:00",
        "comment_author": "bjorn3",
        "comment_body": "If the indirect argument is a local variable rather than the argument of the caller it would be deallocated while preparing for the tail call together with the rest of the stack of the caller.",
        "pr_file_module": null
      },
      {
        "comment_id": "2219947583",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144232,
        "pr_file": "compiler/rustc_codegen_ssa/src/mir/block.rs",
        "discussion_id": "2218543841",
        "commented_code": "@@ -221,6 +222,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         };\n \n+        if tail {\n+            bx.tail_call(fn_ty, fn_attrs, fn_abi, fn_ptr, llargs, self.funclet(fx), instance);\n+            for &(tmp, size) in lifetime_ends_after_call {\n+                bx.lifetime_end(tmp, size);\n+            }",
        "comment_created_at": "2025-07-21T18:26:04+00:00",
        "comment_author": "xacrimon",
        "comment_body": "Right, I've added a `bug!` for this case now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218513783",
    "pr_number": 144221,
    "pr_file": "compiler/rustc_codegen_ssa/src/back/link/raw_dylib.rs",
    "created_at": "2025-07-21T08:27:59+00:00",
    "commented_code": "});\n     }\n \n+    // .dynstr\n+    stub.write_dynstr();\n+\n+    // .gnu_version\n+    stub.write_null_gnu_versym();\n+    for (_name, _dynstr, ver) in syms.iter().copied() {\n+        stub.write_gnu_versym(if let Some(ver) = ver {\n+            elf::VERSYM_HIDDEN | (2 + ver as u16)",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2218513783",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 144221,
        "pr_file": "compiler/rustc_codegen_ssa/src/back/link/raw_dylib.rs",
        "discussion_id": "2218513783",
        "commented_code": "@@ -363,10 +389,43 @@ fn create_elf_raw_dylib_stub(sess: &Session, soname: &str, symbols: &[DllImport]\n         });\n     }\n \n+    // .dynstr\n+    stub.write_dynstr();\n+\n+    // .gnu_version\n+    stub.write_null_gnu_versym();\n+    for (_name, _dynstr, ver) in syms.iter().copied() {\n+        stub.write_gnu_versym(if let Some(ver) = ver {\n+            elf::VERSYM_HIDDEN | (2 + ver as u16)",
        "comment_created_at": "2025-07-21T08:27:59+00:00",
        "comment_author": "bjorn3",
        "comment_body": "Maybe assert that `ver + 2 < VERSYM_HIDDEN`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203520738",
    "pr_number": 143906,
    "pr_file": "src/tools/miri/src/helpers.rs",
    "created_at": "2025-07-13T20:55:00+00:00",
    "commented_code": "}\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub fn clamp_float_value<S: Semantics>(intrinsic_name: &str, val: IeeeFloat<S>) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = IeeeFloat::<S>::frac_pi_2();\n+\n+    // Exclusive ranges are made using next_up/next_down.\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg().next_up().value, pi_over_2.next_down().value),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg().next_up().value, one.next_down().value),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero.next_up().value, two.next_down().value),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        // FIXME: According to Wolfram Alpha, the range of ln(gamma) is [-0.121486, +INF]. What to do?\n+        \"lgammaf_r\" | \"lgamma_r\" => val,",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2203520738",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143906,
        "pr_file": "src/tools/miri/src/helpers.rs",
        "discussion_id": "2203520738",
        "commented_code": "@@ -215,6 +217,61 @@ impl ToSoft for f32 {\n     }\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub fn clamp_float_value<S: Semantics>(intrinsic_name: &str, val: IeeeFloat<S>) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = IeeeFloat::<S>::frac_pi_2();\n+\n+    // Exclusive ranges are made using next_up/next_down.\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg().next_up().value, pi_over_2.next_down().value),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg().next_up().value, one.next_down().value),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero.next_up().value, two.next_down().value),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        // FIXME: According to Wolfram Alpha, the range of ln(gamma) is [-0.121486, +INF]. What to do?\n+        \"lgammaf_r\" | \"lgamma_r\" => val,",
        "comment_created_at": "2025-07-13T20:55:00+00:00",
        "comment_author": "LorrensP-2158466",
        "comment_body": "Do I make a method in `IeeeExt` trait that gives this exact value, or? \r\n\r\nSomething like:\r\n\r\n```rust\r\nfn lgamma_min_output() -> IeeeFloat<S>{ ... }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2204847309",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 143906,
        "pr_file": "src/tools/miri/src/helpers.rs",
        "discussion_id": "2203520738",
        "commented_code": "@@ -215,6 +217,61 @@ impl ToSoft for f32 {\n     }\n }\n \n+/// Given a floating-point operation and a floating-point value, clamps the result to the output\n+/// range of the given operation according to the C standard, if any.\n+pub fn clamp_float_value<S: Semantics>(intrinsic_name: &str, val: IeeeFloat<S>) -> IeeeFloat<S>\n+where\n+    IeeeFloat<S>: IeeeExt,\n+{\n+    let zero = IeeeFloat::<S>::ZERO;\n+    let one = IeeeFloat::<S>::one();\n+    let two = IeeeFloat::<S>::two();\n+    let pi = IeeeFloat::<S>::pi();\n+    let pi_over_2 = IeeeFloat::<S>::frac_pi_2();\n+\n+    // Exclusive ranges are made using next_up/next_down.\n+    match intrinsic_name {\n+        // sin, cos, tanh: [-1, 1]\n+        #[rustfmt::skip]\n+        | \"sinf32\"\n+        | \"sinf64\"\n+        | \"cosf32\"\n+        | \"cosf64\"\n+        | \"tanhf\"\n+        | \"tanh\"\n+         => val.clamp(one.neg(), one),\n+\n+        // exp: [0, +INF)\n+        \"expf32\" | \"exp2f32\" | \"expf64\" | \"exp2f64\" => val.maximum(zero),\n+\n+        // cosh: [1, +INF)\n+        \"coshf\" | \"cosh\" => val.maximum(one),\n+\n+        // acos: [0, \u03c0]\n+        \"acosf\" | \"acos\" => val.clamp(zero, pi),\n+\n+        // asin: [-\u03c0, +\u03c0]\n+        \"asinf\" | \"asin\" => val.clamp(pi.neg(), pi),\n+\n+        // atan: (-\u03c0/2, +\u03c0/2)\n+        \"atanf\" | \"atan\" => val.clamp(pi_over_2.neg().next_up().value, pi_over_2.next_down().value),\n+\n+        // erfc: (-1, 1)\n+        \"erff\" | \"erf\" => val.clamp(one.neg().next_up().value, one.next_down().value),\n+\n+        // erfc: (0, 2)\n+        \"erfcf\" | \"erfc\" => val.clamp(zero.next_up().value, two.next_down().value),\n+\n+        // atan2(y, x): arctan(y/x) in [\u2212\u03c0, +\u03c0]\n+        \"atan2f\" | \"atan2\" => val.clamp(pi.neg(), pi),\n+\n+        // FIXME: According to Wolfram Alpha, the range of ln(gamma) is [-0.121486, +INF]. What to do?\n+        \"lgammaf_r\" | \"lgamma_r\" => val,",
        "comment_created_at": "2025-07-14T12:46:06+00:00",
        "comment_author": "RalfJung",
        "comment_body": "I assume the C standard doesn't give a value range for this function, so we can just skip doing any clamping here I'd say.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1974051046",
    "pr_number": 136006,
    "pr_file": "library/core/src/num/niche_types.rs",
    "created_at": "2025-02-27T17:31:47+00:00",
    "commented_code": "pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "1974051046",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1974051046",
        "commented_code": "@@ -160,6 +172,15 @@ define_valid_range_type! {\n     pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
        "comment_created_at": "2025-02-27T17:31:47+00:00",
        "comment_author": "programmerjake",
        "comment_body": "`-0x7fff_fffe..` is very much the wrong range since it excludes `-0x8000_0000..=-0x7fff_ffff` rather than `-1`\r\n\r\nimo this should be `..=-2 | 0..`",
        "pr_file_module": null
      },
      {
        "comment_id": "1974068407",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1974051046",
        "commented_code": "@@ -160,6 +172,15 @@ define_valid_range_type! {\n     pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
        "comment_created_at": "2025-02-27T17:43:37+00:00",
        "comment_author": "oli-obk",
        "comment_body": "Oh lmao thx.",
        "pr_file_module": null
      },
      {
        "comment_id": "1974069079",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1974051046",
        "commented_code": "@@ -160,6 +172,15 @@ define_valid_range_type! {\n     pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
        "comment_created_at": "2025-02-27T17:44:03+00:00",
        "comment_author": "programmerjake",
        "comment_body": "I would probably also change the macro input to be:\r\n(remove the parenthesis around the `|` patterns if not needed)\r\n```rust\r\ndefine_valid_range_type! {\r\n    #[uint = u32]\r\n    pub struct U32NotAllOnes(u32 in 0..=0xffff_fffe);\r\n    #[uint = u32]\r\n    pub struct I32NotAllOnes(i32 in (..=-2 | 1..));\r\n\r\n    #[uint = u64]\r\n    pub struct U64NotAllOnes(u64 in 0..=0xffff_ffff_ffff_fffe);\r\n    #[uint = u64]\r\n    pub struct I64NotAllOnes(i64 in (..=-2 | 1..));\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1989023843",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1974051046",
        "commented_code": "@@ -160,6 +172,15 @@ define_valid_range_type! {\n     pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
        "comment_created_at": "2025-03-11T11:23:43+00:00",
        "comment_author": "oli-obk",
        "comment_body": "How do you like the latest version? Unfortunately I had to duplicate the validity check, because there is no way to ask a pattern type for its valid range/check the range in a generic way at present (can't write generic pattern types without an incomplete feature gate which causes all kinds of problems, so it can't be non-incomplete \ud83d\ude06 )",
        "pr_file_module": null
      },
      {
        "comment_id": "1989632026",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1974051046",
        "commented_code": "@@ -160,6 +172,15 @@ define_valid_range_type! {\n     pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
        "comment_created_at": "2025-03-11T15:59:02+00:00",
        "comment_author": "programmerjake",
        "comment_body": "from just reading the library changes, it looks good enough to me (except the 1 nit I commented on). though it did occur to me, wouldn't just using this in `new()` work? it *is* a pattern, built-in pattern matching should work...\r\n```rust\r\nimpl WrapperTypeOverU32 {\r\n    pub fn new(input: u32) -> Option<Self> {\r\n        if let $pat = input {\r\n            Some(...)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1989640263",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1974051046",
        "commented_code": "@@ -160,6 +172,15 @@ define_valid_range_type! {\n     pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n }\n \n+#[cfg(not(bootstrap))]\n+define_valid_range_type! {\n+    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n+    pub struct I32NotAllOnes(i32 as u32 in -0x7fff_fffe..);",
        "comment_created_at": "2025-03-11T16:02:48+00:00",
        "comment_author": "oli-obk",
        "comment_body": "\ud83e\udd26 thank you. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989611996",
    "pr_number": 136006,
    "pr_file": "library/core/src/num/niche_types.rs",
    "created_at": "2025-03-11T15:50:15+00:00",
    "commented_code": "}\n }\n \n-define_valid_range_type! {\n-    pub struct NonZeroU8Inner(u8 as u8 in 1..=0xff);\n-    pub struct NonZeroU16Inner(u16 as u16 in 1..=0xff_ff);\n-    pub struct NonZeroU32Inner(u32 as u32 in 1..=0xffff_ffff);\n-    pub struct NonZeroU64Inner(u64 as u64 in 1..=0xffffffff_ffffffff);\n-    pub struct NonZeroU128Inner(u128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);\n-\n-    pub struct NonZeroI8Inner(i8 as u8 in 1..=0xff);\n-    pub struct NonZeroI16Inner(i16 as u16 in 1..=0xff_ff);\n-    pub struct NonZeroI32Inner(i32 as u32 in 1..=0xffff_ffff);\n-    pub struct NonZeroI64Inner(i64 as u64 in 1..=0xffffffff_ffffffff);\n-    pub struct NonZeroI128Inner(i128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);\n-}\n-\n-#[cfg(target_pointer_width = \"16\")]\n-define_valid_range_type! {\n-    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff);\n-    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff);\n-    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff);\n-}\n-#[cfg(target_pointer_width = \"32\")]\n-define_valid_range_type! {\n-    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff);\n-    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff);\n-    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff);\n-}\n-#[cfg(target_pointer_width = \"64\")]\n-define_valid_range_type! {\n-    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff_ffff_ffff);\n-    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff_ffff_ffff);\n-    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff_ffff_ffff);\n-}\n+const MAX_32_MINUS_1: u32 = u32::MAX - 1;\n+const MAX_64_MINUS_1: u64 = u64::MAX - 1;\n+const HALF_USIZE: usize = usize::MAX >> 1;\n \n define_valid_range_type! {\n-    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n-    pub struct I32NotAllOnes(i32 as u32 in 0..=0xffff_fffe);\n-\n-    pub struct U64NotAllOnes(u64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n-    pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n+    pub struct NonZeroU8Inner(u8 is 1.., != 0);\n+    pub struct NonZeroU16Inner(u16 is 1.., != 0);\n+    pub struct NonZeroU32Inner(u32 is 1.., != 0);\n+    pub struct NonZeroU64Inner(u64 is 1.., != 0);\n+    pub struct NonZeroU128Inner(u128 is 1.., != 0);\n+\n+    pub struct NonZeroI8Inner(i8 is ..0 | 1.., != 0);\n+    pub struct NonZeroI16Inner(i16 is ..0 | 1.., != 0);\n+    pub struct NonZeroI32Inner(i32 is ..0 | 1.., != 0);\n+    pub struct NonZeroI64Inner(i64 is ..0 | 1.., != 0);\n+    pub struct NonZeroI128Inner(i128 is ..0 | 1.., != 0);\n+\n+    pub struct UsizeNoHighBit(usize is 0..=HALF_USIZE, <= HALF_USIZE);\n+    pub struct NonZeroUsizeInner(usize is 1.., != 0);\n+    pub struct NonZeroIsizeInner(isize is ..0 | 1.., != 0);\n+\n+    pub struct U32NotAllOnes(u32 is 0..=MAX_32_MINUS_1, <= MAX_32_MINUS_1);",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "1989611996",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 136006,
        "pr_file": "library/core/src/num/niche_types.rs",
        "discussion_id": "1989611996",
        "commented_code": "@@ -119,45 +108,32 @@ impl Default for Nanoseconds {\n     }\n }\n \n-define_valid_range_type! {\n-    pub struct NonZeroU8Inner(u8 as u8 in 1..=0xff);\n-    pub struct NonZeroU16Inner(u16 as u16 in 1..=0xff_ff);\n-    pub struct NonZeroU32Inner(u32 as u32 in 1..=0xffff_ffff);\n-    pub struct NonZeroU64Inner(u64 as u64 in 1..=0xffffffff_ffffffff);\n-    pub struct NonZeroU128Inner(u128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);\n-\n-    pub struct NonZeroI8Inner(i8 as u8 in 1..=0xff);\n-    pub struct NonZeroI16Inner(i16 as u16 in 1..=0xff_ff);\n-    pub struct NonZeroI32Inner(i32 as u32 in 1..=0xffff_ffff);\n-    pub struct NonZeroI64Inner(i64 as u64 in 1..=0xffffffff_ffffffff);\n-    pub struct NonZeroI128Inner(i128 as u128 in 1..=0xffffffffffffffff_ffffffffffffffff);\n-}\n-\n-#[cfg(target_pointer_width = \"16\")]\n-define_valid_range_type! {\n-    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff);\n-    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff);\n-    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff);\n-}\n-#[cfg(target_pointer_width = \"32\")]\n-define_valid_range_type! {\n-    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff);\n-    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff);\n-    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff);\n-}\n-#[cfg(target_pointer_width = \"64\")]\n-define_valid_range_type! {\n-    pub struct UsizeNoHighBit(usize as usize in 0..=0x7fff_ffff_ffff_ffff);\n-    pub struct NonZeroUsizeInner(usize as usize in 1..=0xffff_ffff_ffff_ffff);\n-    pub struct NonZeroIsizeInner(isize as usize in 1..=0xffff_ffff_ffff_ffff);\n-}\n+const MAX_32_MINUS_1: u32 = u32::MAX - 1;\n+const MAX_64_MINUS_1: u64 = u64::MAX - 1;\n+const HALF_USIZE: usize = usize::MAX >> 1;\n \n define_valid_range_type! {\n-    pub struct U32NotAllOnes(u32 as u32 in 0..=0xffff_fffe);\n-    pub struct I32NotAllOnes(i32 as u32 in 0..=0xffff_fffe);\n-\n-    pub struct U64NotAllOnes(u64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n-    pub struct I64NotAllOnes(i64 as u64 in 0..=0xffff_ffff_ffff_fffe);\n+    pub struct NonZeroU8Inner(u8 is 1.., != 0);\n+    pub struct NonZeroU16Inner(u16 is 1.., != 0);\n+    pub struct NonZeroU32Inner(u32 is 1.., != 0);\n+    pub struct NonZeroU64Inner(u64 is 1.., != 0);\n+    pub struct NonZeroU128Inner(u128 is 1.., != 0);\n+\n+    pub struct NonZeroI8Inner(i8 is ..0 | 1.., != 0);\n+    pub struct NonZeroI16Inner(i16 is ..0 | 1.., != 0);\n+    pub struct NonZeroI32Inner(i32 is ..0 | 1.., != 0);\n+    pub struct NonZeroI64Inner(i64 is ..0 | 1.., != 0);\n+    pub struct NonZeroI128Inner(i128 is ..0 | 1.., != 0);\n+\n+    pub struct UsizeNoHighBit(usize is 0..=HALF_USIZE, <= HALF_USIZE);\n+    pub struct NonZeroUsizeInner(usize is 1.., != 0);\n+    pub struct NonZeroIsizeInner(isize is ..0 | 1.., != 0);\n+\n+    pub struct U32NotAllOnes(u32 is 0..=MAX_32_MINUS_1, <= MAX_32_MINUS_1);",
        "comment_created_at": "2025-03-11T15:50:15+00:00",
        "comment_author": "programmerjake",
        "comment_body": "rather than having the `MAX_32_MINUS_1` constant, could you use\r\n`u32 is 0..u32::MAX, < u32::MAX`? similarly for the `u64` equivalent",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2148817421",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
    "created_at": "2025-06-15T20:25:26+00:00",
    "commented_code": "}\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    storage_to_remove: DenseBitSet<Local>,\n+    head_storage_to_check: DenseBitSet<Local>,\n+    maybe_storage_dead: ResultsCursor<'a, 'tcx, MaybeStorageDead<'a>>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        if !context.is_use() {\n+            return;\n+        }\n+\n+        let head = self.copy_classes[local];\n+        if self.head_storage_to_check.contains(head) {\n+            self.maybe_storage_dead.seek_after_primary_effect(location);\n+\n+            if self.maybe_storage_dead.get().contains(head) {",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2148817421",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2148817421",
        "commented_code": "@@ -172,3 +202,36 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    storage_to_remove: DenseBitSet<Local>,\n+    head_storage_to_check: DenseBitSet<Local>,\n+    maybe_storage_dead: ResultsCursor<'a, 'tcx, MaybeStorageDead<'a>>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        if !context.is_use() {\n+            return;\n+        }\n+\n+        let head = self.copy_classes[local];\n+        if self.head_storage_to_check.contains(head) {\n+            self.maybe_storage_dead.seek_after_primary_effect(location);\n+\n+            if self.maybe_storage_dead.get().contains(head) {",
        "comment_created_at": "2025-06-15T20:25:26+00:00",
        "comment_author": "tmiasko",
        "comment_body": "Storage liveness is not quite sufficient to identify locations where the definition can be used. Consider the following, where `_2` becomes uninitialized after executing `StorageDead(_2)` and `StorageLive(_2)`:\r\n\r\n```rust\r\n#![feature(custom_mir, core_intrinsics)]\r\nextern crate core;\r\nuse core::intrinsics::mir::*;\r\n\r\n#[custom_mir(dialect = \"runtime\")]\r\npub fn f<T: Copy>(_1: T) -> T {\r\n    mir! {\r\n        let _2: T;\r\n        let _3: T;\r\n        {\r\n            StorageLive(_2);\r\n            Call(_2 = opaque(Move(_1)), ReturnTo(bb1), UnwindUnreachable())\r\n        }\r\n        bb1 = {\r\n            let _3 = Move(_2);\r\n            StorageDead(_2);\r\n            StorageLive(_2);\r\n            Call(RET = opaque(Move(_3)), ReturnTo(bb2), UnwindUnreachable())\r\n        }\r\n        bb2 = {\r\n            StorageDead(_2);\r\n            Return()\r\n        }\r\n    }\r\n}\r\n\r\n#[inline(never)]\r\nfn opaque<T>(a: T) -> T { a }\r\n```\r\n\r\n```console\r\nrustc +ef7d20666974f0dac45b03e051f2e283f9d9f090 a.rs --crate-type=lib -Zmir-opt-level=0 -Zmir-enable-passes=+CopyProp -Zunpretty=mir\r\n// WARNING: This output format is intended for human consumers only\r\n// and is subject to change without notice. Knock yourself out.\r\n// HINT: See also -Z dump-mir for MIR at specific points during compilation.\r\nfn f(_1: T) -> T {\r\n    let mut _0: T;\r\n    let mut _2: T;\r\n    let mut _3: T;\r\n    let mut _4: T;\r\n\r\n    bb0: {\r\n        StorageLive(_2);\r\n        _2 = opaque::<T>(move _1) -> [return: bb1, unwind unreachable];\r\n    }\r\n\r\n    bb1: {\r\n        StorageDead(_2);\r\n        StorageLive(_2);\r\n        _0 = opaque::<T>(move _2) -> [return: bb2, unwind unreachable];\r\n    }\r\n\r\n    bb2: {\r\n        StorageDead(_2);\r\n        return;\r\n    }\r\n}\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2149160616",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2148817421",
        "commented_code": "@@ -172,3 +202,36 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    storage_to_remove: DenseBitSet<Local>,\n+    head_storage_to_check: DenseBitSet<Local>,\n+    maybe_storage_dead: ResultsCursor<'a, 'tcx, MaybeStorageDead<'a>>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        if !context.is_use() {\n+            return;\n+        }\n+\n+        let head = self.copy_classes[local];\n+        if self.head_storage_to_check.contains(head) {\n+            self.maybe_storage_dead.seek_after_primary_effect(location);\n+\n+            if self.maybe_storage_dead.get().contains(head) {",
        "comment_created_at": "2025-06-16T06:42:38+00:00",
        "comment_author": "ohadravid",
        "comment_body": "Added this as a new test and switched to using the `MaybeUninitializedPlaces` analysis (which also requires _another_ pass - `TautologicalMoveAssignmentRemover`).\r\n\r\nDo you think this is a good approach?\r\n\r\nAnd thanks for taking the time to look into this and for writing the test \ud83d\ude4f",
        "pr_file_module": null
      },
      {
        "comment_id": "2150745253",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2148817421",
        "commented_code": "@@ -172,3 +202,36 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    storage_to_remove: DenseBitSet<Local>,\n+    head_storage_to_check: DenseBitSet<Local>,\n+    maybe_storage_dead: ResultsCursor<'a, 'tcx, MaybeStorageDead<'a>>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        if !context.is_use() {\n+            return;\n+        }\n+\n+        let head = self.copy_classes[local];\n+        if self.head_storage_to_check.contains(head) {\n+            self.maybe_storage_dead.seek_after_primary_effect(location);\n+\n+            if self.maybe_storage_dead.get().contains(head) {",
        "comment_created_at": "2025-06-16T19:46:41+00:00",
        "comment_author": "tmiasko",
        "comment_body": "I would suggest implementing a new dedicated analysis for the purpose.\r\n\r\n`MaybeUninitializedPlaces` does too many things we don't need here. It tracks initialization with a precision of individual fields, while we are only interested in complete locals. It also models the effect of moves on initialization which should be irrelevant here since the pass adjust moves into copies later.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154627788",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_dataflow/src/impls/initialized.rs",
    "created_at": "2025-06-18T13:33:27+00:00",
    "commented_code": "}\n }\n \n+/// A dataflow analysis that tracks locals that are maybe uninitialized.\n+///\n+/// This is a simpler analysis than `MaybeUninitializedPlaces`, because it does not track\n+/// individual fields.\n+pub struct MaybeUninitializedLocals;\n+\n+impl MaybeUninitializedLocals {\n+    pub fn new() -> Self {\n+        Self {}\n+    }\n+}\n+\n+impl<'tcx> Analysis<'tcx> for MaybeUninitializedLocals {\n+    type Domain = DenseBitSet<mir::Local>;\n+\n+    const NAME: &'static str = \"maybe_uninit_locals\";\n+\n+    fn bottom_value(&self, body: &Body<'tcx>) -> Self::Domain {\n+        // bottom = all locals are initialized.\n+        DenseBitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        // All locals start as uninitialized...\n+        state.insert_all();\n+        // ...except for arguments, which are definitely initialized.\n+        for arg in body.args_iter() {\n+            state.remove(arg);\n+        }\n+    }\n+\n+    fn apply_primary_statement_effect(\n+        &mut self,\n+        state: &mut Self::Domain,\n+        statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        match statement.kind {\n+            // An assignment makes a local initialized.\n+            mir::StatementKind::Assign(box (place, _)) => {\n+                if let Some(local) = place.as_local() {\n+                    state.remove(local);\n+                }\n+            }\n+            // Deinit makes the local uninitialized.\n+            mir::StatementKind::Deinit(box place) => {\n+                // A deinit makes a local uninitialized.\n+                if let Some(local) = place.as_local() {\n+                    state.insert(local);\n+                }\n+            }\n+            // StorageDead makes a local uninitialized.\n+            mir::StatementKind::StorageDead(local) => {\n+                state.insert(local);\n+            }",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2154627788",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_dataflow/src/impls/initialized.rs",
        "discussion_id": "2154627788",
        "commented_code": "@@ -558,6 +558,80 @@ impl<'tcx> Analysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     }\n }\n \n+/// A dataflow analysis that tracks locals that are maybe uninitialized.\n+///\n+/// This is a simpler analysis than `MaybeUninitializedPlaces`, because it does not track\n+/// individual fields.\n+pub struct MaybeUninitializedLocals;\n+\n+impl MaybeUninitializedLocals {\n+    pub fn new() -> Self {\n+        Self {}\n+    }\n+}\n+\n+impl<'tcx> Analysis<'tcx> for MaybeUninitializedLocals {\n+    type Domain = DenseBitSet<mir::Local>;\n+\n+    const NAME: &'static str = \"maybe_uninit_locals\";\n+\n+    fn bottom_value(&self, body: &Body<'tcx>) -> Self::Domain {\n+        // bottom = all locals are initialized.\n+        DenseBitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        // All locals start as uninitialized...\n+        state.insert_all();\n+        // ...except for arguments, which are definitely initialized.\n+        for arg in body.args_iter() {\n+            state.remove(arg);\n+        }\n+    }\n+\n+    fn apply_primary_statement_effect(\n+        &mut self,\n+        state: &mut Self::Domain,\n+        statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        match statement.kind {\n+            // An assignment makes a local initialized.\n+            mir::StatementKind::Assign(box (place, _)) => {\n+                if let Some(local) = place.as_local() {\n+                    state.remove(local);\n+                }\n+            }\n+            // Deinit makes the local uninitialized.\n+            mir::StatementKind::Deinit(box place) => {\n+                // A deinit makes a local uninitialized.\n+                if let Some(local) = place.as_local() {\n+                    state.insert(local);\n+                }\n+            }\n+            // StorageDead makes a local uninitialized.\n+            mir::StatementKind::StorageDead(local) => {\n+                state.insert(local);\n+            }",
        "comment_created_at": "2025-06-18T13:33:27+00:00",
        "comment_author": "tmiasko",
        "comment_body": "This should also include `StorageLive`. A variant of [the earlier example](https://github.com/rust-lang/rust/pull/142531#discussion_r2148817421):\r\n\r\n```rust\r\n#![feature(custom_mir, core_intrinsics)]\r\nuse std::intrinsics::mir::*;\r\n\r\n#[custom_mir(dialect = \"runtime\")]\r\npub fn live_twice<T: Copy>(_1: T) -> T {\r\n    mir! {\r\n        let _2: T;\r\n        let _3: T;\r\n        {\r\n            StorageLive(_2);\r\n            Call(_2 = opaque(Move(_1)), ReturnTo(bb1), UnwindUnreachable())\r\n        }\r\n        bb1 = {\r\n            let _3 = Move(_2);\r\n            StorageLive(_2);\r\n            Call(RET = opaque(_3), ReturnTo(bb2), UnwindUnreachable())\r\n        }\r\n        bb2 = {\r\n            StorageDead(_2);\r\n            Return()\r\n        }\r\n    }\r\n}\r\n\r\n#[inline(never)]\r\nfn opaque<T>(a: T) -> T {\r\n    a\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2155035014",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_dataflow/src/impls/initialized.rs",
        "discussion_id": "2154627788",
        "commented_code": "@@ -558,6 +558,80 @@ impl<'tcx> Analysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     }\n }\n \n+/// A dataflow analysis that tracks locals that are maybe uninitialized.\n+///\n+/// This is a simpler analysis than `MaybeUninitializedPlaces`, because it does not track\n+/// individual fields.\n+pub struct MaybeUninitializedLocals;\n+\n+impl MaybeUninitializedLocals {\n+    pub fn new() -> Self {\n+        Self {}\n+    }\n+}\n+\n+impl<'tcx> Analysis<'tcx> for MaybeUninitializedLocals {\n+    type Domain = DenseBitSet<mir::Local>;\n+\n+    const NAME: &'static str = \"maybe_uninit_locals\";\n+\n+    fn bottom_value(&self, body: &Body<'tcx>) -> Self::Domain {\n+        // bottom = all locals are initialized.\n+        DenseBitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        // All locals start as uninitialized...\n+        state.insert_all();\n+        // ...except for arguments, which are definitely initialized.\n+        for arg in body.args_iter() {\n+            state.remove(arg);\n+        }\n+    }\n+\n+    fn apply_primary_statement_effect(\n+        &mut self,\n+        state: &mut Self::Domain,\n+        statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        match statement.kind {\n+            // An assignment makes a local initialized.\n+            mir::StatementKind::Assign(box (place, _)) => {\n+                if let Some(local) = place.as_local() {\n+                    state.remove(local);\n+                }\n+            }\n+            // Deinit makes the local uninitialized.\n+            mir::StatementKind::Deinit(box place) => {\n+                // A deinit makes a local uninitialized.\n+                if let Some(local) = place.as_local() {\n+                    state.insert(local);\n+                }\n+            }\n+            // StorageDead makes a local uninitialized.\n+            mir::StatementKind::StorageDead(local) => {\n+                state.insert(local);\n+            }",
        "comment_created_at": "2025-06-18T16:23:53+00:00",
        "comment_author": "ohadravid",
        "comment_body": "I'll add the StorageLive check anyway, but this won't compile since \r\n\r\n```\r\nbroken MIR in Item(...) at bb1[0]:\r\n StorageLive(_2) which already has storage here\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2155064020",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_dataflow/src/impls/initialized.rs",
        "discussion_id": "2154627788",
        "commented_code": "@@ -558,6 +558,80 @@ impl<'tcx> Analysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     }\n }\n \n+/// A dataflow analysis that tracks locals that are maybe uninitialized.\n+///\n+/// This is a simpler analysis than `MaybeUninitializedPlaces`, because it does not track\n+/// individual fields.\n+pub struct MaybeUninitializedLocals;\n+\n+impl MaybeUninitializedLocals {\n+    pub fn new() -> Self {\n+        Self {}\n+    }\n+}\n+\n+impl<'tcx> Analysis<'tcx> for MaybeUninitializedLocals {\n+    type Domain = DenseBitSet<mir::Local>;\n+\n+    const NAME: &'static str = \"maybe_uninit_locals\";\n+\n+    fn bottom_value(&self, body: &Body<'tcx>) -> Self::Domain {\n+        // bottom = all locals are initialized.\n+        DenseBitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        // All locals start as uninitialized...\n+        state.insert_all();\n+        // ...except for arguments, which are definitely initialized.\n+        for arg in body.args_iter() {\n+            state.remove(arg);\n+        }\n+    }\n+\n+    fn apply_primary_statement_effect(\n+        &mut self,\n+        state: &mut Self::Domain,\n+        statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+        match statement.kind {\n+            // An assignment makes a local initialized.\n+            mir::StatementKind::Assign(box (place, _)) => {\n+                if let Some(local) = place.as_local() {\n+                    state.remove(local);\n+                }\n+            }\n+            // Deinit makes the local uninitialized.\n+            mir::StatementKind::Deinit(box place) => {\n+                // A deinit makes a local uninitialized.\n+                if let Some(local) = place.as_local() {\n+                    state.insert(local);\n+                }\n+            }\n+            // StorageDead makes a local uninitialized.\n+            mir::StatementKind::StorageDead(local) => {\n+                state.insert(local);\n+            }",
        "comment_created_at": "2025-06-18T16:39:01+00:00",
        "comment_author": "tmiasko",
        "comment_body": "This MIR is valid, although we wouldn't like to generate such a code in the first place. mir-opt tests enable an additional lint that detects suspicious MIR code patterns.. You can disable it with `-Zlint-mir=false`. \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154636613",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
    "created_at": "2025-06-18T13:37:19+00:00",
    "commented_code": "let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2154636613",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2154636613",
        "commented_code": "@@ -34,25 +36,49 @@ impl<'tcx> crate::MirPass<'tcx> for CopyProp {\n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);",
        "comment_created_at": "2025-06-18T13:37:19+00:00",
        "comment_author": "tmiasko",
        "comment_body": "Add a comment that this approach requires local not to be borrowed, since otherwise we cannot easily identify when it is used.\r\n\r\nPlease rebase past #142571, when it lands, and double check that we actually enforce this. I suspect this pull request also fixes failure from `x86_64-gnu-tools` cc @cjgillot.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159984424",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2154636613",
        "commented_code": "@@ -34,25 +36,49 @@ impl<'tcx> crate::MirPass<'tcx> for CopyProp {\n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);",
        "comment_created_at": "2025-06-21T09:06:50+00:00",
        "comment_author": "ohadravid",
        "comment_body": "Changed the logic to force-remove any heads with borrowed locals (+ added this case in the new test file)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160056142",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
    "created_at": "2025-06-21T14:48:49+00:00",
    "commented_code": "let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);\n             }\n         }\n \n         let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n+        // Debug builds have no use for the storage statements, so avoid extra work.\n+        let storage_to_remove = if any_replacement && tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::copy_prop\"))\n+                .into_results_cursor(body);\n+\n+            // To keep the storage of a head, we require that none of the locals in it's copy class are borrowed,\n+            // since otherwise we cannot easily identify when it is used.\n+            let mut storage_to_remove = ssa.borrowed_locals().clone();\n+            storage_to_remove.intersect(&head_storage_to_check);",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2160056142",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2160056142",
        "commented_code": "@@ -36,15 +38,46 @@ impl<'tcx> crate::MirPass<'tcx> for CopyProp {\n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);\n             }\n         }\n \n         let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n+        // Debug builds have no use for the storage statements, so avoid extra work.\n+        let storage_to_remove = if any_replacement && tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::copy_prop\"))\n+                .into_results_cursor(body);\n+\n+            // To keep the storage of a head, we require that none of the locals in it's copy class are borrowed,\n+            // since otherwise we cannot easily identify when it is used.\n+            let mut storage_to_remove = ssa.borrowed_locals().clone();\n+            storage_to_remove.intersect(&head_storage_to_check);",
        "comment_created_at": "2025-06-21T14:48:49+00:00",
        "comment_author": "tmiasko",
        "comment_body": "`SsaLocals::borrowed_locals()[local]` describes whether `local` is borrowed, not whether any local in its copy class is borrowed. An example that doesn't work as it supposed to:\r\n\r\n```rust\r\n#![feature(custom_mir, core_intrinsics, freeze)]\r\nextern crate core;\r\nuse core::intrinsics::mir::*;\r\nuse core::marker::Freeze;\r\n\r\n#[custom_mir(dialect = \"runtime\")]\r\npub fn f<T: Copy + Freeze>(_1: (T, T)) -> T {\r\n    mir! {\r\n        let _2: T;\r\n        let _3: T;\r\n        let _4: &T;\r\n        {\r\n            StorageLive(_2);\r\n            _2 = _1.0;\r\n            _3 = _2;\r\n            _4 = &_3;\r\n            StorageDead(_2);\r\n            RET = *_4;\r\n            Return()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```console\r\n$ rustc +stage1 b.rs --crate-type=lib -Zmir-opt-level=0 -Zmir-enable-passes=+CopyProp -Zunpretty=mir -Copt-level=1\r\nfn f(_1: (T, T)) -> T {\r\n    let mut _0: T;\r\n    let mut _2: T;\r\n    let mut _3: T;\r\n    let mut _4: &T;\r\n\r\n    bb0: {\r\n        StorageLive(_2);\r\n        _2 = copy (_1.0: T);\r\n        _4 = &_2;\r\n        StorageDead(_2);\r\n        _0 = copy (*_4);\r\n        return;\r\n    }\r\n}\r\n```\r\n\r\nI think it should be fine to allow the head itself to be borrowed (it is only all other locals from the copy class that cannot be borrowed).",
        "pr_file_module": null
      },
      {
        "comment_id": "2160062977",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2160056142",
        "commented_code": "@@ -36,15 +38,46 @@ impl<'tcx> crate::MirPass<'tcx> for CopyProp {\n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);\n             }\n         }\n \n         let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n+        // Debug builds have no use for the storage statements, so avoid extra work.\n+        let storage_to_remove = if any_replacement && tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::copy_prop\"))\n+                .into_results_cursor(body);\n+\n+            // To keep the storage of a head, we require that none of the locals in it's copy class are borrowed,\n+            // since otherwise we cannot easily identify when it is used.\n+            let mut storage_to_remove = ssa.borrowed_locals().clone();\n+            storage_to_remove.intersect(&head_storage_to_check);",
        "comment_created_at": "2025-06-21T15:18:51+00:00",
        "comment_author": "ohadravid",
        "comment_body": "Oh I see, I read the `compute_copy_classes` comment but assumed it referred to `ssa.borrowed_locals()`, not the one it computes internally.",
        "pr_file_module": null
      },
      {
        "comment_id": "2160070332",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2160056142",
        "commented_code": "@@ -36,15 +38,46 @@ impl<'tcx> crate::MirPass<'tcx> for CopyProp {\n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n-        let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);\n             }\n         }\n \n         let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n+        // Debug builds have no use for the storage statements, so avoid extra work.\n+        let storage_to_remove = if any_replacement && tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::copy_prop\"))\n+                .into_results_cursor(body);\n+\n+            // To keep the storage of a head, we require that none of the locals in it's copy class are borrowed,\n+            // since otherwise we cannot easily identify when it is used.\n+            let mut storage_to_remove = ssa.borrowed_locals().clone();\n+            storage_to_remove.intersect(&head_storage_to_check);",
        "comment_created_at": "2025-06-21T15:51:37+00:00",
        "comment_author": "ohadravid",
        "comment_body": "Add this test and pushed the correct fix.\r\nI do get reordered output for some tests (like `tests/mir-opt/pre-codegen/derived_ord.rs`) and I'm not sure why, but the fixed impl now produces the correct output for this test.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161073652",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
    "created_at": "2025-06-23T08:52:44+00:00",
    "commented_code": "let typing_env = body.typing_env(tcx);\n         let ssa = SsaLocals::new(tcx, body, typing_env);\n-        debug!(borrowed_locals = ?ssa.borrowed_locals());\n+        let borrowed_locals = ssa.borrowed_locals().clone();\n+\n+        debug!(?borrowed_locals);\n         debug!(copy_classes = ?ssa.copy_classes());\n \n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n         let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);\n+\n+                if borrowed_locals.contains(local) {\n+                    // To keep the storage of a head, we require that none of the locals in it's copy class are borrowed,\n+                    // since otherwise we cannot easily identify when it is used.\n+                    storage_to_remove.insert(head);\n+                }\n             }\n         }\n \n         let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n+        // Debug builds have no use for the storage statements, so avoid extra work.\n+        let storage_to_remove = if any_replacement && tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::copy_prop\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                maybe_uninit,\n+                copy_classes: ssa.copy_classes(),\n+                head_storage_to_check,\n+                storage_to_remove,\n+            };\n+\n+            storage_checker.visit_body(body);",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2161073652",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2161073652",
        "commented_code": "@@ -30,21 +32,56 @@ impl<'tcx> crate::MirPass<'tcx> for CopyProp {\n \n         let typing_env = body.typing_env(tcx);\n         let ssa = SsaLocals::new(tcx, body, typing_env);\n-        debug!(borrowed_locals = ?ssa.borrowed_locals());\n+        let borrowed_locals = ssa.borrowed_locals().clone();\n+\n+        debug!(?borrowed_locals);\n         debug!(copy_classes = ?ssa.copy_classes());\n \n         let fully_moved = fully_moved_locals(&ssa, body);\n         debug!(?fully_moved);\n \n+        let mut head_storage_to_check = DenseBitSet::new_empty(fully_moved.domain_size());\n         let mut storage_to_remove = DenseBitSet::new_empty(fully_moved.domain_size());\n+\n         for (local, &head) in ssa.copy_classes().iter_enumerated() {\n             if local != head {\n-                storage_to_remove.insert(head);\n+                // We need to determine if we can keep the head's storage statements (which enables better optimizations).\n+                // For every local's usage location, if the head is maybe-uninitialized, we'll need to remove it's storage statements.\n+                head_storage_to_check.insert(head);\n+\n+                if borrowed_locals.contains(local) {\n+                    // To keep the storage of a head, we require that none of the locals in it's copy class are borrowed,\n+                    // since otherwise we cannot easily identify when it is used.\n+                    storage_to_remove.insert(head);\n+                }\n             }\n         }\n \n         let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n \n+        // Debug builds have no use for the storage statements, so avoid extra work.\n+        let storage_to_remove = if any_replacement && tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::copy_prop\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                maybe_uninit,\n+                copy_classes: ssa.copy_classes(),\n+                head_storage_to_check,\n+                storage_to_remove,\n+            };\n+\n+            storage_checker.visit_body(body);",
        "comment_created_at": "2025-06-23T08:52:44+00:00",
        "comment_author": "tmiasko",
        "comment_body": "Visit only reachable blocks with `traversal::reachable`. By default the dataflow engine prohibits obtaining results from unreachable blocks (there is a debug assertion).\r\n\r\nCan you also add a test that code from unreachable blocks doesn't block the optimization?\r\n\r\n```rust\r\n#![feature(custom_mir, core_intrinsics)]\r\nextern crate core;\r\nuse core::intrinsics::mir::*;\r\n\r\n#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\r\npub fn f(_1: &mut usize) {\r\n    mir! {\r\n        let _2: usize;\r\n        let _3: usize;\r\n        {\r\n            StorageLive(_2);\r\n            _2 = 42;\r\n            _3 = _2;\r\n            (*_1) = _3;\r\n            StorageDead(_2);\r\n            Return()\r\n        }\r\n        bb1 = {\r\n            // Ensure that _2 is considered uninitialized by `MaybeUninitializedLocals`.\r\n            StorageLive(_2);\r\n            // Use of _3 (in an unreachable block) when definition of _2 is unavailable.\r\n            (*_1) = _3;\r\n            StorageDead(_2);\r\n            Return()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163252842",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
    "created_at": "2025-06-24T08:11:03+00:00",
    "commented_code": "}\n     }\n }\n+\n+// Marks heads of copy classes that are maybe uninitialized at the location of a local\n+// as needing storage statement removal.\n+struct StorageChecker<'a, 'tcx> {\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+    head_storage_to_check: DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, loc: Location) {\n+        // We don't need to check storage statements and statements for which the local doesn't need to be initialized.",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2163252842",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2163252842",
        "commented_code": "@@ -152,3 +189,51 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n         }\n     }\n }\n+\n+// Marks heads of copy classes that are maybe uninitialized at the location of a local\n+// as needing storage statement removal.\n+struct StorageChecker<'a, 'tcx> {\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+    head_storage_to_check: DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, loc: Location) {\n+        // We don't need to check storage statements and statements for which the local doesn't need to be initialized.",
        "comment_created_at": "2025-06-24T08:11:03+00:00",
        "comment_author": "tmiasko",
        "comment_body": "For `local == head` we would be preserving the existing behavior and we don't need to check anything. Return early in that situation.\r\n\r\nCould you also add test for this? We should optimize and keep storage statements in:\r\n\r\n```rust\r\n#![feature(custom_mir, core_intrinsics)]\r\nextern crate core;\r\nuse core::intrinsics::mir::*;\r\n\r\n#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\r\npub fn f(_1: &mut usize) {\r\n    mir! {\r\n        let _2: usize;\r\n        let _3: usize;\r\n        {\r\n            StorageLive(_2);\r\n            _2 = 0;\r\n            _3 = _2;\r\n            (*_1) = _3;\r\n            StorageDead(_2);\r\n            (*_1) = _2;\r\n            Return()\r\n        }\r\n    }\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179597772",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
    "created_at": "2025-07-02T09:36:08+00:00",
    "commented_code": "state.visit_basic_block_data(bb, data);\n         }\n \n-        // For each local that is reused (`y` above), we remove its storage statements do avoid any\n-        // difficulty. Those locals are SSA, so should be easy to optimize by LLVM without storage\n-        // statements.\n-        StorageRemover { tcx, reused_locals: state.reused_locals }.visit_body_preserves_cfg(body);\n+        // When emitting storage statements, we want to retain the reused locals' storage statements,\n+        // as this enables better optimizations. For each local use location, we mark it for storage removal\n+        // only if it might be uninitialized at that point.\n+        let storage_to_remove = if tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::gvn\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                reused_locals: &state.reused_locals,\n+                storage_to_remove: DenseBitSet::new_empty(body.local_decls.len()),\n+                maybe_uninit,\n+            };\n+\n+            for (bb, data) in traversal::reachable(body) {\n+                storage_checker.visit_basic_block_data(bb, data);\n+            }\n+\n+            storage_checker.storage_to_remove\n+        } else {\n+            // Remove the storage statements of all the reused locals.\n+            state.reused_locals.clone()\n+        };",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2179597772",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179597772",
        "commented_code": "@@ -140,10 +141,34 @@ impl<'tcx> crate::MirPass<'tcx> for GVN {\n             state.visit_basic_block_data(bb, data);\n         }\n \n-        // For each local that is reused (`y` above), we remove its storage statements do avoid any\n-        // difficulty. Those locals are SSA, so should be easy to optimize by LLVM without storage\n-        // statements.\n-        StorageRemover { tcx, reused_locals: state.reused_locals }.visit_body_preserves_cfg(body);\n+        // When emitting storage statements, we want to retain the reused locals' storage statements,\n+        // as this enables better optimizations. For each local use location, we mark it for storage removal\n+        // only if it might be uninitialized at that point.\n+        let storage_to_remove = if tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::gvn\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                reused_locals: &state.reused_locals,\n+                storage_to_remove: DenseBitSet::new_empty(body.local_decls.len()),\n+                maybe_uninit,\n+            };\n+\n+            for (bb, data) in traversal::reachable(body) {\n+                storage_checker.visit_basic_block_data(bb, data);\n+            }\n+\n+            storage_checker.storage_to_remove\n+        } else {\n+            // Remove the storage statements of all the reused locals.\n+            state.reused_locals.clone()\n+        };",
        "comment_created_at": "2025-07-02T09:36:08+00:00",
        "comment_author": "cjgillot",
        "comment_body": "This logic is very close to the one in `copy_prop`. Could you merge them into a single `compute_storage_to_remove` function in `rustc_mir_transform::ssa`? It would take a set of relevant locals (copy-prop : `copy_classes[local] != local`, GVN : `reused_locals`) and compute `storage_to_remove`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2185079679",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179597772",
        "commented_code": "@@ -140,10 +141,34 @@ impl<'tcx> crate::MirPass<'tcx> for GVN {\n             state.visit_basic_block_data(bb, data);\n         }\n \n-        // For each local that is reused (`y` above), we remove its storage statements do avoid any\n-        // difficulty. Those locals are SSA, so should be easy to optimize by LLVM without storage\n-        // statements.\n-        StorageRemover { tcx, reused_locals: state.reused_locals }.visit_body_preserves_cfg(body);\n+        // When emitting storage statements, we want to retain the reused locals' storage statements,\n+        // as this enables better optimizations. For each local use location, we mark it for storage removal\n+        // only if it might be uninitialized at that point.\n+        let storage_to_remove = if tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::gvn\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                reused_locals: &state.reused_locals,\n+                storage_to_remove: DenseBitSet::new_empty(body.local_decls.len()),\n+                maybe_uninit,\n+            };\n+\n+            for (bb, data) in traversal::reachable(body) {\n+                storage_checker.visit_basic_block_data(bb, data);\n+            }\n+\n+            storage_checker.storage_to_remove\n+        } else {\n+            // Remove the storage statements of all the reused locals.\n+            state.reused_locals.clone()\n+        };",
        "comment_created_at": "2025-07-04T11:10:55+00:00",
        "comment_author": "ohadravid",
        "comment_body": "I can, but I think such a function will need to also accept a `map: Fn(Local) -> Local` (`|local| copy_class[local]` in `copy_prop`) since in `copy_prop` we check the `head` and not the actual `visit_local`'s `local` param. We could change the storage check to run after the replacement, but then we'll need to add a separate `StorageRemover` (similar to GVN).\n\nEdit: Also, after implementing https://github.com/rust-lang/rust/pull/142531#discussion_r2181001248, the storage check logic diverged even more between the two passes.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203472557",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179597772",
        "commented_code": "@@ -140,10 +141,34 @@ impl<'tcx> crate::MirPass<'tcx> for GVN {\n             state.visit_basic_block_data(bb, data);\n         }\n \n-        // For each local that is reused (`y` above), we remove its storage statements do avoid any\n-        // difficulty. Those locals are SSA, so should be easy to optimize by LLVM without storage\n-        // statements.\n-        StorageRemover { tcx, reused_locals: state.reused_locals }.visit_body_preserves_cfg(body);\n+        // When emitting storage statements, we want to retain the reused locals' storage statements,\n+        // as this enables better optimizations. For each local use location, we mark it for storage removal\n+        // only if it might be uninitialized at that point.\n+        let storage_to_remove = if tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::gvn\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                reused_locals: &state.reused_locals,\n+                storage_to_remove: DenseBitSet::new_empty(body.local_decls.len()),\n+                maybe_uninit,\n+            };\n+\n+            for (bb, data) in traversal::reachable(body) {\n+                storage_checker.visit_basic_block_data(bb, data);\n+            }\n+\n+            storage_checker.storage_to_remove\n+        } else {\n+            // Remove the storage statements of all the reused locals.\n+            state.reused_locals.clone()\n+        };",
        "comment_created_at": "2025-07-13T17:25:11+00:00",
        "comment_author": "cjgillot",
        "comment_body": "> Edit: Also, after implementing [#142531 (comment)](https://github.com/rust-lang/rust/pull/142531#discussion_r2181001248), the storage check logic diverged even more between the two passes.\r\n\r\nThe implementations should not diverge. They should use the same code. That comment applies to both.",
        "pr_file_module": null
      },
      {
        "comment_id": "2212276742",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179597772",
        "commented_code": "@@ -140,10 +141,34 @@ impl<'tcx> crate::MirPass<'tcx> for GVN {\n             state.visit_basic_block_data(bb, data);\n         }\n \n-        // For each local that is reused (`y` above), we remove its storage statements do avoid any\n-        // difficulty. Those locals are SSA, so should be easy to optimize by LLVM without storage\n-        // statements.\n-        StorageRemover { tcx, reused_locals: state.reused_locals }.visit_body_preserves_cfg(body);\n+        // When emitting storage statements, we want to retain the reused locals' storage statements,\n+        // as this enables better optimizations. For each local use location, we mark it for storage removal\n+        // only if it might be uninitialized at that point.\n+        let storage_to_remove = if tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::gvn\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                reused_locals: &state.reused_locals,\n+                storage_to_remove: DenseBitSet::new_empty(body.local_decls.len()),\n+                maybe_uninit,\n+            };\n+\n+            for (bb, data) in traversal::reachable(body) {\n+                storage_checker.visit_basic_block_data(bb, data);\n+            }\n+\n+            storage_checker.storage_to_remove\n+        } else {\n+            // Remove the storage statements of all the reused locals.\n+            state.reused_locals.clone()\n+        };",
        "comment_created_at": "2025-07-17T05:12:13+00:00",
        "comment_author": "ohadravid",
        "comment_body": "I might be missing something, but I think that because we run the storage check at different stages (in `copy_prop`, we do this before the replacement) they have to be different: removing the `PlaceContext::MutatingUse` part in GVN results in removing many more storage statements because we end up checking assignment as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "2222879525",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179597772",
        "commented_code": "@@ -140,10 +141,34 @@ impl<'tcx> crate::MirPass<'tcx> for GVN {\n             state.visit_basic_block_data(bb, data);\n         }\n \n-        // For each local that is reused (`y` above), we remove its storage statements do avoid any\n-        // difficulty. Those locals are SSA, so should be easy to optimize by LLVM without storage\n-        // statements.\n-        StorageRemover { tcx, reused_locals: state.reused_locals }.visit_body_preserves_cfg(body);\n+        // When emitting storage statements, we want to retain the reused locals' storage statements,\n+        // as this enables better optimizations. For each local use location, we mark it for storage removal\n+        // only if it might be uninitialized at that point.\n+        let storage_to_remove = if tcx.sess.emit_lifetime_markers() {\n+            let maybe_uninit = MaybeUninitializedLocals::new()\n+                .iterate_to_fixpoint(tcx, body, Some(\"mir_opt::gvn\"))\n+                .into_results_cursor(body);\n+\n+            let mut storage_checker = StorageChecker {\n+                reused_locals: &state.reused_locals,\n+                storage_to_remove: DenseBitSet::new_empty(body.local_decls.len()),\n+                maybe_uninit,\n+            };\n+\n+            for (bb, data) in traversal::reachable(body) {\n+                storage_checker.visit_basic_block_data(bb, data);\n+            }\n+\n+            storage_checker.storage_to_remove\n+        } else {\n+            // Remove the storage statements of all the reused locals.\n+            state.reused_locals.clone()\n+        };",
        "comment_created_at": "2025-07-22T15:14:15+00:00",
        "comment_author": "tmiasko",
        "comment_body": "The current approach from copy propagation crucially depends on being able to distinguish a representative local of a copy class from other members. The distinction disappears after the transformation, so the approach won't work as is in GVN.\r\n\r\nOn the other hand, reusing the current approach from GVN in copy propagation seems plausible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179618090",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
    "created_at": "2025-07-02T09:45:30+00:00",
    "commented_code": "match stmt.kind {\n             // When removing storage statements, we need to remove both (#107511).\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n-                if self.reused_locals.contains(l) =>\n+                if self.storage_to_remove.contains(l) =>\n             {\n                 stmt.make_nop()\n             }\n             _ => self.super_statement(stmt, loc),\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    reused_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        match context {\n+            // These mutating uses do not require the local to be initialized.\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Call)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Store)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Yield)",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2179618090",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179618090",
        "commented_code": "@@ -1844,11 +1870,50 @@ impl<'tcx> MutVisitor<'tcx> for StorageRemover<'tcx> {\n         match stmt.kind {\n             // When removing storage statements, we need to remove both (#107511).\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n-                if self.reused_locals.contains(l) =>\n+                if self.storage_to_remove.contains(l) =>\n             {\n                 stmt.make_nop()\n             }\n             _ => self.super_statement(stmt, loc),\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    reused_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        match context {\n+            // These mutating uses do not require the local to be initialized.\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Call)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Store)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Yield)",
        "comment_created_at": "2025-07-02T09:45:30+00:00",
        "comment_author": "cjgillot",
        "comment_body": "They do not require the local to be initialized, but they do require it to have storage. Mixing the two notions makes me uneasy.",
        "pr_file_module": null
      },
      {
        "comment_id": "2180389814",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179618090",
        "commented_code": "@@ -1844,11 +1870,50 @@ impl<'tcx> MutVisitor<'tcx> for StorageRemover<'tcx> {\n         match stmt.kind {\n             // When removing storage statements, we need to remove both (#107511).\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n-                if self.reused_locals.contains(l) =>\n+                if self.storage_to_remove.contains(l) =>\n             {\n                 stmt.make_nop()\n             }\n             _ => self.super_statement(stmt, loc),\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    reused_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        match context {\n+            // These mutating uses do not require the local to be initialized.\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Call)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Store)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Yield)",
        "comment_created_at": "2025-07-02T15:41:17+00:00",
        "comment_author": "ohadravid",
        "comment_body": "I can probably add a test that triggers this. Is the right solution to use two separate analysis checks (so for these we'll check the `MaybeStorageDead`)?",
        "pr_file_module": null
      },
      {
        "comment_id": "2185308834",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179618090",
        "commented_code": "@@ -1844,11 +1870,50 @@ impl<'tcx> MutVisitor<'tcx> for StorageRemover<'tcx> {\n         match stmt.kind {\n             // When removing storage statements, we need to remove both (#107511).\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n-                if self.reused_locals.contains(l) =>\n+                if self.storage_to_remove.contains(l) =>\n             {\n                 stmt.make_nop()\n             }\n             _ => self.super_statement(stmt, loc),\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    reused_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        match context {\n+            // These mutating uses do not require the local to be initialized.\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Call)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Store)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Yield)",
        "comment_created_at": "2025-07-04T12:57:11+00:00",
        "comment_author": "ohadravid",
        "comment_body": "Actually, thinking about this some more: we know that the `reused_locals` have valid storage before their original assignments.\n\nFor any replacements (eg target of the `Store`) the `local` cannot be a reused local anyway.\n\nWhat do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "2222900729",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/gvn.rs",
        "discussion_id": "2179618090",
        "commented_code": "@@ -1844,11 +1870,50 @@ impl<'tcx> MutVisitor<'tcx> for StorageRemover<'tcx> {\n         match stmt.kind {\n             // When removing storage statements, we need to remove both (#107511).\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n-                if self.reused_locals.contains(l) =>\n+                if self.storage_to_remove.contains(l) =>\n             {\n                 stmt.make_nop()\n             }\n             _ => self.super_statement(stmt, loc),\n         }\n     }\n }\n+\n+struct StorageChecker<'a, 'tcx> {\n+    reused_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, location: Location) {\n+        match context {\n+            // These mutating uses do not require the local to be initialized.\n+            PlaceContext::MutatingUse(MutatingUseContext::AsmOutput)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Call)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Store)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Yield)",
        "comment_created_at": "2025-07-22T15:18:55+00:00",
        "comment_author": "tmiasko",
        "comment_body": "In the case of mutation the GVN merely preserves existing behavior (it doesn't introduce new mutations, nor moves mutations around, etc). Which is why this aspect of implementations seems fine to me. Though I share the concern about the explanation given in the comment above.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181001248",
    "pr_number": 142531,
    "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
    "created_at": "2025-07-02T21:26:05+00:00",
    "commented_code": "}\n     }\n }\n+\n+// Marks heads of copy classes that are maybe uninitialized at the location of a local\n+// as needing storage statement removal.\n+struct StorageChecker<'a, 'tcx> {\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+    borrowed_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, loc: Location) {\n+        // We don't need to check storage statements and statements for which the local doesn't need to be initialized.\n+        match context {\n+            PlaceContext::MutatingUse(\n+                MutatingUseContext::Store\n+                | MutatingUseContext::Call\n+                | MutatingUseContext::Yield\n+                | MutatingUseContext::AsmOutput,\n+            )\n+            | PlaceContext::NonUse(_) => {\n+                return;\n+            }\n+            _ => {}\n+        };",
    "repo_full_name": "rust-lang/rust",
    "discussion_comments": [
      {
        "comment_id": "2181001248",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2181001248",
        "commented_code": "@@ -154,3 +187,56 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n         }\n     }\n }\n+\n+// Marks heads of copy classes that are maybe uninitialized at the location of a local\n+// as needing storage statement removal.\n+struct StorageChecker<'a, 'tcx> {\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+    borrowed_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, loc: Location) {\n+        // We don't need to check storage statements and statements for which the local doesn't need to be initialized.\n+        match context {\n+            PlaceContext::MutatingUse(\n+                MutatingUseContext::Store\n+                | MutatingUseContext::Call\n+                | MutatingUseContext::Yield\n+                | MutatingUseContext::AsmOutput,\n+            )\n+            | PlaceContext::NonUse(_) => {\n+                return;\n+            }\n+            _ => {}\n+        };",
        "comment_created_at": "2025-07-02T21:26:05+00:00",
        "comment_author": "tmiasko",
        "comment_body": "This entire match is unnecessary and can be removed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2181056317",
        "repo_full_name": "rust-lang/rust",
        "pr_number": 142531,
        "pr_file": "compiler/rustc_mir_transform/src/copy_prop.rs",
        "discussion_id": "2181001248",
        "commented_code": "@@ -154,3 +187,56 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n         }\n     }\n }\n+\n+// Marks heads of copy classes that are maybe uninitialized at the location of a local\n+// as needing storage statement removal.\n+struct StorageChecker<'a, 'tcx> {\n+    maybe_uninit: ResultsCursor<'a, 'tcx, MaybeUninitializedLocals>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n+    borrowed_locals: &'a DenseBitSet<Local>,\n+    storage_to_remove: DenseBitSet<Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StorageChecker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, loc: Location) {\n+        // We don't need to check storage statements and statements for which the local doesn't need to be initialized.\n+        match context {\n+            PlaceContext::MutatingUse(\n+                MutatingUseContext::Store\n+                | MutatingUseContext::Call\n+                | MutatingUseContext::Yield\n+                | MutatingUseContext::AsmOutput,\n+            )\n+            | PlaceContext::NonUse(_) => {\n+                return;\n+            }\n+            _ => {}\n+        };",
        "comment_created_at": "2025-07-02T22:06:54+00:00",
        "comment_author": "tmiasko",
        "comment_body": "Actually `PlaceContext::NoUse` part is potentially useful, but there are no tests. Could you add one? Something with storage statements other way around like in:\r\n\r\n```rust\r\n#![feature(custom_mir, core_intrinsics)]\r\nuse std::intrinsics::mir::*;\r\n\r\n#[custom_mir(dialect = \"runtime\")]\r\npub fn f() -> usize {\r\n    mir! {\r\n        let _1: usize;\r\n        let _2: usize;\r\n        let _3: usize;\r\n        {\r\n            StorageLive(_2);\r\n            StorageLive(_1);\r\n            _1 = 0;\r\n            _2 = _1;\r\n            _3 = _2;\r\n            RET = _3 + _3;\r\n            StorageDead(_1);\r\n            StorageDead(_2);\r\n            Return()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]