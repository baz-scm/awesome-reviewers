[
  {
    "discussion_id": "2501622528",
    "pr_number": 1147,
    "pr_file": "src/strands/session/session_manager.py",
    "created_at": "2025-11-07T04:14:41+00:00",
    "commented_code": "registry.add_callback(AfterInvocationEvent, lambda event: self.sync_agent(event.agent))\n \n         registry.add_callback(MultiAgentInitializedEvent, lambda event: self.initialize_multi_agent(event.source))\n-        registry.add_callback(AfterNodeCallEvent, lambda event: self.sync_multi_agent(event.source))\n+        registry.add_callback(BeforeNodeCallEvent, lambda event: self.sync_multi_agent(event.source))",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2501622528",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1147,
        "pr_file": "src/strands/session/session_manager.py",
        "discussion_id": "2501622528",
        "commented_code": "@@ -44,7 +44,7 @@ def register_hooks(self, registry: HookRegistry, **kwargs: Any) -> None:\n         registry.add_callback(AfterInvocationEvent, lambda event: self.sync_agent(event.agent))\n \n         registry.add_callback(MultiAgentInitializedEvent, lambda event: self.initialize_multi_agent(event.source))\n-        registry.add_callback(AfterNodeCallEvent, lambda event: self.sync_multi_agent(event.source))\n+        registry.add_callback(BeforeNodeCallEvent, lambda event: self.sync_multi_agent(event.source))",
        "comment_created_at": "2025-11-07T04:14:41+00:00",
        "comment_author": "pgrayy",
        "comment_body": "Let's say we have successfully executed one node and are now executing the handoff node. If we crash on the handoff node, we would be left in different states depending on which event we persist on:\n* `AfterNodeCallEvent`: Current node is not set to the handoff node in session because the handoff node hasn't yet emitted its `AfterNodeCallEvent`. This means if we resume after crashing on the handoff node, we will be starting again from the first node.\n* `BeforeNodeCallEvent`: Current node is set to the handoff node in session because the handoff node already emitted its `BeforeNodeCallEvent`. This means if we resume after crashing on the handoff node, we will be starting again from the handoff node.\n\nIn short, persisting on `AfterNodeCallEvent` only made sense when setting the current node to the handoff in the handoff tool.",
        "pr_file_module": null
      },
      {
        "comment_id": "2511343625",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1147,
        "pr_file": "src/strands/session/session_manager.py",
        "discussion_id": "2501622528",
        "commented_code": "@@ -44,7 +44,7 @@ def register_hooks(self, registry: HookRegistry, **kwargs: Any) -> None:\n         registry.add_callback(AfterInvocationEvent, lambda event: self.sync_agent(event.agent))\n \n         registry.add_callback(MultiAgentInitializedEvent, lambda event: self.initialize_multi_agent(event.source))\n-        registry.add_callback(AfterNodeCallEvent, lambda event: self.sync_multi_agent(event.source))\n+        registry.add_callback(BeforeNodeCallEvent, lambda event: self.sync_multi_agent(event.source))",
        "comment_created_at": "2025-11-10T17:11:40+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "This changes also apply to Graph?\r\nInitilized -> Before->1st node->After->Before->2nd node->After,  so for 2nd node(handoff node) before/after is kinda same?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2481615869",
    "pr_number": 1110,
    "pr_file": "src/strands/multiagent/graph.py",
    "created_at": "2025-10-31T14:27:24+00:00",
    "commented_code": "edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    def serialize_state(self) -> dict[str, Any]:\n+        \"\"\"Serialize the current graph state to a dictionary.\"\"\"\n+        status_str = self.state.status.value\n+        compute_nodes = self._compute_ready_nodes_for_resume()\n+        next_nodes = [n.node_id for n in compute_nodes] if compute_nodes else []\n+        return {\n+            \"type\": \"graph\",\n+            \"id\": self.id,\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"failed_nodes\": [n.node_id for n in self.state.failed_nodes],\n+            \"node_results\": {k: v.to_dict() for k, v in (self.state.results or {}).items()},\n+            \"next_nodes_to_execute\": next_nodes,\n+            \"current_task\": self.state.task,\n+            \"execution_order\": [n.node_id for n in self.state.execution_order],\n+        }\n+\n+    def deserialize_state(self, payload: dict[str, Any]) -> None:\n+        \"\"\"Restore graph state from a session dict and prepare for execution.\n+\n+        This method handles two scenarios:\n+        1. If the persisted status is COMPLETED, FAILED resets all nodes and graph state",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2481615869",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1110,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2481615869",
        "commented_code": "@@ -731,3 +804,94 @@ def _build_result(self) -> GraphResult:\n             edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    def serialize_state(self) -> dict[str, Any]:\n+        \"\"\"Serialize the current graph state to a dictionary.\"\"\"\n+        status_str = self.state.status.value\n+        compute_nodes = self._compute_ready_nodes_for_resume()\n+        next_nodes = [n.node_id for n in compute_nodes] if compute_nodes else []\n+        return {\n+            \"type\": \"graph\",\n+            \"id\": self.id,\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"failed_nodes\": [n.node_id for n in self.state.failed_nodes],\n+            \"node_results\": {k: v.to_dict() for k, v in (self.state.results or {}).items()},\n+            \"next_nodes_to_execute\": next_nodes,\n+            \"current_task\": self.state.task,\n+            \"execution_order\": [n.node_id for n in self.state.execution_order],\n+        }\n+\n+    def deserialize_state(self, payload: dict[str, Any]) -> None:\n+        \"\"\"Restore graph state from a session dict and prepare for execution.\n+\n+        This method handles two scenarios:\n+        1. If the persisted status is COMPLETED, FAILED resets all nodes and graph state",
        "comment_created_at": "2025-10-31T14:27:24+00:00",
        "comment_author": "pgrayy",
        "comment_body": "We should be a bit more clear here. If the graph state is FAILED but not at the end of execution, we resume from where we left off. More specifically, if the graph ended last session (whether in a COMPLETED or FAILED state), we start from the beginning.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2389162861",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/graph.py",
    "created_at": "2025-09-29T20:14:03+00:00",
    "commented_code": "logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2389162861",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2389162861",
        "commented_code": "@@ -423,17 +504,30 @@ async def invoke_async(\n \n         logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
        "comment_created_at": "2025-09-29T20:14:03+00:00",
        "comment_author": "zastrowm",
        "comment_body": "> Reset failed nodes after resume.\n\nWhy?",
        "pr_file_module": null
      },
      {
        "comment_id": "2392544762",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2389162861",
        "commented_code": "@@ -423,17 +504,30 @@ async def invoke_async(\n \n         logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
        "comment_created_at": "2025-09-30T18:56:07+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "If we interrupted while a node is executing it might be marked as Failed node, in Graph execution, a failed node won't be re-runned. \r\nOr, you think we should only continue where we left, not trying to recover?",
        "pr_file_module": null
      },
      {
        "comment_id": "2402926617",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2389162861",
        "commented_code": "@@ -423,17 +504,30 @@ async def invoke_async(\n \n         logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
        "comment_created_at": "2025-10-03T18:25:15+00:00",
        "comment_author": "zastrowm",
        "comment_body": "Should we have a new status `interrupted` to represent this instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2408467056",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2389162861",
        "commented_code": "@@ -423,17 +504,30 @@ async def invoke_async(\n \n         logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
        "comment_created_at": "2025-10-06T20:42:36+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "Actually we don't need to. it can resume from any status.",
        "pr_file_module": null
      },
      {
        "comment_id": "2417988490",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2389162861",
        "commented_code": "@@ -423,17 +504,30 @@ async def invoke_async(\n \n         logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
        "comment_created_at": "2025-10-09T21:21:02+00:00",
        "comment_author": "zastrowm",
        "comment_body": "Is there a change in behavior here if we suspend and resume?  E.g. is there a case where we would incorrectly clear a failed state?",
        "pr_file_module": null
      },
      {
        "comment_id": "2421838191",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2389162861",
        "commented_code": "@@ -423,17 +504,30 @@ async def invoke_async(\n \n         logger.debug(\"task=<%s> | starting graph execution\", task)\n \n-        # Initialize state\n-        start_time = time.time()\n-        self.state = GraphState(\n-            status=Status.EXECUTING,\n-            task=task,\n-            total_nodes=len(self.nodes),\n-            edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n-            entry_points=list(self.entry_points),\n-            start_time=start_time,\n-        )\n-\n+        if not self._resume_from_persisted and self.state.status == Status.PENDING:\n+            # TODO: to check if we need do something on BeforeGraphInvocationEvent\n+            self._call_hook_safely(MultiAgentInitializationEvent(orchestrator=self))\n+\n+        self._call_hook_safely(BeforeMultiAgentInvocationEvent(orchestrator=self))\n+\n+        if not self._resume_from_persisted:\n+            start_time = time.time()\n+            # Initialize state\n+            self.state = GraphState(\n+                status=Status.EXECUTING,\n+                task=task,\n+                total_nodes=len(self.nodes),\n+                edges=[(edge.from_node, edge.to_node) for edge in self.edges],\n+                entry_points=sorted(self.entry_points, key=lambda node: node.node_id),\n+                start_time=start_time,\n+            )\n+        else:\n+            if isinstance(self.state.task, (str, list)) and not self.state.task:\n+                self.state.task = task\n+            # Reset failed nodes after resume.",
        "comment_created_at": "2025-10-10T19:23:43+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "Yes, this is a behavior change. In next revision I will remove this `failed_nodes.clear()`.\nMy initial idea was to give failed nodes a second chance to run during resume. However, this would alter the original execution path. Additionally, nodes can fail for various reasons, making this approach potentially problematic",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2441320062",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/graph.py",
    "created_at": "2025-10-17T21:36:28+00:00",
    "commented_code": "edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    # Persistence Helper Functions\n+\n+    def _from_dict(self, payload: dict[str, Any]) -> None:\n+        status_raw = payload.get(\"status\", \"pending\")\n+        self.state.status = Status(status_raw)\n+\n+        # Hydrate completed nodes & results\n+        raw_results = payload.get(\"node_results\") or {}\n+        results: dict[str, NodeResult] = {}\n+        for node_id, entry in raw_results.items():\n+            if node_id not in self.nodes:\n+                continue\n+            try:\n+                results[node_id] = NodeResult.from_dict(entry)\n+            except Exception:\n+                logger.exception(\"Failed to hydrate NodeResult for node_id=%s; skipping.\", node_id)\n+                raise\n+        self.state.results = results\n+\n+        # Restore completed nodes from persisted data\n+        completed_node_ids = payload.get(\"completed_nodes\") or []\n+        self.state.completed_nodes = {self.nodes[node_id] for node_id in completed_node_ids if node_id in self.nodes}\n+\n+        # Execution order (only nodes that still exist)\n+        order_node_ids = payload.get(\"execution_order\") or []\n+        self.state.execution_order = [self.nodes[node_id] for node_id in order_node_ids if node_id in self.nodes]\n+\n+        # Task\n+        self.state.task = payload.get(\"current_task\", self.state.task)\n+\n+    def _to_dict(self) -> dict[str, Any]:\n+        status_str = getattr(self.state.status, \"value\", str(self.state.status))\n+        next_nodes = [n.node_id for n in self._compute_ready_nodes_for_resume()]\n+        return {\n+            \"type\": \"graph\",\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"node_results\": {\n+                k: self.serialize_node_result_for_persist(v) for k, v in (self.state.results or {}).items()\n+            },\n+            \"next_node_to_execute\": next_nodes,\n+            \"current_task\": self.state.task,\n+            \"execution_order\": [n.node_id for n in self.state.execution_order],\n+        }\n+\n+    def _map_node_ids(self, node_ids: list[str] | None) -> list[GraphNode]:\n+        if not node_ids:\n+            return []\n+        mapped_nodes = []\n+        for node_id in node_ids:\n+            node = self.nodes.get(node_id)\n+            if node:\n+                mapped_nodes.append(node)\n+        return mapped_nodes\n+\n+    def _compute_ready_nodes_for_resume(self) -> list[GraphNode]:\n+        ready_nodes: list[GraphNode] = []\n+        completed_nodes = set(self.state.completed_nodes)\n+        for node in self.nodes.values():\n+            if node in completed_nodes:\n+                continue\n+            incoming = [e for e in self.edges if e.to_node is node]\n+            if not incoming:\n+                ready_nodes.append(node)\n+            elif all(e.from_node in completed_nodes and e.should_traverse(self.state) for e in incoming):\n+                ready_nodes.append(node)\n+\n+        return ready_nodes\n+\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\n+\n+        Returns:\n+            Dictionary containing the current graph state\n+        \"\"\"\n+        return self._to_dict()\n+\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict and prepare for execution.\n+\n+        This method handles two scenarios:\n+        1. If the persisted status is COMPLETED, resets all nodes and graph state\n+           to allow re-execution from the beginning.\n+        2. Otherwise, restores the persisted state and prepares to resume execution\n+           from the next ready nodes.\n+\n+        Args:\n+            payload: Dictionary containing persisted state data including status,\n+                    completed nodes, results, and next nodes to execute.\n+        \"\"\"\n+        if payload.get(\"status\") in (Status.COMPLETED.value, \"completed\"):",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2441320062",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2441320062",
        "commented_code": "@@ -736,3 +800,133 @@ def _build_result(self) -> GraphResult:\n             edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    # Persistence Helper Functions\n+\n+    def _from_dict(self, payload: dict[str, Any]) -> None:\n+        status_raw = payload.get(\"status\", \"pending\")\n+        self.state.status = Status(status_raw)\n+\n+        # Hydrate completed nodes & results\n+        raw_results = payload.get(\"node_results\") or {}\n+        results: dict[str, NodeResult] = {}\n+        for node_id, entry in raw_results.items():\n+            if node_id not in self.nodes:\n+                continue\n+            try:\n+                results[node_id] = NodeResult.from_dict(entry)\n+            except Exception:\n+                logger.exception(\"Failed to hydrate NodeResult for node_id=%s; skipping.\", node_id)\n+                raise\n+        self.state.results = results\n+\n+        # Restore completed nodes from persisted data\n+        completed_node_ids = payload.get(\"completed_nodes\") or []\n+        self.state.completed_nodes = {self.nodes[node_id] for node_id in completed_node_ids if node_id in self.nodes}\n+\n+        # Execution order (only nodes that still exist)\n+        order_node_ids = payload.get(\"execution_order\") or []\n+        self.state.execution_order = [self.nodes[node_id] for node_id in order_node_ids if node_id in self.nodes]\n+\n+        # Task\n+        self.state.task = payload.get(\"current_task\", self.state.task)\n+\n+    def _to_dict(self) -> dict[str, Any]:\n+        status_str = getattr(self.state.status, \"value\", str(self.state.status))\n+        next_nodes = [n.node_id for n in self._compute_ready_nodes_for_resume()]\n+        return {\n+            \"type\": \"graph\",\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"node_results\": {\n+                k: self.serialize_node_result_for_persist(v) for k, v in (self.state.results or {}).items()\n+            },\n+            \"next_node_to_execute\": next_nodes,\n+            \"current_task\": self.state.task,\n+            \"execution_order\": [n.node_id for n in self.state.execution_order],\n+        }\n+\n+    def _map_node_ids(self, node_ids: list[str] | None) -> list[GraphNode]:\n+        if not node_ids:\n+            return []\n+        mapped_nodes = []\n+        for node_id in node_ids:\n+            node = self.nodes.get(node_id)\n+            if node:\n+                mapped_nodes.append(node)\n+        return mapped_nodes\n+\n+    def _compute_ready_nodes_for_resume(self) -> list[GraphNode]:\n+        ready_nodes: list[GraphNode] = []\n+        completed_nodes = set(self.state.completed_nodes)\n+        for node in self.nodes.values():\n+            if node in completed_nodes:\n+                continue\n+            incoming = [e for e in self.edges if e.to_node is node]\n+            if not incoming:\n+                ready_nodes.append(node)\n+            elif all(e.from_node in completed_nodes and e.should_traverse(self.state) for e in incoming):\n+                ready_nodes.append(node)\n+\n+        return ready_nodes\n+\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\n+\n+        Returns:\n+            Dictionary containing the current graph state\n+        \"\"\"\n+        return self._to_dict()\n+\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict and prepare for execution.\n+\n+        This method handles two scenarios:\n+        1. If the persisted status is COMPLETED, resets all nodes and graph state\n+           to allow re-execution from the beginning.\n+        2. Otherwise, restores the persisted state and prepares to resume execution\n+           from the next ready nodes.\n+\n+        Args:\n+            payload: Dictionary containing persisted state data including status,\n+                    completed nodes, results, and next nodes to execute.\n+        \"\"\"\n+        if payload.get(\"status\") in (Status.COMPLETED.value, \"completed\"):",
        "comment_created_at": "2025-10-17T21:36:28+00:00",
        "comment_author": "pgrayy",
        "comment_body": "What happens if the graph completed but in a failed state? It seem the following would happen:\r\n```Python\r\ngraph(\"Run my task\") # ended but failed\r\n# shutdown\r\n# startup\r\ngraph(\"Run my next task\") # will immediately return with previous results.\r\n```\r\n\r\nI would expect though for `graph(\"Run my next task\")` to start a new cycle.",
        "pr_file_module": null
      },
      {
        "comment_id": "2445659932",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2441320062",
        "commented_code": "@@ -736,3 +800,133 @@ def _build_result(self) -> GraphResult:\n             edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    # Persistence Helper Functions\n+\n+    def _from_dict(self, payload: dict[str, Any]) -> None:\n+        status_raw = payload.get(\"status\", \"pending\")\n+        self.state.status = Status(status_raw)\n+\n+        # Hydrate completed nodes & results\n+        raw_results = payload.get(\"node_results\") or {}\n+        results: dict[str, NodeResult] = {}\n+        for node_id, entry in raw_results.items():\n+            if node_id not in self.nodes:\n+                continue\n+            try:\n+                results[node_id] = NodeResult.from_dict(entry)\n+            except Exception:\n+                logger.exception(\"Failed to hydrate NodeResult for node_id=%s; skipping.\", node_id)\n+                raise\n+        self.state.results = results\n+\n+        # Restore completed nodes from persisted data\n+        completed_node_ids = payload.get(\"completed_nodes\") or []\n+        self.state.completed_nodes = {self.nodes[node_id] for node_id in completed_node_ids if node_id in self.nodes}\n+\n+        # Execution order (only nodes that still exist)\n+        order_node_ids = payload.get(\"execution_order\") or []\n+        self.state.execution_order = [self.nodes[node_id] for node_id in order_node_ids if node_id in self.nodes]\n+\n+        # Task\n+        self.state.task = payload.get(\"current_task\", self.state.task)\n+\n+    def _to_dict(self) -> dict[str, Any]:\n+        status_str = getattr(self.state.status, \"value\", str(self.state.status))\n+        next_nodes = [n.node_id for n in self._compute_ready_nodes_for_resume()]\n+        return {\n+            \"type\": \"graph\",\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"node_results\": {\n+                k: self.serialize_node_result_for_persist(v) for k, v in (self.state.results or {}).items()\n+            },\n+            \"next_node_to_execute\": next_nodes,\n+            \"current_task\": self.state.task,\n+            \"execution_order\": [n.node_id for n in self.state.execution_order],\n+        }\n+\n+    def _map_node_ids(self, node_ids: list[str] | None) -> list[GraphNode]:\n+        if not node_ids:\n+            return []\n+        mapped_nodes = []\n+        for node_id in node_ids:\n+            node = self.nodes.get(node_id)\n+            if node:\n+                mapped_nodes.append(node)\n+        return mapped_nodes\n+\n+    def _compute_ready_nodes_for_resume(self) -> list[GraphNode]:\n+        ready_nodes: list[GraphNode] = []\n+        completed_nodes = set(self.state.completed_nodes)\n+        for node in self.nodes.values():\n+            if node in completed_nodes:\n+                continue\n+            incoming = [e for e in self.edges if e.to_node is node]\n+            if not incoming:\n+                ready_nodes.append(node)\n+            elif all(e.from_node in completed_nodes and e.should_traverse(self.state) for e in incoming):\n+                ready_nodes.append(node)\n+\n+        return ready_nodes\n+\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\n+\n+        Returns:\n+            Dictionary containing the current graph state\n+        \"\"\"\n+        return self._to_dict()\n+\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict and prepare for execution.\n+\n+        This method handles two scenarios:\n+        1. If the persisted status is COMPLETED, resets all nodes and graph state\n+           to allow re-execution from the beginning.\n+        2. Otherwise, restores the persisted state and prepares to resume execution\n+           from the next ready nodes.\n+\n+        Args:\n+            payload: Dictionary containing persisted state data including status,\n+                    completed nodes, results, and next nodes to execute.\n+        \"\"\"\n+        if payload.get(\"status\") in (Status.COMPLETED.value, \"completed\"):",
        "comment_created_at": "2025-10-20T17:27:01+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "Understood.  \r\nFor example:\r\n`payload.get(\"status\") in (Status.FAILED.value, \"failed\") and not payload.get(\"next_node_to_execute\")`\r\n^ This means failure in last node or this failed node is the blocker to its dependents.\r\n",
        "pr_file_module": null
      }
    ]
  }
]