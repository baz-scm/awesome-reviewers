[
  {
    "discussion_id": "2389180112",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/swarm.py",
    "created_at": "2025-09-29T20:21:43+00:00",
    "commented_code": "execution_time=self.state.execution_time,\n             node_history=self.state.node_history,\n         )\n+\n+    # Persistence Helper function\n+\n+    def _initial_node(self) -> SwarmNode:\n+        if self.entry_point:\n+            return self.nodes[str(self.entry_point.name)]\n+\n+        return next(iter(self.nodes.values()))  # First SwarmNode\n+\n+    def _load_and_apply_persisted_state(self) -> None:\n+        if self.session_manager is None:\n+            return\n+        try:\n+            saved = self.session_manager.read_multi_agent_json()\n+        except Exception as e:\n+            logger.warning(\"Skipping resume; failed to load state: %s\", e)",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2389180112",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/swarm.py",
        "discussion_id": "2389180112",
        "commented_code": "@@ -703,3 +758,112 @@ def _build_result(self) -> SwarmResult:\n             execution_time=self.state.execution_time,\n             node_history=self.state.node_history,\n         )\n+\n+    # Persistence Helper function\n+\n+    def _initial_node(self) -> SwarmNode:\n+        if self.entry_point:\n+            return self.nodes[str(self.entry_point.name)]\n+\n+        return next(iter(self.nodes.values()))  # First SwarmNode\n+\n+    def _load_and_apply_persisted_state(self) -> None:\n+        if self.session_manager is None:\n+            return\n+        try:\n+            saved = self.session_manager.read_multi_agent_json()\n+        except Exception as e:\n+            logger.warning(\"Skipping resume; failed to load state: %s\", e)",
        "comment_created_at": "2025-09-29T20:21:43+00:00",
        "comment_author": "zastrowm",
        "comment_body": "I don't think we should be silently failing here; let's propagate this up",
        "pr_file_module": null
      },
      {
        "comment_id": "2392494671",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/swarm.py",
        "discussion_id": "2389180112",
        "commented_code": "@@ -703,3 +758,112 @@ def _build_result(self) -> SwarmResult:\n             execution_time=self.state.execution_time,\n             node_history=self.state.node_history,\n         )\n+\n+    # Persistence Helper function\n+\n+    def _initial_node(self) -> SwarmNode:\n+        if self.entry_point:\n+            return self.nodes[str(self.entry_point.name)]\n+\n+        return next(iter(self.nodes.values()))  # First SwarmNode\n+\n+    def _load_and_apply_persisted_state(self) -> None:\n+        if self.session_manager is None:\n+            return\n+        try:\n+            saved = self.session_manager.read_multi_agent_json()\n+        except Exception as e:\n+            logger.warning(\"Skipping resume; failed to load state: %s\", e)",
        "comment_created_at": "2025-09-30T18:35:49+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "Yes sir",
        "pr_file_module": null
      },
      {
        "comment_id": "2403029855",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/swarm.py",
        "discussion_id": "2389180112",
        "commented_code": "@@ -703,3 +758,112 @@ def _build_result(self) -> SwarmResult:\n             execution_time=self.state.execution_time,\n             node_history=self.state.node_history,\n         )\n+\n+    # Persistence Helper function\n+\n+    def _initial_node(self) -> SwarmNode:\n+        if self.entry_point:\n+            return self.nodes[str(self.entry_point.name)]\n+\n+        return next(iter(self.nodes.values()))  # First SwarmNode\n+\n+    def _load_and_apply_persisted_state(self) -> None:\n+        if self.session_manager is None:\n+            return\n+        try:\n+            saved = self.session_manager.read_multi_agent_json()\n+        except Exception as e:\n+            logger.warning(\"Skipping resume; failed to load state: %s\", e)",
        "comment_created_at": "2025-10-03T18:54:44+00:00",
        "comment_author": "zastrowm",
        "comment_body": "All cases where we're logging a warning we should be letting the exception propagate up.  Especially while in experimental, we want to know about as many bugs as possible",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2395708664",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/base.py",
    "created_at": "2025-10-01T19:47:18+00:00",
    "commented_code": "with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    @abstractmethod\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict.\"\"\"\n+        raise NotImplementedError\n+\n+    def serialize_node_result_for_persist(self, raw: NodeResult) -> dict[str, Any]:\n+        \"\"\"Serialize node result for persistence.\n+\n+        Args:\n+            raw: Raw node result to serialize\n+\n+        Returns:\n+            JSON-serializable dict representation\n+        \"\"\"\n+        if isinstance(raw, dict):\n+            return raw\n+\n+        if hasattr(raw, \"to_dict\") and callable(raw.to_dict):\n+            return raw.to_dict()\n+\n+        # Fallback for strings and other types\n+        return {\"agent_outputs\": [str(raw)]}",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2395708664",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/base.py",
        "discussion_id": "2395708664",
        "commented_code": "@@ -117,3 +164,31 @@ def execute() -> MultiAgentResult:\n         with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    @abstractmethod\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict.\"\"\"\n+        raise NotImplementedError\n+\n+    def serialize_node_result_for_persist(self, raw: NodeResult) -> dict[str, Any]:\n+        \"\"\"Serialize node result for persistence.\n+\n+        Args:\n+            raw: Raw node result to serialize\n+\n+        Returns:\n+            JSON-serializable dict representation\n+        \"\"\"\n+        if isinstance(raw, dict):\n+            return raw\n+\n+        if hasattr(raw, \"to_dict\") and callable(raw.to_dict):\n+            return raw.to_dict()\n+\n+        # Fallback for strings and other types\n+        return {\"agent_outputs\": [str(raw)]}",
        "comment_created_at": "2025-10-01T19:47:18+00:00",
        "comment_author": "Unshure",
        "comment_body": "Should we fallback? Or should we throw an exception here if we dont know what it is?",
        "pr_file_module": null
      },
      {
        "comment_id": "2395824099",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/base.py",
        "discussion_id": "2395708664",
        "commented_code": "@@ -117,3 +164,31 @@ def execute() -> MultiAgentResult:\n         with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    @abstractmethod\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict.\"\"\"\n+        raise NotImplementedError\n+\n+    def serialize_node_result_for_persist(self, raw: NodeResult) -> dict[str, Any]:\n+        \"\"\"Serialize node result for persistence.\n+\n+        Args:\n+            raw: Raw node result to serialize\n+\n+        Returns:\n+            JSON-serializable dict representation\n+        \"\"\"\n+        if isinstance(raw, dict):\n+            return raw\n+\n+        if hasattr(raw, \"to_dict\") and callable(raw.to_dict):\n+            return raw.to_dict()\n+\n+        # Fallback for strings and other types\n+        return {\"agent_outputs\": [str(raw)]}",
        "comment_created_at": "2025-10-01T20:26:34+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "We should safely handle to_dict() already, this line is more like defensive check. Even if we fall back to string, I think we still could add raw string as context for resumption.",
        "pr_file_module": null
      },
      {
        "comment_id": "2402901809",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/base.py",
        "discussion_id": "2395708664",
        "commented_code": "@@ -117,3 +164,31 @@ def execute() -> MultiAgentResult:\n         with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    @abstractmethod\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict.\"\"\"\n+        raise NotImplementedError\n+\n+    def serialize_node_result_for_persist(self, raw: NodeResult) -> dict[str, Any]:\n+        \"\"\"Serialize node result for persistence.\n+\n+        Args:\n+            raw: Raw node result to serialize\n+\n+        Returns:\n+            JSON-serializable dict representation\n+        \"\"\"\n+        if isinstance(raw, dict):\n+            return raw\n+\n+        if hasattr(raw, \"to_dict\") and callable(raw.to_dict):\n+            return raw.to_dict()\n+\n+        # Fallback for strings and other types\n+        return {\"agent_outputs\": [str(raw)]}",
        "comment_created_at": "2025-10-03T18:17:17+00:00",
        "comment_author": "zastrowm",
        "comment_body": "> Even if we fall back to string, I think we still could add raw string as context for resumption.\n\nI'm concerned that we'd be masking problems.  Esp for the first release and in experimental, I'd rather throw in cases that we're unsure of so that we can iron out bugs with users, rather than potentially be throwing away data or masking bugs",
        "pr_file_module": null
      },
      {
        "comment_id": "2408532119",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/base.py",
        "discussion_id": "2395708664",
        "commented_code": "@@ -117,3 +164,31 @@ def execute() -> MultiAgentResult:\n         with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    @abstractmethod\n+    def serialize_state(self) -> dict:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def deserialize_state(self, payload: dict) -> None:\n+        \"\"\"Restore orchestrator state from a session dict.\"\"\"\n+        raise NotImplementedError\n+\n+    def serialize_node_result_for_persist(self, raw: NodeResult) -> dict[str, Any]:\n+        \"\"\"Serialize node result for persistence.\n+\n+        Args:\n+            raw: Raw node result to serialize\n+\n+        Returns:\n+            JSON-serializable dict representation\n+        \"\"\"\n+        if isinstance(raw, dict):\n+            return raw\n+\n+        if hasattr(raw, \"to_dict\") and callable(raw.to_dict):\n+            return raw.to_dict()\n+\n+        # Fallback for strings and other types\n+        return {\"agent_outputs\": [str(raw)]}",
        "comment_created_at": "2025-10-06T20:56:33+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "Got it, removed fall back to string for now, only returns defined type/ dict.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2445852062",
    "pr_number": 900,
    "pr_file": "src/strands/session/session_manager.py",
    "created_at": "2025-10-20T18:58:18+00:00",
    "commented_code": "agent: Agent to initialize\n             **kwargs: Additional keyword arguments for future extensibility.\n         \"\"\"\n+\n+    def _persist_multi_agent_state(self, source: \"MultiAgentBase\") -> None:\n+        \"\"\"Thread-safe persistence of multi-agent state.\n+\n+        Args:\n+            source: Multi-agent orchestrator to persist\n+        \"\"\"\n+        with self._lock:\n+            state = source.serialize_state()\n+            self.write_multi_agent_json(state)\n+\n+    def write_multi_agent_json(self, state: dict[str, Any]) -> None:\n+        \"\"\"Write multi-agent state to persistent storage.\n+\n+        Args:\n+            state: Multi-agent state dictionary to persist\n+        \"\"\"\n+        raise NotImplementedError(\n+            f\"{self.__class__.__name__} does not support multi-agent persistence \"\n+            \"(write_multi_agent_json). Provide an implementation or use a \"\n+            \"SessionManager with session_type=SessionType.MULTI_AGENT.\"\n+        )\n+\n+    def read_multi_agent_json(self) -> dict[str, Any]:\n+        \"\"\"Read multi-agent state from persistent storage.\n+\n+        Returns:\n+            Multi-agent state dictionary or empty dict if not found\n+        \"\"\"\n+        raise NotImplementedError(\n+            f\"{self.__class__.__name__} does not support multi-agent persistence \"\n+            \"(read_multi_agent_json). Provide an implementation or use a \"\n+            \"SessionManager with session_type=SessionType.MULTI_AGENT.\"\n+        )\n+\n+    def _on_multiagent_initialized(self, event: MultiAgentInitializedEvent) -> None:\n+        \"\"\"Initialization path: attempt to resume and then persist a fresh snapshot.\"\"\"\n+        source: MultiAgentBase = event.source\n+        payload = self.read_multi_agent_json()\n+        # payload can be {} or Graph/Swarm state json\n+        if payload:\n+            source.deserialize_state(payload)\n+        else:\n+            try:\n+                self._persist_multi_agent_state(source)\n+            except NotImplementedError:",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2445852062",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/session/session_manager.py",
        "discussion_id": "2445852062",
        "commented_code": "@@ -71,3 +99,50 @@ def initialize(self, agent: \"Agent\", **kwargs: Any) -> None:\n             agent: Agent to initialize\n             **kwargs: Additional keyword arguments for future extensibility.\n         \"\"\"\n+\n+    def _persist_multi_agent_state(self, source: \"MultiAgentBase\") -> None:\n+        \"\"\"Thread-safe persistence of multi-agent state.\n+\n+        Args:\n+            source: Multi-agent orchestrator to persist\n+        \"\"\"\n+        with self._lock:\n+            state = source.serialize_state()\n+            self.write_multi_agent_json(state)\n+\n+    def write_multi_agent_json(self, state: dict[str, Any]) -> None:\n+        \"\"\"Write multi-agent state to persistent storage.\n+\n+        Args:\n+            state: Multi-agent state dictionary to persist\n+        \"\"\"\n+        raise NotImplementedError(\n+            f\"{self.__class__.__name__} does not support multi-agent persistence \"\n+            \"(write_multi_agent_json). Provide an implementation or use a \"\n+            \"SessionManager with session_type=SessionType.MULTI_AGENT.\"\n+        )\n+\n+    def read_multi_agent_json(self) -> dict[str, Any]:\n+        \"\"\"Read multi-agent state from persistent storage.\n+\n+        Returns:\n+            Multi-agent state dictionary or empty dict if not found\n+        \"\"\"\n+        raise NotImplementedError(\n+            f\"{self.__class__.__name__} does not support multi-agent persistence \"\n+            \"(read_multi_agent_json). Provide an implementation or use a \"\n+            \"SessionManager with session_type=SessionType.MULTI_AGENT.\"\n+        )\n+\n+    def _on_multiagent_initialized(self, event: MultiAgentInitializedEvent) -> None:\n+        \"\"\"Initialization path: attempt to resume and then persist a fresh snapshot.\"\"\"\n+        source: MultiAgentBase = event.source\n+        payload = self.read_multi_agent_json()\n+        # payload can be {} or Graph/Swarm state json\n+        if payload:\n+            source.deserialize_state(payload)\n+        else:\n+            try:\n+                self._persist_multi_agent_state(source)\n+            except NotImplementedError:",
        "comment_created_at": "2025-10-20T18:58:18+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "shouldn't we be raising the exception here still? If we pass then someone would do \n\n```\nGraph(session_manager=SomeSessionManager)\n```\n\nthen it would do nothing, then when we do _persist_multi_agent_state it would throw NotImplementedError. So why not just throw early?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2392372667",
    "pr_number": 950,
    "pr_file": "src/strands/tools/registry.py",
    "created_at": "2025-09-30T17:41:09+00:00",
    "commented_code": "tool_dirs.append(directory)\n                 logger.debug(\"tools_dir=<%s> | found tools directory\", directory)\n             else:\n-                logger.debug(\"tools_dir=<%s> | tools directory not found\", directory)\n+                logger.debug(",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2392372667",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 950,
        "pr_file": "src/strands/tools/registry.py",
        "discussion_id": "2392372667",
        "commented_code": "@@ -246,7 +246,11 @@ def get_tools_dirs(self) -> List[Path]:\n                 tool_dirs.append(directory)\n                 logger.debug(\"tools_dir=<%s> | found tools directory\", directory)\n             else:\n-                logger.debug(\"tools_dir=<%s> | tools directory not found\", directory)\n+                logger.debug(",
        "comment_created_at": "2025-09-30T17:41:09+00:00",
        "comment_author": "zastrowm",
        "comment_body": "Any reason not to throw?  I feel like if you enable this option and there is no directory, it's not obvious that it's not going to work.\n\nI feel like because they explicitly opt-ed in, we should either throw or create the directory",
        "pr_file_module": null
      },
      {
        "comment_id": "2392627239",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 950,
        "pr_file": "src/strands/tools/registry.py",
        "discussion_id": "2392372667",
        "commented_code": "@@ -246,7 +246,11 @@ def get_tools_dirs(self) -> List[Path]:\n                 tool_dirs.append(directory)\n                 logger.debug(\"tools_dir=<%s> | found tools directory\", directory)\n             else:\n-                logger.debug(\"tools_dir=<%s> | tools directory not found\", directory)\n+                logger.debug(",
        "comment_created_at": "2025-09-30T19:30:15+00:00",
        "comment_author": "Unshure",
        "comment_body": "Backwards compatibility \u00af\\\\\\_(\u30c4)\\_/\u00af\r\n\r\nI actually mean to update this to a warning instead of debug, so at least this is more visible",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2395544036",
    "pr_number": 943,
    "pr_file": "src/strands/event_loop/event_loop.py",
    "created_at": "2025-10-01T18:51:25+00:00",
    "commented_code": "logger.exception(\"cycle failed\")\n         raise EventLoopException(e, invocation_state[\"request_state\"]) from e\n \n-    yield EventLoopStopEvent(stop_reason, message, agent.event_loop_metrics, invocation_state[\"request_state\"])\n+    # Force structured output tool call if LLM didn't use it automatically\n+    if structured_output_context and structured_output_context.output_schema and stop_reason == \"end_turn\":\n+        if not structured_output_context.can_retry():\n+            logger.warning(",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2395544036",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/event_loop/event_loop.py",
        "discussion_id": "2395544036",
        "commented_code": "@@ -265,18 +286,49 @@ async def event_loop_cycle(agent: \"Agent\", invocation_state: dict[str, Any]) ->\n         logger.exception(\"cycle failed\")\n         raise EventLoopException(e, invocation_state[\"request_state\"]) from e\n \n-    yield EventLoopStopEvent(stop_reason, message, agent.event_loop_metrics, invocation_state[\"request_state\"])\n+    # Force structured output tool call if LLM didn't use it automatically\n+    if structured_output_context and structured_output_context.output_schema and stop_reason == \"end_turn\":\n+        if not structured_output_context.can_retry():\n+            logger.warning(",
        "comment_created_at": "2025-10-01T18:51:25+00:00",
        "comment_author": "zastrowm",
        "comment_body": "I think this should be a throw case?  Let's throw for now and we can lighten later if we decide that's not desirable.\n\nBut for now I'd say \"If we said it has to be structured_output and it ends up not being structured_output, we should make the user aware of that\"",
        "pr_file_module": null
      },
      {
        "comment_id": "2395627922",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/event_loop/event_loop.py",
        "discussion_id": "2395544036",
        "commented_code": "@@ -265,18 +286,49 @@ async def event_loop_cycle(agent: \"Agent\", invocation_state: dict[str, Any]) ->\n         logger.exception(\"cycle failed\")\n         raise EventLoopException(e, invocation_state[\"request_state\"]) from e\n \n-    yield EventLoopStopEvent(stop_reason, message, agent.event_loop_metrics, invocation_state[\"request_state\"])\n+    # Force structured output tool call if LLM didn't use it automatically\n+    if structured_output_context and structured_output_context.output_schema and stop_reason == \"end_turn\":\n+        if not structured_output_context.can_retry():\n+            logger.warning(",
        "comment_created_at": "2025-10-01T19:16:23+00:00",
        "comment_author": "afarntrog",
        "comment_body": "hmmm. I can hear that. I think this comes back to what you mentioned to me earlier how we can consider a `structured_output_config` in the future and something like this can be configured. Although, I would push back a bit on raising an error to be the default as users may _desire_ structured output but settle on the text output when it's not feasible. I would like to reason through some more use cases as for now I can hear both sides.",
        "pr_file_module": null
      },
      {
        "comment_id": "2395869824",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/event_loop/event_loop.py",
        "discussion_id": "2395544036",
        "commented_code": "@@ -265,18 +286,49 @@ async def event_loop_cycle(agent: \"Agent\", invocation_state: dict[str, Any]) ->\n         logger.exception(\"cycle failed\")\n         raise EventLoopException(e, invocation_state[\"request_state\"]) from e\n \n-    yield EventLoopStopEvent(stop_reason, message, agent.event_loop_metrics, invocation_state[\"request_state\"])\n+    # Force structured output tool call if LLM didn't use it automatically\n+    if structured_output_context and structured_output_context.output_schema and stop_reason == \"end_turn\":\n+        if not structured_output_context.can_retry():\n+            logger.warning(",
        "comment_created_at": "2025-10-01T20:50:27+00:00",
        "comment_author": "Unshure",
        "comment_body": "Can we raise an exception that captures that additional information. If our structured output feature did not produce structured output, that feels like an error. If someone wants to do something with that, they can catch the error and then handle it. An exception feels more explicit.",
        "pr_file_module": null
      },
      {
        "comment_id": "2406828470",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/event_loop/event_loop.py",
        "discussion_id": "2395544036",
        "commented_code": "@@ -265,18 +286,49 @@ async def event_loop_cycle(agent: \"Agent\", invocation_state: dict[str, Any]) ->\n         logger.exception(\"cycle failed\")\n         raise EventLoopException(e, invocation_state[\"request_state\"]) from e\n \n-    yield EventLoopStopEvent(stop_reason, message, agent.event_loop_metrics, invocation_state[\"request_state\"])\n+    # Force structured output tool call if LLM didn't use it automatically\n+    if structured_output_context and structured_output_context.output_schema and stop_reason == \"end_turn\":\n+        if not structured_output_context.can_retry():\n+            logger.warning(",
        "comment_created_at": "2025-10-06T14:56:50+00:00",
        "comment_author": "afarntrog",
        "comment_body": "updated to raise a `StructuredOutputException`",
        "pr_file_module": null
      }
    ]
  }
]