[
  {
    "discussion_id": "2523563991",
    "pr_number": 1174,
    "pr_file": "src/strands/agent/a2a_agent.py",
    "created_at": "2025-11-13T13:54:57+00:00",
    "commented_code": "+\"\"\"A2A Agent client for Strands Agents.\n+\n+This module provides the A2AAgent class, which acts as a client wrapper for remote A2A agents,\n+allowing them to be used in graphs, swarms, and other multi-agent patterns.\n+\"\"\"\n+\n+import logging\n+from typing import Any, AsyncIterator, cast\n+from uuid import uuid4\n+\n+import httpx\n+from a2a.client import A2ACardResolver, ClientConfig, ClientFactory\n+from a2a.types import AgentCard, Part, Role, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent, TextPart\n+from a2a.types import Message as A2AMessage\n+\n+from .._async import run_async\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.agent import AgentInput\n+from ..types.content import ContentBlock, Message\n+from .agent_result import AgentResult\n+\n+logger = logging.getLogger(__name__)\n+\n+DEFAULT_TIMEOUT = 300\n+\n+\n+class A2AAgent:\n+    \"\"\"Client wrapper for remote A2A agents.\n+\n+    Implements the AgentBase protocol to enable remote A2A agents to be used\n+    in graphs, swarms, and other multi-agent patterns.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        endpoint: str,\n+        timeout: int = DEFAULT_TIMEOUT,\n+        httpx_client_args: dict[str, Any] | None = None,\n+    ):\n+        \"\"\"Initialize A2A agent client.\n+\n+        Args:\n+            endpoint: The base URL of the remote A2A agent\n+            timeout: Timeout for HTTP operations in seconds (defaults to 300)\n+            httpx_client_args: Optional dictionary of arguments to pass to httpx.AsyncClient\n+                constructor. Allows custom auth, headers, proxies, etc.\n+                Example: {\"headers\": {\"Authorization\": \"Bearer token\"}}\n+        \"\"\"\n+        self.endpoint = endpoint\n+        self.timeout = timeout\n+        self._httpx_client_args: dict[str, Any] = httpx_client_args or {}\n+\n+        if \"timeout\" not in self._httpx_client_args:\n+            self._httpx_client_args[\"timeout\"] = self.timeout\n+\n+        self._agent_card: AgentCard | None = None\n+\n+    def _get_httpx_client(self) -> httpx.AsyncClient:\n+        \"\"\"Get a fresh httpx client for the current operation.\n+\n+        Returns:\n+            Configured httpx.AsyncClient instance.\n+        \"\"\"\n+        return httpx.AsyncClient(**self._httpx_client_args)\n+\n+    def _get_client_factory(self, streaming: bool = False) -> ClientFactory:\n+        \"\"\"Get a ClientFactory for the current operation.\n+\n+        Args:\n+            streaming: Whether to enable streaming mode.\n+\n+        Returns:\n+            Configured ClientFactory instance.\n+        \"\"\"\n+        httpx_client = self._get_httpx_client()\n+        config = ClientConfig(\n+            httpx_client=httpx_client,\n+            streaming=streaming,\n+        )\n+        return ClientFactory(config)\n+\n+    async def _discover_agent_card(self) -> AgentCard:",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2523563991",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1174,
        "pr_file": "src/strands/agent/a2a_agent.py",
        "discussion_id": "2523563991",
        "commented_code": "@@ -0,0 +1,283 @@\n+\"\"\"A2A Agent client for Strands Agents.\n+\n+This module provides the A2AAgent class, which acts as a client wrapper for remote A2A agents,\n+allowing them to be used in graphs, swarms, and other multi-agent patterns.\n+\"\"\"\n+\n+import logging\n+from typing import Any, AsyncIterator, cast\n+from uuid import uuid4\n+\n+import httpx\n+from a2a.client import A2ACardResolver, ClientConfig, ClientFactory\n+from a2a.types import AgentCard, Part, Role, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent, TextPart\n+from a2a.types import Message as A2AMessage\n+\n+from .._async import run_async\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.agent import AgentInput\n+from ..types.content import ContentBlock, Message\n+from .agent_result import AgentResult\n+\n+logger = logging.getLogger(__name__)\n+\n+DEFAULT_TIMEOUT = 300\n+\n+\n+class A2AAgent:\n+    \"\"\"Client wrapper for remote A2A agents.\n+\n+    Implements the AgentBase protocol to enable remote A2A agents to be used\n+    in graphs, swarms, and other multi-agent patterns.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        endpoint: str,\n+        timeout: int = DEFAULT_TIMEOUT,\n+        httpx_client_args: dict[str, Any] | None = None,\n+    ):\n+        \"\"\"Initialize A2A agent client.\n+\n+        Args:\n+            endpoint: The base URL of the remote A2A agent\n+            timeout: Timeout for HTTP operations in seconds (defaults to 300)\n+            httpx_client_args: Optional dictionary of arguments to pass to httpx.AsyncClient\n+                constructor. Allows custom auth, headers, proxies, etc.\n+                Example: {\"headers\": {\"Authorization\": \"Bearer token\"}}\n+        \"\"\"\n+        self.endpoint = endpoint\n+        self.timeout = timeout\n+        self._httpx_client_args: dict[str, Any] = httpx_client_args or {}\n+\n+        if \"timeout\" not in self._httpx_client_args:\n+            self._httpx_client_args[\"timeout\"] = self.timeout\n+\n+        self._agent_card: AgentCard | None = None\n+\n+    def _get_httpx_client(self) -> httpx.AsyncClient:\n+        \"\"\"Get a fresh httpx client for the current operation.\n+\n+        Returns:\n+            Configured httpx.AsyncClient instance.\n+        \"\"\"\n+        return httpx.AsyncClient(**self._httpx_client_args)\n+\n+    def _get_client_factory(self, streaming: bool = False) -> ClientFactory:\n+        \"\"\"Get a ClientFactory for the current operation.\n+\n+        Args:\n+            streaming: Whether to enable streaming mode.\n+\n+        Returns:\n+            Configured ClientFactory instance.\n+        \"\"\"\n+        httpx_client = self._get_httpx_client()\n+        config = ClientConfig(\n+            httpx_client=httpx_client,\n+            streaming=streaming,\n+        )\n+        return ClientFactory(config)\n+\n+    async def _discover_agent_card(self) -> AgentCard:",
        "comment_created_at": "2025-11-13T13:54:57+00:00",
        "comment_author": "mkmeral",
        "comment_body": "nit: get agent card? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2523564770",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1174,
        "pr_file": "src/strands/agent/a2a_agent.py",
        "discussion_id": "2523563991",
        "commented_code": "@@ -0,0 +1,283 @@\n+\"\"\"A2A Agent client for Strands Agents.\n+\n+This module provides the A2AAgent class, which acts as a client wrapper for remote A2A agents,\n+allowing them to be used in graphs, swarms, and other multi-agent patterns.\n+\"\"\"\n+\n+import logging\n+from typing import Any, AsyncIterator, cast\n+from uuid import uuid4\n+\n+import httpx\n+from a2a.client import A2ACardResolver, ClientConfig, ClientFactory\n+from a2a.types import AgentCard, Part, Role, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent, TextPart\n+from a2a.types import Message as A2AMessage\n+\n+from .._async import run_async\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.agent import AgentInput\n+from ..types.content import ContentBlock, Message\n+from .agent_result import AgentResult\n+\n+logger = logging.getLogger(__name__)\n+\n+DEFAULT_TIMEOUT = 300\n+\n+\n+class A2AAgent:\n+    \"\"\"Client wrapper for remote A2A agents.\n+\n+    Implements the AgentBase protocol to enable remote A2A agents to be used\n+    in graphs, swarms, and other multi-agent patterns.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        endpoint: str,\n+        timeout: int = DEFAULT_TIMEOUT,\n+        httpx_client_args: dict[str, Any] | None = None,\n+    ):\n+        \"\"\"Initialize A2A agent client.\n+\n+        Args:\n+            endpoint: The base URL of the remote A2A agent\n+            timeout: Timeout for HTTP operations in seconds (defaults to 300)\n+            httpx_client_args: Optional dictionary of arguments to pass to httpx.AsyncClient\n+                constructor. Allows custom auth, headers, proxies, etc.\n+                Example: {\"headers\": {\"Authorization\": \"Bearer token\"}}\n+        \"\"\"\n+        self.endpoint = endpoint\n+        self.timeout = timeout\n+        self._httpx_client_args: dict[str, Any] = httpx_client_args or {}\n+\n+        if \"timeout\" not in self._httpx_client_args:\n+            self._httpx_client_args[\"timeout\"] = self.timeout\n+\n+        self._agent_card: AgentCard | None = None\n+\n+    def _get_httpx_client(self) -> httpx.AsyncClient:\n+        \"\"\"Get a fresh httpx client for the current operation.\n+\n+        Returns:\n+            Configured httpx.AsyncClient instance.\n+        \"\"\"\n+        return httpx.AsyncClient(**self._httpx_client_args)\n+\n+    def _get_client_factory(self, streaming: bool = False) -> ClientFactory:\n+        \"\"\"Get a ClientFactory for the current operation.\n+\n+        Args:\n+            streaming: Whether to enable streaming mode.\n+\n+        Returns:\n+            Configured ClientFactory instance.\n+        \"\"\"\n+        httpx_client = self._get_httpx_client()\n+        config = ClientConfig(\n+            httpx_client=httpx_client,\n+            streaming=streaming,\n+        )\n+        return ClientFactory(config)\n+\n+    async def _discover_agent_card(self) -> AgentCard:",
        "comment_created_at": "2025-11-13T13:55:11+00:00",
        "comment_author": "mkmeral",
        "comment_body": "or better yet @property agent_card? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2523727849",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1174,
        "pr_file": "src/strands/agent/a2a_agent.py",
        "discussion_id": "2523563991",
        "commented_code": "@@ -0,0 +1,283 @@\n+\"\"\"A2A Agent client for Strands Agents.\n+\n+This module provides the A2AAgent class, which acts as a client wrapper for remote A2A agents,\n+allowing them to be used in graphs, swarms, and other multi-agent patterns.\n+\"\"\"\n+\n+import logging\n+from typing import Any, AsyncIterator, cast\n+from uuid import uuid4\n+\n+import httpx\n+from a2a.client import A2ACardResolver, ClientConfig, ClientFactory\n+from a2a.types import AgentCard, Part, Role, Task, TaskArtifactUpdateEvent, TaskStatusUpdateEvent, TextPart\n+from a2a.types import Message as A2AMessage\n+\n+from .._async import run_async\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.agent import AgentInput\n+from ..types.content import ContentBlock, Message\n+from .agent_result import AgentResult\n+\n+logger = logging.getLogger(__name__)\n+\n+DEFAULT_TIMEOUT = 300\n+\n+\n+class A2AAgent:\n+    \"\"\"Client wrapper for remote A2A agents.\n+\n+    Implements the AgentBase protocol to enable remote A2A agents to be used\n+    in graphs, swarms, and other multi-agent patterns.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        endpoint: str,\n+        timeout: int = DEFAULT_TIMEOUT,\n+        httpx_client_args: dict[str, Any] | None = None,\n+    ):\n+        \"\"\"Initialize A2A agent client.\n+\n+        Args:\n+            endpoint: The base URL of the remote A2A agent\n+            timeout: Timeout for HTTP operations in seconds (defaults to 300)\n+            httpx_client_args: Optional dictionary of arguments to pass to httpx.AsyncClient\n+                constructor. Allows custom auth, headers, proxies, etc.\n+                Example: {\"headers\": {\"Authorization\": \"Bearer token\"}}\n+        \"\"\"\n+        self.endpoint = endpoint\n+        self.timeout = timeout\n+        self._httpx_client_args: dict[str, Any] = httpx_client_args or {}\n+\n+        if \"timeout\" not in self._httpx_client_args:\n+            self._httpx_client_args[\"timeout\"] = self.timeout\n+\n+        self._agent_card: AgentCard | None = None\n+\n+    def _get_httpx_client(self) -> httpx.AsyncClient:\n+        \"\"\"Get a fresh httpx client for the current operation.\n+\n+        Returns:\n+            Configured httpx.AsyncClient instance.\n+        \"\"\"\n+        return httpx.AsyncClient(**self._httpx_client_args)\n+\n+    def _get_client_factory(self, streaming: bool = False) -> ClientFactory:\n+        \"\"\"Get a ClientFactory for the current operation.\n+\n+        Args:\n+            streaming: Whether to enable streaming mode.\n+\n+        Returns:\n+            Configured ClientFactory instance.\n+        \"\"\"\n+        httpx_client = self._get_httpx_client()\n+        config = ClientConfig(\n+            httpx_client=httpx_client,\n+            streaming=streaming,\n+        )\n+        return ClientFactory(config)\n+\n+    async def _discover_agent_card(self) -> AgentCard:",
        "comment_created_at": "2025-11-13T14:38:24+00:00",
        "comment_author": "awsarron",
        "comment_body": "will rename to `get_agent_card`. Not sure if it can be a `@property` cleanly because it's resolved async with `A2ACardResolver`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2528715609",
    "pr_number": 1184,
    "pr_file": "src/strands/tools/mcp/mcp_agent_tool.py",
    "created_at": "2025-11-14T19:35:25+00:00",
    "commented_code": "seamlessly within the agent framework.\n     \"\"\"\n \n-    def __init__(self, mcp_tool: MCPTool, mcp_client: \"MCPClient\", name_override: str | None = None) -> None:\n+    def __init__(\n+        self,\n+        mcp_tool: MCPTool,\n+        mcp_client: \"MCPClient\",\n+        name_override: str | None = None,\n+        timeout: timedelta | None = None,\n+    ) -> None:\n         \"\"\"Initialize a new MCPAgentTool instance.\n \n         Args:\n             mcp_tool: The MCP tool to adapt\n             mcp_client: The MCP server connection to use for tool invocation\n             name_override: Optional name to use for the agent tool (for disambiguation)\n                            If None, uses the original MCP tool name\n+            timeout: Optional timeout duration for tool execution\n         \"\"\"\n         super().__init__()\n         logger.debug(\"tool_name=<%s> | creating mcp agent tool\", mcp_tool.name)\n         self.mcp_tool = mcp_tool\n         self.mcp_client = mcp_client\n         self._agent_tool_name = name_override or mcp_tool.name\n+        self._timeout_seconds = timeout",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2528715609",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 1184,
        "pr_file": "src/strands/tools/mcp/mcp_agent_tool.py",
        "discussion_id": "2528715609",
        "commented_code": "@@ -28,20 +29,28 @@ class MCPAgentTool(AgentTool):\n     seamlessly within the agent framework.\n     \"\"\"\n \n-    def __init__(self, mcp_tool: MCPTool, mcp_client: \"MCPClient\", name_override: str | None = None) -> None:\n+    def __init__(\n+        self,\n+        mcp_tool: MCPTool,\n+        mcp_client: \"MCPClient\",\n+        name_override: str | None = None,\n+        timeout: timedelta | None = None,\n+    ) -> None:\n         \"\"\"Initialize a new MCPAgentTool instance.\n \n         Args:\n             mcp_tool: The MCP tool to adapt\n             mcp_client: The MCP server connection to use for tool invocation\n             name_override: Optional name to use for the agent tool (for disambiguation)\n                            If None, uses the original MCP tool name\n+            timeout: Optional timeout duration for tool execution\n         \"\"\"\n         super().__init__()\n         logger.debug(\"tool_name=<%s> | creating mcp agent tool\", mcp_tool.name)\n         self.mcp_tool = mcp_tool\n         self.mcp_client = mcp_client\n         self._agent_tool_name = name_override or mcp_tool.name\n+        self._timeout_seconds = timeout",
        "comment_created_at": "2025-11-14T19:35:25+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "hey I know you got this from mcp_client, but this is a bad name that we shouldn't propagate.\n\nlets make this public if the expectation is that at user will override this. and then instead of timeout_seconds lets just call it timeout since we are accepting a timedelta not an int of seconds",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2389145360",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/base.py",
    "created_at": "2025-09-29T20:05:37+00:00",
    "commented_code": "with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    def _call_hook_safely(self, event_object: object) -> None:\n+        \"\"\"Invoke hook callbacks and swallow hook errors.\n+\n+        Args:\n+            event_object: The event to dispatch to registered callbacks.\n+        \"\"\"\n+        try:\n+            self.hooks.invoke_callbacks(event_object)  # type: ignore\n+        except Exception as e:\n+            logger.exception(\"Hook invocation failed for %s: %s\", type(event_object).__name__, e)\n+\n+    @abstractmethod\n+    def get_state_from_orchestrator(self) -> dict:",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2389145360",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/base.py",
        "discussion_id": "2389145360",
        "commented_code": "@@ -117,3 +134,66 @@ def execute() -> MultiAgentResult:\n         with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    def _call_hook_safely(self, event_object: object) -> None:\n+        \"\"\"Invoke hook callbacks and swallow hook errors.\n+\n+        Args:\n+            event_object: The event to dispatch to registered callbacks.\n+        \"\"\"\n+        try:\n+            self.hooks.invoke_callbacks(event_object)  # type: ignore\n+        except Exception as e:\n+            logger.exception(\"Hook invocation failed for %s: %s\", type(event_object).__name__, e)\n+\n+    @abstractmethod\n+    def get_state_from_orchestrator(self) -> dict:",
        "comment_created_at": "2025-09-29T20:05:37+00:00",
        "comment_author": "zastrowm",
        "comment_body": "I would propose `serialize_state` and `deserialize_state` for these method names",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2395545258",
    "pr_number": 900,
    "pr_file": "src/strands/experimental/multiagent_hooks/multiagent_events.py",
    "created_at": "2025-10-01T18:51:52+00:00",
    "commented_code": "+\"\"\"Multi-agent execution lifecycle events for hook system integration.\n+\n+These events are fired by orchestrators (Graph/Swarm) at key points so\n+hooks can persist, monitor, or debug execution. No intermediate state model\n+is used\u2014hooks read from the orchestrator directly.\n+\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import TYPE_CHECKING, Any\n+\n+from ...hooks.registry import BaseHookEvent\n+\n+if TYPE_CHECKING:\n+    from ...multiagent.base import MultiAgentBase\n+\n+\n+@dataclass\n+class MultiAgentInitializationEvent(BaseHookEvent):\n+    \"\"\"Event triggered when multi-agent orchestrator initializes.\n+\n+    Attributes:\n+        orchestrator: The multi-agent orchestrator instance\n+        invocation_state: Configuration that user pass in\n+    \"\"\"\n+\n+    orchestrator: \"MultiAgentBase\"",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2395545258",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/experimental/multiagent_hooks/multiagent_events.py",
        "discussion_id": "2395545258",
        "commented_code": "@@ -0,0 +1,55 @@\n+\"\"\"Multi-agent execution lifecycle events for hook system integration.\n+\n+These events are fired by orchestrators (Graph/Swarm) at key points so\n+hooks can persist, monitor, or debug execution. No intermediate state model\n+is used\u2014hooks read from the orchestrator directly.\n+\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import TYPE_CHECKING, Any\n+\n+from ...hooks.registry import BaseHookEvent\n+\n+if TYPE_CHECKING:\n+    from ...multiagent.base import MultiAgentBase\n+\n+\n+@dataclass\n+class MultiAgentInitializationEvent(BaseHookEvent):\n+    \"\"\"Event triggered when multi-agent orchestrator initializes.\n+\n+    Attributes:\n+        orchestrator: The multi-agent orchestrator instance\n+        invocation_state: Configuration that user pass in\n+    \"\"\"\n+\n+    orchestrator: \"MultiAgentBase\"",
        "comment_created_at": "2025-10-01T18:51:52+00:00",
        "comment_author": "Unshure",
        "comment_body": "nit: Can we just call this `base`? We may add other primitives in the future that may not be orchestrators",
        "pr_file_module": null
      },
      {
        "comment_id": "2402861341",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/experimental/multiagent_hooks/multiagent_events.py",
        "discussion_id": "2395545258",
        "commented_code": "@@ -0,0 +1,55 @@\n+\"\"\"Multi-agent execution lifecycle events for hook system integration.\n+\n+These events are fired by orchestrators (Graph/Swarm) at key points so\n+hooks can persist, monitor, or debug execution. No intermediate state model\n+is used\u2014hooks read from the orchestrator directly.\n+\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import TYPE_CHECKING, Any\n+\n+from ...hooks.registry import BaseHookEvent\n+\n+if TYPE_CHECKING:\n+    from ...multiagent.base import MultiAgentBase\n+\n+\n+@dataclass\n+class MultiAgentInitializationEvent(BaseHookEvent):\n+    \"\"\"Event triggered when multi-agent orchestrator initializes.\n+\n+    Attributes:\n+        orchestrator: The multi-agent orchestrator instance\n+        invocation_state: Configuration that user pass in\n+    \"\"\"\n+\n+    orchestrator: \"MultiAgentBase\"",
        "comment_created_at": "2025-10-03T18:02:59+00:00",
        "comment_author": "zastrowm",
        "comment_body": "`base` seems like an odd name - though I agree with the intent of the comment.\n\nMaybe `target` or `source`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2410855636",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/experimental/multiagent_hooks/multiagent_events.py",
        "discussion_id": "2395545258",
        "commented_code": "@@ -0,0 +1,55 @@\n+\"\"\"Multi-agent execution lifecycle events for hook system integration.\n+\n+These events are fired by orchestrators (Graph/Swarm) at key points so\n+hooks can persist, monitor, or debug execution. No intermediate state model\n+is used\u2014hooks read from the orchestrator directly.\n+\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import TYPE_CHECKING, Any\n+\n+from ...hooks.registry import BaseHookEvent\n+\n+if TYPE_CHECKING:\n+    from ...multiagent.base import MultiAgentBase\n+\n+\n+@dataclass\n+class MultiAgentInitializationEvent(BaseHookEvent):\n+    \"\"\"Event triggered when multi-agent orchestrator initializes.\n+\n+    Attributes:\n+        orchestrator: The multi-agent orchestrator instance\n+        invocation_state: Configuration that user pass in\n+    \"\"\"\n+\n+    orchestrator: \"MultiAgentBase\"",
        "comment_created_at": "2025-10-07T14:31:45+00:00",
        "comment_author": "JackYPCOnline",
        "comment_body": "using `source` now.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2445865658",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/graph.py",
    "created_at": "2025-10-20T19:05:43+00:00",
    "commented_code": "edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    # Persistence Helper Functions\n+\n+    def _from_dict(self, payload: dict[str, Any]) -> None:\n+        status_raw = payload.get(\"status\", \"pending\")\n+        self.state.status = Status(status_raw)\n+\n+        # Hydrate completed nodes & results\n+        raw_results = payload.get(\"node_results\") or {}\n+        results: dict[str, NodeResult] = {}\n+        for node_id, entry in raw_results.items():\n+            if node_id not in self.nodes:\n+                continue\n+            try:\n+                results[node_id] = NodeResult.from_dict(entry)\n+            except Exception:\n+                logger.exception(\"Failed to hydrate NodeResult for node_id=%s; skipping.\", node_id)\n+                raise\n+        self.state.results = results\n+\n+        # Restore completed nodes from persisted data\n+        completed_node_ids = payload.get(\"completed_nodes\") or []\n+        self.state.completed_nodes = {self.nodes[node_id] for node_id in completed_node_ids if node_id in self.nodes}\n+\n+        # Execution order (only nodes that still exist)\n+        order_node_ids = payload.get(\"execution_order\") or []\n+        self.state.execution_order = [self.nodes[node_id] for node_id in order_node_ids if node_id in self.nodes]\n+\n+        # Task\n+        self.state.task = payload.get(\"current_task\", self.state.task)\n+\n+    def _to_dict(self) -> dict[str, Any]:\n+        status_str = getattr(self.state.status, \"value\", str(self.state.status))\n+        next_nodes = [n.node_id for n in self._compute_ready_nodes_for_resume()]\n+        return {\n+            \"type\": \"graph\",\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"node_results\": {k: v.to_dict() for k, v in (self.state.results or {}).items()},\n+            \"next_node_to_execute\": next_nodes,",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2445865658",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/graph.py",
        "discussion_id": "2445865658",
        "commented_code": "@@ -736,3 +799,133 @@ def _build_result(self) -> GraphResult:\n             edges=self.state.edges,\n             entry_points=self.state.entry_points,\n         )\n+\n+    # Persistence Helper Functions\n+\n+    def _from_dict(self, payload: dict[str, Any]) -> None:\n+        status_raw = payload.get(\"status\", \"pending\")\n+        self.state.status = Status(status_raw)\n+\n+        # Hydrate completed nodes & results\n+        raw_results = payload.get(\"node_results\") or {}\n+        results: dict[str, NodeResult] = {}\n+        for node_id, entry in raw_results.items():\n+            if node_id not in self.nodes:\n+                continue\n+            try:\n+                results[node_id] = NodeResult.from_dict(entry)\n+            except Exception:\n+                logger.exception(\"Failed to hydrate NodeResult for node_id=%s; skipping.\", node_id)\n+                raise\n+        self.state.results = results\n+\n+        # Restore completed nodes from persisted data\n+        completed_node_ids = payload.get(\"completed_nodes\") or []\n+        self.state.completed_nodes = {self.nodes[node_id] for node_id in completed_node_ids if node_id in self.nodes}\n+\n+        # Execution order (only nodes that still exist)\n+        order_node_ids = payload.get(\"execution_order\") or []\n+        self.state.execution_order = [self.nodes[node_id] for node_id in order_node_ids if node_id in self.nodes]\n+\n+        # Task\n+        self.state.task = payload.get(\"current_task\", self.state.task)\n+\n+    def _to_dict(self) -> dict[str, Any]:\n+        status_str = getattr(self.state.status, \"value\", str(self.state.status))\n+        next_nodes = [n.node_id for n in self._compute_ready_nodes_for_resume()]\n+        return {\n+            \"type\": \"graph\",\n+            \"status\": status_str,\n+            \"completed_nodes\": [n.node_id for n in self.state.completed_nodes],\n+            \"node_results\": {k: v.to_dict() for k, v in (self.state.results or {}).items()},\n+            \"next_node_to_execute\": next_nodes,",
        "comment_created_at": "2025-10-20T19:05:43+00:00",
        "comment_author": "pgrayy",
        "comment_body": "For clarity, I would call this `next_nodes_to_execute` (plural).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2449530171",
    "pr_number": 900,
    "pr_file": "src/strands/multiagent/base.py",
    "created_at": "2025-10-21T19:47:00+00:00",
    "commented_code": "with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    def serialize_state(self) -> dict[str, Any]:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    def deserialize_state(self, payload: dict[str, Any]) -> None:",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2449530171",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 900,
        "pr_file": "src/strands/multiagent/base.py",
        "discussion_id": "2449530171",
        "commented_code": "@@ -122,3 +233,11 @@ def execute() -> MultiAgentResult:\n         with ThreadPoolExecutor() as executor:\n             future = executor.submit(execute)\n             return future.result()\n+\n+    def serialize_state(self) -> dict[str, Any]:\n+        \"\"\"Return a JSON-serializable snapshot of the orchestrator state.\"\"\"\n+        raise NotImplementedError\n+\n+    def deserialize_state(self, payload: dict[str, Any]) -> None:",
        "comment_created_at": "2025-10-21T19:47:00+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "I still don't see deserialize as being a mutative action. If this is actually doing\n>   \"\"\"Restore orchestrator state from a session dict and prepare for execution.\n\nwhy not call restore_from_state or session",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2417946041",
    "pr_number": 991,
    "pr_file": "src/strands/multiagent/function_node.py",
    "created_at": "2025-10-09T20:59:07+00:00",
    "commented_code": "+\"\"\"FunctionNode implementation for executing deterministic Python functions as graph nodes.\n+\n+This module provides the FunctionNode class that extends MultiAgentBase to execute\n+regular Python functions while maintaining compatibility with the existing graph\n+execution framework, proper error handling, metrics collection, and result formatting.\n+\"\"\"\n+\n+import logging\n+import time\n+from typing import Any, Callable, Union\n+\n+from opentelemetry import trace as trace_api\n+\n+from ..agent import AgentResult\n+from ..telemetry import get_tracer\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.content import ContentBlock, Message\n+from ..types.event_loop import Metrics, Usage\n+from .base import MultiAgentBase, MultiAgentResult, NodeResult, Status\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+FunctionNodeCallable = Callable[[Union[str, list[ContentBlock]], dict[str, Any] | None], str]\n+\n+\n+class FunctionNode(MultiAgentBase):\n+    \"\"\"Execute deterministic Python functions as graph nodes.\n+\n+    FunctionNode wraps any callable Python function and executes it within the\n+    established multiagent framework, handling input conversion, error management,\n+    metrics collection, and result formatting automatically.\n+\n+    Args:\n+        func: The callable function to wrap and execute\n+        name: Required name for the node\n+    \"\"\"\n+\n+    def __init__(self, func: FunctionNodeCallable, name: str):",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2417946041",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 991,
        "pr_file": "src/strands/multiagent/function_node.py",
        "discussion_id": "2417946041",
        "commented_code": "@@ -0,0 +1,142 @@\n+\"\"\"FunctionNode implementation for executing deterministic Python functions as graph nodes.\n+\n+This module provides the FunctionNode class that extends MultiAgentBase to execute\n+regular Python functions while maintaining compatibility with the existing graph\n+execution framework, proper error handling, metrics collection, and result formatting.\n+\"\"\"\n+\n+import logging\n+import time\n+from typing import Any, Callable, Union\n+\n+from opentelemetry import trace as trace_api\n+\n+from ..agent import AgentResult\n+from ..telemetry import get_tracer\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.content import ContentBlock, Message\n+from ..types.event_loop import Metrics, Usage\n+from .base import MultiAgentBase, MultiAgentResult, NodeResult, Status\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+FunctionNodeCallable = Callable[[Union[str, list[ContentBlock]], dict[str, Any] | None], str]\n+\n+\n+class FunctionNode(MultiAgentBase):\n+    \"\"\"Execute deterministic Python functions as graph nodes.\n+\n+    FunctionNode wraps any callable Python function and executes it within the\n+    established multiagent framework, handling input conversion, error management,\n+    metrics collection, and result formatting automatically.\n+\n+    Args:\n+        func: The callable function to wrap and execute\n+        name: Required name for the node\n+    \"\"\"\n+\n+    def __init__(self, func: FunctionNodeCallable, name: str):",
        "comment_created_at": "2025-10-09T20:59:07+00:00",
        "comment_author": "zastrowm",
        "comment_body": "semi-nit - do we have consensus elsewhere in the SDK or in python for the name of this argument - `func` vs `callable` vs `function`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2420626175",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 991,
        "pr_file": "src/strands/multiagent/function_node.py",
        "discussion_id": "2417946041",
        "commented_code": "@@ -0,0 +1,142 @@\n+\"\"\"FunctionNode implementation for executing deterministic Python functions as graph nodes.\n+\n+This module provides the FunctionNode class that extends MultiAgentBase to execute\n+regular Python functions while maintaining compatibility with the existing graph\n+execution framework, proper error handling, metrics collection, and result formatting.\n+\"\"\"\n+\n+import logging\n+import time\n+from typing import Any, Callable, Union\n+\n+from opentelemetry import trace as trace_api\n+\n+from ..agent import AgentResult\n+from ..telemetry import get_tracer\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.content import ContentBlock, Message\n+from ..types.event_loop import Metrics, Usage\n+from .base import MultiAgentBase, MultiAgentResult, NodeResult, Status\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+FunctionNodeCallable = Callable[[Union[str, list[ContentBlock]], dict[str, Any] | None], str]\n+\n+\n+class FunctionNode(MultiAgentBase):\n+    \"\"\"Execute deterministic Python functions as graph nodes.\n+\n+    FunctionNode wraps any callable Python function and executes it within the\n+    established multiagent framework, handling input conversion, error management,\n+    metrics collection, and result formatting automatically.\n+\n+    Args:\n+        func: The callable function to wrap and execute\n+        name: Required name for the node\n+    \"\"\"\n+\n+    def __init__(self, func: FunctionNodeCallable, name: str):",
        "comment_created_at": "2025-10-10T14:46:46+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "we use func in decorator we use transport_callable in mcp_client. So no",
        "pr_file_module": null
      },
      {
        "comment_id": "2420639079",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 991,
        "pr_file": "src/strands/multiagent/function_node.py",
        "discussion_id": "2417946041",
        "commented_code": "@@ -0,0 +1,142 @@\n+\"\"\"FunctionNode implementation for executing deterministic Python functions as graph nodes.\n+\n+This module provides the FunctionNode class that extends MultiAgentBase to execute\n+regular Python functions while maintaining compatibility with the existing graph\n+execution framework, proper error handling, metrics collection, and result formatting.\n+\"\"\"\n+\n+import logging\n+import time\n+from typing import Any, Callable, Union\n+\n+from opentelemetry import trace as trace_api\n+\n+from ..agent import AgentResult\n+from ..telemetry import get_tracer\n+from ..telemetry.metrics import EventLoopMetrics\n+from ..types.content import ContentBlock, Message\n+from ..types.event_loop import Metrics, Usage\n+from .base import MultiAgentBase, MultiAgentResult, NodeResult, Status\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+FunctionNodeCallable = Callable[[Union[str, list[ContentBlock]], dict[str, Any] | None], str]\n+\n+\n+class FunctionNode(MultiAgentBase):\n+    \"\"\"Execute deterministic Python functions as graph nodes.\n+\n+    FunctionNode wraps any callable Python function and executes it within the\n+    established multiagent framework, handling input conversion, error management,\n+    metrics collection, and result formatting automatically.\n+\n+    Args:\n+        func: The callable function to wrap and execute\n+        name: Required name for the node\n+    \"\"\"\n+\n+    def __init__(self, func: FunctionNodeCallable, name: str):",
        "comment_created_at": "2025-10-10T14:49:14+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "LLM guidance is though\n> In Python, the conventional way to name a Callable parameter is func or a descriptive name ending in _func or _callback. For example:\n\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2414121342",
    "pr_number": 895,
    "pr_file": "src/strands/tools/mcp/mcp_agent_tool.py",
    "created_at": "2025-10-08T14:47:59+00:00",
    "commented_code": "seamlessly within the agent framework.\n     \"\"\"\n \n-    def __init__(self, mcp_tool: MCPTool, mcp_client: \"MCPClient\") -> None:\n+    def __init__(self, mcp_tool: MCPTool, mcp_client: \"MCPClient\", agent_facing_tool_name: str | None = None) -> None:\n         \"\"\"Initialize a new MCPAgentTool instance.\n \n         Args:\n             mcp_tool: The MCP tool to adapt\n             mcp_client: The MCP server connection to use for tool invocation\n+            agent_facing_tool_name: Optional name to use for the agent tool (for disambiguation)",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2414121342",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 895,
        "pr_file": "src/strands/tools/mcp/mcp_agent_tool.py",
        "discussion_id": "2414121342",
        "commented_code": "@@ -28,26 +28,29 @@ class MCPAgentTool(AgentTool):\n     seamlessly within the agent framework.\n     \"\"\"\n \n-    def __init__(self, mcp_tool: MCPTool, mcp_client: \"MCPClient\") -> None:\n+    def __init__(self, mcp_tool: MCPTool, mcp_client: \"MCPClient\", agent_facing_tool_name: str | None = None) -> None:\n         \"\"\"Initialize a new MCPAgentTool instance.\n \n         Args:\n             mcp_tool: The MCP tool to adapt\n             mcp_client: The MCP server connection to use for tool invocation\n+            agent_facing_tool_name: Optional name to use for the agent tool (for disambiguation)",
        "comment_created_at": "2025-10-08T14:47:59+00:00",
        "comment_author": "zastrowm",
        "comment_body": "I'd suggest something less verbose - `name_override` or just `name` with documentation intending the purpose?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2400126568",
    "pr_number": 964,
    "pr_file": "src/strands/hooks/events.py",
    "created_at": "2025-10-02T21:32:50+00:00",
    "commented_code": "to change which tool gets executed. This may be None if tool lookup failed.\n         tool_use: The tool parameters that will be passed to selected_tool.\n         invocation_state: Keyword arguments that will be passed to the tool.\n+        cancel: A user defined message that when set, will cancel the tool call.\n+            The message will be placed into a tool result with an error status.\n     \"\"\"\n \n     selected_tool: Optional[AgentTool]\n     tool_use: ToolUse\n     invocation_state: dict[str, Any]\n+    cancel: Optional[str] = None",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2400126568",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 964,
        "pr_file": "src/strands/hooks/events.py",
        "discussion_id": "2400126568",
        "commented_code": "@@ -97,14 +97,17 @@ class BeforeToolCallEvent(HookEvent):\n             to change which tool gets executed. This may be None if tool lookup failed.\n         tool_use: The tool parameters that will be passed to selected_tool.\n         invocation_state: Keyword arguments that will be passed to the tool.\n+        cancel: A user defined message that when set, will cancel the tool call.\n+            The message will be placed into a tool result with an error status.\n     \"\"\"\n \n     selected_tool: Optional[AgentTool]\n     tool_use: ToolUse\n     invocation_state: dict[str, Any]\n+    cancel: Optional[str] = None",
        "comment_created_at": "2025-10-02T21:32:50+00:00",
        "comment_author": "Unshure",
        "comment_body": "nit: cancel_tool?\n```suggestion\n    cancel_tool: str | None = None\n```\n\nalso wondering if a flag or a function makes more sense here? Curious on your thoughts",
        "pr_file_module": null
      },
      {
        "comment_id": "2400167324",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 964,
        "pr_file": "src/strands/hooks/events.py",
        "discussion_id": "2400126568",
        "commented_code": "@@ -97,14 +97,17 @@ class BeforeToolCallEvent(HookEvent):\n             to change which tool gets executed. This may be None if tool lookup failed.\n         tool_use: The tool parameters that will be passed to selected_tool.\n         invocation_state: Keyword arguments that will be passed to the tool.\n+        cancel: A user defined message that when set, will cancel the tool call.\n+            The message will be placed into a tool result with an error status.\n     \"\"\"\n \n     selected_tool: Optional[AgentTool]\n     tool_use: ToolUse\n     invocation_state: dict[str, Any]\n+    cancel: Optional[str] = None",
        "comment_created_at": "2025-10-02T21:50:07+00:00",
        "comment_author": "pgrayy",
        "comment_body": "* Since this is a field within the context of BeforeToolCallEvent, I thought `cancel` as a name would be sufficient. No hard stance though. I could get behind `cancel_tool`.\r\n* I feel like a string is more appropriate over a flag since it can then be used as the message for the tool result.\r\n* I also feel like a string is more appropriate over a function since this is already being configured within a function (i.e., the customer defined hook). So in other words, if more complex logic is required in setting the field, it can be coded in the hook itself rather than a separate function.",
        "pr_file_module": null
      },
      {
        "comment_id": "2401902878",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 964,
        "pr_file": "src/strands/hooks/events.py",
        "discussion_id": "2400126568",
        "commented_code": "@@ -97,14 +97,17 @@ class BeforeToolCallEvent(HookEvent):\n             to change which tool gets executed. This may be None if tool lookup failed.\n         tool_use: The tool parameters that will be passed to selected_tool.\n         invocation_state: Keyword arguments that will be passed to the tool.\n+        cancel: A user defined message that when set, will cancel the tool call.\n+            The message will be placed into a tool result with an error status.\n     \"\"\"\n \n     selected_tool: Optional[AgentTool]\n     tool_use: ToolUse\n     invocation_state: dict[str, Any]\n+    cancel: Optional[str] = None",
        "comment_created_at": "2025-10-03T13:24:06+00:00",
        "comment_author": "Unshure",
        "comment_body": "The flag makes sense, but I still think a bool + string would be nice. Just a simple sensible default so I dont need to think about what a good cancel message for a tool is",
        "pr_file_module": null
      },
      {
        "comment_id": "2401933334",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 964,
        "pr_file": "src/strands/hooks/events.py",
        "discussion_id": "2400126568",
        "commented_code": "@@ -97,14 +97,17 @@ class BeforeToolCallEvent(HookEvent):\n             to change which tool gets executed. This may be None if tool lookup failed.\n         tool_use: The tool parameters that will be passed to selected_tool.\n         invocation_state: Keyword arguments that will be passed to the tool.\n+        cancel: A user defined message that when set, will cancel the tool call.\n+            The message will be placed into a tool result with an error status.\n     \"\"\"\n \n     selected_tool: Optional[AgentTool]\n     tool_use: ToolUse\n     invocation_state: dict[str, Any]\n+    cancel: Optional[str] = None",
        "comment_created_at": "2025-10-03T13:34:09+00:00",
        "comment_author": "pgrayy",
        "comment_body": "So are you suggesting I make the type `str | bool` and if the user sets `True`, we can configure a default message on their behalf? If so, I really like that idea.",
        "pr_file_module": null
      },
      {
        "comment_id": "2402404735",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 964,
        "pr_file": "src/strands/hooks/events.py",
        "discussion_id": "2400126568",
        "commented_code": "@@ -97,14 +97,17 @@ class BeforeToolCallEvent(HookEvent):\n             to change which tool gets executed. This may be None if tool lookup failed.\n         tool_use: The tool parameters that will be passed to selected_tool.\n         invocation_state: Keyword arguments that will be passed to the tool.\n+        cancel: A user defined message that when set, will cancel the tool call.\n+            The message will be placed into a tool result with an error status.\n     \"\"\"\n \n     selected_tool: Optional[AgentTool]\n     tool_use: ToolUse\n     invocation_state: dict[str, Any]\n+    cancel: Optional[str] = None",
        "comment_created_at": "2025-10-03T15:34:52+00:00",
        "comment_author": "pgrayy",
        "comment_body": "See latest revision.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2391659661",
    "pr_number": 943,
    "pr_file": "src/strands/agent/agent.py",
    "created_at": "2025-09-30T14:07:43+00:00",
    "commented_code": "messages: Optional[Messages] = None,\n         tools: Optional[list[Union[str, dict[str, str], Any]]] = None,\n         system_prompt: Optional[str] = None,\n+        structured_output_type: Optional[Type[BaseModel]] = None,",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2391659661",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/agent/agent.py",
        "discussion_id": "2391659661",
        "commented_code": "@@ -210,6 +213,7 @@ def __init__(\n         messages: Optional[Messages] = None,\n         tools: Optional[list[Union[str, dict[str, str], Any]]] = None,\n         system_prompt: Optional[str] = None,\n+        structured_output_type: Optional[Type[BaseModel]] = None,",
        "comment_created_at": "2025-09-30T14:07:43+00:00",
        "comment_author": "zastrowm",
        "comment_body": "```suggestion\n        structured_output_type: Type[BaseModel] | None = None,\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2391663586",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/agent/agent.py",
        "discussion_id": "2391659661",
        "commented_code": "@@ -210,6 +213,7 @@ def __init__(\n         messages: Optional[Messages] = None,\n         tools: Optional[list[Union[str, dict[str, str], Any]]] = None,\n         system_prompt: Optional[str] = None,\n+        structured_output_type: Optional[Type[BaseModel]] = None,",
        "comment_created_at": "2025-09-30T14:08:38+00:00",
        "comment_author": "zastrowm",
        "comment_body": "We should api-bar raise the naming.\n\nI'm thinking `output_type` makes more sense - not sure we need the `structured` part",
        "pr_file_module": null
      },
      {
        "comment_id": "2392838840",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/agent/agent.py",
        "discussion_id": "2391659661",
        "commented_code": "@@ -210,6 +213,7 @@ def __init__(\n         messages: Optional[Messages] = None,\n         tools: Optional[list[Union[str, dict[str, str], Any]]] = None,\n         system_prompt: Optional[str] = None,\n+        structured_output_type: Optional[Type[BaseModel]] = None,",
        "comment_created_at": "2025-09-30T21:08:08+00:00",
        "comment_author": "afarntrog",
        "comment_body": "agreed. The team thought it should `structured_output_type` but as discussed that sounds overly verbose. Are we aligned with `output_schema`? @zastrowm @Unshure ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2392801041",
    "pr_number": 943,
    "pr_file": "src/strands/output/utils.py",
    "created_at": "2025-09-30T20:48:53+00:00",
    "commented_code": null,
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2392801041",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/output/utils.py",
        "discussion_id": "2392801041",
        "commented_code": null,
        "comment_created_at": "2025-09-30T20:48:53+00:00",
        "comment_author": "Unshure",
        "comment_body": "lets try not to name files or directories `utils`. Can we come up with a more specific name for what this does?",
        "pr_file_module": null
      },
      {
        "comment_id": "2394652234",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/output/utils.py",
        "discussion_id": "2392801041",
        "commented_code": null,
        "comment_created_at": "2025-10-01T13:46:38+00:00",
        "comment_author": "afarntrog",
        "comment_body": "gotcha. what's the aversion to naming it `utils` is it because it's too generic? Because in this case I'm kinda using the path to imply it's utility `output.utils`",
        "pr_file_module": null
      },
      {
        "comment_id": "2395343129",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/output/utils.py",
        "discussion_id": "2392801041",
        "commented_code": null,
        "comment_created_at": "2025-10-01T17:34:43+00:00",
        "comment_author": "zastrowm",
        "comment_body": "utils end up being dumping grounds for unrelated functionality, so it's effectively banned; it usually makes sense in a better name module/file.  In this case, I think this could live in OutputSchema",
        "pr_file_module": null
      },
      {
        "comment_id": "2395613363",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/output/utils.py",
        "discussion_id": "2392801041",
        "commented_code": null,
        "comment_created_at": "2025-10-01T19:12:23+00:00",
        "comment_author": "afarntrog",
        "comment_body": "makes sense!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2392802972",
    "pr_number": 943,
    "pr_file": "src/strands/tools/structured_output/structured_output_utils.py",
    "created_at": "2025-09-30T20:49:59+00:00",
    "commented_code": null,
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2392802972",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/tools/structured_output/structured_output_utils.py",
        "discussion_id": "2392802972",
        "commented_code": null,
        "comment_created_at": "2025-09-30T20:49:59+00:00",
        "comment_author": "Unshure",
        "comment_body": "nit: dont name directories or files `utils`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2421398429",
    "pr_number": 943,
    "pr_file": "src/strands/tools/structured_output/_structured_output_context.py",
    "created_at": "2025-10-10T17:38:41+00:00",
    "commented_code": null,
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2421398429",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/tools/structured_output/_structured_output_context.py",
        "discussion_id": "2421398429",
        "commented_code": null,
        "comment_created_at": "2025-10-10T17:38:41+00:00",
        "comment_author": "zastrowm",
        "comment_body": "Rename this to have a _ in the beginning of the file name - let's keep this an internal implementation detail ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2452661369",
    "pr_number": 943,
    "pr_file": "src/strands/tools/_tool_helpers.py",
    "created_at": "2025-10-22T16:27:56+00:00",
    "commented_code": "+\"\"\"Helpers for tools.\"\"\"",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2452661369",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/tools/_tool_helpers.py",
        "discussion_id": "2452661369",
        "commented_code": "@@ -0,0 +1,15 @@\n+\"\"\"Helpers for tools.\"\"\"",
        "comment_created_at": "2025-10-22T16:27:56+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "nit: why a different pattern than just \n\ntools/_tool_helpers.py\n\n\nthen you don't need\n\n@tool(name=\"noop\", \n",
        "pr_file_module": null
      },
      {
        "comment_id": "2452868799",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 943,
        "pr_file": "src/strands/tools/_tool_helpers.py",
        "discussion_id": "2452661369",
        "commented_code": "@@ -0,0 +1,15 @@\n+\"\"\"Helpers for tools.\"\"\"",
        "comment_created_at": "2025-10-22T17:50:29+00:00",
        "comment_author": "afarntrog",
        "comment_body": "good point. that is cleaner",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2273403178",
    "pr_number": 658,
    "pr_file": "src/strands/tools/executors/concurrent.py",
    "created_at": "2025-08-13T13:03:41+00:00",
    "commented_code": "+\"\"\"Concurrent tool executor implementation.\"\"\"\n+\n+import asyncio\n+from typing import TYPE_CHECKING, Any\n+\n+from typing_extensions import override\n+\n+from ...experimental.tools.executors import Executor as SAExecutor\n+from ...types.tools import ToolGenerator, ToolResult, ToolUse\n+\n+if TYPE_CHECKING:  # pragma: no cover\n+    from ...agent import Agent\n+\n+\n+class Executor(SAExecutor):",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2273403178",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 658,
        "pr_file": "src/strands/tools/executors/concurrent.py",
        "discussion_id": "2273403178",
        "commented_code": "@@ -0,0 +1,95 @@\n+\"\"\"Concurrent tool executor implementation.\"\"\"\n+\n+import asyncio\n+from typing import TYPE_CHECKING, Any\n+\n+from typing_extensions import override\n+\n+from ...experimental.tools.executors import Executor as SAExecutor\n+from ...types.tools import ToolGenerator, ToolResult, ToolUse\n+\n+if TYPE_CHECKING:  # pragma: no cover\n+    from ...agent import Agent\n+\n+\n+class Executor(SAExecutor):",
        "comment_created_at": "2025-08-13T13:03:41+00:00",
        "comment_author": "zastrowm",
        "comment_body": "Why not name it ConcurrentExecutor? and exporter it from __init__?",
        "pr_file_module": null
      },
      {
        "comment_id": "2288229632",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 658,
        "pr_file": "src/strands/tools/executors/concurrent.py",
        "discussion_id": "2273403178",
        "commented_code": "@@ -0,0 +1,95 @@\n+\"\"\"Concurrent tool executor implementation.\"\"\"\n+\n+import asyncio\n+from typing import TYPE_CHECKING, Any\n+\n+from typing_extensions import override\n+\n+from ...experimental.tools.executors import Executor as SAExecutor\n+from ...types.tools import ToolGenerator, ToolResult, ToolUse\n+\n+if TYPE_CHECKING:  # pragma: no cover\n+    from ...agent import Agent\n+\n+\n+class Executor(SAExecutor):",
        "comment_created_at": "2025-08-20T13:46:40+00:00",
        "comment_author": "pgrayy",
        "comment_body": "This is a convention I like to follow. We are in the context of `tools/executors/concurrent.py` and so `ConcurrentExecutor` would be a redundant name. I have no hard stance though. If you prefer something like `ConcurrentExecutor` I could switch.",
        "pr_file_module": null
      },
      {
        "comment_id": "2289384911",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 658,
        "pr_file": "src/strands/tools/executors/concurrent.py",
        "discussion_id": "2273403178",
        "commented_code": "@@ -0,0 +1,95 @@\n+\"\"\"Concurrent tool executor implementation.\"\"\"\n+\n+import asyncio\n+from typing import TYPE_CHECKING, Any\n+\n+from typing_extensions import override\n+\n+from ...experimental.tools.executors import Executor as SAExecutor\n+from ...types.tools import ToolGenerator, ToolResult, ToolUse\n+\n+if TYPE_CHECKING:  # pragma: no cover\n+    from ...agent import Agent\n+\n+\n+class Executor(SAExecutor):",
        "comment_created_at": "2025-08-20T21:53:18+00:00",
        "comment_author": "zastrowm",
        "comment_body": "I think we should make a call on this as a team - I'm a big fan of \"Only one typed named X in the codebase\"  to make it easy to see what's going on verses requiring aliases on imports",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2273609245",
    "pr_number": 658,
    "pr_file": "src/strands/tools/executors/sequential.py",
    "created_at": "2025-08-13T14:13:18+00:00",
    "commented_code": "+\"\"\"Sequential tool executor implementation.\"\"\"\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from typing_extensions import override\n+\n+from ...experimental.tools.executors import Executor as SAExecutor\n+from ...types.tools import ToolGenerator, ToolResult, ToolUse\n+\n+if TYPE_CHECKING:  # pragma: no cover\n+    from ...agent import Agent\n+\n+\n+class Executor(SAExecutor):",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2273609245",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 658,
        "pr_file": "src/strands/tools/executors/sequential.py",
        "discussion_id": "2273609245",
        "commented_code": "@@ -0,0 +1,34 @@\n+\"\"\"Sequential tool executor implementation.\"\"\"\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from typing_extensions import override\n+\n+from ...experimental.tools.executors import Executor as SAExecutor\n+from ...types.tools import ToolGenerator, ToolResult, ToolUse\n+\n+if TYPE_CHECKING:  # pragma: no cover\n+    from ...agent import Agent\n+\n+\n+class Executor(SAExecutor):",
        "comment_created_at": "2025-08-13T14:13:18+00:00",
        "comment_author": "dbschmigelski",
        "comment_body": "Similar to @zastrowm s comment, I think I prefer naming of SequentialExecutor , and ConcurrentExecutor. I might even push for ToolExecutor to be as clear as possible",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180069011",
    "pr_number": 302,
    "pr_file": "src/strands/session/agent_session_manager.py",
    "created_at": "2025-07-02T13:27:12+00:00",
    "commented_code": "+\"\"\"File-based implementation of session manager.\"\"\"\n+\n+import logging\n+from typing import TYPE_CHECKING, Any, Optional\n+\n+from ..agent.state import AgentState\n+from ..handlers.callback_handler import CompositeCallbackHandler\n+from ..types.content import Message\n+from .exceptions import SessionException\n+from .file_session_dao import FileSessionDAO\n+from .session_dao import SessionDAO\n+from .session_manager import SessionManager\n+from .session_models import Session, SessionAgent, SessionMessage, SessionType\n+\n+logger = logging.getLogger(__name__)\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class AgentSessionManager(SessionManager):",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2180069011",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/session/agent_session_manager.py",
        "discussion_id": "2180069011",
        "commented_code": "@@ -0,0 +1,117 @@\n+\"\"\"File-based implementation of session manager.\"\"\"\n+\n+import logging\n+from typing import TYPE_CHECKING, Any, Optional\n+\n+from ..agent.state import AgentState\n+from ..handlers.callback_handler import CompositeCallbackHandler\n+from ..types.content import Message\n+from .exceptions import SessionException\n+from .file_session_dao import FileSessionDAO\n+from .session_dao import SessionDAO\n+from .session_manager import SessionManager\n+from .session_models import Session, SessionAgent, SessionMessage, SessionType\n+\n+logger = logging.getLogger(__name__)\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class AgentSessionManager(SessionManager):",
        "comment_created_at": "2025-07-02T13:27:12+00:00",
        "comment_author": "zastrowm",
        "comment_body": "This name seems so abstract IMHO.  I feel like this should be `FileSessionManager` or something that indicates that it's file based",
        "pr_file_module": null
      },
      {
        "comment_id": "2180980312",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/session/agent_session_manager.py",
        "discussion_id": "2180069011",
        "commented_code": "@@ -0,0 +1,117 @@\n+\"\"\"File-based implementation of session manager.\"\"\"\n+\n+import logging\n+from typing import TYPE_CHECKING, Any, Optional\n+\n+from ..agent.state import AgentState\n+from ..handlers.callback_handler import CompositeCallbackHandler\n+from ..types.content import Message\n+from .exceptions import SessionException\n+from .file_session_dao import FileSessionDAO\n+from .session_dao import SessionDAO\n+from .session_manager import SessionManager\n+from .session_models import Session, SessionAgent, SessionMessage, SessionType\n+\n+logger = logging.getLogger(__name__)\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class AgentSessionManager(SessionManager):",
        "comment_created_at": "2025-07-02T21:11:58+00:00",
        "comment_author": "Unshure",
        "comment_body": "I wanted this to represent a single agent session manager. Since we eventually want to support multi-agent session managers, I figured we might have a `GraphSessionManager` or `SwarmSessionManager` in the future as well. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2195716492",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/session/agent_session_manager.py",
        "discussion_id": "2180069011",
        "commented_code": "@@ -0,0 +1,117 @@\n+\"\"\"File-based implementation of session manager.\"\"\"\n+\n+import logging\n+from typing import TYPE_CHECKING, Any, Optional\n+\n+from ..agent.state import AgentState\n+from ..handlers.callback_handler import CompositeCallbackHandler\n+from ..types.content import Message\n+from .exceptions import SessionException\n+from .file_session_dao import FileSessionDAO\n+from .session_dao import SessionDAO\n+from .session_manager import SessionManager\n+from .session_models import Session, SessionAgent, SessionMessage, SessionType\n+\n+logger = logging.getLogger(__name__)\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class AgentSessionManager(SessionManager):",
        "comment_created_at": "2025-07-09T18:29:01+00:00",
        "comment_author": "jer96",
        "comment_body": "i agree with @zastrowm here, this class is heavily opinionated (per the docstrings) about how it saves sessions. 1. as JSON files 2. on disk ",
        "pr_file_module": null
      },
      {
        "comment_id": "2196173168",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/session/agent_session_manager.py",
        "discussion_id": "2180069011",
        "commented_code": "@@ -0,0 +1,117 @@\n+\"\"\"File-based implementation of session manager.\"\"\"\n+\n+import logging\n+from typing import TYPE_CHECKING, Any, Optional\n+\n+from ..agent.state import AgentState\n+from ..handlers.callback_handler import CompositeCallbackHandler\n+from ..types.content import Message\n+from .exceptions import SessionException\n+from .file_session_dao import FileSessionDAO\n+from .session_dao import SessionDAO\n+from .session_manager import SessionManager\n+from .session_models import Session, SessionAgent, SessionMessage, SessionType\n+\n+logger = logging.getLogger(__name__)\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class AgentSessionManager(SessionManager):",
        "comment_created_at": "2025-07-09T23:18:21+00:00",
        "comment_author": "Unshure",
        "comment_body": "Need to update the docstring here, its not meant to be that opinionated. It just needs some persistence implementation that supports storing agents and messages in a session.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180075968",
    "pr_number": 302,
    "pr_file": "src/strands/session/session_manager.py",
    "created_at": "2025-07-02T13:30:18+00:00",
    "commented_code": "+\"\"\"Session manager interface for agent session management.\"\"\"\n+\n+from abc import ABC, abstractmethod\n+from typing import TYPE_CHECKING\n+\n+from ..types.content import Message\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class SessionManager(ABC):\n+    \"\"\"Abstract interface for managing agent sessions.\n+\n+    A session represents a complete interaction context including conversation\n+    history, user information, agent state, and metadata. This interface provides\n+    methods to manage sessions and their associated data.\n+    \"\"\"\n+\n+    @abstractmethod\n+    def append_message_to_agent_session(self, agent: \"Agent\", message: Message) -> None:",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2180075968",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/session/session_manager.py",
        "discussion_id": "2180075968",
        "commented_code": "@@ -0,0 +1,46 @@\n+\"\"\"Session manager interface for agent session management.\"\"\"\n+\n+from abc import ABC, abstractmethod\n+from typing import TYPE_CHECKING\n+\n+from ..types.content import Message\n+\n+if TYPE_CHECKING:\n+    from ..agent.agent import Agent\n+\n+\n+class SessionManager(ABC):\n+    \"\"\"Abstract interface for managing agent sessions.\n+\n+    A session represents a complete interaction context including conversation\n+    history, user information, agent state, and metadata. This interface provides\n+    methods to manage sessions and their associated data.\n+    \"\"\"\n+\n+    @abstractmethod\n+    def append_message_to_agent_session(self, agent: \"Agent\", message: Message) -> None:",
        "comment_created_at": "2025-07-02T13:30:18+00:00",
        "comment_author": "zastrowm",
        "comment_body": "This seems verbose compared to many of our apis is there a need to specify `agent_session` here?\r\n\r\nI'd suggest `append_message`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203052326",
    "pr_number": 302,
    "pr_file": "src/strands/types/session.py",
    "created_at": "2025-07-13T02:16:24+00:00",
    "commented_code": "+\"\"\"Data models for session management.\"\"\"\n+\n+import base64\n+import inspect\n+from dataclasses import dataclass, field\n+from datetime import datetime, timezone\n+from enum import Enum\n+from typing import Any, Dict, cast\n+from uuid import uuid4\n+\n+from ..agent.agent import Agent\n+from .content import Message\n+\n+\n+class SessionType(str, Enum):\n+    \"\"\"Enumeration of session types.\"\"\"\n+\n+    AGENT = \"AGENT\"\n+\n+\n+def encode_bytes_values(obj: Any) -> Any:\n+    \"\"\"Recursively encode any bytes values in an object to base64.\n+\n+    Handles dictionaries, lists, and nested structures.\n+    \"\"\"\n+    if isinstance(obj, bytes):\n+        return {\"__bytes_encoded__\": True, \"data\": base64.b64encode(obj).decode()}\n+    elif isinstance(obj, dict):\n+        return {k: encode_bytes_values(v) for k, v in obj.items()}\n+    elif isinstance(obj, list):\n+        return [encode_bytes_values(item) for item in obj]\n+    else:\n+        return obj\n+\n+\n+def decode_bytes_values(obj: Any) -> Any:\n+    \"\"\"Recursively decode any base64-encoded bytes values in an object.\n+\n+    Handles dictionaries, lists, and nested structures.\n+    \"\"\"\n+    if isinstance(obj, dict):\n+        if obj.get(\"__bytes_encoded__\") is True and \"data\" in obj:\n+            return base64.b64decode(obj[\"data\"])\n+        return {k: decode_bytes_values(v) for k, v in obj.items()}\n+    elif isinstance(obj, list):\n+        return [decode_bytes_values(item) for item in obj]\n+    else:\n+        return obj\n+\n+\n+@dataclass\n+class SessionMessage:\n+    \"\"\"Message within a SessionAgent.\"\"\"\n+\n+    message: Message\n+    message_id: str = field(default_factory=lambda: str(uuid4()))\n+    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n+    updated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n+\n+    @classmethod\n+    def from_message(cls, message: Message) -> \"SessionMessage\":\n+        \"\"\"Convert from a Message, base64 encoding bytes values.\"\"\"\n+        bytes_encoded_dict = encode_bytes_values(message)\n+        return cls(\n+            message=bytes_encoded_dict,\n+            message_id=str(uuid4()),\n+            created_at=datetime.now(timezone.utc).isoformat(),\n+            updated_at=datetime.now(timezone.utc).isoformat(),\n+        )\n+\n+    def to_message(self) -> Message:\n+        \"\"\"Convert SessionMessage back to a Message, decoding any bytes values.\"\"\"\n+        return cast(Message, decode_bytes_values(self.message))\n+\n+    @classmethod\n+    def from_dict(cls, env: dict[str, Any]) -> \"SessionMessage\":\n+        \"\"\"Initialize a SessionMessage from a dictionary, ignoring keys that are not calss parameters.\"\"\"\n+        return cls(**{k: v for k, v in env.items() if k in inspect.signature(cls).parameters})\n+\n+\n+@dataclass\n+class SessionAgent:",
    "repo_full_name": "strands-agents/sdk-python",
    "discussion_comments": [
      {
        "comment_id": "2203052326",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/types/session.py",
        "discussion_id": "2203052326",
        "commented_code": "@@ -0,0 +1,118 @@\n+\"\"\"Data models for session management.\"\"\"\n+\n+import base64\n+import inspect\n+from dataclasses import dataclass, field\n+from datetime import datetime, timezone\n+from enum import Enum\n+from typing import Any, Dict, cast\n+from uuid import uuid4\n+\n+from ..agent.agent import Agent\n+from .content import Message\n+\n+\n+class SessionType(str, Enum):\n+    \"\"\"Enumeration of session types.\"\"\"\n+\n+    AGENT = \"AGENT\"\n+\n+\n+def encode_bytes_values(obj: Any) -> Any:\n+    \"\"\"Recursively encode any bytes values in an object to base64.\n+\n+    Handles dictionaries, lists, and nested structures.\n+    \"\"\"\n+    if isinstance(obj, bytes):\n+        return {\"__bytes_encoded__\": True, \"data\": base64.b64encode(obj).decode()}\n+    elif isinstance(obj, dict):\n+        return {k: encode_bytes_values(v) for k, v in obj.items()}\n+    elif isinstance(obj, list):\n+        return [encode_bytes_values(item) for item in obj]\n+    else:\n+        return obj\n+\n+\n+def decode_bytes_values(obj: Any) -> Any:\n+    \"\"\"Recursively decode any base64-encoded bytes values in an object.\n+\n+    Handles dictionaries, lists, and nested structures.\n+    \"\"\"\n+    if isinstance(obj, dict):\n+        if obj.get(\"__bytes_encoded__\") is True and \"data\" in obj:\n+            return base64.b64decode(obj[\"data\"])\n+        return {k: decode_bytes_values(v) for k, v in obj.items()}\n+    elif isinstance(obj, list):\n+        return [decode_bytes_values(item) for item in obj]\n+    else:\n+        return obj\n+\n+\n+@dataclass\n+class SessionMessage:\n+    \"\"\"Message within a SessionAgent.\"\"\"\n+\n+    message: Message\n+    message_id: str = field(default_factory=lambda: str(uuid4()))\n+    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n+    updated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n+\n+    @classmethod\n+    def from_message(cls, message: Message) -> \"SessionMessage\":\n+        \"\"\"Convert from a Message, base64 encoding bytes values.\"\"\"\n+        bytes_encoded_dict = encode_bytes_values(message)\n+        return cls(\n+            message=bytes_encoded_dict,\n+            message_id=str(uuid4()),\n+            created_at=datetime.now(timezone.utc).isoformat(),\n+            updated_at=datetime.now(timezone.utc).isoformat(),\n+        )\n+\n+    def to_message(self) -> Message:\n+        \"\"\"Convert SessionMessage back to a Message, decoding any bytes values.\"\"\"\n+        return cast(Message, decode_bytes_values(self.message))\n+\n+    @classmethod\n+    def from_dict(cls, env: dict[str, Any]) -> \"SessionMessage\":\n+        \"\"\"Initialize a SessionMessage from a dictionary, ignoring keys that are not calss parameters.\"\"\"\n+        return cls(**{k: v for k, v in env.items() if k in inspect.signature(cls).parameters})\n+\n+\n+@dataclass\n+class SessionAgent:",
        "comment_created_at": "2025-07-13T02:16:24+00:00",
        "comment_author": "zastrowm",
        "comment_body": "After reading through some of the code, `AgentSession` *might* read more clearly?  \r\n\r\nI go back and forth on it. SessionMessage makes sense to me. However, when I read SessionAgent I think of an agent that specialized is Sessions whereas AgentSession is more clearly a session that belongs to an agent.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203436609",
        "repo_full_name": "strands-agents/sdk-python",
        "pr_number": 302,
        "pr_file": "src/strands/types/session.py",
        "discussion_id": "2203052326",
        "commented_code": "@@ -0,0 +1,118 @@\n+\"\"\"Data models for session management.\"\"\"\n+\n+import base64\n+import inspect\n+from dataclasses import dataclass, field\n+from datetime import datetime, timezone\n+from enum import Enum\n+from typing import Any, Dict, cast\n+from uuid import uuid4\n+\n+from ..agent.agent import Agent\n+from .content import Message\n+\n+\n+class SessionType(str, Enum):\n+    \"\"\"Enumeration of session types.\"\"\"\n+\n+    AGENT = \"AGENT\"\n+\n+\n+def encode_bytes_values(obj: Any) -> Any:\n+    \"\"\"Recursively encode any bytes values in an object to base64.\n+\n+    Handles dictionaries, lists, and nested structures.\n+    \"\"\"\n+    if isinstance(obj, bytes):\n+        return {\"__bytes_encoded__\": True, \"data\": base64.b64encode(obj).decode()}\n+    elif isinstance(obj, dict):\n+        return {k: encode_bytes_values(v) for k, v in obj.items()}\n+    elif isinstance(obj, list):\n+        return [encode_bytes_values(item) for item in obj]\n+    else:\n+        return obj\n+\n+\n+def decode_bytes_values(obj: Any) -> Any:\n+    \"\"\"Recursively decode any base64-encoded bytes values in an object.\n+\n+    Handles dictionaries, lists, and nested structures.\n+    \"\"\"\n+    if isinstance(obj, dict):\n+        if obj.get(\"__bytes_encoded__\") is True and \"data\" in obj:\n+            return base64.b64decode(obj[\"data\"])\n+        return {k: decode_bytes_values(v) for k, v in obj.items()}\n+    elif isinstance(obj, list):\n+        return [decode_bytes_values(item) for item in obj]\n+    else:\n+        return obj\n+\n+\n+@dataclass\n+class SessionMessage:\n+    \"\"\"Message within a SessionAgent.\"\"\"\n+\n+    message: Message\n+    message_id: str = field(default_factory=lambda: str(uuid4()))\n+    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n+    updated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())\n+\n+    @classmethod\n+    def from_message(cls, message: Message) -> \"SessionMessage\":\n+        \"\"\"Convert from a Message, base64 encoding bytes values.\"\"\"\n+        bytes_encoded_dict = encode_bytes_values(message)\n+        return cls(\n+            message=bytes_encoded_dict,\n+            message_id=str(uuid4()),\n+            created_at=datetime.now(timezone.utc).isoformat(),\n+            updated_at=datetime.now(timezone.utc).isoformat(),\n+        )\n+\n+    def to_message(self) -> Message:\n+        \"\"\"Convert SessionMessage back to a Message, decoding any bytes values.\"\"\"\n+        return cast(Message, decode_bytes_values(self.message))\n+\n+    @classmethod\n+    def from_dict(cls, env: dict[str, Any]) -> \"SessionMessage\":\n+        \"\"\"Initialize a SessionMessage from a dictionary, ignoring keys that are not calss parameters.\"\"\"\n+        return cls(**{k: v for k, v in env.items() if k in inspect.signature(cls).parameters})\n+\n+\n+@dataclass\n+class SessionAgent:",
        "comment_created_at": "2025-07-13T16:03:43+00:00",
        "comment_author": "Unshure",
        "comment_body": "When thinking of the datamodel, sessions dont belong to agents, and agent belongs to a session. I can try to make this more clear by updating the docstring, but I would like to keep `SessionAgent`",
        "pr_file_module": null
      }
    ]
  }
]