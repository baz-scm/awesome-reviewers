[
  {
    "discussion_id": "1326859909",
    "pr_number": 8690,
    "pr_file": "src/analyzing/CFG_build.ml",
    "created_at": "2023-09-15T06:34:03+00:00",
    "commented_code": "| Return (tok, e) ->\n       let newi = state.g#add_node { F.n = F.NReturn (tok, e) } in\n       state.g |> add_arc_from_opt (previ, newi);\n-      state.g |> add_arc (newi, state.exiti);\n+      state.g |> add_arc (newi, state.return_destination);\n+      state.may_return := true;\n       CfgFirstLast (newi, None)\n-  | Try (try_st, catches, finally_st) ->\n+  | Try (try_st, catches, else_st, finally_st) ->",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1326859909",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "src/analyzing/CFG_build.ml",
        "discussion_id": "1326859909",
        "commented_code": "@@ -240,41 +247,91 @@ let rec cfg_stmt : state -> F.nodei option -> stmt -> cfg_stmt_result =\n   | Return (tok, e) ->\n       let newi = state.g#add_node { F.n = F.NReturn (tok, e) } in\n       state.g |> add_arc_from_opt (previ, newi);\n-      state.g |> add_arc (newi, state.exiti);\n+      state.g |> add_arc (newi, state.return_destination);\n+      state.may_return := true;\n       CfgFirstLast (newi, None)\n-  | Try (try_st, catches, finally_st) ->\n+  | Try (try_st, catches, else_st, finally_st) ->",
        "comment_created_at": "2023-09-15T06:34:03+00:00",
        "comment_author": "ihji",
        "comment_body": "This change doesn't seem to be straightforward. It looks like we'll need thorough testing to ensure the new logic works correctly. Do we currently have a unit test for the CFG building code?",
        "pr_file_module": null
      },
      {
        "comment_id": "1327086169",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "src/analyzing/CFG_build.ml",
        "discussion_id": "1326859909",
        "commented_code": "@@ -240,41 +247,91 @@ let rec cfg_stmt : state -> F.nodei option -> stmt -> cfg_stmt_result =\n   | Return (tok, e) ->\n       let newi = state.g#add_node { F.n = F.NReturn (tok, e) } in\n       state.g |> add_arc_from_opt (previ, newi);\n-      state.g |> add_arc (newi, state.exiti);\n+      state.g |> add_arc (newi, state.return_destination);\n+      state.may_return := true;\n       CfgFirstLast (newi, None)\n-  | Try (try_st, catches, finally_st) ->\n+  | Try (try_st, catches, else_st, finally_st) ->",
        "comment_created_at": "2023-09-15T10:06:43+00:00",
        "comment_author": "aryx",
        "comment_body": "We don't have unit tests for that I think. The test plan is usually \"run -cfg_il and looks like it's ok\".\r\nMaybe we should start some test infra there (in a separate PR). Not super easy though to specify some tests and asserts that are readable.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1327479187",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "src/analyzing/CFG_build.ml",
        "discussion_id": "1326859909",
        "commented_code": "@@ -240,41 +247,91 @@ let rec cfg_stmt : state -> F.nodei option -> stmt -> cfg_stmt_result =\n   | Return (tok, e) ->\n       let newi = state.g#add_node { F.n = F.NReturn (tok, e) } in\n       state.g |> add_arc_from_opt (previ, newi);\n-      state.g |> add_arc (newi, state.exiti);\n+      state.g |> add_arc (newi, state.return_destination);\n+      state.may_return := true;\n       CfgFirstLast (newi, None)\n-  | Try (try_st, catches, finally_st) ->\n+  | Try (try_st, catches, else_st, finally_st) ->",
        "comment_created_at": "2023-09-15T15:41:37+00:00",
        "comment_author": "amchiclet",
        "comment_body": "Currently, some of the tainting and constant propagation unit tests rely on the correctness of the CFG.\r\n\r\nI'm currently writing some more unit tests that exercise these new arcs. Once I have those, I'll update this PR again, and I think it will be ready for review.\r\n\r\nIf a separate infra is useful, then that would be in a separate PR.\r\n\r\nThanks for all of your early feedback!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1544907557",
    "pr_number": 9945,
    "pr_file": "src/osemgrep/language_server/custom_requests/Search.ml",
    "created_at": "2024-03-29T22:03:59+00:00",
    "commented_code": "(* Information gathering *)\n (*****************************************************************************)\n \n-let mk_env (server : RPC_server.t) params =\n+let mk_env (server : RPC_server.t) (params : Request_params.t) =\n   let scanning_roots =\n     List_.map Scanning_root.of_fpath server.session.workspace_folders\n   in\n   let files =\n     server.session.cached_workspace_targets |> Hashtbl.to_seq_values\n     |> List.of_seq |> List.concat\n   in\n+  let project_root =\n+    match\n+      List.nth scanning_roots 0 |> Scanning_root.to_fpath |> Rfpath.of_fpath\n+    with\n+    | Error _ -> failwith \"somehow unable to get project root from first root\"\n+    | Ok rfpath -> rfpath\n+  in\n   (* Filter all files by gitignores *)\n   let filtered_files =\n     (* Gitignore code. We hard-code it to be false for now.\n        This adds 10s to startup time in `semgrep-app` on my machine.\n        Gitignore is expensive! I don't know why.\n     *)\n-    if false then filter_by_gitignore files scanning_roots else files\n+    if false then filter_by_gitignore ~project_root files else files\n+  in\n+  (* TODO: This has a bug!!!\n+     Suppose we exclude `test.py` and are given `tests2/test.py`.\n+     This code will not exclude properly, on the basis that `test.py`\n+     does not match `tests2/test.py`.\n+     Essentially, we may need to look at every suffix of the file to see\n+     if it matches.\n+  *)\n+  let filtered_by_includes_excludes =\n+    filtered_files\n+    |> List.filter (fun file ->\n+           (* Why must we do this?\n+               The paths that we receive are absolute paths in the machine.\n+               This means something like /Users/brandonspark/test/test.py.\n+               When we match it against a blob, like `test.py`, obviously this\n+               will not match, because of the giant absolute prefix.\n+               We actually want the path _relative to the project root_, which is\n+               `test.py` for the project `test`.\n+               So we use `Fpath.rem_prefix` here, which emulates that functionality.\n+           *)",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1544907557",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9945,
        "pr_file": "src/osemgrep/language_server/custom_requests/Search.ml",
        "discussion_id": "1544907557",
        "commented_code": "@@ -156,23 +169,83 @@ let filter_by_gitignore (files : Fpath.t list)\n (* Information gathering *)\n (*****************************************************************************)\n \n-let mk_env (server : RPC_server.t) params =\n+let mk_env (server : RPC_server.t) (params : Request_params.t) =\n   let scanning_roots =\n     List_.map Scanning_root.of_fpath server.session.workspace_folders\n   in\n   let files =\n     server.session.cached_workspace_targets |> Hashtbl.to_seq_values\n     |> List.of_seq |> List.concat\n   in\n+  let project_root =\n+    match\n+      List.nth scanning_roots 0 |> Scanning_root.to_fpath |> Rfpath.of_fpath\n+    with\n+    | Error _ -> failwith \"somehow unable to get project root from first root\"\n+    | Ok rfpath -> rfpath\n+  in\n   (* Filter all files by gitignores *)\n   let filtered_files =\n     (* Gitignore code. We hard-code it to be false for now.\n        This adds 10s to startup time in `semgrep-app` on my machine.\n        Gitignore is expensive! I don't know why.\n     *)\n-    if false then filter_by_gitignore files scanning_roots else files\n+    if false then filter_by_gitignore ~project_root files else files\n+  in\n+  (* TODO: This has a bug!!!\n+     Suppose we exclude `test.py` and are given `tests2/test.py`.\n+     This code will not exclude properly, on the basis that `test.py`\n+     does not match `tests2/test.py`.\n+     Essentially, we may need to look at every suffix of the file to see\n+     if it matches.\n+  *)\n+  let filtered_by_includes_excludes =\n+    filtered_files\n+    |> List.filter (fun file ->\n+           (* Why must we do this?\n+               The paths that we receive are absolute paths in the machine.\n+               This means something like /Users/brandonspark/test/test.py.\n+               When we match it against a blob, like `test.py`, obviously this\n+               will not match, because of the giant absolute prefix.\n+               We actually want the path _relative to the project root_, which is\n+               `test.py` for the project `test`.\n+               So we use `Fpath.rem_prefix` here, which emulates that functionality.\n+           *)",
        "comment_created_at": "2024-03-29T22:03:59+00:00",
        "comment_author": "ajbt200128",
        "comment_body": "we should either assume the user will write *test.py for all test.py files, and we should not do this. Or if we assume they wont, we should auto add * to the pattern",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1398794043",
    "pr_number": 9288,
    "pr_file": "libs/gitignore/Gitignore_filter.ml",
    "created_at": "2023-11-20T08:18:41+00:00",
    "commented_code": "| []\n           | [ \"\" ] ->\n               loop sel_events levels file_path segments\n+          (* If a path has been deselected, don't test for dir-only patterns *)\n+          | _ :: _ when deselected -> loop sel_events levels file_path segments",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1398794043",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9288,
        "pr_file": "libs/gitignore/Gitignore_filter.ml",
        "discussion_id": "1398794043",
        "commented_code": "@@ -79,6 +84,8 @@ let select_path opt_gitignore_file_cache sel_events levels relative_segments =\n           | []\n           | [ \"\" ] ->\n               loop sel_events levels file_path segments\n+          (* If a path has been deselected, don't test for dir-only patterns *)\n+          | _ :: _ when deselected -> loop sel_events levels file_path segments",
        "comment_created_at": "2023-11-20T08:18:41+00:00",
        "comment_author": "aryx",
        "comment_body": "would be good to have a unit test for that. @mjambon wrote many of them in Unit_gitignore.ml\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1399561563",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9288,
        "pr_file": "libs/gitignore/Gitignore_filter.ml",
        "discussion_id": "1398794043",
        "commented_code": "@@ -79,6 +84,8 @@ let select_path opt_gitignore_file_cache sel_events levels relative_segments =\n           | []\n           | [ \"\" ] ->\n               loop sel_events levels file_path segments\n+          (* If a path has been deselected, don't test for dir-only patterns *)\n+          | _ :: _ when deselected -> loop sel_events levels file_path segments",
        "comment_created_at": "2023-11-20T18:01:31+00:00",
        "comment_author": "ajbt200128",
        "comment_body": "Will add one",
        "pr_file_module": null
      },
      {
        "comment_id": "1406842114",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9288,
        "pr_file": "libs/gitignore/Gitignore_filter.ml",
        "discussion_id": "1398794043",
        "commented_code": "@@ -79,6 +84,8 @@ let select_path opt_gitignore_file_cache sel_events levels relative_segments =\n           | []\n           | [ \"\" ] ->\n               loop sel_events levels file_path segments\n+          (* If a path has been deselected, don't test for dir-only patterns *)\n+          | _ :: _ when deselected -> loop sel_events levels file_path segments",
        "comment_created_at": "2023-11-27T22:31:05+00:00",
        "comment_author": "mjambon",
        "comment_body": "Also, if you see any spots where tests are missing, don't hesitate to add a `(* TODO: test this *)`. It's useful for whomever will work on the relevant test suite later and acknowledges that the situation isn't ideal.",
        "pr_file_module": null
      }
    ]
  }
]