[
  {
    "discussion_id": "1960750406",
    "pr_number": 10836,
    "pr_file": "languages/swift/generic/Parse_swift_tree_sitter.ml",
    "created_at": "2025-02-18T23:55:10+00:00",
    "commented_code": "G.New (G.fake \"new\", v1, G.empty_id_info (), v2) |> G.e\n   | `Navi_exp x -> map_navigation_expression env x\n   | `Prefix_exp (v1, v2) ->\n-      let e = map_expression env v2 in\n+      let e =\n+        match v2 with\n+        | `Exp x -> map_expression env x\n+        | `Choice_async _ ->\n+            (* This is not valid swift code, a hack in the grammar: see: https://github.com/alex-pinkus/tree-sitter-swift/issues/468 *)\n+            failwith \"Invalid Swift\"",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1960750406",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10836,
        "pr_file": "languages/swift/generic/Parse_swift_tree_sitter.ml",
        "discussion_id": "1960750406",
        "commented_code": "@@ -3122,7 +3351,13 @@ and map_unary_expression (env : env) (x : CST.unary_expression) : G.expr =\n       G.New (G.fake \"new\", v1, G.empty_id_info (), v2) |> G.e\n   | `Navi_exp x -> map_navigation_expression env x\n   | `Prefix_exp (v1, v2) ->\n-      let e = map_expression env v2 in\n+      let e =\n+        match v2 with\n+        | `Exp x -> map_expression env x\n+        | `Choice_async _ ->\n+            (* This is not valid swift code, a hack in the grammar: see: https://github.com/alex-pinkus/tree-sitter-swift/issues/468 *)\n+            failwith \"Invalid Swift\"",
        "comment_created_at": "2025-02-18T23:55:10+00:00",
        "comment_author": "nmote",
        "comment_body": "I've encountered cases where we actually got a supposedly impossible CST after Tree Sitter's error recovery. `failwith`s like this can turn a recoverable error into an unrecoverable one. Nowadays we tend to prefer to use the raw tree construct for cases like this, which allows at least some basic matching of the untranslated section (and more importantly, does not bring down the whole parse attempt).\r\n\r\nhttps://github.com/semgrep/semgrep/blob/develop/src/ast_generic/AST_generic.ml#L853-L855",
        "pr_file_module": null
      },
      {
        "comment_id": "1977223078",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10836,
        "pr_file": "languages/swift/generic/Parse_swift_tree_sitter.ml",
        "discussion_id": "1960750406",
        "commented_code": "@@ -3122,7 +3351,13 @@ and map_unary_expression (env : env) (x : CST.unary_expression) : G.expr =\n       G.New (G.fake \"new\", v1, G.empty_id_info (), v2) |> G.e\n   | `Navi_exp x -> map_navigation_expression env x\n   | `Prefix_exp (v1, v2) ->\n-      let e = map_expression env v2 in\n+      let e =\n+        match v2 with\n+        | `Exp x -> map_expression env x\n+        | `Choice_async _ ->\n+            (* This is not valid swift code, a hack in the grammar: see: https://github.com/alex-pinkus/tree-sitter-swift/issues/468 *)\n+            failwith \"Invalid Swift\"",
        "comment_created_at": "2025-03-03T10:04:29+00:00",
        "comment_author": "NinjaLikesCheez",
        "comment_body": "Addressed in 1afbaa3c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1484667725",
    "pr_number": 9709,
    "pr_file": "libs/commons/List_.ml",
    "created_at": "2024-02-09T18:26:12+00:00",
    "commented_code": "| [] -> failwith errmsg\n   | _ :: tail -> tail\n \n+let rec last_exn errmsg xs =\n+  match xs with\n+  | [] -> failwith errmsg\n+  | [ x ] -> x\n+  | _ :: tl -> last_exn errmsg tl\n+\n+let last_opt xs =\n+  try Some (last_exn \"last_opt failed\" xs) with\n+  | Failure _ -> None",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1484667725",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9709,
        "pr_file": "libs/commons/List_.ml",
        "discussion_id": "1484667725",
        "commented_code": "@@ -222,6 +222,16 @@ let tl_exn errmsg xs =\n   | [] -> failwith errmsg\n   | _ :: tail -> tail\n \n+let rec last_exn errmsg xs =\n+  match xs with\n+  | [] -> failwith errmsg\n+  | [ x ] -> x\n+  | _ :: tl -> last_exn errmsg tl\n+\n+let last_opt xs =\n+  try Some (last_exn \"last_opt failed\" xs) with\n+  | Failure _ -> None",
        "comment_created_at": "2024-02-09T18:26:12+00:00",
        "comment_author": "nmote",
        "comment_body": "I'd rather not encourage people to use exceptions. Just implement last_opt directly and leave last_exn out.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1484899052",
    "pr_number": 9709,
    "pr_file": "src/analyzing/AST_to_IL.ml",
    "created_at": "2024-02-09T23:54:21+00:00",
    "commented_code": "| _ -> exp\n       in\n       ident_function_call_hack exp\n+  (* x = ClassName(args ...) in Python *)\n+  (* ClassName has been resolved to __init__ by the pro engine. *)\n+  (* Identified and treated as x = New ClassName(args ...) to support\n+     field sensitivity. *)\n+  | G.Assign\n+      ( ({\n+           e =\n+             ( G.N (G.Id ((_, _), lhs_info))\n+             | G.DotAccess (_, _, FN (Id ((_, _), lhs_info))) );\n+           _;\n+         } as lhs_e),\n+        _,\n+        ({\n+           e =\n+             G.Call\n+               ( {\n+                   e =\n+                     ( G.N (Id (_, id_info))\n+                     | G.DotAccess (_, _, FN (Id (_, id_info))) );\n+                   _;\n+                 },\n+                 args );\n+           _;\n+         } as origin_exp) )\n+  (* Can we be tighter about side conditions here to avoid catching\n+     direct calls to __init__ ? *)\n+    when match id_info.G.id_resolved.contents with\n+         | Some (G.GlobalName (ls, _), _) -> (\n+             env.lang =*= Lang.Python\n+             && List.length ls >= 3 (* Module + Class + __init__ *)\n+             && (match List_.last_opt ls with\n+                | Some \"__init__\" -> true\n+                | _ -> false)\n+             &&\n+             match lhs_info.id_type.contents with\n+             | Some { t = G.TyN _; _ } -> true\n+             | _ -> false)\n+         | _ -> false ->\n+      let lval = lval env lhs_e in\n+      let ty =\n+        match lhs_info.id_type.contents with\n+        | Some ty -> ty\n+        | _ -> failwith \"Impossible: guard above checks that this exists\"",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1484899052",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9709,
        "pr_file": "src/analyzing/AST_to_IL.ml",
        "discussion_id": "1484899052",
        "commented_code": "@@ -685,6 +685,52 @@ and expr_aux env ?(void = false) e_gen =\n         | _ -> exp\n       in\n       ident_function_call_hack exp\n+  (* x = ClassName(args ...) in Python *)\n+  (* ClassName has been resolved to __init__ by the pro engine. *)\n+  (* Identified and treated as x = New ClassName(args ...) to support\n+     field sensitivity. *)\n+  | G.Assign\n+      ( ({\n+           e =\n+             ( G.N (G.Id ((_, _), lhs_info))\n+             | G.DotAccess (_, _, FN (Id ((_, _), lhs_info))) );\n+           _;\n+         } as lhs_e),\n+        _,\n+        ({\n+           e =\n+             G.Call\n+               ( {\n+                   e =\n+                     ( G.N (Id (_, id_info))\n+                     | G.DotAccess (_, _, FN (Id (_, id_info))) );\n+                   _;\n+                 },\n+                 args );\n+           _;\n+         } as origin_exp) )\n+  (* Can we be tighter about side conditions here to avoid catching\n+     direct calls to __init__ ? *)\n+    when match id_info.G.id_resolved.contents with\n+         | Some (G.GlobalName (ls, _), _) -> (\n+             env.lang =*= Lang.Python\n+             && List.length ls >= 3 (* Module + Class + __init__ *)\n+             && (match List_.last_opt ls with\n+                | Some \"__init__\" -> true\n+                | _ -> false)\n+             &&\n+             match lhs_info.id_type.contents with\n+             | Some { t = G.TyN _; _ } -> true\n+             | _ -> false)\n+         | _ -> false ->\n+      let lval = lval env lhs_e in\n+      let ty =\n+        match lhs_info.id_type.contents with\n+        | Some ty -> ty\n+        | _ -> failwith \"Impossible: guard above checks that this exists\"",
        "comment_created_at": "2024-02-09T23:54:21+00:00",
        "comment_author": "nmote",
        "comment_body": "I'd rather pattern match on `lhs_info` and have the pattern match duplicated in both cases where that is bound than have a failwith here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1484908349",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9709,
        "pr_file": "src/analyzing/AST_to_IL.ml",
        "discussion_id": "1484899052",
        "commented_code": "@@ -685,6 +685,52 @@ and expr_aux env ?(void = false) e_gen =\n         | _ -> exp\n       in\n       ident_function_call_hack exp\n+  (* x = ClassName(args ...) in Python *)\n+  (* ClassName has been resolved to __init__ by the pro engine. *)\n+  (* Identified and treated as x = New ClassName(args ...) to support\n+     field sensitivity. *)\n+  | G.Assign\n+      ( ({\n+           e =\n+             ( G.N (G.Id ((_, _), lhs_info))\n+             | G.DotAccess (_, _, FN (Id ((_, _), lhs_info))) );\n+           _;\n+         } as lhs_e),\n+        _,\n+        ({\n+           e =\n+             G.Call\n+               ( {\n+                   e =\n+                     ( G.N (Id (_, id_info))\n+                     | G.DotAccess (_, _, FN (Id (_, id_info))) );\n+                   _;\n+                 },\n+                 args );\n+           _;\n+         } as origin_exp) )\n+  (* Can we be tighter about side conditions here to avoid catching\n+     direct calls to __init__ ? *)\n+    when match id_info.G.id_resolved.contents with\n+         | Some (G.GlobalName (ls, _), _) -> (\n+             env.lang =*= Lang.Python\n+             && List.length ls >= 3 (* Module + Class + __init__ *)\n+             && (match List_.last_opt ls with\n+                | Some \"__init__\" -> true\n+                | _ -> false)\n+             &&\n+             match lhs_info.id_type.contents with\n+             | Some { t = G.TyN _; _ } -> true\n+             | _ -> false)\n+         | _ -> false ->\n+      let lval = lval env lhs_e in\n+      let ty =\n+        match lhs_info.id_type.contents with\n+        | Some ty -> ty\n+        | _ -> failwith \"Impossible: guard above checks that this exists\"",
        "comment_created_at": "2024-02-10T00:22:19+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Definitely no `failwith` allowed...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1447794602",
    "pr_number": 9559,
    "pr_file": "src/analyzing/AST_to_IL.ml",
    "created_at": "2024-01-10T18:50:34+00:00",
    "commented_code": "(*****************************************************************************)\n \n let function_definition lang ?ctx def =\n+  let is_method = match lang, fst def.G.fkind with\n+    (* TODO handle class methods and static methods *)\n+    | (Lang.Python, G.Method) -> true\n+    | _ -> false \n+  in\n+  logger#trace \"is_method: %s\" (if is_method then \"true\" else \"false\");\n   let env = { (empty_env lang) with ctx = ctx ||| empty_ctx } in\n-  let params = parameters env def.G.fparams in\n+  (* TODO add the self or class parameter to the env *)\n+  logger#trace \"def parameters: %s\" (G.show_parameters def.G.fparams);\n+  let params =\n+    let ps = if is_method then\n+        let (lb, ps', rb) = def.G.fparams in\n+        (lb, (try List.tl ps'  with Failure _ -> ps'), rb)",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1447794602",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9559,
        "pr_file": "src/analyzing/AST_to_IL.ml",
        "discussion_id": "1447794602",
        "commented_code": "@@ -1804,8 +1804,24 @@ and function_definition env fdef =\n (*****************************************************************************)\n \n let function_definition lang ?ctx def =\n+  let is_method = match lang, fst def.G.fkind with\n+    (* TODO handle class methods and static methods *)\n+    | (Lang.Python, G.Method) -> true\n+    | _ -> false \n+  in\n+  logger#trace \"is_method: %s\" (if is_method then \"true\" else \"false\");\n   let env = { (empty_env lang) with ctx = ctx ||| empty_ctx } in\n-  let params = parameters env def.G.fparams in\n+  (* TODO add the self or class parameter to the env *)\n+  logger#trace \"def parameters: %s\" (G.show_parameters def.G.fparams);\n+  let params =\n+    let ps = if is_method then\n+        let (lb, ps', rb) = def.G.fparams in\n+        (lb, (try List.tl ps'  with Failure _ -> ps'), rb)",
        "comment_created_at": "2024-01-10T18:50:34+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Better to `match` on the list IMO than to `try ... with Failure ...`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1455970539",
    "pr_number": 9608,
    "pr_file": "src/osemgrep/reporting/Sarif_output.ml",
    "created_at": "2024-01-17T16:12:49+00:00",
    "commented_code": "+open Common\n+module OutT = Semgrep_output_v1_t\n+\n+let sarif_severity_of_severity = function\n+  | `Info -> \"note\"\n+  | `Warning -> \"warning\"\n+  | `Error -> \"error\"\n+  | `Experiment\n+  | `Inventory ->\n+      raise Todo\n+\n+let tags_of_metadata metadata =\n+  (* XXX: Tags likely have to be strings, but what do we do with non-string json?! *)\n+  let best_effort_string = function\n+    | JSON.String s -> s\n+    | non_string -> JSON.string_of_json non_string\n+  in\n+  let cwe =\n+    match JSON.member \"cwe\" metadata with\n+    | Some (JSON.Array cwe) -> List_.map best_effort_string cwe\n+    | Some single_cwe -> [ best_effort_string single_cwe ]\n+    | None -> []\n+  in\n+  let owasp =\n+    match JSON.member \"owasp\" metadata with\n+    | Some (JSON.Array owasp) ->\n+        List_.map (fun o -> \"OWASP-\" ^ best_effort_string o) owasp\n+    | Some o -> [ \"OWASP-\" ^ best_effort_string o ]\n+    | None -> []\n+  in\n+  let confidence =\n+    match JSON.member \"confidence\" metadata with\n+    | Some c -> [ best_effort_string c ^ \" CONFIDENCE\" ]\n+    | None -> []\n+  in\n+  let semgrep_policy_slug =\n+    match JSON.member \"semgrep.policy\" metadata with\n+    | Some (JSON.Object _ as sp) -> (\n+        match JSON.member \"slug\" sp with\n+        | Some slug -> [ best_effort_string slug ]\n+        | None -> [])\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  let tags =\n+    match JSON.member \"tags\" metadata with\n+    | Some (JSON.Array tags) -> List_.map best_effort_string tags\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  cwe @ owasp @ confidence @ semgrep_policy_slug @ tags\n+\n+(* We want to produce a json object? with the following shape:\n+   { id; name;\n+     shortDescription; fullDescription;\n+     helpUri; help;\n+     defaultConfiguration = { level };\n+     properties }\n+*)\n+let rules hide_nudge (hrules : Rule.hrules) =\n+  let rules = Hashtbl.to_seq hrules in\n+  let rules =\n+    Seq.map\n+      (fun (rule_id, rule) ->\n+        let metadata = Option.value ~default:JSON.Null rule.Rule.metadata in\n+        let short_description =\n+          match JSON.member \"shortDescription\" metadata with\n+          | Some (JSON.String shortDescription) -> shortDescription\n+          | Some _ -> raise Impossible\n+          | None -> spf \"Semgrep Finding: %s\" (Rule_ID.to_string rule_id)\n+        and source, rule_url =\n+          match JSON.member \"source\" metadata with\n+          | Some (JSON.String source) ->\n+              (Some source, [ (\"helpUri\", `String source) ])\n+          | Some _\n+          | None ->\n+              (None, [])\n+        and rule_help_text =\n+          match JSON.member \"help\" metadata with\n+          | Some (JSON.String txt) -> txt\n+          | Some _\n+          | None ->\n+              rule.message\n+        in\n+        let security_severity =\n+          (* TODO: no test case for this *)\n+          match JSON.member \"security-severity\" metadata with\n+          | Some json -> [ (\"security-severity\", JSON.to_yojson json) ]\n+          | None -> []\n+        in\n+        let properties =\n+          let tags = tags_of_metadata metadata in\n+          [\n+            (\"precision\", `String \"very-high\");\n+            (\"tags\", `List (List_.map (fun s -> `String s) tags));\n+          ]\n+          @ security_severity\n+        in\n+        let nudge_base =\n+          \"\ud83d\udc8e Enable cross-file analysis and Pro rules for free at\"\n+        and nudge_url = \"sg.run/pro\" in\n+        let nudge_plaintext = spf \"\n%s %s\" nudge_base nudge_url\n+        and nudge_md =\n+          spf \"\n\n#### %s <a href='https://%s'>%s</a>\" nudge_base nudge_url\n+            nudge_url\n+        in\n+        let text_suffix = if hide_nudge then \"\" else nudge_plaintext in\n+        let markdown_interstitial = if hide_nudge then \"\" else nudge_md in\n+        let references =\n+          Option.to_list\n+            (Option.map (fun s -> spf \"[Semgrep Rule](%s)\" s) source)\n+        in\n+        let other_references =\n+          match JSON.member \"references\" metadata with\n+          | Some (JSON.String s) -> [ spf \"[%s](%s)\" s s ]\n+          | Some (JSON.Array xs) ->\n+              List_.map\n+                (function\n+                  | JSON.String s -> spf \"[%s](%s)\" s s\n+                  | non_string -> JSON.string_of_json non_string)\n+                xs\n+          | Some _\n+          | None ->\n+              []\n+        in\n+        let references_joined =\n+          List_.map (fun s -> spf \" - %s\n\" s) (references @ other_references)\n+        in\n+        let references_markdown =\n+          match references_joined with\n+          | [] -> \"\"\n+          | xs -> \"\n\n<b>References:</b>\n\" ^ String.concat \"\" xs\n+        in\n+        `Assoc\n+          ([\n+             (\"id\", `String (Rule_ID.to_string rule_id));\n+             (\"name\", `String (Rule_ID.to_string rule_id));\n+             (\"shortDescription\", `Assoc [ (\"text\", `String short_description) ]);\n+             (\"fullDescription\", `Assoc [ (\"text\", `String rule.message) ]);\n+             ( \"defaultConfiguration\",\n+               `Assoc\n+                 [\n+                   (\"level\", `String (sarif_severity_of_severity rule.severity));\n+                 ] );\n+             ( \"help\",\n+               `Assoc\n+                 [\n+                   (\"text\", `String (rule_help_text ^ text_suffix));\n+                   ( \"markdown\",\n+                     `String\n+                       (rule_help_text ^ markdown_interstitial\n+                      ^ references_markdown) );\n+                 ] );\n+             (\"properties\", `Assoc properties);\n+           ]\n+          @ rule_url))\n+      rules\n+  in\n+  List.of_seq rules\n+\n+let fixed_lines (cli_match : OutT.cli_match) fix =\n+  let lines = String.split_on_char '\n' cli_match.extra.lines in\n+  match (lines, List.rev lines) with\n+  | line :: _, last_line :: _ ->\n+      let first_line_part = Str.first_chars line (cli_match.start.col - 1)\n+      and last_line_part =\n+        Str.string_after last_line (cli_match.end_.col - 1)\n+      in\n+      String.split_on_char '\n' (first_line_part ^ fix ^ last_line_part)\n+  | [], _\n+  | _, [] ->\n+      assert false",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1455970539",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9608,
        "pr_file": "src/osemgrep/reporting/Sarif_output.ml",
        "discussion_id": "1455970539",
        "commented_code": "@@ -0,0 +1,357 @@\n+open Common\n+module OutT = Semgrep_output_v1_t\n+\n+let sarif_severity_of_severity = function\n+  | `Info -> \"note\"\n+  | `Warning -> \"warning\"\n+  | `Error -> \"error\"\n+  | `Experiment\n+  | `Inventory ->\n+      raise Todo\n+\n+let tags_of_metadata metadata =\n+  (* XXX: Tags likely have to be strings, but what do we do with non-string json?! *)\n+  let best_effort_string = function\n+    | JSON.String s -> s\n+    | non_string -> JSON.string_of_json non_string\n+  in\n+  let cwe =\n+    match JSON.member \"cwe\" metadata with\n+    | Some (JSON.Array cwe) -> List_.map best_effort_string cwe\n+    | Some single_cwe -> [ best_effort_string single_cwe ]\n+    | None -> []\n+  in\n+  let owasp =\n+    match JSON.member \"owasp\" metadata with\n+    | Some (JSON.Array owasp) ->\n+        List_.map (fun o -> \"OWASP-\" ^ best_effort_string o) owasp\n+    | Some o -> [ \"OWASP-\" ^ best_effort_string o ]\n+    | None -> []\n+  in\n+  let confidence =\n+    match JSON.member \"confidence\" metadata with\n+    | Some c -> [ best_effort_string c ^ \" CONFIDENCE\" ]\n+    | None -> []\n+  in\n+  let semgrep_policy_slug =\n+    match JSON.member \"semgrep.policy\" metadata with\n+    | Some (JSON.Object _ as sp) -> (\n+        match JSON.member \"slug\" sp with\n+        | Some slug -> [ best_effort_string slug ]\n+        | None -> [])\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  let tags =\n+    match JSON.member \"tags\" metadata with\n+    | Some (JSON.Array tags) -> List_.map best_effort_string tags\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  cwe @ owasp @ confidence @ semgrep_policy_slug @ tags\n+\n+(* We want to produce a json object? with the following shape:\n+   { id; name;\n+     shortDescription; fullDescription;\n+     helpUri; help;\n+     defaultConfiguration = { level };\n+     properties }\n+*)\n+let rules hide_nudge (hrules : Rule.hrules) =\n+  let rules = Hashtbl.to_seq hrules in\n+  let rules =\n+    Seq.map\n+      (fun (rule_id, rule) ->\n+        let metadata = Option.value ~default:JSON.Null rule.Rule.metadata in\n+        let short_description =\n+          match JSON.member \"shortDescription\" metadata with\n+          | Some (JSON.String shortDescription) -> shortDescription\n+          | Some _ -> raise Impossible\n+          | None -> spf \"Semgrep Finding: %s\" (Rule_ID.to_string rule_id)\n+        and source, rule_url =\n+          match JSON.member \"source\" metadata with\n+          | Some (JSON.String source) ->\n+              (Some source, [ (\"helpUri\", `String source) ])\n+          | Some _\n+          | None ->\n+              (None, [])\n+        and rule_help_text =\n+          match JSON.member \"help\" metadata with\n+          | Some (JSON.String txt) -> txt\n+          | Some _\n+          | None ->\n+              rule.message\n+        in\n+        let security_severity =\n+          (* TODO: no test case for this *)\n+          match JSON.member \"security-severity\" metadata with\n+          | Some json -> [ (\"security-severity\", JSON.to_yojson json) ]\n+          | None -> []\n+        in\n+        let properties =\n+          let tags = tags_of_metadata metadata in\n+          [\n+            (\"precision\", `String \"very-high\");\n+            (\"tags\", `List (List_.map (fun s -> `String s) tags));\n+          ]\n+          @ security_severity\n+        in\n+        let nudge_base =\n+          \"\ud83d\udc8e Enable cross-file analysis and Pro rules for free at\"\n+        and nudge_url = \"sg.run/pro\" in\n+        let nudge_plaintext = spf \"\\n%s %s\" nudge_base nudge_url\n+        and nudge_md =\n+          spf \"\\n\\n#### %s <a href='https://%s'>%s</a>\" nudge_base nudge_url\n+            nudge_url\n+        in\n+        let text_suffix = if hide_nudge then \"\" else nudge_plaintext in\n+        let markdown_interstitial = if hide_nudge then \"\" else nudge_md in\n+        let references =\n+          Option.to_list\n+            (Option.map (fun s -> spf \"[Semgrep Rule](%s)\" s) source)\n+        in\n+        let other_references =\n+          match JSON.member \"references\" metadata with\n+          | Some (JSON.String s) -> [ spf \"[%s](%s)\" s s ]\n+          | Some (JSON.Array xs) ->\n+              List_.map\n+                (function\n+                  | JSON.String s -> spf \"[%s](%s)\" s s\n+                  | non_string -> JSON.string_of_json non_string)\n+                xs\n+          | Some _\n+          | None ->\n+              []\n+        in\n+        let references_joined =\n+          List_.map (fun s -> spf \" - %s\\n\" s) (references @ other_references)\n+        in\n+        let references_markdown =\n+          match references_joined with\n+          | [] -> \"\"\n+          | xs -> \"\\n\\n<b>References:</b>\\n\" ^ String.concat \"\" xs\n+        in\n+        `Assoc\n+          ([\n+             (\"id\", `String (Rule_ID.to_string rule_id));\n+             (\"name\", `String (Rule_ID.to_string rule_id));\n+             (\"shortDescription\", `Assoc [ (\"text\", `String short_description) ]);\n+             (\"fullDescription\", `Assoc [ (\"text\", `String rule.message) ]);\n+             ( \"defaultConfiguration\",\n+               `Assoc\n+                 [\n+                   (\"level\", `String (sarif_severity_of_severity rule.severity));\n+                 ] );\n+             ( \"help\",\n+               `Assoc\n+                 [\n+                   (\"text\", `String (rule_help_text ^ text_suffix));\n+                   ( \"markdown\",\n+                     `String\n+                       (rule_help_text ^ markdown_interstitial\n+                      ^ references_markdown) );\n+                 ] );\n+             (\"properties\", `Assoc properties);\n+           ]\n+          @ rule_url))\n+      rules\n+  in\n+  List.of_seq rules\n+\n+let fixed_lines (cli_match : OutT.cli_match) fix =\n+  let lines = String.split_on_char '\\n' cli_match.extra.lines in\n+  match (lines, List.rev lines) with\n+  | line :: _, last_line :: _ ->\n+      let first_line_part = Str.first_chars line (cli_match.start.col - 1)\n+      and last_line_part =\n+        Str.string_after last_line (cli_match.end_.col - 1)\n+      in\n+      String.split_on_char '\\n' (first_line_part ^ fix ^ last_line_part)\n+  | [], _\n+  | _, [] ->\n+      assert false",
        "comment_created_at": "2024-01-17T16:12:49+00:00",
        "comment_author": "hannesm",
        "comment_body": "it is unclear what to do in this case -> return an empty list? can it happen? is the assert false fine?",
        "pr_file_module": null
      },
      {
        "comment_id": "1455989205",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9608,
        "pr_file": "src/osemgrep/reporting/Sarif_output.ml",
        "discussion_id": "1455970539",
        "commented_code": "@@ -0,0 +1,357 @@\n+open Common\n+module OutT = Semgrep_output_v1_t\n+\n+let sarif_severity_of_severity = function\n+  | `Info -> \"note\"\n+  | `Warning -> \"warning\"\n+  | `Error -> \"error\"\n+  | `Experiment\n+  | `Inventory ->\n+      raise Todo\n+\n+let tags_of_metadata metadata =\n+  (* XXX: Tags likely have to be strings, but what do we do with non-string json?! *)\n+  let best_effort_string = function\n+    | JSON.String s -> s\n+    | non_string -> JSON.string_of_json non_string\n+  in\n+  let cwe =\n+    match JSON.member \"cwe\" metadata with\n+    | Some (JSON.Array cwe) -> List_.map best_effort_string cwe\n+    | Some single_cwe -> [ best_effort_string single_cwe ]\n+    | None -> []\n+  in\n+  let owasp =\n+    match JSON.member \"owasp\" metadata with\n+    | Some (JSON.Array owasp) ->\n+        List_.map (fun o -> \"OWASP-\" ^ best_effort_string o) owasp\n+    | Some o -> [ \"OWASP-\" ^ best_effort_string o ]\n+    | None -> []\n+  in\n+  let confidence =\n+    match JSON.member \"confidence\" metadata with\n+    | Some c -> [ best_effort_string c ^ \" CONFIDENCE\" ]\n+    | None -> []\n+  in\n+  let semgrep_policy_slug =\n+    match JSON.member \"semgrep.policy\" metadata with\n+    | Some (JSON.Object _ as sp) -> (\n+        match JSON.member \"slug\" sp with\n+        | Some slug -> [ best_effort_string slug ]\n+        | None -> [])\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  let tags =\n+    match JSON.member \"tags\" metadata with\n+    | Some (JSON.Array tags) -> List_.map best_effort_string tags\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  cwe @ owasp @ confidence @ semgrep_policy_slug @ tags\n+\n+(* We want to produce a json object? with the following shape:\n+   { id; name;\n+     shortDescription; fullDescription;\n+     helpUri; help;\n+     defaultConfiguration = { level };\n+     properties }\n+*)\n+let rules hide_nudge (hrules : Rule.hrules) =\n+  let rules = Hashtbl.to_seq hrules in\n+  let rules =\n+    Seq.map\n+      (fun (rule_id, rule) ->\n+        let metadata = Option.value ~default:JSON.Null rule.Rule.metadata in\n+        let short_description =\n+          match JSON.member \"shortDescription\" metadata with\n+          | Some (JSON.String shortDescription) -> shortDescription\n+          | Some _ -> raise Impossible\n+          | None -> spf \"Semgrep Finding: %s\" (Rule_ID.to_string rule_id)\n+        and source, rule_url =\n+          match JSON.member \"source\" metadata with\n+          | Some (JSON.String source) ->\n+              (Some source, [ (\"helpUri\", `String source) ])\n+          | Some _\n+          | None ->\n+              (None, [])\n+        and rule_help_text =\n+          match JSON.member \"help\" metadata with\n+          | Some (JSON.String txt) -> txt\n+          | Some _\n+          | None ->\n+              rule.message\n+        in\n+        let security_severity =\n+          (* TODO: no test case for this *)\n+          match JSON.member \"security-severity\" metadata with\n+          | Some json -> [ (\"security-severity\", JSON.to_yojson json) ]\n+          | None -> []\n+        in\n+        let properties =\n+          let tags = tags_of_metadata metadata in\n+          [\n+            (\"precision\", `String \"very-high\");\n+            (\"tags\", `List (List_.map (fun s -> `String s) tags));\n+          ]\n+          @ security_severity\n+        in\n+        let nudge_base =\n+          \"\ud83d\udc8e Enable cross-file analysis and Pro rules for free at\"\n+        and nudge_url = \"sg.run/pro\" in\n+        let nudge_plaintext = spf \"\\n%s %s\" nudge_base nudge_url\n+        and nudge_md =\n+          spf \"\\n\\n#### %s <a href='https://%s'>%s</a>\" nudge_base nudge_url\n+            nudge_url\n+        in\n+        let text_suffix = if hide_nudge then \"\" else nudge_plaintext in\n+        let markdown_interstitial = if hide_nudge then \"\" else nudge_md in\n+        let references =\n+          Option.to_list\n+            (Option.map (fun s -> spf \"[Semgrep Rule](%s)\" s) source)\n+        in\n+        let other_references =\n+          match JSON.member \"references\" metadata with\n+          | Some (JSON.String s) -> [ spf \"[%s](%s)\" s s ]\n+          | Some (JSON.Array xs) ->\n+              List_.map\n+                (function\n+                  | JSON.String s -> spf \"[%s](%s)\" s s\n+                  | non_string -> JSON.string_of_json non_string)\n+                xs\n+          | Some _\n+          | None ->\n+              []\n+        in\n+        let references_joined =\n+          List_.map (fun s -> spf \" - %s\\n\" s) (references @ other_references)\n+        in\n+        let references_markdown =\n+          match references_joined with\n+          | [] -> \"\"\n+          | xs -> \"\\n\\n<b>References:</b>\\n\" ^ String.concat \"\" xs\n+        in\n+        `Assoc\n+          ([\n+             (\"id\", `String (Rule_ID.to_string rule_id));\n+             (\"name\", `String (Rule_ID.to_string rule_id));\n+             (\"shortDescription\", `Assoc [ (\"text\", `String short_description) ]);\n+             (\"fullDescription\", `Assoc [ (\"text\", `String rule.message) ]);\n+             ( \"defaultConfiguration\",\n+               `Assoc\n+                 [\n+                   (\"level\", `String (sarif_severity_of_severity rule.severity));\n+                 ] );\n+             ( \"help\",\n+               `Assoc\n+                 [\n+                   (\"text\", `String (rule_help_text ^ text_suffix));\n+                   ( \"markdown\",\n+                     `String\n+                       (rule_help_text ^ markdown_interstitial\n+                      ^ references_markdown) );\n+                 ] );\n+             (\"properties\", `Assoc properties);\n+           ]\n+          @ rule_url))\n+      rules\n+  in\n+  List.of_seq rules\n+\n+let fixed_lines (cli_match : OutT.cli_match) fix =\n+  let lines = String.split_on_char '\\n' cli_match.extra.lines in\n+  match (lines, List.rev lines) with\n+  | line :: _, last_line :: _ ->\n+      let first_line_part = Str.first_chars line (cli_match.start.col - 1)\n+      and last_line_part =\n+        Str.string_after last_line (cli_match.end_.col - 1)\n+      in\n+      String.split_on_char '\\n' (first_line_part ^ fix ^ last_line_part)\n+  | [], _\n+  | _, [] ->\n+      assert false",
        "comment_created_at": "2024-01-17T16:20:36+00:00",
        "comment_author": "aryx",
        "comment_body": "assert false is fine if we're sure this can never happen (because OCaml exhaustive check has limitations). If you're not sure, better failwith maybe\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1456361390",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9608,
        "pr_file": "src/osemgrep/reporting/Sarif_output.ml",
        "discussion_id": "1455970539",
        "commented_code": "@@ -0,0 +1,357 @@\n+open Common\n+module OutT = Semgrep_output_v1_t\n+\n+let sarif_severity_of_severity = function\n+  | `Info -> \"note\"\n+  | `Warning -> \"warning\"\n+  | `Error -> \"error\"\n+  | `Experiment\n+  | `Inventory ->\n+      raise Todo\n+\n+let tags_of_metadata metadata =\n+  (* XXX: Tags likely have to be strings, but what do we do with non-string json?! *)\n+  let best_effort_string = function\n+    | JSON.String s -> s\n+    | non_string -> JSON.string_of_json non_string\n+  in\n+  let cwe =\n+    match JSON.member \"cwe\" metadata with\n+    | Some (JSON.Array cwe) -> List_.map best_effort_string cwe\n+    | Some single_cwe -> [ best_effort_string single_cwe ]\n+    | None -> []\n+  in\n+  let owasp =\n+    match JSON.member \"owasp\" metadata with\n+    | Some (JSON.Array owasp) ->\n+        List_.map (fun o -> \"OWASP-\" ^ best_effort_string o) owasp\n+    | Some o -> [ \"OWASP-\" ^ best_effort_string o ]\n+    | None -> []\n+  in\n+  let confidence =\n+    match JSON.member \"confidence\" metadata with\n+    | Some c -> [ best_effort_string c ^ \" CONFIDENCE\" ]\n+    | None -> []\n+  in\n+  let semgrep_policy_slug =\n+    match JSON.member \"semgrep.policy\" metadata with\n+    | Some (JSON.Object _ as sp) -> (\n+        match JSON.member \"slug\" sp with\n+        | Some slug -> [ best_effort_string slug ]\n+        | None -> [])\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  let tags =\n+    match JSON.member \"tags\" metadata with\n+    | Some (JSON.Array tags) -> List_.map best_effort_string tags\n+    | Some _\n+    | None ->\n+        []\n+  in\n+  cwe @ owasp @ confidence @ semgrep_policy_slug @ tags\n+\n+(* We want to produce a json object? with the following shape:\n+   { id; name;\n+     shortDescription; fullDescription;\n+     helpUri; help;\n+     defaultConfiguration = { level };\n+     properties }\n+*)\n+let rules hide_nudge (hrules : Rule.hrules) =\n+  let rules = Hashtbl.to_seq hrules in\n+  let rules =\n+    Seq.map\n+      (fun (rule_id, rule) ->\n+        let metadata = Option.value ~default:JSON.Null rule.Rule.metadata in\n+        let short_description =\n+          match JSON.member \"shortDescription\" metadata with\n+          | Some (JSON.String shortDescription) -> shortDescription\n+          | Some _ -> raise Impossible\n+          | None -> spf \"Semgrep Finding: %s\" (Rule_ID.to_string rule_id)\n+        and source, rule_url =\n+          match JSON.member \"source\" metadata with\n+          | Some (JSON.String source) ->\n+              (Some source, [ (\"helpUri\", `String source) ])\n+          | Some _\n+          | None ->\n+              (None, [])\n+        and rule_help_text =\n+          match JSON.member \"help\" metadata with\n+          | Some (JSON.String txt) -> txt\n+          | Some _\n+          | None ->\n+              rule.message\n+        in\n+        let security_severity =\n+          (* TODO: no test case for this *)\n+          match JSON.member \"security-severity\" metadata with\n+          | Some json -> [ (\"security-severity\", JSON.to_yojson json) ]\n+          | None -> []\n+        in\n+        let properties =\n+          let tags = tags_of_metadata metadata in\n+          [\n+            (\"precision\", `String \"very-high\");\n+            (\"tags\", `List (List_.map (fun s -> `String s) tags));\n+          ]\n+          @ security_severity\n+        in\n+        let nudge_base =\n+          \"\ud83d\udc8e Enable cross-file analysis and Pro rules for free at\"\n+        and nudge_url = \"sg.run/pro\" in\n+        let nudge_plaintext = spf \"\\n%s %s\" nudge_base nudge_url\n+        and nudge_md =\n+          spf \"\\n\\n#### %s <a href='https://%s'>%s</a>\" nudge_base nudge_url\n+            nudge_url\n+        in\n+        let text_suffix = if hide_nudge then \"\" else nudge_plaintext in\n+        let markdown_interstitial = if hide_nudge then \"\" else nudge_md in\n+        let references =\n+          Option.to_list\n+            (Option.map (fun s -> spf \"[Semgrep Rule](%s)\" s) source)\n+        in\n+        let other_references =\n+          match JSON.member \"references\" metadata with\n+          | Some (JSON.String s) -> [ spf \"[%s](%s)\" s s ]\n+          | Some (JSON.Array xs) ->\n+              List_.map\n+                (function\n+                  | JSON.String s -> spf \"[%s](%s)\" s s\n+                  | non_string -> JSON.string_of_json non_string)\n+                xs\n+          | Some _\n+          | None ->\n+              []\n+        in\n+        let references_joined =\n+          List_.map (fun s -> spf \" - %s\\n\" s) (references @ other_references)\n+        in\n+        let references_markdown =\n+          match references_joined with\n+          | [] -> \"\"\n+          | xs -> \"\\n\\n<b>References:</b>\\n\" ^ String.concat \"\" xs\n+        in\n+        `Assoc\n+          ([\n+             (\"id\", `String (Rule_ID.to_string rule_id));\n+             (\"name\", `String (Rule_ID.to_string rule_id));\n+             (\"shortDescription\", `Assoc [ (\"text\", `String short_description) ]);\n+             (\"fullDescription\", `Assoc [ (\"text\", `String rule.message) ]);\n+             ( \"defaultConfiguration\",\n+               `Assoc\n+                 [\n+                   (\"level\", `String (sarif_severity_of_severity rule.severity));\n+                 ] );\n+             ( \"help\",\n+               `Assoc\n+                 [\n+                   (\"text\", `String (rule_help_text ^ text_suffix));\n+                   ( \"markdown\",\n+                     `String\n+                       (rule_help_text ^ markdown_interstitial\n+                      ^ references_markdown) );\n+                 ] );\n+             (\"properties\", `Assoc properties);\n+           ]\n+          @ rule_url))\n+      rules\n+  in\n+  List.of_seq rules\n+\n+let fixed_lines (cli_match : OutT.cli_match) fix =\n+  let lines = String.split_on_char '\\n' cli_match.extra.lines in\n+  match (lines, List.rev lines) with\n+  | line :: _, last_line :: _ ->\n+      let first_line_part = Str.first_chars line (cli_match.start.col - 1)\n+      and last_line_part =\n+        Str.string_after last_line (cli_match.end_.col - 1)\n+      in\n+      String.split_on_char '\\n' (first_line_part ^ fix ^ last_line_part)\n+  | [], _\n+  | _, [] ->\n+      assert false",
        "comment_created_at": "2024-01-17T19:22:53+00:00",
        "comment_author": "hannesm",
        "comment_body": "done in [3bf4518](https://github.com/semgrep/semgrep/pull/9608/commits/3bf45181dd39089747601288efc06bae41cb1fe0)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1446707154",
    "pr_number": 9551,
    "pr_file": "src/osemgrep/cli_scan/Scan_subcommand.ml",
    "created_at": "2024-01-09T22:59:28+00:00",
    "commented_code": "{ conf with core_runner_conf = { conf.core_runner_conf with num_jobs = 1 } })\n   else conf\n \n+let setup_repository url =\n+  let repository_path =\n+    url |> Git_wrapper.temporary_remote_checkout_path |> Option.get",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1446707154",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9551,
        "pr_file": "src/osemgrep/cli_scan/Scan_subcommand.ml",
        "discussion_id": "1446707154",
        "commented_code": "@@ -59,6 +59,17 @@ let setup_profiling (conf : Scan_CLI.conf) =\n     { conf with core_runner_conf = { conf.core_runner_conf with num_jobs = 1 } })\n   else conf\n \n+let setup_repository url =\n+  let repository_path =\n+    url |> Git_wrapper.temporary_remote_checkout_path |> Option.get",
        "comment_created_at": "2024-01-09T22:59:28+00:00",
        "comment_author": "kopecs",
        "comment_body": "Is it possible this raises? If it can't, could we just carry whatever information which proves it doesn't along instead? If it can, then I think this warrants error handling.",
        "pr_file_module": null
      },
      {
        "comment_id": "1447729220",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9551,
        "pr_file": "src/osemgrep/cli_scan/Scan_subcommand.ml",
        "discussion_id": "1446707154",
        "commented_code": "@@ -59,6 +59,17 @@ let setup_profiling (conf : Scan_CLI.conf) =\n     { conf with core_runner_conf = { conf.core_runner_conf with num_jobs = 1 } })\n   else conf\n \n+let setup_repository url =\n+  let repository_path =\n+    url |> Git_wrapper.temporary_remote_checkout_path |> Option.get",
        "comment_created_at": "2024-01-10T17:48:26+00:00",
        "comment_author": "ajbt200128",
        "comment_body": "Yea fair, I forgot to go back and fix this one from when I was prototyping, will do that",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1449308213",
    "pr_number": 9551,
    "pr_file": "src/targeting/Find_targets.ml",
    "created_at": "2024-01-11T19:34:04+00:00",
    "commented_code": "Some\n         (project_roots.scanning_roots\n         |> List.concat_map (fun (sc_root : Fppath.t) ->\n-               Git_wrapper.ls_files ~kinds:file_kinds [ sc_root.fpath ]\n+               let cwd = Rpath.to_fpath project.path in\n+               Git_wrapper.ls_files ~cwd ~kinds:file_kinds [ sc_root.fpath ]\n                |> List_.map (fun fpath ->\n                       let fpath_relative_to_scan_root =\n                         match Fpath.relativize ~root:sc_root.fpath fpath with\n                         | Some x -> x\n-                        | None -> assert false\n+                        | None ->\n+                            failwith\n+                              (Printf.sprintf \"failed to relativize %s to %s\"\n+                                 !!fpath !!(sc_root.fpath))",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1449308213",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9551,
        "pr_file": "src/targeting/Find_targets.ml",
        "discussion_id": "1449308213",
        "commented_code": "@@ -246,12 +257,16 @@ let git_list_files (file_kinds : Git_wrapper.ls_files_kind list)\n       Some\n         (project_roots.scanning_roots\n         |> List.concat_map (fun (sc_root : Fppath.t) ->\n-               Git_wrapper.ls_files ~kinds:file_kinds [ sc_root.fpath ]\n+               let cwd = Rpath.to_fpath project.path in\n+               Git_wrapper.ls_files ~cwd ~kinds:file_kinds [ sc_root.fpath ]\n                |> List_.map (fun fpath ->\n                       let fpath_relative_to_scan_root =\n                         match Fpath.relativize ~root:sc_root.fpath fpath with\n                         | Some x -> x\n-                        | None -> assert false\n+                        | None ->\n+                            failwith\n+                              (Printf.sprintf \"failed to relativize %s to %s\"\n+                                 !!fpath !!(sc_root.fpath))",
        "comment_created_at": "2024-01-11T19:34:04+00:00",
        "comment_author": "kopecs",
        "comment_body": "May warrant a comment that this is expected to never fail due to the ls_files.",
        "pr_file_module": null
      },
      {
        "comment_id": "1449384487",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9551,
        "pr_file": "src/targeting/Find_targets.ml",
        "discussion_id": "1449308213",
        "commented_code": "@@ -246,12 +257,16 @@ let git_list_files (file_kinds : Git_wrapper.ls_files_kind list)\n       Some\n         (project_roots.scanning_roots\n         |> List.concat_map (fun (sc_root : Fppath.t) ->\n-               Git_wrapper.ls_files ~kinds:file_kinds [ sc_root.fpath ]\n+               let cwd = Rpath.to_fpath project.path in\n+               Git_wrapper.ls_files ~cwd ~kinds:file_kinds [ sc_root.fpath ]\n                |> List_.map (fun fpath ->\n                       let fpath_relative_to_scan_root =\n                         match Fpath.relativize ~root:sc_root.fpath fpath with\n                         | Some x -> x\n-                        | None -> assert false\n+                        | None ->\n+                            failwith\n+                              (Printf.sprintf \"failed to relativize %s to %s\"\n+                                 !!fpath !!(sc_root.fpath))",
        "comment_created_at": "2024-01-11T20:55:53+00:00",
        "comment_author": "ajbt200128",
        "comment_body": "Yea I'm not sure if this never fails, I just updated the message to not be `assert false`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1398797778",
    "pr_number": 9288,
    "pr_file": "src/core_scan/Core_scan.ml",
    "created_at": "2023-11-20T08:22:38+00:00",
    "commented_code": "(* FIXME:\n                   Actually, I managed to get this assert to trigger by running\n                   semgrep -c p/default-v2 on elasticsearch with -timeout 0.01 ! *)\n-               | Time_limit.Timeout _ -> assert false\n+               | Time_limit.Timeout _ -> failwith \"Time limit exceeded\"",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1398797778",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9288,
        "pr_file": "src/core_scan/Core_scan.ml",
        "discussion_id": "1398797778",
        "commented_code": "@@ -574,7 +574,7 @@ let iter_targets_and_get_matches_and_exn_to_errors config\n                (* FIXME:\n                   Actually, I managed to get this assert to trigger by running\n                   semgrep -c p/default-v2 on elasticsearch with -timeout 0.01 ! *)\n-               | Time_limit.Timeout _ -> assert false\n+               | Time_limit.Timeout _ -> failwith \"Time limit exceeded\"",
        "comment_created_at": "2023-11-20T08:22:38+00:00",
        "comment_author": "aryx",
        "comment_body": "maybe add in the error \"(this should not happen, FIXME)\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1406811083",
    "pr_number": 9288,
    "pr_file": "libs/gitignore/Gitignore_filter.ml",
    "created_at": "2023-11-27T22:02:03+00:00",
    "commented_code": "let select t sel_events (full_git_path : Ppath.t) =\n   let rel_segments =\n     match Ppath.segments full_git_path with\n+    (* Remove empty line segment *)\n     | \"\" :: xs -> xs\n-    | __else__ -> assert false\n+    | \"/\" :: _ ->\n+        failwith\n+          (Printf.sprintf \"Gitignore: full_git_path %s not relative\"\n+             Ppath.(to_string full_git_path))",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1406811083",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9288,
        "pr_file": "libs/gitignore/Gitignore_filter.ml",
        "discussion_id": "1406811083",
        "commented_code": "@@ -99,8 +106,13 @@ let select_path opt_gitignore_file_cache sel_events levels relative_segments =\n let select t sel_events (full_git_path : Ppath.t) =\n   let rel_segments =\n     match Ppath.segments full_git_path with\n+    (* Remove empty line segment *)\n     | \"\" :: xs -> xs\n-    | __else__ -> assert false\n+    | \"/\" :: _ ->\n+        failwith\n+          (Printf.sprintf \"Gitignore: full_git_path %s not relative\"\n+             Ppath.(to_string full_git_path))",
        "comment_created_at": "2023-11-27T22:02:03+00:00",
        "comment_author": "mjambon",
        "comment_body": "Does this case indicate a bug in the program? If so, we should use the `Invalid_argument` exception which is raised with `invalid_arg` instead of `failwith`. It's like `assert false` but shifts the blame to the caller of the function. `failwith` (the `Failure` exception) is more when you're lazy and didn't bother to classify the error.",
        "pr_file_module": null
      },
      {
        "comment_id": "1406905162",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9288,
        "pr_file": "libs/gitignore/Gitignore_filter.ml",
        "discussion_id": "1406811083",
        "commented_code": "@@ -99,8 +106,13 @@ let select_path opt_gitignore_file_cache sel_events levels relative_segments =\n let select t sel_events (full_git_path : Ppath.t) =\n   let rel_segments =\n     match Ppath.segments full_git_path with\n+    (* Remove empty line segment *)\n     | \"\" :: xs -> xs\n-    | __else__ -> assert false\n+    | \"/\" :: _ ->\n+        failwith\n+          (Printf.sprintf \"Gitignore: full_git_path %s not relative\"\n+             Ppath.(to_string full_git_path))",
        "comment_created_at": "2023-11-27T23:45:15+00:00",
        "comment_author": "ajbt200128",
        "comment_body": "This was me trying to get a better error message instead of `assert false`. This was my interpretation of why this assert false existed before, but I wasn't sure. I can switch to Invalid_argument if you think that makes more sense, but I wasn't sure if that was the intention of the original assert false.",
        "pr_file_module": null
      }
    ]
  }
]