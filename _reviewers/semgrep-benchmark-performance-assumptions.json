[
  {
    "discussion_id": "1541997307",
    "pr_number": 10003,
    "pr_file": "libs/paths/Ppath.ml",
    "created_at": "2024-03-27T20:36:46+00:00",
    "commented_code": "*)\n let make_absolute path =\n   if Fpath.is_rel path then Fpath.(v (Unix.getcwd ()) // path)\n-  else (* save a syscall *)\n-    path\n+  else\n+    (* Here, we must make a syscall, bceause we are making an unnormalized path absolute\n+       so that we can compare it to a normalized path.\n+       However, in the presence of symlinks, certain relationships like prefixes and\n+       naive string operations do not work properly, because they are not cognizant of\n+       how certain paths are actually related on the filesystem.\n+       For instance, on Mac systems, `/var/` is actually the same as `/private/var`, so\n+       our absolute form for `/var/` would prefer to be `/private/var`.\n+       So we turn our path into an rpath. *)\n+    match Rpath.of_fpath path with\n+    | Ok path ->\n+        Rpath.to_fpath path\n+        (* Only warn here, since we don't guarantee Ppath exists  *)\n+    | Error err ->\n+        Logs.warn (fun m ->\n+            m \"Failed to make path %s absolute: %s\" (Fpath.to_string path) err);\n+        path",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1541997307",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10003,
        "pr_file": "libs/paths/Ppath.ml",
        "discussion_id": "1541997307",
        "commented_code": "@@ -246,8 +246,23 @@ let remove_prefix root path =\n *)\n let make_absolute path =\n   if Fpath.is_rel path then Fpath.(v (Unix.getcwd ()) // path)\n-  else (* save a syscall *)\n-    path\n+  else\n+    (* Here, we must make a syscall, bceause we are making an unnormalized path absolute\n+       so that we can compare it to a normalized path.\n+       However, in the presence of symlinks, certain relationships like prefixes and\n+       naive string operations do not work properly, because they are not cognizant of\n+       how certain paths are actually related on the filesystem.\n+       For instance, on Mac systems, `/var/` is actually the same as `/private/var`, so\n+       our absolute form for `/var/` would prefer to be `/private/var`.\n+       So we turn our path into an rpath. *)\n+    match Rpath.of_fpath path with\n+    | Ok path ->\n+        Rpath.to_fpath path\n+        (* Only warn here, since we don't guarantee Ppath exists  *)\n+    | Error err ->\n+        Logs.warn (fun m ->\n+            m \"Failed to make path %s absolute: %s\" (Fpath.to_string path) err);\n+        path",
        "comment_created_at": "2024-03-27T20:36:46+00:00",
        "comment_author": "mjambon",
        "comment_body": "We cannot afford to call `Unix.realpath` for each path because it's too slow. This needs to be done more carefully with solid safeguards.",
        "pr_file_module": null
      },
      {
        "comment_id": "1542019729",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10003,
        "pr_file": "libs/paths/Ppath.ml",
        "discussion_id": "1541997307",
        "commented_code": "@@ -246,8 +246,23 @@ let remove_prefix root path =\n *)\n let make_absolute path =\n   if Fpath.is_rel path then Fpath.(v (Unix.getcwd ()) // path)\n-  else (* save a syscall *)\n-    path\n+  else\n+    (* Here, we must make a syscall, bceause we are making an unnormalized path absolute\n+       so that we can compare it to a normalized path.\n+       However, in the presence of symlinks, certain relationships like prefixes and\n+       naive string operations do not work properly, because they are not cognizant of\n+       how certain paths are actually related on the filesystem.\n+       For instance, on Mac systems, `/var/` is actually the same as `/private/var`, so\n+       our absolute form for `/var/` would prefer to be `/private/var`.\n+       So we turn our path into an rpath. *)\n+    match Rpath.of_fpath path with\n+    | Ok path ->\n+        Rpath.to_fpath path\n+        (* Only warn here, since we don't guarantee Ppath exists  *)\n+    | Error err ->\n+        Logs.warn (fun m ->\n+            m \"Failed to make path %s absolute: %s\" (Fpath.to_string path) err);\n+        path",
        "comment_created_at": "2024-03-27T20:48:58+00:00",
        "comment_author": "kopecs",
        "comment_body": "> We cannot afford to call Unix.realpath for each path because it's too slow. \r\n\r\n\ud83d\ude15 doesn't the Argo benchmark above provide reasonable evidence to the contrary? If there's data to support that then we can re-evaluate but the data we do have seems to support that this doesn't particularly matter.",
        "pr_file_module": null
      },
      {
        "comment_id": "1558315308",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10003,
        "pr_file": "libs/paths/Ppath.ml",
        "discussion_id": "1541997307",
        "commented_code": "@@ -246,8 +246,23 @@ let remove_prefix root path =\n *)\n let make_absolute path =\n   if Fpath.is_rel path then Fpath.(v (Unix.getcwd ()) // path)\n-  else (* save a syscall *)\n-    path\n+  else\n+    (* Here, we must make a syscall, bceause we are making an unnormalized path absolute\n+       so that we can compare it to a normalized path.\n+       However, in the presence of symlinks, certain relationships like prefixes and\n+       naive string operations do not work properly, because they are not cognizant of\n+       how certain paths are actually related on the filesystem.\n+       For instance, on Mac systems, `/var/` is actually the same as `/private/var`, so\n+       our absolute form for `/var/` would prefer to be `/private/var`.\n+       So we turn our path into an rpath. *)\n+    match Rpath.of_fpath path with\n+    | Ok path ->\n+        Rpath.to_fpath path\n+        (* Only warn here, since we don't guarantee Ppath exists  *)\n+    | Error err ->\n+        Logs.warn (fun m ->\n+            m \"Failed to make path %s absolute: %s\" (Fpath.to_string path) err);\n+        path",
        "comment_created_at": "2024-04-09T21:28:20+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Yeah I agree with @kopecs here, we are running Semgrep with all free and Pro rules on 38 repos, and seeing no difference in perf wrt baseline, so clearly we can afford `Unix.realpath`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1508330325",
    "pr_number": 9837,
    "pr_file": "src/core_scan/Report_pro_findings.ml",
    "created_at": "2024-03-01T00:09:31+00:00",
    "commented_code": "+(*****************************************************************************)\n+(* Purpose *)\n+(*****************************************************************************)\n+(** Support the reporting of pro findings\n+\n+  * Users want to know when a finding could only be found by the pro engine\n+  * so that they can understand the value Semgrep provides. Additionally,\n+  * we want to surface our \"coolest\" findings early to make sure users see\n+  * them.\n+\n+  * To support this, we have a different type for the engine kind for matches,\n+  * which includes a `PRO_SPECIFIC` option that reports when a finding could\n+  * only be found using the pro engine. This option also allows us to highlight\n+  * findings we think users should prioritize.\n+  *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(* Check if the taint trace of the pattern crosses functions or files *)\n+\n+let tokens_of_trace_item (trace_item : Pattern_match.taint_trace_item) =\n+  let rec tokens_of_call_trace (call_trace : Pattern_match.taint_call_trace) =\n+    match call_trace with\n+    | Toks ts -> ts\n+    | Call { call_toks; intermediate_vars; call_trace } ->\n+        call_toks @ intermediate_vars @ tokens_of_call_trace call_trace\n+  in\n+  tokens_of_call_trace trace_item.source_trace\n+  @ tokens_of_call_trace trace_item.sink_trace\n+  @ trace_item.tokens\n+\n+let is_interfile_trace (trace : Pattern_match.taint_trace) =\n+  let trace_tokens = trace |> List.concat_map tokens_of_trace_item in",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1508330325",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9837,
        "pr_file": "src/core_scan/Report_pro_findings.ml",
        "discussion_id": "1508330325",
        "commented_code": "@@ -0,0 +1,90 @@\n+(*****************************************************************************)\n+(* Purpose *)\n+(*****************************************************************************)\n+(** Support the reporting of pro findings\n+\n+  * Users want to know when a finding could only be found by the pro engine\n+  * so that they can understand the value Semgrep provides. Additionally,\n+  * we want to surface our \"coolest\" findings early to make sure users see\n+  * them.\n+\n+  * To support this, we have a different type for the engine kind for matches,\n+  * which includes a `PRO_SPECIFIC` option that reports when a finding could\n+  * only be found using the pro engine. This option also allows us to highlight\n+  * findings we think users should prioritize.\n+  *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(* Check if the taint trace of the pattern crosses functions or files *)\n+\n+let tokens_of_trace_item (trace_item : Pattern_match.taint_trace_item) =\n+  let rec tokens_of_call_trace (call_trace : Pattern_match.taint_call_trace) =\n+    match call_trace with\n+    | Toks ts -> ts\n+    | Call { call_toks; intermediate_vars; call_trace } ->\n+        call_toks @ intermediate_vars @ tokens_of_call_trace call_trace\n+  in\n+  tokens_of_call_trace trace_item.source_trace\n+  @ tokens_of_call_trace trace_item.sink_trace\n+  @ trace_item.tokens\n+\n+let is_interfile_trace (trace : Pattern_match.taint_trace) =\n+  let trace_tokens = trace |> List.concat_map tokens_of_trace_item in",
        "comment_created_at": "2024-03-01T00:09:31+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "This feels potentially inefficient? You could iterate through the call trace without constructing the list of all the `trace_tokens` and then constructing a new list with all the filenames ? At the least, you could directly get the list of filenames without going through the tokens, and it could be a `Set` so you don't keep duplicates.",
        "pr_file_module": null
      },
      {
        "comment_id": "1508388325",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9837,
        "pr_file": "src/core_scan/Report_pro_findings.ml",
        "discussion_id": "1508330325",
        "commented_code": "@@ -0,0 +1,90 @@\n+(*****************************************************************************)\n+(* Purpose *)\n+(*****************************************************************************)\n+(** Support the reporting of pro findings\n+\n+  * Users want to know when a finding could only be found by the pro engine\n+  * so that they can understand the value Semgrep provides. Additionally,\n+  * we want to surface our \"coolest\" findings early to make sure users see\n+  * them.\n+\n+  * To support this, we have a different type for the engine kind for matches,\n+  * which includes a `PRO_SPECIFIC` option that reports when a finding could\n+  * only be found using the pro engine. This option also allows us to highlight\n+  * findings we think users should prioritize.\n+  *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(* Check if the taint trace of the pattern crosses functions or files *)\n+\n+let tokens_of_trace_item (trace_item : Pattern_match.taint_trace_item) =\n+  let rec tokens_of_call_trace (call_trace : Pattern_match.taint_call_trace) =\n+    match call_trace with\n+    | Toks ts -> ts\n+    | Call { call_toks; intermediate_vars; call_trace } ->\n+        call_toks @ intermediate_vars @ tokens_of_call_trace call_trace\n+  in\n+  tokens_of_call_trace trace_item.source_trace\n+  @ tokens_of_call_trace trace_item.sink_trace\n+  @ trace_item.tokens\n+\n+let is_interfile_trace (trace : Pattern_match.taint_trace) =\n+  let trace_tokens = trace |> List.concat_map tokens_of_trace_item in",
        "comment_created_at": "2024-03-01T01:43:20+00:00",
        "comment_author": "emjin",
        "comment_body": "Good call; I didn't think the cost mattered, but it clearly does",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1480529151",
    "pr_number": 9715,
    "pr_file": "src/core_cli/Core_command.ml",
    "created_at": "2024-02-06T20:54:45+00:00",
    "commented_code": "( Rule_options.default_config,\n                        Core_scan.parse_equivalences config.equivalences_file )\n                      minirule\n-                     (Fpath.v file, lang, ast)\n+                     (Fpath.v file, File (Fpath.v file), lang, ast)",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1480529151",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "src/core_cli/Core_command.ml",
        "discussion_id": "1480529151",
        "commented_code": "@@ -210,7 +211,7 @@ let semgrep_core_with_one_pattern (config : Core_scan_config.t) : unit =\n                      ( Rule_options.default_config,\n                        Core_scan.parse_equivalences config.equivalences_file )\n                      minirule\n-                     (Fpath.v file, lang, ast)\n+                     (Fpath.v file, File (Fpath.v file), lang, ast)",
        "comment_created_at": "2024-02-06T20:54:45+00:00",
        "comment_author": "mjambon",
        "comment_body": "Call `Fpath.v` as little as possible. It's an expensive operation, unlike `Fpath.to_string`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1481934854",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "src/core_cli/Core_command.ml",
        "discussion_id": "1480529151",
        "commented_code": "@@ -210,7 +211,7 @@ let semgrep_core_with_one_pattern (config : Core_scan_config.t) : unit =\n                      ( Rule_options.default_config,\n                        Core_scan.parse_equivalences config.equivalences_file )\n                      minirule\n-                     (Fpath.v file, lang, ast)\n+                     (Fpath.v file, File (Fpath.v file), lang, ast)",
        "comment_created_at": "2024-02-07T18:47:37+00:00",
        "comment_author": "kopecs",
        "comment_body": "Done in ed375e0a88c5792bb6c349ccaaf056254ad846ce; see also https://github.com/semgrep/semgrep/pull/9715/files/2193eb567fd8c8fc924cb989e1726c2602275a44#r1481932234 as is relevant more generally.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1409399589",
    "pr_number": 9342,
    "pr_file": "src/tainting/Dataflow_tainting.ml",
    "created_at": "2023-11-29T14:50:21+00:00",
    "commented_code": "if findings <> [] then\n     env.config.handle_findings env.fun_name findings env.lval_env\n \n-(* Checks whether the sink corresponds has the shape\n+(* TODO: Add `exact: true` option to sinks so one can skip this heuristic, and\n+ * it could be a good default for \"syntax 2.0\". The current behavior could be\n+ * `exact: compat`, and the old behavior could be `exact: false`. *)\n+(* Checks whether the sink corresponds has essentially the shape\n  *\n  *     patterns:\n  *     - pattern: <func>(<args>)\n  *     - focus-metavariable: $MVAR\n  *\n+ * or, more generally, a shape like\n+ *\n+ *     patterns:\n+ *     - pattern-either:\n+ *       - patterns:\n+ *         - pattern-inside: |\n+ *             <P>\n+ *         - pattern: <func>(<args>)\n+ *       - ...\n+ *     - focus-metavariable: $MVAR\n+ *\n  * In which case we know that the function call itself is not the sink, but\n- * either the <func> or one (or more) of the <args>.\n+ * it is either the <func> or one (or more) of the <args>.\n  *)\n let is_func_sink_with_focus taint_sink =",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1409399589",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9342,
        "pr_file": "src/tainting/Dataflow_tainting.ml",
        "discussion_id": "1409399589",
        "commented_code": "@@ -245,25 +245,61 @@ let report_findings env findings =\n   if findings <> [] then\n     env.config.handle_findings env.fun_name findings env.lval_env\n \n-(* Checks whether the sink corresponds has the shape\n+(* TODO: Add `exact: true` option to sinks so one can skip this heuristic, and\n+ * it could be a good default for \"syntax 2.0\". The current behavior could be\n+ * `exact: compat`, and the old behavior could be `exact: false`. *)\n+(* Checks whether the sink corresponds has essentially the shape\n  *\n  *     patterns:\n  *     - pattern: <func>(<args>)\n  *     - focus-metavariable: $MVAR\n  *\n+ * or, more generally, a shape like\n+ *\n+ *     patterns:\n+ *     - pattern-either:\n+ *       - patterns:\n+ *         - pattern-inside: |\n+ *             <P>\n+ *         - pattern: <func>(<args>)\n+ *       - ...\n+ *     - focus-metavariable: $MVAR\n+ *\n  * In which case we know that the function call itself is not the sink, but\n- * either the <func> or one (or more) of the <args>.\n+ * it is either the <func> or one (or more) of the <args>.\n  *)\n let is_func_sink_with_focus taint_sink =",
        "comment_created_at": "2023-11-29T14:50:21+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Hmmm, we should instead compute this during parse-time and cache it, so we don't need to recompute this condition every time. There is a small slowdown showing up in the benchmarks that could be due to this.",
        "pr_file_module": null
      },
      {
        "comment_id": "1411317131",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9342,
        "pr_file": "src/tainting/Dataflow_tainting.ml",
        "discussion_id": "1409399589",
        "commented_code": "@@ -245,25 +245,61 @@ let report_findings env findings =\n   if findings <> [] then\n     env.config.handle_findings env.fun_name findings env.lval_env\n \n-(* Checks whether the sink corresponds has the shape\n+(* TODO: Add `exact: true` option to sinks so one can skip this heuristic, and\n+ * it could be a good default for \"syntax 2.0\". The current behavior could be\n+ * `exact: compat`, and the old behavior could be `exact: false`. *)\n+(* Checks whether the sink corresponds has essentially the shape\n  *\n  *     patterns:\n  *     - pattern: <func>(<args>)\n  *     - focus-metavariable: $MVAR\n  *\n+ * or, more generally, a shape like\n+ *\n+ *     patterns:\n+ *     - pattern-either:\n+ *       - patterns:\n+ *         - pattern-inside: |\n+ *             <P>\n+ *         - pattern: <func>(<args>)\n+ *       - ...\n+ *     - focus-metavariable: $MVAR\n+ *\n  * In which case we know that the function call itself is not the sink, but\n- * either the <func> or one (or more) of the <args>.\n+ * it is either the <func> or one (or more) of the <args>.\n  *)\n let is_func_sink_with_focus taint_sink =",
        "comment_created_at": "2023-11-30T21:58:50+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Done it, although perf seems the same. There is certainly a bunch of noise. So I picked 4 repos that showed a slowdown in two runs of the benchmarks and I'm running a comparison locally without Docker.",
        "pr_file_module": null
      }
    ]
  }
]