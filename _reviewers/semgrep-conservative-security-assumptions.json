[
  {
    "discussion_id": "1334018716",
    "pr_number": 8690,
    "pr_file": "changelog.d/pa-3054.added",
    "created_at": "2023-09-22T07:51:56+00:00",
    "commented_code": "+Try-catch-else-finally is now supported in taint analysis.\n+\n+This kind of statement is supported in languages including Python, Ruby, and Julia.\n+\n+Python example:\n+\n+```py\n+def f(tainted_input):\n+  try:\n+    a = 0\n+    b = 0\n+    c = tainted_input\n+    d = tainted_input\n+  except RuntimeError:\n+    a = tainted_input\n+    c = sanitize(c)\n+  else:\n+    b = tainted_input\n+  finally:\n+    d = sanitize(d)\n+\n+  # a is not tainted because exception wasn't thrown",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1334018716",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "changelog.d/pa-3054.added",
        "discussion_id": "1334018716",
        "commented_code": "@@ -0,0 +1,32 @@\n+Try-catch-else-finally is now supported in taint analysis.\n+\n+This kind of statement is supported in languages including Python, Ruby, and Julia.\n+\n+Python example:\n+\n+```py\n+def f(tainted_input):\n+  try:\n+    a = 0\n+    b = 0\n+    c = tainted_input\n+    d = tainted_input\n+  except RuntimeError:\n+    a = tainted_input\n+    c = sanitize(c)\n+  else:\n+    b = tainted_input\n+  finally:\n+    d = sanitize(d)\n+\n+  # a is not tainted because exception wasn't thrown",
        "comment_created_at": "2023-09-22T07:51:56+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "For any arbitrary code, how do you know that no exception was thrown?",
        "pr_file_module": null
      },
      {
        "comment_id": "1334234027",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "changelog.d/pa-3054.added",
        "discussion_id": "1334018716",
        "commented_code": "@@ -0,0 +1,32 @@\n+Try-catch-else-finally is now supported in taint analysis.\n+\n+This kind of statement is supported in languages including Python, Ruby, and Julia.\n+\n+Python example:\n+\n+```py\n+def f(tainted_input):\n+  try:\n+    a = 0\n+    b = 0\n+    c = tainted_input\n+    d = tainted_input\n+  except RuntimeError:\n+    a = tainted_input\n+    c = sanitize(c)\n+  else:\n+    b = tainted_input\n+  finally:\n+    d = sanitize(d)\n+\n+  # a is not tainted because exception wasn't thrown",
        "comment_created_at": "2023-09-22T11:04:36+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "If there is a potential path for `a` to get tainted (and that seems to be the case) then it should be tainted, since it's a may-analysis. But I also don't clearly see why this `a` is not tainted here based on the code, need to check the tests you wrote too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1334270776",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "changelog.d/pa-3054.added",
        "discussion_id": "1334018716",
        "commented_code": "@@ -0,0 +1,32 @@\n+Try-catch-else-finally is now supported in taint analysis.\n+\n+This kind of statement is supported in languages including Python, Ruby, and Julia.\n+\n+Python example:\n+\n+```py\n+def f(tainted_input):\n+  try:\n+    a = 0\n+    b = 0\n+    c = tainted_input\n+    d = tainted_input\n+  except RuntimeError:\n+    a = tainted_input\n+    c = sanitize(c)\n+  else:\n+    b = tainted_input\n+  finally:\n+    d = sanitize(d)\n+\n+  # a is not tainted because exception wasn't thrown",
        "comment_created_at": "2023-09-22T11:42:44+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Could you point me where in the code we ensure that `a` he isn't tainted?",
        "pr_file_module": null
      },
      {
        "comment_id": "1335242682",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 8690,
        "pr_file": "changelog.d/pa-3054.added",
        "discussion_id": "1334018716",
        "commented_code": "@@ -0,0 +1,32 @@\n+Try-catch-else-finally is now supported in taint analysis.\n+\n+This kind of statement is supported in languages including Python, Ruby, and Julia.\n+\n+Python example:\n+\n+```py\n+def f(tainted_input):\n+  try:\n+    a = 0\n+    b = 0\n+    c = tainted_input\n+    d = tainted_input\n+  except RuntimeError:\n+    a = tainted_input\n+    c = sanitize(c)\n+  else:\n+    b = tainted_input\n+  finally:\n+    d = sanitize(d)\n+\n+  # a is not tainted because exception wasn't thrown",
        "comment_created_at": "2023-09-24T20:43:36+00:00",
        "comment_author": "amchiclet",
        "comment_body": "Based on your other comment, I believe you found the code, but happy to discuss more if you have any questions.\r\n\r\nI've added a bit more details in the changelog to make it clearer what assumptions are updated in this change.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1530700239",
    "pr_number": 9961,
    "pr_file": "src/rpc/RPC.mli",
    "created_at": "2024-03-19T16:17:35+00:00",
    "commented_code": "+(* Runs an RPC server that takes calls on stdin and sends results to stdout. *)\n+val main : Cap.all_caps -> unit",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1530700239",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9961,
        "pr_file": "src/rpc/RPC.mli",
        "discussion_id": "1530700239",
        "commented_code": "@@ -0,0 +1,2 @@\n+(* Runs an RPC server that takes calls on stdin and sends results to stdout. *)\n+val main : Cap.all_caps -> unit",
        "comment_created_at": "2024-03-19T16:17:35+00:00",
        "comment_author": "aryx",
        "comment_body": "you can actually pass all_caps here, but then restrict it for the callback, so for example don't pass the stdin/stdout capability to the callback so we're sure they can't interfere.",
        "pr_file_module": null
      },
      {
        "comment_id": "1530722108",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9961,
        "pr_file": "src/rpc/RPC.mli",
        "discussion_id": "1530700239",
        "commented_code": "@@ -0,0 +1,2 @@\n+(* Runs an RPC server that takes calls on stdin and sends results to stdout. *)\n+val main : Cap.all_caps -> unit",
        "comment_created_at": "2024-03-19T16:32:20+00:00",
        "comment_author": "nmote",
        "comment_body": "Yeah, right now we don't actually plumb any caps down (but we should, since we're writing to the filesystem!), but we will definitely want to restrict them once we do.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1424778078",
    "pr_number": 9434,
    "pr_file": "libs/alcotest_ext/lib/Tag.ml",
    "created_at": "2023-12-13T02:37:53+00:00",
    "commented_code": "+(*\n+   Test tags\n+*)\n+\n+open Printf\n+\n+type t = (* private *) string\n+\n+let compare = String.compare\n+let equal = String.equal\n+let show x = x\n+let to_string x = x\n+\n+(*\n+   The tag syntax is a dot-separated identifier similar to pytest markers.\n+   coupling: update the error message below when changing this syntax\n+*)\n+let tag_syntax = {|\\A[a-z_][a-z_0-9]*(?:[.][a-z_][a-z_0-9]*)*\\z|}\n+\n+let has_valid_tag_syntax =\n+  (* We use the same regexp library as Alcotest to facilitate\n+     future integration efforts. *)\n+  let re = Re.Pcre.regexp tag_syntax in\n+  fun tag -> Re.execp re tag\n+\n+let check_tag_syntax tag =\n+  if not (has_valid_tag_syntax tag) then\n+    invalid_arg\n+      (sprintf\n+         \"Alcotest_ext.declare_tag: invalid syntax for test tag %S.\n\\\n+          It must be a dot-separated sequence of one or more lowercase \\\n+          alphanumeric\n\\\n+          identifiers e.g. \\\"foo_bar.v2.todo\\\" . It must match the following \\\n+          regexp:\n\\\n+         \\  %s\" tag tag_syntax)\n+\n+(* no duplicates are allowed *)\n+let declared_tags : (t, unit) Hashtbl.t = Hashtbl.create 100",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1424781839",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9434,
        "pr_file": "libs/alcotest_ext/lib/Tag.ml",
        "discussion_id": "1424778078",
        "commented_code": "@@ -0,0 +1,53 @@\n+(*\n+   Test tags\n+*)\n+\n+open Printf\n+\n+type t = (* private *) string\n+\n+let compare = String.compare\n+let equal = String.equal\n+let show x = x\n+let to_string x = x\n+\n+(*\n+   The tag syntax is a dot-separated identifier similar to pytest markers.\n+   coupling: update the error message below when changing this syntax\n+*)\n+let tag_syntax = {|\\A[a-z_][a-z_0-9]*(?:[.][a-z_][a-z_0-9]*)*\\z|}\n+\n+let has_valid_tag_syntax =\n+  (* We use the same regexp library as Alcotest to facilitate\n+     future integration efforts. *)\n+  let re = Re.Pcre.regexp tag_syntax in\n+  fun tag -> Re.execp re tag\n+\n+let check_tag_syntax tag =\n+  if not (has_valid_tag_syntax tag) then\n+    invalid_arg\n+      (sprintf\n+         \"Alcotest_ext.declare_tag: invalid syntax for test tag %S.\\n\\\n+          It must be a dot-separated sequence of one or more lowercase \\\n+          alphanumeric\\n\\\n+          identifiers e.g. \\\"foo_bar.v2.todo\\\" . It must match the following \\\n+          regexp:\\n\\\n+         \\  %s\" tag tag_syntax)\n+\n+(* no duplicates are allowed *)\n+let declared_tags : (t, unit) Hashtbl.t = Hashtbl.create 100",
        "comment_created_at": "2023-12-13T02:37:53+00:00",
        "comment_author": "mjambon",
        "comment_body": "DoS vulnerabilities are irrelevant since we're not running a service. Calls to the `semgrep` command should be wrapped in a timeout.",
        "pr_file_module": null
      }
    ]
  }
]