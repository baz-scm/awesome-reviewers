[
  {
    "discussion_id": "1416353171",
    "pr_number": 9382,
    "pr_file": "cli/src/semgrep/commands/ci.py",
    "created_at": "2023-12-05T22:31:02+00:00",
    "commented_code": "state.error_handler.configure(suppress_errors)\n     scan_handler = None\n \n+    if allow_untrusted_validators and not run_secrets_flag:\n+        logger.debug(\n+            \"Implicity enable secrets validation since allow_untrusted_validators is set.\"\n+        )\n+        run_secrets_flag = True\n+\n     token = state.app_session.token\n     if not token and not config:\n         # Not logged in and no explicit config\n         logger.info(\"run `semgrep login` before using `semgrep ci` or set `--config`\")\n         sys.exit(INVALID_API_KEY_EXIT_CODE)\n     elif not token and config:\n         # Not logged in but has explicit config\n-        pass\n+        if run_secrets_flag:",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1416353171",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9382,
        "pr_file": "cli/src/semgrep/commands/ci.py",
        "discussion_id": "1416353171",
        "commented_code": "@@ -223,14 +223,23 @@ def ci(\n     state.error_handler.configure(suppress_errors)\n     scan_handler = None\n \n+    if allow_untrusted_validators and not run_secrets_flag:\n+        logger.debug(\n+            \"Implicity enable secrets validation since allow_untrusted_validators is set.\"\n+        )\n+        run_secrets_flag = True\n+\n     token = state.app_session.token\n     if not token and not config:\n         # Not logged in and no explicit config\n         logger.info(\"run `semgrep login` before using `semgrep ci` or set `--config`\")\n         sys.exit(INVALID_API_KEY_EXIT_CODE)\n     elif not token and config:\n         # Not logged in but has explicit config\n-        pass\n+        if run_secrets_flag:",
        "comment_created_at": "2023-12-05T22:31:02+00:00",
        "comment_author": "kopecs",
        "comment_body": "Thoughts on exiting with a message (similar to prior case) instead of just disabling and continuing the run?",
        "pr_file_module": null
      },
      {
        "comment_id": "1416462185",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9382,
        "pr_file": "cli/src/semgrep/commands/ci.py",
        "discussion_id": "1416353171",
        "commented_code": "@@ -223,14 +223,23 @@ def ci(\n     state.error_handler.configure(suppress_errors)\n     scan_handler = None\n \n+    if allow_untrusted_validators and not run_secrets_flag:\n+        logger.debug(\n+            \"Implicity enable secrets validation since allow_untrusted_validators is set.\"\n+        )\n+        run_secrets_flag = True\n+\n     token = state.app_session.token\n     if not token and not config:\n         # Not logged in and no explicit config\n         logger.info(\"run `semgrep login` before using `semgrep ci` or set `--config`\")\n         sys.exit(INVALID_API_KEY_EXIT_CODE)\n     elif not token and config:\n         # Not logged in but has explicit config\n-        pass\n+        if run_secrets_flag:",
        "comment_created_at": "2023-12-06T00:21:33+00:00",
        "comment_author": "salolivares",
        "comment_body": "The idea here was to sorta do what the playground does and still run the rules without any validation. Basically keep this:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 1 Unvalidated Secrets Finding \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nBut I'm open to just refusing to run any rules with a validator when a user is not logged in. Any thoughts here @leifdreizler or @LewisArdern?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1537994978",
    "pr_number": 9872,
    "pr_file": "cli/src/semgrep/engine.py",
    "created_at": "2024-03-25T17:48:34+00:00",
    "commented_code": "@classmethod\n     def decide_engine_type(\n         cls,\n-        requested_engine: Optional[\"EngineType\"] = None,\n+        logged_in: bool = False,\n+        engine_flag: Optional[\"EngineType\"] = None,\n+        run_secrets: bool = False,\n+        interfile_diff_scan_enabled: bool = False,\n+        # ci-only args\n         scan_handler: Optional[ScanHandler] = None,\n         git_meta: Optional[GitMeta] = None,\n-        run_secrets: bool = False,\n-        enable_pro_diff_scan: bool = False,\n         supply_chain_only: bool = False,\n     ) -> \"EngineType\":\n         \"\"\"Select which Semgrep engine type to use if none is explicitly requested.\n \n         Considers settings from Semgrep Cloud Platform and version control state.\n         \"\"\"\n-        # Change default to pro-engine intrafile if secrets was requested.\n-        # Secrets is built into pro-engine, but any pro-setting should work.\n-        if (\n-            not (scan_handler and scan_handler.deepsemgrep)\n-            and requested_engine is None\n-            and run_secrets\n-        ):\n-            requested_engine = cls.PRO_LANG\n-        elif run_secrets and requested_engine is cls.OSS:\n-            # Should be impossible if the CLI gates impossible arguement combinations.\n-            raise SemgrepError(\"Semgrep Secrets is not part of the open source engine\")\n+        interfile_is_requested_via_app = scan_handler and scan_handler.deepsemgrep\n \n-        if git_meta and scan_handler:\n-            if scan_handler.deepsemgrep and requested_engine is None:\n+        requested_engine = engine_flag\n+        if engine_flag is None:\n+            if interfile_is_requested_via_app:\n                 requested_engine = cls.PRO_INTERFILE\n-\n-            if (\n-                requested_engine == cls.PRO_INTERFILE\n-                and not git_meta.is_full_scan\n-                and not enable_pro_diff_scan\n-            ):\n+            elif run_secrets:\n                 requested_engine = cls.PRO_INTRAFILE\n \n-        # Using PRO_LANG engine since PRO_INTERFILE/PRO_INTRAFILE defaults to -j 1\n-        # note if using OSS, then will keep using OSS\n+        if run_secrets and engine_flag is cls.OSS:\n+            # Should be impossible if the CLI gates impossible argument combinations.\n+            # TODO Can we delete this check?\n+            raise SemgrepError(\"Semgrep Secrets is not part of the open source engine\")\n+\n+        diff_scan = git_meta and not git_meta.is_full_scan\n         if (\n-            requested_engine in {cls.PRO_INTERFILE, cls.PRO_INTRAFILE}\n-            and supply_chain_only\n+            diff_scan\n+            and not interfile_diff_scan_enabled\n+            and requested_engine is cls.PRO_INTERFILE\n         ):\n-            logger.info(\n-                \"Running only supply chain rules so running without extra interfile analysis\"\n-            )\n-            return cls.PRO_LANG\n+            requested_engine = cls.PRO_INTRAFILE\n+\n+        # Hack: Turn off the PRO_INTERFILE engine when only supply chain is requested\n+        # This is necessary because PRO_INTERFILE defaults to `-j 1`\n+        if supply_chain_only and requested_engine is cls.PRO_INTERFILE:\n+            requested_engine = cls.PRO_INTRAFILE\n \n-        return requested_engine or cls.OSS\n+        # TODO: should we fail here if logged_in is false and requested_engine is not cls.OSS?\n+\n+        # `logged_in and ci_scan_handler` is redundant because `ci_scan_handler` requires\n+        # being logged in, but let's check this defensively",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1537994978",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9872,
        "pr_file": "cli/src/semgrep/engine.py",
        "discussion_id": "1537994978",
        "commented_code": "@@ -33,52 +33,54 @@ class EngineType(Enum):\n     @classmethod\n     def decide_engine_type(\n         cls,\n-        requested_engine: Optional[\"EngineType\"] = None,\n+        logged_in: bool = False,\n+        engine_flag: Optional[\"EngineType\"] = None,\n+        run_secrets: bool = False,\n+        interfile_diff_scan_enabled: bool = False,\n+        # ci-only args\n         scan_handler: Optional[ScanHandler] = None,\n         git_meta: Optional[GitMeta] = None,\n-        run_secrets: bool = False,\n-        enable_pro_diff_scan: bool = False,\n         supply_chain_only: bool = False,\n     ) -> \"EngineType\":\n         \"\"\"Select which Semgrep engine type to use if none is explicitly requested.\n \n         Considers settings from Semgrep Cloud Platform and version control state.\n         \"\"\"\n-        # Change default to pro-engine intrafile if secrets was requested.\n-        # Secrets is built into pro-engine, but any pro-setting should work.\n-        if (\n-            not (scan_handler and scan_handler.deepsemgrep)\n-            and requested_engine is None\n-            and run_secrets\n-        ):\n-            requested_engine = cls.PRO_LANG\n-        elif run_secrets and requested_engine is cls.OSS:\n-            # Should be impossible if the CLI gates impossible arguement combinations.\n-            raise SemgrepError(\"Semgrep Secrets is not part of the open source engine\")\n+        interfile_is_requested_via_app = scan_handler and scan_handler.deepsemgrep\n \n-        if git_meta and scan_handler:\n-            if scan_handler.deepsemgrep and requested_engine is None:\n+        requested_engine = engine_flag\n+        if engine_flag is None:\n+            if interfile_is_requested_via_app:\n                 requested_engine = cls.PRO_INTERFILE\n-\n-            if (\n-                requested_engine == cls.PRO_INTERFILE\n-                and not git_meta.is_full_scan\n-                and not enable_pro_diff_scan\n-            ):\n+            elif run_secrets:\n                 requested_engine = cls.PRO_INTRAFILE\n \n-        # Using PRO_LANG engine since PRO_INTERFILE/PRO_INTRAFILE defaults to -j 1\n-        # note if using OSS, then will keep using OSS\n+        if run_secrets and engine_flag is cls.OSS:\n+            # Should be impossible if the CLI gates impossible argument combinations.\n+            # TODO Can we delete this check?\n+            raise SemgrepError(\"Semgrep Secrets is not part of the open source engine\")\n+\n+        diff_scan = git_meta and not git_meta.is_full_scan\n         if (\n-            requested_engine in {cls.PRO_INTERFILE, cls.PRO_INTRAFILE}\n-            and supply_chain_only\n+            diff_scan\n+            and not interfile_diff_scan_enabled\n+            and requested_engine is cls.PRO_INTERFILE\n         ):\n-            logger.info(\n-                \"Running only supply chain rules so running without extra interfile analysis\"\n-            )\n-            return cls.PRO_LANG\n+            requested_engine = cls.PRO_INTRAFILE\n+\n+        # Hack: Turn off the PRO_INTERFILE engine when only supply chain is requested\n+        # This is necessary because PRO_INTERFILE defaults to `-j 1`\n+        if supply_chain_only and requested_engine is cls.PRO_INTERFILE:\n+            requested_engine = cls.PRO_INTRAFILE\n \n-        return requested_engine or cls.OSS\n+        # TODO: should we fail here if logged_in is false and requested_engine is not cls.OSS?\n+\n+        # `logged_in and ci_scan_handler` is redundant because `ci_scan_handler` requires\n+        # being logged in, but let's check this defensively",
        "comment_created_at": "2024-03-25T17:48:34+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "Why do we need to be defensive about `scan_handler`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1538375662",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9872,
        "pr_file": "cli/src/semgrep/engine.py",
        "discussion_id": "1537994978",
        "commented_code": "@@ -33,52 +33,54 @@ class EngineType(Enum):\n     @classmethod\n     def decide_engine_type(\n         cls,\n-        requested_engine: Optional[\"EngineType\"] = None,\n+        logged_in: bool = False,\n+        engine_flag: Optional[\"EngineType\"] = None,\n+        run_secrets: bool = False,\n+        interfile_diff_scan_enabled: bool = False,\n+        # ci-only args\n         scan_handler: Optional[ScanHandler] = None,\n         git_meta: Optional[GitMeta] = None,\n-        run_secrets: bool = False,\n-        enable_pro_diff_scan: bool = False,\n         supply_chain_only: bool = False,\n     ) -> \"EngineType\":\n         \"\"\"Select which Semgrep engine type to use if none is explicitly requested.\n \n         Considers settings from Semgrep Cloud Platform and version control state.\n         \"\"\"\n-        # Change default to pro-engine intrafile if secrets was requested.\n-        # Secrets is built into pro-engine, but any pro-setting should work.\n-        if (\n-            not (scan_handler and scan_handler.deepsemgrep)\n-            and requested_engine is None\n-            and run_secrets\n-        ):\n-            requested_engine = cls.PRO_LANG\n-        elif run_secrets and requested_engine is cls.OSS:\n-            # Should be impossible if the CLI gates impossible arguement combinations.\n-            raise SemgrepError(\"Semgrep Secrets is not part of the open source engine\")\n+        interfile_is_requested_via_app = scan_handler and scan_handler.deepsemgrep\n \n-        if git_meta and scan_handler:\n-            if scan_handler.deepsemgrep and requested_engine is None:\n+        requested_engine = engine_flag\n+        if engine_flag is None:\n+            if interfile_is_requested_via_app:\n                 requested_engine = cls.PRO_INTERFILE\n-\n-            if (\n-                requested_engine == cls.PRO_INTERFILE\n-                and not git_meta.is_full_scan\n-                and not enable_pro_diff_scan\n-            ):\n+            elif run_secrets:\n                 requested_engine = cls.PRO_INTRAFILE\n \n-        # Using PRO_LANG engine since PRO_INTERFILE/PRO_INTRAFILE defaults to -j 1\n-        # note if using OSS, then will keep using OSS\n+        if run_secrets and engine_flag is cls.OSS:\n+            # Should be impossible if the CLI gates impossible argument combinations.\n+            # TODO Can we delete this check?\n+            raise SemgrepError(\"Semgrep Secrets is not part of the open source engine\")\n+\n+        diff_scan = git_meta and not git_meta.is_full_scan\n         if (\n-            requested_engine in {cls.PRO_INTERFILE, cls.PRO_INTRAFILE}\n-            and supply_chain_only\n+            diff_scan\n+            and not interfile_diff_scan_enabled\n+            and requested_engine is cls.PRO_INTERFILE\n         ):\n-            logger.info(\n-                \"Running only supply chain rules so running without extra interfile analysis\"\n-            )\n-            return cls.PRO_LANG\n+            requested_engine = cls.PRO_INTRAFILE\n+\n+        # Hack: Turn off the PRO_INTERFILE engine when only supply chain is requested\n+        # This is necessary because PRO_INTERFILE defaults to `-j 1`\n+        if supply_chain_only and requested_engine is cls.PRO_INTERFILE:\n+            requested_engine = cls.PRO_INTRAFILE\n \n-        return requested_engine or cls.OSS\n+        # TODO: should we fail here if logged_in is false and requested_engine is not cls.OSS?\n+\n+        # `logged_in and ci_scan_handler` is redundant because `ci_scan_handler` requires\n+        # being logged in, but let's check this defensively",
        "comment_created_at": "2024-03-25T23:51:26+00:00",
        "comment_author": "emjin",
        "comment_body": "Fleshed out the comment. Basically I want to separate the concerns of \"is this a ci scan?\" and \"is this a logged in scan?\". In particular, I wouldn't want someone to change how `scan_handler` works and then accidentally allow logged out pro scans. This is not possible right now for various reasons but I want to be explicit since it's kind of important.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1538052392",
    "pr_number": 9872,
    "pr_file": "cli/tests/default/unit/test_engine_type.py",
    "created_at": "2024-03-25T18:22:33+00:00",
    "commented_code": "from semgrep.app.scans import ScanHandler\n from semgrep.engine import EngineType as ET\n+from semgrep.error import SemgrepError\n from semgrep.meta import GitMeta\n \n \n @pytest.mark.quick\n+@pytest.mark.parametrize(\"is_supply_chain_only\", [True, False])\n+@pytest.mark.parametrize(\"is_secrets_scan\", [True, False])\n @pytest.mark.parametrize(\n-    (\"is_cloud_flag_on\", \"is_ci_scan_full\", \"enable_pro_diff\", \"requested\", \"expected\"),\n+    \"engine_flag\", [None, ET.OSS, ET.PRO_LANG, ET.PRO_INTRAFILE, ET.PRO_INTERFILE]\n+)\n+@pytest.mark.parametrize(\n+    (\n+        \"logged_in\",\n+        \"is_interfile_flag_on\",\n+        \"is_ci_scan_full\",\n+        \"interfile_diff_scan_enabled\",\n+        \"expected_default\",\n+    ),\n     [\n+        # These combinations define the expected engine for Code scans when no\n+        # engine is explicitly requested via a CLI argument. Requesting the engine\n+        # in the CLI or running Secrets or Supply Chain may change the engine used.\n+        #\n+        # We assume some invariants and thus don't test them:\n+        # - not logged_in -> is_interfile_flag_on is None, is_ci_scan_full is None\n+        # - is_interfile_flag_on is None -> is_ci_scan_full is None\n+        #\n         # semgrep scan\n-        (False, None, False, None, ET.OSS),\n-        (False, None, False, ET.OSS, ET.OSS),\n-        (False, None, False, ET.PRO_LANG, ET.PRO_LANG),\n-        (False, None, False, ET.PRO_INTRAFILE, ET.PRO_INTRAFILE),\n-        (False, None, False, ET.PRO_INTERFILE, ET.PRO_INTERFILE),\n+        (False, None, None, False, ET.OSS),\n+        (False, None, None, True, ET.OSS),\n+        (True, None, None, False, ET.OSS),\n+        (True, None, None, True, ET.OSS),\n+        # semgrep ci, not logged in",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1538052392",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9872,
        "pr_file": "cli/tests/default/unit/test_engine_type.py",
        "discussion_id": "1538052392",
        "commented_code": "@@ -2,79 +2,127 @@\n \n from semgrep.app.scans import ScanHandler\n from semgrep.engine import EngineType as ET\n+from semgrep.error import SemgrepError\n from semgrep.meta import GitMeta\n \n \n @pytest.mark.quick\n+@pytest.mark.parametrize(\"is_supply_chain_only\", [True, False])\n+@pytest.mark.parametrize(\"is_secrets_scan\", [True, False])\n @pytest.mark.parametrize(\n-    (\"is_cloud_flag_on\", \"is_ci_scan_full\", \"enable_pro_diff\", \"requested\", \"expected\"),\n+    \"engine_flag\", [None, ET.OSS, ET.PRO_LANG, ET.PRO_INTRAFILE, ET.PRO_INTERFILE]\n+)\n+@pytest.mark.parametrize(\n+    (\n+        \"logged_in\",\n+        \"is_interfile_flag_on\",\n+        \"is_ci_scan_full\",\n+        \"interfile_diff_scan_enabled\",\n+        \"expected_default\",\n+    ),\n     [\n+        # These combinations define the expected engine for Code scans when no\n+        # engine is explicitly requested via a CLI argument. Requesting the engine\n+        # in the CLI or running Secrets or Supply Chain may change the engine used.\n+        #\n+        # We assume some invariants and thus don't test them:\n+        # - not logged_in -> is_interfile_flag_on is None, is_ci_scan_full is None\n+        # - is_interfile_flag_on is None -> is_ci_scan_full is None\n+        #\n         # semgrep scan\n-        (False, None, False, None, ET.OSS),\n-        (False, None, False, ET.OSS, ET.OSS),\n-        (False, None, False, ET.PRO_LANG, ET.PRO_LANG),\n-        (False, None, False, ET.PRO_INTRAFILE, ET.PRO_INTRAFILE),\n-        (False, None, False, ET.PRO_INTERFILE, ET.PRO_INTERFILE),\n+        (False, None, None, False, ET.OSS),\n+        (False, None, None, True, ET.OSS),\n+        (True, None, None, False, ET.OSS),\n+        (True, None, None, True, ET.OSS),\n+        # semgrep ci, not logged in",
        "comment_created_at": "2024-03-25T18:22:33+00:00",
        "comment_author": "IagoAbal",
        "comment_body": "I thought one needed to be logged in to even do anything with `semgrep ci`, since the rules etc need to come from the App.",
        "pr_file_module": null
      },
      {
        "comment_id": "1538301057",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9872,
        "pr_file": "cli/tests/default/unit/test_engine_type.py",
        "discussion_id": "1538052392",
        "commented_code": "@@ -2,79 +2,127 @@\n \n from semgrep.app.scans import ScanHandler\n from semgrep.engine import EngineType as ET\n+from semgrep.error import SemgrepError\n from semgrep.meta import GitMeta\n \n \n @pytest.mark.quick\n+@pytest.mark.parametrize(\"is_supply_chain_only\", [True, False])\n+@pytest.mark.parametrize(\"is_secrets_scan\", [True, False])\n @pytest.mark.parametrize(\n-    (\"is_cloud_flag_on\", \"is_ci_scan_full\", \"enable_pro_diff\", \"requested\", \"expected\"),\n+    \"engine_flag\", [None, ET.OSS, ET.PRO_LANG, ET.PRO_INTRAFILE, ET.PRO_INTERFILE]\n+)\n+@pytest.mark.parametrize(\n+    (\n+        \"logged_in\",\n+        \"is_interfile_flag_on\",\n+        \"is_ci_scan_full\",\n+        \"interfile_diff_scan_enabled\",\n+        \"expected_default\",\n+    ),\n     [\n+        # These combinations define the expected engine for Code scans when no\n+        # engine is explicitly requested via a CLI argument. Requesting the engine\n+        # in the CLI or running Secrets or Supply Chain may change the engine used.\n+        #\n+        # We assume some invariants and thus don't test them:\n+        # - not logged_in -> is_interfile_flag_on is None, is_ci_scan_full is None\n+        # - is_interfile_flag_on is None -> is_ci_scan_full is None\n+        #\n         # semgrep scan\n-        (False, None, False, None, ET.OSS),\n-        (False, None, False, ET.OSS, ET.OSS),\n-        (False, None, False, ET.PRO_LANG, ET.PRO_LANG),\n-        (False, None, False, ET.PRO_INTRAFILE, ET.PRO_INTRAFILE),\n-        (False, None, False, ET.PRO_INTERFILE, ET.PRO_INTERFILE),\n+        (False, None, None, False, ET.OSS),\n+        (False, None, None, True, ET.OSS),\n+        (True, None, None, False, ET.OSS),\n+        (True, None, None, True, ET.OSS),\n+        # semgrep ci, not logged in",
        "comment_created_at": "2024-03-25T22:19:06+00:00",
        "comment_author": "emjin",
        "comment_body": "Nope! From `ci.py`:\r\n```\r\n    if not token and not config:\r\n        # Not logged in and no explicit config\r\n        logger.info(\r\n            \"run `semgrep login` before using `semgrep ci` or use `semgrep scan` and set `--config`\"\r\n        )\r\n        sys.exit(INVALID_API_KEY_EXIT_CODE)\r\n    elif not token and config:\r\n        # Not logged in but has explicit config\r\n        pass\r\n```\r\n\r\nThe second condition explicitly allows `semgrep ci` with no token but `--config`. (Note that if you do pass a token, you aren't allowed to give it `--config`, and we ask them to log out instead. I suspect we are going to want to change this behavior but that's very out of scope.)",
        "pr_file_module": null
      }
    ]
  }
]