[
  {
    "discussion_id": "1866311456",
    "pr_number": 10702,
    "pr_file": "src/osemgrep/language_server/server/Lsp_.ml",
    "created_at": "2024-12-02T17:39:56+00:00",
    "commented_code": "in\n   let request, _id = request progress in\n   let start =\n-    SN.Progress.Begin (WorkDoneProgressBegin.create ~message ~title ())\n+    Lsp.Progress.Begin (WorkDoneProgressBegin.create ~message ~title ())",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1866311456",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10702,
        "pr_file": "src/osemgrep/language_server/server/Lsp_.ml",
        "discussion_id": "1866311456",
        "commented_code": "@@ -130,7 +130,7 @@ let create_progress title message =\n   in\n   let request, _id = request progress in\n   let start =\n-    SN.Progress.Begin (WorkDoneProgressBegin.create ~message ~title ())\n+    Lsp.Progress.Begin (WorkDoneProgressBegin.create ~message ~title ())",
        "comment_created_at": "2024-12-02T17:39:56+00:00",
        "comment_author": "kopecs",
        "comment_body": "```suggestion\r\n   Progress.Begin (WorkDoneProgressBegin.create ~message ~title ())\r\n```\r\nWe `open Lsp` already so this can just be `Progress`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1719137183",
    "pr_number": 10448,
    "pr_file": "languages/move_on_aptos/generic/Parse_move_on_aptos_tree_sitter.ml",
    "created_at": "2024-08-16T00:07:55+00:00",
    "commented_code": "G.Arg (G.L (G.Bool (false, tok)) |> G.e)\n                | None -> G.Arg (G.L (G.Bool (true, sc)) |> G.e)\n              in\n-             let specifier =\n+             let tk, specifier =\n                match v2 with\n-               | `Acquis tok -> (* \"acquires\" *) str env tok\n-               | `Reads tok -> (* \"reads\" *) str env tok\n-               | `Writes tok -> (* \"writes\" *) str env tok\n+               | `Acquis tok -> (token env tok, (* \"acquires\" *) str env tok)\n+               | `Reads tok -> (token env tok, (* \"reads\" *) str env tok)\n+               | `Writes tok -> (token env tok, (* \"writes\" *) str env tok)",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1719137183",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10448,
        "pr_file": "languages/move_on_aptos/generic/Parse_move_on_aptos_tree_sitter.ml",
        "discussion_id": "1719137183",
        "commented_code": "@@ -1105,18 +1137,18 @@ let map_specifier (env : env) (x : CST.specifier) : G.attribute list =\n                    G.Arg (G.L (G.Bool (false, tok)) |> G.e)\n                | None -> G.Arg (G.L (G.Bool (true, sc)) |> G.e)\n              in\n-             let specifier =\n+             let tk, specifier =\n                match v2 with\n-               | `Acquis tok -> (* \"acquires\" *) str env tok\n-               | `Reads tok -> (* \"reads\" *) str env tok\n-               | `Writes tok -> (* \"writes\" *) str env tok\n+               | `Acquis tok -> (token env tok, (* \"acquires\" *) str env tok)\n+               | `Reads tok -> (token env tok, (* \"reads\" *) str env tok)\n+               | `Writes tok -> (token env tok, (* \"writes\" *) str env tok)",
        "comment_created_at": "2024-08-16T00:07:55+00:00",
        "comment_author": "nmote",
        "comment_body": "`str` just returns `string * Tok.t`, where the second item is just the result of a call to `token`. You can simplify this by removing the call to `token` and just calling `snd specifier` where needed (or destructuring the tuple if you prefer)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1397754041",
    "pr_number": 9284,
    "pr_file": "src/osemgrep/reporting/Summary_report.ml",
    "created_at": "2023-11-17T19:05:49+00:00",
    "commented_code": "*)\n   let out_limited =\n     if respect_git_ignore then\n-      (* # Each target could be a git repo, and we respect the git ignore\n-         # of each target, so to be accurate with this print statement we\n-         # need to check if any target is a git repo and not just the cwd\n-         targets_not_in_git = 0\n-         dir_targets = 0\n-         for t in self.target_manager.targets:\n-             if t.path.is_dir():\n-                 dir_targets += 1\n-                 try:\n-                     t.files_from_git_ls()\n-                 except (subprocess.SubprocessError, FileNotFoundError):\n-                     targets_not_in_git += 1\n-                     continue\n-         if targets_not_in_git != dir_targets: *)\n-      Some \"Scan was limited to files tracked by git.\"\n+      let any_git_repos = find_git_dir target_roots in\n+      match any_git_repos with\n+      | Some _ -> Some \"Scan was limited to files tracked by git.\"",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1397754041",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9284,
        "pr_file": "src/osemgrep/reporting/Summary_report.ml",
        "discussion_id": "1397754041",
        "commented_code": "@@ -37,21 +58,10 @@ let pp_summary ppf\n   *)\n   let out_limited =\n     if respect_git_ignore then\n-      (* # Each target could be a git repo, and we respect the git ignore\n-         # of each target, so to be accurate with this print statement we\n-         # need to check if any target is a git repo and not just the cwd\n-         targets_not_in_git = 0\n-         dir_targets = 0\n-         for t in self.target_manager.targets:\n-             if t.path.is_dir():\n-                 dir_targets += 1\n-                 try:\n-                     t.files_from_git_ls()\n-                 except (subprocess.SubprocessError, FileNotFoundError):\n-                     targets_not_in_git += 1\n-                     continue\n-         if targets_not_in_git != dir_targets: *)\n-      Some \"Scan was limited to files tracked by git.\"\n+      let any_git_repos = find_git_dir target_roots in\n+      match any_git_repos with\n+      | Some _ -> Some \"Scan was limited to files tracked by git.\"",
        "comment_created_at": "2023-11-17T19:05:49+00:00",
        "comment_author": "emjin",
        "comment_body": "Do you use the value in the Some at all? If not, this could just be a boolean (in which case you can use `List.exists`)",
        "pr_file_module": null
      },
      {
        "comment_id": "1397789646",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9284,
        "pr_file": "src/osemgrep/reporting/Summary_report.ml",
        "discussion_id": "1397754041",
        "commented_code": "@@ -37,21 +58,10 @@ let pp_summary ppf\n   *)\n   let out_limited =\n     if respect_git_ignore then\n-      (* # Each target could be a git repo, and we respect the git ignore\n-         # of each target, so to be accurate with this print statement we\n-         # need to check if any target is a git repo and not just the cwd\n-         targets_not_in_git = 0\n-         dir_targets = 0\n-         for t in self.target_manager.targets:\n-             if t.path.is_dir():\n-                 dir_targets += 1\n-                 try:\n-                     t.files_from_git_ls()\n-                 except (subprocess.SubprocessError, FileNotFoundError):\n-                     targets_not_in_git += 1\n-                     continue\n-         if targets_not_in_git != dir_targets: *)\n-      Some \"Scan was limited to files tracked by git.\"\n+      let any_git_repos = find_git_dir target_roots in\n+      match any_git_repos with\n+      | Some _ -> Some \"Scan was limited to files tracked by git.\"",
        "comment_created_at": "2023-11-17T19:39:59+00:00",
        "comment_author": "zzeleznick",
        "comment_body": "I kept this in for debugging ease \u2013 but I can remove",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1593005443",
    "pr_number": 10216,
    "pr_file": "src/parsing/Parse_rule.ml",
    "created_at": "2024-05-07T20:05:53+00:00",
    "commented_code": "let response = take_key validator_dict env parse_http_response \"response\" in\n   HTTP { request; response }\n \n-let parse_validator key env value =\n-  let rd = yaml_to_dict env key value in\n-  let http = take_opt rd env parse_http_validator \"http\" in\n-  match http with\n-  | Some validator -> validator\n-  | None ->\n+let parse_aws_request env key value : Rule.aws_request = \n+  let request_dict = yaml_to_dict env key value in\n+  let secret_access_key = take_key request_dict env parse_string \"secret_access_key\" in\n+  let access_key_id = take_key request_dict env parse_string \"access_key_id\" in\n+  let region = take_key request_dict env parse_string \"region\" in\n+  { secret_access_key; access_key_id; region }\n+\n+let parse_aws_validator env key value : Rule.validator = \n+  let validator_dict = yaml_to_dict env key value in\n+  let request = take_key validator_dict env parse_aws_request \"request\" in\n+  let response = take_key validator_dict env parse_http_response \"response\" in\n+  AWS { request; response }\n+\n+\n+\n+let parse_validator_kind env key value =\n+  let dict = yaml_to_dict env key value in\n+  match List_.find_some_opt (Hashtbl.find_opt dict.h) [\"http\";\"aws\"] with\n+    | Some ((\"http\", _), value) -> `HTTP (key, value)\n+    | Some ((\"aws\", _), value) -> `AWS (key, value)\n+    | Some _ | None -> \n+      (* The [Some _] case here should be impossible *)\n       error_at_key env.id key\n-        (\"No reconigzed validator (e.g., 'http') at \" ^ fst key)\n+    (\"No recognized validator, must be one of ['http', 'aws'] at \" ^ fst key)\n \n+let parse_validator key env value =\n+  match parse_validator_kind env key value with\n+    | `HTTP (key, value) -> parse_http_validator env key value\n+    | `AWS (key, value) -> parse_aws_validator env key value",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1593005443",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10216,
        "pr_file": "src/parsing/Parse_rule.ml",
        "discussion_id": "1593005443",
        "commented_code": "@@ -714,15 +714,36 @@ let parse_http_validator env key value : Rule.validator =\n   let response = take_key validator_dict env parse_http_response \"response\" in\n   HTTP { request; response }\n \n-let parse_validator key env value =\n-  let rd = yaml_to_dict env key value in\n-  let http = take_opt rd env parse_http_validator \"http\" in\n-  match http with\n-  | Some validator -> validator\n-  | None ->\n+let parse_aws_request env key value : Rule.aws_request = \n+  let request_dict = yaml_to_dict env key value in\n+  let secret_access_key = take_key request_dict env parse_string \"secret_access_key\" in\n+  let access_key_id = take_key request_dict env parse_string \"access_key_id\" in\n+  let region = take_key request_dict env parse_string \"region\" in\n+  { secret_access_key; access_key_id; region }\n+\n+let parse_aws_validator env key value : Rule.validator = \n+  let validator_dict = yaml_to_dict env key value in\n+  let request = take_key validator_dict env parse_aws_request \"request\" in\n+  let response = take_key validator_dict env parse_http_response \"response\" in\n+  AWS { request; response }\n+\n+\n+\n+let parse_validator_kind env key value =\n+  let dict = yaml_to_dict env key value in\n+  match List_.find_some_opt (Hashtbl.find_opt dict.h) [\"http\";\"aws\"] with\n+    | Some ((\"http\", _), value) -> `HTTP (key, value)\n+    | Some ((\"aws\", _), value) -> `AWS (key, value)\n+    | Some _ | None -> \n+      (* The [Some _] case here should be impossible *)\n       error_at_key env.id key\n-        (\"No reconigzed validator (e.g., 'http') at \" ^ fst key)\n+    (\"No recognized validator, must be one of ['http', 'aws'] at \" ^ fst key)\n \n+let parse_validator key env value =\n+  match parse_validator_kind env key value with\n+    | `HTTP (key, value) -> parse_http_validator env key value\n+    | `AWS (key, value) -> parse_aws_validator env key value",
        "comment_created_at": "2024-05-07T20:05:53+00:00",
        "comment_author": "kopecs",
        "comment_body": "Any reason to the the polymorphic variant and then call `parse_*_validator` here instead of just doing that in the above match?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1543853897",
    "pr_number": 9919,
    "pr_file": "src/engine/Eval_generic.ml",
    "created_at": "2024-03-28T23:54:03+00:00",
    "commented_code": "* alt: let s = value_to_string v in\n      * to convert anything in a string before using regexps on it\n   *)\n-  let regexp = Regexp_engine.pcre_compile_with_flags ~flags:[ `ANCHORED ] re in\n+  let regexp = Legacy_regex.regexp ~flags:[ `ANCHORED ] re in\n   let matches =\n-    Xpattern_match_regexp.regexp_matcher ~base_offset str file regexp\n+    (* TODO: just Xpattern_match_regexp.regexp_matcher but with Legacy_regex *)\n+    let subs = Legacy_regex.exec_all_noerr ~rex:regexp str in\n+    subs |> Array.to_list\n+    |> List_.map (fun sub ->\n+           (* Below, we add `base_offset` to any instance of `bytepos`, because\n+              the `bytepos` we obtain is only within the range of the string\n+              being searched, which may itself be offset from a larger file.\n+\n+              By maintaining this base offset, we can accurately recreate the\n+              original line/col, at minimum cost.\n+           *)\n+           let matched_str = Pcre.get_substring sub 0 in\n+           let bytepos, _ = Pcre.get_substring_ofs sub 0 in\n+           let bytepos = bytepos + base_offset in\n+           let str = matched_str in\n+           let line, column =\n+             Xpattern_matcher.line_col_of_charpos file bytepos\n+           in\n+           let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+           let loc1 = { Tok.str; pos } in\n+\n+           let bytepos = bytepos + String.length str in\n+           let str = \"\" in\n+           let line, column =\n+             Xpattern_matcher.line_col_of_charpos file bytepos\n+           in\n+           let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+           let loc2 = { Tok.str; pos } in\n+\n+           (* the names of all capture groups within the regexp *)\n+           let names = Pcre.names regexp.regexp |> Array.to_list in\n+           (* return regexp bound group $1 $2 etc *)\n+           let n = Pcre.num_of_subs sub in\n+           (* TODO: remove when we kill numeric capture groups *)\n+           let numbers_env =\n+             match n with\n+             | 1 -> []\n+             | _ when n <= 0 -> raise Impossible\n+             | n ->\n+                 List_.enum 1 (n - 1)\n+                 |> List_.map_filter (fun n ->\n+                        try\n+                          let bytepos, _ = Pcre.get_substring_ofs sub n in\n+                          let str = Pcre.get_substring sub n in\n+                          let line, column =\n+                            Xpattern_matcher.line_col_of_charpos file bytepos\n+                          in\n+                          let pos =\n+                            Pos.make ~file:!!file ~line ~column bytepos\n+                          in\n+                          let loc = { Tok.str; pos } in\n+                          let t = Tok.tok_of_loc loc in\n+                          Some (spf \"$%d\" n, MV.Text (str, t, t))\n+                        with\n+                        | Not_found ->\n+                            Logs.debug (fun m ->\n+                                m ~tags \"not found %d substring of %s in %s\" n\n+                                  regexp.pattern matched_str);\n+                            None)\n+           in\n+           let names_env =\n+             names\n+             |> List_.map_filter (fun name ->\n+                    try\n+                      (* TODO: make exception-free versions of the missing\n+                         functions in SPcre. *)\n+                      let bytepos, _ =\n+                        Pcre.get_named_substring_ofs regexp.regexp name sub\n+                      in\n+                      let bytepos = bytepos + base_offset in\n+                      let str =\n+                        Pcre.get_named_substring regexp.regexp name sub\n+                      in\n+                      let line, column =\n+                        Xpattern_matcher.line_col_of_charpos file bytepos\n+                      in\n+                      let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+                      let loc = { Tok.str; pos } in\n+                      let t = Tok.tok_of_loc loc in\n+                      Some (spf \"$%s\" name, MV.Text (str, t, t))\n+                    with\n+                    | Not_found ->\n+                        Logs.debug (fun m ->\n+                            m ~tags \"not found %s substring of %s in %s\" name\n+                              regexp.pattern matched_str);\n+                        None)\n+           in\n+           ((loc1, loc2), names_env @ numbers_env))",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1543853897",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9919,
        "pr_file": "src/engine/Eval_generic.ml",
        "discussion_id": "1543853897",
        "commented_code": "@@ -229,9 +230,96 @@ let eval_regexp_matches ?(base_offset = 0) ~file ~regexp:re str =\n      * alt: let s = value_to_string v in\n      * to convert anything in a string before using regexps on it\n   *)\n-  let regexp = Regexp_engine.pcre_compile_with_flags ~flags:[ `ANCHORED ] re in\n+  let regexp = Legacy_regex.regexp ~flags:[ `ANCHORED ] re in\n   let matches =\n-    Xpattern_match_regexp.regexp_matcher ~base_offset str file regexp\n+    (* TODO: just Xpattern_match_regexp.regexp_matcher but with Legacy_regex *)\n+    let subs = Legacy_regex.exec_all_noerr ~rex:regexp str in\n+    subs |> Array.to_list\n+    |> List_.map (fun sub ->\n+           (* Below, we add `base_offset` to any instance of `bytepos`, because\n+              the `bytepos` we obtain is only within the range of the string\n+              being searched, which may itself be offset from a larger file.\n+\n+              By maintaining this base offset, we can accurately recreate the\n+              original line/col, at minimum cost.\n+           *)\n+           let matched_str = Pcre.get_substring sub 0 in\n+           let bytepos, _ = Pcre.get_substring_ofs sub 0 in\n+           let bytepos = bytepos + base_offset in\n+           let str = matched_str in\n+           let line, column =\n+             Xpattern_matcher.line_col_of_charpos file bytepos\n+           in\n+           let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+           let loc1 = { Tok.str; pos } in\n+\n+           let bytepos = bytepos + String.length str in\n+           let str = \"\" in\n+           let line, column =\n+             Xpattern_matcher.line_col_of_charpos file bytepos\n+           in\n+           let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+           let loc2 = { Tok.str; pos } in\n+\n+           (* the names of all capture groups within the regexp *)\n+           let names = Pcre.names regexp.regexp |> Array.to_list in\n+           (* return regexp bound group $1 $2 etc *)\n+           let n = Pcre.num_of_subs sub in\n+           (* TODO: remove when we kill numeric capture groups *)\n+           let numbers_env =\n+             match n with\n+             | 1 -> []\n+             | _ when n <= 0 -> raise Impossible\n+             | n ->\n+                 List_.enum 1 (n - 1)\n+                 |> List_.map_filter (fun n ->\n+                        try\n+                          let bytepos, _ = Pcre.get_substring_ofs sub n in\n+                          let str = Pcre.get_substring sub n in\n+                          let line, column =\n+                            Xpattern_matcher.line_col_of_charpos file bytepos\n+                          in\n+                          let pos =\n+                            Pos.make ~file:!!file ~line ~column bytepos\n+                          in\n+                          let loc = { Tok.str; pos } in\n+                          let t = Tok.tok_of_loc loc in\n+                          Some (spf \"$%d\" n, MV.Text (str, t, t))\n+                        with\n+                        | Not_found ->\n+                            Logs.debug (fun m ->\n+                                m ~tags \"not found %d substring of %s in %s\" n\n+                                  regexp.pattern matched_str);\n+                            None)\n+           in\n+           let names_env =\n+             names\n+             |> List_.map_filter (fun name ->\n+                    try\n+                      (* TODO: make exception-free versions of the missing\n+                         functions in SPcre. *)\n+                      let bytepos, _ =\n+                        Pcre.get_named_substring_ofs regexp.regexp name sub\n+                      in\n+                      let bytepos = bytepos + base_offset in\n+                      let str =\n+                        Pcre.get_named_substring regexp.regexp name sub\n+                      in\n+                      let line, column =\n+                        Xpattern_matcher.line_col_of_charpos file bytepos\n+                      in\n+                      let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+                      let loc = { Tok.str; pos } in\n+                      let t = Tok.tok_of_loc loc in\n+                      Some (spf \"$%s\" name, MV.Text (str, t, t))\n+                    with\n+                    | Not_found ->\n+                        Logs.debug (fun m ->\n+                            m ~tags \"not found %s substring of %s in %s\" name\n+                              regexp.pattern matched_str);\n+                        None)\n+           in\n+           ((loc1, loc2), names_env @ numbers_env))",
        "comment_created_at": "2024-03-28T23:54:03+00:00",
        "comment_author": "mjambon",
        "comment_body": "Is this whole block duplicated? Can we avoid it since it's not trivial? It could be done by passing a record or a first-class module containing the regexp functions as a parameter to `Xpattern_match_regexp.regexp_matcher`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1544837699",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9919,
        "pr_file": "src/engine/Eval_generic.ml",
        "discussion_id": "1543853897",
        "commented_code": "@@ -229,9 +230,96 @@ let eval_regexp_matches ?(base_offset = 0) ~file ~regexp:re str =\n      * alt: let s = value_to_string v in\n      * to convert anything in a string before using regexps on it\n   *)\n-  let regexp = Regexp_engine.pcre_compile_with_flags ~flags:[ `ANCHORED ] re in\n+  let regexp = Legacy_regex.regexp ~flags:[ `ANCHORED ] re in\n   let matches =\n-    Xpattern_match_regexp.regexp_matcher ~base_offset str file regexp\n+    (* TODO: just Xpattern_match_regexp.regexp_matcher but with Legacy_regex *)\n+    let subs = Legacy_regex.exec_all_noerr ~rex:regexp str in\n+    subs |> Array.to_list\n+    |> List_.map (fun sub ->\n+           (* Below, we add `base_offset` to any instance of `bytepos`, because\n+              the `bytepos` we obtain is only within the range of the string\n+              being searched, which may itself be offset from a larger file.\n+\n+              By maintaining this base offset, we can accurately recreate the\n+              original line/col, at minimum cost.\n+           *)\n+           let matched_str = Pcre.get_substring sub 0 in\n+           let bytepos, _ = Pcre.get_substring_ofs sub 0 in\n+           let bytepos = bytepos + base_offset in\n+           let str = matched_str in\n+           let line, column =\n+             Xpattern_matcher.line_col_of_charpos file bytepos\n+           in\n+           let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+           let loc1 = { Tok.str; pos } in\n+\n+           let bytepos = bytepos + String.length str in\n+           let str = \"\" in\n+           let line, column =\n+             Xpattern_matcher.line_col_of_charpos file bytepos\n+           in\n+           let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+           let loc2 = { Tok.str; pos } in\n+\n+           (* the names of all capture groups within the regexp *)\n+           let names = Pcre.names regexp.regexp |> Array.to_list in\n+           (* return regexp bound group $1 $2 etc *)\n+           let n = Pcre.num_of_subs sub in\n+           (* TODO: remove when we kill numeric capture groups *)\n+           let numbers_env =\n+             match n with\n+             | 1 -> []\n+             | _ when n <= 0 -> raise Impossible\n+             | n ->\n+                 List_.enum 1 (n - 1)\n+                 |> List_.map_filter (fun n ->\n+                        try\n+                          let bytepos, _ = Pcre.get_substring_ofs sub n in\n+                          let str = Pcre.get_substring sub n in\n+                          let line, column =\n+                            Xpattern_matcher.line_col_of_charpos file bytepos\n+                          in\n+                          let pos =\n+                            Pos.make ~file:!!file ~line ~column bytepos\n+                          in\n+                          let loc = { Tok.str; pos } in\n+                          let t = Tok.tok_of_loc loc in\n+                          Some (spf \"$%d\" n, MV.Text (str, t, t))\n+                        with\n+                        | Not_found ->\n+                            Logs.debug (fun m ->\n+                                m ~tags \"not found %d substring of %s in %s\" n\n+                                  regexp.pattern matched_str);\n+                            None)\n+           in\n+           let names_env =\n+             names\n+             |> List_.map_filter (fun name ->\n+                    try\n+                      (* TODO: make exception-free versions of the missing\n+                         functions in SPcre. *)\n+                      let bytepos, _ =\n+                        Pcre.get_named_substring_ofs regexp.regexp name sub\n+                      in\n+                      let bytepos = bytepos + base_offset in\n+                      let str =\n+                        Pcre.get_named_substring regexp.regexp name sub\n+                      in\n+                      let line, column =\n+                        Xpattern_matcher.line_col_of_charpos file bytepos\n+                      in\n+                      let pos = Pos.make ~file:!!file ~line ~column bytepos in\n+                      let loc = { Tok.str; pos } in\n+                      let t = Tok.tok_of_loc loc in\n+                      Some (spf \"$%s\" name, MV.Text (str, t, t))\n+                    with\n+                    | Not_found ->\n+                        Logs.debug (fun m ->\n+                            m ~tags \"not found %s substring of %s in %s\" name\n+                              regexp.pattern matched_str);\n+                        None)\n+           in\n+           ((loc1, loc2), names_env @ numbers_env))",
        "comment_created_at": "2024-03-29T20:19:43+00:00",
        "comment_author": "kopecs",
        "comment_body": "Yes, I was a bit hesitant to add a first class module, but I do think that's better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1529181484",
    "pr_number": 9942,
    "pr_file": "src/osemgrep/cli_scan/Scan_CLI.ml",
    "created_at": "2024-03-18T19:51:51+00:00",
    "commented_code": "| Some root, None ->\n           Some (Find_targets.Filesystem (Rfpath.of_string_exn root))\n       | None, Some url when is_git_repo url ->\n-          let checkout_path =\n-            match !Semgrep_envvars.v.remote_clone_dir with\n-            | Some dir -> Rfpath.of_fpath_exn dir\n-            | None ->\n-                Git_wrapper.temporary_remote_checkout_path caps url\n-                |> Rfpath.of_fpath_exn\n-          in\n+          (* CWD must be empty for this to work *)\n+          let has_files = List_files.list (Fpath.v \".\") <> [] in",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1529181484",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9942,
        "pr_file": "src/osemgrep/cli_scan/Scan_CLI.ml",
        "discussion_id": "1529181484",
        "commented_code": "@@ -898,15 +898,14 @@ let cmdline_term caps ~allow_empty_config : conf Term.t =\n       | Some root, None ->\n           Some (Find_targets.Filesystem (Rfpath.of_string_exn root))\n       | None, Some url when is_git_repo url ->\n-          let checkout_path =\n-            match !Semgrep_envvars.v.remote_clone_dir with\n-            | Some dir -> Rfpath.of_fpath_exn dir\n-            | None ->\n-                Git_wrapper.temporary_remote_checkout_path caps url\n-                |> Rfpath.of_fpath_exn\n-          in\n+          (* CWD must be empty for this to work *)\n+          let has_files = List_files.list (Fpath.v \".\") <> [] in",
        "comment_created_at": "2024-03-18T19:51:51+00:00",
        "comment_author": "kopecs",
        "comment_body": "```suggestion\r\n          let has_files = not @@ List_.null @@ List_files.list (Fpath.v \".\") in\r\n```\r\nwould rather avoid polymorphic (dis)equality.",
        "pr_file_module": null
      },
      {
        "comment_id": "1529353710",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9942,
        "pr_file": "src/osemgrep/cli_scan/Scan_CLI.ml",
        "discussion_id": "1529181484",
        "commented_code": "@@ -898,15 +898,14 @@ let cmdline_term caps ~allow_empty_config : conf Term.t =\n       | Some root, None ->\n           Some (Find_targets.Filesystem (Rfpath.of_string_exn root))\n       | None, Some url when is_git_repo url ->\n-          let checkout_path =\n-            match !Semgrep_envvars.v.remote_clone_dir with\n-            | Some dir -> Rfpath.of_fpath_exn dir\n-            | None ->\n-                Git_wrapper.temporary_remote_checkout_path caps url\n-                |> Rfpath.of_fpath_exn\n-          in\n+          (* CWD must be empty for this to work *)\n+          let has_files = List_files.list (Fpath.v \".\") <> [] in",
        "comment_created_at": "2024-03-18T22:15:08+00:00",
        "comment_author": "ajbt200128",
        "comment_body": "just going to use parens like a heathen",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1526785844",
    "pr_number": 9943,
    "pr_file": "src/osemgrep/cli_ci/Ci_subcommand.ml",
    "created_at": "2024-03-15T20:10:34+00:00",
    "commented_code": "match metadata with\n   | JSON.Object xs ->\n+      let should_check_validation_state =\n+        Option.is_some m.extra.validation_state\n+      in",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1526785844",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9943,
        "pr_file": "src/osemgrep/cli_ci/Ci_subcommand.ml",
        "discussion_id": "1526785844",
        "commented_code": "@@ -336,6 +336,10 @@ let finding_is_blocking (m : OutJ.cli_match) =\n \n   match metadata with\n   | JSON.Object xs ->\n+      let should_check_validation_state =\n+        Option.is_some m.extra.validation_state\n+      in",
        "comment_created_at": "2024-03-15T20:10:34+00:00",
        "comment_author": "kopecs",
        "comment_body": "Seems odd to have this given we check this same condition 3 lines later. Seems like this whole chunk could be re-written as\r\n```ocaml\r\n  match metadata with\r\n  | JSON.Object xs ->\r\n        (match\r\n          ( m.extra.validation_state,\r\n            List.assoc_opt \"dev.semgrep.validation_state.actions\" xs,\r\n            List.assoc_opt \"dev.semgrep.actions\" xs )\r\n        with\r\n        | Some validation_state, Some (JSON.Object vs) ->\r\n            List.assoc_opt (validation_state_to_action validation_state) vs\r\n            |> Option.map (JSON.equal (JSON.String \"block\"))\r\n            |> Option.value ~default:false\r\n        | None, Some (JSON.Array actions) -> contains_blocking actions\r\n        | _ -> false)\r\n  | _ -> false\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1526908860",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9943,
        "pr_file": "src/osemgrep/cli_ci/Ci_subcommand.ml",
        "discussion_id": "1526785844",
        "commented_code": "@@ -336,6 +336,10 @@ let finding_is_blocking (m : OutJ.cli_match) =\n \n   match metadata with\n   | JSON.Object xs ->\n+      let should_check_validation_state =\n+        Option.is_some m.extra.validation_state\n+      in",
        "comment_created_at": "2024-03-15T22:18:40+00:00",
        "comment_author": "salolivares",
        "comment_body": "Much cleaner. Done in [1a3a69e](https://github.com/semgrep/semgrep/pull/9943/commits/1a3a69e442e8274e7bbcc565baa4cc3c86e88c64)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1433626208",
    "pr_number": 9501,
    "pr_file": "src/osemgrep/core/Metrics_.ml",
    "created_at": "2023-12-21T07:00:30+00:00",
    "commented_code": "| Intraprocedural -> `Intraprocedural\n             | Interprocedural -> `Interprocedural\n             | Interfile -> `Interfile);\n-          code_config;\n+          code_config = Option.map (Fun.const true) code_config;",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1433626208",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9501,
        "pr_file": "src/osemgrep/core/Metrics_.ml",
        "discussion_id": "1433626208",
        "commented_code": "@@ -286,7 +286,7 @@ let add_engine_type (engine_type : Engine_type.t) =\n             | Intraprocedural -> `Intraprocedural\n             | Interprocedural -> `Interprocedural\n             | Interfile -> `Interfile);\n-          code_config;\n+          code_config = Option.map (Fun.const true) code_config;",
        "comment_created_at": "2023-12-21T07:00:30+00:00",
        "comment_author": "aryx",
        "comment_body": "This is not readable. Avoid Option.map and Fun.xxx when you can and when the resulting simpler code is actually shorter.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1434389830",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9501,
        "pr_file": "src/osemgrep/core/Metrics_.ml",
        "discussion_id": "1433626208",
        "commented_code": "@@ -286,7 +286,7 @@ let add_engine_type (engine_type : Engine_type.t) =\n             | Intraprocedural -> `Intraprocedural\n             | Interprocedural -> `Interprocedural\n             | Interfile -> `Interfile);\n-          code_config;\n+          code_config = Option.map (Fun.const true) code_config;",
        "comment_created_at": "2023-12-21T18:34:31+00:00",
        "comment_author": "kopecs",
        "comment_body": "Do you find the version in 00fcd33e6b5dbebb7123834e4863fb70c6a875ca objectionable? I can't tell from this if you are opposed to the combination or both `Option.map` and `Fun` individually.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1434397487",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9501,
        "pr_file": "src/osemgrep/core/Metrics_.ml",
        "discussion_id": "1433626208",
        "commented_code": "@@ -286,7 +286,7 @@ let add_engine_type (engine_type : Engine_type.t) =\n             | Intraprocedural -> `Intraprocedural\n             | Interprocedural -> `Interprocedural\n             | Interfile -> `Interfile);\n-          code_config;\n+          code_config = Option.map (Fun.const true) code_config;",
        "comment_created_at": "2023-12-21T18:45:12+00:00",
        "comment_author": "aryx",
        "comment_body": "I usually find code more readable when they don't use Fun.const, or the $ operator, or curry, or Option.value, etc. KISS. In this case I think `match code_config with None -> false |  Some _ -> true' more readable.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1434399541",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9501,
        "pr_file": "src/osemgrep/core/Metrics_.ml",
        "discussion_id": "1433626208",
        "commented_code": "@@ -286,7 +286,7 @@ let add_engine_type (engine_type : Engine_type.t) =\n             | Intraprocedural -> `Intraprocedural\n             | Interprocedural -> `Interprocedural\n             | Interfile -> `Interfile);\n-          code_config;\n+          code_config = Option.map (Fun.const true) code_config;",
        "comment_created_at": "2023-12-21T18:47:30+00:00",
        "comment_author": "kopecs",
        "comment_body": "Sure; I wrote it like this instead of just `Option.is_some` in anticipation of a change like the one in the commit I linked. Do you want me to make any additional changes to the version in the most recent commit?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1410835712",
    "pr_number": 9269,
    "pr_file": "libs/networking/http_mock_client/Http_mock_client.ml",
    "created_at": "2023-11-30T15:22:53+00:00",
    "commented_code": "let check_body expected_body actual_body =\n   let%lwt actual_body_content = Cohttp_lwt.Body.to_string actual_body in\n   let%lwt expected_body_content = Cohttp_lwt.Body.to_string expected_body in\n-  Alcotest.(check string) \"body\" expected_body_content actual_body_content;\n+  (* Passing \"\" for the name of the check prevents an otherwise",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1410835712",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9269,
        "pr_file": "libs/networking/http_mock_client/Http_mock_client.ml",
        "discussion_id": "1410835712",
        "commented_code": "@@ -105,12 +105,16 @@ let body_of_file ?(trim = false) path =\n let check_body expected_body actual_body =\n   let%lwt actual_body_content = Cohttp_lwt.Body.to_string actual_body in\n   let%lwt expected_body_content = Cohttp_lwt.Body.to_string expected_body in\n-  Alcotest.(check string) \"body\" expected_body_content actual_body_content;\n+  (* Passing \"\" for the name of the check prevents an otherwise",
        "comment_created_at": "2023-11-30T15:22:53+00:00",
        "comment_author": "aryx",
        "comment_body": "would probably have been better to define a wrapper my_alcotest_check_string()\r\nthat takes just 2 arguments and call Alcotest with the empty string, so we have\r\njust one place with this comment instead of 4.\r\n",
        "pr_file_module": null
      }
    ]
  }
]