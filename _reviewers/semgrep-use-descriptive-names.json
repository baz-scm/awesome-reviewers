[
  {
    "discussion_id": "1591733144",
    "pr_number": 10204,
    "pr_file": "src/core/Rule.ml",
    "created_at": "2024-05-07T02:19:57+00:00",
    "commented_code": "}\n [@@deriving show, eq]\n \n+type sca_mode = [ `SCA of dependency_formula ] [@@deriving show]",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1591733144",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10204,
        "pr_file": "src/core/Rule.ml",
        "discussion_id": "1591733144",
        "commented_code": "@@ -547,6 +547,8 @@ and dependency_pattern = {\n }\n [@@deriving show, eq]\n \n+type sca_mode = [ `SCA of dependency_formula ] [@@deriving show]",
        "comment_created_at": "2024-05-07T02:19:57+00:00",
        "comment_author": "mjambon",
        "comment_body": "What's SCA? The other modes don't use acronyms. If it's about dependencies, call it \"dependency_mode\" or something that describes what it is, nothing more, nothing else, because maybe it could be reused in other contexts than \"SCA\" or maybe it will outlive \"SCA\".",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1568028596",
    "pr_number": 10106,
    "pr_file": "libs/commons/Logs_.ml",
    "created_at": "2024-04-16T23:12:36+00:00",
    "commented_code": "ok || List.mem (Logs.Tag.name def) tag_str_list)\n     tag_set false\n \n-let default_tag_str = \"default\"\n-let default_tags = [ default_tag_str ]\n-let default_tag = create_tag default_tag_str\n-let default_tag_set = create_tag_set [ default_tag ]\n-\n (* Consult environment variables from left-to-right in order of precedence. *)\n-let read_from_environment_variables vars =\n+let read_from_env_vars (vars : string list) : string option =\n   List.find_map (fun var -> USys.getenv_opt var) vars\n \n-let read_tags_from_env_vars vars =\n-  vars |> read_from_environment_variables\n-  |> Option.map (String.split_on_char ',')\n+let read_csv_from_env_vars (vars : string list) : string list option =\n+  vars |> read_from_env_vars |> Option.map (String.split_on_char ',')",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1568028596",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10106,
        "pr_file": "libs/commons/Logs_.ml",
        "discussion_id": "1568028596",
        "commented_code": "@@ -142,35 +123,54 @@ let has_nonempty_intersection tag_str_list tag_set =\n       ok || List.mem (Logs.Tag.name def) tag_str_list)\n     tag_set false\n \n-let default_tag_str = \"default\"\n-let default_tags = [ default_tag_str ]\n-let default_tag = create_tag default_tag_str\n-let default_tag_set = create_tag_set [ default_tag ]\n-\n (* Consult environment variables from left-to-right in order of precedence. *)\n-let read_from_environment_variables vars =\n+let read_from_env_vars (vars : string list) : string option =\n   List.find_map (fun var -> USys.getenv_opt var) vars\n \n-let read_tags_from_env_vars vars =\n-  vars |> read_from_environment_variables\n-  |> Option.map (String.split_on_char ',')\n+let read_csv_from_env_vars (vars : string list) : string list option =\n+  vars |> read_from_env_vars |> Option.map (String.split_on_char ',')",
        "comment_created_at": "2024-04-16T23:12:36+00:00",
        "comment_author": "mjambon",
        "comment_body": "CSV refers to a specific format. Please don't call this CSV because it's not how CSV is parsed.",
        "pr_file_module": null
      },
      {
        "comment_id": "1568342996",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10106,
        "pr_file": "libs/commons/Logs_.ml",
        "discussion_id": "1568028596",
        "commented_code": "@@ -142,35 +123,54 @@ let has_nonempty_intersection tag_str_list tag_set =\n       ok || List.mem (Logs.Tag.name def) tag_str_list)\n     tag_set false\n \n-let default_tag_str = \"default\"\n-let default_tags = [ default_tag_str ]\n-let default_tag = create_tag default_tag_str\n-let default_tag_set = create_tag_set [ default_tag ]\n-\n (* Consult environment variables from left-to-right in order of precedence. *)\n-let read_from_environment_variables vars =\n+let read_from_env_vars (vars : string list) : string option =\n   List.find_map (fun var -> USys.getenv_opt var) vars\n \n-let read_tags_from_env_vars vars =\n-  vars |> read_from_environment_variables\n-  |> Option.map (String.split_on_char ',')\n+let read_csv_from_env_vars (vars : string list) : string list option =\n+  vars |> read_from_env_vars |> Option.map (String.split_on_char ',')",
        "comment_created_at": "2024-04-17T07:16:01+00:00",
        "comment_author": "aryx",
        "comment_body": "true, csv usually have multiple lines. I'll use comma_separated_strings",
        "pr_file_module": null
      },
      {
        "comment_id": "1569741513",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 10106,
        "pr_file": "libs/commons/Logs_.ml",
        "discussion_id": "1568028596",
        "commented_code": "@@ -142,35 +123,54 @@ let has_nonempty_intersection tag_str_list tag_set =\n       ok || List.mem (Logs.Tag.name def) tag_str_list)\n     tag_set false\n \n-let default_tag_str = \"default\"\n-let default_tags = [ default_tag_str ]\n-let default_tag = create_tag default_tag_str\n-let default_tag_set = create_tag_set [ default_tag ]\n-\n (* Consult environment variables from left-to-right in order of precedence. *)\n-let read_from_environment_variables vars =\n+let read_from_env_vars (vars : string list) : string option =\n   List.find_map (fun var -> USys.getenv_opt var) vars\n \n-let read_tags_from_env_vars vars =\n-  vars |> read_from_environment_variables\n-  |> Option.map (String.split_on_char ',')\n+let read_csv_from_env_vars (vars : string list) : string list option =\n+  vars |> read_from_env_vars |> Option.map (String.split_on_char ',')",
        "comment_created_at": "2024-04-18T00:54:20+00:00",
        "comment_author": "mjambon",
        "comment_body": "No, it's that `\"1,2\",3` is 2 CSV cells holding `1,2` and `3`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1520587007",
    "pr_number": 9907,
    "pr_file": "libs/tracing/Tracing.mli",
    "created_at": "2024-03-12T00:09:27+00:00",
    "commented_code": "See header of Tracing.ml for details\n  *)\n \n+(*****************************************************************************)\n+(* Types *)\n+(*****************************************************************************)\n+\n+type analysis_flags = {\n+  secrets_validators : bool;\n+  historical_scan : bool;\n+  allow_all_origins : bool;\n+  deep_intra_file : bool;\n+  deep_inter_file : bool;\n+}\n+\n+type top_level_data = { version : string; analysis_flags : analysis_flags }\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+val oss_analysis : unit -> analysis_flags\n+(** For analysis run with the oss engine, we know all the flags will be false *)",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1520587007",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9907,
        "pr_file": "libs/tracing/Tracing.mli",
        "discussion_id": "1520587007",
        "commented_code": "@@ -2,10 +2,41 @@\n    See header of Tracing.ml for details\n  *)\n \n+(*****************************************************************************)\n+(* Types *)\n+(*****************************************************************************)\n+\n+type analysis_flags = {\n+  secrets_validators : bool;\n+  historical_scan : bool;\n+  allow_all_origins : bool;\n+  deep_intra_file : bool;\n+  deep_inter_file : bool;\n+}\n+\n+type top_level_data = { version : string; analysis_flags : analysis_flags }\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+val oss_analysis : unit -> analysis_flags\n+(** For analysis run with the oss engine, we know all the flags will be false *)",
        "comment_created_at": "2024-03-12T00:09:27+00:00",
        "comment_author": "kopecs",
        "comment_body": "Based on description I might rather call this `no_analysis_features` or similar.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1483107411",
    "pr_number": 9715,
    "pr_file": "libs/source/Source.mli",
    "created_at": "2024-02-08T14:54:50+00:00",
    "commented_code": "+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Sources of content which may be consumed by Semgrep.\n+\n+   A source is the {e user-relevant location} where content (e.g., source code)\n+   originated. This should be used when storing a location which will later be\n+   reported to a user.\n+\n+   While a source may imply that content can be obtained from a given location,\n+   it should generally be stored alongside the content to be consumed. This is\n+   so that it can be used principally for reporting where a finding originated\n+   independently of getting the content, which allows de-coupling reporting\n+   where a finding originated from obtaining the contents.\n+\n+   This is since when these uses are fused, it is more difficult to\n+   {ul\n+      {- create a target where the contents are not the verbatim file contents}\n+      {- associate additional data to findings about location which we might\n+      want to report to users (e.g., \"nested within a metavariable pattern\";\n+      \"via extract mode\")}\n+      {- scan anything which is not resident on the filesystem (e.g.,\n+      metavariable pattern, git object)---currently this requires writing a\n+      tempfile.}\n+    }\n+    A major contributor to this is that [Match_search_mode] and similar\n+    currently require the contents of the scan target to be in a file.\n+ *)\n+\n+(** The type for sources.\n+\n+    {ul\n+      {- [File] sources are for files, and should have as their path the\n+        relative path from the scanned project root.}\n+    }\n+ *)\n+type t = File of Fpath.t [@@deriving show, eq, ord, sexp]\n+\n+val to_string : t -> string\n+(** [to_string s] is the path [s] as a user-facing string. This is the version\n+   which should be displayed to the user. Cf. the derived show implementation,\n+   which is for internal debugging purposes.\n+ *)\n+\n+val to_string_opt : ?unspecified:string -> t option -> string\n+(** [to_string_opt ~unspecified s] is the path [s] as a user-facing string, or",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1483107411",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "libs/source/Source.mli",
        "discussion_id": "1483107411",
        "commented_code": "@@ -0,0 +1,60 @@\n+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Sources of content which may be consumed by Semgrep.\n+\n+   A source is the {e user-relevant location} where content (e.g., source code)\n+   originated. This should be used when storing a location which will later be\n+   reported to a user.\n+\n+   While a source may imply that content can be obtained from a given location,\n+   it should generally be stored alongside the content to be consumed. This is\n+   so that it can be used principally for reporting where a finding originated\n+   independently of getting the content, which allows de-coupling reporting\n+   where a finding originated from obtaining the contents.\n+\n+   This is since when these uses are fused, it is more difficult to\n+   {ul\n+      {- create a target where the contents are not the verbatim file contents}\n+      {- associate additional data to findings about location which we might\n+      want to report to users (e.g., \"nested within a metavariable pattern\";\n+      \"via extract mode\")}\n+      {- scan anything which is not resident on the filesystem (e.g.,\n+      metavariable pattern, git object)---currently this requires writing a\n+      tempfile.}\n+    }\n+    A major contributor to this is that [Match_search_mode] and similar\n+    currently require the contents of the scan target to be in a file.\n+ *)\n+\n+(** The type for sources.\n+\n+    {ul\n+      {- [File] sources are for files, and should have as their path the\n+        relative path from the scanned project root.}\n+    }\n+ *)\n+type t = File of Fpath.t [@@deriving show, eq, ord, sexp]\n+\n+val to_string : t -> string\n+(** [to_string s] is the path [s] as a user-facing string. This is the version\n+   which should be displayed to the user. Cf. the derived show implementation,\n+   which is for internal debugging purposes.\n+ *)\n+\n+val to_string_opt : ?unspecified:string -> t option -> string\n+(** [to_string_opt ~unspecified s] is the path [s] as a user-facing string, or",
        "comment_created_at": "2024-02-08T14:54:50+00:00",
        "comment_author": "aryx",
        "comment_body": "do not use s, it's often used for string, src seems better (if we agree that source.ml is a good name for this module).\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1484856834",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "libs/source/Source.mli",
        "discussion_id": "1483107411",
        "commented_code": "@@ -0,0 +1,60 @@\n+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Sources of content which may be consumed by Semgrep.\n+\n+   A source is the {e user-relevant location} where content (e.g., source code)\n+   originated. This should be used when storing a location which will later be\n+   reported to a user.\n+\n+   While a source may imply that content can be obtained from a given location,\n+   it should generally be stored alongside the content to be consumed. This is\n+   so that it can be used principally for reporting where a finding originated\n+   independently of getting the content, which allows de-coupling reporting\n+   where a finding originated from obtaining the contents.\n+\n+   This is since when these uses are fused, it is more difficult to\n+   {ul\n+      {- create a target where the contents are not the verbatim file contents}\n+      {- associate additional data to findings about location which we might\n+      want to report to users (e.g., \"nested within a metavariable pattern\";\n+      \"via extract mode\")}\n+      {- scan anything which is not resident on the filesystem (e.g.,\n+      metavariable pattern, git object)---currently this requires writing a\n+      tempfile.}\n+    }\n+    A major contributor to this is that [Match_search_mode] and similar\n+    currently require the contents of the scan target to be in a file.\n+ *)\n+\n+(** The type for sources.\n+\n+    {ul\n+      {- [File] sources are for files, and should have as their path the\n+        relative path from the scanned project root.}\n+    }\n+ *)\n+type t = File of Fpath.t [@@deriving show, eq, ord, sexp]\n+\n+val to_string : t -> string\n+(** [to_string s] is the path [s] as a user-facing string. This is the version\n+   which should be displayed to the user. Cf. the derived show implementation,\n+   which is for internal debugging purposes.\n+ *)\n+\n+val to_string_opt : ?unspecified:string -> t option -> string\n+(** [to_string_opt ~unspecified s] is the path [s] as a user-facing string, or",
        "comment_created_at": "2024-02-09T22:21:34+00:00",
        "comment_author": "kopecs",
        "comment_body": "Done in 5fee815255b446b1e3360b63d94021332adf6f60",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1488277818",
    "pr_number": 9715,
    "pr_file": "js/engine/Main.ml",
    "created_at": "2024-02-13T17:13:23+00:00",
    "commented_code": "in\n            let targets =\n              List.map\n-               (fun f ->\n-                 `CodeTarget\n-                   Input_to_core_t.\n-                     {\n-                       path = f;\n-                       analyzer = xlang;\n-                       products = Product.all;\n-                       lockfile_target = None;\n-                     })\n+               (fun f : Target.t ->\n+                 Code\n+                   (Target.code_of_origin xlang Product.all (File (Fpath.v f))))",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1488277818",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "js/engine/Main.ml",
        "discussion_id": "1488277818",
        "commented_code": "@@ -48,15 +48,9 @@ let _ =\n            in\n            let targets =\n              List.map\n-               (fun f ->\n-                 `CodeTarget\n-                   Input_to_core_t.\n-                     {\n-                       path = f;\n-                       analyzer = xlang;\n-                       products = Product.all;\n-                       lockfile_target = None;\n-                     })\n+               (fun f : Target.t ->\n+                 Code\n+                   (Target.code_of_origin xlang Product.all (File (Fpath.v f))))",
        "comment_created_at": "2024-02-13T17:13:23+00:00",
        "comment_author": "aryx",
        "comment_body": "code_of_origin is a bad name given you don't pass just an origin here but lots of arguments.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1488387704",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "js/engine/Main.ml",
        "discussion_id": "1488277818",
        "commented_code": "@@ -48,15 +48,9 @@ let _ =\n            in\n            let targets =\n              List.map\n-               (fun f ->\n-                 `CodeTarget\n-                   Input_to_core_t.\n-                     {\n-                       path = f;\n-                       analyzer = xlang;\n-                       products = Product.all;\n-                       lockfile_target = None;\n-                     })\n+               (fun f : Target.t ->\n+                 Code\n+                   (Target.code_of_origin xlang Product.all (File (Fpath.v f))))",
        "comment_created_at": "2024-02-13T18:28:42+00:00",
        "comment_author": "kopecs",
        "comment_body": "Done in 1e38a3c65ba5f117024690f171ed62c91a1ad09f. I have called this functions`mk_code` instead (and likewise for the other versions). Please let me know a more concrete suggestion if that's also disliked.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1488283338",
    "pr_number": 9715,
    "pr_file": "src/core/Target.mli",
    "created_at": "2024-02-13T17:17:03+00:00",
    "commented_code": "+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Types for describing targets.\n+\n+    See also {!Input_to_core_t}, which has a similar set of types used when\n+    pysemgrep generates targets that have slightly less information (e.g.,\n+    these types have expanded information about the targets' locations). *)\n+\n+(** The location of a Semgrep target. This contains all of the target-specific\n+    details needed to be able to determine how to scan a target, e.g.,\n+\n+    {ul\n+      {- What products should we select rules from?}\n+      {- Where can we get the contents of the target?}\n+      {- What language should we analyze the target as?}\n+    }\n+\n+    However, it does not contain the actual contents (parsed or otherwise) of\n+    the target itself.\n+ *)\n+type t = Code of code | Lockfile of lockfile [@@deriving show]",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1488283338",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "src/core/Target.mli",
        "discussion_id": "1488283338",
        "commented_code": "@@ -0,0 +1,144 @@\n+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Types for describing targets.\n+\n+    See also {!Input_to_core_t}, which has a similar set of types used when\n+    pysemgrep generates targets that have slightly less information (e.g.,\n+    these types have expanded information about the targets' locations). *)\n+\n+(** The location of a Semgrep target. This contains all of the target-specific\n+    details needed to be able to determine how to scan a target, e.g.,\n+\n+    {ul\n+      {- What products should we select rules from?}\n+      {- Where can we get the contents of the target?}\n+      {- What language should we analyze the target as?}\n+    }\n+\n+    However, it does not contain the actual contents (parsed or otherwise) of\n+    the target itself.\n+ *)\n+type t = Code of code | Lockfile of lockfile [@@deriving show]",
        "comment_created_at": "2024-02-13T17:17:03+00:00",
        "comment_author": "aryx",
        "comment_body": "Code is a very bad name, as this data structure does not contain code.\r\nMaybe call it RegularTarget, ",
        "pr_file_module": null
      },
      {
        "comment_id": "1488368511",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "src/core/Target.mli",
        "discussion_id": "1488283338",
        "commented_code": "@@ -0,0 +1,144 @@\n+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Types for describing targets.\n+\n+    See also {!Input_to_core_t}, which has a similar set of types used when\n+    pysemgrep generates targets that have slightly less information (e.g.,\n+    these types have expanded information about the targets' locations). *)\n+\n+(** The location of a Semgrep target. This contains all of the target-specific\n+    details needed to be able to determine how to scan a target, e.g.,\n+\n+    {ul\n+      {- What products should we select rules from?}\n+      {- Where can we get the contents of the target?}\n+      {- What language should we analyze the target as?}\n+    }\n+\n+    However, it does not contain the actual contents (parsed or otherwise) of\n+    the target itself.\n+ *)\n+type t = Code of code | Lockfile of lockfile [@@deriving show]",
        "comment_created_at": "2024-02-13T18:15:44+00:00",
        "comment_author": "kopecs",
        "comment_body": "This is called `Code` so that it is consistent with the types @mmcqd introduced in https://github.com/semgrep/semgrep/pull/9695. I can change it here, but it would then no longer be consistent with the similar type added there.\r\n\r\nI can rename both, and update the python code which generates this, but I am uncertain that this PR is the appropriate place to do so.",
        "pr_file_module": null
      },
      {
        "comment_id": "1488632919",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "src/core/Target.mli",
        "discussion_id": "1488283338",
        "commented_code": "@@ -0,0 +1,144 @@\n+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Types for describing targets.\n+\n+    See also {!Input_to_core_t}, which has a similar set of types used when\n+    pysemgrep generates targets that have slightly less information (e.g.,\n+    these types have expanded information about the targets' locations). *)\n+\n+(** The location of a Semgrep target. This contains all of the target-specific\n+    details needed to be able to determine how to scan a target, e.g.,\n+\n+    {ul\n+      {- What products should we select rules from?}\n+      {- Where can we get the contents of the target?}\n+      {- What language should we analyze the target as?}\n+    }\n+\n+    However, it does not contain the actual contents (parsed or otherwise) of\n+    the target itself.\n+ *)\n+type t = Code of code | Lockfile of lockfile [@@deriving show]",
        "comment_created_at": "2024-02-13T21:53:42+00:00",
        "comment_author": "mmcqd",
        "comment_body": "I'm happy to change the name. Just wanted to indicate it's a target with source code in it and we should do regular matching on it. `RegularTarget` seems good to me. If Cooper is ok with changing the name here that's fine with me, or I can I open a separate PR after this one renaming everything.",
        "pr_file_module": null
      },
      {
        "comment_id": "1488702979",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "src/core/Target.mli",
        "discussion_id": "1488283338",
        "commented_code": "@@ -0,0 +1,144 @@\n+(* Cooper Pierce\n+ *\n+ * Copyright (c) Semgrep Inc.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public License\n+ * version 2.1 as published by the Free Software Foundation, with the\n+ * special exception on linking described in file LICENSE.\n+ *\n+ * This library is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file\n+ * LICENSE for more details.\n+ *)\n+\n+(** Types for describing targets.\n+\n+    See also {!Input_to_core_t}, which has a similar set of types used when\n+    pysemgrep generates targets that have slightly less information (e.g.,\n+    these types have expanded information about the targets' locations). *)\n+\n+(** The location of a Semgrep target. This contains all of the target-specific\n+    details needed to be able to determine how to scan a target, e.g.,\n+\n+    {ul\n+      {- What products should we select rules from?}\n+      {- Where can we get the contents of the target?}\n+      {- What language should we analyze the target as?}\n+    }\n+\n+    However, it does not contain the actual contents (parsed or otherwise) of\n+    the target itself.\n+ *)\n+type t = Code of code | Lockfile of lockfile [@@deriving show]",
        "comment_created_at": "2024-02-13T23:10:07+00:00",
        "comment_author": "kopecs",
        "comment_body": "I have renamed this `Regular`, without the Target, (given it is in the module name already) in e18e0a6b4e5b7776a80ac46ff158b1490806f156.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1489112623",
    "pr_number": 9715,
    "pr_file": "libs/commons/List_.ml",
    "created_at": "2024-02-14T08:46:51+00:00",
    "commented_code": "let sort xs = List.sort compare xs\n \n+let sort_by_key key cmp xs =",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1489112623",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "libs/commons/List_.ml",
        "discussion_id": "1489112623",
        "commented_code": "@@ -325,6 +325,11 @@ let optlist_to_list = function\n \n let sort xs = List.sort compare xs\n \n+let sort_by_key key cmp xs =",
        "comment_created_at": "2024-02-14T08:46:51+00:00",
        "comment_author": "aryx",
        "comment_body": "maybe I would rename sort_by_mapped_key,\r\nto avoid ambiguity with the Assoc_.sort_by_key_xxx function\r\nand I would rename key as fkey, so it's clear we're passing a function here, not a key.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1489958962",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9715,
        "pr_file": "libs/commons/List_.ml",
        "discussion_id": "1489112623",
        "commented_code": "@@ -325,6 +325,11 @@ let optlist_to_list = function\n \n let sort xs = List.sort compare xs\n \n+let sort_by_key key cmp xs =",
        "comment_created_at": "2024-02-14T19:26:09+00:00",
        "comment_author": "kopecs",
        "comment_body": ">  I would rename key as fkey, so it's clear we're passing a function here, not a key.\r\n\r\nI am not certain what would be unclear here, given the function is 3 lines and the one usage of this is that it is applied. I can rename it, but I think this probably speaks more to the fact that this warrants documentation. I will add some in the mli.\r\n\r\n> maybe I would rename sort_by_mapped_key,\r\nto avoid ambiguity with the Assoc_.sort_by_key_xxx function\r\n\r\nI would rather not rename this, since I think the suggestion simply increases verbosity and imo any ambiguity is resolved by the module name.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1474079712",
    "pr_number": 9695,
    "pr_file": "src/core/Pattern_match.ml",
    "created_at": "2024-02-01T09:14:21+00:00",
    "commented_code": "the override is applied on top of the default and only changes the fields\n      present in the override. *)\n   metadata_override : JSON.t option;\n+  dependency_match_data : dependency_match_data;",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1474079712",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9695,
        "pr_file": "src/core/Pattern_match.ml",
        "discussion_id": "1474079712",
        "commented_code": "@@ -129,8 +129,20 @@ type t = {\n      the override is applied on top of the default and only changes the fields\n      present in the override. *)\n   metadata_override : JSON.t option;\n+  dependency_match_data : dependency_match_data;",
        "comment_created_at": "2024-02-01T09:14:21+00:00",
        "comment_author": "aryx",
        "comment_body": "remove the _match_data suffix in the field and the type\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1401203412",
    "pr_number": 9280,
    "pr_file": "src/core/Target_file.ml",
    "created_at": "2023-11-21T21:15:40+00:00",
    "commented_code": "+type provided_target_language_info =",
    "repo_full_name": "semgrep/semgrep",
    "discussion_comments": [
      {
        "comment_id": "1401203412",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9280,
        "pr_file": "src/core/Target_file.ml",
        "discussion_id": "1401203412",
        "commented_code": "@@ -0,0 +1,19 @@\n+type provided_target_language_info =",
        "comment_created_at": "2023-11-21T21:15:40+00:00",
        "comment_author": "aryx",
        "comment_body": "a type with _info is not great.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1401576215",
        "repo_full_name": "semgrep/semgrep",
        "pr_number": 9280,
        "pr_file": "src/core/Target_file.ml",
        "discussion_id": "1401203412",
        "commented_code": "@@ -0,0 +1,19 @@\n+type provided_target_language_info =",
        "comment_created_at": "2023-11-22T06:41:10+00:00",
        "comment_author": "mjambon",
        "comment_body": "We're trying to move away from using the term \"language\" because it's ambiguous and restrictive in the context of semgrep rules. Please prefer \"selector\" or \"target selection\", etc. the goal being to select files however we like using a combination of filters e.g. `image and not pdf`. \"file type\" is fine too, as long as it's understood that a file does not have an exclusive type.",
        "pr_file_module": null
      }
    ]
  }
]