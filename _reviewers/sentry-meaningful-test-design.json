[
  {
    "discussion_id": "2190151412",
    "pr_number": 94354,
    "pr_file": "static/app/utils/array/uniq.spec.ts",
    "created_at": "2025-07-07T13:41:36+00:00",
    "commented_code": "it('should return empty array for undefined input', () => {\n     expect(uniq(undefined)).toStrictEqual([]);\n   });\n+\n+  it('should return empty array for null input', () => {\n+    expect(uniq(null)).toStrictEqual([]);\n+  });\n+\n+  it('should return empty array for empty object input', () => {\n+    expect(uniq({} as any)).toStrictEqual([]);",
    "repo_full_name": "getsentry/sentry",
    "discussion_comments": [
      {
        "comment_id": "2190151412",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 94354,
        "pr_file": "static/app/utils/array/uniq.spec.ts",
        "discussion_id": "2190151412",
        "commented_code": "@@ -8,4 +8,24 @@ describe('uniq', () => {\n   it('should return empty array for undefined input', () => {\n     expect(uniq(undefined)).toStrictEqual([]);\n   });\n+\n+  it('should return empty array for null input', () => {\n+    expect(uniq(null)).toStrictEqual([]);\n+  });\n+\n+  it('should return empty array for empty object input', () => {\n+    expect(uniq({} as any)).toStrictEqual([]);",
        "comment_created_at": "2025-07-07T13:41:36+00:00",
        "comment_author": "seer-by-sentry[bot]",
        "comment_body": "The test cases are comprehensive, but there's redundancy between testing `{}` and `{key: 'value'}` since both are non-array objects. Consider consolidating or focusing on more meaningful edge cases. Also, consider testing with array-like objects that aren't true arrays.\n```suggestion\nit('should return empty array for array-like objects that are not arrays', () => {\n  const arrayLike = {0: 'a', 1: 'b', length: 2};\n  expect(uniq(arrayLike as any)).toStrictEqual([]);\n});\n```\n\n<sub><i>Did we get this right? :+1: / :-1: to inform future reviews.</i></sub>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159331976",
    "pr_number": 93902,
    "pr_file": "static/app/views/dashboards/widgets/tableWidget/fixtures/tabularColumn.ts",
    "created_at": "2025-06-20T16:20:35+00:00",
    "commented_code": null,
    "repo_full_name": "getsentry/sentry",
    "discussion_comments": [
      {
        "comment_id": "2159331976",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 93902,
        "pr_file": "static/app/views/dashboards/widgets/tableWidget/fixtures/tabularColumn.ts",
        "discussion_id": "2159331976",
        "commented_code": null,
        "comment_created_at": "2025-06-20T16:20:35+00:00",
        "comment_author": "gggritso",
        "comment_body": "I didn't clarify this before, sorry, I meant this should go into `tests/js/fixtures/tabularColumn.ts`, with the rest of the fixtures. You'll also need to restructure _just a bit_\r\n\r\n1. Export `TabularColumnFixture` that returns a single `TabularColumn`, and it should accept `params: Partial<TabularColumn>` which it merges into the fixture. Check out `organization.ts` for an example\r\n2. Add a second fixture file called `tabularColumns.ts` which exports `TabularColumn[]`, and then you can use `TabularColumnFixture` to make an array of two columns with the key, name, and type you want",
        "pr_file_module": null
      }
    ]
  }
]