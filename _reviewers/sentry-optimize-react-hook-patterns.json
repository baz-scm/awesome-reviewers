[
  {
    "discussion_id": "2164042546",
    "pr_number": 94164,
    "pr_file": "static/app/views/insights/agentMonitoring/views/onboarding.tsx",
    "created_at": "2025-06-24T13:41:28+00:00",
    "commented_code": "+import {useEffect, useState} from 'react';\n+import styled from '@emotion/styled';\n+\n+import emptyTraceImg from 'sentry-images/spot/profiling-empty-state.svg';\n+\n+import {Button} from 'sentry/components/core/button';\n+import {LinkButton} from 'sentry/components/core/button/linkButton';\n+import {GuidedSteps} from 'sentry/components/guidedSteps/guidedSteps';\n+import LoadingIndicator from 'sentry/components/loadingIndicator';\n+import {AuthTokenGeneratorProvider} from 'sentry/components/onboarding/gettingStartedDoc/authTokenGenerator';\n+import {OnboardingCodeSnippet} from 'sentry/components/onboarding/gettingStartedDoc/onboardingCodeSnippet';\n+import {\n+  type Configuration,\n+  type StepProps,\n+  StepTitles,\n+  StepType,\n+  TabbedCodeSnippet,\n+} from 'sentry/components/onboarding/gettingStartedDoc/step';\n+import {\n+  DocsPageLocation,\n+  type DocsParams,\n+  ProductSolution,\n+} from 'sentry/components/onboarding/gettingStartedDoc/types';\n+import {useSourcePackageRegistries} from 'sentry/components/onboarding/gettingStartedDoc/useSourcePackageRegistries';\n+import {useLoadGettingStarted} from 'sentry/components/onboarding/gettingStartedDoc/utils/useLoadGettingStarted';\n+import Panel from 'sentry/components/panels/panel';\n+import PanelBody from 'sentry/components/panels/panelBody';\n+import {agentMonitoringPlatforms} from 'sentry/data/platformCategories';\n+import platforms, {otherPlatform} from 'sentry/data/platforms';\n+import {t, tct} from 'sentry/locale';\n+import ConfigStore from 'sentry/stores/configStore';\n+import {useLegacyStore} from 'sentry/stores/useLegacyStore';\n+import pulsingIndicatorStyles from 'sentry/styles/pulsingIndicator';\n+import {space} from 'sentry/styles/space';\n+import type {PlatformKey, Project} from 'sentry/types/project';\n+import {getSelectedProjectList} from 'sentry/utils/project/useSelectedProjectsHaveField';\n+import useApi from 'sentry/utils/useApi';\n+import useOrganization from 'sentry/utils/useOrganization';\n+import usePageFilters from 'sentry/utils/usePageFilters';\n+import useProjects from 'sentry/utils/useProjects';\n+import {Referrer} from 'sentry/views/insights/agentMonitoring/utils/referrers';\n+import {useEAPSpans} from 'sentry/views/insights/common/queries/useDiscover';\n+\n+function useOnboardingProject() {\n+  const {projects} = useProjects();\n+  const pageFilters = usePageFilters();\n+  const selectedProject = getSelectedProjectList(\n+    pageFilters.selection.projects,\n+    projects\n+  );\n+  const agentMonitoringProjects = selectedProject.filter(p =>\n+    agentMonitoringPlatforms.has(p.platform as PlatformKey)\n+  );\n+\n+  if (agentMonitoringProjects.length > 0) {\n+    return agentMonitoringProjects[0];\n+  }\n+  return selectedProject[0];\n+}\n+\n+function useAgentEventWaiter(project: Project) {\n+  const [refetchKey, setRefetchKey] = useState(0);\n+\n+  const {data, isPending} = useEAPSpans(\n+    {\n+      search: 'span.op:\"gen_ai.*\"',\n+      fields: ['id'],\n+      limit: 1,\n+      enabled: !!project,\n+      useQueryOptions: {\n+        additonalQueryKey: [`refetch-${refetchKey}`],\n+      },\n+    },\n+    Referrer.ONBOARDING\n+  );\n+\n+  const hasEvents = Boolean(data?.length);\n+\n+  // Create a custom key that changes every 5 seconds to trigger refetch\n+  // TODO(aknaus): remove this and add refetchInterval to useEAPSpans\n+  useEffect(() => {\n+    if (!hasEvents) {\n+      const interval = setInterval(() => {\n+        setRefetchKey(prev => prev + 1);\n+      }, 5000); // Poll every 5 seconds\n+\n+      return () => clearInterval(interval);\n+    }\n+    return () => {};\n+  }, [hasEvents]);\n+\n+  return {\n+    hasEvents: Boolean(data?.length),\n+    isPending,\n+  };",
    "repo_full_name": "getsentry/sentry",
    "discussion_comments": [
      {
        "comment_id": "2164042546",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 94164,
        "pr_file": "static/app/views/insights/agentMonitoring/views/onboarding.tsx",
        "discussion_id": "2164042546",
        "commented_code": "@@ -0,0 +1,505 @@\n+import {useEffect, useState} from 'react';\n+import styled from '@emotion/styled';\n+\n+import emptyTraceImg from 'sentry-images/spot/profiling-empty-state.svg';\n+\n+import {Button} from 'sentry/components/core/button';\n+import {LinkButton} from 'sentry/components/core/button/linkButton';\n+import {GuidedSteps} from 'sentry/components/guidedSteps/guidedSteps';\n+import LoadingIndicator from 'sentry/components/loadingIndicator';\n+import {AuthTokenGeneratorProvider} from 'sentry/components/onboarding/gettingStartedDoc/authTokenGenerator';\n+import {OnboardingCodeSnippet} from 'sentry/components/onboarding/gettingStartedDoc/onboardingCodeSnippet';\n+import {\n+  type Configuration,\n+  type StepProps,\n+  StepTitles,\n+  StepType,\n+  TabbedCodeSnippet,\n+} from 'sentry/components/onboarding/gettingStartedDoc/step';\n+import {\n+  DocsPageLocation,\n+  type DocsParams,\n+  ProductSolution,\n+} from 'sentry/components/onboarding/gettingStartedDoc/types';\n+import {useSourcePackageRegistries} from 'sentry/components/onboarding/gettingStartedDoc/useSourcePackageRegistries';\n+import {useLoadGettingStarted} from 'sentry/components/onboarding/gettingStartedDoc/utils/useLoadGettingStarted';\n+import Panel from 'sentry/components/panels/panel';\n+import PanelBody from 'sentry/components/panels/panelBody';\n+import {agentMonitoringPlatforms} from 'sentry/data/platformCategories';\n+import platforms, {otherPlatform} from 'sentry/data/platforms';\n+import {t, tct} from 'sentry/locale';\n+import ConfigStore from 'sentry/stores/configStore';\n+import {useLegacyStore} from 'sentry/stores/useLegacyStore';\n+import pulsingIndicatorStyles from 'sentry/styles/pulsingIndicator';\n+import {space} from 'sentry/styles/space';\n+import type {PlatformKey, Project} from 'sentry/types/project';\n+import {getSelectedProjectList} from 'sentry/utils/project/useSelectedProjectsHaveField';\n+import useApi from 'sentry/utils/useApi';\n+import useOrganization from 'sentry/utils/useOrganization';\n+import usePageFilters from 'sentry/utils/usePageFilters';\n+import useProjects from 'sentry/utils/useProjects';\n+import {Referrer} from 'sentry/views/insights/agentMonitoring/utils/referrers';\n+import {useEAPSpans} from 'sentry/views/insights/common/queries/useDiscover';\n+\n+function useOnboardingProject() {\n+  const {projects} = useProjects();\n+  const pageFilters = usePageFilters();\n+  const selectedProject = getSelectedProjectList(\n+    pageFilters.selection.projects,\n+    projects\n+  );\n+  const agentMonitoringProjects = selectedProject.filter(p =>\n+    agentMonitoringPlatforms.has(p.platform as PlatformKey)\n+  );\n+\n+  if (agentMonitoringProjects.length > 0) {\n+    return agentMonitoringProjects[0];\n+  }\n+  return selectedProject[0];\n+}\n+\n+function useAgentEventWaiter(project: Project) {\n+  const [refetchKey, setRefetchKey] = useState(0);\n+\n+  const {data, isPending} = useEAPSpans(\n+    {\n+      search: 'span.op:\"gen_ai.*\"',\n+      fields: ['id'],\n+      limit: 1,\n+      enabled: !!project,\n+      useQueryOptions: {\n+        additonalQueryKey: [`refetch-${refetchKey}`],\n+      },\n+    },\n+    Referrer.ONBOARDING\n+  );\n+\n+  const hasEvents = Boolean(data?.length);\n+\n+  // Create a custom key that changes every 5 seconds to trigger refetch\n+  // TODO(aknaus): remove this and add refetchInterval to useEAPSpans\n+  useEffect(() => {\n+    if (!hasEvents) {\n+      const interval = setInterval(() => {\n+        setRefetchKey(prev => prev + 1);\n+      }, 5000); // Poll every 5 seconds\n+\n+      return () => clearInterval(interval);\n+    }\n+    return () => {};\n+  }, [hasEvents]);\n+\n+  return {\n+    hasEvents: Boolean(data?.length),\n+    isPending,\n+  };",
        "comment_created_at": "2025-06-24T13:41:28+00:00",
        "comment_author": "JonasBa",
        "comment_body": "Nit, but I think it's a good idea to just return the entire call from the useEAPSpans expression\r\n```\r\nconst {data, isPending} = useEAPSpans(\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2164050797",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 94164,
        "pr_file": "static/app/views/insights/agentMonitoring/views/onboarding.tsx",
        "discussion_id": "2164042546",
        "commented_code": "@@ -0,0 +1,505 @@\n+import {useEffect, useState} from 'react';\n+import styled from '@emotion/styled';\n+\n+import emptyTraceImg from 'sentry-images/spot/profiling-empty-state.svg';\n+\n+import {Button} from 'sentry/components/core/button';\n+import {LinkButton} from 'sentry/components/core/button/linkButton';\n+import {GuidedSteps} from 'sentry/components/guidedSteps/guidedSteps';\n+import LoadingIndicator from 'sentry/components/loadingIndicator';\n+import {AuthTokenGeneratorProvider} from 'sentry/components/onboarding/gettingStartedDoc/authTokenGenerator';\n+import {OnboardingCodeSnippet} from 'sentry/components/onboarding/gettingStartedDoc/onboardingCodeSnippet';\n+import {\n+  type Configuration,\n+  type StepProps,\n+  StepTitles,\n+  StepType,\n+  TabbedCodeSnippet,\n+} from 'sentry/components/onboarding/gettingStartedDoc/step';\n+import {\n+  DocsPageLocation,\n+  type DocsParams,\n+  ProductSolution,\n+} from 'sentry/components/onboarding/gettingStartedDoc/types';\n+import {useSourcePackageRegistries} from 'sentry/components/onboarding/gettingStartedDoc/useSourcePackageRegistries';\n+import {useLoadGettingStarted} from 'sentry/components/onboarding/gettingStartedDoc/utils/useLoadGettingStarted';\n+import Panel from 'sentry/components/panels/panel';\n+import PanelBody from 'sentry/components/panels/panelBody';\n+import {agentMonitoringPlatforms} from 'sentry/data/platformCategories';\n+import platforms, {otherPlatform} from 'sentry/data/platforms';\n+import {t, tct} from 'sentry/locale';\n+import ConfigStore from 'sentry/stores/configStore';\n+import {useLegacyStore} from 'sentry/stores/useLegacyStore';\n+import pulsingIndicatorStyles from 'sentry/styles/pulsingIndicator';\n+import {space} from 'sentry/styles/space';\n+import type {PlatformKey, Project} from 'sentry/types/project';\n+import {getSelectedProjectList} from 'sentry/utils/project/useSelectedProjectsHaveField';\n+import useApi from 'sentry/utils/useApi';\n+import useOrganization from 'sentry/utils/useOrganization';\n+import usePageFilters from 'sentry/utils/usePageFilters';\n+import useProjects from 'sentry/utils/useProjects';\n+import {Referrer} from 'sentry/views/insights/agentMonitoring/utils/referrers';\n+import {useEAPSpans} from 'sentry/views/insights/common/queries/useDiscover';\n+\n+function useOnboardingProject() {\n+  const {projects} = useProjects();\n+  const pageFilters = usePageFilters();\n+  const selectedProject = getSelectedProjectList(\n+    pageFilters.selection.projects,\n+    projects\n+  );\n+  const agentMonitoringProjects = selectedProject.filter(p =>\n+    agentMonitoringPlatforms.has(p.platform as PlatformKey)\n+  );\n+\n+  if (agentMonitoringProjects.length > 0) {\n+    return agentMonitoringProjects[0];\n+  }\n+  return selectedProject[0];\n+}\n+\n+function useAgentEventWaiter(project: Project) {\n+  const [refetchKey, setRefetchKey] = useState(0);\n+\n+  const {data, isPending} = useEAPSpans(\n+    {\n+      search: 'span.op:\"gen_ai.*\"',\n+      fields: ['id'],\n+      limit: 1,\n+      enabled: !!project,\n+      useQueryOptions: {\n+        additonalQueryKey: [`refetch-${refetchKey}`],\n+      },\n+    },\n+    Referrer.ONBOARDING\n+  );\n+\n+  const hasEvents = Boolean(data?.length);\n+\n+  // Create a custom key that changes every 5 seconds to trigger refetch\n+  // TODO(aknaus): remove this and add refetchInterval to useEAPSpans\n+  useEffect(() => {\n+    if (!hasEvents) {\n+      const interval = setInterval(() => {\n+        setRefetchKey(prev => prev + 1);\n+      }, 5000); // Poll every 5 seconds\n+\n+      return () => clearInterval(interval);\n+    }\n+    return () => {};\n+  }, [hasEvents]);\n+\n+  return {\n+    hasEvents: Boolean(data?.length),\n+    isPending,\n+  };",
        "comment_created_at": "2025-06-24T13:45:00+00:00",
        "comment_author": "JonasBa",
        "comment_body": "I would caution from returning hasEvents here with the reasoning that someone might use hasEvents without actually checking the query states to correctly handle loading or error state.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2194383496",
    "pr_number": 94893,
    "pr_file": "static/app/views/codecov/tests/testSearchBar/testSearchBar.tsx",
    "created_at": "2025-07-09T08:21:39+00:00",
    "commented_code": "+import {useEffect, useRef} from 'react';\n+import {useSearchParams} from 'react-router-dom';\n+import styled from '@emotion/styled';\n+import debounce from 'lodash/debounce';\n+\n+import BaseSearchBar from 'sentry/components/searchBar';\n+import {t} from 'sentry/locale';\n+import {space} from 'sentry/styles/space';\n+\n+const FILTER_TO_NAME = {\n+  slowestTests: 'Slowest Tests',\n+  flakyTests: 'Flaky Tests',\n+  failedTests: 'Failed Tests',\n+  skippedTests: 'Skipped Tests',\n+};\n+\n+type TestSearchBarProps = {\n+  testCount: number;\n+};\n+\n+export function TestSearchBar({testCount}: TestSearchBarProps) {\n+  const [searchParams, setSearchParams] = useSearchParams();\n+  const term = searchParams.get('term') || '';\n+\n+  const filterBy = searchParams.get('filterBy') || '';\n+  const testTitle =\n+    filterBy in FILTER_TO_NAME\n+      ? FILTER_TO_NAME[filterBy as keyof typeof FILTER_TO_NAME]\n+      : 'Tests';\n+  const count = testCount > 999 ? `${(testCount / 1000).toFixed(1)}K` : testCount;\n+  const searchTitle = `${testTitle} (${count})`;\n+\n+  const handleSearchChangeRef = useRef<((newValue: string) => void) | null>(null);",
    "repo_full_name": "getsentry/sentry",
    "discussion_comments": [
      {
        "comment_id": "2194383496",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 94893,
        "pr_file": "static/app/views/codecov/tests/testSearchBar/testSearchBar.tsx",
        "discussion_id": "2194383496",
        "commented_code": "@@ -0,0 +1,91 @@\n+import {useEffect, useRef} from 'react';\n+import {useSearchParams} from 'react-router-dom';\n+import styled from '@emotion/styled';\n+import debounce from 'lodash/debounce';\n+\n+import BaseSearchBar from 'sentry/components/searchBar';\n+import {t} from 'sentry/locale';\n+import {space} from 'sentry/styles/space';\n+\n+const FILTER_TO_NAME = {\n+  slowestTests: 'Slowest Tests',\n+  flakyTests: 'Flaky Tests',\n+  failedTests: 'Failed Tests',\n+  skippedTests: 'Skipped Tests',\n+};\n+\n+type TestSearchBarProps = {\n+  testCount: number;\n+};\n+\n+export function TestSearchBar({testCount}: TestSearchBarProps) {\n+  const [searchParams, setSearchParams] = useSearchParams();\n+  const term = searchParams.get('term') || '';\n+\n+  const filterBy = searchParams.get('filterBy') || '';\n+  const testTitle =\n+    filterBy in FILTER_TO_NAME\n+      ? FILTER_TO_NAME[filterBy as keyof typeof FILTER_TO_NAME]\n+      : 'Tests';\n+  const count = testCount > 999 ? `${(testCount / 1000).toFixed(1)}K` : testCount;\n+  const searchTitle = `${testTitle} (${count})`;\n+\n+  const handleSearchChangeRef = useRef<((newValue: string) => void) | null>(null);",
        "comment_created_at": "2025-07-09T08:21:39+00:00",
        "comment_author": "calvin-codecov",
        "comment_body": "I like the use of useEffect to cleanup the function on unmount. I think we could achieve the same thing here by combining that idea with using a useMemo for the debounced function though, saving us from having to create an extra wrapper function on each render around the ref value, since the dependency array is also different now and shouldn't cause the linter to complain. We would still cleanup with the useEffect on unmount but have it do nothing typically. In this case, we can call the debounced function directly instead of invoking the ref's value, making it more straightforward.\r\n\r\nSo i'm thinking something like\r\n```\r\nconst handleSearchChange = useMemo(() => debounce(() => function))\r\nuseEffect(() => {\r\n  return () => { cleanup handleSearchChange}\r\n}\r\n\r\n*handleSearchChanged passed as usual to the component*\r\n\r\n```\r\nLet me know if that runs into any problems. I believe this should work the same way as you're proposing.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2155727400",
    "pr_number": 93893,
    "pr_file": "static/app/views/automations/components/automationForm.tsx",
    "created_at": "2025-06-18T23:46:00+00:00",
    "commented_code": "});\n   const connectedMonitors = monitors.filter(monitor => connectedIds.has(monitor.id));\n \n+  useEffect(() => {\n+    model.setValue('detectorIds', Array.from(connectedIds));",
    "repo_full_name": "getsentry/sentry",
    "discussion_comments": [
      {
        "comment_id": "2155727400",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 93893,
        "pr_file": "static/app/views/automations/components/automationForm.tsx",
        "discussion_id": "2155727400",
        "commented_code": "@@ -59,6 +59,10 @@ export default function AutomationForm({model}: {model: FormModel}) {\n   });\n   const connectedMonitors = monitors.filter(monitor => connectedIds.has(monitor.id));\n \n+  useEffect(() => {\n+    model.setValue('detectorIds', Array.from(connectedIds));",
        "comment_created_at": "2025-06-18T23:46:00+00:00",
        "comment_author": "scttcper",
        "comment_body": "can we update the model when the connectedIds changes instead of in an effect. Overall, the goal is usually to have as few useEffects as possible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2024743374",
    "pr_number": 88170,
    "pr_file": "static/app/utils/useResizableDrawer.tsx",
    "created_at": "2025-04-02T12:40:09+00:00",
    "commented_code": "* Call this function to manually set the size of the drawer.\n    */\n   setSize: (newSize: number, userEvent?: boolean) => void;\n-  /**\n-   * The resulting size of the container axis. Updated while dragging.\n-   *\n-   * NOTE: Be careful using this as this as react state updates are not\n-   * synchronous, you may want to update the element size using onResize instead\n-   */\n-  size: number;\n } {\n   const rafIdRef = useRef<number | null>(null);\n   const currentMouseVectorRaf = useRef<[number, number] | null>(null);\n-  const [size, setSize] = useState<number>(() => {\n-    const storedSize = options.sizeStorageKey\n-      ? parseInt(localStorage.getItem(options.sizeStorageKey) ?? '', 10)\n-      : undefined;\n-\n-    return storedSize || options.initialSize;\n-  });\n   const [isHeld, setIsHeld] = useState(false);\n+  const sizeRef = useRef<number>(options.initialSize);\n \n   const updateSize = useCallback(\n     (newSize: number, userEvent = false) => {\n-      setSize(newSize);\n-      options.onResize(newSize, undefined, userEvent);\n-      if (options.sizeStorageKey) {\n-        localStorage.setItem(options.sizeStorageKey, newSize.toString());\n-      }\n+      sizeRef.current = newSize;\n+      options.onResize(newSize, userEvent);\n     },\n     [options]",
    "repo_full_name": "getsentry/sentry",
    "discussion_comments": [
      {
        "comment_id": "2024743374",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 88170,
        "pr_file": "static/app/utils/useResizableDrawer.tsx",
        "discussion_id": "2024743374",
        "commented_code": "@@ -51,32 +47,16 @@ export function useResizableDrawer(options: UseResizableDrawerOptions): {\n    * Call this function to manually set the size of the drawer.\n    */\n   setSize: (newSize: number, userEvent?: boolean) => void;\n-  /**\n-   * The resulting size of the container axis. Updated while dragging.\n-   *\n-   * NOTE: Be careful using this as this as react state updates are not\n-   * synchronous, you may want to update the element size using onResize instead\n-   */\n-  size: number;\n } {\n   const rafIdRef = useRef<number | null>(null);\n   const currentMouseVectorRaf = useRef<[number, number] | null>(null);\n-  const [size, setSize] = useState<number>(() => {\n-    const storedSize = options.sizeStorageKey\n-      ? parseInt(localStorage.getItem(options.sizeStorageKey) ?? '', 10)\n-      : undefined;\n-\n-    return storedSize || options.initialSize;\n-  });\n   const [isHeld, setIsHeld] = useState(false);\n+  const sizeRef = useRef<number>(options.initialSize);\n \n   const updateSize = useCallback(\n     (newSize: number, userEvent = false) => {\n-      setSize(newSize);\n-      options.onResize(newSize, undefined, userEvent);\n-      if (options.sizeStorageKey) {\n-        localStorage.setItem(options.sizeStorageKey, newSize.toString());\n-      }\n+      sizeRef.current = newSize;\n+      options.onResize(newSize, userEvent);\n     },\n     [options]",
        "comment_created_at": "2025-04-02T12:40:09+00:00",
        "comment_author": "TkDodo",
        "comment_body": "making a memoized version of something with `useCallback` that depends on an object passed in as a prop (`options`) is rarely a good idea, because it means consumers would need to memoize the options object, which isn\u2019t clear, so lots of usages don\u2019t do it. It\u2019s also not a great API.\r\n\r\nIf we call `useResizableDrawer` with an inline object, this `useCallback` does nothing. That also means all further memoization that relies on `updateSize` will be disappointed because it will be a new reference every render.\r\n\r\nI guess the idea here was to have memoized versions returned to consumers, and there are consumers that do it right, like `flamegraphDrawer/profileDetails.tsx`, where we actually pass the returned functions to a memo\u2019d component.\r\n\r\n---\r\n\r\nMy suggestion here would be to use [the latest ref pattern](https://www.epicreact.dev/the-latest-ref-pattern-in-react) to write the options to a ref, then always use the latest version of it inside `useCallback`. This ensures consumers can pass options in however they want:\r\n\r\n```\r\nconst optionsRef = useRef(options);\r\nuseLayoutEffect(() => {\r\n  optionsRef.current = options;\r\n});\r\n```\r\n\r\nThis is also what react-query does to the options, because we need them in a `useEffect`, but don\u2019t want it to be \u201creactive\u201d towards it:\r\n\r\nhttps://github.com/TanStack/query/blob/ed2d4e95a00df867347e13de456bb8ba057c51da/packages/react-query-persist-client/src/PersistQueryClientProvider.tsx#L27-L29\r\n\r\nThis is also where `useEffectEvent` from React itself will help in the future.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2025294504",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 88170,
        "pr_file": "static/app/utils/useResizableDrawer.tsx",
        "discussion_id": "2024743374",
        "commented_code": "@@ -51,32 +47,16 @@ export function useResizableDrawer(options: UseResizableDrawerOptions): {\n    * Call this function to manually set the size of the drawer.\n    */\n   setSize: (newSize: number, userEvent?: boolean) => void;\n-  /**\n-   * The resulting size of the container axis. Updated while dragging.\n-   *\n-   * NOTE: Be careful using this as this as react state updates are not\n-   * synchronous, you may want to update the element size using onResize instead\n-   */\n-  size: number;\n } {\n   const rafIdRef = useRef<number | null>(null);\n   const currentMouseVectorRaf = useRef<[number, number] | null>(null);\n-  const [size, setSize] = useState<number>(() => {\n-    const storedSize = options.sizeStorageKey\n-      ? parseInt(localStorage.getItem(options.sizeStorageKey) ?? '', 10)\n-      : undefined;\n-\n-    return storedSize || options.initialSize;\n-  });\n   const [isHeld, setIsHeld] = useState(false);\n+  const sizeRef = useRef<number>(options.initialSize);\n \n   const updateSize = useCallback(\n     (newSize: number, userEvent = false) => {\n-      setSize(newSize);\n-      options.onResize(newSize, undefined, userEvent);\n-      if (options.sizeStorageKey) {\n-        localStorage.setItem(options.sizeStorageKey, newSize.toString());\n-      }\n+      sizeRef.current = newSize;\n+      options.onResize(newSize, userEvent);\n     },\n     [options]",
        "comment_created_at": "2025-04-02T17:36:37+00:00",
        "comment_author": "JonasBa",
        "comment_body": "Agree. This API is bad and needs to be changed.\r\n\r\nCurious, but why even use a useLayoutEffect for the latest ref? Couldn't you just write to the ref inside the hook body directly, I don't think that changes anything + you can drop the useLayoutEffect. The hook will be invoked if the options object changes, meaning you'd still get the latest value each time\r\n\r\n```\r\nconst optionsRef = useRef(options)\r\noptionsRef.current = options;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2026458762",
        "repo_full_name": "getsentry/sentry",
        "pr_number": 88170,
        "pr_file": "static/app/utils/useResizableDrawer.tsx",
        "discussion_id": "2024743374",
        "commented_code": "@@ -51,32 +47,16 @@ export function useResizableDrawer(options: UseResizableDrawerOptions): {\n    * Call this function to manually set the size of the drawer.\n    */\n   setSize: (newSize: number, userEvent?: boolean) => void;\n-  /**\n-   * The resulting size of the container axis. Updated while dragging.\n-   *\n-   * NOTE: Be careful using this as this as react state updates are not\n-   * synchronous, you may want to update the element size using onResize instead\n-   */\n-  size: number;\n } {\n   const rafIdRef = useRef<number | null>(null);\n   const currentMouseVectorRaf = useRef<[number, number] | null>(null);\n-  const [size, setSize] = useState<number>(() => {\n-    const storedSize = options.sizeStorageKey\n-      ? parseInt(localStorage.getItem(options.sizeStorageKey) ?? '', 10)\n-      : undefined;\n-\n-    return storedSize || options.initialSize;\n-  });\n   const [isHeld, setIsHeld] = useState(false);\n+  const sizeRef = useRef<number>(options.initialSize);\n \n   const updateSize = useCallback(\n     (newSize: number, userEvent = false) => {\n-      setSize(newSize);\n-      options.onResize(newSize, undefined, userEvent);\n-      if (options.sizeStorageKey) {\n-        localStorage.setItem(options.sizeStorageKey, newSize.toString());\n-      }\n+      sizeRef.current = newSize;\n+      options.onResize(newSize, userEvent);\n     },\n     [options]",
        "comment_created_at": "2025-04-03T08:19:03+00:00",
        "comment_author": "TkDodo",
        "comment_body": "it\u2019s technically not allowed to write to refs during render, as that is seen as a side-effect. The react compiler won\u2019t optimize components were it sees those patterns. Technically, react could start a render, you would write to the ref, then it aborts a render (e.g. when using concurrent features). In those cases, the ref would\u2019ve gotten updated \u201ctoo early\u201d, as the render didn\u2019t complete.\r\n\r\nso, it\u2019s just against the \u201crules of react\u201d.",
        "pr_file_module": null
      }
    ]
  }
]