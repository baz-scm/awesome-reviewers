[
  {
    "discussion_id": "1034605111",
    "pr_number": 1436,
    "pr_file": "src/Attachment.php",
    "created_at": "2022-11-29T11:01:04+00:00",
    "commented_code": "+<?php\n+\n+declare(strict_types=1);\n+\n+namespace Sentry;\n+\n+final class Attachment\n+{\n+    public const CONTENT_TYPE_DEFAULT = 'application/octet-stream';\n+\n+    /**\n+     * @var string\n+     */\n+    private $filename;\n+\n+    /**\n+     * @var string\n+     */\n+    private $contentType;\n+\n+    /**\n+     * @var string\n+     */\n+    private $data;\n+\n+    public function __construct(string $data, string $filename, string $contentType = self::CONTENT_TYPE_DEFAULT)\n+    {\n+        $this->data = $data;\n+        $this->filename = $filename;\n+        $this->contentType = $contentType;\n+    }\n+\n+    public function getFilename(): string\n+    {\n+        return $this->filename;\n+    }\n+\n+    public function getContentType(): string\n+    {\n+        return $this->contentType;\n+    }\n+\n+    public function getData(): string\n+    {\n+        return $this->data;\n+    }\n+\n+    /**\n+     * Helper method to create an Attachment from a file in the filesystem.\n+     */\n+    public static function fromFile(string $filename, string $contentType = self::CONTENT_TYPE_DEFAULT): self\n+    {\n+        $data = file_get_contents($filename);",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "1034605111",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 1436,
        "pr_file": "src/Attachment.php",
        "discussion_id": "1034605111",
        "commented_code": "@@ -0,0 +1,64 @@\n+<?php\n+\n+declare(strict_types=1);\n+\n+namespace Sentry;\n+\n+final class Attachment\n+{\n+    public const CONTENT_TYPE_DEFAULT = 'application/octet-stream';\n+\n+    /**\n+     * @var string\n+     */\n+    private $filename;\n+\n+    /**\n+     * @var string\n+     */\n+    private $contentType;\n+\n+    /**\n+     * @var string\n+     */\n+    private $data;\n+\n+    public function __construct(string $data, string $filename, string $contentType = self::CONTENT_TYPE_DEFAULT)\n+    {\n+        $this->data = $data;\n+        $this->filename = $filename;\n+        $this->contentType = $contentType;\n+    }\n+\n+    public function getFilename(): string\n+    {\n+        return $this->filename;\n+    }\n+\n+    public function getContentType(): string\n+    {\n+        return $this->contentType;\n+    }\n+\n+    public function getData(): string\n+    {\n+        return $this->data;\n+    }\n+\n+    /**\n+     * Helper method to create an Attachment from a file in the filesystem.\n+     */\n+    public static function fromFile(string $filename, string $contentType = self::CONTENT_TYPE_DEFAULT): self\n+    {\n+        $data = file_get_contents($filename);",
        "comment_created_at": "2022-11-29T11:01:04+00:00",
        "comment_author": "stayallive",
        "comment_body": "Since we are dealing with PHP here... we are reading the full file into memory without checking if it's within limits of something we can sent to Sentry (Sentry allows at most 20MB for a compressed request, and at most 100MB of uncompressed attachments per event). Although we might let the server bounce our request instead of adding client side validation.\r\n\r\nI wonder if it's possible to use streams to move the files instead of needing them in memory twice (once here and once when the payload is constructed). At the very least we should try to keep the memory footprint as low as possible until we are constructing the evelope.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1034611624",
    "pr_number": 1436,
    "pr_file": "src/Serializer/PayloadSerializer.php",
    "created_at": "2022-11-29T11:07:39+00:00",
    "commented_code": "}\n         }\n \n-        $itemHeader = [\n+        $eventItemHeader = [\n             'type' => (string) $event->getType(),\n             'content_type' => 'application/json',\n         ];\n \n-        return sprintf(\"%s\n%s\n%s\", JSON::encode($envelopeHeader), JSON::encode($itemHeader), $this->serializeAsEvent($event));\n+        $items = [\n+            JSON::encode($envelopeHeader),\n+            JSON::encode($eventItemHeader),\n+            $this->serializeAsEvent($event),\n+        ];\n+\n+        foreach ($event->getAttachments() as $attachment) {\n+            $data = $attachment->getData();\n+\n+            $attachmentItemHeader = [\n+                'type' => 'attachment',\n+                'filename' => $attachment->getFilename(),\n+                'content_type' => $attachment->getContentType(),\n+                'length' => \\strlen($data),",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "1034611624",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 1436,
        "pr_file": "src/Serializer/PayloadSerializer.php",
        "discussion_id": "1034611624",
        "commented_code": "@@ -215,12 +215,32 @@ private function serializeAsEnvelope(Event $event): string\n             }\n         }\n \n-        $itemHeader = [\n+        $eventItemHeader = [\n             'type' => (string) $event->getType(),\n             'content_type' => 'application/json',\n         ];\n \n-        return sprintf(\"%s\\n%s\\n%s\", JSON::encode($envelopeHeader), JSON::encode($itemHeader), $this->serializeAsEvent($event));\n+        $items = [\n+            JSON::encode($envelopeHeader),\n+            JSON::encode($eventItemHeader),\n+            $this->serializeAsEvent($event),\n+        ];\n+\n+        foreach ($event->getAttachments() as $attachment) {\n+            $data = $attachment->getData();\n+\n+            $attachmentItemHeader = [\n+                'type' => 'attachment',\n+                'filename' => $attachment->getFilename(),\n+                'content_type' => $attachment->getContentType(),\n+                'length' => \\strlen($data),",
        "comment_created_at": "2022-11-29T11:07:39+00:00",
        "comment_author": "stayallive",
        "comment_body": "We could replace this with `filesize()` on the file path (to not read the file multiple times into memory to count it's length).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1034612179",
    "pr_number": 1436,
    "pr_file": "src/Serializer/PayloadSerializer.php",
    "created_at": "2022-11-29T11:08:13+00:00",
    "commented_code": "}\n         }\n \n-        $itemHeader = [\n+        $eventItemHeader = [\n             'type' => (string) $event->getType(),\n             'content_type' => 'application/json',\n         ];\n \n-        return sprintf(\"%s\n%s\n%s\", JSON::encode($envelopeHeader), JSON::encode($itemHeader), $this->serializeAsEvent($event));\n+        $items = [\n+            JSON::encode($envelopeHeader),\n+            JSON::encode($eventItemHeader),\n+            $this->serializeAsEvent($event),\n+        ];\n+\n+        foreach ($event->getAttachments() as $attachment) {\n+            $data = $attachment->getData();\n+\n+            $attachmentItemHeader = [\n+                'type' => 'attachment',\n+                'filename' => $attachment->getFilename(),\n+                'content_type' => $attachment->getContentType(),\n+                'length' => \\strlen($data),\n+            ];\n+\n+            $items[] = JSON::encode($attachmentItemHeader);\n+            $items[] = $data;",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "1034612179",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 1436,
        "pr_file": "src/Serializer/PayloadSerializer.php",
        "discussion_id": "1034612179",
        "commented_code": "@@ -215,12 +215,32 @@ private function serializeAsEnvelope(Event $event): string\n             }\n         }\n \n-        $itemHeader = [\n+        $eventItemHeader = [\n             'type' => (string) $event->getType(),\n             'content_type' => 'application/json',\n         ];\n \n-        return sprintf(\"%s\\n%s\\n%s\", JSON::encode($envelopeHeader), JSON::encode($itemHeader), $this->serializeAsEvent($event));\n+        $items = [\n+            JSON::encode($envelopeHeader),\n+            JSON::encode($eventItemHeader),\n+            $this->serializeAsEvent($event),\n+        ];\n+\n+        foreach ($event->getAttachments() as $attachment) {\n+            $data = $attachment->getData();\n+\n+            $attachmentItemHeader = [\n+                'type' => 'attachment',\n+                'filename' => $attachment->getFilename(),\n+                'content_type' => $attachment->getContentType(),\n+                'length' => \\strlen($data),\n+            ];\n+\n+            $items[] = JSON::encode($attachmentItemHeader);\n+            $items[] = $data;",
        "comment_created_at": "2022-11-29T11:08:13+00:00",
        "comment_author": "stayallive",
        "comment_body": "As discussed earlier it might be better to only read the file here once. Otherwise we have it at least twice in memory.",
        "pr_file_module": null
      }
    ]
  }
]