[
  {
    "discussion_id": "977000484",
    "pr_number": 1360,
    "pr_file": "src/Serializer/PayloadSerializer.php",
    "created_at": "2022-09-21T21:27:50+00:00",
    "commented_code": "private function serializeAsEnvelope(Event $event): string\n     {\n-        $envelopeHeader = JSON::encode([\n+        /**\n+         * @see https://develop.sentry.dev/sdk/envelopes/#envelope-headers\n+         */",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "977000484",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 1360,
        "pr_file": "src/Serializer/PayloadSerializer.php",
        "discussion_id": "977000484",
        "commented_code": "@@ -175,17 +194,34 @@ public function toArray(Event $event): array\n \n     private function serializeAsEnvelope(Event $event): string\n     {\n-        $envelopeHeader = JSON::encode([\n+        /**\n+         * @see https://develop.sentry.dev/sdk/envelopes/#envelope-headers\n+         */",
        "comment_created_at": "2022-09-21T21:27:50+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Usually inline comments like this one are formatted on a single line, e.g. `/** @see ... */`",
        "pr_file_module": null
      },
      {
        "comment_id": "979647304",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 1360,
        "pr_file": "src/Serializer/PayloadSerializer.php",
        "discussion_id": "977000484",
        "commented_code": "@@ -175,17 +194,34 @@ public function toArray(Event $event): array\n \n     private function serializeAsEnvelope(Event $event): string\n     {\n-        $envelopeHeader = JSON::encode([\n+        /**\n+         * @see https://develop.sentry.dev/sdk/envelopes/#envelope-headers\n+         */",
        "comment_created_at": "2022-09-26T07:23:25+00:00",
        "comment_author": "cleptric",
        "comment_body": "I would expect our code-style checks to catch this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "279093585",
    "pr_number": 807,
    "pr_file": "src/Integration/RequestIntegration.php",
    "created_at": "2019-04-26T20:29:40+00:00",
    "commented_code": "{\n         $keysToRemove = ['authorization', 'cookie', 'set-cookie', 'remote_addr'];\n \n-        return array_filter($headers, function ($key) use ($keysToRemove) {\n-            return !\\in_array(strtolower($key), $keysToRemove, true);\n-        }, ARRAY_FILTER_USE_KEY);\n+        return array_filter(\n+            $headers,\n+            static function (string $key) use ($keysToRemove): bool {\n+                return !\\in_array(strtolower($key), $keysToRemove, true);\n+            },\n+            ARRAY_FILTER_USE_KEY\n+        );\n+    }\n+\n+    /**\n+     * Gets the decoded body of the request, if available. If the Content-Type\n+     * header contains \"application/json\" then the content is decoded and if\n+     * the parsing fails then the raw data is returned. If there are submitted\n+     * fields or files, all of their information are parsed and returned.\n+     *\n+     * @param ServerRequestInterface $serverRequest The server request\n+     *\n+     * @return mixed\n+     */\n+    private function captureRequestBody(ServerRequestInterface $serverRequest)\n+    {\n+        $maxRequestBodySize = $this->options->getRequestBodies();\n+        $requestBody = $serverRequest->getBody();\n+\n+        if ('none' === $maxRequestBodySize || ('small' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_SMALL_MAX_CONTENT_LENGTH) || ('medium' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_MEDIUM_MAX_CONTENT_LENGTH)) {",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "279093585",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 807,
        "pr_file": "src/Integration/RequestIntegration.php",
        "discussion_id": "279093585",
        "commented_code": "@@ -109,8 +132,64 @@ private function removePiiFromHeaders(array $headers): array\n     {\n         $keysToRemove = ['authorization', 'cookie', 'set-cookie', 'remote_addr'];\n \n-        return array_filter($headers, function ($key) use ($keysToRemove) {\n-            return !\\in_array(strtolower($key), $keysToRemove, true);\n-        }, ARRAY_FILTER_USE_KEY);\n+        return array_filter(\n+            $headers,\n+            static function (string $key) use ($keysToRemove): bool {\n+                return !\\in_array(strtolower($key), $keysToRemove, true);\n+            },\n+            ARRAY_FILTER_USE_KEY\n+        );\n+    }\n+\n+    /**\n+     * Gets the decoded body of the request, if available. If the Content-Type\n+     * header contains \"application/json\" then the content is decoded and if\n+     * the parsing fails then the raw data is returned. If there are submitted\n+     * fields or files, all of their information are parsed and returned.\n+     *\n+     * @param ServerRequestInterface $serverRequest The server request\n+     *\n+     * @return mixed\n+     */\n+    private function captureRequestBody(ServerRequestInterface $serverRequest)\n+    {\n+        $maxRequestBodySize = $this->options->getRequestBodies();\n+        $requestBody = $serverRequest->getBody();\n+\n+        if ('none' === $maxRequestBodySize || ('small' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_SMALL_MAX_CONTENT_LENGTH) || ('medium' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_MEDIUM_MAX_CONTENT_LENGTH)) {",
        "comment_created_at": "2019-04-26T20:29:40+00:00",
        "comment_author": "Jean85",
        "comment_body": "Please split this on multiple lines for better readability:\r\n\r\n```suggestion\r\n        if (\r\n        'none' === $maxRequestBodySize \r\n        || ('small' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_SMALL_MAX_CONTENT_LENGTH) \r\n        || ('medium' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_MEDIUM_MAX_CONTENT_LENGTH)\r\n        ) {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "279093881",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 807,
        "pr_file": "src/Integration/RequestIntegration.php",
        "discussion_id": "279093585",
        "commented_code": "@@ -109,8 +132,64 @@ private function removePiiFromHeaders(array $headers): array\n     {\n         $keysToRemove = ['authorization', 'cookie', 'set-cookie', 'remote_addr'];\n \n-        return array_filter($headers, function ($key) use ($keysToRemove) {\n-            return !\\in_array(strtolower($key), $keysToRemove, true);\n-        }, ARRAY_FILTER_USE_KEY);\n+        return array_filter(\n+            $headers,\n+            static function (string $key) use ($keysToRemove): bool {\n+                return !\\in_array(strtolower($key), $keysToRemove, true);\n+            },\n+            ARRAY_FILTER_USE_KEY\n+        );\n+    }\n+\n+    /**\n+     * Gets the decoded body of the request, if available. If the Content-Type\n+     * header contains \"application/json\" then the content is decoded and if\n+     * the parsing fails then the raw data is returned. If there are submitted\n+     * fields or files, all of their information are parsed and returned.\n+     *\n+     * @param ServerRequestInterface $serverRequest The server request\n+     *\n+     * @return mixed\n+     */\n+    private function captureRequestBody(ServerRequestInterface $serverRequest)\n+    {\n+        $maxRequestBodySize = $this->options->getRequestBodies();\n+        $requestBody = $serverRequest->getBody();\n+\n+        if ('none' === $maxRequestBodySize || ('small' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_SMALL_MAX_CONTENT_LENGTH) || ('medium' === $maxRequestBodySize && $requestBody->getSize() > self::REQUEST_BODY_MEDIUM_MAX_CONTENT_LENGTH)) {",
        "comment_created_at": "2019-04-26T20:30:40+00:00",
        "comment_author": "Jean85",
        "comment_body": "Or even better, we could split this in a private method with a switch of the enum.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "384395313",
    "pr_number": 984,
    "pr_file": "tests/Integration/RequestIntegrationTest.php",
    "created_at": "2020-02-26T10:13:47+00:00",
    "commented_code": "return $stream;\n     }\n+\n+    private function createRequestFactory(ServerRequestInterface $request): RequestFactory\n+    {\n+        return new class($request) implements RequestFactory {\n+            /** @var ServerRequestInterface */",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "384395313",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 984,
        "pr_file": "tests/Integration/RequestIntegrationTest.php",
        "discussion_id": "384395313",
        "commented_code": "@@ -442,4 +443,22 @@ private function getStreamMock(int $size, string $content = ''): StreamInterface\n \n         return $stream;\n     }\n+\n+    private function createRequestFactory(ServerRequestInterface $request): RequestFactory\n+    {\n+        return new class($request) implements RequestFactory {\n+            /** @var ServerRequestInterface */",
        "comment_created_at": "2020-02-26T10:13:47+00:00",
        "comment_author": "ste93cry",
        "comment_body": ":pray: format the DocBlock so that it's multiline to keep consistency with the rest of the codebase",
        "pr_file_module": null
      },
      {
        "comment_id": "384404847",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 984,
        "pr_file": "tests/Integration/RequestIntegrationTest.php",
        "discussion_id": "384395313",
        "commented_code": "@@ -442,4 +443,22 @@ private function getStreamMock(int $size, string $content = ''): StreamInterface\n \n         return $stream;\n     }\n+\n+    private function createRequestFactory(ServerRequestInterface $request): RequestFactory\n+    {\n+        return new class($request) implements RequestFactory {\n+            /** @var ServerRequestInterface */",
        "comment_created_at": "2020-02-26T10:31:12+00:00",
        "comment_author": "iluuu1994",
        "comment_body": "There's a [fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer/blob/2.16/src/Fixer/Phpdoc/PhpdocLineSpanFixer.php) for that.",
        "pr_file_module": null
      },
      {
        "comment_id": "384407292",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 984,
        "pr_file": "tests/Integration/RequestIntegrationTest.php",
        "discussion_id": "384395313",
        "commented_code": "@@ -442,4 +443,22 @@ private function getStreamMock(int $size, string $content = ''): StreamInterface\n \n         return $stream;\n     }\n+\n+    private function createRequestFactory(ServerRequestInterface $request): RequestFactory\n+    {\n+        return new class($request) implements RequestFactory {\n+            /** @var ServerRequestInterface */",
        "comment_created_at": "2020-02-26T10:35:28+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Nice to know, would you be so kind to add it to the PHPCS config to avoid further issues in the future?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "272749756",
    "pr_number": 798,
    "pr_file": "src/Breadcrumb.php",
    "created_at": "2019-04-05T21:29:27+00:00",
    "commented_code": "];\n     }\n \n+    /**\n+     * Constructon helper.",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "272749756",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 798,
        "pr_file": "src/Breadcrumb.php",
        "discussion_id": "272749756",
        "commented_code": "@@ -357,6 +362,22 @@ public function toArray(): array\n         ];\n     }\n \n+    /**\n+     * Constructon helper.",
        "comment_created_at": "2019-04-05T21:29:27+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please change this description to something like `Helper method to create an instance of this class from an array of data`. Also, as a convention we try to not write comments longer than 80 characters (it's a soft limit anyway, nothing enforced strictly) but if this is the case please consider splitting it into multiple lines to improve readability",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "254229540",
    "pr_number": 752,
    "pr_file": "tests/EventTest.php",
    "created_at": "2019-02-06T11:16:20+00:00",
    "commented_code": "$this->assertEquals($expected, $event->toArray());\n     }\n \n-    public function testToArrayWithMessage(): void\n+    /**\n+     * @dataProvider toArrayWithMessageDataProvider\n+     */\n+    public function testToArrayWithMessage(array $message, $expectedValue): void\n     {\n         $event = new Event();\n-        $event->setMessage('foo bar');\n+        call_user_func_array([$event, 'setMessage'], $message);\n \n         $data = $event->toArray();\n \n         $this->assertArrayHasKey('message', $data);\n-        $this->assertEquals('foo bar', $data['message']);\n+        $this->assertSame($expectedValue, $data['message']);\n     }\n \n-    public function testToArrayWithMessageWithParams(): void\n+    public function toArrayWithMessageDataProvider(): array\n     {\n-        $expected = [\n-            'message' => 'foo %s',\n-            'params' => ['bar'],\n-            'formatted' => 'foo bar',\n+        return [\n+            [['foo bar'], 'foo bar'],",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "254229540",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 752,
        "pr_file": "tests/EventTest.php",
        "discussion_id": "254229540",
        "commented_code": "@@ -119,32 +119,27 @@ public function testToArray(): void\n         $this->assertEquals($expected, $event->toArray());\n     }\n \n-    public function testToArrayWithMessage(): void\n+    /**\n+     * @dataProvider toArrayWithMessageDataProvider\n+     */\n+    public function testToArrayWithMessage(array $message, $expectedValue): void\n     {\n         $event = new Event();\n-        $event->setMessage('foo bar');\n+        call_user_func_array([$event, 'setMessage'], $message);\n \n         $data = $event->toArray();\n \n         $this->assertArrayHasKey('message', $data);\n-        $this->assertEquals('foo bar', $data['message']);\n+        $this->assertSame($expectedValue, $data['message']);\n     }\n \n-    public function testToArrayWithMessageWithParams(): void\n+    public function toArrayWithMessageDataProvider(): array\n     {\n-        $expected = [\n-            'message' => 'foo %s',\n-            'params' => ['bar'],\n-            'formatted' => 'foo bar',\n+        return [\n+            [['foo bar'], 'foo bar'],",
        "comment_created_at": "2019-02-06T11:16:20+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please split this array into multiple lines (have a look at how other data providers are formatted)",
        "pr_file_module": null
      },
      {
        "comment_id": "255371870",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 752,
        "pr_file": "tests/EventTest.php",
        "discussion_id": "254229540",
        "commented_code": "@@ -119,32 +119,27 @@ public function testToArray(): void\n         $this->assertEquals($expected, $event->toArray());\n     }\n \n-    public function testToArrayWithMessage(): void\n+    /**\n+     * @dataProvider toArrayWithMessageDataProvider\n+     */\n+    public function testToArrayWithMessage(array $message, $expectedValue): void\n     {\n         $event = new Event();\n-        $event->setMessage('foo bar');\n+        call_user_func_array([$event, 'setMessage'], $message);\n \n         $data = $event->toArray();\n \n         $this->assertArrayHasKey('message', $data);\n-        $this->assertEquals('foo bar', $data['message']);\n+        $this->assertSame($expectedValue, $data['message']);\n     }\n \n-    public function testToArrayWithMessageWithParams(): void\n+    public function toArrayWithMessageDataProvider(): array\n     {\n-        $expected = [\n-            'message' => 'foo %s',\n-            'params' => ['bar'],\n-            'formatted' => 'foo bar',\n+        return [\n+            [['foo bar'], 'foo bar'],",
        "comment_created_at": "2019-02-11T02:39:01+00:00",
        "comment_author": "mfb",
        "comment_body": "It looks like some data provider arrays are split into multiple lines while some are not.  Cleaning all of those up seems out of scope for this PR though.",
        "pr_file_module": null
      },
      {
        "comment_id": "255407330",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 752,
        "pr_file": "tests/EventTest.php",
        "discussion_id": "254229540",
        "commented_code": "@@ -119,32 +119,27 @@ public function testToArray(): void\n         $this->assertEquals($expected, $event->toArray());\n     }\n \n-    public function testToArrayWithMessage(): void\n+    /**\n+     * @dataProvider toArrayWithMessageDataProvider\n+     */\n+    public function testToArrayWithMessage(array $message, $expectedValue): void\n     {\n         $event = new Event();\n-        $event->setMessage('foo bar');\n+        call_user_func_array([$event, 'setMessage'], $message);\n \n         $data = $event->toArray();\n \n         $this->assertArrayHasKey('message', $data);\n-        $this->assertEquals('foo bar', $data['message']);\n+        $this->assertSame($expectedValue, $data['message']);\n     }\n \n-    public function testToArrayWithMessageWithParams(): void\n+    public function toArrayWithMessageDataProvider(): array\n     {\n-        $expected = [\n-            'message' => 'foo %s',\n-            'params' => ['bar'],\n-            'formatted' => 'foo bar',\n+        return [\n+            [['foo bar'], 'foo bar'],",
        "comment_created_at": "2019-02-11T08:24:24+00:00",
        "comment_author": "ste93cry",
        "comment_body": "I meant the data provider of this file. You should format the arrays one item per line if possible, e.g.\r\n\r\n```php\r\n[\r\n    [\r\n        'foo @bar',\r\n        [\r\n            '@bar' => 'bar',\r\n        ],\r\n        'foo bar',\r\n    ],\r\n    [\r\n        'message' => 'foo @bar',\r\n        'params' => [\r\n            '@bar' => 'bar',\r\n        ],\r\n        'formatted' => 'foo bar',\r\n    ],\r\n]\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "255411282",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 752,
        "pr_file": "tests/EventTest.php",
        "discussion_id": "254229540",
        "commented_code": "@@ -119,32 +119,27 @@ public function testToArray(): void\n         $this->assertEquals($expected, $event->toArray());\n     }\n \n-    public function testToArrayWithMessage(): void\n+    /**\n+     * @dataProvider toArrayWithMessageDataProvider\n+     */\n+    public function testToArrayWithMessage(array $message, $expectedValue): void\n     {\n         $event = new Event();\n-        $event->setMessage('foo bar');\n+        call_user_func_array([$event, 'setMessage'], $message);\n \n         $data = $event->toArray();\n \n         $this->assertArrayHasKey('message', $data);\n-        $this->assertEquals('foo bar', $data['message']);\n+        $this->assertSame($expectedValue, $data['message']);\n     }\n \n-    public function testToArrayWithMessageWithParams(): void\n+    public function toArrayWithMessageDataProvider(): array\n     {\n-        $expected = [\n-            'message' => 'foo %s',\n-            'params' => ['bar'],\n-            'formatted' => 'foo bar',\n+        return [\n+            [['foo bar'], 'foo bar'],",
        "comment_created_at": "2019-02-11T08:40:48+00:00",
        "comment_author": "mfb",
        "comment_body": "FYI there was a pre-existing data provider in this file that has \"packed\" array syntax:\r\n```\r\n            ['modules', ['foo' => '0.0.1', 'bar' => '0.0.2'], ['modules' => ['foo' => '0.0.1', 'bar' => '0.0.2']]],\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "255419736",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 752,
        "pr_file": "tests/EventTest.php",
        "discussion_id": "254229540",
        "commented_code": "@@ -119,32 +119,27 @@ public function testToArray(): void\n         $this->assertEquals($expected, $event->toArray());\n     }\n \n-    public function testToArrayWithMessage(): void\n+    /**\n+     * @dataProvider toArrayWithMessageDataProvider\n+     */\n+    public function testToArrayWithMessage(array $message, $expectedValue): void\n     {\n         $event = new Event();\n-        $event->setMessage('foo bar');\n+        call_user_func_array([$event, 'setMessage'], $message);\n \n         $data = $event->toArray();\n \n         $this->assertArrayHasKey('message', $data);\n-        $this->assertEquals('foo bar', $data['message']);\n+        $this->assertSame($expectedValue, $data['message']);\n     }\n \n-    public function testToArrayWithMessageWithParams(): void\n+    public function toArrayWithMessageDataProvider(): array\n     {\n-        $expected = [\n-            'message' => 'foo %s',\n-            'params' => ['bar'],\n-            'formatted' => 'foo bar',\n+        return [\n+            [['foo bar'], 'foo bar'],",
        "comment_created_at": "2019-02-11T09:08:04+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Thank you for reporting this, some inconsistencies are indeed possible since style is not forced by PHPCS-Fixer. However I would prefer usage of the \"expanded\" version",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "253453528",
    "pr_number": 762,
    "pr_file": "src/ErrorHandler.php",
    "created_at": "2019-02-04T12:40:18+00:00",
    "commented_code": "// first call to the set_error_handler method would cause the PHP\n             // bug https://bugs.php.net/63206 if the handler is not the first\n             // one in the chain of handlers\n-            set_error_handler([$this, 'handleError'], $this->capturedErrors);\n-\n-            $this->isRoot = true;\n+            set_error_handler([$this, 'handleError'], E_ALL);\n         }\n \n         $this->previousExceptionHandler = set_exception_handler([$this, 'handleException']);\n     }\n \n     /**\n-     * Registers this error handler and associates the given callback to the\n-     * instance.\n-     *\n-     * @param callable $callback           callback that will be called when exception is caught\n-     * @param int      $reservedMemorySize The amount of memory to reserve for the fatal error handler\n+     * Gets the current registered error handler; if none is present, it will register it.\n      *\n-     * @return self\n+     * @param int|null $reservedMemorySize The requested amount of memory to reserve\n      *\n-     * @throws \\ReflectionException\n+     * @return ErrorHandler The ErrorHandler singleton\n      */\n-    public static function register(callable $callback, int $reservedMemorySize = self::DEFAULT_RESERVED_MEMORY_SIZE): self\n+    public static function getRegisteredHandler(int $reservedMemorySize = null): self\n     {\n-        return new self($callback, $reservedMemorySize);\n+        if (null === self::$registeredHandler) {\n+            self::$registeredHandler = new self($reservedMemorySize ?? self::DEFAULT_RESERVED_MEMORY_SIZE);\n+        } elseif (null !== $reservedMemorySize) {\n+            self::setReservedMemory($reservedMemorySize);\n+        }\n+\n+        return self::$registeredHandler;\n     }\n \n     /**\n-     * Sets the PHP error levels that will be captured by the Raven client when\n-     * a PHP error occurs.\n+     * Adds a listener to the current error handler to be called upon each invoked captured error;\n+     * if no handler is registered, this method will instantiate and register it.\n      *\n-     * @param int  $levels  A bit field of E_* constants for captured errors\n-     * @param bool $replace Whether to replace or amend the previous value\n+     * If you want to use a naked callable and not an object as a listener,\n+     * you can create one with \\Closure::fromCallable.\n      *\n-     * @return int The previous value\n+     * @param ErrorListenerInterface $listener A type-safe callable that will act as a listener\n      */\n-    public function captureAt(int $levels, bool $replace = false): int\n+    public static function addErrorListener(ErrorListenerInterface $listener): void\n     {\n-        $prev = $this->capturedErrors;\n+        $handler = self::getRegisteredHandler();\n+        $handler->errorListeners[] = $listener;\n+    }\n \n-        $this->capturedErrors = $levels;\n+    /**\n+     * Adds a listener to the current error handler to be called upon each invoked captured exception;\n+     * if no handler is registered, this method will instantiate and register it.\n+     *\n+     * If you want to use a naked callable and not an object as a listener,\n+     * you can create one with \\Closure::fromCallable.\n+     *\n+     * @param ExceptionListenerInterface $listener A type-safe callable that will act as a listener\n+     */\n+    public static function addExceptionListener(ExceptionListenerInterface $listener): void\n+    {\n+        $handler = self::getRegisteredHandler();\n+        $handler->exceptionListeners[] = $listener;\n+    }\n \n-        if (!$replace) {\n-            $this->capturedErrors |= $prev;\n+    /**\n+     * Fills a static property with a string to reserve some memory to be used while handling fatal errors.\n+     * \n+     * @param int $reservedMemorySize The amount of memory to be reserved, is in char string length \n+     */\n+    private static function setReservedMemory(int $reservedMemorySize): void",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "253453528",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 762,
        "pr_file": "src/ErrorHandler.php",
        "discussion_id": "253453528",
        "commented_code": "@@ -111,52 +100,72 @@ private function __construct(callable $callback, int $reservedMemorySize = self:\n             // first call to the set_error_handler method would cause the PHP\n             // bug https://bugs.php.net/63206 if the handler is not the first\n             // one in the chain of handlers\n-            set_error_handler([$this, 'handleError'], $this->capturedErrors);\n-\n-            $this->isRoot = true;\n+            set_error_handler([$this, 'handleError'], E_ALL);\n         }\n \n         $this->previousExceptionHandler = set_exception_handler([$this, 'handleException']);\n     }\n \n     /**\n-     * Registers this error handler and associates the given callback to the\n-     * instance.\n-     *\n-     * @param callable $callback           callback that will be called when exception is caught\n-     * @param int      $reservedMemorySize The amount of memory to reserve for the fatal error handler\n+     * Gets the current registered error handler; if none is present, it will register it.\n      *\n-     * @return self\n+     * @param int|null $reservedMemorySize The requested amount of memory to reserve\n      *\n-     * @throws \\ReflectionException\n+     * @return ErrorHandler The ErrorHandler singleton\n      */\n-    public static function register(callable $callback, int $reservedMemorySize = self::DEFAULT_RESERVED_MEMORY_SIZE): self\n+    public static function getRegisteredHandler(int $reservedMemorySize = null): self\n     {\n-        return new self($callback, $reservedMemorySize);\n+        if (null === self::$registeredHandler) {\n+            self::$registeredHandler = new self($reservedMemorySize ?? self::DEFAULT_RESERVED_MEMORY_SIZE);\n+        } elseif (null !== $reservedMemorySize) {\n+            self::setReservedMemory($reservedMemorySize);\n+        }\n+\n+        return self::$registeredHandler;\n     }\n \n     /**\n-     * Sets the PHP error levels that will be captured by the Raven client when\n-     * a PHP error occurs.\n+     * Adds a listener to the current error handler to be called upon each invoked captured error;\n+     * if no handler is registered, this method will instantiate and register it.\n      *\n-     * @param int  $levels  A bit field of E_* constants for captured errors\n-     * @param bool $replace Whether to replace or amend the previous value\n+     * If you want to use a naked callable and not an object as a listener,\n+     * you can create one with \\Closure::fromCallable.\n      *\n-     * @return int The previous value\n+     * @param ErrorListenerInterface $listener A type-safe callable that will act as a listener\n      */\n-    public function captureAt(int $levels, bool $replace = false): int\n+    public static function addErrorListener(ErrorListenerInterface $listener): void\n     {\n-        $prev = $this->capturedErrors;\n+        $handler = self::getRegisteredHandler();\n+        $handler->errorListeners[] = $listener;\n+    }\n \n-        $this->capturedErrors = $levels;\n+    /**\n+     * Adds a listener to the current error handler to be called upon each invoked captured exception;\n+     * if no handler is registered, this method will instantiate and register it.\n+     *\n+     * If you want to use a naked callable and not an object as a listener,\n+     * you can create one with \\Closure::fromCallable.\n+     *\n+     * @param ExceptionListenerInterface $listener A type-safe callable that will act as a listener\n+     */\n+    public static function addExceptionListener(ExceptionListenerInterface $listener): void\n+    {\n+        $handler = self::getRegisteredHandler();\n+        $handler->exceptionListeners[] = $listener;\n+    }\n \n-        if (!$replace) {\n-            $this->capturedErrors |= $prev;\n+    /**\n+     * Fills a static property with a string to reserve some memory to be used while handling fatal errors.\n+     * \n+     * @param int $reservedMemorySize The amount of memory to be reserved, is in char string length \n+     */\n+    private static function setReservedMemory(int $reservedMemorySize): void",
        "comment_created_at": "2019-02-04T12:40:18+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please keep all `private` functions after `public` ones",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "253686457",
    "pr_number": 762,
    "pr_file": "tests/Fixtures/classes/StubErrorListener.php",
    "created_at": "2019-02-04T23:23:08+00:00",
    "commented_code": "+<?php\n+\n+namespace Sentry\\Tests\\Fixtures\\classes;\n+\n+use Sentry\\ErrorListenerInterface;\n+\n+final class StubErrorListener implements ErrorListenerInterface\n+{\n+    /** @var \\ErrorException|null */\n+    private $error;\n+    \n+    /** @var callable|null */",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "253686457",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 762,
        "pr_file": "tests/Fixtures/classes/StubErrorListener.php",
        "discussion_id": "253686457",
        "commented_code": "@@ -0,0 +1,33 @@\n+<?php\n+\n+namespace Sentry\\Tests\\Fixtures\\classes;\n+\n+use Sentry\\ErrorListenerInterface;\n+\n+final class StubErrorListener implements ErrorListenerInterface\n+{\n+    /** @var \\ErrorException|null */\n+    private $error;\n+    \n+    /** @var callable|null */",
        "comment_created_at": "2019-02-04T23:23:08+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please split this docblock into multiple lines",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "253686506",
    "pr_number": 762,
    "pr_file": "tests/Fixtures/classes/StubTransport.php",
    "created_at": "2019-02-04T23:23:20+00:00",
    "commented_code": "+<?php\n+\n+namespace Sentry\\Tests\\Fixtures\\classes;\n+\n+use Sentry\\Event;\n+use Sentry\\Transport\\TransportInterface;\n+\n+class StubTransport implements TransportInterface\n+{\n+    /** @var Event[] */",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "253686506",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 762,
        "pr_file": "tests/Fixtures/classes/StubTransport.php",
        "discussion_id": "253686506",
        "commented_code": "@@ -0,0 +1,36 @@\n+<?php\n+\n+namespace Sentry\\Tests\\Fixtures\\classes;\n+\n+use Sentry\\Event;\n+use Sentry\\Transport\\TransportInterface;\n+\n+class StubTransport implements TransportInterface\n+{\n+    /** @var Event[] */",
        "comment_created_at": "2019-02-04T23:23:20+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please split this docblock into multiple lines",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "253686513",
    "pr_number": 762,
    "pr_file": "tests/Fixtures/classes/StubTransport.php",
    "created_at": "2019-02-04T23:23:23+00:00",
    "commented_code": "+<?php\n+\n+namespace Sentry\\Tests\\Fixtures\\classes;\n+\n+use Sentry\\Event;\n+use Sentry\\Transport\\TransportInterface;\n+\n+class StubTransport implements TransportInterface\n+{\n+    /** @var Event[] */\n+    private $events = [];\n+    \n+    /** @var Event|null */",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "253686513",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 762,
        "pr_file": "tests/Fixtures/classes/StubTransport.php",
        "discussion_id": "253686513",
        "commented_code": "@@ -0,0 +1,36 @@\n+<?php\n+\n+namespace Sentry\\Tests\\Fixtures\\classes;\n+\n+use Sentry\\Event;\n+use Sentry\\Transport\\TransportInterface;\n+\n+class StubTransport implements TransportInterface\n+{\n+    /** @var Event[] */\n+    private $events = [];\n+    \n+    /** @var Event|null */",
        "comment_created_at": "2019-02-04T23:23:23+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please split this docblock into multiple lines",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "253802440",
    "pr_number": 762,
    "pr_file": "src/ErrorHandler.php",
    "created_at": "2019-02-05T10:14:59+00:00",
    "commented_code": "$this->handleException($previousExceptionHandlerException);\n     }\n \n+    /**\n+     * Fills a static property with a string to reserve some memory to be used while handling fatal errors.",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "253802440",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 762,
        "pr_file": "src/ErrorHandler.php",
        "discussion_id": "253802440",
        "commented_code": "@@ -268,6 +254,20 @@ public function handleException(\\Throwable $exception): void\n         $this->handleException($previousExceptionHandlerException);\n     }\n \n+    /**\n+     * Fills a static property with a string to reserve some memory to be used while handling fatal errors.",
        "comment_created_at": "2019-02-05T10:14:59+00:00",
        "comment_author": "ste93cry",
        "comment_body": "Please try to split the descriptions comments so that each line length is around 80 characters at most",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "254487367",
    "pr_number": 762,
    "pr_file": "src/ErrorHandler.php",
    "created_at": "2019-02-06T23:00:00+00:00",
    "commented_code": "// first call to the set_error_handler method would cause the PHP\n             // bug https://bugs.php.net/63206 if the handler is not the first\n             // one in the chain of handlers\n-            set_error_handler([$this, 'handleError'], $this->capturedErrors);\n-\n-            $this->isRoot = true;\n+            set_error_handler([$this, 'handleError'], E_ALL);\n         }\n \n         $this->previousExceptionHandler = set_exception_handler([$this, 'handleException']);\n     }\n \n     /**\n-     * Registers this error handler and associates the given callback to the\n-     * instance.\n+     * Gets the current registered error handler; if none is present, it will register it.\n+     * Subsequent calls will not change the reserved memory size.\n      *\n-     * @param callable $callback           callback that will be called when exception is caught\n-     * @param int      $reservedMemorySize The amount of memory to reserve for the fatal error handler\n+     * @param int|null $reservedMemorySize The requested amount of memory to reserve\n      *\n-     * @return self\n-     *\n-     * @throws \\ReflectionException\n+     * @return self The ErrorHandler singleton\n      */\n-    public static function register(callable $callback, int $reservedMemorySize = self::DEFAULT_RESERVED_MEMORY_SIZE): self\n+    public static function registerOnce(int $reservedMemorySize = null): self\n     {\n-        return new self($callback, $reservedMemorySize);\n+        if (null === self::$handlerInstance) {\n+            self::$handlerInstance = new self($reservedMemorySize ?? self::DEFAULT_RESERVED_MEMORY_SIZE);\n+        }\n+\n+        return self::$handlerInstance;\n     }\n \n     /**\n-     * Sets the PHP error levels that will be captured by the Raven client when\n-     * a PHP error occurs.\n+     * Adds a listener to the current error handler to be called upon each invoked captured error;\n+     * if no handler is registered, this method will instantiate and register it.\n      *\n-     * @param int  $levels  A bit field of E_* constants for captured errors\n-     * @param bool $replace Whether to replace or amend the previous value\n-     *\n-     * @return int The previous value\n+     * @param callable $listener A callable that will act as a listener; this callable will receive\n+     *                           a single \\ErrorException argument\n      */\n-    public function captureAt(int $levels, bool $replace = false): int\n+    public static function addErrorListener(callable $listener): void\n     {\n-        $prev = $this->capturedErrors;\n-\n-        $this->capturedErrors = $levels;\n-\n-        if (!$replace) {\n-            $this->capturedErrors |= $prev;\n-        }\n-\n-        $this->reRegister($prev);\n+        $handler = self::registerOnce();\n+        $handler->errorListeners[] = $listener;\n+    }\n \n-        return $prev;\n+    /**\n+     * Adds a listener to the current error handler to be called upon each invoked captured exception;",
    "repo_full_name": "getsentry/sentry-php",
    "discussion_comments": [
      {
        "comment_id": "254487367",
        "repo_full_name": "getsentry/sentry-php",
        "pr_number": 762,
        "pr_file": "src/ErrorHandler.php",
        "discussion_id": "254487367",
        "commented_code": "@@ -111,52 +100,53 @@ private function __construct(callable $callback, int $reservedMemorySize = self:\n             // first call to the set_error_handler method would cause the PHP\n             // bug https://bugs.php.net/63206 if the handler is not the first\n             // one in the chain of handlers\n-            set_error_handler([$this, 'handleError'], $this->capturedErrors);\n-\n-            $this->isRoot = true;\n+            set_error_handler([$this, 'handleError'], E_ALL);\n         }\n \n         $this->previousExceptionHandler = set_exception_handler([$this, 'handleException']);\n     }\n \n     /**\n-     * Registers this error handler and associates the given callback to the\n-     * instance.\n+     * Gets the current registered error handler; if none is present, it will register it.\n+     * Subsequent calls will not change the reserved memory size.\n      *\n-     * @param callable $callback           callback that will be called when exception is caught\n-     * @param int      $reservedMemorySize The amount of memory to reserve for the fatal error handler\n+     * @param int|null $reservedMemorySize The requested amount of memory to reserve\n      *\n-     * @return self\n-     *\n-     * @throws \\ReflectionException\n+     * @return self The ErrorHandler singleton\n      */\n-    public static function register(callable $callback, int $reservedMemorySize = self::DEFAULT_RESERVED_MEMORY_SIZE): self\n+    public static function registerOnce(int $reservedMemorySize = null): self\n     {\n-        return new self($callback, $reservedMemorySize);\n+        if (null === self::$handlerInstance) {\n+            self::$handlerInstance = new self($reservedMemorySize ?? self::DEFAULT_RESERVED_MEMORY_SIZE);\n+        }\n+\n+        return self::$handlerInstance;\n     }\n \n     /**\n-     * Sets the PHP error levels that will be captured by the Raven client when\n-     * a PHP error occurs.\n+     * Adds a listener to the current error handler to be called upon each invoked captured error;\n+     * if no handler is registered, this method will instantiate and register it.\n      *\n-     * @param int  $levels  A bit field of E_* constants for captured errors\n-     * @param bool $replace Whether to replace or amend the previous value\n-     *\n-     * @return int The previous value\n+     * @param callable $listener A callable that will act as a listener; this callable will receive\n+     *                           a single \\ErrorException argument\n      */\n-    public function captureAt(int $levels, bool $replace = false): int\n+    public static function addErrorListener(callable $listener): void\n     {\n-        $prev = $this->capturedErrors;\n-\n-        $this->capturedErrors = $levels;\n-\n-        if (!$replace) {\n-            $this->capturedErrors |= $prev;\n-        }\n-\n-        $this->reRegister($prev);\n+        $handler = self::registerOnce();\n+        $handler->errorListeners[] = $listener;\n+    }\n \n-        return $prev;\n+    /**\n+     * Adds a listener to the current error handler to be called upon each invoked captured exception;",
        "comment_created_at": "2019-02-06T23:00:00+00:00",
        "comment_author": "ste93cry",
        "comment_body": "As a \"soft\" limit usually the descriptions of the methods goes to a new line after ~ 80 chars",
        "pr_file_module": null
      }
    ]
  }
]