[
  {
    "discussion_id": "2323428046",
    "pr_number": 593,
    "pr_file": "src/solidlsp/language_servers/al_language_server.py",
    "created_at": "2025-09-04T20:17:24+00:00",
    "commented_code": "+\"\"\"AL Language Server implementation for Microsoft Dynamics 365 Business Central.\"\"\"\n+\n+import logging\n+import os\n+import platform\n+import time\n+import zipfile\n+from pathlib import Path\n+\n+import requests\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import Definition, DefinitionParams, LocationLink\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+from solidlsp.settings import SolidLSPSettings\n+\n+\n+class ALLanguageServer(SolidLanguageServer):\n+    \"\"\"\n+    Language server implementation for AL (Microsoft Dynamics 365 Business Central).\n+\n+    This implementation uses the AL Language Server from the VS Code AL extension\n+    (ms-dynamics-smb.al). The extension must be installed or available locally.\n+\n+    Key Features:\n+    - Automatic download of AL extension from VS Code marketplace if not present\n+    - Platform-specific executable detection (Windows/Linux/macOS)\n+    - Special initialization sequence required by AL Language Server\n+    - Custom AL-specific LSP commands (al/gotodefinition, al/setActiveWorkspace)\n+    - File opening requirement before symbol retrieval\n+    \"\"\"\n+\n+    def __init__(\n+        self, config: LanguageServerConfig, logger: LanguageServerLogger, repository_root_path: str, solidlsp_settings: SolidLSPSettings\n+    ):\n+        \"\"\"\n+        Initialize the AL Language Server.\n+\n+        Args:\n+            config: Language server configuration\n+            logger: Logger instance for debugging\n+            repository_root_path: Root path of the AL project (must contain app.json)\n+            solidlsp_settings: Solid LSP settings\n+\n+        Note:\n+            The initialization process will automatically:\n+            1. Check for AL extension in the resources directory\n+            2. Download it from VS Code marketplace if not found\n+            3. Extract and configure the platform-specific executable\n+\n+        \"\"\"\n+        # Setup runtime dependencies and get the language server command\n+        # This will download the AL extension if needed\n+        cmd = self._setup_runtime_dependencies(logger, config, solidlsp_settings)\n+\n+        super().__init__(\n+            config,\n+            logger,\n+            repository_root_path,\n+            ProcessLaunchInfo(cmd=cmd, cwd=repository_root_path),\n+            \"al\",  # Language ID for LSP\n+            solidlsp_settings,\n+        )\n+\n+    @classmethod\n+    def _download_al_extension(cls, logger: LanguageServerLogger, url: str, target_dir: str) -> bool:\n+        \"\"\"\n+        Download and extract the AL extension from VS Code marketplace.\n+\n+        The VS Code marketplace packages extensions as .vsix files (which are ZIP archives).\n+        This method downloads the VSIX file and extracts it to get the language server binaries.\n+\n+        Args:\n+            logger: Logger for tracking download progress\n+            url: VS Code marketplace URL for the AL extension\n+            target_dir: Directory where the extension will be extracted\n+\n+        Returns:\n+            True if successful, False otherwise\n+\n+        Note:\n+            The download includes progress tracking and proper user-agent headers\n+            to ensure compatibility with the VS Code marketplace.\n+\n+        \"\"\"\n+        try:\n+            logger.log(f\"Downloading AL extension from {url}\", logging.INFO)\n+\n+            # Create target directory for the extension\n+            os.makedirs(target_dir, exist_ok=True)\n+\n+            # Download with proper headers to mimic VS Code marketplace client\n+            # These headers are required for the marketplace to serve the VSIX file\n+            headers = {\n+                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n+                \"Accept\": \"application/octet-stream, application/vsix, */*\",\n+            }\n+\n+            response = requests.get(url, headers=headers, stream=True, timeout=300)\n+            response.raise_for_status()\n+\n+            # Save to temporary VSIX file (will be deleted after extraction)\n+            temp_file = os.path.join(target_dir, \"al_extension_temp.vsix\")\n+            total_size = int(response.headers.get(\"content-length\", 0))\n+\n+            logger.log(f\"Downloading {total_size / 1024 / 1024:.1f} MB...\", logging.INFO)\n+\n+            with open(temp_file, \"wb\") as f:\n+                downloaded = 0\n+                for chunk in response.iter_content(chunk_size=8192):\n+                    if chunk:\n+                        f.write(chunk)\n+                        downloaded += len(chunk)\n+                        if total_size > 0 and downloaded % (10 * 1024 * 1024) == 0:  # Log progress every 10MB\n+                            progress = (downloaded / total_size) * 100\n+                            logger.log(f\"Download progress: {progress:.1f}%\", logging.INFO)\n+\n+            logger.log(\"Download complete, extracting...\", logging.INFO)\n+\n+            # Extract VSIX file (VSIX files are just ZIP archives with a different extension)\n+            # This will extract the extension folder containing the language server binaries\n+            with zipfile.ZipFile(temp_file, \"r\") as zip_ref:\n+                zip_ref.extractall(target_dir)\n+\n+            # Clean up temp file\n+            os.remove(temp_file)\n+\n+            logger.log(\"AL extension extracted successfully\", logging.INFO)\n+            return True\n+\n+        except Exception as e:\n+            logger.log(f\"Error downloading/extracting AL extension: {e}\", logging.ERROR)\n+            return False\n+\n+    @classmethod\n+    def _setup_runtime_dependencies(\n+        cls, logger: LanguageServerLogger, config: LanguageServerConfig, solidlsp_settings: SolidLSPSettings\n+    ) -> str:\n+        \"\"\"\n+        Setup runtime dependencies for AL Language Server and return the command to start the server.\n+\n+        This method handles the complete setup process:\n+        1. Determines the correct platform-specific executable path\n+        2. Checks if the AL extension is already installed\n+        3. Downloads the extension from VS Code marketplace if needed\n+        4. Configures executable permissions on Unix systems\n+        5. Returns the properly formatted command string\n+\n+        The AL Language Server executable is located in different paths based on the platform:\n+        - Windows: extension/bin/win32/Microsoft.Dynamics.Nav.EditorServices.Host.exe\n+        - Linux: extension/bin/linux/Microsoft.Dynamics.Nav.EditorServices.Host\n+        - macOS: extension/bin/darwin/Microsoft.Dynamics.Nav.EditorServices.Host\n+        \"\"\"\n+        # Directory where the AL extension will be installed\n+        # This is typically ~/.serena/ls_resources/al-extension\n+        al_extension_dir = os.path.join(cls.ls_resources_dir(solidlsp_settings), \"al-extension\")\n+\n+        # Determine platform-specific executable path within the extension\n+        # AL provides different binaries for each platform\n+        system = platform.system()\n+        if system == \"Windows\":\n+            executable_relative_path = os.path.join(\"extension\", \"bin\", \"win32\", \"Microsoft.Dynamics.Nav.EditorServices.Host.exe\")\n+        elif system == \"Linux\":\n+            executable_relative_path = os.path.join(\"extension\", \"bin\", \"linux\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        elif system == \"Darwin\":\n+            executable_relative_path = os.path.join(\"extension\", \"bin\", \"darwin\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        else:\n+            raise RuntimeError(f\"Unsupported platform: {system}\")\n+\n+        executable_path = os.path.join(al_extension_dir, executable_relative_path)\n+\n+        # Check if the extension is already installed\n+        if not os.path.exists(executable_path):\n+            logger.log(f\"AL Language Server not found at {executable_path}. Downloading from VS Code marketplace...\", logging.INFO)\n+\n+            # AL extension version - using latest stable version\n+            AL_VERSION = \"latest\"\n+            url = f\"https://marketplace.visualstudio.com/_apis/public/gallery/publishers/ms-dynamics-smb/vsextensions/al/{AL_VERSION}/vspackage\"\n+\n+            # Try to download the extension\n+            if cls._download_al_extension(logger, url, al_extension_dir):\n+                logger.log(\"AL Extension downloaded successfully.\", logging.INFO)\n+            else:\n+                logger.log(\"Failed to download AL extension, falling back to manual search.\", logging.WARNING)\n+                # Fall back to the old method of finding the extension\n+                return cls._get_language_server_command_fallback(logger)\n+\n+        # Verify executable exists after download\n+        if not os.path.exists(executable_path):\n+            logger.log(\"AL Language Server executable still not found after download. Falling back to manual search.\", logging.WARNING)\n+            return cls._get_language_server_command_fallback(logger)\n+\n+        # Make sure executable has proper permissions on Unix-like systems\n+        # This is crucial for Linux/macOS where downloaded files may not be executable\n+        if system in [\"Linux\", \"Darwin\"]:\n+            import stat\n+\n+            st = os.stat(executable_path)\n+            os.chmod(executable_path, st.st_mode | stat.S_IEXEC)\n+\n+        logger.log(f\"Using AL Language Server executable: {executable_path}\", level=5)\n+\n+        # The AL Language Server uses stdio for LSP communication by default\n+        # Unlike many other language servers, it doesn't require a --stdio flag\n+        # On Windows, we need to properly quote the path if it contains spaces to avoid shell issues\n+        if system == \"Windows\" and \" \" in executable_path:\n+            return f'\"{executable_path}\"'\n+        else:\n+            return executable_path\n+\n+    @classmethod\n+    def _get_language_server_command_fallback(cls, logger: LanguageServerLogger) -> str:\n+        \"\"\"\n+        Get the command to start the AL language server.\n+\n+        Returns:\n+            Command string to launch the AL language server\n+\n+        Raises:\n+            RuntimeError: If AL extension cannot be found\n+\n+        \"\"\"\n+        # Check if AL extension path is configured via environment variable\n+        al_extension_path = os.environ.get(\"AL_EXTENSION_PATH\")\n+\n+        if not al_extension_path:\n+            # Try to find the extension in the current working directory\n+            # (for development/testing when extension is in the serena repo)\n+            cwd_path = Path.cwd()\n+            potential_extension = None\n+\n+            # Look for ms-dynamics-smb.al-* directories\n+            for item in cwd_path.iterdir():\n+                if item.is_dir() and item.name.startswith(\"ms-dynamics-smb.al-\"):\n+                    potential_extension = item\n+                    break\n+\n+            if potential_extension:\n+                al_extension_path = str(potential_extension)\n+                logger.log(f\"Found AL extension in current directory: {al_extension_path}\", level=5)\n+            else:\n+                # Try to find in common VS Code extension locations\n+                al_extension_path = cls._find_al_extension_in_vscode(logger)\n+\n+        if not al_extension_path:\n+            raise RuntimeError(\n+                \"AL Language Server not found. Please either:\n\"\n+                \"1. Set AL_EXTENSION_PATH environment variable to the VS Code AL extension directory\n\"\n+                \"2. Install the AL extension in VS Code (ms-dynamics-smb.al)\n\"\n+                \"3. Place the extension directory in the current working directory\"\n+            )\n+\n+        # Determine platform-specific executable\n+        system = platform.system()\n+        if system == \"Windows\":\n+            executable = os.path.join(al_extension_path, \"bin\", \"win32\", \"Microsoft.Dynamics.Nav.EditorServices.Host.exe\")\n+        elif system == \"Linux\":\n+            executable = os.path.join(al_extension_path, \"bin\", \"linux\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        elif system == \"Darwin\":\n+            executable = os.path.join(al_extension_path, \"bin\", \"darwin\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        else:\n+            raise RuntimeError(f\"Unsupported platform: {system}\")\n+\n+        # Verify executable exists\n+        if not os.path.exists(executable):\n+            raise RuntimeError(\n+                f\"AL Language Server executable not found at: {executable}\nPlease ensure the AL extension is properly installed.\"\n+            )\n+\n+        # Make sure executable has proper permissions on Unix-like systems\n+        if system in [\"Linux\", \"Darwin\"]:\n+            import stat\n+\n+            st = os.stat(executable)\n+            os.chmod(executable, st.st_mode | stat.S_IEXEC)\n+\n+        logger.log(f\"Using AL Language Server executable: {executable}\", level=5)\n+\n+        # The AL Language Server uses stdio for LSP communication (no --stdio flag needed)\n+        # On Windows, we need to properly quote the path if it contains spaces\n+        if system == \"Windows\" and \" \" in executable:\n+            return f'\"{executable}\"'\n+        else:\n+            return executable\n+\n+    @classmethod\n+    def _find_al_extension_in_vscode(cls, logger: LanguageServerLogger) -> str | None:\n+        \"\"\"\n+        Try to find AL extension in common VS Code extension locations.\n+\n+        Returns:\n+            Path to AL extension directory or None if not found\n+\n+        \"\"\"\n+        home = Path.home()\n+        possible_paths = []\n+\n+        # Common VS Code extension paths\n+        if platform.system() == \"Windows\":\n+            possible_paths.extend(\n+                [\n+                    home / \".vscode\" / \"extensions\",\n+                    home / \".vscode-insiders\" / \"extensions\",\n+                    Path(os.environ.get(\"APPDATA\", \"\")) / \"Code\" / \"User\" / \"extensions\",\n+                    Path(os.environ.get(\"APPDATA\", \"\")) / \"Code - Insiders\" / \"User\" / \"extensions\",\n+                ]\n+            )\n+        else:\n+            possible_paths.extend(\n+                [\n+                    home / \".vscode\" / \"extensions\",\n+                    home / \".vscode-server\" / \"extensions\",\n+                    home / \".vscode-insiders\" / \"extensions\",\n+                ]\n+            )\n+\n+        for base_path in possible_paths:\n+            if base_path.exists():\n+                logger.log(f\"Searching for AL extension in: {base_path}\", level=10)\n+                # Look for AL extension directories\n+                for item in base_path.iterdir():\n+                    if item.is_dir() and item.name.startswith(\"ms-dynamics-smb.al-\"):\n+                        logger.log(f\"Found AL extension at: {item}\", level=5)\n+                        return str(item)\n+\n+        return None\n+\n+    @staticmethod\n+    def _get_initialize_params(repository_absolute_path: str) -> dict:\n+        \"\"\"\n+        Returns the initialize params for the AL Language Server.\n+        \"\"\"\n+        import os\n+        import pathlib\n+\n+        # Ensure we have an absolute path for URI generation\n+        repository_path = pathlib.Path(repository_absolute_path).resolve()\n+        root_uri = repository_path.as_uri()\n+\n+        # AL requires extensive capabilities based on VS Code trace\n+        initialize_params = {\n+            \"processId\": os.getpid(),\n+            \"rootPath\": str(repository_path),\n+            \"rootUri\": root_uri,\n+            \"capabilities\": {\n+                \"workspace\": {\n+                    \"applyEdit\": True,\n+                    \"workspaceEdit\": {\n+                        \"documentChanges\": True,\n+                        \"resourceOperations\": [\"create\", \"rename\", \"delete\"],\n+                        \"failureHandling\": \"textOnlyTransactional\",\n+                        \"normalizesLineEndings\": True,\n+                    },\n+                    \"configuration\": True,\n+                    \"didChangeWatchedFiles\": {\"dynamicRegistration\": True},\n+                    \"symbol\": {\"dynamicRegistration\": True, \"symbolKind\": {\"valueSet\": list(range(1, 27))}},\n+                    \"executeCommand\": {\"dynamicRegistration\": True},\n+                    \"didChangeConfiguration\": {\"dynamicRegistration\": True},\n+                    \"workspaceFolders\": True,\n+                },\n+                \"textDocument\": {\n+                    \"synchronization\": {\"dynamicRegistration\": True, \"willSave\": True, \"willSaveWaitUntil\": True, \"didSave\": True},\n+                    \"completion\": {\n+                        \"dynamicRegistration\": True,\n+                        \"contextSupport\": True,\n+                        \"completionItem\": {\n+                            \"snippetSupport\": True,\n+                            \"commitCharactersSupport\": True,\n+                            \"documentationFormat\": [\"markdown\", \"plaintext\"],\n+                            \"deprecatedSupport\": True,\n+                            \"preselectSupport\": True,\n+                        },\n+                    },\n+                    \"hover\": {\"dynamicRegistration\": True, \"contentFormat\": [\"markdown\", \"plaintext\"]},\n+                    \"definition\": {\"dynamicRegistration\": True, \"linkSupport\": True},\n+                    \"references\": {\"dynamicRegistration\": True},\n+                    \"documentHighlight\": {\"dynamicRegistration\": True},\n+                    \"documentSymbol\": {\n+                        \"dynamicRegistration\": True,\n+                        \"symbolKind\": {\"valueSet\": list(range(1, 27))},\n+                        \"hierarchicalDocumentSymbolSupport\": True,\n+                    },\n+                    \"codeAction\": {\"dynamicRegistration\": True},\n+                    \"formatting\": {\"dynamicRegistration\": True},\n+                    \"rangeFormatting\": {\"dynamicRegistration\": True},\n+                    \"rename\": {\"dynamicRegistration\": True, \"prepareSupport\": True},\n+                },\n+                \"window\": {\n+                    \"showMessage\": {\"messageActionItem\": {\"additionalPropertiesSupport\": True}},\n+                    \"showDocument\": {\"support\": True},\n+                    \"workDoneProgress\": True,\n+                },\n+            },\n+            \"trace\": \"verbose\",\n+            \"workspaceFolders\": [{\"uri\": root_uri, \"name\": repository_path.name}],\n+        }\n+\n+        return initialize_params\n+\n+    def _start_server(self):\n+        \"\"\"\n+        Starts the AL Language Server process and initializes it.\n+\n+        This method sets up custom notification handlers for AL-specific messages\n+        before starting the server. The AL server sends various notifications\n+        during initialization and project loading that need to be handled.\n+        \"\"\"\n+        import logging\n+\n+        # Set up event handlers\n+        def do_nothing(params):\n+            return\n+\n+        def window_log_message(msg):\n+            self.logger.log(f\"AL LSP: window/logMessage: {msg}\", logging.INFO)\n+\n+        def publish_diagnostics(params):\n+            # AL server publishes diagnostics during initialization\n+            uri = params.get(\"uri\", \"\")\n+            diagnostics = params.get(\"diagnostics\", [])\n+            self.logger.log(f\"AL LSP: Diagnostics for {uri}: {len(diagnostics)} issues\", logging.DEBUG)\n+\n+        def handle_al_notifications(params):\n+            # AL server sends custom notifications during project loading\n+            self.logger.log(\"AL LSP: Notification received\", logging.DEBUG)\n+\n+        # Register handlers for AL-specific notifications\n+        # These notifications are sent by the AL server during initialization and operation\n+        self.server.on_notification(\"window/logMessage\", window_log_message)  # Server log messages\n+        self.server.on_notification(\"textDocument/publishDiagnostics\", publish_diagnostics)  # Compilation diagnostics\n+        self.server.on_notification(\"$/progress\", do_nothing)  # Progress notifications during loading\n+        self.server.on_notification(\"al/refreshExplorerObjects\", handle_al_notifications)  # AL-specific object updates\n+\n+        # Start the server process\n+        self.logger.log(\"Starting AL Language Server process\", logging.INFO)\n+        self.server.start()\n+\n+        # Send initialize request\n+        initialize_params = self._get_initialize_params(self.repository_root_path)\n+\n+        self.logger.log(\n+            \"Sending initialize request from LSP client to AL LSP server and awaiting response\",\n+            logging.INFO,\n+        )\n+\n+        # Send initialize and wait for response\n+        resp = self.server.send_request(\"initialize\", initialize_params)\n+        if resp is None:\n+            raise RuntimeError(\"AL Language Server initialization failed - no response\")\n+\n+        self.logger.log(\"AL Language Server initialized successfully\", logging.INFO)\n+\n+        # Send initialized notification\n+        self.server.send_notification(\"initialized\", {})\n+        self.logger.log(\"Sent initialized notification\", logging.INFO)\n+\n+    def start(self) -> \"ALLanguageServer\":\n+        \"\"\"\n+        Start the AL Language Server with special initialization.\n+        \"\"\"\n+        # Call parent start method\n+        super().start()\n+\n+        # AL-specific post-initialization\n+        self._post_initialize_al_workspace()\n+\n+        # Note: set_active_workspace() can be called manually if needed for multi-workspace scenarios\n+        # We don't call it automatically to avoid issues during single-workspace initialization\n+\n+        return self\n+\n+    def _post_initialize_al_workspace(self) -> None:\n+        \"\"\"\n+        Post-initialization setup for AL Language Server.\n+\n+        The AL server requires additional setup after initialization:\n+        1. Set the active workspace - tells AL which project to work with\n+        2. Send workspace configuration - provides AL settings and paths\n+        3. Open app.json to trigger project loading - AL uses app.json to identify project structure\n+        4. Wait for project to be loaded - ensures symbols are indexed before operations\n+\n+        This special initialization sequence is unique to AL and necessary for proper\n+        symbol resolution and navigation features.\n+        \"\"\"\n+        import time\n+        from pathlib import Path\n+\n+        # Give the server a moment to fully initialize\n+        time.sleep(1)\n+\n+        # Send workspace configuration first\n+        # This tells AL about assembly paths, package caches, and code analysis settings\n+        try:\n+            self.server.send_notification(\n+                \"workspace/didChangeConfiguration\",\n+                {\n+                    \"settings\": {\n+                        \"workspacePath\": self.repository_root_path,\n+                        \"alResourceConfigurationSettings\": {\n+                            \"assemblyProbingPaths\": [\"./.netpackages\"],\n+                            \"codeAnalyzers\": [],\n+                            \"enableCodeAnalysis\": False,\n+                            \"backgroundCodeAnalysis\": \"Project\",\n+                            \"packageCachePaths\": [\"./.alpackages\"],\n+                            \"ruleSetPath\": None,\n+                            \"enableCodeActions\": True,\n+                            \"incrementalBuild\": False,\n+                            \"outputAnalyzerStatistics\": True,\n+                            \"enableExternalRulesets\": True,\n+                        },\n+                        \"setActiveWorkspace\": True,\n+                        \"expectedProjectReferenceDefinitions\": [],\n+                        \"activeWorkspaceClosure\": [self.repository_root_path],\n+                    }\n+                },\n+            )\n+            self.logger.log(\"Sent workspace configuration\", level=5)\n+        except Exception as e:\n+            self.logger.log(f\"Failed to send workspace config: {e}\", level=3)\n+\n+        # Check if app.json exists and open it\n+        # app.json is the AL project manifest file (similar to package.json for Node.js)\n+        # Opening it triggers AL to load the project and index all AL files\n+        app_json_path = Path(self.repository_root_path) / \"app.json\"\n+        if app_json_path.exists():\n+            try:\n+                with open(app_json_path, encoding=\"utf-8\") as f:\n+                    app_json_content = f.read()\n+\n+                # Use forward slashes for URI\n+                app_json_uri = app_json_path.as_uri()\n+\n+                # Send textDocument/didOpen for app.json\n+                self.server.send_notification(\n+                    \"textDocument/didOpen\",\n+                    {\"textDocument\": {\"uri\": app_json_uri, \"languageId\": \"json\", \"version\": 1, \"text\": app_json_content}},\n+                )\n+\n+                self.logger.log(f\"Opened app.json: {app_json_uri}\", level=5)\n+            except Exception as e:\n+                self.logger.log(f\"Failed to open app.json: {e}\", level=3)\n+\n+        # Try to set active workspace (AL-specific custom LSP request)\n+        # This is important when multiple AL projects are open\n+        workspace_uri = Path(self.repository_root_path).resolve().as_uri()\n+        try:\n+            result = self.server.send_request(\n+                \"al/setActiveWorkspace\",\n+                {\n+                    \"currentWorkspaceFolderPath\": {\"uri\": workspace_uri, \"name\": Path(self.repository_root_path).name, \"index\": 0},\n+                    \"settings\": {\n+                        \"workspacePath\": self.repository_root_path,\n+                        \"alResourceConfigurationSettings\": {\n+                            \"assemblyProbingPaths\": [\"./.netpackages\"],\n+                            \"codeAnalyzers\": [],\n+                            \"enableCodeAnalysis\": False,\n+                            \"backgroundCodeAnalysis\": \"Project\",\n+                            \"packageCachePaths\": [\"./.alpackages\"],\n+                            \"ruleSetPath\": None,\n+                            \"enableCodeActions\": True,\n+                            \"incrementalBuild\": False,\n+                            \"outputAnalyzerStatistics\": True,\n+                            \"enableExternalRulesets\": True,\n+                        },\n+                        \"setActiveWorkspace\": True,\n+                        \"expectedProjectReferenceDefinitions\": [],\n+                        \"activeWorkspaceClosure\": [self.repository_root_path],\n+                    },\n+                },\n+                timeout=10,\n+            )\n+            self.logger.log(f\"Set active workspace result: {result}\", level=5)\n+        except Exception as e:\n+            # This is a custom AL request, might not be critical\n+            self.logger.log(f\"Failed to set active workspace: {e}\", level=3)\n+\n+        # Wait for project to be loaded using AL's custom load check\n+        # The AL server needs time to parse all AL files and build its symbol index\n+        if not self._wait_for_project_load(timeout=30):\n+            # Even if not confirmed loaded, give it extra time to index\n+            # Some large projects may take longer to fully index\n+            self.logger.log(\"Project load not confirmed, waiting additional time for AL workspace indexing\", level=5)\n+            time.sleep(5)\n+        else:\n+            # Even when loaded, give a bit more time for symbol indexing to complete\n+            # This ensures all symbols are available for navigation\n+            self.logger.log(\"Project loaded, waiting for symbol indexing\", level=5)\n+            time.sleep(2)\n+\n+    def is_ignored_dirname(self, dirname: str) -> bool:",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2323428046",
        "repo_full_name": "oraios/serena",
        "pr_number": 593,
        "pr_file": "src/solidlsp/language_servers/al_language_server.py",
        "discussion_id": "2323428046",
        "commented_code": "@@ -0,0 +1,1045 @@\n+\"\"\"AL Language Server implementation for Microsoft Dynamics 365 Business Central.\"\"\"\n+\n+import logging\n+import os\n+import platform\n+import time\n+import zipfile\n+from pathlib import Path\n+\n+import requests\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import Definition, DefinitionParams, LocationLink\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+from solidlsp.settings import SolidLSPSettings\n+\n+\n+class ALLanguageServer(SolidLanguageServer):\n+    \"\"\"\n+    Language server implementation for AL (Microsoft Dynamics 365 Business Central).\n+\n+    This implementation uses the AL Language Server from the VS Code AL extension\n+    (ms-dynamics-smb.al). The extension must be installed or available locally.\n+\n+    Key Features:\n+    - Automatic download of AL extension from VS Code marketplace if not present\n+    - Platform-specific executable detection (Windows/Linux/macOS)\n+    - Special initialization sequence required by AL Language Server\n+    - Custom AL-specific LSP commands (al/gotodefinition, al/setActiveWorkspace)\n+    - File opening requirement before symbol retrieval\n+    \"\"\"\n+\n+    def __init__(\n+        self, config: LanguageServerConfig, logger: LanguageServerLogger, repository_root_path: str, solidlsp_settings: SolidLSPSettings\n+    ):\n+        \"\"\"\n+        Initialize the AL Language Server.\n+\n+        Args:\n+            config: Language server configuration\n+            logger: Logger instance for debugging\n+            repository_root_path: Root path of the AL project (must contain app.json)\n+            solidlsp_settings: Solid LSP settings\n+\n+        Note:\n+            The initialization process will automatically:\n+            1. Check for AL extension in the resources directory\n+            2. Download it from VS Code marketplace if not found\n+            3. Extract and configure the platform-specific executable\n+\n+        \"\"\"\n+        # Setup runtime dependencies and get the language server command\n+        # This will download the AL extension if needed\n+        cmd = self._setup_runtime_dependencies(logger, config, solidlsp_settings)\n+\n+        super().__init__(\n+            config,\n+            logger,\n+            repository_root_path,\n+            ProcessLaunchInfo(cmd=cmd, cwd=repository_root_path),\n+            \"al\",  # Language ID for LSP\n+            solidlsp_settings,\n+        )\n+\n+    @classmethod\n+    def _download_al_extension(cls, logger: LanguageServerLogger, url: str, target_dir: str) -> bool:\n+        \"\"\"\n+        Download and extract the AL extension from VS Code marketplace.\n+\n+        The VS Code marketplace packages extensions as .vsix files (which are ZIP archives).\n+        This method downloads the VSIX file and extracts it to get the language server binaries.\n+\n+        Args:\n+            logger: Logger for tracking download progress\n+            url: VS Code marketplace URL for the AL extension\n+            target_dir: Directory where the extension will be extracted\n+\n+        Returns:\n+            True if successful, False otherwise\n+\n+        Note:\n+            The download includes progress tracking and proper user-agent headers\n+            to ensure compatibility with the VS Code marketplace.\n+\n+        \"\"\"\n+        try:\n+            logger.log(f\"Downloading AL extension from {url}\", logging.INFO)\n+\n+            # Create target directory for the extension\n+            os.makedirs(target_dir, exist_ok=True)\n+\n+            # Download with proper headers to mimic VS Code marketplace client\n+            # These headers are required for the marketplace to serve the VSIX file\n+            headers = {\n+                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n+                \"Accept\": \"application/octet-stream, application/vsix, */*\",\n+            }\n+\n+            response = requests.get(url, headers=headers, stream=True, timeout=300)\n+            response.raise_for_status()\n+\n+            # Save to temporary VSIX file (will be deleted after extraction)\n+            temp_file = os.path.join(target_dir, \"al_extension_temp.vsix\")\n+            total_size = int(response.headers.get(\"content-length\", 0))\n+\n+            logger.log(f\"Downloading {total_size / 1024 / 1024:.1f} MB...\", logging.INFO)\n+\n+            with open(temp_file, \"wb\") as f:\n+                downloaded = 0\n+                for chunk in response.iter_content(chunk_size=8192):\n+                    if chunk:\n+                        f.write(chunk)\n+                        downloaded += len(chunk)\n+                        if total_size > 0 and downloaded % (10 * 1024 * 1024) == 0:  # Log progress every 10MB\n+                            progress = (downloaded / total_size) * 100\n+                            logger.log(f\"Download progress: {progress:.1f}%\", logging.INFO)\n+\n+            logger.log(\"Download complete, extracting...\", logging.INFO)\n+\n+            # Extract VSIX file (VSIX files are just ZIP archives with a different extension)\n+            # This will extract the extension folder containing the language server binaries\n+            with zipfile.ZipFile(temp_file, \"r\") as zip_ref:\n+                zip_ref.extractall(target_dir)\n+\n+            # Clean up temp file\n+            os.remove(temp_file)\n+\n+            logger.log(\"AL extension extracted successfully\", logging.INFO)\n+            return True\n+\n+        except Exception as e:\n+            logger.log(f\"Error downloading/extracting AL extension: {e}\", logging.ERROR)\n+            return False\n+\n+    @classmethod\n+    def _setup_runtime_dependencies(\n+        cls, logger: LanguageServerLogger, config: LanguageServerConfig, solidlsp_settings: SolidLSPSettings\n+    ) -> str:\n+        \"\"\"\n+        Setup runtime dependencies for AL Language Server and return the command to start the server.\n+\n+        This method handles the complete setup process:\n+        1. Determines the correct platform-specific executable path\n+        2. Checks if the AL extension is already installed\n+        3. Downloads the extension from VS Code marketplace if needed\n+        4. Configures executable permissions on Unix systems\n+        5. Returns the properly formatted command string\n+\n+        The AL Language Server executable is located in different paths based on the platform:\n+        - Windows: extension/bin/win32/Microsoft.Dynamics.Nav.EditorServices.Host.exe\n+        - Linux: extension/bin/linux/Microsoft.Dynamics.Nav.EditorServices.Host\n+        - macOS: extension/bin/darwin/Microsoft.Dynamics.Nav.EditorServices.Host\n+        \"\"\"\n+        # Directory where the AL extension will be installed\n+        # This is typically ~/.serena/ls_resources/al-extension\n+        al_extension_dir = os.path.join(cls.ls_resources_dir(solidlsp_settings), \"al-extension\")\n+\n+        # Determine platform-specific executable path within the extension\n+        # AL provides different binaries for each platform\n+        system = platform.system()\n+        if system == \"Windows\":\n+            executable_relative_path = os.path.join(\"extension\", \"bin\", \"win32\", \"Microsoft.Dynamics.Nav.EditorServices.Host.exe\")\n+        elif system == \"Linux\":\n+            executable_relative_path = os.path.join(\"extension\", \"bin\", \"linux\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        elif system == \"Darwin\":\n+            executable_relative_path = os.path.join(\"extension\", \"bin\", \"darwin\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        else:\n+            raise RuntimeError(f\"Unsupported platform: {system}\")\n+\n+        executable_path = os.path.join(al_extension_dir, executable_relative_path)\n+\n+        # Check if the extension is already installed\n+        if not os.path.exists(executable_path):\n+            logger.log(f\"AL Language Server not found at {executable_path}. Downloading from VS Code marketplace...\", logging.INFO)\n+\n+            # AL extension version - using latest stable version\n+            AL_VERSION = \"latest\"\n+            url = f\"https://marketplace.visualstudio.com/_apis/public/gallery/publishers/ms-dynamics-smb/vsextensions/al/{AL_VERSION}/vspackage\"\n+\n+            # Try to download the extension\n+            if cls._download_al_extension(logger, url, al_extension_dir):\n+                logger.log(\"AL Extension downloaded successfully.\", logging.INFO)\n+            else:\n+                logger.log(\"Failed to download AL extension, falling back to manual search.\", logging.WARNING)\n+                # Fall back to the old method of finding the extension\n+                return cls._get_language_server_command_fallback(logger)\n+\n+        # Verify executable exists after download\n+        if not os.path.exists(executable_path):\n+            logger.log(\"AL Language Server executable still not found after download. Falling back to manual search.\", logging.WARNING)\n+            return cls._get_language_server_command_fallback(logger)\n+\n+        # Make sure executable has proper permissions on Unix-like systems\n+        # This is crucial for Linux/macOS where downloaded files may not be executable\n+        if system in [\"Linux\", \"Darwin\"]:\n+            import stat\n+\n+            st = os.stat(executable_path)\n+            os.chmod(executable_path, st.st_mode | stat.S_IEXEC)\n+\n+        logger.log(f\"Using AL Language Server executable: {executable_path}\", level=5)\n+\n+        # The AL Language Server uses stdio for LSP communication by default\n+        # Unlike many other language servers, it doesn't require a --stdio flag\n+        # On Windows, we need to properly quote the path if it contains spaces to avoid shell issues\n+        if system == \"Windows\" and \" \" in executable_path:\n+            return f'\"{executable_path}\"'\n+        else:\n+            return executable_path\n+\n+    @classmethod\n+    def _get_language_server_command_fallback(cls, logger: LanguageServerLogger) -> str:\n+        \"\"\"\n+        Get the command to start the AL language server.\n+\n+        Returns:\n+            Command string to launch the AL language server\n+\n+        Raises:\n+            RuntimeError: If AL extension cannot be found\n+\n+        \"\"\"\n+        # Check if AL extension path is configured via environment variable\n+        al_extension_path = os.environ.get(\"AL_EXTENSION_PATH\")\n+\n+        if not al_extension_path:\n+            # Try to find the extension in the current working directory\n+            # (for development/testing when extension is in the serena repo)\n+            cwd_path = Path.cwd()\n+            potential_extension = None\n+\n+            # Look for ms-dynamics-smb.al-* directories\n+            for item in cwd_path.iterdir():\n+                if item.is_dir() and item.name.startswith(\"ms-dynamics-smb.al-\"):\n+                    potential_extension = item\n+                    break\n+\n+            if potential_extension:\n+                al_extension_path = str(potential_extension)\n+                logger.log(f\"Found AL extension in current directory: {al_extension_path}\", level=5)\n+            else:\n+                # Try to find in common VS Code extension locations\n+                al_extension_path = cls._find_al_extension_in_vscode(logger)\n+\n+        if not al_extension_path:\n+            raise RuntimeError(\n+                \"AL Language Server not found. Please either:\\n\"\n+                \"1. Set AL_EXTENSION_PATH environment variable to the VS Code AL extension directory\\n\"\n+                \"2. Install the AL extension in VS Code (ms-dynamics-smb.al)\\n\"\n+                \"3. Place the extension directory in the current working directory\"\n+            )\n+\n+        # Determine platform-specific executable\n+        system = platform.system()\n+        if system == \"Windows\":\n+            executable = os.path.join(al_extension_path, \"bin\", \"win32\", \"Microsoft.Dynamics.Nav.EditorServices.Host.exe\")\n+        elif system == \"Linux\":\n+            executable = os.path.join(al_extension_path, \"bin\", \"linux\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        elif system == \"Darwin\":\n+            executable = os.path.join(al_extension_path, \"bin\", \"darwin\", \"Microsoft.Dynamics.Nav.EditorServices.Host\")\n+        else:\n+            raise RuntimeError(f\"Unsupported platform: {system}\")\n+\n+        # Verify executable exists\n+        if not os.path.exists(executable):\n+            raise RuntimeError(\n+                f\"AL Language Server executable not found at: {executable}\\nPlease ensure the AL extension is properly installed.\"\n+            )\n+\n+        # Make sure executable has proper permissions on Unix-like systems\n+        if system in [\"Linux\", \"Darwin\"]:\n+            import stat\n+\n+            st = os.stat(executable)\n+            os.chmod(executable, st.st_mode | stat.S_IEXEC)\n+\n+        logger.log(f\"Using AL Language Server executable: {executable}\", level=5)\n+\n+        # The AL Language Server uses stdio for LSP communication (no --stdio flag needed)\n+        # On Windows, we need to properly quote the path if it contains spaces\n+        if system == \"Windows\" and \" \" in executable:\n+            return f'\"{executable}\"'\n+        else:\n+            return executable\n+\n+    @classmethod\n+    def _find_al_extension_in_vscode(cls, logger: LanguageServerLogger) -> str | None:\n+        \"\"\"\n+        Try to find AL extension in common VS Code extension locations.\n+\n+        Returns:\n+            Path to AL extension directory or None if not found\n+\n+        \"\"\"\n+        home = Path.home()\n+        possible_paths = []\n+\n+        # Common VS Code extension paths\n+        if platform.system() == \"Windows\":\n+            possible_paths.extend(\n+                [\n+                    home / \".vscode\" / \"extensions\",\n+                    home / \".vscode-insiders\" / \"extensions\",\n+                    Path(os.environ.get(\"APPDATA\", \"\")) / \"Code\" / \"User\" / \"extensions\",\n+                    Path(os.environ.get(\"APPDATA\", \"\")) / \"Code - Insiders\" / \"User\" / \"extensions\",\n+                ]\n+            )\n+        else:\n+            possible_paths.extend(\n+                [\n+                    home / \".vscode\" / \"extensions\",\n+                    home / \".vscode-server\" / \"extensions\",\n+                    home / \".vscode-insiders\" / \"extensions\",\n+                ]\n+            )\n+\n+        for base_path in possible_paths:\n+            if base_path.exists():\n+                logger.log(f\"Searching for AL extension in: {base_path}\", level=10)\n+                # Look for AL extension directories\n+                for item in base_path.iterdir():\n+                    if item.is_dir() and item.name.startswith(\"ms-dynamics-smb.al-\"):\n+                        logger.log(f\"Found AL extension at: {item}\", level=5)\n+                        return str(item)\n+\n+        return None\n+\n+    @staticmethod\n+    def _get_initialize_params(repository_absolute_path: str) -> dict:\n+        \"\"\"\n+        Returns the initialize params for the AL Language Server.\n+        \"\"\"\n+        import os\n+        import pathlib\n+\n+        # Ensure we have an absolute path for URI generation\n+        repository_path = pathlib.Path(repository_absolute_path).resolve()\n+        root_uri = repository_path.as_uri()\n+\n+        # AL requires extensive capabilities based on VS Code trace\n+        initialize_params = {\n+            \"processId\": os.getpid(),\n+            \"rootPath\": str(repository_path),\n+            \"rootUri\": root_uri,\n+            \"capabilities\": {\n+                \"workspace\": {\n+                    \"applyEdit\": True,\n+                    \"workspaceEdit\": {\n+                        \"documentChanges\": True,\n+                        \"resourceOperations\": [\"create\", \"rename\", \"delete\"],\n+                        \"failureHandling\": \"textOnlyTransactional\",\n+                        \"normalizesLineEndings\": True,\n+                    },\n+                    \"configuration\": True,\n+                    \"didChangeWatchedFiles\": {\"dynamicRegistration\": True},\n+                    \"symbol\": {\"dynamicRegistration\": True, \"symbolKind\": {\"valueSet\": list(range(1, 27))}},\n+                    \"executeCommand\": {\"dynamicRegistration\": True},\n+                    \"didChangeConfiguration\": {\"dynamicRegistration\": True},\n+                    \"workspaceFolders\": True,\n+                },\n+                \"textDocument\": {\n+                    \"synchronization\": {\"dynamicRegistration\": True, \"willSave\": True, \"willSaveWaitUntil\": True, \"didSave\": True},\n+                    \"completion\": {\n+                        \"dynamicRegistration\": True,\n+                        \"contextSupport\": True,\n+                        \"completionItem\": {\n+                            \"snippetSupport\": True,\n+                            \"commitCharactersSupport\": True,\n+                            \"documentationFormat\": [\"markdown\", \"plaintext\"],\n+                            \"deprecatedSupport\": True,\n+                            \"preselectSupport\": True,\n+                        },\n+                    },\n+                    \"hover\": {\"dynamicRegistration\": True, \"contentFormat\": [\"markdown\", \"plaintext\"]},\n+                    \"definition\": {\"dynamicRegistration\": True, \"linkSupport\": True},\n+                    \"references\": {\"dynamicRegistration\": True},\n+                    \"documentHighlight\": {\"dynamicRegistration\": True},\n+                    \"documentSymbol\": {\n+                        \"dynamicRegistration\": True,\n+                        \"symbolKind\": {\"valueSet\": list(range(1, 27))},\n+                        \"hierarchicalDocumentSymbolSupport\": True,\n+                    },\n+                    \"codeAction\": {\"dynamicRegistration\": True},\n+                    \"formatting\": {\"dynamicRegistration\": True},\n+                    \"rangeFormatting\": {\"dynamicRegistration\": True},\n+                    \"rename\": {\"dynamicRegistration\": True, \"prepareSupport\": True},\n+                },\n+                \"window\": {\n+                    \"showMessage\": {\"messageActionItem\": {\"additionalPropertiesSupport\": True}},\n+                    \"showDocument\": {\"support\": True},\n+                    \"workDoneProgress\": True,\n+                },\n+            },\n+            \"trace\": \"verbose\",\n+            \"workspaceFolders\": [{\"uri\": root_uri, \"name\": repository_path.name}],\n+        }\n+\n+        return initialize_params\n+\n+    def _start_server(self):\n+        \"\"\"\n+        Starts the AL Language Server process and initializes it.\n+\n+        This method sets up custom notification handlers for AL-specific messages\n+        before starting the server. The AL server sends various notifications\n+        during initialization and project loading that need to be handled.\n+        \"\"\"\n+        import logging\n+\n+        # Set up event handlers\n+        def do_nothing(params):\n+            return\n+\n+        def window_log_message(msg):\n+            self.logger.log(f\"AL LSP: window/logMessage: {msg}\", logging.INFO)\n+\n+        def publish_diagnostics(params):\n+            # AL server publishes diagnostics during initialization\n+            uri = params.get(\"uri\", \"\")\n+            diagnostics = params.get(\"diagnostics\", [])\n+            self.logger.log(f\"AL LSP: Diagnostics for {uri}: {len(diagnostics)} issues\", logging.DEBUG)\n+\n+        def handle_al_notifications(params):\n+            # AL server sends custom notifications during project loading\n+            self.logger.log(\"AL LSP: Notification received\", logging.DEBUG)\n+\n+        # Register handlers for AL-specific notifications\n+        # These notifications are sent by the AL server during initialization and operation\n+        self.server.on_notification(\"window/logMessage\", window_log_message)  # Server log messages\n+        self.server.on_notification(\"textDocument/publishDiagnostics\", publish_diagnostics)  # Compilation diagnostics\n+        self.server.on_notification(\"$/progress\", do_nothing)  # Progress notifications during loading\n+        self.server.on_notification(\"al/refreshExplorerObjects\", handle_al_notifications)  # AL-specific object updates\n+\n+        # Start the server process\n+        self.logger.log(\"Starting AL Language Server process\", logging.INFO)\n+        self.server.start()\n+\n+        # Send initialize request\n+        initialize_params = self._get_initialize_params(self.repository_root_path)\n+\n+        self.logger.log(\n+            \"Sending initialize request from LSP client to AL LSP server and awaiting response\",\n+            logging.INFO,\n+        )\n+\n+        # Send initialize and wait for response\n+        resp = self.server.send_request(\"initialize\", initialize_params)\n+        if resp is None:\n+            raise RuntimeError(\"AL Language Server initialization failed - no response\")\n+\n+        self.logger.log(\"AL Language Server initialized successfully\", logging.INFO)\n+\n+        # Send initialized notification\n+        self.server.send_notification(\"initialized\", {})\n+        self.logger.log(\"Sent initialized notification\", logging.INFO)\n+\n+    def start(self) -> \"ALLanguageServer\":\n+        \"\"\"\n+        Start the AL Language Server with special initialization.\n+        \"\"\"\n+        # Call parent start method\n+        super().start()\n+\n+        # AL-specific post-initialization\n+        self._post_initialize_al_workspace()\n+\n+        # Note: set_active_workspace() can be called manually if needed for multi-workspace scenarios\n+        # We don't call it automatically to avoid issues during single-workspace initialization\n+\n+        return self\n+\n+    def _post_initialize_al_workspace(self) -> None:\n+        \"\"\"\n+        Post-initialization setup for AL Language Server.\n+\n+        The AL server requires additional setup after initialization:\n+        1. Set the active workspace - tells AL which project to work with\n+        2. Send workspace configuration - provides AL settings and paths\n+        3. Open app.json to trigger project loading - AL uses app.json to identify project structure\n+        4. Wait for project to be loaded - ensures symbols are indexed before operations\n+\n+        This special initialization sequence is unique to AL and necessary for proper\n+        symbol resolution and navigation features.\n+        \"\"\"\n+        import time\n+        from pathlib import Path\n+\n+        # Give the server a moment to fully initialize\n+        time.sleep(1)\n+\n+        # Send workspace configuration first\n+        # This tells AL about assembly paths, package caches, and code analysis settings\n+        try:\n+            self.server.send_notification(\n+                \"workspace/didChangeConfiguration\",\n+                {\n+                    \"settings\": {\n+                        \"workspacePath\": self.repository_root_path,\n+                        \"alResourceConfigurationSettings\": {\n+                            \"assemblyProbingPaths\": [\"./.netpackages\"],\n+                            \"codeAnalyzers\": [],\n+                            \"enableCodeAnalysis\": False,\n+                            \"backgroundCodeAnalysis\": \"Project\",\n+                            \"packageCachePaths\": [\"./.alpackages\"],\n+                            \"ruleSetPath\": None,\n+                            \"enableCodeActions\": True,\n+                            \"incrementalBuild\": False,\n+                            \"outputAnalyzerStatistics\": True,\n+                            \"enableExternalRulesets\": True,\n+                        },\n+                        \"setActiveWorkspace\": True,\n+                        \"expectedProjectReferenceDefinitions\": [],\n+                        \"activeWorkspaceClosure\": [self.repository_root_path],\n+                    }\n+                },\n+            )\n+            self.logger.log(\"Sent workspace configuration\", level=5)\n+        except Exception as e:\n+            self.logger.log(f\"Failed to send workspace config: {e}\", level=3)\n+\n+        # Check if app.json exists and open it\n+        # app.json is the AL project manifest file (similar to package.json for Node.js)\n+        # Opening it triggers AL to load the project and index all AL files\n+        app_json_path = Path(self.repository_root_path) / \"app.json\"\n+        if app_json_path.exists():\n+            try:\n+                with open(app_json_path, encoding=\"utf-8\") as f:\n+                    app_json_content = f.read()\n+\n+                # Use forward slashes for URI\n+                app_json_uri = app_json_path.as_uri()\n+\n+                # Send textDocument/didOpen for app.json\n+                self.server.send_notification(\n+                    \"textDocument/didOpen\",\n+                    {\"textDocument\": {\"uri\": app_json_uri, \"languageId\": \"json\", \"version\": 1, \"text\": app_json_content}},\n+                )\n+\n+                self.logger.log(f\"Opened app.json: {app_json_uri}\", level=5)\n+            except Exception as e:\n+                self.logger.log(f\"Failed to open app.json: {e}\", level=3)\n+\n+        # Try to set active workspace (AL-specific custom LSP request)\n+        # This is important when multiple AL projects are open\n+        workspace_uri = Path(self.repository_root_path).resolve().as_uri()\n+        try:\n+            result = self.server.send_request(\n+                \"al/setActiveWorkspace\",\n+                {\n+                    \"currentWorkspaceFolderPath\": {\"uri\": workspace_uri, \"name\": Path(self.repository_root_path).name, \"index\": 0},\n+                    \"settings\": {\n+                        \"workspacePath\": self.repository_root_path,\n+                        \"alResourceConfigurationSettings\": {\n+                            \"assemblyProbingPaths\": [\"./.netpackages\"],\n+                            \"codeAnalyzers\": [],\n+                            \"enableCodeAnalysis\": False,\n+                            \"backgroundCodeAnalysis\": \"Project\",\n+                            \"packageCachePaths\": [\"./.alpackages\"],\n+                            \"ruleSetPath\": None,\n+                            \"enableCodeActions\": True,\n+                            \"incrementalBuild\": False,\n+                            \"outputAnalyzerStatistics\": True,\n+                            \"enableExternalRulesets\": True,\n+                        },\n+                        \"setActiveWorkspace\": True,\n+                        \"expectedProjectReferenceDefinitions\": [],\n+                        \"activeWorkspaceClosure\": [self.repository_root_path],\n+                    },\n+                },\n+                timeout=10,\n+            )\n+            self.logger.log(f\"Set active workspace result: {result}\", level=5)\n+        except Exception as e:\n+            # This is a custom AL request, might not be critical\n+            self.logger.log(f\"Failed to set active workspace: {e}\", level=3)\n+\n+        # Wait for project to be loaded using AL's custom load check\n+        # The AL server needs time to parse all AL files and build its symbol index\n+        if not self._wait_for_project_load(timeout=30):\n+            # Even if not confirmed loaded, give it extra time to index\n+            # Some large projects may take longer to fully index\n+            self.logger.log(\"Project load not confirmed, waiting additional time for AL workspace indexing\", level=5)\n+            time.sleep(5)\n+        else:\n+            # Even when loaded, give a bit more time for symbol indexing to complete\n+            # This ensures all symbols are available for navigation\n+            self.logger.log(\"Project loaded, waiting for symbol indexing\", level=5)\n+            time.sleep(2)\n+\n+    def is_ignored_dirname(self, dirname: str) -> bool:",
        "comment_created_at": "2025-09-04T20:17:24+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "pls add `@override` (imported from `overrides`, not `typing`), a helpful util that we use throughout",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2256871292",
    "pr_number": 418,
    "pr_file": "src/solidlsp/language_servers/csharp_language_server.py",
    "created_at": "2025-08-06T11:35:34+00:00",
    "commented_code": "from overrides import override\n \n+from serena.util.zip import SafeZipExtractor",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2256871292",
        "repo_full_name": "oraios/serena",
        "pr_number": 418,
        "pr_file": "src/solidlsp/language_servers/csharp_language_server.py",
        "discussion_id": "2256871292",
        "commented_code": "@@ -18,6 +18,8 @@\n \n from overrides import override\n \n+from serena.util.zip import SafeZipExtractor",
        "comment_created_at": "2025-08-06T11:35:34+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "pls move the module to solidlsp.\n\nWe consider solidlsp to be an independent library, we might publish it as a separate package later. Therefore, it should not import anything from serena",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2256906898",
    "pr_number": 423,
    "pr_file": "src/serena/cli.py",
    "created_at": "2025-08-06T11:52:12+00:00",
    "commented_code": "from pathlib import Path\n from typing import Any, Literal\n \n+# Import CREATE_NO_WINDOW safely across platforms\n+try:\n+    from subprocess import CREATE_NO_WINDOW",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2256906898",
        "repo_full_name": "oraios/serena",
        "pr_number": 423,
        "pr_file": "src/serena/cli.py",
        "discussion_id": "2256906898",
        "commented_code": "@@ -7,6 +7,13 @@\n from pathlib import Path\n from typing import Any, Literal\n \n+# Import CREATE_NO_WINDOW safely across platforms\n+try:\n+    from subprocess import CREATE_NO_WINDOW",
        "comment_created_at": "2025-08-06T11:52:12+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "import this from util.shell pls, then you don't need the try-except in each module",
        "pr_file_module": null
      },
      {
        "comment_id": "2256920528",
        "repo_full_name": "oraios/serena",
        "pr_number": 423,
        "pr_file": "src/serena/cli.py",
        "discussion_id": "2256906898",
        "commented_code": "@@ -7,6 +7,13 @@\n from pathlib import Path\n from typing import Any, Literal\n \n+# Import CREATE_NO_WINDOW safely across platforms\n+try:\n+    from subprocess import CREATE_NO_WINDOW",
        "comment_created_at": "2025-08-06T11:58:19+00:00",
        "comment_author": "eLyiN",
        "comment_body": "@MischaPanch Thanks for the guidance!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2187784771",
    "pr_number": 277,
    "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
    "created_at": "2025-07-05T22:18:21+00:00",
    "commented_code": "+import json\n+import logging\n+import os\n+import pathlib\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version():\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        import os\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform version detection...\")\n+        \n+        # 1. Try to find terraform using shutil.which (standard Python way)\n+        terraform_cmd = shutil.which(\"terraform\")\n+        if terraform_cmd:\n+            print(f\"DEBUG: Found terraform via shutil.which: {terraform_cmd}\")\n+        else:\n+            print(\"DEBUG: terraform not found via shutil.which\")\n+        \n+        # 2. Fallback to TERRAFORM_CLI_PATH (set by hashicorp/setup-terraform action)\n+        if not terraform_cmd:\n+            terraform_cli_path = os.environ.get('TERRAFORM_CLI_PATH')\n+            if terraform_cli_path:\n+                print(f\"DEBUG: Trying TERRAFORM_CLI_PATH: {terraform_cli_path}\")\n+                terraform_exe = os.path.join(terraform_cli_path, \"terraform.exe\")\n+                if os.path.exists(terraform_exe):\n+                    terraform_cmd = terraform_exe\n+                    print(f\"DEBUG: Found terraform via TERRAFORM_CLI_PATH: {terraform_cmd}\")\n+                else:\n+                    print(f\"DEBUG: terraform.exe not found at {terraform_exe}\")\n+            else:\n+                print(\"DEBUG: TERRAFORM_CLI_PATH not set\")\n+        \n+        # 3. Try to run the terraform command if found\n+        if terraform_cmd:\n+            try:\n+                print(f\"DEBUG: Attempting to run: {terraform_cmd} version (with 15s timeout)\")\n+                result = subprocess.run(\n+                    [terraform_cmd, \"version\"], \n+                    capture_output=True, \n+                    text=True, \n+                    check=False, \n+                    timeout=15  # CRITICAL: 15 second timeout to prevent hangs\n+                )\n+                if result.returncode == 0:\n+                    print(f\"DEBUG: terraform version command succeeded\")\n+                    return result.stdout.strip()\n+                else:\n+                    print(f\"DEBUG: terraform version command failed with return code {result.returncode}\")\n+                    print(f\"DEBUG: stderr: {result.stderr}\")\n+            except subprocess.TimeoutExpired:\n+                print(\"ERROR: terraform version command timed out after 15 seconds\")\n+            except (FileNotFoundError, OSError) as e:\n+                print(f\"DEBUG: Failed to run terraform command: {e}\")\n+        else:\n+            print(\"DEBUG: No terraform executable found\")\n+        \n+        return None\n+\n+    @staticmethod\n+    def _get_terraform_ls_version():\n+        \"\"\"Get the installed terraform-ls version or None if not found.\"\"\"\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform-ls version detection...\")\n+        \n+        # Try to find terraform-ls using shutil.which (standard Python way)\n+        terraform_ls_cmd = shutil.which(\"terraform-ls\")\n+        \n+        if terraform_ls_cmd:\n+            print(f\"DEBUG: Found terraform-ls via shutil.which: {terraform_ls_cmd}\")\n+            try:\n+                print(f\"DEBUG: Attempting to run: {terraform_ls_cmd} version (with 15s timeout)\")\n+                result = subprocess.run(\n+                    [terraform_ls_cmd, \"version\"], \n+                    capture_output=True, \n+                    text=True, \n+                    check=False, \n+                    timeout=15  # CRITICAL: 15 second timeout to prevent hangs\n+                )\n+                if result.returncode == 0:\n+                    print(f\"DEBUG: terraform-ls version command succeeded\")\n+                    return result.stdout.strip()\n+                else:\n+                    print(f\"DEBUG: terraform-ls version command failed with return code {result.returncode}\")\n+                    print(f\"DEBUG: stderr: {result.stderr}\")\n+            except subprocess.TimeoutExpired:\n+                print(\"ERROR: terraform-ls version command timed out after 15 seconds\")\n+            except (FileNotFoundError, OSError) as e:\n+                print(f\"DEBUG: Failed to run terraform-ls command: {e}\")\n+        else:\n+            print(\"DEBUG: terraform-ls not found via shutil.which\")\n+        \n+        return None\n+\n+    @classmethod\n+    def setup_runtime_dependency(cls):\n+        \"\"\"\n+        Check if required Terraform runtime dependencies are available.\n+        Raises RuntimeError with helpful message if dependencies are missing.\n+        \"\"\"\n+        terraform_version = cls._get_terraform_version()\n+        if not terraform_version:\n+            raise RuntimeError(\n+                \"Terraform is not installed. Please install Terraform from https://www.terraform.io/downloads and make sure it is added to your PATH.\"\n+            )\n+\n+        terraform_ls_version = cls._get_terraform_ls_version()\n+        if not terraform_ls_version:\n+            raise RuntimeError(\n+                \"Found a Terraform version but terraform-ls is not installed.\n\"\n+                \"Please install terraform-ls from https://github.com/hashicorp/terraform-ls/releases\n\n\"\n+                \"After installation, make sure it is added to your PATH.\"\n+            )\n+\n+        return True\n+\n+    def __init__(self, config: LanguageServerConfig, logger: LanguageServerLogger, repository_root_path: str):\n+        self.setup_runtime_dependency()\n+\n+        # Find the correct terraform-ls executable using the same logic as version check\n+        terraform_ls_cmd = self._find_terraform_ls_executable()\n+\n+        super().__init__(\n+            config,\n+            logger,\n+            repository_root_path,\n+            ProcessLaunchInfo(cmd=terraform_ls_cmd, cwd=repository_root_path),\n+            \"terraform\",\n+        )\n+        self.server_ready = threading.Event()\n+        self.request_id = 0\n+\n+    @staticmethod\n+    def _find_terraform_ls_executable():\n+        \"\"\"Find the terraform-ls executable that actually works.\"\"\"\n+        import shutil",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2187784771",
        "repo_full_name": "oraios/serena",
        "pr_number": 277,
        "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
        "discussion_id": "2187784771",
        "commented_code": "@@ -0,0 +1,260 @@\n+import json\n+import logging\n+import os\n+import pathlib\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version():\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        import os\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform version detection...\")\n+        \n+        # 1. Try to find terraform using shutil.which (standard Python way)\n+        terraform_cmd = shutil.which(\"terraform\")\n+        if terraform_cmd:\n+            print(f\"DEBUG: Found terraform via shutil.which: {terraform_cmd}\")\n+        else:\n+            print(\"DEBUG: terraform not found via shutil.which\")\n+        \n+        # 2. Fallback to TERRAFORM_CLI_PATH (set by hashicorp/setup-terraform action)\n+        if not terraform_cmd:\n+            terraform_cli_path = os.environ.get('TERRAFORM_CLI_PATH')\n+            if terraform_cli_path:\n+                print(f\"DEBUG: Trying TERRAFORM_CLI_PATH: {terraform_cli_path}\")\n+                terraform_exe = os.path.join(terraform_cli_path, \"terraform.exe\")\n+                if os.path.exists(terraform_exe):\n+                    terraform_cmd = terraform_exe\n+                    print(f\"DEBUG: Found terraform via TERRAFORM_CLI_PATH: {terraform_cmd}\")\n+                else:\n+                    print(f\"DEBUG: terraform.exe not found at {terraform_exe}\")\n+            else:\n+                print(\"DEBUG: TERRAFORM_CLI_PATH not set\")\n+        \n+        # 3. Try to run the terraform command if found\n+        if terraform_cmd:\n+            try:\n+                print(f\"DEBUG: Attempting to run: {terraform_cmd} version (with 15s timeout)\")\n+                result = subprocess.run(\n+                    [terraform_cmd, \"version\"], \n+                    capture_output=True, \n+                    text=True, \n+                    check=False, \n+                    timeout=15  # CRITICAL: 15 second timeout to prevent hangs\n+                )\n+                if result.returncode == 0:\n+                    print(f\"DEBUG: terraform version command succeeded\")\n+                    return result.stdout.strip()\n+                else:\n+                    print(f\"DEBUG: terraform version command failed with return code {result.returncode}\")\n+                    print(f\"DEBUG: stderr: {result.stderr}\")\n+            except subprocess.TimeoutExpired:\n+                print(\"ERROR: terraform version command timed out after 15 seconds\")\n+            except (FileNotFoundError, OSError) as e:\n+                print(f\"DEBUG: Failed to run terraform command: {e}\")\n+        else:\n+            print(\"DEBUG: No terraform executable found\")\n+        \n+        return None\n+\n+    @staticmethod\n+    def _get_terraform_ls_version():\n+        \"\"\"Get the installed terraform-ls version or None if not found.\"\"\"\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform-ls version detection...\")\n+        \n+        # Try to find terraform-ls using shutil.which (standard Python way)\n+        terraform_ls_cmd = shutil.which(\"terraform-ls\")\n+        \n+        if terraform_ls_cmd:\n+            print(f\"DEBUG: Found terraform-ls via shutil.which: {terraform_ls_cmd}\")\n+            try:\n+                print(f\"DEBUG: Attempting to run: {terraform_ls_cmd} version (with 15s timeout)\")\n+                result = subprocess.run(\n+                    [terraform_ls_cmd, \"version\"], \n+                    capture_output=True, \n+                    text=True, \n+                    check=False, \n+                    timeout=15  # CRITICAL: 15 second timeout to prevent hangs\n+                )\n+                if result.returncode == 0:\n+                    print(f\"DEBUG: terraform-ls version command succeeded\")\n+                    return result.stdout.strip()\n+                else:\n+                    print(f\"DEBUG: terraform-ls version command failed with return code {result.returncode}\")\n+                    print(f\"DEBUG: stderr: {result.stderr}\")\n+            except subprocess.TimeoutExpired:\n+                print(\"ERROR: terraform-ls version command timed out after 15 seconds\")\n+            except (FileNotFoundError, OSError) as e:\n+                print(f\"DEBUG: Failed to run terraform-ls command: {e}\")\n+        else:\n+            print(\"DEBUG: terraform-ls not found via shutil.which\")\n+        \n+        return None\n+\n+    @classmethod\n+    def setup_runtime_dependency(cls):\n+        \"\"\"\n+        Check if required Terraform runtime dependencies are available.\n+        Raises RuntimeError with helpful message if dependencies are missing.\n+        \"\"\"\n+        terraform_version = cls._get_terraform_version()\n+        if not terraform_version:\n+            raise RuntimeError(\n+                \"Terraform is not installed. Please install Terraform from https://www.terraform.io/downloads and make sure it is added to your PATH.\"\n+            )\n+\n+        terraform_ls_version = cls._get_terraform_ls_version()\n+        if not terraform_ls_version:\n+            raise RuntimeError(\n+                \"Found a Terraform version but terraform-ls is not installed.\\n\"\n+                \"Please install terraform-ls from https://github.com/hashicorp/terraform-ls/releases\\n\\n\"\n+                \"After installation, make sure it is added to your PATH.\"\n+            )\n+\n+        return True\n+\n+    def __init__(self, config: LanguageServerConfig, logger: LanguageServerLogger, repository_root_path: str):\n+        self.setup_runtime_dependency()\n+\n+        # Find the correct terraform-ls executable using the same logic as version check\n+        terraform_ls_cmd = self._find_terraform_ls_executable()\n+\n+        super().__init__(\n+            config,\n+            logger,\n+            repository_root_path,\n+            ProcessLaunchInfo(cmd=terraform_ls_cmd, cwd=repository_root_path),\n+            \"terraform\",\n+        )\n+        self.server_ready = threading.Event()\n+        self.request_id = 0\n+\n+    @staticmethod\n+    def _find_terraform_ls_executable():\n+        \"\"\"Find the terraform-ls executable that actually works.\"\"\"\n+        import shutil",
        "comment_created_at": "2025-07-05T22:18:21+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "this is done many times, Pls remove all local imports here and make them global",
        "pr_file_module": null
      },
      {
        "comment_id": "2187899382",
        "repo_full_name": "oraios/serena",
        "pr_number": 277,
        "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
        "discussion_id": "2187784771",
        "commented_code": "@@ -0,0 +1,260 @@\n+import json\n+import logging\n+import os\n+import pathlib\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version():\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        import os\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform version detection...\")\n+        \n+        # 1. Try to find terraform using shutil.which (standard Python way)\n+        terraform_cmd = shutil.which(\"terraform\")\n+        if terraform_cmd:\n+            print(f\"DEBUG: Found terraform via shutil.which: {terraform_cmd}\")\n+        else:\n+            print(\"DEBUG: terraform not found via shutil.which\")\n+        \n+        # 2. Fallback to TERRAFORM_CLI_PATH (set by hashicorp/setup-terraform action)\n+        if not terraform_cmd:\n+            terraform_cli_path = os.environ.get('TERRAFORM_CLI_PATH')\n+            if terraform_cli_path:\n+                print(f\"DEBUG: Trying TERRAFORM_CLI_PATH: {terraform_cli_path}\")\n+                terraform_exe = os.path.join(terraform_cli_path, \"terraform.exe\")\n+                if os.path.exists(terraform_exe):\n+                    terraform_cmd = terraform_exe\n+                    print(f\"DEBUG: Found terraform via TERRAFORM_CLI_PATH: {terraform_cmd}\")\n+                else:\n+                    print(f\"DEBUG: terraform.exe not found at {terraform_exe}\")\n+            else:\n+                print(\"DEBUG: TERRAFORM_CLI_PATH not set\")\n+        \n+        # 3. Try to run the terraform command if found\n+        if terraform_cmd:\n+            try:\n+                print(f\"DEBUG: Attempting to run: {terraform_cmd} version (with 15s timeout)\")\n+                result = subprocess.run(\n+                    [terraform_cmd, \"version\"], \n+                    capture_output=True, \n+                    text=True, \n+                    check=False, \n+                    timeout=15  # CRITICAL: 15 second timeout to prevent hangs\n+                )\n+                if result.returncode == 0:\n+                    print(f\"DEBUG: terraform version command succeeded\")\n+                    return result.stdout.strip()\n+                else:\n+                    print(f\"DEBUG: terraform version command failed with return code {result.returncode}\")\n+                    print(f\"DEBUG: stderr: {result.stderr}\")\n+            except subprocess.TimeoutExpired:\n+                print(\"ERROR: terraform version command timed out after 15 seconds\")\n+            except (FileNotFoundError, OSError) as e:\n+                print(f\"DEBUG: Failed to run terraform command: {e}\")\n+        else:\n+            print(\"DEBUG: No terraform executable found\")\n+        \n+        return None\n+\n+    @staticmethod\n+    def _get_terraform_ls_version():\n+        \"\"\"Get the installed terraform-ls version or None if not found.\"\"\"\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform-ls version detection...\")\n+        \n+        # Try to find terraform-ls using shutil.which (standard Python way)\n+        terraform_ls_cmd = shutil.which(\"terraform-ls\")\n+        \n+        if terraform_ls_cmd:\n+            print(f\"DEBUG: Found terraform-ls via shutil.which: {terraform_ls_cmd}\")\n+            try:\n+                print(f\"DEBUG: Attempting to run: {terraform_ls_cmd} version (with 15s timeout)\")\n+                result = subprocess.run(\n+                    [terraform_ls_cmd, \"version\"], \n+                    capture_output=True, \n+                    text=True, \n+                    check=False, \n+                    timeout=15  # CRITICAL: 15 second timeout to prevent hangs\n+                )\n+                if result.returncode == 0:\n+                    print(f\"DEBUG: terraform-ls version command succeeded\")\n+                    return result.stdout.strip()\n+                else:\n+                    print(f\"DEBUG: terraform-ls version command failed with return code {result.returncode}\")\n+                    print(f\"DEBUG: stderr: {result.stderr}\")\n+            except subprocess.TimeoutExpired:\n+                print(\"ERROR: terraform-ls version command timed out after 15 seconds\")\n+            except (FileNotFoundError, OSError) as e:\n+                print(f\"DEBUG: Failed to run terraform-ls command: {e}\")\n+        else:\n+            print(\"DEBUG: terraform-ls not found via shutil.which\")\n+        \n+        return None\n+\n+    @classmethod\n+    def setup_runtime_dependency(cls):\n+        \"\"\"\n+        Check if required Terraform runtime dependencies are available.\n+        Raises RuntimeError with helpful message if dependencies are missing.\n+        \"\"\"\n+        terraform_version = cls._get_terraform_version()\n+        if not terraform_version:\n+            raise RuntimeError(\n+                \"Terraform is not installed. Please install Terraform from https://www.terraform.io/downloads and make sure it is added to your PATH.\"\n+            )\n+\n+        terraform_ls_version = cls._get_terraform_ls_version()\n+        if not terraform_ls_version:\n+            raise RuntimeError(\n+                \"Found a Terraform version but terraform-ls is not installed.\\n\"\n+                \"Please install terraform-ls from https://github.com/hashicorp/terraform-ls/releases\\n\\n\"\n+                \"After installation, make sure it is added to your PATH.\"\n+            )\n+\n+        return True\n+\n+    def __init__(self, config: LanguageServerConfig, logger: LanguageServerLogger, repository_root_path: str):\n+        self.setup_runtime_dependency()\n+\n+        # Find the correct terraform-ls executable using the same logic as version check\n+        terraform_ls_cmd = self._find_terraform_ls_executable()\n+\n+        super().__init__(\n+            config,\n+            logger,\n+            repository_root_path,\n+            ProcessLaunchInfo(cmd=terraform_ls_cmd, cwd=repository_root_path),\n+            \"terraform\",\n+        )\n+        self.server_ready = threading.Event()\n+        self.request_id = 0\n+\n+    @staticmethod\n+    def _find_terraform_ls_executable():\n+        \"\"\"Find the terraform-ls executable that actually works.\"\"\"\n+        import shutil",
        "comment_created_at": "2025-07-06T02:38:09+00:00",
        "comment_author": "antigenius0910",
        "comment_body": "Roger that",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188133796",
    "pr_number": 277,
    "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
    "created_at": "2025-07-06T09:44:21+00:00",
    "commented_code": "+import json\n+import logging\n+import os\n+import pathlib\n+import shutil\n+import stat\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.ls_utils import FileUtils, PlatformUtils\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version(logger=None):\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        if logger:\n+            logger.log(\"Starting terraform version detection...\", logging.DEBUG)",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2188133796",
        "repo_full_name": "oraios/serena",
        "pr_number": 277,
        "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
        "discussion_id": "2188133796",
        "commented_code": "@@ -0,0 +1,249 @@\n+import json\n+import logging\n+import os\n+import pathlib\n+import shutil\n+import stat\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.ls_utils import FileUtils, PlatformUtils\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version(logger=None):\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        if logger:\n+            logger.log(\"Starting terraform version detection...\", logging.DEBUG)",
        "comment_created_at": "2025-07-06T09:44:21+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "the if-else complicates the code unnecessarily. You can make it a normal method (not static) and always use self.logger, like in the other LS implementations.\n\nHere and below",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135590089",
    "pr_number": 161,
    "pr_file": "src/serena/config.py",
    "created_at": "2025-06-09T11:58:42+00:00",
    "commented_code": "print(f\"{self.name}:\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2135590089",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T11:58:42+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Overall, the code in serena is object-oriented. This means config-related functionality should be added to the serena-config-related classes. They are currently in agent.py (we can move them to config.py later).\r\n\r\nI suspect that quite some code here was written by AI, which is not a bad thing :). You can ask to rewrite it in an object-oriented way and use existing classes, maybe introduce new ones if needed. I will review then later.\r\n\r\nTo make the reviewing easier for me, pls also add info to the readme and changelog. It has to be done anyway, and will make it easier for me to understand the workflow you envisioned",
        "pr_file_module": null
      },
      {
        "comment_id": "2135860046",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T14:44:00+00:00",
        "comment_author": "80avin",
        "comment_body": "It was me actually. I couldn't find where shall I fit this function, and didn't realize that the repo follows Object Oriented paradigm.\r\n\r\nI'll refactor it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2135863938",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T14:46:06+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Cool, thanks! I suspected an LLM because of the local imports, which often appear as an artefact :)",
        "pr_file_module": null
      },
      {
        "comment_id": "2135888572",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T14:59:12+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Pls make sure to read the overall PR comment [here ](https://github.com/oraios/serena/pull/161#pullrequestreview-2909837162) before you start refactoring. Just making sure you don't do unnecessary work and the next review goes smoothly",
        "pr_file_module": null
      },
      {
        "comment_id": "2135987157",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T15:54:37+00:00",
        "comment_author": "80avin",
        "comment_body": "Sure.\r\n\r\nThough I'm not sure when will I be able to complete them, mostly because of the day job.\r\n\r\n> ...because of the local imports...\r\n\r\nProbably I'm influenced by FreeCAD recently, but I have a habit of doing so, mostly in plugins. Reasoning being that a plugin whose startup may block the app's startup, it is better to do lazy imports.\r\nIn any case, it's probably not worth it here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2136077795",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T16:54:19+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Np, if you feel like you won't have time, let me know, then I'll continue where you stopped ",
        "pr_file_module": null
      },
      {
        "comment_id": "2136194791",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T17:51:38+00:00",
        "comment_author": "80avin",
        "comment_body": "That will be much better !!",
        "pr_file_module": null
      },
      {
        "comment_id": "2136197056",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T17:53:00+00:00",
        "comment_author": "80avin",
        "comment_body": "It may take, at worst, one week for me.\r\nBut if you feel you have enough time to do it earlier, I won't mind at all.",
        "pr_file_module": null
      },
      {
        "comment_id": "2136413508",
        "repo_full_name": "oraios/serena",
        "pr_number": 161,
        "pr_file": "src/serena/config.py",
        "discussion_id": "2135590089",
        "commented_code": "@@ -144,3 +144,185 @@ def print_overview(self) -> None:\n         print(f\"{self.name}:\\n {self.description}\")\n         if self.excluded_tools:\n             print(\" excluded tools:\\n  \" + \", \".join(sorted(self.excluded_tools)))\n+\n+\n+def init_user_config():\n+    \"\"\"\n+    Initialize user configuration by copying config files from package to user data directory.\n+\n+    This function:\n+    1. Creates user config directories if they don't exist\n+    2. Copies config files from package to user data directory if they don't exist\n+    3. Handles version-based migration with backup and logging\n+    4. Copies serena_config.template.yml to serena_config.yml in user data directory\n+\n+    Raises:\n+        Exception: If copying fails due to permissions or other IO issues\n+\n+    \"\"\"\n+    from pathlib import Path\n+\n+    from serena.constants import SERENA_CONFIG_TEMPLATE_FILE, _serena_data_path, _serena_pkg_path\n+\n+    # Define current config version - increment when config format changes\n+    CONFIG_VERSION = \"1.0\"\n+\n+    user_data_path = Path(_serena_data_path)\n+    pkg_config_path = Path(_serena_pkg_path) / \"resources\" / \"config\"\n+    user_config_path = user_data_path / \"config\"\n+\n+    log.info(f\"Initializing user configuration in {user_data_path}\")\n+\n+    try:\n+        # Create user data directory structure\n+        user_data_path.mkdir(parents=True, exist_ok=True)\n+        user_config_path.mkdir(parents=True, exist_ok=True)\n+\n+        # Create config subdirectories\n+        config_dirs = [\"prompt_templates\", \"contexts\", \"modes\"]\n+        for config_dir in config_dirs:\n+            (user_config_path / config_dir).mkdir(parents=True, exist_ok=True)\n+\n+        # Define source and destination paths for each config directory\n+        config_mappings = [\n+            (\"prompt_templates\", pkg_config_path / \"prompt_templates\", user_config_path / \"prompt_templates\"),\n+            (\"contexts\", pkg_config_path / \"contexts\", user_config_path / \"contexts\"),\n+            (\"modes\", pkg_config_path / \"modes\", user_config_path / \"modes\"),\n+        ]\n+\n+        # Handle main config file separately\n+        user_config_file = user_data_path / \"serena_config.yml\"\n+        template_config_file = Path(SERENA_CONFIG_TEMPLATE_FILE)\n+\n+        # Check if we need to copy/migrate config files\n+        for config_name, src_dir, dest_dir in config_mappings:\n+            _copy_or_migrate_config_dir(config_name, src_dir, dest_dir, CONFIG_VERSION)\n+\n+        # Handle main config file (template -> config)\n+        _copy_or_migrate_main_config(template_config_file, user_config_file, CONFIG_VERSION)\n+\n+        log.info(\"User configuration initialization completed successfully\")\n+\n+    except Exception as e:\n+        log.error(f\"Failed to initialize user configuration: {e}\")\n+        raise Exception(f\"Critical error during config initialization: {e}\") from e\n+\n+\n+def _copy_or_migrate_config_dir(config_name: str, src_dir: Path, dest_dir: Path, current_version: str):\n+    \"\"\"Copy or migrate a configuration directory.\"\"\"\n+    import shutil\n+\n+    version_file = dest_dir / \".version\"\n+    needs_copy = False\n+    needs_migration = False\n+\n+    if not dest_dir.exists() or not any(dest_dir.iterdir()):\n+        log.info(f\"Config directory {config_name} doesn't exist in user data, copying from package\")\n+        needs_copy = True\n+    elif version_file.exists():\n+        try:\n+            existing_version = version_file.read_text().strip()\n+            if existing_version != current_version:\n+                log.warning(f\"Config {config_name} version mismatch: existing={existing_version}, current={current_version}\")\n+                needs_migration = True\n+        except Exception as e:\n+            log.warning(f\"Could not read version file for {config_name}: {e}, treating as migration needed\")\n+            needs_migration = True\n+    else:\n+        log.warning(f\"No version file found for {config_name}, treating as migration needed\")\n+        needs_migration = True\n+\n+    if needs_copy or needs_migration:\n+        if needs_migration:\n+            _backup_existing_config(dest_dir, config_name)\n+\n+        # Copy files from source to destination\n+        log.info(f\"Copying {config_name} config files from {src_dir} to {dest_dir}\")\n+\n+        # Remove existing files if migrating\n+        if needs_migration and dest_dir.exists():\n+            shutil.rmtree(dest_dir)\n+\n+        # Copy the directory\n+        shutil.copytree(src_dir, dest_dir, dirs_exist_ok=True)\n+\n+        # Write version file\n+        version_file.write_text(current_version)\n+        log.info(f\"Successfully copied {config_name} config files\")\n+\n+\n+def _copy_or_migrate_main_config(template_file: Path, user_config_file: Path, current_version: str):",
        "comment_created_at": "2025-06-09T20:04:16+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "NP, it can wait a week. Since this touches end-user configuration, it's important to get this right.\r\n\r\nI have more than enough other topics to work on for serena, so I'll happily accept your help on this, even if it may take a while ",
        "pr_file_module": null
      }
    ]
  }
]