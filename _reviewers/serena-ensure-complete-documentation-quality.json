[
  {
    "discussion_id": "2424226123",
    "pr_number": 658,
    "pr_file": "src/solidlsp/language_servers/nim_language_server.py",
    "created_at": "2025-10-12T14:37:37+00:00",
    "commented_code": "+\"\"\"\n+Provides Nim specific instantiation of the LanguageServer class using nimlangserver.\n+Contains various configurations and settings specific to Nim language.\n+\"\"\"",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2424226123",
        "repo_full_name": "oraios/serena",
        "pr_number": 658,
        "pr_file": "src/solidlsp/language_servers/nim_language_server.py",
        "discussion_id": "2424226123",
        "commented_code": "@@ -0,0 +1,590 @@\n+\"\"\"\n+Provides Nim specific instantiation of the LanguageServer class using nimlangserver.\n+Contains various configurations and settings specific to Nim language.\n+\"\"\"",
        "comment_created_at": "2025-10-12T14:37:37+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "There's a whole bunch of tricks used here that are typically not needed in an LS implementation, pls expand the docstring and mention the most unexpected ones (like the custom handler, the while loop, the writing of config files etc) and why they are needed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2035971659",
    "pr_number": 46,
    "pr_file": "src/serena/agent.py",
    "created_at": "2025-04-09T19:02:45+00:00",
    "commented_code": "pass\n \n \n+class RestartLanguageServerTool(Tool):\n+    \"\"\"Restarts the language server, may be necessary when edits not through Serena happen.\"\"\"",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2035971659",
        "repo_full_name": "oraios/serena",
        "pr_number": 46,
        "pr_file": "src/serena/agent.py",
        "discussion_id": "2035971659",
        "commented_code": "@@ -502,6 +502,20 @@ class ToolMarkerDoesNotRequireActiveProject:\n     pass\n \n \n+class RestartLanguageServerTool(Tool):\n+    \"\"\"Restarts the language server, may be necessary when edits not through Serena happen.\"\"\"",
        "comment_created_at": "2025-04-09T19:02:45+00:00",
        "comment_author": "opcode81",
        "comment_body": "\"when edits not through Serena happen\" is not proper English. Change to \"when edits occur outside of Serena\"?\r\nSimilar phrase in docstring below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2029989412",
    "pr_number": 30,
    "pr_file": "src/serena/agent.py",
    "created_at": "2025-04-05T23:03:46+00:00",
    "commented_code": "return self._limit_length(result, max_answer_chars)\n \n \n+class GetReferencingCodeExtractsTool(Tool):\n+    \"\"\"\n+    Gets the code blocks that reference the symbol at the given location.\n+    \"\"\"\n+\n+    def apply(\n+        self,\n+        relative_path: str,\n+        line: int,\n+        column: int,\n+        context_lines_before: int = 0,\n+        context_lines_after: int = 0,\n+        max_answer_chars: int = _DEFAULT_MAX_ANSWER_LENGTH,\n+    ) -> str:\n+        \"\"\"\n+        Returns short code extracts where the symbol at the given location is referenced.\n+\n+        Contrary to the `find_referencing_symbols` tool, this tool returns references that are not symbols but instead\n+        code extracts that may or may not be contained in a symbol (for example, file-level calls).\n+        It may make sense to use this tool if you want to get a quick and dirty overview of the code that references",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2029989412",
        "repo_full_name": "oraios/serena",
        "pr_number": 30,
        "pr_file": "src/serena/agent.py",
        "discussion_id": "2029989412",
        "commented_code": "@@ -536,6 +536,49 @@ def apply(\n         return self._limit_length(result, max_answer_chars)\n \n \n+class GetReferencingCodeExtractsTool(Tool):\n+    \"\"\"\n+    Gets the code blocks that reference the symbol at the given location.\n+    \"\"\"\n+\n+    def apply(\n+        self,\n+        relative_path: str,\n+        line: int,\n+        column: int,\n+        context_lines_before: int = 0,\n+        context_lines_after: int = 0,\n+        max_answer_chars: int = _DEFAULT_MAX_ANSWER_LENGTH,\n+    ) -> str:\n+        \"\"\"\n+        Returns short code extracts where the symbol at the given location is referenced.\n+\n+        Contrary to the `find_referencing_symbols` tool, this tool returns references that are not symbols but instead\n+        code extracts that may or may not be contained in a symbol (for example, file-level calls).\n+        It may make sense to use this tool if you want to get a quick and dirty overview of the code that references",
        "comment_created_at": "2025-04-05T23:03:46+00:00",
        "comment_author": "opcode81",
        "comment_body": "I don't really think there is anything \"dirty\" about this. Depending on the use case, you might not care at all about the full context (symbol retrieval could only give you the symbol's full body) but only about the very concrete usage (e.g. is the function being called with some parameter or not). I think it's actually a very reasonable way of looking at usages (which I constantly make use of in IDEs).\r\nSo I'd lose the \"and dirty\" part.",
        "pr_file_module": null
      },
      {
        "comment_id": "2030120807",
        "repo_full_name": "oraios/serena",
        "pr_number": 30,
        "pr_file": "src/serena/agent.py",
        "discussion_id": "2029989412",
        "commented_code": "@@ -536,6 +536,49 @@ def apply(\n         return self._limit_length(result, max_answer_chars)\n \n \n+class GetReferencingCodeExtractsTool(Tool):\n+    \"\"\"\n+    Gets the code blocks that reference the symbol at the given location.\n+    \"\"\"\n+\n+    def apply(\n+        self,\n+        relative_path: str,\n+        line: int,\n+        column: int,\n+        context_lines_before: int = 0,\n+        context_lines_after: int = 0,\n+        max_answer_chars: int = _DEFAULT_MAX_ANSWER_LENGTH,\n+    ) -> str:\n+        \"\"\"\n+        Returns short code extracts where the symbol at the given location is referenced.\n+\n+        Contrary to the `find_referencing_symbols` tool, this tool returns references that are not symbols but instead\n+        code extracts that may or may not be contained in a symbol (for example, file-level calls).\n+        It may make sense to use this tool if you want to get a quick and dirty overview of the code that references",
        "comment_created_at": "2025-04-06T11:20:12+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2034036559",
    "pr_number": 41,
    "pr_file": "src/multilspy/language_server.py",
    "created_at": "2025-04-08T21:08:26+00:00",
    "commented_code": "# cache often becomes corrupt, so just skip loading it\n                 self.logger.log(\n                         f\"Failed to load document symbols cache from {self._cache_path}: {e}. Possible cause: the cache file is corrupted. \" \n-                        \"Check for any errors related to saving the cache in the logs.\", \n+                        \"Check for any errors related to saving the cache in the logs.\",\n                         logging.ERROR\n                     )\n \n \n+    async def request_workspace_symbol(self, query: str) -> Union[List[multilspy_types.UnifiedSymbolInformation], None]:\n+        \"\"\"\n+        Raise a [workspace/symbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol) request to the Language Server\n+        to find symbols across the whole workspace. Wait for the response and return the result.\n+\n+        :param query: The query string to filter symbols by\n+\n+        :return Union[List[multilspy_types.UnifiedSymbolInformation], None]: A list of matching symbols\n+        \"\"\"\n+        response = await self.server.send.workspace_symbol({\"query\": query})\n+        if response is None:\n+            return None\n+\n+        assert isinstance(response, list)\n+\n+        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n+        for item in response:\n+            assert isinstance(item, dict)\n+\n+            assert LSPConstants.NAME in item\n+            assert LSPConstants.KIND in item\n+            assert LSPConstants.LOCATION in item\n+\n+            ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n+\n+        return ret\n+\n @ensure_all_methods_implemented(LanguageServer)\n class SyncLanguageServer:\n     \"\"\"\n     The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n     It is used to communicate with Language Servers of different programming languages.\n     \"\"\"\n \n-    def __init__(self, language_server: LanguageServer) -> None:\n+    def __init__(self, language_server: LanguageServer, timeout: Optional[int] = None):\n         self.language_server = language_server\n         self.loop = None\n         self.loop_thread = None\n-        \n+        self.timeout = timeout\n+\n         self._server_context = None\n \n     @classmethod\n     def create(\n         cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str, add_gitignore_content_to_config=True,\n+        timeout: Optional[int] = None",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2034036559",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034036559",
        "commented_code": "@@ -1539,43 +1559,72 @@ def load_cache(self):\n                 # cache often becomes corrupt, so just skip loading it\n                 self.logger.log(\n                         f\"Failed to load document symbols cache from {self._cache_path}: {e}. Possible cause: the cache file is corrupted. \" \n-                        \"Check for any errors related to saving the cache in the logs.\", \n+                        \"Check for any errors related to saving the cache in the logs.\",\n                         logging.ERROR\n                     )\n \n \n+    async def request_workspace_symbol(self, query: str) -> Union[List[multilspy_types.UnifiedSymbolInformation], None]:\n+        \"\"\"\n+        Raise a [workspace/symbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol) request to the Language Server\n+        to find symbols across the whole workspace. Wait for the response and return the result.\n+\n+        :param query: The query string to filter symbols by\n+\n+        :return Union[List[multilspy_types.UnifiedSymbolInformation], None]: A list of matching symbols\n+        \"\"\"\n+        response = await self.server.send.workspace_symbol({\"query\": query})\n+        if response is None:\n+            return None\n+\n+        assert isinstance(response, list)\n+\n+        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n+        for item in response:\n+            assert isinstance(item, dict)\n+\n+            assert LSPConstants.NAME in item\n+            assert LSPConstants.KIND in item\n+            assert LSPConstants.LOCATION in item\n+\n+            ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n+\n+        return ret\n+\n @ensure_all_methods_implemented(LanguageServer)\n class SyncLanguageServer:\n     \"\"\"\n     The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n     It is used to communicate with Language Servers of different programming languages.\n     \"\"\"\n \n-    def __init__(self, language_server: LanguageServer) -> None:\n+    def __init__(self, language_server: LanguageServer, timeout: Optional[int] = None):\n         self.language_server = language_server\n         self.loop = None\n         self.loop_thread = None\n-        \n+        self.timeout = timeout\n+\n         self._server_context = None\n \n     @classmethod\n     def create(\n         cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str, add_gitignore_content_to_config=True,\n+        timeout: Optional[int] = None",
        "comment_created_at": "2025-04-08T21:08:26+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Docstring missing",
        "pr_file_module": null
      },
      {
        "comment_id": "2034080254",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034036559",
        "commented_code": "@@ -1539,43 +1559,72 @@ def load_cache(self):\n                 # cache often becomes corrupt, so just skip loading it\n                 self.logger.log(\n                         f\"Failed to load document symbols cache from {self._cache_path}: {e}. Possible cause: the cache file is corrupted. \" \n-                        \"Check for any errors related to saving the cache in the logs.\", \n+                        \"Check for any errors related to saving the cache in the logs.\",\n                         logging.ERROR\n                     )\n \n \n+    async def request_workspace_symbol(self, query: str) -> Union[List[multilspy_types.UnifiedSymbolInformation], None]:\n+        \"\"\"\n+        Raise a [workspace/symbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol) request to the Language Server\n+        to find symbols across the whole workspace. Wait for the response and return the result.\n+\n+        :param query: The query string to filter symbols by\n+\n+        :return Union[List[multilspy_types.UnifiedSymbolInformation], None]: A list of matching symbols\n+        \"\"\"\n+        response = await self.server.send.workspace_symbol({\"query\": query})\n+        if response is None:\n+            return None\n+\n+        assert isinstance(response, list)\n+\n+        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n+        for item in response:\n+            assert isinstance(item, dict)\n+\n+            assert LSPConstants.NAME in item\n+            assert LSPConstants.KIND in item\n+            assert LSPConstants.LOCATION in item\n+\n+            ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n+\n+        return ret\n+\n @ensure_all_methods_implemented(LanguageServer)\n class SyncLanguageServer:\n     \"\"\"\n     The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n     It is used to communicate with Language Servers of different programming languages.\n     \"\"\"\n \n-    def __init__(self, language_server: LanguageServer) -> None:\n+    def __init__(self, language_server: LanguageServer, timeout: Optional[int] = None):\n         self.language_server = language_server\n         self.loop = None\n         self.loop_thread = None\n-        \n+        self.timeout = timeout\n+\n         self._server_context = None\n \n     @classmethod\n     def create(\n         cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str, add_gitignore_content_to_config=True,\n+        timeout: Optional[int] = None",
        "comment_created_at": "2025-04-08T21:45:44+00:00",
        "comment_author": "opcode81",
        "comment_body": "The multilspy devs did not add it. Why do we care?",
        "pr_file_module": null
      },
      {
        "comment_id": "2034903573",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034036559",
        "commented_code": "@@ -1539,43 +1559,72 @@ def load_cache(self):\n                 # cache often becomes corrupt, so just skip loading it\n                 self.logger.log(\n                         f\"Failed to load document symbols cache from {self._cache_path}: {e}. Possible cause: the cache file is corrupted. \" \n-                        \"Check for any errors related to saving the cache in the logs.\", \n+                        \"Check for any errors related to saving the cache in the logs.\",\n                         logging.ERROR\n                     )\n \n \n+    async def request_workspace_symbol(self, query: str) -> Union[List[multilspy_types.UnifiedSymbolInformation], None]:\n+        \"\"\"\n+        Raise a [workspace/symbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol) request to the Language Server\n+        to find symbols across the whole workspace. Wait for the response and return the result.\n+\n+        :param query: The query string to filter symbols by\n+\n+        :return Union[List[multilspy_types.UnifiedSymbolInformation], None]: A list of matching symbols\n+        \"\"\"\n+        response = await self.server.send.workspace_symbol({\"query\": query})\n+        if response is None:\n+            return None\n+\n+        assert isinstance(response, list)\n+\n+        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n+        for item in response:\n+            assert isinstance(item, dict)\n+\n+            assert LSPConstants.NAME in item\n+            assert LSPConstants.KIND in item\n+            assert LSPConstants.LOCATION in item\n+\n+            ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n+\n+        return ret\n+\n @ensure_all_methods_implemented(LanguageServer)\n class SyncLanguageServer:\n     \"\"\"\n     The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n     It is used to communicate with Language Servers of different programming languages.\n     \"\"\"\n \n-    def __init__(self, language_server: LanguageServer) -> None:\n+    def __init__(self, language_server: LanguageServer, timeout: Optional[int] = None):\n         self.language_server = language_server\n         self.loop = None\n         self.loop_thread = None\n-        \n+        self.timeout = timeout\n+\n         self._server_context = None\n \n     @classmethod\n     def create(\n         cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str, add_gitignore_content_to_config=True,\n+        timeout: Optional[int] = None",
        "comment_created_at": "2025-04-09T09:22:44+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Just noticed and mentioned it, it's ok to not add it ofc",
        "pr_file_module": null
      },
      {
        "comment_id": "2035614997",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034036559",
        "commented_code": "@@ -1539,43 +1559,72 @@ def load_cache(self):\n                 # cache often becomes corrupt, so just skip loading it\n                 self.logger.log(\n                         f\"Failed to load document symbols cache from {self._cache_path}: {e}. Possible cause: the cache file is corrupted. \" \n-                        \"Check for any errors related to saving the cache in the logs.\", \n+                        \"Check for any errors related to saving the cache in the logs.\",\n                         logging.ERROR\n                     )\n \n \n+    async def request_workspace_symbol(self, query: str) -> Union[List[multilspy_types.UnifiedSymbolInformation], None]:\n+        \"\"\"\n+        Raise a [workspace/symbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol) request to the Language Server\n+        to find symbols across the whole workspace. Wait for the response and return the result.\n+\n+        :param query: The query string to filter symbols by\n+\n+        :return Union[List[multilspy_types.UnifiedSymbolInformation], None]: A list of matching symbols\n+        \"\"\"\n+        response = await self.server.send.workspace_symbol({\"query\": query})\n+        if response is None:\n+            return None\n+\n+        assert isinstance(response, list)\n+\n+        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n+        for item in response:\n+            assert isinstance(item, dict)\n+\n+            assert LSPConstants.NAME in item\n+            assert LSPConstants.KIND in item\n+            assert LSPConstants.LOCATION in item\n+\n+            ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n+\n+        return ret\n+\n @ensure_all_methods_implemented(LanguageServer)\n class SyncLanguageServer:\n     \"\"\"\n     The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n     It is used to communicate with Language Servers of different programming languages.\n     \"\"\"\n \n-    def __init__(self, language_server: LanguageServer) -> None:\n+    def __init__(self, language_server: LanguageServer, timeout: Optional[int] = None):\n         self.language_server = language_server\n         self.loop = None\n         self.loop_thread = None\n-        \n+        self.timeout = timeout\n+\n         self._server_context = None\n \n     @classmethod\n     def create(\n         cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str, add_gitignore_content_to_config=True,\n+        timeout: Optional[int] = None",
        "comment_created_at": "2025-04-09T15:23:59+00:00",
        "comment_author": "opcode81",
        "comment_body": "I actually hate it when programmers don't add a unit to this type of parameter. I suppose it's in seconds, but you never know without reading the code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2035827400",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034036559",
        "commented_code": "@@ -1539,43 +1559,72 @@ def load_cache(self):\n                 # cache often becomes corrupt, so just skip loading it\n                 self.logger.log(\n                         f\"Failed to load document symbols cache from {self._cache_path}: {e}. Possible cause: the cache file is corrupted. \" \n-                        \"Check for any errors related to saving the cache in the logs.\", \n+                        \"Check for any errors related to saving the cache in the logs.\",\n                         logging.ERROR\n                     )\n \n \n+    async def request_workspace_symbol(self, query: str) -> Union[List[multilspy_types.UnifiedSymbolInformation], None]:\n+        \"\"\"\n+        Raise a [workspace/symbol](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol) request to the Language Server\n+        to find symbols across the whole workspace. Wait for the response and return the result.\n+\n+        :param query: The query string to filter symbols by\n+\n+        :return Union[List[multilspy_types.UnifiedSymbolInformation], None]: A list of matching symbols\n+        \"\"\"\n+        response = await self.server.send.workspace_symbol({\"query\": query})\n+        if response is None:\n+            return None\n+\n+        assert isinstance(response, list)\n+\n+        ret: List[multilspy_types.UnifiedSymbolInformation] = []\n+        for item in response:\n+            assert isinstance(item, dict)\n+\n+            assert LSPConstants.NAME in item\n+            assert LSPConstants.KIND in item\n+            assert LSPConstants.LOCATION in item\n+\n+            ret.append(multilspy_types.UnifiedSymbolInformation(**item))\n+\n+        return ret\n+\n @ensure_all_methods_implemented(LanguageServer)\n class SyncLanguageServer:\n     \"\"\"\n     The SyncLanguageServer class provides a language agnostic interface to the Language Server Protocol.\n     It is used to communicate with Language Servers of different programming languages.\n     \"\"\"\n \n-    def __init__(self, language_server: LanguageServer) -> None:\n+    def __init__(self, language_server: LanguageServer, timeout: Optional[int] = None):\n         self.language_server = language_server\n         self.loop = None\n         self.loop_thread = None\n-        \n+        self.timeout = timeout\n+\n         self._server_context = None\n \n     @classmethod\n     def create(\n         cls, config: MultilspyConfig, logger: MultilspyLogger, repository_root_path: str, add_gitignore_content_to_config=True,\n+        timeout: Optional[int] = None",
        "comment_created_at": "2025-04-09T17:33:40+00:00",
        "comment_author": "opcode81",
        "comment_body": "Added docstrings.",
        "pr_file_module": null
      }
    ]
  }
]