[
  {
    "discussion_id": "2424160024",
    "pr_number": 658,
    "pr_file": "test/solidlsp/nim/test_nim_basic.py",
    "created_at": "2025-10-12T14:12:42+00:00",
    "commented_code": "+\"\"\"\n+Basic integration tests for the Nim language server functionality.\n+\n+These tests validate the functionality of the language server APIs\n+like request_document_symbols using the Nim test repository.\n+\"\"\"\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+\n+\n+@pytest.mark.nim\n+class TestNimLanguageServerBasics:\n+    \"\"\"Test basic functionality of the Nim language server.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_language_server_initialization(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that Nim language server can be initialized successfully.\"\"\"\n+        assert language_server is not None\n+        assert language_server.language == Language.NIM\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_request_document_symbols(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_document_symbols for Nim files.\"\"\"\n+        # Test getting symbols from main.nim\n+        all_symbols, root_symbols = language_server.request_document_symbols(\"main.nim\", include_body=False)\n+\n+        # Extract function symbols (LSP Symbol Kind 12)\n+        function_symbols = [symbol for symbol in all_symbols if symbol.get(\"kind\") == 12]\n+        function_names = [symbol[\"name\"] for symbol in function_symbols]\n+\n+        # Should detect procedures from main.nim\n+        assert \"greet\" in function_names, \"Should find greet procedure\"\n+        assert \"calculate\" in function_names, \"Should find calculate procedure\"\n+        assert \"processData\" in function_names, \"Should find processData procedure\"\n+        assert \"newPerson\" in function_names, \"Should find newPerson procedure\"\n+        assert \"describe\" in function_names, \"Should find describe procedure\"\n+        assert \"newAnimal\" in function_names, \"Should find newAnimal procedure\"\n+        assert \"speak\" in function_names, \"Should find speak procedure\"\n+\n+        # Extract type symbols (LSP Symbol Kind 5 for Class, 23 for Struct)\n+        type_symbols = [symbol for symbol in all_symbols if symbol.get(\"kind\") in [5, 23]]\n+        type_names = [symbol[\"name\"] for symbol in type_symbols]\n+\n+        # Should detect types from main.nim\n+        assert \"Person\" in type_names, \"Should find Person type\"\n+        assert \"Animal\" in type_names, \"Should find Animal type\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_request_document_symbols_with_body(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_document_symbols with body extraction.\"\"\"\n+        # Test with include_body=True\n+        all_symbols, root_symbols = language_server.request_document_symbols(\"main.nim\", include_body=True)\n+\n+        function_symbols = [symbol for symbol in all_symbols if symbol.get(\"kind\") == 12]\n+\n+        # Find greet procedure and check it has body\n+        greet_symbol = next((sym for sym in function_symbols if sym[\"name\"] == \"greet\"), None)\n+        assert greet_symbol is not None, \"Should find greet procedure\"\n+\n+        if \"body\" in greet_symbol:\n+            body = greet_symbol[\"body\"]\n+            # nimlangserver returns just the signature, not the full proc definition\n+            assert \"greet\" in body, \"Procedure body should contain function name\"\n+            assert \"string\" in body, \"greet body should contain return type\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_utils_module(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test symbol detection in utils.nim module.\"\"\"\n+        # Test with utils.nim\n+        utils_all_symbols, utils_root_symbols = language_server.request_document_symbols(\"utils.nim\", include_body=False)\n+\n+        utils_function_symbols = [symbol for symbol in utils_all_symbols if symbol.get(\"kind\") == 12]\n+        utils_function_names = [symbol[\"name\"] for symbol in utils_function_symbols]\n+\n+        # Should detect procedures from utils.nim\n+        expected_utils_functions = [\n+            \"formatNumber\",\n+            \"reverseString\",\n+            \"isPalindrome\",\n+            \"fibonacci\",\n+            \"factorial\",\n+            \"gcd\",\n+            \"lcm\",\n+            \"mapSeq\",\n+        ]\n+\n+        for func_name in expected_utils_functions:\n+            assert func_name in utils_function_names, f\"Should find {func_name} procedure in utils.nim\"\n+\n+        # Note: nimlangserver symbol reporting limitations (confirmed via testing):\n+        # \u2713 Reports 'proc' definitions as SymbolKind.Function (12)\n+        # \u2713 Reports 'template' definitions as SymbolKind.Function (12) - e.g., timeIt is detected\n+        # \u2717 Does NOT report 'iterator' definitions - e.g., countUp is not detected\n+        # \u2717 Does NOT report 'method' definitions - see test_nim_types_module\n+        # \u2717 Returns empty results on semantic errors (missing imports, etc.) - see test_nim_error_recovery\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_types_module(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test type detection in types.nim module.\"\"\"\n+        # Test with types.nim\n+        types_all_symbols, types_root_symbols = language_server.request_document_symbols(\"types.nim\", include_body=False)\n+\n+        # Extract type symbols\n+        type_symbols = [symbol for symbol in types_all_symbols if symbol.get(\"kind\") in [5, 23, 10]]  # Class, Struct, Enum\n+        type_names = [symbol[\"name\"] for symbol in type_symbols]\n+\n+        # Should detect types from types.nim\n+        expected_types = [\"Point\", \"Rectangle\", \"Shape\", \"Circle\", \"Triangle\", \"Color\", \"Status\", \"Result\", \"Database\"]\n+\n+        for type_name in expected_types:\n+            assert type_name in type_names, f\"Should find {type_name} type in types.nim\"\n+\n+        # Extract function symbols\n+        function_symbols = [symbol for symbol in types_all_symbols if symbol.get(\"kind\") == 12]\n+        function_names = [symbol[\"name\"] for symbol in function_symbols]\n+\n+        # Should detect procedures from types.nim\n+        # Note: 'draw' is defined as 'method' (lines 76, 80, 84), not 'proc'\n+        # nimlangserver does NOT report method definitions, only proc definitions\n+        expected_procs = [\n+            \"newPoint\",\n+            \"toString\",\n+            \"distance\",\n+            \"newRectangle\",\n+            \"area\",\n+            \"perimeter\",\n+            \"contains\",\n+            # \"draw\" - NOT included: methods are not reported by nimlangserver\n+            \"ok\",\n+            \"err\",\n+            \"isOk\",\n+            \"isErr\",\n+            \"newDatabase\",\n+            \"set\",\n+            \"get\",\n+            \"delete\",\n+        ]\n+\n+        for proc_name in expected_procs:\n+            assert proc_name in function_names, f\"Should find {proc_name} procedure in types.nim\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_goto_definition(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test goto definition functionality for Nim.\"\"\"\n+        # Test goto definition from main.nim to utils module\n+        definition = language_server.request_definition(\"main.nim\", 58, 8)  # formatNumber call\n+\n+        if definition:\n+            assert isinstance(definition, list), \"Definition should be a list\"\n+            assert len(definition) > 0, \"Should find at least one definition\"\n+\n+            # Check if the definition points to utils.nim\n+            first_def = definition[0]\n+            if \"uri\" in first_def:\n+                assert \"utils.nim\" in first_def[\"uri\"], \"Definition should point to utils.nim\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_find_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test find references functionality for Nim.\"\"\"\n+        # Test finding references to the Person type\n+        references = language_server.request_references(\"main.nim\", 20, 3)  # Person type definition\n+\n+        if references:",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2424160024",
        "repo_full_name": "oraios/serena",
        "pr_number": 658,
        "pr_file": "test/solidlsp/nim/test_nim_basic.py",
        "discussion_id": "2424160024",
        "commented_code": "@@ -0,0 +1,244 @@\n+\"\"\"\n+Basic integration tests for the Nim language server functionality.\n+\n+These tests validate the functionality of the language server APIs\n+like request_document_symbols using the Nim test repository.\n+\"\"\"\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+\n+\n+@pytest.mark.nim\n+class TestNimLanguageServerBasics:\n+    \"\"\"Test basic functionality of the Nim language server.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_language_server_initialization(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that Nim language server can be initialized successfully.\"\"\"\n+        assert language_server is not None\n+        assert language_server.language == Language.NIM\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_request_document_symbols(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_document_symbols for Nim files.\"\"\"\n+        # Test getting symbols from main.nim\n+        all_symbols, root_symbols = language_server.request_document_symbols(\"main.nim\", include_body=False)\n+\n+        # Extract function symbols (LSP Symbol Kind 12)\n+        function_symbols = [symbol for symbol in all_symbols if symbol.get(\"kind\") == 12]\n+        function_names = [symbol[\"name\"] for symbol in function_symbols]\n+\n+        # Should detect procedures from main.nim\n+        assert \"greet\" in function_names, \"Should find greet procedure\"\n+        assert \"calculate\" in function_names, \"Should find calculate procedure\"\n+        assert \"processData\" in function_names, \"Should find processData procedure\"\n+        assert \"newPerson\" in function_names, \"Should find newPerson procedure\"\n+        assert \"describe\" in function_names, \"Should find describe procedure\"\n+        assert \"newAnimal\" in function_names, \"Should find newAnimal procedure\"\n+        assert \"speak\" in function_names, \"Should find speak procedure\"\n+\n+        # Extract type symbols (LSP Symbol Kind 5 for Class, 23 for Struct)\n+        type_symbols = [symbol for symbol in all_symbols if symbol.get(\"kind\") in [5, 23]]\n+        type_names = [symbol[\"name\"] for symbol in type_symbols]\n+\n+        # Should detect types from main.nim\n+        assert \"Person\" in type_names, \"Should find Person type\"\n+        assert \"Animal\" in type_names, \"Should find Animal type\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_request_document_symbols_with_body(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_document_symbols with body extraction.\"\"\"\n+        # Test with include_body=True\n+        all_symbols, root_symbols = language_server.request_document_symbols(\"main.nim\", include_body=True)\n+\n+        function_symbols = [symbol for symbol in all_symbols if symbol.get(\"kind\") == 12]\n+\n+        # Find greet procedure and check it has body\n+        greet_symbol = next((sym for sym in function_symbols if sym[\"name\"] == \"greet\"), None)\n+        assert greet_symbol is not None, \"Should find greet procedure\"\n+\n+        if \"body\" in greet_symbol:\n+            body = greet_symbol[\"body\"]\n+            # nimlangserver returns just the signature, not the full proc definition\n+            assert \"greet\" in body, \"Procedure body should contain function name\"\n+            assert \"string\" in body, \"greet body should contain return type\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_utils_module(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test symbol detection in utils.nim module.\"\"\"\n+        # Test with utils.nim\n+        utils_all_symbols, utils_root_symbols = language_server.request_document_symbols(\"utils.nim\", include_body=False)\n+\n+        utils_function_symbols = [symbol for symbol in utils_all_symbols if symbol.get(\"kind\") == 12]\n+        utils_function_names = [symbol[\"name\"] for symbol in utils_function_symbols]\n+\n+        # Should detect procedures from utils.nim\n+        expected_utils_functions = [\n+            \"formatNumber\",\n+            \"reverseString\",\n+            \"isPalindrome\",\n+            \"fibonacci\",\n+            \"factorial\",\n+            \"gcd\",\n+            \"lcm\",\n+            \"mapSeq\",\n+        ]\n+\n+        for func_name in expected_utils_functions:\n+            assert func_name in utils_function_names, f\"Should find {func_name} procedure in utils.nim\"\n+\n+        # Note: nimlangserver symbol reporting limitations (confirmed via testing):\n+        # \u2713 Reports 'proc' definitions as SymbolKind.Function (12)\n+        # \u2713 Reports 'template' definitions as SymbolKind.Function (12) - e.g., timeIt is detected\n+        # \u2717 Does NOT report 'iterator' definitions - e.g., countUp is not detected\n+        # \u2717 Does NOT report 'method' definitions - see test_nim_types_module\n+        # \u2717 Returns empty results on semantic errors (missing imports, etc.) - see test_nim_error_recovery\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_types_module(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test type detection in types.nim module.\"\"\"\n+        # Test with types.nim\n+        types_all_symbols, types_root_symbols = language_server.request_document_symbols(\"types.nim\", include_body=False)\n+\n+        # Extract type symbols\n+        type_symbols = [symbol for symbol in types_all_symbols if symbol.get(\"kind\") in [5, 23, 10]]  # Class, Struct, Enum\n+        type_names = [symbol[\"name\"] for symbol in type_symbols]\n+\n+        # Should detect types from types.nim\n+        expected_types = [\"Point\", \"Rectangle\", \"Shape\", \"Circle\", \"Triangle\", \"Color\", \"Status\", \"Result\", \"Database\"]\n+\n+        for type_name in expected_types:\n+            assert type_name in type_names, f\"Should find {type_name} type in types.nim\"\n+\n+        # Extract function symbols\n+        function_symbols = [symbol for symbol in types_all_symbols if symbol.get(\"kind\") == 12]\n+        function_names = [symbol[\"name\"] for symbol in function_symbols]\n+\n+        # Should detect procedures from types.nim\n+        # Note: 'draw' is defined as 'method' (lines 76, 80, 84), not 'proc'\n+        # nimlangserver does NOT report method definitions, only proc definitions\n+        expected_procs = [\n+            \"newPoint\",\n+            \"toString\",\n+            \"distance\",\n+            \"newRectangle\",\n+            \"area\",\n+            \"perimeter\",\n+            \"contains\",\n+            # \"draw\" - NOT included: methods are not reported by nimlangserver\n+            \"ok\",\n+            \"err\",\n+            \"isOk\",\n+            \"isErr\",\n+            \"newDatabase\",\n+            \"set\",\n+            \"get\",\n+            \"delete\",\n+        ]\n+\n+        for proc_name in expected_procs:\n+            assert proc_name in function_names, f\"Should find {proc_name} procedure in types.nim\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_goto_definition(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test goto definition functionality for Nim.\"\"\"\n+        # Test goto definition from main.nim to utils module\n+        definition = language_server.request_definition(\"main.nim\", 58, 8)  # formatNumber call\n+\n+        if definition:\n+            assert isinstance(definition, list), \"Definition should be a list\"\n+            assert len(definition) > 0, \"Should find at least one definition\"\n+\n+            # Check if the definition points to utils.nim\n+            first_def = definition[0]\n+            if \"uri\" in first_def:\n+                assert \"utils.nim\" in first_def[\"uri\"], \"Definition should point to utils.nim\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.NIM], indirect=True)\n+    def test_nim_find_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test find references functionality for Nim.\"\"\"\n+        # Test finding references to the Person type\n+        references = language_server.request_references(\"main.nim\", 20, 3)  # Person type definition\n+\n+        if references:",
        "comment_created_at": "2025-10-12T14:12:42+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Since this is the most common point of failure, pls make sure cross-file references finding actually works by ensuring the expected references are found, not just their existence. Pls remove all `assert isinstance` and `assert len(...) > 0`, these are too generic and don't really add value. There's a dedicated section about this in the guide (memory) on how to add support for new languages",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2306639125",
    "pr_number": 555,
    "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
    "created_at": "2025-08-28T08:24:56+00:00",
    "commented_code": "+import os\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+\n+@pytest.mark.haskell\n+class TestHaskellLanguageServer:\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_find_symbol(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding symbols in Haskell code.\"\"\"\n+        symbols = language_server.request_full_symbol_tree()\n+\n+        # Check for main function\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"main\"), \"main function not found in symbol tree\"\n+\n+        # Check for custom data types\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"Calculator\"), \"Calculator type not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"Person\"), \"Person type not found in symbol tree\"\n+\n+        # Check for functions\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"demoFunction\"), \"demoFunction not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"greetPerson\"), \"greetPerson not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"add\"), \"add function not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"helper\"), \"helper function not found in symbol tree\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_find_referencing_symbols(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding references to Haskell functions.\"\"\"\n+        file_path = os.path.join(\"Main.hs\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        # Find demoFunction symbol\n+        demo_function_symbol = None\n+        for sym in symbols[0]:\n+            if sym.get(\"name\") == \"demoFunction\":\n+                demo_function_symbol = sym\n+                break\n+\n+        assert demo_function_symbol is not None, \"Could not find 'demoFunction' symbol in Main.hs\"\n+\n+        # Get references to demoFunction\n+        sel_start = demo_function_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_references(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        # Should find at least the definition itself\n+        assert any(\"Main.hs\" in ref.get(\"relativePath\", \"\") for ref in refs), \"Main.hs should reference demoFunction definition\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_cross_module_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding cross-module references in Haskell.\"\"\"\n+        # This test validates that cross-module symbols are accessible\n+        # The exact implementation depends on HLS capabilities\n+        lib_symbols = language_server.request_document_symbols(os.path.join(\"src\", \"Lib.hs\"))\n+        assert len(lib_symbols[0]) > 0, \"Should find symbols in Lib.hs module\"",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2306639125",
        "repo_full_name": "oraios/serena",
        "pr_number": 555,
        "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
        "discussion_id": "2306639125",
        "commented_code": "@@ -0,0 +1,58 @@\n+import os\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+\n+@pytest.mark.haskell\n+class TestHaskellLanguageServer:\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_find_symbol(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding symbols in Haskell code.\"\"\"\n+        symbols = language_server.request_full_symbol_tree()\n+\n+        # Check for main function\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"main\"), \"main function not found in symbol tree\"\n+\n+        # Check for custom data types\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"Calculator\"), \"Calculator type not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"Person\"), \"Person type not found in symbol tree\"\n+\n+        # Check for functions\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"demoFunction\"), \"demoFunction not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"greetPerson\"), \"greetPerson not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"add\"), \"add function not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"helper\"), \"helper function not found in symbol tree\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_find_referencing_symbols(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding references to Haskell functions.\"\"\"\n+        file_path = os.path.join(\"Main.hs\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        # Find demoFunction symbol\n+        demo_function_symbol = None\n+        for sym in symbols[0]:\n+            if sym.get(\"name\") == \"demoFunction\":\n+                demo_function_symbol = sym\n+                break\n+\n+        assert demo_function_symbol is not None, \"Could not find 'demoFunction' symbol in Main.hs\"\n+\n+        # Get references to demoFunction\n+        sel_start = demo_function_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_references(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        # Should find at least the definition itself\n+        assert any(\"Main.hs\" in ref.get(\"relativePath\", \"\") for ref in refs), \"Main.hs should reference demoFunction definition\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_cross_module_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding cross-module references in Haskell.\"\"\"\n+        # This test validates that cross-module symbols are accessible\n+        # The exact implementation depends on HLS capabilities\n+        lib_symbols = language_server.request_document_symbols(os.path.join(\"src\", \"Lib.hs\"))\n+        assert len(lib_symbols[0]) > 0, \"Should find symbols in Lib.hs module\"",
        "comment_created_at": "2025-08-28T08:24:56+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "should check exact matching of expected symbol names and their files",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2287481272",
    "pr_number": 503,
    "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
    "created_at": "2025-08-20T08:59:36+00:00",
    "commented_code": "+\"\"\"\n+Basic integration tests for the Haskell language server (HLS).\n+\"\"\"\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+\n+\n+@pytest.mark.haskell\n+class TestHaskellLanguageServer:\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols(self, language_server: SolidLanguageServer) -> None:\n+        symbols = language_server.request_document_symbols(\"src/Lib.hs\")\n+        assert symbols, \"Expected document symbols in Lib.hs\"\n+\n+        # HLS returns a tuple with (hierarchical_symbols, flat_symbols)\n+        assert isinstance(symbols, tuple) and len(symbols) == 2, f\"Expected tuple of 2 lists, got: {type(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+        # Use flat symbols for easier searching - extract names from both lists\n+        all_symbols = flat_symbols + hierarchical_symbols\n+        symbol_names = []\n+\n+        for sym in all_symbols:\n+            if isinstance(sym, dict) and \"name\" in sym:\n+                symbol_names.append(sym[\"name\"])\n+            # Also check children if they exist\n+            if isinstance(sym, dict) and \"children\" in sym:\n+                for child in sym[\"children\"]:\n+                    if isinstance(child, dict) and \"name\" in child:\n+                        symbol_names.append(child[\"name\"])\n+\n+        # Check that we can find our key advanced Haskell features\n+        expected_symbols = [\"hello\", \"add\", \"safeDiv\", \"Calculator\", \"User\", \"validateUser\"]\n+\n+        found_symbols = [name for name in expected_symbols if name in symbol_names]\n+        assert len(found_symbols) >= 3, f\"Expected to find at least 3 key symbols, found: {found_symbols} in {symbol_names[:10]}...\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_references(self, language_server: SolidLanguageServer) -> None:\n+        # Simple test - try to get references at a known location without relying on document symbols\n+        # Line 6, column 1 should be around the 'add' function definition in src/Lib.hs\n+        refs = language_server.request_references(\"src/Lib.hs\", 6, 1)\n+        # Just verify we get a list back (may be empty if no references found, but should not error)\n+        assert isinstance(refs, list), f\"Expected list of references, got: {type(refs)}\"",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2287481272",
        "repo_full_name": "oraios/serena",
        "pr_number": 503,
        "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
        "discussion_id": "2287481272",
        "commented_code": "@@ -0,0 +1,94 @@\n+\"\"\"\n+Basic integration tests for the Haskell language server (HLS).\n+\"\"\"\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+\n+\n+@pytest.mark.haskell\n+class TestHaskellLanguageServer:\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols(self, language_server: SolidLanguageServer) -> None:\n+        symbols = language_server.request_document_symbols(\"src/Lib.hs\")\n+        assert symbols, \"Expected document symbols in Lib.hs\"\n+\n+        # HLS returns a tuple with (hierarchical_symbols, flat_symbols)\n+        assert isinstance(symbols, tuple) and len(symbols) == 2, f\"Expected tuple of 2 lists, got: {type(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+        # Use flat symbols for easier searching - extract names from both lists\n+        all_symbols = flat_symbols + hierarchical_symbols\n+        symbol_names = []\n+\n+        for sym in all_symbols:\n+            if isinstance(sym, dict) and \"name\" in sym:\n+                symbol_names.append(sym[\"name\"])\n+            # Also check children if they exist\n+            if isinstance(sym, dict) and \"children\" in sym:\n+                for child in sym[\"children\"]:\n+                    if isinstance(child, dict) and \"name\" in child:\n+                        symbol_names.append(child[\"name\"])\n+\n+        # Check that we can find our key advanced Haskell features\n+        expected_symbols = [\"hello\", \"add\", \"safeDiv\", \"Calculator\", \"User\", \"validateUser\"]\n+\n+        found_symbols = [name for name in expected_symbols if name in symbol_names]\n+        assert len(found_symbols) >= 3, f\"Expected to find at least 3 key symbols, found: {found_symbols} in {symbol_names[:10]}...\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_references(self, language_server: SolidLanguageServer) -> None:\n+        # Simple test - try to get references at a known location without relying on document symbols\n+        # Line 6, column 1 should be around the 'add' function definition in src/Lib.hs\n+        refs = language_server.request_references(\"src/Lib.hs\", 6, 1)\n+        # Just verify we get a list back (may be empty if no references found, but should not error)\n+        assert isinstance(refs, list), f\"Expected list of references, got: {type(refs)}\"",
        "comment_created_at": "2025-08-20T08:59:36+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "these kinds of tests are not useful, they don't test anything. Instead of testing on isinstance, we need test that the expected symbols were actually found. See the tests for other LS, like csharp.\n\nAn important case that needs to be covered is finding references across files (LS can struggle with that if they're not properly initialized).\n\nWe also need tests for the symbolic methods, not just the basic LSP calls. So request_containing_symbol, request_referencing_symbols and so on. All tests should assert for exact equality of the expected result names. Pls have a look at the tests for the other LS to see what I mean",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2290334301",
    "pr_number": 503,
    "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
    "created_at": "2025-08-21T08:38:30+00:00",
    "commented_code": "+\"\"\"\n+Tests for the Haskell language server symbol-related functionality.\n+\n+These tests focus on the following methods:\n+- request_containing_symbol\n+- request_referencing_symbols\n+- request_defining_symbol\n+- request_document_symbols integration\n+\"\"\"\n+\n+import os\n+import time\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_types import SymbolKind\n+\n+pytestmark = pytest.mark.haskell\n+\n+\n+class TestHaskellLanguageServerSymbols:\n+    \"\"\"Test the Haskell language server's symbol-related functionality.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols_lib_exact_content(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test document symbols for Lib.hs and verify exact symbol content.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Give HLS some time to fully analyze the file\n+        time.sleep(2)\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None, \"Should receive symbols from HLS\"\n+        assert isinstance(symbols, tuple), f\"Expected tuple, got {type(symbols)}\"\n+        assert len(symbols) == 2, f\"Expected tuple of length 2, got {len(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Extract symbol names from hierarchical symbols (which should contain the actual functions)\n+        symbol_names = []\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and \"name\" in symbol:\n+                symbol_names.append(symbol[\"name\"])\n+                # Also check children if they exist\n+                if symbol.get(\"children\"):\n+                    for child in symbol[\"children\"]:\n+                        if isinstance(child, dict) and \"name\" in child:\n+                            symbol_names.append(child[\"name\"])\n+\n+        # Verify we can find key Haskell functions and data types\n+        expected_symbols = [\"add\", \"hello\", \"safeDiv\", \"Calculator\", \"User\", \"validateUser\"]\n+        found_symbols = [name for name in expected_symbols if name in symbol_names]\n+\n+        assert len(found_symbols) >= 3, f\"Expected at least 3 key symbols, found: {found_symbols} from all symbols: {symbol_names[:10]}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols_main_exact_content(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test document symbols for Main.hs.\"\"\"\n+        file_path = os.path.join(\"app\", \"Main.hs\")\n+\n+        # Give HLS some time to fully analyze the file\n+        time.sleep(2)\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None, \"Should receive symbols from Main.hs\"\n+        assert isinstance(symbols, tuple), f\"Expected tuple, got {type(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Extract symbol names\n+        symbol_names = []\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and \"name\" in symbol:\n+                symbol_names.append(symbol[\"name\"])\n+                if symbol.get(\"children\"):\n+                    for child in symbol[\"children\"]:\n+                        if isinstance(child, dict) and \"name\" in child:\n+                            symbol_names.append(child[\"name\"])\n+\n+        # Main.hs should have a main function\n+        assert \"main\" in symbol_names, f\"Expected 'main' function, found symbols: {symbol_names}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_containing_symbol_function(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_containing_symbol for a function by using document symbols first.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # First get document symbols to understand the structure\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find the add function symbol to get its exact location\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\":\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\":\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function symbol not found in document symbols\")\n+\n+        # Get the range of the add function\n+        if \"range\" not in add_symbol or \"start\" not in add_symbol[\"range\"]:\n+            pytest.skip(\"add function symbol doesn't have range information\")\n+\n+        add_start = add_symbol[\"range\"][\"start\"]\n+        test_line = add_start[\"line\"]\n+        test_char = add_start[\"character\"] + 5  # Position inside function name\n+\n+        # Test containing symbol\n+        containing_symbol = language_server.request_containing_symbol(file_path, test_line, test_char, include_body=True)\n+\n+        if containing_symbol is None:\n+            # HLS might not support containing symbol or need more time\n+            pytest.skip(\"request_containing_symbol returned None - HLS may not support this feature yet\")\n+\n+        # Verify we found the correct symbol\n+        assert containing_symbol[\"name\"] == \"add\", f\"Expected 'add', got '{containing_symbol.get('name')}'\"\n+        assert containing_symbol[\"kind\"] == SymbolKind.Function.value, f\"Expected Function kind, got {containing_symbol.get('kind')}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_containing_symbol_data_type(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_containing_symbol for data type by using document symbols first.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # First get document symbols to find Calculator data type\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find the Calculator data type symbol\n+        calculator_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"Calculator\":\n+                calculator_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"Calculator\":\n+                        calculator_symbol = child\n+                        break\n+\n+        if not calculator_symbol or \"range\" not in calculator_symbol:\n+            pytest.skip(\"Calculator data type symbol not found or missing range\")\n+\n+        calc_start = calculator_symbol[\"range\"][\"start\"]\n+        test_line = calc_start[\"line\"]\n+        test_char = calc_start[\"character\"] + 5\n+\n+        containing_symbol = language_server.request_containing_symbol(file_path, test_line, test_char)\n+\n+        if containing_symbol is None:\n+            pytest.skip(\"request_containing_symbol returned None for data type\")\n+\n+        assert containing_symbol[\"name\"] == \"Calculator\", f\"Expected 'Calculator', got '{containing_symbol.get('name')}'\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_referencing_symbols_function(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_referencing_symbols for a function.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Get document symbols first\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find add function with selectionRange\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\" and \"selectionRange\" in symbol:\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\" and \"selectionRange\" in child:\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function with selectionRange not found\")\n+\n+        sel_start = add_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        # refs should be a list of ReferenceWithSymbol objects or similar\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"\n+\n+        # Verify structure if references exist\n+        for ref in refs:\n+            if hasattr(ref, \"symbol\"):\n+                symbol = ref.symbol\n+                assert \"name\" in symbol, \"Reference symbol should have name\"\n+                assert \"kind\" in symbol, \"Reference symbol should have kind\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_referencing_symbols_data_type(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_referencing_symbols for a data type.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find User data type\n+        user_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"User\" and \"selectionRange\" in symbol:\n+                user_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"User\" and \"selectionRange\" in child:\n+                        user_symbol = child\n+                        break\n+\n+        if not user_symbol:\n+            pytest.skip(\"User data type with selectionRange not found\")\n+\n+        sel_start = user_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_defining_symbol_function_usage(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_defining_symbol by looking for function usage in Main.hs.\"\"\"\n+        main_file = os.path.join(\"app\", \"Main.hs\")\n+\n+        # Look for the add function call in Main.hs (around line 9: print (add 2 3))\n+        # We'll test position 9, 15 which should be on the 'add' call\n+        defining_symbol = language_server.request_defining_symbol(main_file, 9, 15)\n+\n+        if defining_symbol is None:\n+            pytest.skip(\"request_defining_symbol returned None - may not be supported yet\")\n+\n+        # Should find the definition of 'add' function\n+        assert \"name\" in defining_symbol, \"Defining symbol should have name\"\n+        assert defining_symbol[\"name\"] == \"add\", f\"Expected 'add', got '{defining_symbol.get('name')}'\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_cross_file_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that we can find references across files.\"\"\"\n+        # The 'add' function is defined in src/Lib.hs and used in app/Main.hs\n+        src_file = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Get add function location from document symbols\n+        symbols = language_server.request_document_symbols(src_file)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\" and \"selectionRange\" in symbol:\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\" and \"selectionRange\" in child:\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function with selectionRange not found for cross-file test\")\n+\n+        sel_start = add_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(src_file, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2290334301",
        "repo_full_name": "oraios/serena",
        "pr_number": 503,
        "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
        "discussion_id": "2290334301",
        "commented_code": "@@ -0,0 +1,288 @@\n+\"\"\"\n+Tests for the Haskell language server symbol-related functionality.\n+\n+These tests focus on the following methods:\n+- request_containing_symbol\n+- request_referencing_symbols\n+- request_defining_symbol\n+- request_document_symbols integration\n+\"\"\"\n+\n+import os\n+import time\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_types import SymbolKind\n+\n+pytestmark = pytest.mark.haskell\n+\n+\n+class TestHaskellLanguageServerSymbols:\n+    \"\"\"Test the Haskell language server's symbol-related functionality.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols_lib_exact_content(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test document symbols for Lib.hs and verify exact symbol content.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Give HLS some time to fully analyze the file\n+        time.sleep(2)\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None, \"Should receive symbols from HLS\"\n+        assert isinstance(symbols, tuple), f\"Expected tuple, got {type(symbols)}\"\n+        assert len(symbols) == 2, f\"Expected tuple of length 2, got {len(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Extract symbol names from hierarchical symbols (which should contain the actual functions)\n+        symbol_names = []\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and \"name\" in symbol:\n+                symbol_names.append(symbol[\"name\"])\n+                # Also check children if they exist\n+                if symbol.get(\"children\"):\n+                    for child in symbol[\"children\"]:\n+                        if isinstance(child, dict) and \"name\" in child:\n+                            symbol_names.append(child[\"name\"])\n+\n+        # Verify we can find key Haskell functions and data types\n+        expected_symbols = [\"add\", \"hello\", \"safeDiv\", \"Calculator\", \"User\", \"validateUser\"]\n+        found_symbols = [name for name in expected_symbols if name in symbol_names]\n+\n+        assert len(found_symbols) >= 3, f\"Expected at least 3 key symbols, found: {found_symbols} from all symbols: {symbol_names[:10]}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols_main_exact_content(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test document symbols for Main.hs.\"\"\"\n+        file_path = os.path.join(\"app\", \"Main.hs\")\n+\n+        # Give HLS some time to fully analyze the file\n+        time.sleep(2)\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None, \"Should receive symbols from Main.hs\"\n+        assert isinstance(symbols, tuple), f\"Expected tuple, got {type(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Extract symbol names\n+        symbol_names = []\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and \"name\" in symbol:\n+                symbol_names.append(symbol[\"name\"])\n+                if symbol.get(\"children\"):\n+                    for child in symbol[\"children\"]:\n+                        if isinstance(child, dict) and \"name\" in child:\n+                            symbol_names.append(child[\"name\"])\n+\n+        # Main.hs should have a main function\n+        assert \"main\" in symbol_names, f\"Expected 'main' function, found symbols: {symbol_names}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_containing_symbol_function(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_containing_symbol for a function by using document symbols first.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # First get document symbols to understand the structure\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find the add function symbol to get its exact location\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\":\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\":\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function symbol not found in document symbols\")\n+\n+        # Get the range of the add function\n+        if \"range\" not in add_symbol or \"start\" not in add_symbol[\"range\"]:\n+            pytest.skip(\"add function symbol doesn't have range information\")\n+\n+        add_start = add_symbol[\"range\"][\"start\"]\n+        test_line = add_start[\"line\"]\n+        test_char = add_start[\"character\"] + 5  # Position inside function name\n+\n+        # Test containing symbol\n+        containing_symbol = language_server.request_containing_symbol(file_path, test_line, test_char, include_body=True)\n+\n+        if containing_symbol is None:\n+            # HLS might not support containing symbol or need more time\n+            pytest.skip(\"request_containing_symbol returned None - HLS may not support this feature yet\")\n+\n+        # Verify we found the correct symbol\n+        assert containing_symbol[\"name\"] == \"add\", f\"Expected 'add', got '{containing_symbol.get('name')}'\"\n+        assert containing_symbol[\"kind\"] == SymbolKind.Function.value, f\"Expected Function kind, got {containing_symbol.get('kind')}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_containing_symbol_data_type(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_containing_symbol for data type by using document symbols first.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # First get document symbols to find Calculator data type\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find the Calculator data type symbol\n+        calculator_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"Calculator\":\n+                calculator_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"Calculator\":\n+                        calculator_symbol = child\n+                        break\n+\n+        if not calculator_symbol or \"range\" not in calculator_symbol:\n+            pytest.skip(\"Calculator data type symbol not found or missing range\")\n+\n+        calc_start = calculator_symbol[\"range\"][\"start\"]\n+        test_line = calc_start[\"line\"]\n+        test_char = calc_start[\"character\"] + 5\n+\n+        containing_symbol = language_server.request_containing_symbol(file_path, test_line, test_char)\n+\n+        if containing_symbol is None:\n+            pytest.skip(\"request_containing_symbol returned None for data type\")\n+\n+        assert containing_symbol[\"name\"] == \"Calculator\", f\"Expected 'Calculator', got '{containing_symbol.get('name')}'\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_referencing_symbols_function(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_referencing_symbols for a function.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Get document symbols first\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find add function with selectionRange\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\" and \"selectionRange\" in symbol:\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\" and \"selectionRange\" in child:\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function with selectionRange not found\")\n+\n+        sel_start = add_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        # refs should be a list of ReferenceWithSymbol objects or similar\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"\n+\n+        # Verify structure if references exist\n+        for ref in refs:\n+            if hasattr(ref, \"symbol\"):\n+                symbol = ref.symbol\n+                assert \"name\" in symbol, \"Reference symbol should have name\"\n+                assert \"kind\" in symbol, \"Reference symbol should have kind\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_referencing_symbols_data_type(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_referencing_symbols for a data type.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find User data type\n+        user_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"User\" and \"selectionRange\" in symbol:\n+                user_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"User\" and \"selectionRange\" in child:\n+                        user_symbol = child\n+                        break\n+\n+        if not user_symbol:\n+            pytest.skip(\"User data type with selectionRange not found\")\n+\n+        sel_start = user_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_defining_symbol_function_usage(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_defining_symbol by looking for function usage in Main.hs.\"\"\"\n+        main_file = os.path.join(\"app\", \"Main.hs\")\n+\n+        # Look for the add function call in Main.hs (around line 9: print (add 2 3))\n+        # We'll test position 9, 15 which should be on the 'add' call\n+        defining_symbol = language_server.request_defining_symbol(main_file, 9, 15)\n+\n+        if defining_symbol is None:\n+            pytest.skip(\"request_defining_symbol returned None - may not be supported yet\")\n+\n+        # Should find the definition of 'add' function\n+        assert \"name\" in defining_symbol, \"Defining symbol should have name\"\n+        assert defining_symbol[\"name\"] == \"add\", f\"Expected 'add', got '{defining_symbol.get('name')}'\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_cross_file_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that we can find references across files.\"\"\"\n+        # The 'add' function is defined in src/Lib.hs and used in app/Main.hs\n+        src_file = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Get add function location from document symbols\n+        symbols = language_server.request_document_symbols(src_file)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\" and \"selectionRange\" in symbol:\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\" and \"selectionRange\" in child:\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function with selectionRange not found for cross-file test\")\n+\n+        sel_start = add_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(src_file, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"",
        "comment_created_at": "2025-08-21T08:38:30+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "This is not enough, we should check for exact matches. Pls remove all asserts of a type or of not-None or on len larger 0. The tests should check that the expected symbols were found",
        "pr_file_module": null
      },
      {
        "comment_id": "2371477390",
        "repo_full_name": "oraios/serena",
        "pr_number": 503,
        "pr_file": "test/solidlsp/haskell/test_haskell_basic.py",
        "discussion_id": "2290334301",
        "commented_code": "@@ -0,0 +1,288 @@\n+\"\"\"\n+Tests for the Haskell language server symbol-related functionality.\n+\n+These tests focus on the following methods:\n+- request_containing_symbol\n+- request_referencing_symbols\n+- request_defining_symbol\n+- request_document_symbols integration\n+\"\"\"\n+\n+import os\n+import time\n+\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_types import SymbolKind\n+\n+pytestmark = pytest.mark.haskell\n+\n+\n+class TestHaskellLanguageServerSymbols:\n+    \"\"\"Test the Haskell language server's symbol-related functionality.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols_lib_exact_content(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test document symbols for Lib.hs and verify exact symbol content.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Give HLS some time to fully analyze the file\n+        time.sleep(2)\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None, \"Should receive symbols from HLS\"\n+        assert isinstance(symbols, tuple), f\"Expected tuple, got {type(symbols)}\"\n+        assert len(symbols) == 2, f\"Expected tuple of length 2, got {len(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Extract symbol names from hierarchical symbols (which should contain the actual functions)\n+        symbol_names = []\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and \"name\" in symbol:\n+                symbol_names.append(symbol[\"name\"])\n+                # Also check children if they exist\n+                if symbol.get(\"children\"):\n+                    for child in symbol[\"children\"]:\n+                        if isinstance(child, dict) and \"name\" in child:\n+                            symbol_names.append(child[\"name\"])\n+\n+        # Verify we can find key Haskell functions and data types\n+        expected_symbols = [\"add\", \"hello\", \"safeDiv\", \"Calculator\", \"User\", \"validateUser\"]\n+        found_symbols = [name for name in expected_symbols if name in symbol_names]\n+\n+        assert len(found_symbols) >= 3, f\"Expected at least 3 key symbols, found: {found_symbols} from all symbols: {symbol_names[:10]}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_document_symbols_main_exact_content(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test document symbols for Main.hs.\"\"\"\n+        file_path = os.path.join(\"app\", \"Main.hs\")\n+\n+        # Give HLS some time to fully analyze the file\n+        time.sleep(2)\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None, \"Should receive symbols from Main.hs\"\n+        assert isinstance(symbols, tuple), f\"Expected tuple, got {type(symbols)}\"\n+\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Extract symbol names\n+        symbol_names = []\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and \"name\" in symbol:\n+                symbol_names.append(symbol[\"name\"])\n+                if symbol.get(\"children\"):\n+                    for child in symbol[\"children\"]:\n+                        if isinstance(child, dict) and \"name\" in child:\n+                            symbol_names.append(child[\"name\"])\n+\n+        # Main.hs should have a main function\n+        assert \"main\" in symbol_names, f\"Expected 'main' function, found symbols: {symbol_names}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_containing_symbol_function(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_containing_symbol for a function by using document symbols first.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # First get document symbols to understand the structure\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find the add function symbol to get its exact location\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\":\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\":\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function symbol not found in document symbols\")\n+\n+        # Get the range of the add function\n+        if \"range\" not in add_symbol or \"start\" not in add_symbol[\"range\"]:\n+            pytest.skip(\"add function symbol doesn't have range information\")\n+\n+        add_start = add_symbol[\"range\"][\"start\"]\n+        test_line = add_start[\"line\"]\n+        test_char = add_start[\"character\"] + 5  # Position inside function name\n+\n+        # Test containing symbol\n+        containing_symbol = language_server.request_containing_symbol(file_path, test_line, test_char, include_body=True)\n+\n+        if containing_symbol is None:\n+            # HLS might not support containing symbol or need more time\n+            pytest.skip(\"request_containing_symbol returned None - HLS may not support this feature yet\")\n+\n+        # Verify we found the correct symbol\n+        assert containing_symbol[\"name\"] == \"add\", f\"Expected 'add', got '{containing_symbol.get('name')}'\"\n+        assert containing_symbol[\"kind\"] == SymbolKind.Function.value, f\"Expected Function kind, got {containing_symbol.get('kind')}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_containing_symbol_data_type(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_containing_symbol for data type by using document symbols first.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # First get document symbols to find Calculator data type\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find the Calculator data type symbol\n+        calculator_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"Calculator\":\n+                calculator_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"Calculator\":\n+                        calculator_symbol = child\n+                        break\n+\n+        if not calculator_symbol or \"range\" not in calculator_symbol:\n+            pytest.skip(\"Calculator data type symbol not found or missing range\")\n+\n+        calc_start = calculator_symbol[\"range\"][\"start\"]\n+        test_line = calc_start[\"line\"]\n+        test_char = calc_start[\"character\"] + 5\n+\n+        containing_symbol = language_server.request_containing_symbol(file_path, test_line, test_char)\n+\n+        if containing_symbol is None:\n+            pytest.skip(\"request_containing_symbol returned None for data type\")\n+\n+        assert containing_symbol[\"name\"] == \"Calculator\", f\"Expected 'Calculator', got '{containing_symbol.get('name')}'\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_referencing_symbols_function(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_referencing_symbols for a function.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Get document symbols first\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find add function with selectionRange\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\" and \"selectionRange\" in symbol:\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\" and \"selectionRange\" in child:\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function with selectionRange not found\")\n+\n+        sel_start = add_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        # refs should be a list of ReferenceWithSymbol objects or similar\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"\n+\n+        # Verify structure if references exist\n+        for ref in refs:\n+            if hasattr(ref, \"symbol\"):\n+                symbol = ref.symbol\n+                assert \"name\" in symbol, \"Reference symbol should have name\"\n+                assert \"kind\" in symbol, \"Reference symbol should have kind\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_referencing_symbols_data_type(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_referencing_symbols for a data type.\"\"\"\n+        file_path = os.path.join(\"src\", \"Lib.hs\")\n+\n+        symbols = language_server.request_document_symbols(file_path)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        # Find User data type\n+        user_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"User\" and \"selectionRange\" in symbol:\n+                user_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"User\" and \"selectionRange\" in child:\n+                        user_symbol = child\n+                        break\n+\n+        if not user_symbol:\n+            pytest.skip(\"User data type with selectionRange not found\")\n+\n+        sel_start = user_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(file_path, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_request_defining_symbol_function_usage(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test request_defining_symbol by looking for function usage in Main.hs.\"\"\"\n+        main_file = os.path.join(\"app\", \"Main.hs\")\n+\n+        # Look for the add function call in Main.hs (around line 9: print (add 2 3))\n+        # We'll test position 9, 15 which should be on the 'add' call\n+        defining_symbol = language_server.request_defining_symbol(main_file, 9, 15)\n+\n+        if defining_symbol is None:\n+            pytest.skip(\"request_defining_symbol returned None - may not be supported yet\")\n+\n+        # Should find the definition of 'add' function\n+        assert \"name\" in defining_symbol, \"Defining symbol should have name\"\n+        assert defining_symbol[\"name\"] == \"add\", f\"Expected 'add', got '{defining_symbol.get('name')}'\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.HASKELL], indirect=True)\n+    def test_cross_file_references(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that we can find references across files.\"\"\"\n+        # The 'add' function is defined in src/Lib.hs and used in app/Main.hs\n+        src_file = os.path.join(\"src\", \"Lib.hs\")\n+\n+        # Get add function location from document symbols\n+        symbols = language_server.request_document_symbols(src_file)\n+        assert symbols is not None\n+        hierarchical_symbols, flat_symbols = symbols\n+\n+        add_symbol = None\n+        for symbol in hierarchical_symbols:\n+            if isinstance(symbol, dict) and symbol.get(\"name\") == \"add\" and \"selectionRange\" in symbol:\n+                add_symbol = symbol\n+                break\n+            if isinstance(symbol, dict) and \"children\" in symbol:\n+                for child in symbol[\"children\"]:\n+                    if isinstance(child, dict) and child.get(\"name\") == \"add\" and \"selectionRange\" in child:\n+                        add_symbol = child\n+                        break\n+\n+        if not add_symbol:\n+            pytest.skip(\"add function with selectionRange not found for cross-file test\")\n+\n+        sel_start = add_symbol[\"selectionRange\"][\"start\"]\n+        refs = language_server.request_referencing_symbols(src_file, sel_start[\"line\"], sel_start[\"character\"])\n+\n+        assert isinstance(refs, list), f\"Expected list of references, got {type(refs)}\"",
        "comment_created_at": "2025-09-23T07:51:28+00:00",
        "comment_author": "arjunswaj",
        "comment_body": "Fixed these",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180032008",
    "pr_number": 261,
    "pr_file": "test/solidlsp/elixir/test_elixir_basic.py",
    "created_at": "2025-07-02T13:11:42+00:00",
    "commented_code": "+\"\"\"\n+Basic integration tests for the Elixir language server functionality.\n+\n+These tests validate the functionality of the language server APIs\n+like request_references using the test repository.\n+\"\"\"\n+\n+import os\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+from . import NEXTLS_UNAVAILABLE, NEXTLS_UNAVAILABLE_REASON\n+\n+# These marks will be applied to all tests in this module\n+pytestmark = [\n+    pytest.mark.elixir,\n+    pytest.mark.skipif(NEXTLS_UNAVAILABLE, reason=f\"Next LS not available: {NEXTLS_UNAVAILABLE_REASON}\")\n+]\n+\n+\n+class TestElixirBasic:\n+    \"\"\"Basic Elixir language server functionality tests.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.ELIXIR], indirect=True)\n+    def test_request_references_function_definition(self, language_server: SolidLanguageServer):\n+        \"\"\"Test finding references to a function definition.\"\"\"\n+        file_path = os.path.join(\"lib\", \"models.ex\")\n+        symbols = language_server.request_document_symbols(file_path)\n+        \n+        # Find the User module's 'new' function\n+        user_new_symbol = None\n+        for symbol in symbols[0]:  # Top level symbols\n+            if symbol.get(\"name\") == \"User\" and symbol.get(\"kind\") == 2:  # Module\n+                for child in symbol.get(\"children\", []):\n+                    if child.get(\"name\", \"\").startswith(\"def new(\") and child.get(\"kind\") == 12:  # Function\n+                        user_new_symbol = child\n+                        break\n+                break\n+        \n+        if not user_new_symbol or \"selectionRange\" not in user_new_symbol:\n+            pytest.skip(\"User.new function or its selectionRange not found\")\n+\n+        sel_start = user_new_symbol[\"selectionRange\"][\"start\"]\n+        references = language_server.request_references(\n+            file_path, sel_start[\"line\"], sel_start[\"character\"]\n+        )\n+\n+        assert references is not None\n+        assert len(references) > 0\n+        \n+        # Should find at least one reference (the definition itself)\n+        found_definition = any(\n+            ref[\"uri\"].endswith(\"models.ex\") for ref in references\n+        )\n+        assert found_definition, \"Should find the function definition\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.ELIXIR], indirect=True)\n+    def test_request_references_create_user_function(self, language_server: SolidLanguageServer):\n+        \"\"\"Test finding references to create_user function.\"\"\"\n+        file_path = os.path.join(\"lib\", \"services.ex\")\n+        symbols = language_server.request_document_symbols(file_path)\n+        \n+        # Find the UserService module's 'create_user' function\n+        create_user_symbol = None\n+        for symbol in symbols[0]:  # Top level symbols\n+            if symbol.get(\"name\") == \"UserService\" and symbol.get(\"kind\") == 2:  # Module\n+                for child in symbol.get(\"children\", []):\n+                    if child.get(\"name\", \"\").startswith(\"def create_user(\") and child.get(\"kind\") == 12:  # Function\n+                        create_user_symbol = child\n+                        break\n+                break\n+        \n+        if not create_user_symbol or \"selectionRange\" not in create_user_symbol:\n+            pytest.skip(\"UserService.create_user function or its selectionRange not found\")\n+\n+        sel_start = create_user_symbol[\"selectionRange\"][\"start\"]\n+        references = language_server.request_references(\n+            file_path, sel_start[\"line\"], sel_start[\"character\"]\n+        )\n+\n+        assert references is not None\n+        assert len(references) > 0",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2180032008",
        "repo_full_name": "oraios/serena",
        "pr_number": 261,
        "pr_file": "test/solidlsp/elixir/test_elixir_basic.py",
        "discussion_id": "2180032008",
        "commented_code": "@@ -0,0 +1,123 @@\n+\"\"\"\n+Basic integration tests for the Elixir language server functionality.\n+\n+These tests validate the functionality of the language server APIs\n+like request_references using the test repository.\n+\"\"\"\n+\n+import os\n+import pytest\n+\n+from solidlsp import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+from . import NEXTLS_UNAVAILABLE, NEXTLS_UNAVAILABLE_REASON\n+\n+# These marks will be applied to all tests in this module\n+pytestmark = [\n+    pytest.mark.elixir,\n+    pytest.mark.skipif(NEXTLS_UNAVAILABLE, reason=f\"Next LS not available: {NEXTLS_UNAVAILABLE_REASON}\")\n+]\n+\n+\n+class TestElixirBasic:\n+    \"\"\"Basic Elixir language server functionality tests.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.ELIXIR], indirect=True)\n+    def test_request_references_function_definition(self, language_server: SolidLanguageServer):\n+        \"\"\"Test finding references to a function definition.\"\"\"\n+        file_path = os.path.join(\"lib\", \"models.ex\")\n+        symbols = language_server.request_document_symbols(file_path)\n+        \n+        # Find the User module's 'new' function\n+        user_new_symbol = None\n+        for symbol in symbols[0]:  # Top level symbols\n+            if symbol.get(\"name\") == \"User\" and symbol.get(\"kind\") == 2:  # Module\n+                for child in symbol.get(\"children\", []):\n+                    if child.get(\"name\", \"\").startswith(\"def new(\") and child.get(\"kind\") == 12:  # Function\n+                        user_new_symbol = child\n+                        break\n+                break\n+        \n+        if not user_new_symbol or \"selectionRange\" not in user_new_symbol:\n+            pytest.skip(\"User.new function or its selectionRange not found\")\n+\n+        sel_start = user_new_symbol[\"selectionRange\"][\"start\"]\n+        references = language_server.request_references(\n+            file_path, sel_start[\"line\"], sel_start[\"character\"]\n+        )\n+\n+        assert references is not None\n+        assert len(references) > 0\n+        \n+        # Should find at least one reference (the definition itself)\n+        found_definition = any(\n+            ref[\"uri\"].endswith(\"models.ex\") for ref in references\n+        )\n+        assert found_definition, \"Should find the function definition\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.ELIXIR], indirect=True)\n+    def test_request_references_create_user_function(self, language_server: SolidLanguageServer):\n+        \"\"\"Test finding references to create_user function.\"\"\"\n+        file_path = os.path.join(\"lib\", \"services.ex\")\n+        symbols = language_server.request_document_symbols(file_path)\n+        \n+        # Find the UserService module's 'create_user' function\n+        create_user_symbol = None\n+        for symbol in symbols[0]:  # Top level symbols\n+            if symbol.get(\"name\") == \"UserService\" and symbol.get(\"kind\") == 2:  # Module\n+                for child in symbol.get(\"children\", []):\n+                    if child.get(\"name\", \"\").startswith(\"def create_user(\") and child.get(\"kind\") == 12:  # Function\n+                        create_user_symbol = child\n+                        break\n+                break\n+        \n+        if not create_user_symbol or \"selectionRange\" not in create_user_symbol:\n+            pytest.skip(\"UserService.create_user function or its selectionRange not found\")\n+\n+        sel_start = create_user_symbol[\"selectionRange\"][\"start\"]\n+        references = language_server.request_references(\n+            file_path, sel_start[\"line\"], sel_start[\"character\"]\n+        )\n+\n+        assert references is not None\n+        assert len(references) > 0",
        "comment_created_at": "2025-07-02T13:11:42+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "This is not enough, one should at least test that the references have the right names.",
        "pr_file_module": null
      }
    ]
  }
]