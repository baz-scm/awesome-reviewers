[
  {
    "discussion_id": "2287471840",
    "pr_number": 503,
    "pr_file": "src/solidlsp/language_servers/haskell/haskell_language_server.py",
    "created_at": "2025-08-20T08:56:14+00:00",
    "commented_code": "+import json\n+import logging\n+import os\n+import pathlib\n+import shutil\n+import threading\n+import time\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.ls_utils import PlatformUtils\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+from solidlsp.settings import SolidLSPSettings\n+\n+from ..common import RuntimeDependencyCollection\n+\n+\n+class HaskellLanguageServer(SolidLanguageServer):\n+    \"\"\"\n+    Provides Haskell-specific instantiation of SolidLanguageServer using HLS.\n+    Prefers haskell-language-server-wrapper if available, else falls back to haskell-language-server.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # Common Haskell build artifacts to ignore\n+        return super().is_ignored_dirname(dirname) or dirname in [\n+            \".stack-work\",\n+            \"dist-newstyle\",\n+            \"dist\",\n+            \".cabal-store\",\n+            \".hie\",\n+            \".ghc\",\n+            \"node_modules\",\n+        ]\n+\n+    @staticmethod\n+    def _find_hls_executable() -> list[str]:\n+        # Prefer the wrapper, fallback to hls direct binary\n+        for exe in [\"haskell-language-server-wrapper\", \"haskell-language-server\"]:\n+            path = shutil.which(exe)\n+            if path:\n+                # HLS accepts --lsp to run as LSP server; wrapper may not require it, but it's supported\n+                return [path, \"--lsp\"]\n+        raise RuntimeError(",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2287471840",
        "repo_full_name": "oraios/serena",
        "pr_number": 503,
        "pr_file": "src/solidlsp/language_servers/haskell/haskell_language_server.py",
        "discussion_id": "2287471840",
        "commented_code": "@@ -0,0 +1,206 @@\n+import json\n+import logging\n+import os\n+import pathlib\n+import shutil\n+import threading\n+import time\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.ls_utils import PlatformUtils\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+from solidlsp.settings import SolidLSPSettings\n+\n+from ..common import RuntimeDependencyCollection\n+\n+\n+class HaskellLanguageServer(SolidLanguageServer):\n+    \"\"\"\n+    Provides Haskell-specific instantiation of SolidLanguageServer using HLS.\n+    Prefers haskell-language-server-wrapper if available, else falls back to haskell-language-server.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # Common Haskell build artifacts to ignore\n+        return super().is_ignored_dirname(dirname) or dirname in [\n+            \".stack-work\",\n+            \"dist-newstyle\",\n+            \"dist\",\n+            \".cabal-store\",\n+            \".hie\",\n+            \".ghc\",\n+            \"node_modules\",\n+        ]\n+\n+    @staticmethod\n+    def _find_hls_executable() -> list[str]:\n+        # Prefer the wrapper, fallback to hls direct binary\n+        for exe in [\"haskell-language-server-wrapper\", \"haskell-language-server\"]:\n+            path = shutil.which(exe)\n+            if path:\n+                # HLS accepts --lsp to run as LSP server; wrapper may not require it, but it's supported\n+                return [path, \"--lsp\"]\n+        raise RuntimeError(",
        "comment_created_at": "2025-08-20T08:56:14+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "in the only place where this is used, the exception is caught. This is not good from a design perspective IMO, better to return None or even to just not have it as a separate method",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198577476",
    "pr_number": 284,
    "pr_file": "src/serena/symbol.py",
    "created_at": "2025-07-10T19:45:08+00:00",
    "commented_code": "@dataclass\n-class ReferenceInSymbol(ToStringMixin):\n-    \"\"\"Same as the class of the same name in the language server, but using Serena's Symbol class.\n-    Be careful to not confuse it with counterpart!\n+class ReferenceInLanguageServerSymbol(ToStringMixin):\n     \"\"\"\n+    Represents the location of a reference to another symbol within a symbol/file.\n \n-    symbol: Symbol\n+    The contained symbol is the symbol within which the reference is located,\n+    not the symbol that is referenced.\n+    \"\"\"\n+\n+    symbol: LanguageServerSymbol\n+    \"\"\"\n+    the symbol within which the reference is located\n+    \"\"\"\n     line: int\n+    \"\"\"\n+    the line number in which the reference is located (0-based)\n+    \"\"\"\n     character: int\n-\n-    def get_relative_path(self) -> str | None:\n-        return self.symbol.location.relative_path\n+    \"\"\"\n+    the column number in which the reference is located (0-based)\n+    \"\"\"\n \n     @classmethod\n     def from_lsp_reference(cls, reference: LSPReferenceInSymbol) -> Self:\n-        return cls(symbol=Symbol(reference.symbol), line=reference.line, character=reference.character)\n+        return cls(symbol=LanguageServerSymbol(reference.symbol), line=reference.line, character=reference.character)\n \n+    def get_relative_path(self) -> str | None:",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2198577476",
        "repo_full_name": "oraios/serena",
        "pr_number": 284,
        "pr_file": "src/serena/symbol.py",
        "discussion_id": "2198577476",
        "commented_code": "@@ -490,24 +411,36 @@ def add_children(s: Self) -> list[dict[str, Any]]:\n \n \n @dataclass\n-class ReferenceInSymbol(ToStringMixin):\n-    \"\"\"Same as the class of the same name in the language server, but using Serena's Symbol class.\n-    Be careful to not confuse it with counterpart!\n+class ReferenceInLanguageServerSymbol(ToStringMixin):\n     \"\"\"\n+    Represents the location of a reference to another symbol within a symbol/file.\n \n-    symbol: Symbol\n+    The contained symbol is the symbol within which the reference is located,\n+    not the symbol that is referenced.\n+    \"\"\"\n+\n+    symbol: LanguageServerSymbol\n+    \"\"\"\n+    the symbol within which the reference is located\n+    \"\"\"\n     line: int\n+    \"\"\"\n+    the line number in which the reference is located (0-based)\n+    \"\"\"\n     character: int\n-\n-    def get_relative_path(self) -> str | None:\n-        return self.symbol.location.relative_path\n+    \"\"\"\n+    the column number in which the reference is located (0-based)\n+    \"\"\"\n \n     @classmethod\n     def from_lsp_reference(cls, reference: LSPReferenceInSymbol) -> Self:\n-        return cls(symbol=Symbol(reference.symbol), line=reference.line, character=reference.character)\n+        return cls(symbol=LanguageServerSymbol(reference.symbol), line=reference.line, character=reference.character)\n \n+    def get_relative_path(self) -> str | None:",
        "comment_created_at": "2025-07-10T19:45:08+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "when can this be None?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198727904",
        "repo_full_name": "oraios/serena",
        "pr_number": 284,
        "pr_file": "src/serena/symbol.py",
        "discussion_id": "2198577476",
        "commented_code": "@@ -490,24 +411,36 @@ def add_children(s: Self) -> list[dict[str, Any]]:\n \n \n @dataclass\n-class ReferenceInSymbol(ToStringMixin):\n-    \"\"\"Same as the class of the same name in the language server, but using Serena's Symbol class.\n-    Be careful to not confuse it with counterpart!\n+class ReferenceInLanguageServerSymbol(ToStringMixin):\n     \"\"\"\n+    Represents the location of a reference to another symbol within a symbol/file.\n \n-    symbol: Symbol\n+    The contained symbol is the symbol within which the reference is located,\n+    not the symbol that is referenced.\n+    \"\"\"\n+\n+    symbol: LanguageServerSymbol\n+    \"\"\"\n+    the symbol within which the reference is located\n+    \"\"\"\n     line: int\n+    \"\"\"\n+    the line number in which the reference is located (0-based)\n+    \"\"\"\n     character: int\n-\n-    def get_relative_path(self) -> str | None:\n-        return self.symbol.location.relative_path\n+    \"\"\"\n+    the column number in which the reference is located (0-based)\n+    \"\"\"\n \n     @classmethod\n     def from_lsp_reference(cls, reference: LSPReferenceInSymbol) -> Self:\n-        return cls(symbol=Symbol(reference.symbol), line=reference.line, character=reference.character)\n+        return cls(symbol=LanguageServerSymbol(reference.symbol), line=reference.line, character=reference.character)\n \n+    def get_relative_path(self) -> str | None:",
        "comment_created_at": "2025-07-10T20:56:35+00:00",
        "comment_author": "opcode81",
        "comment_body": "See defining class `LanguageServerSymbolLocation`:\r\n\r\n> the relative path of the file containing the symbol; if None, the symbol is defined outside of the project's scope",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057794173",
    "pr_number": 84,
    "pr_file": "src/multilspy/language_server.py",
    "created_at": "2025-04-24T08:03:22+00:00",
    "commented_code": "_, document_roots = await self.request_document_symbols(relative_file_path)\n         return [\n             (\n-                root[\"name\"],\n-                root[\"kind\"],\n-                root[\"selectionRange\"][\"start\"][\"line\"], # type: ignore\n-                root[\"selectionRange\"][\"start\"][\"character\"] # type: ignore\n+                root.get(\"name\"),",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2057794173",
        "repo_full_name": "oraios/serena",
        "pr_number": 84,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2057794173",
        "commented_code": "@@ -1046,10 +1046,10 @@ async def request_document_overview(self, relative_file_path: str) -> list[tuple\n         _, document_roots = await self.request_document_symbols(relative_file_path)\n         return [\n             (\n-                root[\"name\"],\n-                root[\"kind\"],\n-                root[\"selectionRange\"][\"start\"][\"line\"], # type: ignore\n-                root[\"selectionRange\"][\"start\"][\"character\"] # type: ignore\n+                root.get(\"name\"),",
        "comment_created_at": "2025-04-24T08:03:22+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Could you tell me which kind of symbols you ran into that don't have a name, a kind, or selection range? I don't think there are sensible defaults for them, maybe we should rather filter them out?",
        "pr_file_module": null
      },
      {
        "comment_id": "2057854986",
        "repo_full_name": "oraios/serena",
        "pr_number": 84,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2057794173",
        "commented_code": "@@ -1046,10 +1046,10 @@ async def request_document_overview(self, relative_file_path: str) -> list[tuple\n         _, document_roots = await self.request_document_symbols(relative_file_path)\n         return [\n             (\n-                root[\"name\"],\n-                root[\"kind\"],\n-                root[\"selectionRange\"][\"start\"][\"line\"], # type: ignore\n-                root[\"selectionRange\"][\"start\"][\"character\"] # type: ignore\n+                root.get(\"name\"),",
        "comment_created_at": "2025-04-24T08:34:39+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Or if selectionRange is not available, one should try a fallback, like going through \"location\" or using \"range\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2034032869",
    "pr_number": 41,
    "pr_file": "src/multilspy/language_server.py",
    "created_at": "2025-04-08T21:05:24+00:00",
    "commented_code": "new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2034032869",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-08T21:05:24+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "So does the pathutil do the right job even if the definition is on a different drive?",
        "pr_file_module": null
      },
      {
        "comment_id": "2034071959",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-08T21:38:34+00:00",
        "comment_author": "opcode81",
        "comment_body": "Depends on what \"the right job\" is.\r\nIt will return None:\r\n\r\nhttps://github.com/oraios/serena/blob/2fa6a95aac1f051ae6c187e44c3b3b7aa159b884/src/multilspy/multilspy_utils.py#L98-L105",
        "pr_file_module": null
      },
      {
        "comment_id": "2034909123",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-09T09:24:23+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "previously we were adding absPath.\r\n\r\nIt explains why they changed the type for relativePath to optional in the location type-dict. I guess None is good, not sure whether this means we need none-checks in our code now",
        "pr_file_module": null
      },
      {
        "comment_id": "2035619995",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-09T15:26:41+00:00",
        "comment_author": "opcode81",
        "comment_body": "This probably needs consolidation. Semantically, it's wrong to use an absolute path. Then again, the original authors basically assumed that one can always use a relative path (which is wrong for Windows though), so in that sense, using an absolute path is the right thing to do.\r\n\r\nSo shall we change their function to return the absolute path instead of None and use it everywhere, getting rid of our exception handlers?",
        "pr_file_module": null
      },
      {
        "comment_id": "2035695425",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-09T16:08:44+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Thing is, receiving an abs path when one expects a relative path is also wrong. In many places we join relative paths with the project root. I feel like it's better to return None if relativePath cannot be achieved, bite into the sour apple (is that an expression in English as well?) and do None handling everywhere",
        "pr_file_module": null
      },
      {
        "comment_id": "2035814508",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-09T17:24:09+00:00",
        "comment_author": "opcode81",
        "comment_body": "Agreed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2035825625",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-09T17:32:25+00:00",
        "comment_author": "opcode81",
        "comment_body": "I changed all calls to use the PathUtils function",
        "pr_file_module": null
      },
      {
        "comment_id": "2035826784",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-09T17:33:16+00:00",
        "comment_author": "opcode81",
        "comment_body": "A potential downside of using None is, however, that Serena will be completely unable to read any files for which no relative paths can be constructed, as we never return the absolute paths.\r\n\r\nWe might consider changing Serena's interface to return an unspecified \"path\", which could either be relative or absolute. But this is something for another PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "2051574746",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-19T20:32:47+00:00",
        "comment_author": "scottyybt",
        "comment_body": "Today was setting up mcp server on my new linux machine and started getting this error when tried to run the server with vscode:\r\n\r\n> Should` ignore all files in gitignore not not .gitignore found at /home/fedora/scottie/serena/myproject.yml/.gitignore. Skipping. Fatal exception: [Errno 20] Not a directory: '/home/fedora/scottie/serena/myproject.yml'\r\n\r\n_The constructor of SerenaAgent takes a project_file_path and loads the project configuration from it if it exists. It uses ProjectConfig.from_yml to load the config from the given path. Then it calls activate_project with the loaded project_config.\r\nThe activate_project method calls reset_language_server, which creates the language server with the project_root path. The project_root is set in the ProjectConfig constructor, but it may be None or a file path.\r\n  You have to ensure that project_root is always a directory path. Added this at line 79 and it worked. Cant even believe.. hehe \r\n      79        if project_root.is_file():\r\n      80          project_root = project_root.parent",
        "pr_file_module": null
      },
      {
        "comment_id": "2051575382",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-19T20:38:48+00:00",
        "comment_author": "scottyybt",
        "comment_body": "Sorry for my bad english btw. Hope someone will be able to understand what I tried to say :D ",
        "pr_file_module": null
      },
      {
        "comment_id": "2051596441",
        "repo_full_name": "oraios/serena",
        "pr_number": 41,
        "pr_file": "src/multilspy/language_server.py",
        "discussion_id": "2034032869",
        "commented_code": "@@ -538,9 +560,7 @@ async def request_definition(\n             new_item: multilspy_types.Location = {}\n             new_item.update(response)\n             new_item[\"absolutePath\"] = PathUtils.uri_to_path(new_item[\"uri\"])\n-            new_item[\"relativePath\"] = str(\n-                PurePath(os.path.relpath(new_item[\"absolutePath\"], self.repository_root_path))\n-            )\n+            new_item[\"relativePath\"] = PathUtils.get_relative_path(new_item[\"absolutePath\"], self.repository_root_path)",
        "comment_created_at": "2025-04-19T22:56:50+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Pls open a new issue for that and share your MCP server config and your Serena config",
        "pr_file_module": null
      }
    ]
  }
]