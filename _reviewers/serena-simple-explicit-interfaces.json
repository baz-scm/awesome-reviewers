[
  {
    "discussion_id": "2422639792",
    "pr_number": 660,
    "pr_file": "src/solidlsp/ls.py",
    "created_at": "2025-10-11T09:06:11+00:00",
    "commented_code": "return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2422639792",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-11T09:06:11+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Thing is, many language servers don't support this newer functionality AFAIK and I don't really like the idea of depending on it in Serena. So I think we should have an own fallback in case the LS does not support it - search all appearances of the name and replace it ourselves. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "2422843488",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-11T13:26:58+00:00",
        "comment_author": "dsyme",
        "comment_body": "@MischaPanch It's your call as designers. But from experience of using coding agents, they would probably do pretty well at adjusting gracefully and making use of other tools, or else returning the error up.  It's non-trivial to get a rename right in all situations - there are reasons why it's built into LSP - and if asked I think I would just recommend returning a tool failure in this case.\r\n\r\nAs one random example, if renaming from a symbol without spaces to one with spaces in F# the LSP should be responsible for enclosing the F# symbol with ``` ``...`` ``` quotes.  Doing that sort of thing from the outside is not fun",
        "pr_file_module": null
      },
      {
        "comment_id": "2422905569",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-11T14:29:28+00:00",
        "comment_author": "opcode81",
        "comment_body": "> It's non-trivial to get a rename right in all situations - there are reasons why it's built into LSP - and if asked I think I would just recommend returning a tool failure in this case.\r\n\r\nI agree with this assessment.",
        "pr_file_module": null
      },
      {
        "comment_id": "2424492030",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-12T16:16:20+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Ok, then instead of the fallback, this tool should be disabled automatically if the project's language server does not provide the desired functionality. Something like a method (in Component)\r\n\r\n```python\r\ndef is_available(self) -> bool:\r\n   return True\r\n```\r\n\r\nwhich can be overridden for the new tool\r\n\r\n```python\r\n@override\r\ndef is_available(self) -> bool:\r\n   if not self.agent.is_using_language_server():\r\n       return True  # jetbrains mode, rename tool will be implemented \r\n   return self.agent.language_server.supports_rename()\r\n```\r\n\r\nwhich is then used to filter out active tools",
        "pr_file_module": null
      },
      {
        "comment_id": "2424524372",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-12T16:29:29+00:00",
        "comment_author": "opcode81",
        "comment_body": "This is not really possible, because, during startup, we cannot wait for the language server to be available for the answer to be provided. And even if we could, this could only apply to cases where a project is provided at startup. For these cases, the information will have to be available statically (based on meta-information), e.g. in the `Language` enum (which is basically the LS enum).\r\n\r\nAlso note that we don't need the check for `agent.is_using_language_server()`, because it will be an entirely different tool in the JetBrains case.",
        "pr_file_module": null
      },
      {
        "comment_id": "2424551940",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-12T16:41:28+00:00",
        "comment_author": "opcode81",
        "comment_body": "Perhaps the tool simply failing is acceptable; the number of tokens wasted on a failing tool call is not excessive. Especially if the major LS do support this operation, I would propose to go for this very simple solution. If they don't, we can reconsider our options...",
        "pr_file_module": null
      },
      {
        "comment_id": "2424584329",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-12T16:55:32+00:00",
        "comment_author": "dsyme",
        "comment_body": "If the error message indicates not supported, yes, it seems acceptable. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2424891947",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-12T20:50:16+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "It's not only about a falling tool call, the presence of the tool uses tokens and also confuses weaker llms,.which sometimes can't deal with that (observed for qwen).\r\n\r\nThe information can be available statically, it's known at implementation time. The special case of starting with a known active project is, as I mentioned above, a very important special case (all Claude code users belong to that)",
        "pr_file_module": null
      },
      {
        "comment_id": "2424931047",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-12T21:53:33+00:00",
        "comment_author": "opcode81",
        "comment_body": "I don't think it's worth it. Why make things more complicated only to save a few tokens in cases that will hardly ever occur? The rename function is widely implemented and supported by all of the most relevant language servers (Pyright, RustAnalyzer, typescript-language-server, Gopls, Roslyn, Intelephense, etc.).",
        "pr_file_module": null
      },
      {
        "comment_id": "2430209085",
        "repo_full_name": "oraios/serena",
        "pr_number": 660,
        "pr_file": "src/solidlsp/ls.py",
        "discussion_id": "2422639792",
        "commented_code": "@@ -1626,6 +1626,92 @@ def request_workspace_symbol(self, query: str) -> list[ls_types.UnifiedSymbolInf\n \n         return ret\n \n+    def rename_symbol(\n+        self,\n+        relative_file_path: str,\n+        line: int,\n+        column: int,\n+        new_name: str,\n+    ) -> \"ls_types.WorkspaceEdit | None\":\n+        \"\"\"\n+        Rename a symbol at the given position to a new name.\n+\n+        :param relative_file_path: The relative path to the file containing the symbol\n+        :param line: The 0-indexed line number of the symbol\n+        :param column: The 0-indexed column number of the symbol\n+        :param new_name: The new name for the symbol\n+        :return: A WorkspaceEdit containing the changes needed to rename the symbol, or None if rename is not supported\n+        \"\"\"\n+        from . import ls_types\n+\n+        params = ls_types.RenameParams(\n+            textDocument=ls_types.TextDocumentIdentifier(\n+                uri=pathlib.Path(os.path.join(self.repository_root_path, relative_file_path)).as_uri()\n+            ),\n+            position=ls_types.Position(line=line, character=column),\n+            newName=new_name,\n+        )\n+\n+        return self.server.send.rename(params)",
        "comment_created_at": "2025-10-14T19:28:30+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Ok, agree. We can later extend the tests and see how an LS which lacks this feature reports the problem",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2432328201",
    "pr_number": 670,
    "pr_file": "test/solidlsp/rego/test_rego_basic.py",
    "created_at": "2025-10-15T12:13:35+00:00",
    "commented_code": "+\"\"\"Tests for Rego language server (Regal) functionality.\"\"\"\n+\n+import os\n+import sys\n+\n+import pytest\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+\n+@pytest.mark.rego\n+@pytest.mark.skipif(\n+    sys.platform == \"win32\", reason=\"Regal LSP has Windows path handling bug - see https://github.com/StyraInc/regal/issues/1683\"\n+)\n+class TestRegoLanguageServer:\n+    \"\"\"Test Regal language server functionality for Rego.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_document_symbols_authz(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that document symbols can be retrieved from authz.rego.\"\"\"\n+        file_path = os.path.join(\"policies\", \"authz.rego\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        assert symbols is not None\n+        assert len(symbols) > 0\n+\n+        # Extract symbol names\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+        symbol_names = {sym.get(\"name\") for sym in symbol_list if isinstance(sym, dict)}\n+\n+        # Verify specific Rego rules/functions are found\n+        assert \"allow\" in symbol_names, \"allow rule not found\"\n+        assert \"allow_read\" in symbol_names, \"allow_read rule not found\"\n+        assert \"is_admin\" in symbol_names, \"is_admin function not found\"\n+        assert \"admin_roles\" in symbol_names, \"admin_roles constant not found\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_document_symbols_helpers(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that document symbols can be retrieved from helpers.rego.\"\"\"\n+        file_path = os.path.join(\"utils\", \"helpers.rego\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        assert symbols is not None\n+        assert len(symbols) > 0\n+\n+        # Extract symbol names\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+        symbol_names = {sym.get(\"name\") for sym in symbol_list if isinstance(sym, dict)}\n+\n+        # Verify specific helper functions are found\n+        assert \"is_valid_user\" in symbol_names, \"is_valid_user function not found\"\n+        assert \"is_valid_email\" in symbol_names, \"is_valid_email function not found\"\n+        assert \"is_valid_username\" in symbol_names, \"is_valid_username function not found\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_find_symbol_full_tree(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding symbols across entire workspace using symbol tree.\"\"\"\n+        symbols = language_server.request_full_symbol_tree()\n+\n+        # Use SymbolUtils to check for expected symbols\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"allow\"), \"allow rule not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"is_valid_user\"), \"is_valid_user function not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"is_admin\"), \"is_admin function not found in symbol tree\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_definition(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test go-to-definition for Rego symbols.\"\"\"\n+        # In authz.rego, the allow rule references helpers.is_valid_user\n+        file_path = os.path.join(\"policies\", \"authz.rego\")\n+\n+        # Get document symbols to find a good position to test\n+        symbols = language_server.request_document_symbols(file_path)\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+\n+        # Find the allow symbol (should reference helpers.is_valid_user)\n+        allow_symbol = next((s for s in symbol_list if s.get(\"name\") == \"allow\"), None)\n+\n+        if allow_symbol and \"range\" in allow_symbol:",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2432328201",
        "repo_full_name": "oraios/serena",
        "pr_number": 670,
        "pr_file": "test/solidlsp/rego/test_rego_basic.py",
        "discussion_id": "2432328201",
        "commented_code": "@@ -0,0 +1,108 @@\n+\"\"\"Tests for Rego language server (Regal) functionality.\"\"\"\n+\n+import os\n+import sys\n+\n+import pytest\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+\n+@pytest.mark.rego\n+@pytest.mark.skipif(\n+    sys.platform == \"win32\", reason=\"Regal LSP has Windows path handling bug - see https://github.com/StyraInc/regal/issues/1683\"\n+)\n+class TestRegoLanguageServer:\n+    \"\"\"Test Regal language server functionality for Rego.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_document_symbols_authz(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that document symbols can be retrieved from authz.rego.\"\"\"\n+        file_path = os.path.join(\"policies\", \"authz.rego\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        assert symbols is not None\n+        assert len(symbols) > 0\n+\n+        # Extract symbol names\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+        symbol_names = {sym.get(\"name\") for sym in symbol_list if isinstance(sym, dict)}\n+\n+        # Verify specific Rego rules/functions are found\n+        assert \"allow\" in symbol_names, \"allow rule not found\"\n+        assert \"allow_read\" in symbol_names, \"allow_read rule not found\"\n+        assert \"is_admin\" in symbol_names, \"is_admin function not found\"\n+        assert \"admin_roles\" in symbol_names, \"admin_roles constant not found\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_document_symbols_helpers(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that document symbols can be retrieved from helpers.rego.\"\"\"\n+        file_path = os.path.join(\"utils\", \"helpers.rego\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        assert symbols is not None\n+        assert len(symbols) > 0\n+\n+        # Extract symbol names\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+        symbol_names = {sym.get(\"name\") for sym in symbol_list if isinstance(sym, dict)}\n+\n+        # Verify specific helper functions are found\n+        assert \"is_valid_user\" in symbol_names, \"is_valid_user function not found\"\n+        assert \"is_valid_email\" in symbol_names, \"is_valid_email function not found\"\n+        assert \"is_valid_username\" in symbol_names, \"is_valid_username function not found\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_find_symbol_full_tree(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding symbols across entire workspace using symbol tree.\"\"\"\n+        symbols = language_server.request_full_symbol_tree()\n+\n+        # Use SymbolUtils to check for expected symbols\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"allow\"), \"allow rule not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"is_valid_user\"), \"is_valid_user function not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"is_admin\"), \"is_admin function not found in symbol tree\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_definition(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test go-to-definition for Rego symbols.\"\"\"\n+        # In authz.rego, the allow rule references helpers.is_valid_user\n+        file_path = os.path.join(\"policies\", \"authz.rego\")\n+\n+        # Get document symbols to find a good position to test\n+        symbols = language_server.request_document_symbols(file_path)\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+\n+        # Find the allow symbol (should reference helpers.is_valid_user)\n+        allow_symbol = next((s for s in symbol_list if s.get(\"name\") == \"allow\"), None)\n+\n+        if allow_symbol and \"range\" in allow_symbol:",
        "comment_created_at": "2025-10-15T12:13:35+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "the condition should be removed, the symbol should always be found. All language servers should support cross-file references and definition finding. Pls also add a test for cross-file reference finding (not just definition)",
        "pr_file_module": null
      },
      {
        "comment_id": "2433424645",
        "repo_full_name": "oraios/serena",
        "pr_number": 670,
        "pr_file": "test/solidlsp/rego/test_rego_basic.py",
        "discussion_id": "2432328201",
        "commented_code": "@@ -0,0 +1,108 @@\n+\"\"\"Tests for Rego language server (Regal) functionality.\"\"\"\n+\n+import os\n+import sys\n+\n+import pytest\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import Language\n+from solidlsp.ls_utils import SymbolUtils\n+\n+\n+@pytest.mark.rego\n+@pytest.mark.skipif(\n+    sys.platform == \"win32\", reason=\"Regal LSP has Windows path handling bug - see https://github.com/StyraInc/regal/issues/1683\"\n+)\n+class TestRegoLanguageServer:\n+    \"\"\"Test Regal language server functionality for Rego.\"\"\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_document_symbols_authz(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that document symbols can be retrieved from authz.rego.\"\"\"\n+        file_path = os.path.join(\"policies\", \"authz.rego\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        assert symbols is not None\n+        assert len(symbols) > 0\n+\n+        # Extract symbol names\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+        symbol_names = {sym.get(\"name\") for sym in symbol_list if isinstance(sym, dict)}\n+\n+        # Verify specific Rego rules/functions are found\n+        assert \"allow\" in symbol_names, \"allow rule not found\"\n+        assert \"allow_read\" in symbol_names, \"allow_read rule not found\"\n+        assert \"is_admin\" in symbol_names, \"is_admin function not found\"\n+        assert \"admin_roles\" in symbol_names, \"admin_roles constant not found\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_document_symbols_helpers(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test that document symbols can be retrieved from helpers.rego.\"\"\"\n+        file_path = os.path.join(\"utils\", \"helpers.rego\")\n+        symbols = language_server.request_document_symbols(file_path)\n+\n+        assert symbols is not None\n+        assert len(symbols) > 0\n+\n+        # Extract symbol names\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+        symbol_names = {sym.get(\"name\") for sym in symbol_list if isinstance(sym, dict)}\n+\n+        # Verify specific helper functions are found\n+        assert \"is_valid_user\" in symbol_names, \"is_valid_user function not found\"\n+        assert \"is_valid_email\" in symbol_names, \"is_valid_email function not found\"\n+        assert \"is_valid_username\" in symbol_names, \"is_valid_username function not found\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_find_symbol_full_tree(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test finding symbols across entire workspace using symbol tree.\"\"\"\n+        symbols = language_server.request_full_symbol_tree()\n+\n+        # Use SymbolUtils to check for expected symbols\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"allow\"), \"allow rule not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"is_valid_user\"), \"is_valid_user function not found in symbol tree\"\n+        assert SymbolUtils.symbol_tree_contains_name(symbols, \"is_admin\"), \"is_admin function not found in symbol tree\"\n+\n+    @pytest.mark.parametrize(\"language_server\", [Language.REGO], indirect=True)\n+    def test_request_definition(self, language_server: SolidLanguageServer) -> None:\n+        \"\"\"Test go-to-definition for Rego symbols.\"\"\"\n+        # In authz.rego, the allow rule references helpers.is_valid_user\n+        file_path = os.path.join(\"policies\", \"authz.rego\")\n+\n+        # Get document symbols to find a good position to test\n+        symbols = language_server.request_document_symbols(file_path)\n+        symbol_list = symbols[0] if isinstance(symbols, tuple) else symbols\n+\n+        # Find the allow symbol (should reference helpers.is_valid_user)\n+        allow_symbol = next((s for s in symbol_list if s.get(\"name\") == \"allow\"), None)\n+\n+        if allow_symbol and \"range\" in allow_symbol:",
        "comment_created_at": "2025-10-15T17:29:35+00:00",
        "comment_author": "antigenius0910",
        "comment_body": "Hi @MischaPanch,\r\n\r\n  Thanks for the feedback! I've addressed both points:\r\n\r\n  1. Removed conditional checks\r\n  The test now uses explicit assertions instead of conditionals. Symbols are always expected to be found:\r\n\r\n```\r\n  allow_symbol = next((s for s in symbol_list if s.get(\"name\") == \"allow\"), None)\r\n  assert allow_symbol is not None, \"allow symbol should always be found in authz.rego\"\r\n  assert \"range\" in allow_symbol, \"allow symbol should have a range\"\r\n```\r\n\r\n  2. Added cross-file definition test\r\n\r\n  I've split the original test into two focused tests:\r\n\r\n  - test_request_definition_within_file: Tests definition finding within the same file (e.g., admin_roles\r\n  reference \u2192 definition)\r\n  - test_request_definition_across_files: Tests cross-file definition finding from policies/authz.rego:11 where\r\n  utils.is_valid_user() is called to utils/helpers.rego:4 where it's defined\r\n\r\n  Note on references vs definitions: Regal LSP v0.36.1 doesn't support textDocument/references (returns -32601\r\n  \"method not supported\"), so the cross-file test uses textDocument/definition instead. This still validates\r\n  that Regal can resolve symbols across files, just in the opposite direction (from usage to definition rather\r\n  than definition to usages).\r\n\r\n  3. Fixed Rego syntax\r\n\r\n  Also updated all test repository files to use the if keyword required by Regal v0.36.1: rule_name if { body }\r\n  instead of the older rule_name { body } syntax.\r\n\r\n  All 6 tests now pass locally. Let me know if there's anything else you'd like me to adjust!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2233930594",
    "pr_number": 369,
    "pr_file": "src/solidlsp/language_servers/common.py",
    "created_at": "2025-07-27T11:51:24+00:00",
    "commented_code": "if dep.url:\n                 self._install_from_url(dep, logger, target_dir)\n             if dep.command:\n-                self._run_command(dep.command, target_dir)\n+                self._run_command(dep.command, logger, target_dir)\n             if dep.binary_name:\n                 results[dep.id] = os.path.join(target_dir, dep.binary_name)\n             else:\n                 results[dep.id] = target_dir\n         return results\n \n     @staticmethod\n-    def _run_command(command: str, cwd: str) -> None:\n+    def _run_command(command: str | list[str], logger: LanguageServerLogger, cwd: str) -> None:\n         kwargs = {}\n         if PlatformUtils.get_platform_id().is_windows():\n             kwargs[\"creationflags\"] = subprocess.CREATE_NO_WINDOW  # type: ignore\n         else:\n             import pwd\n \n             kwargs[\"user\"] = pwd.getpwuid(os.getuid()).pw_name\n-        log.info(\"Running command '%s' in '%s'\", command, cwd)\n-        completed_process = subprocess.run(\n-            command,\n-            shell=True,\n-            check=True,\n-            cwd=cwd,\n-            stdout=subprocess.PIPE,\n-            stderr=subprocess.STDOUT,\n-            **kwargs,\n-        )\n-        if completed_process.returncode != 0:\n-            log.warning(\"Command '%s' failed with return code %d\", command, completed_process.returncode)\n-            log.warning(\"Command output:\n%s\", completed_process.stdout)\n+\n+        if isinstance(command, list):\n+            command_parts = command",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2233930594",
        "repo_full_name": "oraios/serena",
        "pr_number": 369,
        "pr_file": "src/solidlsp/language_servers/common.py",
        "discussion_id": "2233930594",
        "commented_code": "@@ -63,39 +63,57 @@ def install(self, logger: LanguageServerLogger, target_dir: str) -> dict[str, st\n             if dep.url:\n                 self._install_from_url(dep, logger, target_dir)\n             if dep.command:\n-                self._run_command(dep.command, target_dir)\n+                self._run_command(dep.command, logger, target_dir)\n             if dep.binary_name:\n                 results[dep.id] = os.path.join(target_dir, dep.binary_name)\n             else:\n                 results[dep.id] = target_dir\n         return results\n \n     @staticmethod\n-    def _run_command(command: str, cwd: str) -> None:\n+    def _run_command(command: str | list[str], logger: LanguageServerLogger, cwd: str) -> None:\n         kwargs = {}\n         if PlatformUtils.get_platform_id().is_windows():\n             kwargs[\"creationflags\"] = subprocess.CREATE_NO_WINDOW  # type: ignore\n         else:\n             import pwd\n \n             kwargs[\"user\"] = pwd.getpwuid(os.getuid()).pw_name\n-        log.info(\"Running command '%s' in '%s'\", command, cwd)\n-        completed_process = subprocess.run(\n-            command,\n-            shell=True,\n-            check=True,\n-            cwd=cwd,\n-            stdout=subprocess.PIPE,\n-            stderr=subprocess.STDOUT,\n-            **kwargs,\n-        )\n-        if completed_process.returncode != 0:\n-            log.warning(\"Command '%s' failed with return code %d\", command, completed_process.returncode)\n-            log.warning(\"Command output:\\n%s\", completed_process.stdout)\n+\n+        if isinstance(command, list):\n+            command_parts = command",
        "comment_created_at": "2025-07-27T11:51:24+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "let's keep simple interfaces. If you need a list for solving this issue, the interface should be changed to `command: list[str]` and the callers should be responsible for creating the list.",
        "pr_file_module": null
      },
      {
        "comment_id": "2234152035",
        "repo_full_name": "oraios/serena",
        "pr_number": 369,
        "pr_file": "src/solidlsp/language_servers/common.py",
        "discussion_id": "2233930594",
        "commented_code": "@@ -63,39 +63,57 @@ def install(self, logger: LanguageServerLogger, target_dir: str) -> dict[str, st\n             if dep.url:\n                 self._install_from_url(dep, logger, target_dir)\n             if dep.command:\n-                self._run_command(dep.command, target_dir)\n+                self._run_command(dep.command, logger, target_dir)\n             if dep.binary_name:\n                 results[dep.id] = os.path.join(target_dir, dep.binary_name)\n             else:\n                 results[dep.id] = target_dir\n         return results\n \n     @staticmethod\n-    def _run_command(command: str, cwd: str) -> None:\n+    def _run_command(command: str | list[str], logger: LanguageServerLogger, cwd: str) -> None:\n         kwargs = {}\n         if PlatformUtils.get_platform_id().is_windows():\n             kwargs[\"creationflags\"] = subprocess.CREATE_NO_WINDOW  # type: ignore\n         else:\n             import pwd\n \n             kwargs[\"user\"] = pwd.getpwuid(os.getuid()).pw_name\n-        log.info(\"Running command '%s' in '%s'\", command, cwd)\n-        completed_process = subprocess.run(\n-            command,\n-            shell=True,\n-            check=True,\n-            cwd=cwd,\n-            stdout=subprocess.PIPE,\n-            stderr=subprocess.STDOUT,\n-            **kwargs,\n-        )\n-        if completed_process.returncode != 0:\n-            log.warning(\"Command '%s' failed with return code %d\", command, completed_process.returncode)\n-            log.warning(\"Command output:\\n%s\", completed_process.stdout)\n+\n+        if isinstance(command, list):\n+            command_parts = command",
        "comment_created_at": "2025-07-27T22:16:30+00:00",
        "comment_author": "auric",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  }
]