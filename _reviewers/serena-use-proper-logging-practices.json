[
  {
    "discussion_id": "2439359917",
    "pr_number": 682,
    "pr_file": "src/solidlsp/ls_utils.py",
    "created_at": "2025-10-17T11:02:41+00:00",
    "commented_code": "logger.log(f\"File read '{file_path}' failed: File does not exist.\", logging.ERROR)\n             raise SolidLSPException(f\"File read '{file_path}' failed: File does not exist.\")\n         try:\n-            with open(file_path, encoding=encoding) as inp_file:\n-                return inp_file.read()\n+            try:\n+                with open(file_path, encoding=encoding) as inp_file:\n+                    return inp_file.read()\n+            except UnicodeDecodeError as ude:\n+                results = from_path(file_path)\n+                match = results.best()\n+                if match:\n+                    return match.raw.decode(match.encoding)",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2439359917",
        "repo_full_name": "oraios/serena",
        "pr_number": 682,
        "pr_file": "src/solidlsp/ls_utils.py",
        "discussion_id": "2439359917",
        "commented_code": "@@ -173,8 +174,15 @@ def read_file(logger: LanguageServerLogger, file_path: str, encoding: str) -> st\n             logger.log(f\"File read '{file_path}' failed: File does not exist.\", logging.ERROR)\n             raise SolidLSPException(f\"File read '{file_path}' failed: File does not exist.\")\n         try:\n-            with open(file_path, encoding=encoding) as inp_file:\n-                return inp_file.read()\n+            try:\n+                with open(file_path, encoding=encoding) as inp_file:\n+                    return inp_file.read()\n+            except UnicodeDecodeError as ude:\n+                results = from_path(file_path)\n+                match = results.best()\n+                if match:\n+                    return match.raw.decode(match.encoding)",
        "comment_created_at": "2025-10-17T11:02:41+00:00",
        "comment_author": "opcode81",
        "comment_body": "Let's log a warning here, e.g.\r\n\r\n    log.warning(f\"Could not decode {file_path} with encoding='{encoding}'; using best match '{match.encoding}' instead\")\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2035812712",
    "pr_number": 45,
    "pr_file": "src/serena/text_utils.py",
    "created_at": "2025-04-09T17:22:51+00:00",
    "commented_code": "matches.append(MatchedConsecutiveLines(lines=context_lines, source_file_path=source_file_path))\n \n     return matches\n+\n+\n+def default_content_reader(file_path: str) -> str:\n+    with open(file_path) as f:\n+        return f.read()\n+\n+\n+def search_files(\n+    file_paths: list[str],\n+    pattern: re.Pattern | str,\n+    content_reader: Callable[[str], str] = default_content_reader,\n+    context_lines_before: int = 0,\n+    context_lines_after: int = 0,\n+    paths_include_glob: str | None = None,\n+    paths_exclude_glob: str | None = None,\n+) -> list[MatchedConsecutiveLines]:\n+    matches = []\n+    for path in file_paths:\n+        # TODO: fnmatch is not exactly the same as glob\n+        if paths_include_glob and not fnmatch(path, paths_include_glob):\n+            log.debug(f\"Skipping {path}: does not match include pattern {paths_include_glob}\")\n+            continue\n+\n+        if paths_exclude_glob and fnmatch(path, paths_exclude_glob):\n+            log.debug(f\"Skipping {path}: matches exclude pattern {paths_exclude_glob}\")\n+            continue\n+        try:\n+            file_content = content_reader(path)\n+        except Exception as e:",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2035812712",
        "repo_full_name": "oraios/serena",
        "pr_number": 45,
        "pr_file": "src/serena/text_utils.py",
        "discussion_id": "2035812712",
        "commented_code": "@@ -205,3 +210,48 @@ def search_text(\n                 matches.append(MatchedConsecutiveLines(lines=context_lines, source_file_path=source_file_path))\n \n     return matches\n+\n+\n+def default_content_reader(file_path: str) -> str:\n+    with open(file_path) as f:\n+        return f.read()\n+\n+\n+def search_files(\n+    file_paths: list[str],\n+    pattern: re.Pattern | str,\n+    content_reader: Callable[[str], str] = default_content_reader,\n+    context_lines_before: int = 0,\n+    context_lines_after: int = 0,\n+    paths_include_glob: str | None = None,\n+    paths_exclude_glob: str | None = None,\n+) -> list[MatchedConsecutiveLines]:\n+    matches = []\n+    for path in file_paths:\n+        # TODO: fnmatch is not exactly the same as glob\n+        if paths_include_glob and not fnmatch(path, paths_include_glob):\n+            log.debug(f\"Skipping {path}: does not match include pattern {paths_include_glob}\")\n+            continue\n+\n+        if paths_exclude_glob and fnmatch(path, paths_exclude_glob):\n+            log.debug(f\"Skipping {path}: matches exclude pattern {paths_exclude_glob}\")\n+            continue\n+        try:\n+            file_content = content_reader(path)\n+        except Exception as e:",
        "comment_created_at": "2025-04-09T17:22:51+00:00",
        "comment_author": "opcode81",
        "comment_body": "This probably triggers for most binary files, as they will contain character combinations that are not valid in utf-8.\r\nIs this intentional? I believe it will spam the log too much.",
        "pr_file_module": null
      },
      {
        "comment_id": "2038005457",
        "repo_full_name": "oraios/serena",
        "pr_number": 45,
        "pr_file": "src/serena/text_utils.py",
        "discussion_id": "2035812712",
        "commented_code": "@@ -205,3 +210,48 @@ def search_text(\n                 matches.append(MatchedConsecutiveLines(lines=context_lines, source_file_path=source_file_path))\n \n     return matches\n+\n+\n+def default_content_reader(file_path: str) -> str:\n+    with open(file_path) as f:\n+        return f.read()\n+\n+\n+def search_files(\n+    file_paths: list[str],\n+    pattern: re.Pattern | str,\n+    content_reader: Callable[[str], str] = default_content_reader,\n+    context_lines_before: int = 0,\n+    context_lines_after: int = 0,\n+    paths_include_glob: str | None = None,\n+    paths_exclude_glob: str | None = None,\n+) -> list[MatchedConsecutiveLines]:\n+    matches = []\n+    for path in file_paths:\n+        # TODO: fnmatch is not exactly the same as glob\n+        if paths_include_glob and not fnmatch(path, paths_include_glob):\n+            log.debug(f\"Skipping {path}: does not match include pattern {paths_include_glob}\")\n+            continue\n+\n+        if paths_exclude_glob and fnmatch(path, paths_exclude_glob):\n+            log.debug(f\"Skipping {path}: matches exclude pattern {paths_exclude_glob}\")\n+            continue\n+        try:\n+            file_content = content_reader(path)\n+        except Exception as e:",
        "comment_created_at": "2025-04-10T18:20:41+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "I now make a single log with all skipped files on debug level at the end of the execution",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180050641",
    "pr_number": 261,
    "pr_file": "test/solidlsp/elixir/conftest.py",
    "created_at": "2025-07-02T13:20:12+00:00",
    "commented_code": "+\"\"\"\n+Elixir-specific test configuration and fixtures.\n+\"\"\"\n+import os\n+import subprocess\n+import pytest\n+import time\n+from pathlib import Path\n+\n+\n+def ensure_elixir_test_repo_compiled(repo_path: str) -> None:\n+    \"\"\"Ensure the Elixir test repository dependencies are installed and project is compiled.\n+    \n+    Next LS requires the project to be fully compiled and indexed before providing\n+    complete references and symbol resolution. This function:\n+    1. Installs dependencies via 'mix deps.get'\n+    2. Compiles the project via 'mix compile'\n+    \n+    This is essential in CI environments where dependencies aren't pre-installed.\n+    \n+    Args:\n+        repo_path: Path to the Elixir project root directory\n+    \"\"\"\n+    # Check if this looks like an Elixir project\n+    mix_file = os.path.join(repo_path, \"mix.exs\")\n+    if not os.path.exists(mix_file):\n+        return\n+    \n+    # Check if already compiled (optimization for repeated runs)\n+    build_path = os.path.join(repo_path, \"_build\")\n+    deps_path = os.path.join(repo_path, \"deps\")\n+    \n+    if os.path.exists(build_path) and os.path.exists(deps_path):\n+        print(f\"Elixir test repository already compiled in {repo_path}\")\n+        return\n+        \n+    try:\n+        print(f\"Installing dependencies and compiling Elixir test repository for optimal Next LS performance...\")",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2180050641",
        "repo_full_name": "oraios/serena",
        "pr_number": 261,
        "pr_file": "test/solidlsp/elixir/conftest.py",
        "discussion_id": "2180050641",
        "commented_code": "@@ -0,0 +1,169 @@\n+\"\"\"\n+Elixir-specific test configuration and fixtures.\n+\"\"\"\n+import os\n+import subprocess\n+import pytest\n+import time\n+from pathlib import Path\n+\n+\n+def ensure_elixir_test_repo_compiled(repo_path: str) -> None:\n+    \"\"\"Ensure the Elixir test repository dependencies are installed and project is compiled.\n+    \n+    Next LS requires the project to be fully compiled and indexed before providing\n+    complete references and symbol resolution. This function:\n+    1. Installs dependencies via 'mix deps.get'\n+    2. Compiles the project via 'mix compile'\n+    \n+    This is essential in CI environments where dependencies aren't pre-installed.\n+    \n+    Args:\n+        repo_path: Path to the Elixir project root directory\n+    \"\"\"\n+    # Check if this looks like an Elixir project\n+    mix_file = os.path.join(repo_path, \"mix.exs\")\n+    if not os.path.exists(mix_file):\n+        return\n+    \n+    # Check if already compiled (optimization for repeated runs)\n+    build_path = os.path.join(repo_path, \"_build\")\n+    deps_path = os.path.join(repo_path, \"deps\")\n+    \n+    if os.path.exists(build_path) and os.path.exists(deps_path):\n+        print(f\"Elixir test repository already compiled in {repo_path}\")\n+        return\n+        \n+    try:\n+        print(f\"Installing dependencies and compiling Elixir test repository for optimal Next LS performance...\")",
        "comment_created_at": "2025-07-02T13:20:12+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "not sure we should have prints in tests or rather use logging, @opcode81 wdyt?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2187782660",
    "pr_number": 277,
    "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
    "created_at": "2025-07-05T22:15:10+00:00",
    "commented_code": "+import json\n+import logging\n+import os\n+import pathlib\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version():\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        import os\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform version detection...\")",
    "repo_full_name": "oraios/serena",
    "discussion_comments": [
      {
        "comment_id": "2187782660",
        "repo_full_name": "oraios/serena",
        "pr_number": 277,
        "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
        "discussion_id": "2187782660",
        "commented_code": "@@ -0,0 +1,260 @@\n+import json\n+import logging\n+import os\n+import pathlib\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version():\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        import os\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform version detection...\")",
        "comment_created_at": "2025-07-05T22:15:10+00:00",
        "comment_author": "MischaPanch",
        "comment_body": "Pls replace all prints by logs. Printing in Serena is strictly forbidden anywhere, it contaminates the stdio buffer and the MCP server stops working",
        "pr_file_module": null
      },
      {
        "comment_id": "2187891587",
        "repo_full_name": "oraios/serena",
        "pr_number": 277,
        "pr_file": "src/solidlsp/language_servers/terraform_ls/terraform_ls.py",
        "discussion_id": "2187782660",
        "commented_code": "@@ -0,0 +1,260 @@\n+import json\n+import logging\n+import os\n+import pathlib\n+import subprocess\n+import threading\n+\n+from overrides import override\n+\n+from solidlsp.ls import SolidLanguageServer\n+from solidlsp.ls_config import LanguageServerConfig\n+from solidlsp.ls_logger import LanguageServerLogger\n+from solidlsp.lsp_protocol_handler.lsp_types import InitializeParams\n+from solidlsp.lsp_protocol_handler.server import ProcessLaunchInfo\n+\n+\n+class TerraformLS(SolidLanguageServer):\n+    \"\"\"\n+    Provides Terraform specific instantiation of the LanguageServer class using terraform-ls.\n+    \"\"\"\n+\n+    @override\n+    def is_ignored_dirname(self, dirname: str) -> bool:\n+        # For Terraform projects, we should ignore:\n+        # - .terraform: Terraform working directory with providers and modules\n+        # - terraform.tfstate.d: Terraform workspace state directories\n+        # - .git: Version control\n+        # - node_modules: If the project has JavaScript components\n+        return super().is_ignored_dirname(dirname) or dirname in [\".terraform\", \"terraform.tfstate.d\", \"node_modules\"]\n+\n+    @staticmethod\n+    def _get_terraform_version():\n+        \"\"\"Get the installed Terraform version or None if not found.\"\"\"\n+        import os\n+        import shutil\n+        \n+        print(\"DEBUG: Starting terraform version detection...\")",
        "comment_created_at": "2025-07-06T02:08:56+00:00",
        "comment_author": "antigenius0910",
        "comment_body": "Roger that. proceed changing to logger ",
        "pr_file_module": null
      }
    ]
  }
]