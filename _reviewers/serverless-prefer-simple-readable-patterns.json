[
  {
    "discussion_id": "562421778",
    "pr_number": 8788,
    "pr_file": "lib/plugins/interactiveCli/initializeService.js",
    "created_at": "2021-01-22T06:51:30+00:00",
    "commented_code": "\"   - Shouldn't exceed 128 characters\"\n           );\n         }\n-        if (await fse.exists(join(workingDir, input))) return `Path ${input} is already taken`;\n-        return true;\n+\n+        try {\n+          await fs.promises.access(join(workingDir, input));\n+          return `Path ${input} is already taken`;\n+        } catch {\n+          return true;\n+        }",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "562421778",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8788,
        "pr_file": "lib/plugins/interactiveCli/initializeService.js",
        "discussion_id": "562421778",
        "commented_code": "@@ -43,8 +43,13 @@ const projectNameInput = async (workingDir) =>\n             \"   - Shouldn't exceed 128 characters\"\n           );\n         }\n-        if (await fse.exists(join(workingDir, input))) return `Path ${input} is already taken`;\n-        return true;\n+\n+        try {\n+          await fs.promises.access(join(workingDir, input));\n+          return `Path ${input} is already taken`;\n+        } catch {\n+          return true;\n+        }",
        "comment_created_at": "2021-01-22T06:51:30+00:00",
        "comment_author": "sdas13",
        "comment_body": "Hey @medikoo, these statements can also be written like this\r\n`fs.promises.access(join(workingDir, input))\r\n      .then(() => Path ${input} is already taken)\r\n      .catch(() => true)`\r\nWhich one do you prefer?      \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "562584953",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8788,
        "pr_file": "lib/plugins/interactiveCli/initializeService.js",
        "discussion_id": "562421778",
        "commented_code": "@@ -43,8 +43,13 @@ const projectNameInput = async (workingDir) =>\n             \"   - Shouldn't exceed 128 characters\"\n           );\n         }\n-        if (await fse.exists(join(workingDir, input))) return `Path ${input} is already taken`;\n-        return true;\n+\n+        try {\n+          await fs.promises.access(join(workingDir, input));\n+          return `Path ${input} is already taken`;\n+        } catch {\n+          return true;\n+        }",
        "comment_created_at": "2021-01-22T12:00:26+00:00",
        "comment_author": "medikoo",
        "comment_body": "@sdas13 we definitely should stick to async/await syntax. It's way more readable and maintanable",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "446030681",
    "pr_number": 7881,
    "pr_file": "lib/plugins/aws/package/compile/events/apiGateway/lib/hack/updateStage.js",
    "created_at": "2020-06-26T08:02:40+00:00",
    "commented_code": "if (apiGatewayResourcesIds.length !== 1) return null;\n   const apiGatewayResourceId = apiGatewayResourcesIds[0];\n   if (\n-    !_.findKey(resources, resource => {\n+    !Object.keys(resources).find(key => {",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "446030681",
        "repo_full_name": "serverless/serverless",
        "pr_number": 7881,
        "pr_file": "lib/plugins/aws/package/compile/events/apiGateway/lib/hack/updateStage.js",
        "discussion_id": "446030681",
        "commented_code": "@@ -118,7 +118,8 @@ function resolveApiGatewayResource(resources) {\n   if (apiGatewayResourcesIds.length !== 1) return null;\n   const apiGatewayResourceId = apiGatewayResourcesIds[0];\n   if (\n-    !_.findKey(resources, resource => {\n+    !Object.keys(resources).find(key => {",
        "comment_created_at": "2020-06-26T08:02:40+00:00",
        "comment_author": "medikoo",
        "comment_body": "I think more natural would be to use `some` here (`find` is good when we're interested in _key_ value, and not just fact that it matches some conditions)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "446034767",
    "pr_number": 7881,
    "pr_file": "lib/plugins/aws/package/compile/layers/index.test.js",
    "created_at": "2020-06-26T08:11:28+00:00",
    "commented_code": "return expect(\n         Promise.all([awsCompileLayers.compileLayers(), secondAwsCompileLayers.compileLayers()])\n       ).to.be.fulfilled.then(() => {\n+        const resources =\n+          awsCompileLayers.serverless.service.provider.compiledCloudFormationTemplate.Resources;\n+        const secondResources =\n+          secondAwsCompileLayers.serverless.service.provider.compiledCloudFormationTemplate\n+            .Resources;\n         expect(\n-          _.findKey(\n-            awsCompileLayers.serverless.service.provider.compiledCloudFormationTemplate.Resources,\n-            r => r.Type === 'AWS::Lambda::LayerVersion'\n-          )\n+          Object.keys(resources).find(key => {\n+            const r = resources[key];\n+            return r.Type === 'AWS::Lambda::LayerVersion';",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "446034767",
        "repo_full_name": "serverless/serverless",
        "pr_number": 7881,
        "pr_file": "lib/plugins/aws/package/compile/layers/index.test.js",
        "discussion_id": "446034767",
        "commented_code": "@@ -223,17 +223,21 @@ describe('AwsCompileLayers', () => {\n       return expect(\n         Promise.all([awsCompileLayers.compileLayers(), secondAwsCompileLayers.compileLayers()])\n       ).to.be.fulfilled.then(() => {\n+        const resources =\n+          awsCompileLayers.serverless.service.provider.compiledCloudFormationTemplate.Resources;\n+        const secondResources =\n+          secondAwsCompileLayers.serverless.service.provider.compiledCloudFormationTemplate\n+            .Resources;\n         expect(\n-          _.findKey(\n-            awsCompileLayers.serverless.service.provider.compiledCloudFormationTemplate.Resources,\n-            r => r.Type === 'AWS::Lambda::LayerVersion'\n-          )\n+          Object.keys(resources).find(key => {\n+            const r = resources[key];\n+            return r.Type === 'AWS::Lambda::LayerVersion';",
        "comment_created_at": "2020-06-26T08:11:28+00:00",
        "comment_author": "medikoo",
        "comment_body": "Le'ts just write it as `return resources[key].Type === 'AWS::Lambda::LayerVersion'`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "560928216",
    "pr_number": 8790,
    "pr_file": "lib/plugins/aws/package/compile/events/httpApi.js",
    "created_at": "2021-01-20T12:38:29+00:00",
    "commented_code": "const userAuthorizers = userConfig.authorizers;\n       const authorizers = (this.config.authorizers = new Map());\n       if (userAuthorizers) {\n+        if (typeof userAuthorizers !== 'object') {\n+          throw new this.serverless.classes.Error(\n+            'serverless.yaml is malformed at provider httpApi authorizers - should be an object with names as keys',\n+            'MALFORMED_YAML'\n+          );\n+        }\n         if (userConfig.id) {\n           throw new this.serverless.classes.Error(\n             'Cannot setup authorizers for externally configured HTTP API',\n             'EXTERNAL_HTTP_API_AUTHORIZERS_CONFIG'\n           );\n         }\n         for (const [name, authorizerConfig] of Object.entries(userAuthorizers)) {\n+          // todo uncomment code when authorizer type is supported",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "560928216",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8790,
        "pr_file": "lib/plugins/aws/package/compile/events/httpApi.js",
        "discussion_id": "560928216",
        "commented_code": "@@ -274,15 +274,39 @@ Object.defineProperties(\n       const userAuthorizers = userConfig.authorizers;\n       const authorizers = (this.config.authorizers = new Map());\n       if (userAuthorizers) {\n+        if (typeof userAuthorizers !== 'object') {\n+          throw new this.serverless.classes.Error(\n+            'serverless.yaml is malformed at provider httpApi authorizers - should be an object with names as keys',\n+            'MALFORMED_YAML'\n+          );\n+        }\n         if (userConfig.id) {\n           throw new this.serverless.classes.Error(\n             'Cannot setup authorizers for externally configured HTTP API',\n             'EXTERNAL_HTTP_API_AUTHORIZERS_CONFIG'\n           );\n         }\n         for (const [name, authorizerConfig] of Object.entries(userAuthorizers)) {\n+          // todo uncomment code when authorizer type is supported",
        "comment_created_at": "2021-01-20T12:38:29+00:00",
        "comment_author": "pgrzesik",
        "comment_body": "We usually don't add such commented code and I think it would be better to remove it here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "730803077",
    "pr_number": 10067,
    "pr_file": "lib/plugins/aws/package/lib/resolveIamRoles.js",
    "created_at": "2021-10-18T10:55:13+00:00",
    "commented_code": "+'use strict';\n+\n+const _ = require('lodash');\n+const deepSortObjectByKey = require('../../../../utils/deepSortObjectByKey');\n+\n+module.exports = {\n+  resolveIamRoles() {\n+    const iamRoleLambdaExecution =\n+      this.serverless.service.provider.compiledCloudFormationTemplate.Resources[\n+        this.provider.naming.getRoleLogicalId()\n+      ];\n+\n+    if (!iamRoleLambdaExecution) {\n+      return;\n+    }\n+\n+    const context = { iamRoleLambdaExecution };\n+\n+    this.resolveServicePrincipals(context);\n+    this.resolveStatements(context);\n+    this.pushManagedPolicies(context);\n+  },\n+\n+  resolveServicePrincipals({ iamRoleLambdaExecution }) {\n+    const lambdaAssumeStatement =\n+      iamRoleLambdaExecution.Properties.AssumeRolePolicyDocument.Statement.find((statement) =>\n+        statement.Principal.Service.includes('lambda.amazonaws.com')\n+      );\n+\n+    lambdaAssumeStatement.Principal.Service = Array.from(\n+      new Set([\n+        ...lambdaAssumeStatement.Principal.Service,\n+        ...this.provider.iamConfig.servicePrincipals,\n+        ..._.flatten(\n+          Object.values(this.serverless.service.functions).map(({ iamConfig }) => [\n+            ...iamConfig.servicePrincipals,\n+          ])\n+        ),\n+      ])\n+    );\n+  },\n+\n+  resolveStatements({ iamRoleLambdaExecution }) {\n+    const statements = [\n+      ...iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement,\n+      ...this.provider.iamConfig.policyStatements,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.policyStatements\n+        )\n+      ),\n+    ];\n+\n+    iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement = this.mergeStatements(\n+      _.uniqWith(statements, _.isEqual)\n+    );\n+  },\n+\n+  pushManagedPolicies({ iamRoleLambdaExecution }) {\n+    const managedPolicies = [\n+      ...(iamRoleLambdaExecution.Properties.ManagedPolicyArns || []),\n+      ...this.provider.iamConfig.managedPolicies,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.managedPolicies\n+        )\n+      ),\n+    ];\n+\n+    if (!managedPolicies.length) return;\n+\n+    iamRoleLambdaExecution.Properties.ManagedPolicyArns = _.uniqWith(managedPolicies, _.isEqual);\n+  },\n+\n+  mergeStatements(statements) {\n+    const groups = _.groupBy(statements, (statement) => {\n+      const { Resource, ...keySegments } = statement; // eslint-disable-line",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "730803077",
        "repo_full_name": "serverless/serverless",
        "pr_number": 10067,
        "pr_file": "lib/plugins/aws/package/lib/resolveIamRoles.js",
        "discussion_id": "730803077",
        "commented_code": "@@ -0,0 +1,107 @@\n+'use strict';\n+\n+const _ = require('lodash');\n+const deepSortObjectByKey = require('../../../../utils/deepSortObjectByKey');\n+\n+module.exports = {\n+  resolveIamRoles() {\n+    const iamRoleLambdaExecution =\n+      this.serverless.service.provider.compiledCloudFormationTemplate.Resources[\n+        this.provider.naming.getRoleLogicalId()\n+      ];\n+\n+    if (!iamRoleLambdaExecution) {\n+      return;\n+    }\n+\n+    const context = { iamRoleLambdaExecution };\n+\n+    this.resolveServicePrincipals(context);\n+    this.resolveStatements(context);\n+    this.pushManagedPolicies(context);\n+  },\n+\n+  resolveServicePrincipals({ iamRoleLambdaExecution }) {\n+    const lambdaAssumeStatement =\n+      iamRoleLambdaExecution.Properties.AssumeRolePolicyDocument.Statement.find((statement) =>\n+        statement.Principal.Service.includes('lambda.amazonaws.com')\n+      );\n+\n+    lambdaAssumeStatement.Principal.Service = Array.from(\n+      new Set([\n+        ...lambdaAssumeStatement.Principal.Service,\n+        ...this.provider.iamConfig.servicePrincipals,\n+        ..._.flatten(\n+          Object.values(this.serverless.service.functions).map(({ iamConfig }) => [\n+            ...iamConfig.servicePrincipals,\n+          ])\n+        ),\n+      ])\n+    );\n+  },\n+\n+  resolveStatements({ iamRoleLambdaExecution }) {\n+    const statements = [\n+      ...iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement,\n+      ...this.provider.iamConfig.policyStatements,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.policyStatements\n+        )\n+      ),\n+    ];\n+\n+    iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement = this.mergeStatements(\n+      _.uniqWith(statements, _.isEqual)\n+    );\n+  },\n+\n+  pushManagedPolicies({ iamRoleLambdaExecution }) {\n+    const managedPolicies = [\n+      ...(iamRoleLambdaExecution.Properties.ManagedPolicyArns || []),\n+      ...this.provider.iamConfig.managedPolicies,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.managedPolicies\n+        )\n+      ),\n+    ];\n+\n+    if (!managedPolicies.length) return;\n+\n+    iamRoleLambdaExecution.Properties.ManagedPolicyArns = _.uniqWith(managedPolicies, _.isEqual);\n+  },\n+\n+  mergeStatements(statements) {\n+    const groups = _.groupBy(statements, (statement) => {\n+      const { Resource, ...keySegments } = statement; // eslint-disable-line",
        "comment_created_at": "2021-10-18T10:55:13+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's remove `eslint-disable` comment (ensure to construct logic in away, so we don't have to disable linter)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "730815329",
    "pr_number": 10067,
    "pr_file": "lib/plugins/aws/package/lib/resolveIamRoles.js",
    "created_at": "2021-10-18T11:13:05+00:00",
    "commented_code": "+'use strict';\n+\n+const _ = require('lodash');\n+const deepSortObjectByKey = require('../../../../utils/deepSortObjectByKey');\n+\n+module.exports = {\n+  resolveIamRoles() {\n+    const iamRoleLambdaExecution =\n+      this.serverless.service.provider.compiledCloudFormationTemplate.Resources[\n+        this.provider.naming.getRoleLogicalId()\n+      ];\n+\n+    if (!iamRoleLambdaExecution) {\n+      return;\n+    }\n+\n+    const context = { iamRoleLambdaExecution };\n+\n+    this.resolveServicePrincipals(context);\n+    this.resolveStatements(context);\n+    this.pushManagedPolicies(context);\n+  },\n+\n+  resolveServicePrincipals({ iamRoleLambdaExecution }) {\n+    const lambdaAssumeStatement =\n+      iamRoleLambdaExecution.Properties.AssumeRolePolicyDocument.Statement.find((statement) =>\n+        statement.Principal.Service.includes('lambda.amazonaws.com')\n+      );\n+\n+    lambdaAssumeStatement.Principal.Service = Array.from(\n+      new Set([\n+        ...lambdaAssumeStatement.Principal.Service,\n+        ...this.provider.iamConfig.servicePrincipals,\n+        ..._.flatten(\n+          Object.values(this.serverless.service.functions).map(({ iamConfig }) => [\n+            ...iamConfig.servicePrincipals,\n+          ])\n+        ),\n+      ])\n+    );\n+  },\n+\n+  resolveStatements({ iamRoleLambdaExecution }) {\n+    const statements = [\n+      ...iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement,\n+      ...this.provider.iamConfig.policyStatements,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.policyStatements\n+        )\n+      ),\n+    ];\n+\n+    iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement = this.mergeStatements(\n+      _.uniqWith(statements, _.isEqual)\n+    );\n+  },\n+\n+  pushManagedPolicies({ iamRoleLambdaExecution }) {\n+    const managedPolicies = [\n+      ...(iamRoleLambdaExecution.Properties.ManagedPolicyArns || []),\n+      ...this.provider.iamConfig.managedPolicies,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.managedPolicies\n+        )\n+      ),\n+    ];\n+\n+    if (!managedPolicies.length) return;\n+\n+    iamRoleLambdaExecution.Properties.ManagedPolicyArns = _.uniqWith(managedPolicies, _.isEqual);\n+  },\n+\n+  mergeStatements(statements) {\n+    const groups = _.groupBy(statements, (statement) => {\n+      const { Resource, ...keySegments } = statement; // eslint-disable-line\n+      const sortedKeySegments = deepSortObjectByKey(keySegments);\n+      Object.values(sortedKeySegments).forEach((keySegement) => {\n+        if (Array.isArray(keySegement)) {\n+          keySegement.sort();\n+        }\n+      });\n+      return JSON.stringify(sortedKeySegments);\n+    });\n+\n+    const merged = [];\n+\n+    Object.values(groups).forEach((statements_) => {\n+      const resources = statements_.reduce((acc, { Resource: resource }) => {\n+        if (!resource) {\n+          return acc;\n+        }\n+        return acc.concat(Array.isArray(resource) ? resource : [resource]);\n+      }, []);",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "730815329",
        "repo_full_name": "serverless/serverless",
        "pr_number": 10067,
        "pr_file": "lib/plugins/aws/package/lib/resolveIamRoles.js",
        "discussion_id": "730815329",
        "commented_code": "@@ -0,0 +1,107 @@\n+'use strict';\n+\n+const _ = require('lodash');\n+const deepSortObjectByKey = require('../../../../utils/deepSortObjectByKey');\n+\n+module.exports = {\n+  resolveIamRoles() {\n+    const iamRoleLambdaExecution =\n+      this.serverless.service.provider.compiledCloudFormationTemplate.Resources[\n+        this.provider.naming.getRoleLogicalId()\n+      ];\n+\n+    if (!iamRoleLambdaExecution) {\n+      return;\n+    }\n+\n+    const context = { iamRoleLambdaExecution };\n+\n+    this.resolveServicePrincipals(context);\n+    this.resolveStatements(context);\n+    this.pushManagedPolicies(context);\n+  },\n+\n+  resolveServicePrincipals({ iamRoleLambdaExecution }) {\n+    const lambdaAssumeStatement =\n+      iamRoleLambdaExecution.Properties.AssumeRolePolicyDocument.Statement.find((statement) =>\n+        statement.Principal.Service.includes('lambda.amazonaws.com')\n+      );\n+\n+    lambdaAssumeStatement.Principal.Service = Array.from(\n+      new Set([\n+        ...lambdaAssumeStatement.Principal.Service,\n+        ...this.provider.iamConfig.servicePrincipals,\n+        ..._.flatten(\n+          Object.values(this.serverless.service.functions).map(({ iamConfig }) => [\n+            ...iamConfig.servicePrincipals,\n+          ])\n+        ),\n+      ])\n+    );\n+  },\n+\n+  resolveStatements({ iamRoleLambdaExecution }) {\n+    const statements = [\n+      ...iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement,\n+      ...this.provider.iamConfig.policyStatements,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.policyStatements\n+        )\n+      ),\n+    ];\n+\n+    iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement = this.mergeStatements(\n+      _.uniqWith(statements, _.isEqual)\n+    );\n+  },\n+\n+  pushManagedPolicies({ iamRoleLambdaExecution }) {\n+    const managedPolicies = [\n+      ...(iamRoleLambdaExecution.Properties.ManagedPolicyArns || []),\n+      ...this.provider.iamConfig.managedPolicies,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.managedPolicies\n+        )\n+      ),\n+    ];\n+\n+    if (!managedPolicies.length) return;\n+\n+    iamRoleLambdaExecution.Properties.ManagedPolicyArns = _.uniqWith(managedPolicies, _.isEqual);\n+  },\n+\n+  mergeStatements(statements) {\n+    const groups = _.groupBy(statements, (statement) => {\n+      const { Resource, ...keySegments } = statement; // eslint-disable-line\n+      const sortedKeySegments = deepSortObjectByKey(keySegments);\n+      Object.values(sortedKeySegments).forEach((keySegement) => {\n+        if (Array.isArray(keySegement)) {\n+          keySegement.sort();\n+        }\n+      });\n+      return JSON.stringify(sortedKeySegments);\n+    });\n+\n+    const merged = [];\n+\n+    Object.values(groups).forEach((statements_) => {\n+      const resources = statements_.reduce((acc, { Resource: resource }) => {\n+        if (!resource) {\n+          return acc;\n+        }\n+        return acc.concat(Array.isArray(resource) ? resource : [resource]);\n+      }, []);",
        "comment_created_at": "2021-10-18T11:13:05+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's not use `reduce`, it doesn't feel as use case for it.\r\n\r\nHow about:\r\n\r\n```javascript\r\nreturn Object.values(groups).map((groupStatements) => {\r\n  const [resultStatement, ...toBeJoinedStatements] = groupStatements;\r\n  resultStatement.Resource = Array.concat(\r\n    resultStatement.Resource,\r\n    ...toBeJoinedStatements.map(({ Resource }) => Resource)\r\n  );\r\n  return resultStatement;\r\n});\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "730920514",
        "repo_full_name": "serverless/serverless",
        "pr_number": 10067,
        "pr_file": "lib/plugins/aws/package/lib/resolveIamRoles.js",
        "discussion_id": "730815329",
        "commented_code": "@@ -0,0 +1,107 @@\n+'use strict';\n+\n+const _ = require('lodash');\n+const deepSortObjectByKey = require('../../../../utils/deepSortObjectByKey');\n+\n+module.exports = {\n+  resolveIamRoles() {\n+    const iamRoleLambdaExecution =\n+      this.serverless.service.provider.compiledCloudFormationTemplate.Resources[\n+        this.provider.naming.getRoleLogicalId()\n+      ];\n+\n+    if (!iamRoleLambdaExecution) {\n+      return;\n+    }\n+\n+    const context = { iamRoleLambdaExecution };\n+\n+    this.resolveServicePrincipals(context);\n+    this.resolveStatements(context);\n+    this.pushManagedPolicies(context);\n+  },\n+\n+  resolveServicePrincipals({ iamRoleLambdaExecution }) {\n+    const lambdaAssumeStatement =\n+      iamRoleLambdaExecution.Properties.AssumeRolePolicyDocument.Statement.find((statement) =>\n+        statement.Principal.Service.includes('lambda.amazonaws.com')\n+      );\n+\n+    lambdaAssumeStatement.Principal.Service = Array.from(\n+      new Set([\n+        ...lambdaAssumeStatement.Principal.Service,\n+        ...this.provider.iamConfig.servicePrincipals,\n+        ..._.flatten(\n+          Object.values(this.serverless.service.functions).map(({ iamConfig }) => [\n+            ...iamConfig.servicePrincipals,\n+          ])\n+        ),\n+      ])\n+    );\n+  },\n+\n+  resolveStatements({ iamRoleLambdaExecution }) {\n+    const statements = [\n+      ...iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement,\n+      ...this.provider.iamConfig.policyStatements,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.policyStatements\n+        )\n+      ),\n+    ];\n+\n+    iamRoleLambdaExecution.Properties.Policies[0].PolicyDocument.Statement = this.mergeStatements(\n+      _.uniqWith(statements, _.isEqual)\n+    );\n+  },\n+\n+  pushManagedPolicies({ iamRoleLambdaExecution }) {\n+    const managedPolicies = [\n+      ...(iamRoleLambdaExecution.Properties.ManagedPolicyArns || []),\n+      ...this.provider.iamConfig.managedPolicies,\n+      ..._.flatten(\n+        Object.values(this.serverless.service.functions).map(\n+          ({ iamConfig }) => iamConfig.managedPolicies\n+        )\n+      ),\n+    ];\n+\n+    if (!managedPolicies.length) return;\n+\n+    iamRoleLambdaExecution.Properties.ManagedPolicyArns = _.uniqWith(managedPolicies, _.isEqual);\n+  },\n+\n+  mergeStatements(statements) {\n+    const groups = _.groupBy(statements, (statement) => {\n+      const { Resource, ...keySegments } = statement; // eslint-disable-line\n+      const sortedKeySegments = deepSortObjectByKey(keySegments);\n+      Object.values(sortedKeySegments).forEach((keySegement) => {\n+        if (Array.isArray(keySegement)) {\n+          keySegement.sort();\n+        }\n+      });\n+      return JSON.stringify(sortedKeySegments);\n+    });\n+\n+    const merged = [];\n+\n+    Object.values(groups).forEach((statements_) => {\n+      const resources = statements_.reduce((acc, { Resource: resource }) => {\n+        if (!resource) {\n+          return acc;\n+        }\n+        return acc.concat(Array.isArray(resource) ? resource : [resource]);\n+      }, []);",
        "comment_created_at": "2021-10-18T13:26:55+00:00",
        "comment_author": "issea1015",
        "comment_body": "Thanks for walking me through!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1187663596",
    "pr_number": 11895,
    "pr_file": "lib/plugins/aws/deploy/lib/check-for-changes.js",
    "created_at": "2023-05-08T16:50:28+00:00",
    "commented_code": "return this.checkLogGroupSubscriptionFilterResourceLimitExceeded();\n     }\n \n-    return BbPromise.bind(this)\n-      .then(this.getMostRecentObjects)\n-      .then((objs) => {\n-        return BbPromise.all([\n-          this.getObjectMetadata(objs),\n-          this.getFunctionsEarliestLastModifiedDate(),\n-        ]);\n-      })\n-      .then(([objMetadata, lastModifiedDate]) =>\n-        this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate)\n-      )\n-      .then(() => {\n-        if (this.serverless.service.provider.shouldNotDeploy) {\n-          return BbPromise.resolve();\n-        }\n+    const objs = await this.getMostRecentObjects();\n+    const [objMetadata, lastModifiedDate] = await Promise.all([\n+      this.getObjectMetadata(objs),\n+      this.getFunctionsEarliestLastModifiedDate(),\n+    ]);\n+    await this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate);\n+\n+    if (this.serverless.service.provider.shouldNotDeploy) {\n+      return Promise.resolve();",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "1187663596",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11895,
        "pr_file": "lib/plugins/aws/deploy/lib/check-for-changes.js",
        "discussion_id": "1187663596",
        "commented_code": "@@ -25,25 +24,19 @@ module.exports = {\n       return this.checkLogGroupSubscriptionFilterResourceLimitExceeded();\n     }\n \n-    return BbPromise.bind(this)\n-      .then(this.getMostRecentObjects)\n-      .then((objs) => {\n-        return BbPromise.all([\n-          this.getObjectMetadata(objs),\n-          this.getFunctionsEarliestLastModifiedDate(),\n-        ]);\n-      })\n-      .then(([objMetadata, lastModifiedDate]) =>\n-        this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate)\n-      )\n-      .then(() => {\n-        if (this.serverless.service.provider.shouldNotDeploy) {\n-          return BbPromise.resolve();\n-        }\n+    const objs = await this.getMostRecentObjects();\n+    const [objMetadata, lastModifiedDate] = await Promise.all([\n+      this.getObjectMetadata(objs),\n+      this.getFunctionsEarliestLastModifiedDate(),\n+    ]);\n+    await this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate);\n+\n+    if (this.serverless.service.provider.shouldNotDeploy) {\n+      return Promise.resolve();",
        "comment_created_at": "2023-05-08T16:50:28+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's simply `return` (no need for `Promise.resolve()`",
        "pr_file_module": null
      },
      {
        "comment_id": "1188809351",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11895,
        "pr_file": "lib/plugins/aws/deploy/lib/check-for-changes.js",
        "discussion_id": "1187663596",
        "commented_code": "@@ -25,25 +24,19 @@ module.exports = {\n       return this.checkLogGroupSubscriptionFilterResourceLimitExceeded();\n     }\n \n-    return BbPromise.bind(this)\n-      .then(this.getMostRecentObjects)\n-      .then((objs) => {\n-        return BbPromise.all([\n-          this.getObjectMetadata(objs),\n-          this.getFunctionsEarliestLastModifiedDate(),\n-        ]);\n-      })\n-      .then(([objMetadata, lastModifiedDate]) =>\n-        this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate)\n-      )\n-      .then(() => {\n-        if (this.serverless.service.provider.shouldNotDeploy) {\n-          return BbPromise.resolve();\n-        }\n+    const objs = await this.getMostRecentObjects();\n+    const [objMetadata, lastModifiedDate] = await Promise.all([\n+      this.getObjectMetadata(objs),\n+      this.getFunctionsEarliestLastModifiedDate(),\n+    ]);\n+    await this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate);\n+\n+    if (this.serverless.service.provider.shouldNotDeploy) {\n+      return Promise.resolve();",
        "comment_created_at": "2023-05-09T15:49:51+00:00",
        "comment_author": "sleepwithcoffee",
        "comment_body": "I am getting an eslint error if I were to return <empty>\r\nhttps://eslint.org/docs/latest/rules/consistent-return",
        "pr_file_module": null
      },
      {
        "comment_id": "1188811109",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11895,
        "pr_file": "lib/plugins/aws/deploy/lib/check-for-changes.js",
        "discussion_id": "1187663596",
        "commented_code": "@@ -25,25 +24,19 @@ module.exports = {\n       return this.checkLogGroupSubscriptionFilterResourceLimitExceeded();\n     }\n \n-    return BbPromise.bind(this)\n-      .then(this.getMostRecentObjects)\n-      .then((objs) => {\n-        return BbPromise.all([\n-          this.getObjectMetadata(objs),\n-          this.getFunctionsEarliestLastModifiedDate(),\n-        ]);\n-      })\n-      .then(([objMetadata, lastModifiedDate]) =>\n-        this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate)\n-      )\n-      .then(() => {\n-        if (this.serverless.service.provider.shouldNotDeploy) {\n-          return BbPromise.resolve();\n-        }\n+    const objs = await this.getMostRecentObjects();\n+    const [objMetadata, lastModifiedDate] = await Promise.all([\n+      this.getObjectMetadata(objs),\n+      this.getFunctionsEarliestLastModifiedDate(),\n+    ]);\n+    await this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate);\n+\n+    if (this.serverless.service.provider.shouldNotDeploy) {\n+      return Promise.resolve();",
        "comment_created_at": "2023-05-09T15:51:15+00:00",
        "comment_author": "medikoo",
        "comment_body": "Yes, the function either needs to return value or not.\r\n\r\nAs this function is not designed to return specific value, I think fix is to ensure we do not return last promise but just await it",
        "pr_file_module": null
      },
      {
        "comment_id": "1188851116",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11895,
        "pr_file": "lib/plugins/aws/deploy/lib/check-for-changes.js",
        "discussion_id": "1187663596",
        "commented_code": "@@ -25,25 +24,19 @@ module.exports = {\n       return this.checkLogGroupSubscriptionFilterResourceLimitExceeded();\n     }\n \n-    return BbPromise.bind(this)\n-      .then(this.getMostRecentObjects)\n-      .then((objs) => {\n-        return BbPromise.all([\n-          this.getObjectMetadata(objs),\n-          this.getFunctionsEarliestLastModifiedDate(),\n-        ]);\n-      })\n-      .then(([objMetadata, lastModifiedDate]) =>\n-        this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate)\n-      )\n-      .then(() => {\n-        if (this.serverless.service.provider.shouldNotDeploy) {\n-          return BbPromise.resolve();\n-        }\n+    const objs = await this.getMostRecentObjects();\n+    const [objMetadata, lastModifiedDate] = await Promise.all([\n+      this.getObjectMetadata(objs),\n+      this.getFunctionsEarliestLastModifiedDate(),\n+    ]);\n+    await this.checkIfDeploymentIsNecessary(objMetadata, lastModifiedDate);\n+\n+    if (this.serverless.service.provider.shouldNotDeploy) {\n+      return Promise.resolve();",
        "comment_created_at": "2023-05-09T16:24:37+00:00",
        "comment_author": "sleepwithcoffee",
        "comment_body": "it does return another promise, let me check further if we can turn that into an `await` statement instead. In that case we can remove the `resolve()` call",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1149440225",
    "pr_number": 11861,
    "pr_file": "test/unit/lib/classes/plugin-manager.test.js",
    "created_at": "2023-03-27T15:39:11+00:00",
    "commented_code": "const plugin1 = new ServicePluginMock1();\n       plugin1.asyncInit = sinon.stub().returns(Promise.resolve());\n       pluginManager.plugins = [plugin1];\n-      return pluginManager.asyncPluginInit().then(() => {\n-        expect(plugin1.asyncInit.calledOnce).to.equal(true);\n-      });\n+\n+      await pluginManager.asyncPluginInit();\n+      expect(plugin1.asyncInit.calledOnce).to.be.true;",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "1149440225",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11861,
        "pr_file": "test/unit/lib/classes/plugin-manager.test.js",
        "discussion_id": "1149440225",
        "commented_code": "@@ -586,9 +585,9 @@ describe('PluginManager', () => {\n       const plugin1 = new ServicePluginMock1();\n       plugin1.asyncInit = sinon.stub().returns(Promise.resolve());\n       pluginManager.plugins = [plugin1];\n-      return pluginManager.asyncPluginInit().then(() => {\n-        expect(plugin1.asyncInit.calledOnce).to.equal(true);\n-      });\n+\n+      await pluginManager.asyncPluginInit();\n+      expect(plugin1.asyncInit.calledOnce).to.be.true;",
        "comment_created_at": "2023-03-27T15:39:11+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's not introce such stylistic changes (`to.equal(true)` into `to.be.true`), it brings on extra value, while increases maintenance cost",
        "pr_file_module": null
      }
    ]
  }
]