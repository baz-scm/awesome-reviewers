[
  {
    "discussion_id": "1859827128",
    "pr_number": 12925,
    "pr_file": "lib/plugins/package/lib/zip-service.js",
    "created_at": "2024-11-27T04:15:56+00:00",
    "commented_code": "['dev', 'prod'],\n           (env) => {\n             const depFile = env === 'dev' ? nodeDevDepFile : nodeProdDepFile\n-            return childProcess\n-              .execAsync(\n-                `npm ls --${env}=true --parseable=true --long=false --silent --all >> ${depFile}`,\n-                {\n-                  cwd: dirWithPackageJson,\n-                  // We are overriding `NODE_ENV` because when it is set to \"production\"\n-                  // it causes invalid output of `npm ls` with `--dev=true`\n-                  env: {\n-                    ...process.env,\n-                    NODE_ENV: null,\n-                  },\n+            return execAsync(\n+              `npm ls --${env}=true --parseable=true --long=false --silent --all >> ${depFile}`,\n+              {\n+                cwd: dirWithPackageJson,\n+                // We are overriding `NODE_ENV` because when it is set to \"production\"\n+                // it causes invalid output of `npm ls` with `--dev=true`\n+                env: {\n+                  ...process.env,\n+                  NODE_ENV: null,\n                 },\n+              },\n+            ).catch((err) => {\n+              log.debug(\n+                `Failed to run npm ls to retrieve dependencies for exclusion. Error: ${err.message}`,\n               )\n-              .catch(() => Promise.resolve())\n+              Promise.resolve()",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "1859827128",
        "repo_full_name": "serverless/serverless",
        "pr_number": 12925,
        "pr_file": "lib/plugins/package/lib/zip-service.js",
        "discussion_id": "1859827128",
        "commented_code": "@@ -218,20 +219,23 @@ async function excludeNodeDevDependencies(serviceDir) {\n           ['dev', 'prod'],\n           (env) => {\n             const depFile = env === 'dev' ? nodeDevDepFile : nodeProdDepFile\n-            return childProcess\n-              .execAsync(\n-                `npm ls --${env}=true --parseable=true --long=false --silent --all >> ${depFile}`,\n-                {\n-                  cwd: dirWithPackageJson,\n-                  // We are overriding `NODE_ENV` because when it is set to \"production\"\n-                  // it causes invalid output of `npm ls` with `--dev=true`\n-                  env: {\n-                    ...process.env,\n-                    NODE_ENV: null,\n-                  },\n+            return execAsync(\n+              `npm ls --${env}=true --parseable=true --long=false --silent --all >> ${depFile}`,\n+              {\n+                cwd: dirWithPackageJson,\n+                // We are overriding `NODE_ENV` because when it is set to \"production\"\n+                // it causes invalid output of `npm ls` with `--dev=true`\n+                env: {\n+                  ...process.env,\n+                  NODE_ENV: null,\n                 },\n+              },\n+            ).catch((err) => {\n+              log.debug(\n+                `Failed to run npm ls to retrieve dependencies for exclusion. Error: ${err.message}`,\n               )\n-              .catch(() => Promise.resolve())\n+              Promise.resolve()",
        "comment_created_at": "2024-11-27T04:15:56+00:00",
        "comment_author": "ethanherbertson",
        "comment_body": "This looks like a mistake introduced by the conversion of the `.catch` handler from an arrow function with an right-hand-side expression to an arrow function with braces. If you really want to return the `Promise.resolve()` you need to add an explicit `return`.\r\n\r\nThat said, `.catch` will (if its handler is executed) **already** resolve with whatever you return from its handler, which is `undefined` if you **don't** have explicit return, so you might as well drop this line entirely.",
        "pr_file_module": null
      },
      {
        "comment_id": "1860517407",
        "repo_full_name": "serverless/serverless",
        "pr_number": 12925,
        "pr_file": "lib/plugins/package/lib/zip-service.js",
        "discussion_id": "1859827128",
        "commented_code": "@@ -218,20 +219,23 @@ async function excludeNodeDevDependencies(serviceDir) {\n           ['dev', 'prod'],\n           (env) => {\n             const depFile = env === 'dev' ? nodeDevDepFile : nodeProdDepFile\n-            return childProcess\n-              .execAsync(\n-                `npm ls --${env}=true --parseable=true --long=false --silent --all >> ${depFile}`,\n-                {\n-                  cwd: dirWithPackageJson,\n-                  // We are overriding `NODE_ENV` because when it is set to \"production\"\n-                  // it causes invalid output of `npm ls` with `--dev=true`\n-                  env: {\n-                    ...process.env,\n-                    NODE_ENV: null,\n-                  },\n+            return execAsync(\n+              `npm ls --${env}=true --parseable=true --long=false --silent --all >> ${depFile}`,\n+              {\n+                cwd: dirWithPackageJson,\n+                // We are overriding `NODE_ENV` because when it is set to \"production\"\n+                // it causes invalid output of `npm ls` with `--dev=true`\n+                env: {\n+                  ...process.env,\n+                  NODE_ENV: null,\n                 },\n+              },\n+            ).catch((err) => {\n+              log.debug(\n+                `Failed to run npm ls to retrieve dependencies for exclusion. Error: ${err.message}`,\n               )\n-              .catch(() => Promise.resolve())\n+              Promise.resolve()",
        "comment_created_at": "2024-11-27T11:45:42+00:00",
        "comment_author": "czubocha",
        "comment_body": "You're right - thanks for pointing that out!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136073957",
    "pr_number": 11782,
    "pr_file": "lib/cli/interactive-setup/index.js",
    "created_at": "2023-03-14T19:18:02+00:00",
    "commented_code": "}\n   }\n \n+  if (context.isConsole && options.dev && initialContext.isInServiceContext) {\n+    const compatibilityMap = await apiRequest('/api/inventories/compatibility', {\n+      method: 'GET',\n+    });\n+    const devModeRuntimeCompatibility = compatibilityMap.mode.dev.runtimes;\n+    const { provider } = context.serverless.service;\n+    if (!devModeRuntimeCompatibility.includes(provider.runtime)) {\n+      context.incompatibleRuntime = true;\n+      log.error('This services runtime is not currently supported by Serverless Console Dev Mode.');\n+      throw new Error('INCOMPATIBLE_RUNTIME');",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "1136073957",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11782,
        "pr_file": "lib/cli/interactive-setup/index.js",
        "discussion_id": "1136073957",
        "commented_code": "@@ -63,6 +66,21 @@ module.exports = async (context) => {\n     }\n   }\n \n+  if (context.isConsole && options.dev && initialContext.isInServiceContext) {\n+    const compatibilityMap = await apiRequest('/api/inventories/compatibility', {\n+      method: 'GET',\n+    });\n+    const devModeRuntimeCompatibility = compatibilityMap.mode.dev.runtimes;\n+    const { provider } = context.serverless.service;\n+    if (!devModeRuntimeCompatibility.includes(provider.runtime)) {\n+      context.incompatibleRuntime = true;\n+      log.error('This services runtime is not currently supported by Serverless Console Dev Mode.');\n+      throw new Error('INCOMPATIBLE_RUNTIME');",
        "comment_created_at": "2023-03-14T19:18:02+00:00",
        "comment_author": "medikoo",
        "comment_body": "Do we really want to throw here?\r\n\r\nEven if, we should use `ServerlessError` and configure it with human friendly message which will be displayed to user",
        "pr_file_module": null
      },
      {
        "comment_id": "1136171404",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11782,
        "pr_file": "lib/cli/interactive-setup/index.js",
        "discussion_id": "1136073957",
        "commented_code": "@@ -63,6 +66,21 @@ module.exports = async (context) => {\n     }\n   }\n \n+  if (context.isConsole && options.dev && initialContext.isInServiceContext) {\n+    const compatibilityMap = await apiRequest('/api/inventories/compatibility', {\n+      method: 'GET',\n+    });\n+    const devModeRuntimeCompatibility = compatibilityMap.mode.dev.runtimes;\n+    const { provider } = context.serverless.service;\n+    if (!devModeRuntimeCompatibility.includes(provider.runtime)) {\n+      context.incompatibleRuntime = true;\n+      log.error('This services runtime is not currently supported by Serverless Console Dev Mode.');\n+      throw new Error('INCOMPATIBLE_RUNTIME');",
        "comment_created_at": "2023-03-14T20:38:42+00:00",
        "comment_author": "Danwakeem",
        "comment_body": "This is a good question. It wasn\u2019t clear to me if there was a way for me to end the execution early without throwing. If I put a return here it threw a lint error \ud83e\udd14",
        "pr_file_module": null
      },
      {
        "comment_id": "1136226902",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11782,
        "pr_file": "lib/cli/interactive-setup/index.js",
        "discussion_id": "1136073957",
        "commented_code": "@@ -63,6 +66,21 @@ module.exports = async (context) => {\n     }\n   }\n \n+  if (context.isConsole && options.dev && initialContext.isInServiceContext) {\n+    const compatibilityMap = await apiRequest('/api/inventories/compatibility', {\n+      method: 'GET',\n+    });\n+    const devModeRuntimeCompatibility = compatibilityMap.mode.dev.runtimes;\n+    const { provider } = context.serverless.service;\n+    if (!devModeRuntimeCompatibility.includes(provider.runtime)) {\n+      context.incompatibleRuntime = true;\n+      log.error('This services runtime is not currently supported by Serverless Console Dev Mode.');\n+      throw new Error('INCOMPATIBLE_RUNTIME');",
        "comment_created_at": "2023-03-14T21:25:59+00:00",
        "comment_author": "medikoo",
        "comment_body": "Question, is do we want here (1) abort the command and present user with the error message then we should throw (but as mentioned above using dedicated interface and with human friendly message)\r\nOr do we want to  (2) just show error stating that given step cannot be accomplish and let command follow with other steps (as e.g. consol integration). In this case we should just log the error, do not set `context.isConsoleDevMode: true`  and let process continue",
        "pr_file_module": null
      },
      {
        "comment_id": "1136240152",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11782,
        "pr_file": "lib/cli/interactive-setup/index.js",
        "discussion_id": "1136073957",
        "commented_code": "@@ -63,6 +66,21 @@ module.exports = async (context) => {\n     }\n   }\n \n+  if (context.isConsole && options.dev && initialContext.isInServiceContext) {\n+    const compatibilityMap = await apiRequest('/api/inventories/compatibility', {\n+      method: 'GET',\n+    });\n+    const devModeRuntimeCompatibility = compatibilityMap.mode.dev.runtimes;\n+    const { provider } = context.serverless.service;\n+    if (!devModeRuntimeCompatibility.includes(provider.runtime)) {\n+      context.incompatibleRuntime = true;\n+      log.error('This services runtime is not currently supported by Serverless Console Dev Mode.');\n+      throw new Error('INCOMPATIBLE_RUNTIME');",
        "comment_created_at": "2023-03-14T21:38:17+00:00",
        "comment_author": "Danwakeem",
        "comment_body": "\ud83e\udd14 I guess it might be fine to just let the process continue and just log the error. That would probably be the least inconvenient.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1045793629",
    "pr_number": 11558,
    "pr_file": "lib/serverless.js",
    "created_at": "2022-12-12T12:53:13+00:00",
    "commented_code": "logDeprecation(code, message) {\n     return this._logDeprecation(`EXT_${ensureString(code)}`, ensureString(message));\n   }\n+\n+  extendConfiguration(configurationPathKeys, value) {\n+    configurationPathKeys = ensureArray(configurationPathKeys, {\n+      ensureItem: ensureString,\n+    });\n+    if (configurationPathKeys.length < 1) {\n+      throw new ServerlessError(\n+        'ConfigurationPathKeys needs to contain at least one element.',\n+        'INVALID_EXTEND_AT_ROOT'\n+      );\n+    }\n+\n+    if (!this.isConfigurationExtendable) {\n+      throw new ServerlessError(",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "1045793629",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11558,
        "pr_file": "lib/serverless.js",
        "discussion_id": "1045793629",
        "commented_code": "@@ -215,6 +220,46 @@ class Serverless {\n   logDeprecation(code, message) {\n     return this._logDeprecation(`EXT_${ensureString(code)}`, ensureString(message));\n   }\n+\n+  extendConfiguration(configurationPathKeys, value) {\n+    configurationPathKeys = ensureArray(configurationPathKeys, {\n+      ensureItem: ensureString,\n+    });\n+    if (configurationPathKeys.length < 1) {\n+      throw new ServerlessError(\n+        'ConfigurationPathKeys needs to contain at least one element.',\n+        'INVALID_EXTEND_AT_ROOT'\n+      );\n+    }\n+\n+    if (!this.isConfigurationExtendable) {\n+      throw new ServerlessError(",
        "comment_created_at": "2022-12-12T12:53:13+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's use regular `Error` as it's a API for plugins, while `ServerlessError` is intended to report errors caused by users's misusage (e.g invalid configuration etc)",
        "pr_file_module": null
      },
      {
        "comment_id": "1047078774",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11558,
        "pr_file": "lib/serverless.js",
        "discussion_id": "1045793629",
        "commented_code": "@@ -215,6 +220,46 @@ class Serverless {\n   logDeprecation(code, message) {\n     return this._logDeprecation(`EXT_${ensureString(code)}`, ensureString(message));\n   }\n+\n+  extendConfiguration(configurationPathKeys, value) {\n+    configurationPathKeys = ensureArray(configurationPathKeys, {\n+      ensureItem: ensureString,\n+    });\n+    if (configurationPathKeys.length < 1) {\n+      throw new ServerlessError(\n+        'ConfigurationPathKeys needs to contain at least one element.',\n+        'INVALID_EXTEND_AT_ROOT'\n+      );\n+    }\n+\n+    if (!this.isConfigurationExtendable) {\n+      throw new ServerlessError(",
        "comment_created_at": "2022-12-13T12:13:24+00:00",
        "comment_author": "mklenbw",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "620061525",
    "pr_number": 9314,
    "pr_file": "lib/configuration/variables/sources/merge.js",
    "created_at": "2021-04-26T08:03:00+00:00",
    "commented_code": "+'use strict';\n+\n+const ServerlessError = require('../../../serverless-error');\n+const isPlainObject = require('type/plain-object/is');\n+\n+module.exports = {\n+  resolve: ({ params }) => {\n+    if (!params || params.length < 2) {\n+      throw new ServerlessError('${merge(...)} needs a sequence of values to merge');\n+    }\n+\n+    if (params.every((item) => Array.isArray(item))) {\n+      const result = [];\n+      for (const param of params) result.push(...param);\n+      return { value: result };\n+    }\n+\n+    if (params.every((item) => isPlainObject(item))) {\n+      const keys = {};\n+\n+      params.forEach((item, index) => {\n+        Object.keys(item).forEach((key) => {\n+          if (keys[key] !== undefined) {\n+            throw new ServerlessError(\n+              `duplicate key \\`${key}\\` in \\${merge(...)}[${index}]; first seen in \\${merge(...)}[${keys[key]}]`\n+            );\n+          }\n+          keys[key] = index;\n+        });\n+      });\n+\n+      return { value: Object.assign({}, ...params) };\n+    }\n+\n+    throw new ServerlessError('${merge(...)} needs a list of arrays or objects to merge');",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "620061525",
        "repo_full_name": "serverless/serverless",
        "pr_number": 9314,
        "pr_file": "lib/configuration/variables/sources/merge.js",
        "discussion_id": "620061525",
        "commented_code": "@@ -0,0 +1,37 @@\n+'use strict';\n+\n+const ServerlessError = require('../../../serverless-error');\n+const isPlainObject = require('type/plain-object/is');\n+\n+module.exports = {\n+  resolve: ({ params }) => {\n+    if (!params || params.length < 2) {\n+      throw new ServerlessError('${merge(...)} needs a sequence of values to merge');\n+    }\n+\n+    if (params.every((item) => Array.isArray(item))) {\n+      const result = [];\n+      for (const param of params) result.push(...param);\n+      return { value: result };\n+    }\n+\n+    if (params.every((item) => isPlainObject(item))) {\n+      const keys = {};\n+\n+      params.forEach((item, index) => {\n+        Object.keys(item).forEach((key) => {\n+          if (keys[key] !== undefined) {\n+            throw new ServerlessError(\n+              `duplicate key \\`${key}\\` in \\${merge(...)}[${index}]; first seen in \\${merge(...)}[${keys[key]}]`\n+            );\n+          }\n+          keys[key] = index;\n+        });\n+      });\n+\n+      return { value: Object.assign({}, ...params) };\n+    }\n+\n+    throw new ServerlessError('${merge(...)} needs a list of arrays or objects to merge');",
        "comment_created_at": "2021-04-26T08:03:00+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's reword to `Invalid arguments for variable \"merge\" (expected exclusive list of arrays or plain objects)` and add code `INVALID_VARIABLE_MERGE_PARAMS`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "480956474",
    "pr_number": 8157,
    "pr_file": "lib/plugins/aws/invokeLocal/index.js",
    "created_at": "2020-09-01T08:16:12+00:00",
    "commented_code": "}\n \n   loadEnvVars() {\n-    const lambdaName = this.options.functionObj.name;\n-    const memorySize =\n-      Number(this.options.functionObj.memorySize) ||\n-      Number(this.serverless.service.provider.memorySize) ||\n-      1024;\n-\n-    const lambdaDefaultEnvVars = {\n-      LANG: 'en_US.UTF-8',\n-      LD_LIBRARY_PATH:\n-        '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n-      LAMBDA_TASK_ROOT: '/var/task',\n-      LAMBDA_RUNTIME_DIR: '/var/runtime',\n-      AWS_REGION: this.provider.getRegion(),\n-      AWS_DEFAULT_REGION: this.provider.getRegion(),\n-      AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n-      AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n-      AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n-      AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n-      AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n-      NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n-    };\n+    return BbPromise.try(() => {\n+      const lambdaName = this.options.functionObj.name;\n+      const memorySize =\n+        Number(this.options.functionObj.memorySize) ||\n+        Number(this.serverless.service.provider.memorySize) ||\n+        1024;\n+\n+      const lambdaDefaultEnvVars = {\n+        LANG: 'en_US.UTF-8',\n+        LD_LIBRARY_PATH:\n+          '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n+        LAMBDA_TASK_ROOT: '/var/task',\n+        LAMBDA_RUNTIME_DIR: '/var/runtime',\n+        AWS_REGION: this.provider.getRegion(),\n+        AWS_DEFAULT_REGION: this.provider.getRegion(),\n+        AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n+        AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n+        AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n+        AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n+        AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n+        NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n+      };\n \n-    const credentialEnvVars = this.getCredentialEnvVars();\n+      const credentialEnvVars = this.getCredentialEnvVars();\n \n-    // profile override from config\n-    const profileOverride = this.provider.getProfile();\n-    if (profileOverride) {\n-      lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n-    }\n+      // profile override from config\n+      const profileOverride = this.provider.getProfile();\n+      if (profileOverride) {\n+        lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n+      }\n \n-    const configuredEnvVars = this.getConfiguredEnvVars();\n+      const configuredEnvVars = this.getConfiguredEnvVars();\n \n-    _.merge(process.env, lambdaDefaultEnvVars, credentialEnvVars, configuredEnvVars);\n+      const promises = _.entries(configuredEnvVars).map(([name, value]) => {\n+        return this.resolveCfFunctionValue(this.provider, value)\n+          .then(resolvedValue => {\n+            configuredEnvVars[name] = resolvedValue;\n+          })\n+          .catch(e => {",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "480956474",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/invokeLocal/index.js",
        "discussion_id": "480956474",
        "commented_code": "@@ -150,41 +152,55 @@ class AwsInvokeLocal {\n   }\n \n   loadEnvVars() {\n-    const lambdaName = this.options.functionObj.name;\n-    const memorySize =\n-      Number(this.options.functionObj.memorySize) ||\n-      Number(this.serverless.service.provider.memorySize) ||\n-      1024;\n-\n-    const lambdaDefaultEnvVars = {\n-      LANG: 'en_US.UTF-8',\n-      LD_LIBRARY_PATH:\n-        '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n-      LAMBDA_TASK_ROOT: '/var/task',\n-      LAMBDA_RUNTIME_DIR: '/var/runtime',\n-      AWS_REGION: this.provider.getRegion(),\n-      AWS_DEFAULT_REGION: this.provider.getRegion(),\n-      AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n-      AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n-      AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n-      AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n-      AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n-      NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n-    };\n+    return BbPromise.try(() => {\n+      const lambdaName = this.options.functionObj.name;\n+      const memorySize =\n+        Number(this.options.functionObj.memorySize) ||\n+        Number(this.serverless.service.provider.memorySize) ||\n+        1024;\n+\n+      const lambdaDefaultEnvVars = {\n+        LANG: 'en_US.UTF-8',\n+        LD_LIBRARY_PATH:\n+          '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n+        LAMBDA_TASK_ROOT: '/var/task',\n+        LAMBDA_RUNTIME_DIR: '/var/runtime',\n+        AWS_REGION: this.provider.getRegion(),\n+        AWS_DEFAULT_REGION: this.provider.getRegion(),\n+        AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n+        AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n+        AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n+        AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n+        AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n+        NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n+      };\n \n-    const credentialEnvVars = this.getCredentialEnvVars();\n+      const credentialEnvVars = this.getCredentialEnvVars();\n \n-    // profile override from config\n-    const profileOverride = this.provider.getProfile();\n-    if (profileOverride) {\n-      lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n-    }\n+      // profile override from config\n+      const profileOverride = this.provider.getProfile();\n+      if (profileOverride) {\n+        lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n+      }\n \n-    const configuredEnvVars = this.getConfiguredEnvVars();\n+      const configuredEnvVars = this.getConfiguredEnvVars();\n \n-    _.merge(process.env, lambdaDefaultEnvVars, credentialEnvVars, configuredEnvVars);\n+      const promises = _.entries(configuredEnvVars).map(([name, value]) => {\n+        return this.resolveCfFunctionValue(this.provider, value)\n+          .then(resolvedValue => {\n+            configuredEnvVars[name] = resolvedValue;\n+          })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T08:16:12+00:00",
        "comment_author": "medikoo",
        "comment_body": "This should be a second callback to previous `then` (otherwise we're catching here eventual programmer error in _first_ then callback, and that can hide important issues)",
        "pr_file_module": null
      },
      {
        "comment_id": "480990064",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/invokeLocal/index.js",
        "discussion_id": "480956474",
        "commented_code": "@@ -150,41 +152,55 @@ class AwsInvokeLocal {\n   }\n \n   loadEnvVars() {\n-    const lambdaName = this.options.functionObj.name;\n-    const memorySize =\n-      Number(this.options.functionObj.memorySize) ||\n-      Number(this.serverless.service.provider.memorySize) ||\n-      1024;\n-\n-    const lambdaDefaultEnvVars = {\n-      LANG: 'en_US.UTF-8',\n-      LD_LIBRARY_PATH:\n-        '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n-      LAMBDA_TASK_ROOT: '/var/task',\n-      LAMBDA_RUNTIME_DIR: '/var/runtime',\n-      AWS_REGION: this.provider.getRegion(),\n-      AWS_DEFAULT_REGION: this.provider.getRegion(),\n-      AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n-      AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n-      AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n-      AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n-      AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n-      NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n-    };\n+    return BbPromise.try(() => {\n+      const lambdaName = this.options.functionObj.name;\n+      const memorySize =\n+        Number(this.options.functionObj.memorySize) ||\n+        Number(this.serverless.service.provider.memorySize) ||\n+        1024;\n+\n+      const lambdaDefaultEnvVars = {\n+        LANG: 'en_US.UTF-8',\n+        LD_LIBRARY_PATH:\n+          '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n+        LAMBDA_TASK_ROOT: '/var/task',\n+        LAMBDA_RUNTIME_DIR: '/var/runtime',\n+        AWS_REGION: this.provider.getRegion(),\n+        AWS_DEFAULT_REGION: this.provider.getRegion(),\n+        AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n+        AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n+        AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n+        AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n+        AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n+        NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n+      };\n \n-    const credentialEnvVars = this.getCredentialEnvVars();\n+      const credentialEnvVars = this.getCredentialEnvVars();\n \n-    // profile override from config\n-    const profileOverride = this.provider.getProfile();\n-    if (profileOverride) {\n-      lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n-    }\n+      // profile override from config\n+      const profileOverride = this.provider.getProfile();\n+      if (profileOverride) {\n+        lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n+      }\n \n-    const configuredEnvVars = this.getConfiguredEnvVars();\n+      const configuredEnvVars = this.getConfiguredEnvVars();\n \n-    _.merge(process.env, lambdaDefaultEnvVars, credentialEnvVars, configuredEnvVars);\n+      const promises = _.entries(configuredEnvVars).map(([name, value]) => {\n+        return this.resolveCfFunctionValue(this.provider, value)\n+          .then(resolvedValue => {\n+            configuredEnvVars[name] = resolvedValue;\n+          })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T09:12:07+00:00",
        "comment_author": "fredericbarthelet",
        "comment_body": "Ok, I updated accordingly.\r\n\r\nJust for my knowledge, my understanding of promise chainable then/catch was indeed to avoid nesting then and catch and have all instructions on the same level.\r\n\r\nHow is \r\n\r\n```\r\nreturn bool ? resolveAsync() : BbPromise.resolve(value)\r\n  .then(value => {\r\n    doSomething\r\n  })\r\n  .catch(e => {\r\n    doSomething\r\n  })\r\n```\r\n\r\ndifferent from \r\n\r\n```\r\nreturn bool ? resolveAsync().catch(e => {\r\n    doSomething\r\n  }) : BbPromise.resolve(value)\r\n  .then(value => {\r\n    doSomething\r\n  })\r\n```\r\n\r\nEspecially since I throw again in my catch statement. This serve as error context enriching, even if error is thrown in the `then` statement, it will benefit the user having the same formatting - wether the error has been thrown by resolveAsync of doSomething in the then statement - no ?",
        "pr_file_module": null
      },
      {
        "comment_id": "481039055",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/invokeLocal/index.js",
        "discussion_id": "480956474",
        "commented_code": "@@ -150,41 +152,55 @@ class AwsInvokeLocal {\n   }\n \n   loadEnvVars() {\n-    const lambdaName = this.options.functionObj.name;\n-    const memorySize =\n-      Number(this.options.functionObj.memorySize) ||\n-      Number(this.serverless.service.provider.memorySize) ||\n-      1024;\n-\n-    const lambdaDefaultEnvVars = {\n-      LANG: 'en_US.UTF-8',\n-      LD_LIBRARY_PATH:\n-        '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n-      LAMBDA_TASK_ROOT: '/var/task',\n-      LAMBDA_RUNTIME_DIR: '/var/runtime',\n-      AWS_REGION: this.provider.getRegion(),\n-      AWS_DEFAULT_REGION: this.provider.getRegion(),\n-      AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n-      AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n-      AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n-      AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n-      AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n-      NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n-    };\n+    return BbPromise.try(() => {\n+      const lambdaName = this.options.functionObj.name;\n+      const memorySize =\n+        Number(this.options.functionObj.memorySize) ||\n+        Number(this.serverless.service.provider.memorySize) ||\n+        1024;\n+\n+      const lambdaDefaultEnvVars = {\n+        LANG: 'en_US.UTF-8',\n+        LD_LIBRARY_PATH:\n+          '/usr/local/lib64/node-v4.3.x/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib', // eslint-disable-line max-len\n+        LAMBDA_TASK_ROOT: '/var/task',\n+        LAMBDA_RUNTIME_DIR: '/var/runtime',\n+        AWS_REGION: this.provider.getRegion(),\n+        AWS_DEFAULT_REGION: this.provider.getRegion(),\n+        AWS_LAMBDA_LOG_GROUP_NAME: this.provider.naming.getLogGroupName(lambdaName),\n+        AWS_LAMBDA_LOG_STREAM_NAME: '2016/12/02/[$LATEST]f77ff5e4026c45bda9a9ebcec6bc9cad',\n+        AWS_LAMBDA_FUNCTION_NAME: lambdaName,\n+        AWS_LAMBDA_FUNCTION_MEMORY_SIZE: memorySize,\n+        AWS_LAMBDA_FUNCTION_VERSION: '$LATEST',\n+        NODE_PATH: '/var/runtime:/var/task:/var/runtime/node_modules',\n+      };\n \n-    const credentialEnvVars = this.getCredentialEnvVars();\n+      const credentialEnvVars = this.getCredentialEnvVars();\n \n-    // profile override from config\n-    const profileOverride = this.provider.getProfile();\n-    if (profileOverride) {\n-      lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n-    }\n+      // profile override from config\n+      const profileOverride = this.provider.getProfile();\n+      if (profileOverride) {\n+        lambdaDefaultEnvVars.AWS_PROFILE = profileOverride;\n+      }\n \n-    const configuredEnvVars = this.getConfiguredEnvVars();\n+      const configuredEnvVars = this.getConfiguredEnvVars();\n \n-    _.merge(process.env, lambdaDefaultEnvVars, credentialEnvVars, configuredEnvVars);\n+      const promises = _.entries(configuredEnvVars).map(([name, value]) => {\n+        return this.resolveCfFunctionValue(this.provider, value)\n+          .then(resolvedValue => {\n+            configuredEnvVars[name] = resolvedValue;\n+          })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T10:31:06+00:00",
        "comment_author": "medikoo",
        "comment_body": "@fredericbarthelet I was referring strictly to lines as commented (your comment seems to dive into some other area).\r\n\r\nNote the important difference between the outcome of two below snippets:\r\n\r\n```javascript\r\nconst configuredEnvVars = {}\r\nconst potentiallyErrorneousResolution = Promise.resole(\"successValue\");\r\npotentiallyErrorneousResolution.then(resolvedValue => {\r\n  configuredEvnVars[name] = resolvedValue;\r\n}).catch(e => {\r\n  throw new Error(\"Could not resolve environment variable\")\r\n});\r\n```\r\n\r\n```javascript\r\nconst configuredEnvVars = {}\r\nconst potentiallyErrorneousResolution = Promise.resole(\"successValue\");\r\npotentiallyErrorneousResolution.then(resolvedValue => {\r\n  configuredEvnVars[name] = resolvedValue;\r\n}, e => {\r\n  throw new Error(\"Could not resolve environment variable\")\r\n});\r\n```\r\n\r\nUnfortunately erroneous `then(onSuccess).catch(onFailure)` pattern is repeated by most of promise tutorials and you find in many docs. While _if/else_ logic is resembled correctly only by `then(onSuccess, onFailure)`\r\n\r\n`catch(onFailure)` is nothing more than convenient shortcut for `then(null, onFailure)`, and ideally should be seen just as that.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "481040896",
    "pr_number": 8157,
    "pr_file": "lib/plugins/aws/info/getStackInfo.js",
    "created_at": "2020-09-01T10:34:46+00:00",
    "commented_code": ".then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "481040896",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/info/getStackInfo.js",
        "discussion_id": "481040896",
        "commented_code": "@@ -52,6 +43,11 @@ module.exports = {\n           .then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T10:34:46+00:00",
        "comment_author": "medikoo",
        "comment_body": "This should be a _second_ callback to previous `then` (not a new `catch` clause), for reasons outlined here: https://github.com/serverless/serverless/pull/8157#discussion_r481039055\r\n\r\nEventually we can make it as `catch` clause that directly follows `provider.request` above",
        "pr_file_module": null
      },
      {
        "comment_id": "481049655",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/info/getStackInfo.js",
        "discussion_id": "481040896",
        "commented_code": "@@ -52,6 +43,11 @@ module.exports = {\n           .then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T10:51:58+00:00",
        "comment_author": "fredericbarthelet",
        "comment_body": "understood your point, updated.\r\n\r\nWe cannot make it a catch clause in resolveCfImportValue as Serverless.Error class is not accessible there",
        "pr_file_module": null
      },
      {
        "comment_id": "481052309",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/info/getStackInfo.js",
        "discussion_id": "481040896",
        "commented_code": "@@ -52,6 +43,11 @@ module.exports = {\n           .then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T10:57:18+00:00",
        "comment_author": "fredericbarthelet",
        "comment_body": "However I ran some test, and I think final catching in this use case is quite useful.\r\n\r\n**With the code as is in this current PR state**, if I reference a non-existing name for my httpAPI id import, I get the following error :\r\n\r\n![image](https://user-images.githubusercontent.com/23530626/91841184-30e4dd00-ec52-11ea-8325-75894b2b04d6.png)\r\n\r\nAnd when I reference an existing import name, but the corresponding value does not match any httpApi Id (or I simply use a string as `httpApi.id` parameter not corresponding to any API), I get the following error :\r\n\r\n![image](https://user-images.githubusercontent.com/23530626/91841299-64c00280-ec52-11ea-97b1-f1e8f3d96d9c.png)\r\n\r\nIf I change this to be catching only error from `provider.request` using `then` second argument or a `catch` clause on `request` method, the first error remain the same, while the second become much less clear as to where and why the error occured, since I'm only left with the `Invalid API identifier specified 871803655707:value` error message.\r\n\r\n@medikoo , don't you think the current version is actually better for DX ?",
        "pr_file_module": null
      },
      {
        "comment_id": "481057751",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/info/getStackInfo.js",
        "discussion_id": "481040896",
        "commented_code": "@@ -52,6 +43,11 @@ module.exports = {\n           .then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T11:08:43+00:00",
        "comment_author": "medikoo",
        "comment_body": "In case I commented, the only thing I proposed, is to not cover this callback:\r\n\r\n```javascript\r\nif (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\r\n```\r\n\r\nwith added error handler.  I don't see how it can produce difference you point in screenshots. By content of callback it seems clear that it's only programmer error that will eventually surface, not AWS request error",
        "pr_file_module": null
      },
      {
        "comment_id": "481059768",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/info/getStackInfo.js",
        "discussion_id": "481040896",
        "commented_code": "@@ -52,6 +43,11 @@ module.exports = {\n           .then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T11:12:49+00:00",
        "comment_author": "medikoo",
        "comment_body": "To be perfectly clear. I mean to do this:\r\n\r\n```javascript\r\n.then(id => {\r\n  return this.provider.request('ApiGatewayV2', 'getApi', { ApiId: id });\r\n})\r\n.then(result => {\r\n  stackData.externalHttpApiEndpoint = result.ApiEndpoint;\r\n}, e => {\r\n  throw new this.serverless.classes.Error(\r\n    `Could not resolve provider.httpApi.id parameter. ${e.message}`\r\n  );\r\n})\r\n```\r\n\r\ninstead of\r\n\r\n```javascript\r\n.then(id => {\r\n  return this.provider.request('ApiGatewayV2', 'getApi', { ApiId: id });\r\n})\r\n.then(result => {\r\n  stackData.externalHttpApiEndpoint = result.ApiEndpoint;\r\n})\r\n.catch(e => {\r\n  throw new this.serverless.classes.Error(\r\n    `Could not resolve provider.httpApi.id parameter. ${e.message}`\r\n  );\r\n})\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "481061511",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8157,
        "pr_file": "lib/plugins/aws/info/getStackInfo.js",
        "discussion_id": "481040896",
        "commented_code": "@@ -52,6 +43,11 @@ module.exports = {\n           .then(result => {\n             if (result) stackData.externalHttpApiEndpoint = result.ApiEndpoint;\n           })\n+          .catch(e => {",
        "comment_created_at": "2020-09-01T11:16:26+00:00",
        "comment_author": "fredericbarthelet",
        "comment_body": "Ok, understood your point about leaving out the last `then` statement.\r\nI'll update according to your comments",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "971803683",
    "pr_number": 11389,
    "pr_file": "lib/plugins/aws/deploy/lib/ensure-valid-bucket-exists.js",
    "created_at": "2022-09-15T10:16:48+00:00",
    "commented_code": "});\n       } catch (err) {\n         throw new ServerlessError(\n-          `Could not locate deployment bucket. Error: ${err.message}`,\n+          `Could not locate deployment bucket: ${this.bucketName}. Error: ${err.message}`,",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "971803683",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11389,
        "pr_file": "lib/plugins/aws/deploy/lib/ensure-valid-bucket-exists.js",
        "discussion_id": "971803683",
        "commented_code": "@@ -31,7 +31,7 @@ module.exports = {\n         });\n       } catch (err) {\n         throw new ServerlessError(\n-          `Could not locate deployment bucket. Error: ${err.message}`,\n+          `Could not locate deployment bucket: ${this.bucketName}. Error: ${err.message}`,",
        "comment_created_at": "2022-09-15T10:16:48+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's also wrap bucket name in parenthesis (it's our convention for adding names to error messages)",
        "pr_file_module": null
      },
      {
        "comment_id": "971851152",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11389,
        "pr_file": "lib/plugins/aws/deploy/lib/ensure-valid-bucket-exists.js",
        "discussion_id": "971803683",
        "commented_code": "@@ -31,7 +31,7 @@ module.exports = {\n         });\n       } catch (err) {\n         throw new ServerlessError(\n-          `Could not locate deployment bucket. Error: ${err.message}`,\n+          `Could not locate deployment bucket: ${this.bucketName}. Error: ${err.message}`,",
        "comment_created_at": "2022-09-15T11:10:37+00:00",
        "comment_author": "rca",
        "comment_body": "@medikoo alright, the patch has been updated, thanks!",
        "pr_file_module": null
      }
    ]
  }
]