[
  {
    "discussion_id": "464953402",
    "pr_number": 8042,
    "pr_file": "lib/plugins/aws/package/compile/functions/index.js",
    "created_at": "2020-08-04T10:26:44+00:00",
    "commented_code": "}\n       }\n \n+      const fileSystemConfigs = functionObject.fileSystemConfigs;\n+\n+      // TODO: Simplify these conditions\n+      if (fileSystemConfigs && fileSystemConfigs.length !== 0) {\n+        if (fileSystemConfigs.length > 1) {\n+          // TODO: Add explanation - CloudFormation limitation\n+          const errorMessage = 'You can specify at most 1 fileSystemConfig';\n+          throw new this.serverless.classes.Error(errorMessage);",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "464953402",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8042,
        "pr_file": "lib/plugins/aws/package/compile/functions/index.js",
        "discussion_id": "464953402",
        "commented_code": "@@ -301,6 +301,71 @@ class AwsCompileFunctions {\n         }\n       }\n \n+      const fileSystemConfigs = functionObject.fileSystemConfigs;\n+\n+      // TODO: Simplify these conditions\n+      if (fileSystemConfigs && fileSystemConfigs.length !== 0) {\n+        if (fileSystemConfigs.length > 1) {\n+          // TODO: Add explanation - CloudFormation limitation\n+          const errorMessage = 'You can specify at most 1 fileSystemConfig';\n+          throw new this.serverless.classes.Error(errorMessage);",
        "comment_created_at": "2020-08-04T10:26:44+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's not put any validation here.\r\n\r\nWe've just added schema based config validation. So we should simply configure a JSON schema for those properties here: https://github.com/serverless/serverless/blob/d403d9c6d3dccdfc9f79d7c42b3cbc1a06fcfac0/lib/plugins/aws/provider/awsProvider.js#L145",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "471519068",
    "pr_number": 8042,
    "pr_file": "lib/plugins/aws/provider/awsProvider.js",
    "created_at": "2020-08-17T14:30:26+00:00",
    "commented_code": "serverless.configSchemaHandler.defineProvider('aws', {\n         function: {\n           // TODO: Complete schema, see https://github.com/serverless/serverless/issues/8017\n-          properties: { handler: { type: 'string' } },\n+          properties: {\n+            handler: { type: 'string' },\n+            fileSystemConfigs: {\n+              description:\n+                'Parameters describing connection between a Lambda function and an Amazon EFS file system',\n+              type: 'array',\n+              minItems: 1,",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "471519068",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8042,
        "pr_file": "lib/plugins/aws/provider/awsProvider.js",
        "discussion_id": "471519068",
        "commented_code": "@@ -142,7 +142,39 @@ class AwsProvider {\n       serverless.configSchemaHandler.defineProvider('aws', {\n         function: {\n           // TODO: Complete schema, see https://github.com/serverless/serverless/issues/8017\n-          properties: { handler: { type: 'string' } },\n+          properties: {\n+            handler: { type: 'string' },\n+            fileSystemConfigs: {\n+              description:\n+                'Parameters describing connection between a Lambda function and an Amazon EFS file system',\n+              type: 'array',\n+              minItems: 1,",
        "comment_created_at": "2020-08-17T14:30:26+00:00",
        "comment_author": "medikoo",
        "comment_body": "I think there's no need to limit that. We should treat an empty array as no EFS configured",
        "pr_file_module": null
      },
      {
        "comment_id": "473112886",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8042,
        "pr_file": "lib/plugins/aws/provider/awsProvider.js",
        "discussion_id": "471519068",
        "commented_code": "@@ -142,7 +142,39 @@ class AwsProvider {\n       serverless.configSchemaHandler.defineProvider('aws', {\n         function: {\n           // TODO: Complete schema, see https://github.com/serverless/serverless/issues/8017\n-          properties: { handler: { type: 'string' } },\n+          properties: {\n+            handler: { type: 'string' },\n+            fileSystemConfigs: {\n+              description:\n+                'Parameters describing connection between a Lambda function and an Amazon EFS file system',\n+              type: 'array',\n+              minItems: 1,",
        "comment_created_at": "2020-08-19T15:22:38+00:00",
        "comment_author": "pgrzesik",
        "comment_body": "Updated :+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "540038904",
    "pr_number": 8581,
    "pr_file": "lib/plugins/package/lib/packageService.js",
    "created_at": "2020-12-10T10:09:18+00:00",
    "commented_code": "],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "540038904",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-10T10:09:18+00:00",
        "comment_author": "medikoo",
        "comment_body": "I think we need to support both `include` and `patterns`, in a way I proposed in this comment: https://github.com/serverless/serverless/pull/8581#discussion_r538467304\r\n\r\nTechnically we stand between choice:\r\n1. If user provided `patterns`, throw if any `include` and `exclude` configurations are found\r\n2. Support all three\r\n\r\nI think it's easier (and not harmful) to support all three",
        "pr_file_module": null
      },
      {
        "comment_id": "540061946",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-10T10:41:11+00:00",
        "comment_author": "juanjoDiaz",
        "comment_body": "You also suggested to crash if both are used in comment: https://github.com/serverless/serverless/issues/8093#issuecomment-676003542 \ud83d\ude05\r\n\r\nThe problem of supporting both `include` and `patterns` is that the order in which they are appended becomes non-evident to the user and can cause tickets simply because the user expects a different order.\r\n\r\nThe current implementation support using `include/exclude` at the service level and `patterns` at the function level or viceversa. It errors if you use `include/exclude` and `patterns` in the same package object (done during the initialization validation).\r\n\r\nI think that it's safer to avoid user confusion.\r\n\r\nDo you still think that we should allow using both at the same time?",
        "pr_file_module": null
      },
      {
        "comment_id": "540895855",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-11T11:56:06+00:00",
        "comment_author": "medikoo",
        "comment_body": "> You also suggested to crash if both are used in comment: #8093 (comment) \ud83d\ude05\r\n\r\nThat's true. Sorry for confusion. At that point it was not deeply thought. Thing is that crashing is more obtrusive.\r\n\r\nFirstly the easy approach to this is to upfront investigate all `package` configs (service-level, function-level, layer-level) and crash if we find that there's `patterns` somewhere and `includes` or `excludes` elsewhere`, and that's aggressive if e.g. user is switching gradually, e.g. refactor first function one, check how it works and then refactor others. It'll be nice to not break that.\r\n\r\nNow trying to validate case by case, is confusing, as e.g. for function 1 config (which uses just `include` and `exclude`) may be valid and for function 2 (which uses just `patterns`) may be not (when on service level `include` or `exclude` is used)\r\n\r\nI assume it's not harmful to support all (user will always be approached with deprecation notice anyway), and implementation wise it's simplest approach.\r\n\r\n> The problem of supporting both include and patterns is that the order in which they are appended becomes non-evident to the user and can cause tickets simply because the user expects a different order.\r\n\r\nUser should not reason about order in such case, but simply ensure that just `patterns` is used , also again _deprecation_ notice will signal that config stands on quirky ground\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "540916837",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-11T12:36:14+00:00",
        "comment_author": "juanjoDiaz",
        "comment_body": "> Now trying to validate case by case, is confusing, as e.g. for function 1 config (which uses just include and exclude) may be valid and for function 2 (which uses just patterns) may be not (when on service level include or exclude is used)\r\n\r\nThat's not how it's implemented in this final version of the implementation. Function 1 and 2 will be valid in that example.\r\n\r\nFunction 3 which uses `patterns` and `exclude` under the same package object would be invalid.\r\nI.e, to get the error you need something like:\r\n```yaml\r\npackage:\r\n  patterns:\r\n    - my-file.js\r\n  include:\r\n    - my-other-file.js\r\n```\r\n\r\nI think that's reasonable. However, if you still disagree, let me know and I'll just remove it. I'm running out of the time I've allocated for this \ud83d\ude05",
        "pr_file_module": null
      },
      {
        "comment_id": "540982675",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-11T14:24:07+00:00",
        "comment_author": "medikoo",
        "comment_body": "> Function 1 and 2 will be valid in that example.\r\n\r\nI think if we invalidate it on function level, we should definitely also not support combining `include` and `exclude` on service level with `patterns` on function level. That would be even more confusing (what's the logical reason for rejecting just one case?)\r\n\r\nAnyway have you read the arguments I've put for supporting all without throwing (?) I take it's simplest thing we can do, and really not harmful",
        "pr_file_module": null
      },
      {
        "comment_id": "541013956",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-11T15:09:01+00:00",
        "comment_author": "juanjoDiaz",
        "comment_body": "I'm not sure if we are understanding each other completely or getting a bit tangled up. \ud83d\ude05\r\nThe validation for service level is exactly the same at the function level.\r\nLet's give it one more go and then do whatever change it needed \ud83d\ude04\r\n\r\nCurrently:\r\n* You can use `patterns` OR `include/exclude` at the service level.\r\n* You can use `patterns` OR `include/exclude` at the function level.\r\n* It doesn't matter if you use pattern in `patterns` at service and `include/exclude` at the function\r\n* It doesn't matter if you use pattern in `include/exclude` at service and `patterns` at the function\r\n* etc...\r\n\r\nThe only thing that fails, is to mix both `patterns` and `include/exclude` in the same config (regardless of whether it is in the service or function level).\r\n\r\nValid:\r\n```yaml\r\npackage:\r\n  patterns:\r\n    - my-file.js\r\n\r\nfunctions:\r\n  myFunction:\r\n    package:\r\n      include:\r\n        - my-other-file.js\r\n      exclude:\r\n        - my-exclude-file.js\r\n```\r\n\r\nValid:\r\n```yaml\r\npackage:\r\n  include:\r\n    - my-other-file.js\r\n  exclude:\r\n    - my-exclude-file.js\r\n\r\nfunctions:\r\n  myFunction:\r\n    patterns:\r\n      - my-file.js\r\n```\r\n\r\nValid:\r\n```yaml\r\npackage:\r\n  include:\r\n    - my-other-file.js\r\n  exclude:\r\n    - my-exclude-file.js\r\n\r\nfunctions:\r\n  myFunction:\r\n    patterns:\r\n      - my-file.js\r\n  myOtherFunction:\r\n    package:\r\n      include:\r\n        - my-other-file.js\r\n      exclude:\r\n        - my-exclude-file.js\r\n```\r\n\r\nThrows:\r\n```yaml\r\npackage:\r\n  patterns:\r\n    - my-file.js\r\n  include:\r\n    - my-other-file.js\r\n  exclude:\r\n    - my-exclude-file.js\r\n\r\nfunctions:\r\n  myFunction:\r\n    package:\r\n      include:\r\n        - my-other-file.js\r\n      exclude:\r\n        - my-exclude-file.js\r\n```\r\nThrows:\r\n```yaml\r\npackage:\r\n  patterns:\r\n    - my-file.js\r\n\r\nfunctions:\r\n  myFunction:\r\n    package:\r\n      patterns:\r\n        - my-file.js\r\n      include:\r\n        - my-other-file.js\r\n      exclude:\r\n        - my-exclude-file.js\r\n```\r\n\r\nJust repeating myself, the reason to not allow that merging is that service goes before package regardless of whether it's `patterns` or `include/exclude`. And `exclude` goes before `include`.\r\nHowever,  if we mix `include/exclude/pattern` in the same config. We need to decide in which order to merge them. \r\nIt's trivial, I know, `exclude -> include -> patterns`, but users might expect otherwise and create confusion.\r\n\r\n> User should not reason about order in such case, but simply ensure that just patterns is used , also again deprecation notice will signal that config stands on quirky ground\r\n\r\nThat's right! That's why I thought that all combinations should be allowed, except for the one that combines both in the same object.\r\n\r\nWas this already clear to you?",
        "pr_file_module": null
      },
      {
        "comment_id": "541034852",
        "repo_full_name": "serverless/serverless",
        "pr_number": 8581,
        "pr_file": "lib/plugins/package/lib/packageService.js",
        "discussion_id": "540038904",
        "commented_code": "@@ -18,7 +18,8 @@ module.exports = {\n   ],\n \n   getIncludes(include) {\n-    const packageIncludes = this.serverless.service.package.include || [];\n+    const packageIncludes =\n+      this.serverless.service.package.patterns || this.serverless.service.package.include || [];",
        "comment_created_at": "2020-12-11T15:37:48+00:00",
        "comment_author": "medikoo",
        "comment_body": "> You can use patterns OR include/exclude at the function level.\r\n> It doesn't matter if you use pattern in patterns at service and include/exclude at the function\r\n\r\nIn last comment, my point was that above feels confusing. If we already support mixing both `include` and `patterns` (coming from two configuration sources) to package given lambda, why restrict mixing of `include` and `patterns` coming from one configuration source.\r\n\r\n> However, if we mix include/exclude/pattern in the same config. We need to decide in which order to merge them.\r\n\r\nYes, I've proposed order in one of the first comments here: https://github.com/serverless/serverless/pull/8581#discussion_r538467304\r\n\r\n> It's trivial, I know, exclude -> include -> patterns, but users might expect otherwise and create confusion.\r\n\r\nUser should not investigate and debate on such order, instead should just use `pattern`. We'd allow mixing both sas temporary mean simply for ease of migration (no need to be too restrictive here)\r\n\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1190107108",
    "pr_number": 11935,
    "pr_file": "lib/plugins/aws/package/compile/events/schedule.js",
    "created_at": "2023-05-10T15:49:13+00:00",
    "commented_code": "required: ['inputTemplate'],\n               additionalProperties: false,\n             },\n+            method: {\n+              type: 'string',\n+              enum: ['eventBus'],\n+            },\n           },\n           required: ['rate'],\n           additionalProperties: false,\n         },\n+        {\n+          title: 'EventbridgeSchedulerSchedule',\n+          type: 'object',",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "1190107108",
        "repo_full_name": "serverless/serverless",
        "pr_number": 11935,
        "pr_file": "lib/plugins/aws/package/compile/events/schedule.js",
        "discussion_id": "1190107108",
        "commented_code": "@@ -75,10 +77,63 @@ class AwsCompileScheduledEvents {\n               required: ['inputTemplate'],\n               additionalProperties: false,\n             },\n+            method: {\n+              type: 'string',\n+              enum: ['eventBus'],\n+            },\n           },\n           required: ['rate'],\n           additionalProperties: false,\n         },\n+        {\n+          title: 'EventbridgeSchedulerSchedule',\n+          type: 'object',",
        "comment_created_at": "2023-05-10T15:49:13+00:00",
        "comment_author": "medikoo",
        "comment_body": "Let's not use different _object_ configurations, as they result with unspecific errors for user.\r\n\r\ne.g. if user misconfigures some property, in result will be presented with error message as: \"Unsupported configuration for 'schedule' event\" not providing a hint which property is misconfigured (it's due to fact that AJV will report validation errors for two object modes and we don't have any intelligent handling to decide which error information we should choose)\r\n\r\nSo let's pack all properties from both configuration modes under one `object` definition and in code introduce further distinction with meaningful validation error throwing if needed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "603868576",
    "pr_number": 9195,
    "pr_file": "lib/plugins/aws/package/compile/events/httpApi.js",
    "created_at": "2021-03-30T07:58:46+00:00",
    "commented_code": "authorizer: {\n               anyOf: [\n                 { type: 'string' },\n+                {\n+                  type: 'object',\n+                  properties: {\n+                    type: { const: 'aws_iam' },\n+                  },\n+                  additionalProperties: false,\n+                },",
    "repo_full_name": "serverless/serverless",
    "discussion_comments": [
      {
        "comment_id": "603868576",
        "repo_full_name": "serverless/serverless",
        "pr_number": 9195,
        "pr_file": "lib/plugins/aws/package/compile/events/httpApi.js",
        "discussion_id": "603868576",
        "commented_code": "@@ -81,6 +81,13 @@ class HttpApiEvents {\n             authorizer: {\n               anyOf: [\n                 { type: 'string' },\n+                {\n+                  type: 'object',\n+                  properties: {\n+                    type: { const: 'aws_iam' },\n+                  },\n+                  additionalProperties: false,\n+                },",
        "comment_created_at": "2021-03-30T07:58:46+00:00",
        "comment_author": "medikoo",
        "comment_body": "Configuring definition like that is slightly problematic as it'll trigger _vague_ mode for validation of other authorizers, as now any validation failure will now be reported simply with _\"Unsupported configuration format\"_ without providing a hint which exactly property is misconfigured.\r\n\r\nIt's due to fact that two versions for _object_ variant are provided, and validator won't know errors of which to report, hence it'll report just message that something is wrong.\r\n\r\n(you may also confirm on that manually).\r\n\r\nI think best way to recover is to use one object notation, and then inline ensure that for AWS IAM case it's just `type` property that provided, and throw meaningful error if any other properties are found",
        "pr_file_module": null
      },
      {
        "comment_id": "603919205",
        "repo_full_name": "serverless/serverless",
        "pr_number": 9195,
        "pr_file": "lib/plugins/aws/package/compile/events/httpApi.js",
        "discussion_id": "603868576",
        "commented_code": "@@ -81,6 +81,13 @@ class HttpApiEvents {\n             authorizer: {\n               anyOf: [\n                 { type: 'string' },\n+                {\n+                  type: 'object',\n+                  properties: {\n+                    type: { const: 'aws_iam' },\n+                  },\n+                  additionalProperties: false,\n+                },",
        "comment_created_at": "2021-03-30T09:08:13+00:00",
        "comment_author": "pgrzesik",
        "comment_body": "I've adjusted the schema so it should be able to accept all possible versions + added additional validation to ensure that we're working with valid configuration.",
        "pr_file_module": null
      }
    ]
  }
]