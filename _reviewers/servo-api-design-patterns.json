[
  {
    "discussion_id": "2326487590",
    "pr_number": 36616,
    "pr_file": "components/net/websocket_loader.rs",
    "created_at": "2025-09-06T04:23:35+00:00",
    "commented_code": "let socket = try_socket.map_err(Error::Io)?;\n     let connector = TlsConnector::from(Arc::new(tls_config));\n \n+    let mut url = client.url();\n+    if url.scheme() == \"https\" {\n+        url.as_mut_url()\n+            .set_scheme(\"wss\")\n+            .expect(\"Can't set scheme from https to wss\");\n+    } else {\n+        url.as_mut_url()\n+            .set_scheme(\"ws\")\n+            .expect(\"Can't set scheme from http to ws\");\n+    };\n+    // TODO(pylbrecht): move request conversion to a separate function\n+    let mut builder = ClientRequestBuilder::new(\n+        url.clone() // FIXME(pylbrecht): deal with clone()\n+            .into_string()\n+            .parse()\n+            .expect(\"unable to parse URI\"),\n+    );\n+    for (key, value) in client.headers.iter() {\n+        builder = builder.with_header(\n+            key.as_str(),\n+            value\n+                .to_str()\n+                .expect(\"unable to convert header value to string\"),\n+        );\n+    }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2326487590",
        "repo_full_name": "servo/servo",
        "pr_number": 36616,
        "pr_file": "components/net/websocket_loader.rs",
        "discussion_id": "2326487590",
        "commented_code": "@@ -331,8 +324,34 @@ async fn start_websocket(\n     let socket = try_socket.map_err(Error::Io)?;\n     let connector = TlsConnector::from(Arc::new(tls_config));\n \n+    let mut url = client.url();\n+    if url.scheme() == \"https\" {\n+        url.as_mut_url()\n+            .set_scheme(\"wss\")\n+            .expect(\"Can't set scheme from https to wss\");\n+    } else {\n+        url.as_mut_url()\n+            .set_scheme(\"ws\")\n+            .expect(\"Can't set scheme from http to ws\");\n+    };\n+    // TODO(pylbrecht): move request conversion to a separate function\n+    let mut builder = ClientRequestBuilder::new(\n+        url.clone() // FIXME(pylbrecht): deal with clone()\n+            .into_string()\n+            .parse()\n+            .expect(\"unable to parse URI\"),\n+    );\n+    for (key, value) in client.headers.iter() {\n+        builder = builder.with_header(\n+            key.as_str(),\n+            value\n+                .to_str()\n+                .expect(\"unable to convert header value to string\"),\n+        );\n+    }",
        "comment_created_at": "2025-09-06T04:23:35+00:00",
        "comment_author": "pylbrecht",
        "comment_body": "I thought about implementing [`IntoClientRequest`](https://docs.rs/tungstenite/0.27.0/tungstenite/client/trait.IntoClientRequest.html) for `net_traits::request::Request`, but I think that would require adding `async-tungstenite` to the `net_traits` crate. Though adding a dependency just for the sake of having a cleaner conversion is probably not worth it. A simple function performing the conversion might suffice here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2414703826",
        "repo_full_name": "servo/servo",
        "pr_number": 36616,
        "pr_file": "components/net/websocket_loader.rs",
        "discussion_id": "2326487590",
        "commented_code": "@@ -331,8 +324,34 @@ async fn start_websocket(\n     let socket = try_socket.map_err(Error::Io)?;\n     let connector = TlsConnector::from(Arc::new(tls_config));\n \n+    let mut url = client.url();\n+    if url.scheme() == \"https\" {\n+        url.as_mut_url()\n+            .set_scheme(\"wss\")\n+            .expect(\"Can't set scheme from https to wss\");\n+    } else {\n+        url.as_mut_url()\n+            .set_scheme(\"ws\")\n+            .expect(\"Can't set scheme from http to ws\");\n+    };\n+    // TODO(pylbrecht): move request conversion to a separate function\n+    let mut builder = ClientRequestBuilder::new(\n+        url.clone() // FIXME(pylbrecht): deal with clone()\n+            .into_string()\n+            .parse()\n+            .expect(\"unable to parse URI\"),\n+    );\n+    for (key, value) in client.headers.iter() {\n+        builder = builder.with_header(\n+            key.as_str(),\n+            value\n+                .to_str()\n+                .expect(\"unable to convert header value to string\"),\n+        );\n+    }",
        "comment_created_at": "2025-10-08T18:32:56+00:00",
        "comment_author": "jdm",
        "comment_body": "I don't think the tradeoff of trying to extract it is worth it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2415278677",
    "pr_number": 39719,
    "pr_file": "components/script/stylesheet_loader.rs",
    "created_at": "2025-10-09T00:14:50+00:00",
    "commented_code": "let win = element.owner_window();\n \n             let loader = ElementStylesheetLoader::new(&element);\n+            let shared_lock = document.style_shared_lock();\n+            let stylesheet = |media| {\n+                #[cfg(feature = \"tracing\")]\n+                let _span =\n+                    tracing::trace_span!(\"ParseStylesheet\", servo_profiling = true).entered();\n+                Arc::new(Stylesheet::from_bytes(\n+                    &data,\n+                    UrlExtraData(final_url.get_arc()),\n+                    protocol_encoding_label,\n+                    Some(environment_encoding),\n+                    Origin::Author,\n+                    media,",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2415278677",
        "repo_full_name": "servo/servo",
        "pr_number": 39719,
        "pr_file": "components/script/stylesheet_loader.rs",
        "discussion_id": "2415278677",
        "commented_code": "@@ -204,6 +206,24 @@ impl FetchResponseListener for StylesheetContext {\n             let win = element.owner_window();\n \n             let loader = ElementStylesheetLoader::new(&element);\n+            let shared_lock = document.style_shared_lock();\n+            let stylesheet = |media| {\n+                #[cfg(feature = \"tracing\")]\n+                let _span =\n+                    tracing::trace_span!(\"ParseStylesheet\", servo_profiling = true).entered();\n+                Arc::new(Stylesheet::from_bytes(\n+                    &data,\n+                    UrlExtraData(final_url.get_arc()),\n+                    protocol_encoding_label,\n+                    Some(environment_encoding),\n+                    Origin::Author,\n+                    media,",
        "comment_created_at": "2025-10-09T00:14:50+00:00",
        "comment_author": "nicoburns",
        "comment_body": "I would note that `Stylesheet::from_str` which is the variant of `Stylesheet::from_bytes` without encoding support (it assumes utf8) takes `Arc<Locked<MediaList>>` rather than `MediaList`. If `Stylesheet::from_bytes` did the same then you could avoid a deep clone and re-allocation of the media list.",
        "pr_file_module": null
      },
      {
        "comment_id": "2415920739",
        "repo_full_name": "servo/servo",
        "pr_number": 39719,
        "pr_file": "components/script/stylesheet_loader.rs",
        "discussion_id": "2415278677",
        "commented_code": "@@ -204,6 +206,24 @@ impl FetchResponseListener for StylesheetContext {\n             let win = element.owner_window();\n \n             let loader = ElementStylesheetLoader::new(&element);\n+            let shared_lock = document.style_shared_lock();\n+            let stylesheet = |media| {\n+                #[cfg(feature = \"tracing\")]\n+                let _span =\n+                    tracing::trace_span!(\"ParseStylesheet\", servo_profiling = true).entered();\n+                Arc::new(Stylesheet::from_bytes(\n+                    &data,\n+                    UrlExtraData(final_url.get_arc()),\n+                    protocol_encoding_label,\n+                    Some(environment_encoding),\n+                    Origin::Author,\n+                    media,",
        "comment_created_at": "2025-10-09T08:07:00+00:00",
        "comment_author": "Loirooriol",
        "comment_body": "Good point, I will address in a follow-up",
        "pr_file_module": null
      },
      {
        "comment_id": "2416942708",
        "repo_full_name": "servo/servo",
        "pr_number": 39719,
        "pr_file": "components/script/stylesheet_loader.rs",
        "discussion_id": "2415278677",
        "commented_code": "@@ -204,6 +206,24 @@ impl FetchResponseListener for StylesheetContext {\n             let win = element.owner_window();\n \n             let loader = ElementStylesheetLoader::new(&element);\n+            let shared_lock = document.style_shared_lock();\n+            let stylesheet = |media| {\n+                #[cfg(feature = \"tracing\")]\n+                let _span =\n+                    tracing::trace_span!(\"ParseStylesheet\", servo_profiling = true).entered();\n+                Arc::new(Stylesheet::from_bytes(\n+                    &data,\n+                    UrlExtraData(final_url.get_arc()),\n+                    protocol_encoding_label,\n+                    Some(environment_encoding),\n+                    Origin::Author,\n+                    media,",
        "comment_created_at": "2025-10-09T14:10:46+00:00",
        "comment_author": "Loirooriol",
        "comment_body": "For reference, https://github.com/servo/servo/pull/39731",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2213665588",
    "pr_number": 38112,
    "pr_file": "components/script/dom/transformstreamdefaultcontroller.rs",
    "created_at": "2025-07-17T15:27:11+00:00",
    "commented_code": "chunk: SafeHandleValue,\n         can_gc: CanGc,\n     ) -> Fallible<Rc<Promise>> {\n-        // If transformerDict[\"cancel\"] exists, set cancelAlgorithm to an algorithm which takes an argument\n-        // reason and returns the result of invoking transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb\n-        // and callback this value transformer.\n-        let algo = self.cancel.borrow().clone();\n-        let result = if let Some(cancel) = algo {\n-            rooted!(in(*cx) let this_object = self.transform_obj.get());\n-            let call_result = cancel.Call_(\n-                &this_object.handle(),\n-                chunk,\n-                ExceptionHandling::Rethrow,\n-                can_gc,\n-            );\n-            match call_result {\n-                Ok(p) => p,\n-                Err(e) => {\n-                    let p = Promise::new(global, can_gc);\n-                    p.reject_error(e, can_gc);\n-                    p\n-                },\n-            }\n-        } else {\n-            // Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n-            Promise::new_resolved(global, cx, (), can_gc)\n+        let result = match &self.transformer_type {\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Js {\n+                cancel,\n+                transform_obj,\n+                ..\n+            } => {\n+                // Step 7. If transformerDict[\"cancel\"] exists, set\n+                // cancelAlgorithm to an algorithm which takes an argument\n+                // reason and returns the result of invoking\n+                // transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb and\n+                // callback this value transformer.\n+                let algo = cancel.borrow().clone();\n+                if let Some(cancel) = algo {\n+                    rooted!(in(*cx) let this_object = transform_obj.get());\n+                    cancel\n+                        .Call_(\n+                            &this_object.handle(),\n+                            chunk,\n+                            ExceptionHandling::Rethrow,\n+                            can_gc,\n+                        )\n+                        .unwrap_or_else(|e| {\n+                            let p = Promise::new(global, can_gc);\n+                            p.reject_error(e, can_gc);\n+                            p\n+                        })\n+                } else {\n+                    // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n+                    Promise::new_resolved(global, cx, (), can_gc)\n+                }\n+            },\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Decoder(_) => {\n+                // `TextDecoderStream` does NOT specify a cancel algorithm.\n+                //\n+                // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2213665588",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/transformstreamdefaultcontroller.rs",
        "discussion_id": "2213665588",
        "commented_code": "@@ -207,29 +268,45 @@ impl TransformStreamDefaultController {\n         chunk: SafeHandleValue,\n         can_gc: CanGc,\n     ) -> Fallible<Rc<Promise>> {\n-        // If transformerDict[\"cancel\"] exists, set cancelAlgorithm to an algorithm which takes an argument\n-        // reason and returns the result of invoking transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb\n-        // and callback this value transformer.\n-        let algo = self.cancel.borrow().clone();\n-        let result = if let Some(cancel) = algo {\n-            rooted!(in(*cx) let this_object = self.transform_obj.get());\n-            let call_result = cancel.Call_(\n-                &this_object.handle(),\n-                chunk,\n-                ExceptionHandling::Rethrow,\n-                can_gc,\n-            );\n-            match call_result {\n-                Ok(p) => p,\n-                Err(e) => {\n-                    let p = Promise::new(global, can_gc);\n-                    p.reject_error(e, can_gc);\n-                    p\n-                },\n-            }\n-        } else {\n-            // Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n-            Promise::new_resolved(global, cx, (), can_gc)\n+        let result = match &self.transformer_type {\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Js {\n+                cancel,\n+                transform_obj,\n+                ..\n+            } => {\n+                // Step 7. If transformerDict[\"cancel\"] exists, set\n+                // cancelAlgorithm to an algorithm which takes an argument\n+                // reason and returns the result of invoking\n+                // transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb and\n+                // callback this value transformer.\n+                let algo = cancel.borrow().clone();\n+                if let Some(cancel) = algo {\n+                    rooted!(in(*cx) let this_object = transform_obj.get());\n+                    cancel\n+                        .Call_(\n+                            &this_object.handle(),\n+                            chunk,\n+                            ExceptionHandling::Rethrow,\n+                            can_gc,\n+                        )\n+                        .unwrap_or_else(|e| {\n+                            let p = Promise::new(global, can_gc);\n+                            p.reject_error(e, can_gc);\n+                            p\n+                        })\n+                } else {\n+                    // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n+                    Promise::new_resolved(global, cx, (), can_gc)\n+                }\n+            },\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Decoder(_) => {\n+                // `TextDecoderStream` does NOT specify a cancel algorithm.\n+                //\n+                // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.",
        "comment_created_at": "2025-07-17T15:27:11+00:00",
        "comment_author": "Taym95",
        "comment_body": "how come `TextDecoderStream` does not specify a cancel algorithm.` but we still have:\r\n\r\n```\r\nStep 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2213816815",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/transformstreamdefaultcontroller.rs",
        "discussion_id": "2213665588",
        "commented_code": "@@ -207,29 +268,45 @@ impl TransformStreamDefaultController {\n         chunk: SafeHandleValue,\n         can_gc: CanGc,\n     ) -> Fallible<Rc<Promise>> {\n-        // If transformerDict[\"cancel\"] exists, set cancelAlgorithm to an algorithm which takes an argument\n-        // reason and returns the result of invoking transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb\n-        // and callback this value transformer.\n-        let algo = self.cancel.borrow().clone();\n-        let result = if let Some(cancel) = algo {\n-            rooted!(in(*cx) let this_object = self.transform_obj.get());\n-            let call_result = cancel.Call_(\n-                &this_object.handle(),\n-                chunk,\n-                ExceptionHandling::Rethrow,\n-                can_gc,\n-            );\n-            match call_result {\n-                Ok(p) => p,\n-                Err(e) => {\n-                    let p = Promise::new(global, can_gc);\n-                    p.reject_error(e, can_gc);\n-                    p\n-                },\n-            }\n-        } else {\n-            // Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n-            Promise::new_resolved(global, cx, (), can_gc)\n+        let result = match &self.transformer_type {\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Js {\n+                cancel,\n+                transform_obj,\n+                ..\n+            } => {\n+                // Step 7. If transformerDict[\"cancel\"] exists, set\n+                // cancelAlgorithm to an algorithm which takes an argument\n+                // reason and returns the result of invoking\n+                // transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb and\n+                // callback this value transformer.\n+                let algo = cancel.borrow().clone();\n+                if let Some(cancel) = algo {\n+                    rooted!(in(*cx) let this_object = transform_obj.get());\n+                    cancel\n+                        .Call_(\n+                            &this_object.handle(),\n+                            chunk,\n+                            ExceptionHandling::Rethrow,\n+                            can_gc,\n+                        )\n+                        .unwrap_or_else(|e| {\n+                            let p = Promise::new(global, can_gc);\n+                            p.reject_error(e, can_gc);\n+                            p\n+                        })\n+                } else {\n+                    // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n+                    Promise::new_resolved(global, cx, (), can_gc)\n+                }\n+            },\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Decoder(_) => {\n+                // `TextDecoderStream` does NOT specify a cancel algorithm.\n+                //\n+                // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.",
        "comment_created_at": "2025-07-17T16:36:56+00:00",
        "comment_author": "gterzian",
        "comment_body": "Same here, \r\n\r\n```\r\n// <https://streams.spec.whatwg.org/#transformstream-set-up>\r\n// Let result be the result of running cancelAlgorithm given reason, if cancelAlgorithm was given, or null otherwise. \r\n// Note: `TextDecoderStream` does not specify a cancel algorithm.\r\n\r\n// If result is a Promise, then return result.\r\n// Note: not applicable. \r\n\r\n// Return a promise resolved with undefined.\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2215467763",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/transformstreamdefaultcontroller.rs",
        "discussion_id": "2213665588",
        "commented_code": "@@ -207,29 +268,45 @@ impl TransformStreamDefaultController {\n         chunk: SafeHandleValue,\n         can_gc: CanGc,\n     ) -> Fallible<Rc<Promise>> {\n-        // If transformerDict[\"cancel\"] exists, set cancelAlgorithm to an algorithm which takes an argument\n-        // reason and returns the result of invoking transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb\n-        // and callback this value transformer.\n-        let algo = self.cancel.borrow().clone();\n-        let result = if let Some(cancel) = algo {\n-            rooted!(in(*cx) let this_object = self.transform_obj.get());\n-            let call_result = cancel.Call_(\n-                &this_object.handle(),\n-                chunk,\n-                ExceptionHandling::Rethrow,\n-                can_gc,\n-            );\n-            match call_result {\n-                Ok(p) => p,\n-                Err(e) => {\n-                    let p = Promise::new(global, can_gc);\n-                    p.reject_error(e, can_gc);\n-                    p\n-                },\n-            }\n-        } else {\n-            // Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n-            Promise::new_resolved(global, cx, (), can_gc)\n+        let result = match &self.transformer_type {\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Js {\n+                cancel,\n+                transform_obj,\n+                ..\n+            } => {\n+                // Step 7. If transformerDict[\"cancel\"] exists, set\n+                // cancelAlgorithm to an algorithm which takes an argument\n+                // reason and returns the result of invoking\n+                // transformerDict[\"cancel\"] with argument list \u00ab reason \u00bb and\n+                // callback this value transformer.\n+                let algo = cancel.borrow().clone();\n+                if let Some(cancel) = algo {\n+                    rooted!(in(*cx) let this_object = transform_obj.get());\n+                    cancel\n+                        .Call_(\n+                            &this_object.handle(),\n+                            chunk,\n+                            ExceptionHandling::Rethrow,\n+                            can_gc,\n+                        )\n+                        .unwrap_or_else(|e| {\n+                            let p = Promise::new(global, can_gc);\n+                            p.reject_error(e, can_gc);\n+                            p\n+                        })\n+                } else {\n+                    // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.\n+                    Promise::new_resolved(global, cx, (), can_gc)\n+                }\n+            },\n+            // <https://streams.spec.whatwg.org/#set-up-transform-stream-default-controller-from-transformer>\n+            TransformerType::Decoder(_) => {\n+                // `TextDecoderStream` does NOT specify a cancel algorithm.\n+                //\n+                // Step 4. Let cancelAlgorithm be an algorithm which returns a promise resolved with undefined.",
        "comment_created_at": "2025-07-18T08:55:00+00:00",
        "comment_author": "minghuaw",
        "comment_body": "Added more spec steps in the documentation ([b857c0c](https://github.com/servo/servo/pull/38112/commits/b857c0c706d85f75a5b9de40b9daedfbf49c71f7))",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2381915898",
    "pr_number": 39483,
    "pr_file": "components/script/dom/element.rs",
    "created_at": "2025-09-26T10:38:03+00:00",
    "commented_code": "}\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#referrer-policy-attribute>\n pub(crate) fn reflect_referrer_policy_attribute(element: &Element) -> DOMString {\n-    let attr =\n-        element.get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")));\n-\n-    if let Some(mut val) = attr.map(|v| v.Value()) {\n-        val.make_ascii_lowercase();\n-        if val == \"no-referrer\" ||\n-            val == \"no-referrer-when-downgrade\" ||\n-            val == \"same-origin\" ||\n-            val == \"origin\" ||\n-            val == \"strict-origin\" ||\n-            val == \"origin-when-cross-origin\" ||\n-            val == \"strict-origin-when-cross-origin\" ||\n-            val == \"unsafe-url\"\n-        {\n-            return val;\n-        }\n+    match element\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| attr.value().to_ascii_lowercase())\n+    {\n+        Some(value) => {\n+            if value == \"no-referrer\" ||\n+                value == \"no-referrer-when-downgrade\" ||\n+                value == \"same-origin\" ||\n+                value == \"origin\" ||\n+                value == \"strict-origin\" ||\n+                value == \"origin-when-cross-origin\" ||\n+                value == \"strict-origin-when-cross-origin\" ||\n+                value == \"unsafe-url\"\n+            {\n+                DOMString::from(value)\n+            } else {\n+                DOMString::from(\"\")\n+            }\n+        },\n+        None => DOMString::from(\"\"),\n     }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2381915898",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2381915898",
        "commented_code": "@@ -5542,38 +5548,40 @@ pub(crate) fn set_cross_origin_attribute(\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#referrer-policy-attribute>\n pub(crate) fn reflect_referrer_policy_attribute(element: &Element) -> DOMString {\n-    let attr =\n-        element.get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")));\n-\n-    if let Some(mut val) = attr.map(|v| v.Value()) {\n-        val.make_ascii_lowercase();\n-        if val == \"no-referrer\" ||\n-            val == \"no-referrer-when-downgrade\" ||\n-            val == \"same-origin\" ||\n-            val == \"origin\" ||\n-            val == \"strict-origin\" ||\n-            val == \"origin-when-cross-origin\" ||\n-            val == \"strict-origin-when-cross-origin\" ||\n-            val == \"unsafe-url\"\n-        {\n-            return val;\n-        }\n+    match element\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| attr.value().to_ascii_lowercase())\n+    {\n+        Some(value) => {\n+            if value == \"no-referrer\" ||\n+                value == \"no-referrer-when-downgrade\" ||\n+                value == \"same-origin\" ||\n+                value == \"origin\" ||\n+                value == \"strict-origin\" ||\n+                value == \"origin-when-cross-origin\" ||\n+                value == \"strict-origin-when-cross-origin\" ||\n+                value == \"unsafe-url\"\n+            {\n+                DOMString::from(value)\n+            } else {\n+                DOMString::from(\"\")\n+            }\n+        },\n+        None => DOMString::from(\"\"),\n     }",
        "comment_created_at": "2025-09-26T10:38:03+00:00",
        "comment_author": "mrobinson",
        "comment_body": "```suggestion\r\n   element\r\n        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\r\n        .map(|attribute| {      \r\n           let value = attribute.value().to_ascii_lowercase())\r\n           if value == \"no-referrer\" ||\r\n                value == \"no-referrer-when-downgrade\" ||\r\n                value == \"same-origin\" ||\r\n                value == \"origin\" ||\r\n                value == \"strict-origin\" ||\r\n                value == \"origin-when-cross-origin\" ||\r\n                value == \"strict-origin-when-cross-origin\" ||\r\n                value == \"unsafe-url\"\r\n          {\r\n              DOMString::from(value)\r\n          } else {\r\n              DOMString::new()\r\n          }\r\n       }).unwrap_or_else(DOMString::new)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2382371230",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2381915898",
        "commented_code": "@@ -5542,38 +5548,40 @@ pub(crate) fn set_cross_origin_attribute(\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#referrer-policy-attribute>\n pub(crate) fn reflect_referrer_policy_attribute(element: &Element) -> DOMString {\n-    let attr =\n-        element.get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")));\n-\n-    if let Some(mut val) = attr.map(|v| v.Value()) {\n-        val.make_ascii_lowercase();\n-        if val == \"no-referrer\" ||\n-            val == \"no-referrer-when-downgrade\" ||\n-            val == \"same-origin\" ||\n-            val == \"origin\" ||\n-            val == \"strict-origin\" ||\n-            val == \"origin-when-cross-origin\" ||\n-            val == \"strict-origin-when-cross-origin\" ||\n-            val == \"unsafe-url\"\n-        {\n-            return val;\n-        }\n+    match element\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| attr.value().to_ascii_lowercase())\n+    {\n+        Some(value) => {\n+            if value == \"no-referrer\" ||\n+                value == \"no-referrer-when-downgrade\" ||\n+                value == \"same-origin\" ||\n+                value == \"origin\" ||\n+                value == \"strict-origin\" ||\n+                value == \"origin-when-cross-origin\" ||\n+                value == \"strict-origin-when-cross-origin\" ||\n+                value == \"unsafe-url\"\n+            {\n+                DOMString::from(value)\n+            } else {\n+                DOMString::from(\"\")\n+            }\n+        },\n+        None => DOMString::from(\"\"),\n     }",
        "comment_created_at": "2025-09-26T13:03:40+00:00",
        "comment_author": "tharkum",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2381923048",
    "pr_number": 39483,
    "pr_file": "components/script/dom/element.rs",
    "created_at": "2025-09-26T10:39:45+00:00",
    "commented_code": "}\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#referrer-policy-attribute>\n pub(crate) fn reflect_referrer_policy_attribute(element: &Element) -> DOMString {\n-    let attr =\n-        element.get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")));\n-\n-    if let Some(mut val) = attr.map(|v| v.Value()) {\n-        val.make_ascii_lowercase();\n-        if val == \"no-referrer\" ||\n-            val == \"no-referrer-when-downgrade\" ||\n-            val == \"same-origin\" ||\n-            val == \"origin\" ||\n-            val == \"strict-origin\" ||\n-            val == \"origin-when-cross-origin\" ||\n-            val == \"strict-origin-when-cross-origin\" ||\n-            val == \"unsafe-url\"\n-        {\n-            return val;\n-        }\n+    match element\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| attr.value().to_ascii_lowercase())\n+    {\n+        Some(value) => {\n+            if value == \"no-referrer\" ||\n+                value == \"no-referrer-when-downgrade\" ||\n+                value == \"same-origin\" ||\n+                value == \"origin\" ||\n+                value == \"strict-origin\" ||\n+                value == \"origin-when-cross-origin\" ||\n+                value == \"strict-origin-when-cross-origin\" ||\n+                value == \"unsafe-url\"\n+            {\n+                DOMString::from(value)\n+            } else {\n+                DOMString::from(\"\")\n+            }\n+        },\n+        None => DOMString::from(\"\"),\n     }\n-    DOMString::new()\n }\n \n pub(crate) fn referrer_policy_for_element(element: &Element) -> ReferrerPolicy {\n     element\n-        .get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")))\n-        .map(|attribute: DomRoot<Attr>| determine_policy_for_token(&attribute.Value()))\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| determine_policy_for_token(&attr.value()))",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2381923048",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2381923048",
        "commented_code": "@@ -5542,38 +5548,40 @@ pub(crate) fn set_cross_origin_attribute(\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#referrer-policy-attribute>\n pub(crate) fn reflect_referrer_policy_attribute(element: &Element) -> DOMString {\n-    let attr =\n-        element.get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")));\n-\n-    if let Some(mut val) = attr.map(|v| v.Value()) {\n-        val.make_ascii_lowercase();\n-        if val == \"no-referrer\" ||\n-            val == \"no-referrer-when-downgrade\" ||\n-            val == \"same-origin\" ||\n-            val == \"origin\" ||\n-            val == \"strict-origin\" ||\n-            val == \"origin-when-cross-origin\" ||\n-            val == \"strict-origin-when-cross-origin\" ||\n-            val == \"unsafe-url\"\n-        {\n-            return val;\n-        }\n+    match element\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| attr.value().to_ascii_lowercase())\n+    {\n+        Some(value) => {\n+            if value == \"no-referrer\" ||\n+                value == \"no-referrer-when-downgrade\" ||\n+                value == \"same-origin\" ||\n+                value == \"origin\" ||\n+                value == \"strict-origin\" ||\n+                value == \"origin-when-cross-origin\" ||\n+                value == \"strict-origin-when-cross-origin\" ||\n+                value == \"unsafe-url\"\n+            {\n+                DOMString::from(value)\n+            } else {\n+                DOMString::from(\"\")\n+            }\n+        },\n+        None => DOMString::from(\"\"),\n     }\n-    DOMString::new()\n }\n \n pub(crate) fn referrer_policy_for_element(element: &Element) -> ReferrerPolicy {\n     element\n-        .get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")))\n-        .map(|attribute: DomRoot<Attr>| determine_policy_for_token(&attribute.Value()))\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| determine_policy_for_token(&attr.value()))",
        "comment_created_at": "2025-09-26T10:39:45+00:00",
        "comment_author": "mrobinson",
        "comment_body": "```suggestion\r\n        .map(|attribute| determine_policy_for_token(&attribute.value()))\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2382370947",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2381923048",
        "commented_code": "@@ -5542,38 +5548,40 @@ pub(crate) fn set_cross_origin_attribute(\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#referrer-policy-attribute>\n pub(crate) fn reflect_referrer_policy_attribute(element: &Element) -> DOMString {\n-    let attr =\n-        element.get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")));\n-\n-    if let Some(mut val) = attr.map(|v| v.Value()) {\n-        val.make_ascii_lowercase();\n-        if val == \"no-referrer\" ||\n-            val == \"no-referrer-when-downgrade\" ||\n-            val == \"same-origin\" ||\n-            val == \"origin\" ||\n-            val == \"strict-origin\" ||\n-            val == \"origin-when-cross-origin\" ||\n-            val == \"strict-origin-when-cross-origin\" ||\n-            val == \"unsafe-url\"\n-        {\n-            return val;\n-        }\n+    match element\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| attr.value().to_ascii_lowercase())\n+    {\n+        Some(value) => {\n+            if value == \"no-referrer\" ||\n+                value == \"no-referrer-when-downgrade\" ||\n+                value == \"same-origin\" ||\n+                value == \"origin\" ||\n+                value == \"strict-origin\" ||\n+                value == \"origin-when-cross-origin\" ||\n+                value == \"strict-origin-when-cross-origin\" ||\n+                value == \"unsafe-url\"\n+            {\n+                DOMString::from(value)\n+            } else {\n+                DOMString::from(\"\")\n+            }\n+        },\n+        None => DOMString::from(\"\"),\n     }\n-    DOMString::new()\n }\n \n pub(crate) fn referrer_policy_for_element(element: &Element) -> ReferrerPolicy {\n     element\n-        .get_attribute_by_name(DOMString::from_string(String::from(\"referrerpolicy\")))\n-        .map(|attribute: DomRoot<Attr>| determine_policy_for_token(&attribute.Value()))\n+        .get_attribute(&ns!(), &local_name!(\"referrerpolicy\"))\n+        .map(|attr| determine_policy_for_token(&attr.value()))",
        "comment_created_at": "2025-09-26T13:03:34+00:00",
        "comment_author": "tharkum",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2381939064",
    "pr_number": 39483,
    "pr_file": "components/script/dom/document.rs",
    "created_at": "2025-09-26T10:43:20+00:00",
    "commented_code": "}\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#cors-settings-attributes>\n+pub(crate) fn determine_cors_setting_for_token(token: &str) -> CorsSettings {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => CorsSettings::Anonymous,\n+        \"use-credentials\" => CorsSettings::UseCredentials,\n+        _ => CorsSettings::Anonymous,\n+    }\n+}\n+",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2381939064",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2381939064",
        "commented_code": "@@ -5961,6 +5961,15 @@ fn update_with_current_instant(marker: &Cell<Option<CrossProcessInstant>>) {\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#cors-settings-attributes>\n+pub(crate) fn determine_cors_setting_for_token(token: &str) -> CorsSettings {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => CorsSettings::Anonymous,\n+        \"use-credentials\" => CorsSettings::UseCredentials,\n+        _ => CorsSettings::Anonymous,\n+    }\n+}\n+",
        "comment_created_at": "2025-09-26T10:43:20+00:00",
        "comment_author": "mrobinson",
        "comment_body": "It probably makes sense to make this an  implementation of `From<&str>` in `components/shared/net/request.rs` where `CorsSettings` is defined. Is there some reason why `document.rs` makes sense versus anywhere else?",
        "pr_file_module": null
      },
      {
        "comment_id": "2382044295",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2381939064",
        "commented_code": "@@ -5961,6 +5961,15 @@ fn update_with_current_instant(marker: &Cell<Option<CrossProcessInstant>>) {\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#cors-settings-attributes>\n+pub(crate) fn determine_cors_setting_for_token(token: &str) -> CorsSettings {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => CorsSettings::Anonymous,\n+        \"use-credentials\" => CorsSettings::UseCredentials,\n+        _ => CorsSettings::Anonymous,\n+    }\n+}\n+",
        "comment_created_at": "2025-09-26T11:16:11+00:00",
        "comment_author": "tharkum",
        "comment_body": "It is specific conversion  from content attribute's value to CORS setting.\r\nAs it was find out in https://github.com/servo/servo/pull/39483#issuecomment-3337021989 there is different version for 'link' processing HTTP headers, so I suggest to keep it as standalone function.",
        "pr_file_module": null
      },
      {
        "comment_id": "2382097803",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2381939064",
        "commented_code": "@@ -5961,6 +5961,15 @@ fn update_with_current_instant(marker: &Cell<Option<CrossProcessInstant>>) {\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#cors-settings-attributes>\n+pub(crate) fn determine_cors_setting_for_token(token: &str) -> CorsSettings {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => CorsSettings::Anonymous,\n+        \"use-credentials\" => CorsSettings::UseCredentials,\n+        _ => CorsSettings::Anonymous,\n+    }\n+}\n+",
        "comment_created_at": "2025-09-26T11:32:47+00:00",
        "comment_author": "mrobinson",
        "comment_body": "If it is specific, then please add it to an `impl` block with a name like `fn from_enumerated_attribute(attribute: &str) -> Self`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2382237484",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2381939064",
        "commented_code": "@@ -5961,6 +5961,15 @@ fn update_with_current_instant(marker: &Cell<Option<CrossProcessInstant>>) {\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#cors-settings-attributes>\n+pub(crate) fn determine_cors_setting_for_token(token: &str) -> CorsSettings {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => CorsSettings::Anonymous,\n+        \"use-credentials\" => CorsSettings::UseCredentials,\n+        _ => CorsSettings::Anonymous,\n+    }\n+}\n+",
        "comment_created_at": "2025-09-26T12:16:26+00:00",
        "comment_author": "tharkum",
        "comment_body": "You mean as `CorsSettings::from_enumerated_attribute()`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2382370164",
        "repo_full_name": "servo/servo",
        "pr_number": 39483,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2381939064",
        "commented_code": "@@ -5961,6 +5961,15 @@ fn update_with_current_instant(marker: &Cell<Option<CrossProcessInstant>>) {\n     }\n }\n \n+/// <https://html.spec.whatwg.org/multipage/#cors-settings-attributes>\n+pub(crate) fn determine_cors_setting_for_token(token: &str) -> CorsSettings {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => CorsSettings::Anonymous,\n+        \"use-credentials\" => CorsSettings::UseCredentials,\n+        _ => CorsSettings::Anonymous,\n+    }\n+}\n+",
        "comment_created_at": "2025-09-26T13:03:18+00:00",
        "comment_author": "tharkum",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2384262712",
    "pr_number": 39052,
    "pr_file": "components/script/dom/processingoptions.rs",
    "created_at": "2025-09-27T17:55:07+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::str::FromStr;\n+\n+use base::id::WebViewId;\n+use cssparser::match_ignore_ascii_case;\n+use http::header::HeaderMap;\n+use hyper_serde::Serde;\n+use mime::Mime;\n+use net_traits::fetch::headers::get_decode_and_split_header_name;\n+use net_traits::mime_classifier::{MediaType, MimeClassifier};\n+use net_traits::policy_container::PolicyContainer;\n+use net_traits::request::{\n+    CorsSettings, Destination, Initiator, InsecureRequestsPolicy, Referrer, RequestBuilder,\n+    RequestId,\n+};\n+use net_traits::{\n+    FetchMetadata, FetchResponseListener, NetworkError, ReferrerPolicy, ResourceFetchTiming,\n+    ResourceTimingType,\n+};\n+pub use nom_rfc8288::complete::LinkDataOwned as LinkHeader;\n+use nom_rfc8288::complete::link_lenient as parse_link_header;\n+use servo_url::{ImmutableOrigin, ServoUrl};\n+use strum_macros::IntoStaticStr;\n+\n+use crate::dom::bindings::inheritance::Castable;\n+use crate::dom::bindings::refcounted::Trusted;\n+use crate::dom::bindings::reflector::DomGlobal;\n+use crate::dom::bindings::root::DomRoot;\n+use crate::dom::csp::{GlobalCspReporting, Violation};\n+use crate::dom::document::{Document, determine_policy_for_token};\n+use crate::dom::element::Element;\n+use crate::dom::globalscope::GlobalScope;\n+use crate::dom::medialist::MediaList;\n+use crate::dom::performanceresourcetiming::InitiatorType;\n+use crate::dom::types::HTMLLinkElement;\n+use crate::fetch::create_a_potential_cors_request;\n+use crate::network_listener::{PreInvoke, ResourceTimingListener, submit_timing};\n+use crate::script_runtime::CanGc;\n+\n+trait ValueForKeyInLinkHeader {\n+    fn has_key_in_link_header(&self, key: &str) -> bool;\n+    fn value_for_key_in_link_header(&self, key: &str) -> Option<&str>;\n+}\n+\n+impl ValueForKeyInLinkHeader for LinkHeader {\n+    fn has_key_in_link_header(&self, key: &str) -> bool {\n+        self.params.iter().any(|p| p.key == key)\n+    }\n+    fn value_for_key_in_link_header(&self, key: &str) -> Option<&str> {\n+        let param = self.params.iter().find(|p| p.key == key)?;\n+        param.val.as_deref()\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+pub(crate) enum LinkProcessingPhase {\n+    Media,\n+    PreMedia,\n+}\n+\n+/// <https://html.spec.whatwg.org/multipage/#link-processing-options>\n+#[derive(Debug)]\n+pub(crate) struct LinkProcessingOptions {\n+    pub(crate) href: String,\n+    pub(crate) destination: Option<Destination>,\n+    pub(crate) integrity: String,\n+    pub(crate) link_type: String,\n+    pub(crate) cryptographic_nonce_metadata: String,\n+    pub(crate) cross_origin: Option<CorsSettings>,\n+    pub(crate) referrer_policy: ReferrerPolicy,\n+    pub(crate) policy_container: PolicyContainer,\n+    pub(crate) source_set: Option<()>,\n+    pub(crate) base_url: ServoUrl,\n+    pub(crate) origin: ImmutableOrigin,\n+    pub(crate) insecure_requests_policy: InsecureRequestsPolicy,\n+    pub(crate) has_trustworthy_ancestor_origin: bool,\n+    // Some fields that we don't need yet are missing\n+}\n+\n+impl LinkProcessingOptions {\n+    /// <https://html.spec.whatwg.org/multipage/#apply-link-options-from-parsed-header-attributes>\n+    fn apply_link_options_from_parsed_header(&mut self, link_object: &LinkHeader) {\n+        // Step 1. If attribs[\"as\"] exists, then set options's destination to the result of translating attribs[\"as\"].\n+        if let Some(as_) = link_object.value_for_key_in_link_header(\"as\") {\n+            self.destination = Some(Self::translate_a_preload_destination(as_));\n+        }\n+        // Step 2. If attribs[\"crossorigin\"] exists and is an ASCII case-insensitive match for one of the\n+        // CORS settings attribute keywords, then set options's crossorigin to the CORS settings attribute\n+        // state corresponding to that keyword.\n+        if let Some(cross_origin) = link_object.value_for_key_in_link_header(\"crossorigin\") {\n+            self.cross_origin = determine_cors_settings_for_token(cross_origin);\n+        }\n+        // Step 3. If attribs[\"integrity\"] exists, then set options's integrity to attribs[\"integrity\"].\n+        if let Some(integrity) = link_object.value_for_key_in_link_header(\"integrity\") {\n+            self.integrity = integrity.to_owned();\n+        }\n+        // Step 4. If attribs[\"referrerpolicy\"] exists and is an ASCII case-insensitive match for\n+        // some referrer policy, then set options's referrer policy to that referrer policy.\n+        if let Some(referrer_policy) = link_object.value_for_key_in_link_header(\"referrerpolicy\") {\n+            self.referrer_policy = determine_policy_for_token(referrer_policy);\n+        }\n+        // Step 5. If attribs[\"nonce\"] exists, then set options's nonce to attribs[\"nonce\"].\n+        if let Some(nonce) = link_object.value_for_key_in_link_header(\"nonce\") {\n+            self.cryptographic_nonce_metadata = nonce.to_owned();\n+        }\n+        // Step 6. If attribs[\"type\"] exists, then set options's type to attribs[\"type\"].\n+        if let Some(link_type) = link_object.value_for_key_in_link_header(\"type\") {\n+            self.link_type = link_type.to_owned();\n+        }\n+        // Step 7. If attribs[\"fetchpriority\"] exists and is an ASCII case-insensitive match\n+        // for a fetch priority attribute keyword, then set options's fetch priority to that\n+        // fetch priority attribute keyword.\n+        // TODO\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#process-a-link-header>\n+    fn process_link_header(self, rel: &str, document: &Document) {\n+        if rel == \"preload\" {\n+            // https://html.spec.whatwg.org/multipage/#link-type-preload:process-a-link-header\n+            // The process a link header step for this type of link given a link processing options options\n+            // is to preload options.\n+            if !self.type_matches_destination() {\n+                return;\n+            }\n+            let Some(request) = self.preload(document.window().webview_id()) else {\n+                return;\n+            };\n+            let url = request.url.clone();\n+            let fetch_context = LinkFetchContext {\n+                url,\n+                link: None,\n+                global: Trusted::new(&document.global()),\n+                resource_timing: ResourceFetchTiming::new(ResourceTimingType::Resource),\n+                type_: LinkFetchContextType::Preload,\n+            };\n+            document.fetch_background(request, fetch_context);\n+        }\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#translate-a-preload-destination>\n+    pub(crate) fn translate_a_preload_destination(potential_destination: &str) -> Destination {\n+        match potential_destination {\n+            \"fetch\" => Destination::None,\n+            \"font\" => Destination::Font,\n+            \"image\" => Destination::Image,\n+            \"script\" => Destination::Script,\n+            \"track\" => Destination::Track,\n+            _ => Destination::None,\n+        }\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#create-a-link-request>\n+    pub(crate) fn create_link_request(self, webview_id: WebViewId) -> Option<RequestBuilder> {\n+        // Step 1. Assert: options's href is not the empty string.\n+        assert!(!self.href.is_empty());\n+\n+        // Step 2. If options's destination is null, then return null.\n+        let destination = self.destination?;\n+\n+        // Step 3. Let url be the result of encoding-parsing a URL given options's href, relative to options's base URL.\n+        let Ok(url) = ServoUrl::parse_with_base(Some(&self.base_url), &self.href) else {\n+            // Step 4. If url is failure, then return null.\n+            return None;\n+        };\n+\n+        // Step 5. Let request be the result of creating a potential-CORS request given\n+        //         url, options's destination, and options's crossorigin.\n+        // Step 6. Set request's policy container to options's policy container.\n+        // Step 7. Set request's integrity metadata to options's integrity.\n+        // Step 8. Set request's cryptographic nonce metadata to options's cryptographic nonce metadata.\n+        // Step 9. Set request's referrer policy to options's referrer policy.\n+        // FIXME: Step 10. Set request's client to options's environment.\n+        // FIXME: Step 11. Set request's priority to options's fetch priority.\n+        // FIXME: Use correct referrer\n+        let builder = create_a_potential_cors_request(\n+            Some(webview_id),\n+            url,\n+            destination,\n+            self.cross_origin,\n+            None,\n+            Referrer::NoReferrer,\n+            self.insecure_requests_policy,\n+            self.has_trustworthy_ancestor_origin,\n+            self.policy_container,\n+        )\n+        .initiator(Initiator::Link)\n+        .origin(self.origin)\n+        .integrity_metadata(self.integrity)\n+        .cryptographic_nonce_metadata(self.cryptographic_nonce_metadata)\n+        .referrer_policy(self.referrer_policy);\n+\n+        // Step 12. Return request.\n+        Some(builder)\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#match-preload-type>\n+    pub(crate) fn type_matches_destination(&self) -> bool {\n+        // Step 1. If type is an empty string, then return true.\n+        if self.link_type.is_empty() {\n+            return true;\n+        }\n+        // Step 2. If destination is \"fetch\", then return true.\n+        //\n+        // Fetch is handled as an empty string destination in the spec:\n+        // https://fetch.spec.whatwg.org/#concept-potential-destination-translate\n+        let Some(destination) = self.destination else {\n+            return false;\n+        };\n+        if destination == Destination::None {\n+            return true;\n+        }\n+        // Step 3. Let mimeTypeRecord be the result of parsing type.\n+        let Ok(mime_type_record) = Mime::from_str(&self.link_type) else {\n+            // Step 4. If mimeTypeRecord is failure, then return false.\n+            return false;\n+        };\n+        // Step 5. If mimeTypeRecord is not supported by the user agent, then return false.\n+        //\n+        // We currently don't check if we actually support the mime type. Only if we can classify\n+        // it according to the spec.\n+        let Some(mime_type) = MimeClassifier::get_media_type(&mime_type_record) else {\n+            return false;\n+        };\n+        // Step 6. If any of the following are true:\n+        if\n+        // destination is \"audio\" or \"video\", and mimeTypeRecord is an audio or video MIME type;\n+        ((destination == Destination::Audio || destination == Destination::Video) &&\n+            mime_type == MediaType::AudioVideo)\n+            // destination is a script-like destination and mimeTypeRecord is a JavaScript MIME type;\n+            || (destination.is_script_like() && mime_type == MediaType::JavaScript)\n+            // destination is \"image\" and mimeTypeRecord is an image MIME type;\n+            || (destination == Destination::Image && mime_type == MediaType::Image)\n+            // destination is \"font\" and mimeTypeRecord is a font MIME type;\n+            || (destination == Destination::Font && mime_type == MediaType::Font)\n+            // destination is \"json\" and mimeTypeRecord is a JSON MIME type;\n+            || (destination == Destination::Json && mime_type == MediaType::Json)\n+            // destination is \"style\" and mimeTypeRecord's essence is text/css; or\n+            || (destination == Destination::Style && mime_type_record == mime::TEXT_CSS)\n+            // destination is \"track\" and mimeTypeRecord's essence is text/vtt,\n+            || (destination == Destination::Track && mime_type_record.essence_str() == \"text/vtt\")\n+        {\n+            // then return true.\n+            return true;\n+        }\n+        // Step 7. Return false.\n+        false\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#preload>\n+    pub(crate) fn preload(self, webview_id: WebViewId) -> Option<RequestBuilder> {\n+        // Step 1. If options's type doesn't match options's destination, then return.\n+        //\n+        // Handled by callers, since we need to check the previous destination type\n+        assert!(self.type_matches_destination());\n+        // Step 2. If options's destination is \"image\" and options's source set is not null,\n+        // then set options's href to the result of selecting an image source from options's source set.\n+        // TODO\n+        // Step 3. Let request be the result of creating a link request given options.\n+        let Some(request) = self.create_link_request(webview_id) else {\n+            // Step 4. If request is null, then return.\n+            return None;\n+        };\n+        // Step 5. Let unsafeEndTime be 0.\n+        // TODO\n+        // Step 6. Let entry be a new preload entry whose integrity metadata is options's integrity.\n+        // TODO\n+        // Step 7. Let key be the result of creating a preload key given request.\n+        // TODO\n+        // Step 8. If options's document is \"pending\", then set request's initiator type to \"early hint\".\n+        // TODO\n+        // Step 9. Let controller be null.\n+        // Step 10. Let reportTiming given a Document document be to report timing for controller\n+        // given document's relevant global object.\n+        // Step 11. Set controller to the result of fetching request, with processResponseConsumeBody\n+        // set to the following steps given a response response and null, failure, or a byte sequence bodyBytes:\n+        Some(request.clone())\n+    }\n+}\n+\n+pub(crate) fn determine_cors_settings_for_token(token: &str) -> Option<CorsSettings> {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => Some(CorsSettings::Anonymous),\n+        \"use-credentials\" => Some(CorsSettings::UseCredentials),\n+        _ => None,\n+    }\n+}\n+\n+/// <https://html.spec.whatwg.org/multipage/#extract-links-from-headers>\n+pub(crate) fn extract_links_from_headers(headers: &Option<Serde<HeaderMap>>) -> Vec<LinkHeader> {\n+    // Step 1. Let links be a new list.\n+    let mut links = Vec::new();\n+    let Some(headers) = headers else {\n+        return links;\n+    };\n+    // Step 2. Let rawLinkHeaders be the result of getting, decoding, and splitting `Link` from headers.\n+    let Some(raw_link_headers) = get_decode_and_split_header_name(\"Link\", headers) else {\n+        return links;\n+    };\n+    // Step 3. For each linkHeader of rawLinkHeaders:\n+    for link_header in raw_link_headers {\n+        // Step 3.1. Let linkObject be the result of parsing linkHeader. [WEBLINK]\n+        let Ok(parsed_link_header) = parse_link_header(&link_header) else {\n+            continue;\n+        };\n+        for link_object in parsed_link_header {\n+            let Some(link_object) = link_object else {\n+                // Step 3.2. If linkObject[\"target_uri\"] does not exist, then continue.\n+                continue;\n+            };\n+            // Step 3.3. Append linkObject to links.\n+            links.push(link_object.to_owned());\n+        }\n+    }\n+    // Step 4. Return links.\n+    links\n+}\n+\n+/// <https://html.spec.whatwg.org/multipage/#process-link-headers>\n+pub(crate) fn process_link_headers(\n+    link_headers: &Vec<LinkHeader>,",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2384262712",
        "repo_full_name": "servo/servo",
        "pr_number": 39052,
        "pr_file": "components/script/dom/processingoptions.rs",
        "discussion_id": "2384262712",
        "commented_code": "@@ -0,0 +1,482 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::str::FromStr;\n+\n+use base::id::WebViewId;\n+use cssparser::match_ignore_ascii_case;\n+use http::header::HeaderMap;\n+use hyper_serde::Serde;\n+use mime::Mime;\n+use net_traits::fetch::headers::get_decode_and_split_header_name;\n+use net_traits::mime_classifier::{MediaType, MimeClassifier};\n+use net_traits::policy_container::PolicyContainer;\n+use net_traits::request::{\n+    CorsSettings, Destination, Initiator, InsecureRequestsPolicy, Referrer, RequestBuilder,\n+    RequestId,\n+};\n+use net_traits::{\n+    FetchMetadata, FetchResponseListener, NetworkError, ReferrerPolicy, ResourceFetchTiming,\n+    ResourceTimingType,\n+};\n+pub use nom_rfc8288::complete::LinkDataOwned as LinkHeader;\n+use nom_rfc8288::complete::link_lenient as parse_link_header;\n+use servo_url::{ImmutableOrigin, ServoUrl};\n+use strum_macros::IntoStaticStr;\n+\n+use crate::dom::bindings::inheritance::Castable;\n+use crate::dom::bindings::refcounted::Trusted;\n+use crate::dom::bindings::reflector::DomGlobal;\n+use crate::dom::bindings::root::DomRoot;\n+use crate::dom::csp::{GlobalCspReporting, Violation};\n+use crate::dom::document::{Document, determine_policy_for_token};\n+use crate::dom::element::Element;\n+use crate::dom::globalscope::GlobalScope;\n+use crate::dom::medialist::MediaList;\n+use crate::dom::performanceresourcetiming::InitiatorType;\n+use crate::dom::types::HTMLLinkElement;\n+use crate::fetch::create_a_potential_cors_request;\n+use crate::network_listener::{PreInvoke, ResourceTimingListener, submit_timing};\n+use crate::script_runtime::CanGc;\n+\n+trait ValueForKeyInLinkHeader {\n+    fn has_key_in_link_header(&self, key: &str) -> bool;\n+    fn value_for_key_in_link_header(&self, key: &str) -> Option<&str>;\n+}\n+\n+impl ValueForKeyInLinkHeader for LinkHeader {\n+    fn has_key_in_link_header(&self, key: &str) -> bool {\n+        self.params.iter().any(|p| p.key == key)\n+    }\n+    fn value_for_key_in_link_header(&self, key: &str) -> Option<&str> {\n+        let param = self.params.iter().find(|p| p.key == key)?;\n+        param.val.as_deref()\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+pub(crate) enum LinkProcessingPhase {\n+    Media,\n+    PreMedia,\n+}\n+\n+/// <https://html.spec.whatwg.org/multipage/#link-processing-options>\n+#[derive(Debug)]\n+pub(crate) struct LinkProcessingOptions {\n+    pub(crate) href: String,\n+    pub(crate) destination: Option<Destination>,\n+    pub(crate) integrity: String,\n+    pub(crate) link_type: String,\n+    pub(crate) cryptographic_nonce_metadata: String,\n+    pub(crate) cross_origin: Option<CorsSettings>,\n+    pub(crate) referrer_policy: ReferrerPolicy,\n+    pub(crate) policy_container: PolicyContainer,\n+    pub(crate) source_set: Option<()>,\n+    pub(crate) base_url: ServoUrl,\n+    pub(crate) origin: ImmutableOrigin,\n+    pub(crate) insecure_requests_policy: InsecureRequestsPolicy,\n+    pub(crate) has_trustworthy_ancestor_origin: bool,\n+    // Some fields that we don't need yet are missing\n+}\n+\n+impl LinkProcessingOptions {\n+    /// <https://html.spec.whatwg.org/multipage/#apply-link-options-from-parsed-header-attributes>\n+    fn apply_link_options_from_parsed_header(&mut self, link_object: &LinkHeader) {\n+        // Step 1. If attribs[\"as\"] exists, then set options's destination to the result of translating attribs[\"as\"].\n+        if let Some(as_) = link_object.value_for_key_in_link_header(\"as\") {\n+            self.destination = Some(Self::translate_a_preload_destination(as_));\n+        }\n+        // Step 2. If attribs[\"crossorigin\"] exists and is an ASCII case-insensitive match for one of the\n+        // CORS settings attribute keywords, then set options's crossorigin to the CORS settings attribute\n+        // state corresponding to that keyword.\n+        if let Some(cross_origin) = link_object.value_for_key_in_link_header(\"crossorigin\") {\n+            self.cross_origin = determine_cors_settings_for_token(cross_origin);\n+        }\n+        // Step 3. If attribs[\"integrity\"] exists, then set options's integrity to attribs[\"integrity\"].\n+        if let Some(integrity) = link_object.value_for_key_in_link_header(\"integrity\") {\n+            self.integrity = integrity.to_owned();\n+        }\n+        // Step 4. If attribs[\"referrerpolicy\"] exists and is an ASCII case-insensitive match for\n+        // some referrer policy, then set options's referrer policy to that referrer policy.\n+        if let Some(referrer_policy) = link_object.value_for_key_in_link_header(\"referrerpolicy\") {\n+            self.referrer_policy = determine_policy_for_token(referrer_policy);\n+        }\n+        // Step 5. If attribs[\"nonce\"] exists, then set options's nonce to attribs[\"nonce\"].\n+        if let Some(nonce) = link_object.value_for_key_in_link_header(\"nonce\") {\n+            self.cryptographic_nonce_metadata = nonce.to_owned();\n+        }\n+        // Step 6. If attribs[\"type\"] exists, then set options's type to attribs[\"type\"].\n+        if let Some(link_type) = link_object.value_for_key_in_link_header(\"type\") {\n+            self.link_type = link_type.to_owned();\n+        }\n+        // Step 7. If attribs[\"fetchpriority\"] exists and is an ASCII case-insensitive match\n+        // for a fetch priority attribute keyword, then set options's fetch priority to that\n+        // fetch priority attribute keyword.\n+        // TODO\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#process-a-link-header>\n+    fn process_link_header(self, rel: &str, document: &Document) {\n+        if rel == \"preload\" {\n+            // https://html.spec.whatwg.org/multipage/#link-type-preload:process-a-link-header\n+            // The process a link header step for this type of link given a link processing options options\n+            // is to preload options.\n+            if !self.type_matches_destination() {\n+                return;\n+            }\n+            let Some(request) = self.preload(document.window().webview_id()) else {\n+                return;\n+            };\n+            let url = request.url.clone();\n+            let fetch_context = LinkFetchContext {\n+                url,\n+                link: None,\n+                global: Trusted::new(&document.global()),\n+                resource_timing: ResourceFetchTiming::new(ResourceTimingType::Resource),\n+                type_: LinkFetchContextType::Preload,\n+            };\n+            document.fetch_background(request, fetch_context);\n+        }\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#translate-a-preload-destination>\n+    pub(crate) fn translate_a_preload_destination(potential_destination: &str) -> Destination {\n+        match potential_destination {\n+            \"fetch\" => Destination::None,\n+            \"font\" => Destination::Font,\n+            \"image\" => Destination::Image,\n+            \"script\" => Destination::Script,\n+            \"track\" => Destination::Track,\n+            _ => Destination::None,\n+        }\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#create-a-link-request>\n+    pub(crate) fn create_link_request(self, webview_id: WebViewId) -> Option<RequestBuilder> {\n+        // Step 1. Assert: options's href is not the empty string.\n+        assert!(!self.href.is_empty());\n+\n+        // Step 2. If options's destination is null, then return null.\n+        let destination = self.destination?;\n+\n+        // Step 3. Let url be the result of encoding-parsing a URL given options's href, relative to options's base URL.\n+        let Ok(url) = ServoUrl::parse_with_base(Some(&self.base_url), &self.href) else {\n+            // Step 4. If url is failure, then return null.\n+            return None;\n+        };\n+\n+        // Step 5. Let request be the result of creating a potential-CORS request given\n+        //         url, options's destination, and options's crossorigin.\n+        // Step 6. Set request's policy container to options's policy container.\n+        // Step 7. Set request's integrity metadata to options's integrity.\n+        // Step 8. Set request's cryptographic nonce metadata to options's cryptographic nonce metadata.\n+        // Step 9. Set request's referrer policy to options's referrer policy.\n+        // FIXME: Step 10. Set request's client to options's environment.\n+        // FIXME: Step 11. Set request's priority to options's fetch priority.\n+        // FIXME: Use correct referrer\n+        let builder = create_a_potential_cors_request(\n+            Some(webview_id),\n+            url,\n+            destination,\n+            self.cross_origin,\n+            None,\n+            Referrer::NoReferrer,\n+            self.insecure_requests_policy,\n+            self.has_trustworthy_ancestor_origin,\n+            self.policy_container,\n+        )\n+        .initiator(Initiator::Link)\n+        .origin(self.origin)\n+        .integrity_metadata(self.integrity)\n+        .cryptographic_nonce_metadata(self.cryptographic_nonce_metadata)\n+        .referrer_policy(self.referrer_policy);\n+\n+        // Step 12. Return request.\n+        Some(builder)\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#match-preload-type>\n+    pub(crate) fn type_matches_destination(&self) -> bool {\n+        // Step 1. If type is an empty string, then return true.\n+        if self.link_type.is_empty() {\n+            return true;\n+        }\n+        // Step 2. If destination is \"fetch\", then return true.\n+        //\n+        // Fetch is handled as an empty string destination in the spec:\n+        // https://fetch.spec.whatwg.org/#concept-potential-destination-translate\n+        let Some(destination) = self.destination else {\n+            return false;\n+        };\n+        if destination == Destination::None {\n+            return true;\n+        }\n+        // Step 3. Let mimeTypeRecord be the result of parsing type.\n+        let Ok(mime_type_record) = Mime::from_str(&self.link_type) else {\n+            // Step 4. If mimeTypeRecord is failure, then return false.\n+            return false;\n+        };\n+        // Step 5. If mimeTypeRecord is not supported by the user agent, then return false.\n+        //\n+        // We currently don't check if we actually support the mime type. Only if we can classify\n+        // it according to the spec.\n+        let Some(mime_type) = MimeClassifier::get_media_type(&mime_type_record) else {\n+            return false;\n+        };\n+        // Step 6. If any of the following are true:\n+        if\n+        // destination is \"audio\" or \"video\", and mimeTypeRecord is an audio or video MIME type;\n+        ((destination == Destination::Audio || destination == Destination::Video) &&\n+            mime_type == MediaType::AudioVideo)\n+            // destination is a script-like destination and mimeTypeRecord is a JavaScript MIME type;\n+            || (destination.is_script_like() && mime_type == MediaType::JavaScript)\n+            // destination is \"image\" and mimeTypeRecord is an image MIME type;\n+            || (destination == Destination::Image && mime_type == MediaType::Image)\n+            // destination is \"font\" and mimeTypeRecord is a font MIME type;\n+            || (destination == Destination::Font && mime_type == MediaType::Font)\n+            // destination is \"json\" and mimeTypeRecord is a JSON MIME type;\n+            || (destination == Destination::Json && mime_type == MediaType::Json)\n+            // destination is \"style\" and mimeTypeRecord's essence is text/css; or\n+            || (destination == Destination::Style && mime_type_record == mime::TEXT_CSS)\n+            // destination is \"track\" and mimeTypeRecord's essence is text/vtt,\n+            || (destination == Destination::Track && mime_type_record.essence_str() == \"text/vtt\")\n+        {\n+            // then return true.\n+            return true;\n+        }\n+        // Step 7. Return false.\n+        false\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#preload>\n+    pub(crate) fn preload(self, webview_id: WebViewId) -> Option<RequestBuilder> {\n+        // Step 1. If options's type doesn't match options's destination, then return.\n+        //\n+        // Handled by callers, since we need to check the previous destination type\n+        assert!(self.type_matches_destination());\n+        // Step 2. If options's destination is \"image\" and options's source set is not null,\n+        // then set options's href to the result of selecting an image source from options's source set.\n+        // TODO\n+        // Step 3. Let request be the result of creating a link request given options.\n+        let Some(request) = self.create_link_request(webview_id) else {\n+            // Step 4. If request is null, then return.\n+            return None;\n+        };\n+        // Step 5. Let unsafeEndTime be 0.\n+        // TODO\n+        // Step 6. Let entry be a new preload entry whose integrity metadata is options's integrity.\n+        // TODO\n+        // Step 7. Let key be the result of creating a preload key given request.\n+        // TODO\n+        // Step 8. If options's document is \"pending\", then set request's initiator type to \"early hint\".\n+        // TODO\n+        // Step 9. Let controller be null.\n+        // Step 10. Let reportTiming given a Document document be to report timing for controller\n+        // given document's relevant global object.\n+        // Step 11. Set controller to the result of fetching request, with processResponseConsumeBody\n+        // set to the following steps given a response response and null, failure, or a byte sequence bodyBytes:\n+        Some(request.clone())\n+    }\n+}\n+\n+pub(crate) fn determine_cors_settings_for_token(token: &str) -> Option<CorsSettings> {\n+    match_ignore_ascii_case! { token,\n+        \"anonymous\" => Some(CorsSettings::Anonymous),\n+        \"use-credentials\" => Some(CorsSettings::UseCredentials),\n+        _ => None,\n+    }\n+}\n+\n+/// <https://html.spec.whatwg.org/multipage/#extract-links-from-headers>\n+pub(crate) fn extract_links_from_headers(headers: &Option<Serde<HeaderMap>>) -> Vec<LinkHeader> {\n+    // Step 1. Let links be a new list.\n+    let mut links = Vec::new();\n+    let Some(headers) = headers else {\n+        return links;\n+    };\n+    // Step 2. Let rawLinkHeaders be the result of getting, decoding, and splitting `Link` from headers.\n+    let Some(raw_link_headers) = get_decode_and_split_header_name(\"Link\", headers) else {\n+        return links;\n+    };\n+    // Step 3. For each linkHeader of rawLinkHeaders:\n+    for link_header in raw_link_headers {\n+        // Step 3.1. Let linkObject be the result of parsing linkHeader. [WEBLINK]\n+        let Ok(parsed_link_header) = parse_link_header(&link_header) else {\n+            continue;\n+        };\n+        for link_object in parsed_link_header {\n+            let Some(link_object) = link_object else {\n+                // Step 3.2. If linkObject[\"target_uri\"] does not exist, then continue.\n+                continue;\n+            };\n+            // Step 3.3. Append linkObject to links.\n+            links.push(link_object.to_owned());\n+        }\n+    }\n+    // Step 4. Return links.\n+    links\n+}\n+\n+/// <https://html.spec.whatwg.org/multipage/#process-link-headers>\n+pub(crate) fn process_link_headers(\n+    link_headers: &Vec<LinkHeader>,",
        "comment_created_at": "2025-09-27T17:55:07+00:00",
        "comment_author": "jdm",
        "comment_body": "```suggestion\n    link_headers: &[LinkHeader],\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2297267439",
    "pr_number": 38846,
    "pr_file": "ports/servoshell/egl/app_state.rs",
    "created_at": "2025-08-25T06:51:15+00:00",
    "commented_code": "}\n \n     /// WebDriver message handling methods\n-    pub(crate) fn webdriver_receiver(&self) -> Option<&Receiver<WebDriverCommandMsg>> {\n-        self.webdriver_receiver.as_ref()\n+    pub fn webview_by_id(&self, id: WebViewId) -> Option<WebView> {\n+        self.inner().webviews.get(&id).cloned()\n+    }\n+\n+    /// Clean up extra webviews for testing, keeping only the specified webview\n+    pub fn cleanup_extra_webviews_for_testing(&self, keep_webview_id: WebViewId) {\n+        let mut inner = self.inner_mut();\n+        let webview_ids_to_remove: Vec<WebViewId> = inner\n+            .webviews\n+            .keys()\n+            .filter(|&id| *id != keep_webview_id)\n+            .cloned()\n+            .collect();\n+\n+        if !webview_ids_to_remove.is_empty() {\n+            for webview_id in webview_ids_to_remove {\n+                if let Some(webview) = inner.webviews.remove(&webview_id) {\n+                    info!(\"Closing webview: {}\", webview_id);\n+                    // Remove from creation order, webview will be automatically cleaned up when dropped\n+                    inner.creation_order.retain(|&id| id != webview_id);\n+                }\n+            }\n+\n+            // Ensure the kept webview is the focused one\n+            inner.focused_webview_id = Some(keep_webview_id);\n+\n+            info!(\n+                \"After cleanup: {} webviews remaining, focused: {:?}\",\n+                inner.webviews.len(),\n+                inner.focused_webview_id\n+            );\n+        }\n     }\n \n     pub fn handle_webdriver_messages(self: &Rc<Self>) {\n         if let Some(webdriver_receiver) = &self.webdriver_receiver {\n             while let Ok(msg) = webdriver_receiver.try_recv() {\n                 match msg {\n                     WebDriverCommandMsg::LoadUrl(webview_id, url, load_status_sender) => {\n-                        info!(\n-                            \"(Not Implemented) Loading URL in webview {}: {}\",\n-                            webview_id, url\n-                        );\n+                        info!(\"Loading URL in webview {}: {}\", webview_id, url);\n+\n+                        // For OHOS testing: clean up multiple webviews and ensure single focused webview\n+                        self.cleanup_extra_webviews_for_testing(webview_id);\n+\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender.clone());\n+                            // Ensure this webview is focused before loading\n+                            self.inner_mut().focused_webview_id = Some(webview_id);\n+                            webview.focus();\n+                            let url_string = url.to_string(); // Store string representation before moving\n+                            webview.load(url.into_url());\n+                            info!(\n+                                \"Successfully loaded URL {} in focused webview {}\",\n+                                url_string, webview_id\n+                            );\n+                            if let Err(error) =\n+                                load_status_sender.send(WebDriverLoadStatus::Complete)\n+                            {\n+                                warn!(\"Failed to send response of LoadUrl: {error}\");\n+                            }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2297267439",
        "repo_full_name": "servo/servo",
        "pr_number": 38846,
        "pr_file": "ports/servoshell/egl/app_state.rs",
        "discussion_id": "2297267439",
        "commented_code": "@@ -494,34 +592,218 @@ impl RunningAppState {\n     }\n \n     /// WebDriver message handling methods\n-    pub(crate) fn webdriver_receiver(&self) -> Option<&Receiver<WebDriverCommandMsg>> {\n-        self.webdriver_receiver.as_ref()\n+    pub fn webview_by_id(&self, id: WebViewId) -> Option<WebView> {\n+        self.inner().webviews.get(&id).cloned()\n+    }\n+\n+    /// Clean up extra webviews for testing, keeping only the specified webview\n+    pub fn cleanup_extra_webviews_for_testing(&self, keep_webview_id: WebViewId) {\n+        let mut inner = self.inner_mut();\n+        let webview_ids_to_remove: Vec<WebViewId> = inner\n+            .webviews\n+            .keys()\n+            .filter(|&id| *id != keep_webview_id)\n+            .cloned()\n+            .collect();\n+\n+        if !webview_ids_to_remove.is_empty() {\n+            for webview_id in webview_ids_to_remove {\n+                if let Some(webview) = inner.webviews.remove(&webview_id) {\n+                    info!(\"Closing webview: {}\", webview_id);\n+                    // Remove from creation order, webview will be automatically cleaned up when dropped\n+                    inner.creation_order.retain(|&id| id != webview_id);\n+                }\n+            }\n+\n+            // Ensure the kept webview is the focused one\n+            inner.focused_webview_id = Some(keep_webview_id);\n+\n+            info!(\n+                \"After cleanup: {} webviews remaining, focused: {:?}\",\n+                inner.webviews.len(),\n+                inner.focused_webview_id\n+            );\n+        }\n     }\n \n     pub fn handle_webdriver_messages(self: &Rc<Self>) {\n         if let Some(webdriver_receiver) = &self.webdriver_receiver {\n             while let Ok(msg) = webdriver_receiver.try_recv() {\n                 match msg {\n                     WebDriverCommandMsg::LoadUrl(webview_id, url, load_status_sender) => {\n-                        info!(\n-                            \"(Not Implemented) Loading URL in webview {}: {}\",\n-                            webview_id, url\n-                        );\n+                        info!(\"Loading URL in webview {}: {}\", webview_id, url);\n+\n+                        // For OHOS testing: clean up multiple webviews and ensure single focused webview\n+                        self.cleanup_extra_webviews_for_testing(webview_id);\n+\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender.clone());\n+                            // Ensure this webview is focused before loading\n+                            self.inner_mut().focused_webview_id = Some(webview_id);\n+                            webview.focus();\n+                            let url_string = url.to_string(); // Store string representation before moving\n+                            webview.load(url.into_url());\n+                            info!(\n+                                \"Successfully loaded URL {} in focused webview {}\",\n+                                url_string, webview_id\n+                            );\n+                            if let Err(error) =\n+                                load_status_sender.send(WebDriverLoadStatus::Complete)\n+                            {\n+                                warn!(\"Failed to send response of LoadUrl: {error}\");\n+                            }",
        "comment_created_at": "2025-08-25T06:51:15+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "instead of sending here, can we implement [notify_load_status_changed](https://github.com/servo/servo/blob/11bea7303d204f82dded355ec60e90e1735ac151/components/servo/webview_delegate.rs#L445) for egl?\r\n\r\nhttps://github.com/servo/servo/blob/11bea7303d204f82dded355ec60e90e1735ac151/ports/servoshell/desktop/app_state.rs#L674-L687\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2297268366",
        "repo_full_name": "servo/servo",
        "pr_number": 38846,
        "pr_file": "ports/servoshell/egl/app_state.rs",
        "discussion_id": "2297267439",
        "commented_code": "@@ -494,34 +592,218 @@ impl RunningAppState {\n     }\n \n     /// WebDriver message handling methods\n-    pub(crate) fn webdriver_receiver(&self) -> Option<&Receiver<WebDriverCommandMsg>> {\n-        self.webdriver_receiver.as_ref()\n+    pub fn webview_by_id(&self, id: WebViewId) -> Option<WebView> {\n+        self.inner().webviews.get(&id).cloned()\n+    }\n+\n+    /// Clean up extra webviews for testing, keeping only the specified webview\n+    pub fn cleanup_extra_webviews_for_testing(&self, keep_webview_id: WebViewId) {\n+        let mut inner = self.inner_mut();\n+        let webview_ids_to_remove: Vec<WebViewId> = inner\n+            .webviews\n+            .keys()\n+            .filter(|&id| *id != keep_webview_id)\n+            .cloned()\n+            .collect();\n+\n+        if !webview_ids_to_remove.is_empty() {\n+            for webview_id in webview_ids_to_remove {\n+                if let Some(webview) = inner.webviews.remove(&webview_id) {\n+                    info!(\"Closing webview: {}\", webview_id);\n+                    // Remove from creation order, webview will be automatically cleaned up when dropped\n+                    inner.creation_order.retain(|&id| id != webview_id);\n+                }\n+            }\n+\n+            // Ensure the kept webview is the focused one\n+            inner.focused_webview_id = Some(keep_webview_id);\n+\n+            info!(\n+                \"After cleanup: {} webviews remaining, focused: {:?}\",\n+                inner.webviews.len(),\n+                inner.focused_webview_id\n+            );\n+        }\n     }\n \n     pub fn handle_webdriver_messages(self: &Rc<Self>) {\n         if let Some(webdriver_receiver) = &self.webdriver_receiver {\n             while let Ok(msg) = webdriver_receiver.try_recv() {\n                 match msg {\n                     WebDriverCommandMsg::LoadUrl(webview_id, url, load_status_sender) => {\n-                        info!(\n-                            \"(Not Implemented) Loading URL in webview {}: {}\",\n-                            webview_id, url\n-                        );\n+                        info!(\"Loading URL in webview {}: {}\", webview_id, url);\n+\n+                        // For OHOS testing: clean up multiple webviews and ensure single focused webview\n+                        self.cleanup_extra_webviews_for_testing(webview_id);\n+\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender.clone());\n+                            // Ensure this webview is focused before loading\n+                            self.inner_mut().focused_webview_id = Some(webview_id);\n+                            webview.focus();\n+                            let url_string = url.to_string(); // Store string representation before moving\n+                            webview.load(url.into_url());\n+                            info!(\n+                                \"Successfully loaded URL {} in focused webview {}\",\n+                                url_string, webview_id\n+                            );\n+                            if let Err(error) =\n+                                load_status_sender.send(WebDriverLoadStatus::Complete)\n+                            {\n+                                warn!(\"Failed to send response of LoadUrl: {error}\");\n+                            }",
        "comment_created_at": "2025-08-25T06:51:47+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "And also for other command below that related with navigation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2297334890",
    "pr_number": 38846,
    "pr_file": "ports/servoshell/egl/app_state.rs",
    "created_at": "2025-08-25T07:28:12+00:00",
    "commented_code": "}\n \n     /// WebDriver message handling methods\n-    pub(crate) fn webdriver_receiver(&self) -> Option<&Receiver<WebDriverCommandMsg>> {\n-        self.webdriver_receiver.as_ref()\n+    pub fn webview_by_id(&self, id: WebViewId) -> Option<WebView> {\n+        self.inner().webviews.get(&id).cloned()\n+    }\n+\n+    /// Clean up extra webviews for testing, keeping only the specified webview\n+    pub fn cleanup_extra_webviews_for_testing(&self, keep_webview_id: WebViewId) {\n+        let mut inner = self.inner_mut();\n+        let webview_ids_to_remove: Vec<WebViewId> = inner\n+            .webviews\n+            .keys()\n+            .filter(|&id| *id != keep_webview_id)\n+            .cloned()\n+            .collect();\n+\n+        if !webview_ids_to_remove.is_empty() {\n+            for webview_id in webview_ids_to_remove {\n+                if let Some(webview) = inner.webviews.remove(&webview_id) {\n+                    info!(\"Closing webview: {}\", webview_id);\n+                    // Remove from creation order, webview will be automatically cleaned up when dropped\n+                    inner.creation_order.retain(|&id| id != webview_id);\n+                }\n+            }\n+\n+            // Ensure the kept webview is the focused one\n+            inner.focused_webview_id = Some(keep_webview_id);\n+\n+            info!(\n+                \"After cleanup: {} webviews remaining, focused: {:?}\",\n+                inner.webviews.len(),\n+                inner.focused_webview_id\n+            );\n+        }\n     }\n \n     pub fn handle_webdriver_messages(self: &Rc<Self>) {\n         if let Some(webdriver_receiver) = &self.webdriver_receiver {\n             while let Ok(msg) = webdriver_receiver.try_recv() {\n                 match msg {\n                     WebDriverCommandMsg::LoadUrl(webview_id, url, load_status_sender) => {\n-                        info!(\n-                            \"(Not Implemented) Loading URL in webview {}: {}\",\n-                            webview_id, url\n-                        );\n+                        info!(\"Loading URL in webview {}: {}\", webview_id, url);\n+\n+                        // For OHOS testing: clean up multiple webviews and ensure single focused webview\n+                        self.cleanup_extra_webviews_for_testing(webview_id);\n+\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender.clone());\n+                            // Ensure this webview is focused before loading\n+                            self.inner_mut().focused_webview_id = Some(webview_id);\n+                            webview.focus();\n+                            let url_string = url.to_string(); // Store string representation before moving\n+                            webview.load(url.into_url());\n+                            info!(\n+                                \"Successfully loaded URL {} in focused webview {}\",\n+                                url_string, webview_id\n+                            );\n+                            if let Err(error) =\n+                                load_status_sender.send(WebDriverLoadStatus::Complete)\n+                            {\n+                                warn!(\"Failed to send response of LoadUrl: {error}\");\n+                            }\n+                        } else {\n+                            warn!(\"WebView {} not found for LoadUrl command\", webview_id);\n+                        }\n                     },\n                     WebDriverCommandMsg::NewWebView(response_sender, load_status_sender) => {\n-                        info!(\"(Not Implemented) Creating new webview\");\n+                        info!(\"Creating new webview via WebDriver\");\n+                        let new_webview = self\n+                            .create_and_focus_toplevel_webview(Url::parse(\"about:blank\").unwrap());\n+\n+                        if let Err(error) = response_sender.send(new_webview.id()) {\n+                            warn!(\"Failed to send response of NewWebview: {error}\");\n+                        }\n+                        if let Some(load_status_sender) = load_status_sender {\n+                            self.set_load_status_sender(new_webview.id(), load_status_sender);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::CloseWebView(webview_id, response_sender) => {\n+                        self.close_webview(webview_id);\n+                        if let Err(error) = response_sender.send(()) {\n+                            warn!(\"Failed to send response of CloseWebView: {error}\");\n+                        }\n                     },\n                     WebDriverCommandMsg::FocusWebView(webview_id, response_sender) => {\n-                        info!(\"(Not Implemented) Focusing webview {}\", webview_id);\n+                        if self.inner().webviews.contains_key(&webview_id) {\n+                            if let Some(webview) = self.webview_by_id(webview_id) {\n+                                let focus_id = webview.focus();\n+                                info!(\"Successfully focused webview {}\", webview_id);\n+                                self.set_pending_focus(focus_id, response_sender.clone());\n+                                let _ = response_sender.send(true);\n+                            } else {\n+                                warn!(\"Webview {} not found after cleanup\", webview_id);\n+                                let _ = response_sender.send(false);\n+                            }\n+                        } else {\n+                            warn!(\"Webview {} not found for focusing\", webview_id);\n+                            let _ = response_sender.send(false);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::IsWebViewOpen(webview_id, response_sender) => {\n+                        let context = self.webview_by_id(webview_id);\n+\n+                        if let Err(error) = response_sender.send(context.is_some()) {\n+                            warn!(\"Failed to send response of IsWebViewOpen: {error}\");\n+                        }\n+                    },\n+                    WebDriverCommandMsg::IsBrowsingContextOpen(..) => {\n+                        self.servo().execute_webdriver_command(msg);\n+                    },\n+                    WebDriverCommandMsg::GetFocusedWebView(response_sender) => {\n+                        let focused_id = self\n+                            .inner()\n+                            .focused_webview_id\n+                            .and_then(|id| self.inner().webviews.get(&id).cloned());\n+\n+                        if let Err(error) = response_sender.send(focused_id.map(|w| w.id())) {\n+                            warn!(\"Failed to send response of GetFocusedWebView: {error}\");\n+                        }\n+                    },\n+                    WebDriverCommandMsg::Refresh(webview_id, load_status_sender) => {\n+                        info!(\"Refreshing webview {}\", webview_id);\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender);\n+                            webview.reload();\n+                        } else {\n+                            warn!(\"WebView {} not found for Refresh command\", webview_id);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::GoBack(webview_id, load_status_sender) => {\n+                        info!(\"Going back in webview {}\", webview_id);\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender);\n+                            webview.go_back(1);\n+                        } else {\n+                            warn!(\"WebView {} not found for GoBack command\", webview_id);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::GoForward(webview_id, load_status_sender) => {\n+                        info!(\"Going forward in webview {}\", webview_id);\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender);\n+                            webview.go_forward(1);\n+                        } else {\n+                            warn!(\"WebView {} not found for GoForward command\", webview_id);\n+                        }\n+                    },",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2297334890",
        "repo_full_name": "servo/servo",
        "pr_number": 38846,
        "pr_file": "ports/servoshell/egl/app_state.rs",
        "discussion_id": "2297334890",
        "commented_code": "@@ -494,34 +592,218 @@ impl RunningAppState {\n     }\n \n     /// WebDriver message handling methods\n-    pub(crate) fn webdriver_receiver(&self) -> Option<&Receiver<WebDriverCommandMsg>> {\n-        self.webdriver_receiver.as_ref()\n+    pub fn webview_by_id(&self, id: WebViewId) -> Option<WebView> {\n+        self.inner().webviews.get(&id).cloned()\n+    }\n+\n+    /// Clean up extra webviews for testing, keeping only the specified webview\n+    pub fn cleanup_extra_webviews_for_testing(&self, keep_webview_id: WebViewId) {\n+        let mut inner = self.inner_mut();\n+        let webview_ids_to_remove: Vec<WebViewId> = inner\n+            .webviews\n+            .keys()\n+            .filter(|&id| *id != keep_webview_id)\n+            .cloned()\n+            .collect();\n+\n+        if !webview_ids_to_remove.is_empty() {\n+            for webview_id in webview_ids_to_remove {\n+                if let Some(webview) = inner.webviews.remove(&webview_id) {\n+                    info!(\"Closing webview: {}\", webview_id);\n+                    // Remove from creation order, webview will be automatically cleaned up when dropped\n+                    inner.creation_order.retain(|&id| id != webview_id);\n+                }\n+            }\n+\n+            // Ensure the kept webview is the focused one\n+            inner.focused_webview_id = Some(keep_webview_id);\n+\n+            info!(\n+                \"After cleanup: {} webviews remaining, focused: {:?}\",\n+                inner.webviews.len(),\n+                inner.focused_webview_id\n+            );\n+        }\n     }\n \n     pub fn handle_webdriver_messages(self: &Rc<Self>) {\n         if let Some(webdriver_receiver) = &self.webdriver_receiver {\n             while let Ok(msg) = webdriver_receiver.try_recv() {\n                 match msg {\n                     WebDriverCommandMsg::LoadUrl(webview_id, url, load_status_sender) => {\n-                        info!(\n-                            \"(Not Implemented) Loading URL in webview {}: {}\",\n-                            webview_id, url\n-                        );\n+                        info!(\"Loading URL in webview {}: {}\", webview_id, url);\n+\n+                        // For OHOS testing: clean up multiple webviews and ensure single focused webview\n+                        self.cleanup_extra_webviews_for_testing(webview_id);\n+\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender.clone());\n+                            // Ensure this webview is focused before loading\n+                            self.inner_mut().focused_webview_id = Some(webview_id);\n+                            webview.focus();\n+                            let url_string = url.to_string(); // Store string representation before moving\n+                            webview.load(url.into_url());\n+                            info!(\n+                                \"Successfully loaded URL {} in focused webview {}\",\n+                                url_string, webview_id\n+                            );\n+                            if let Err(error) =\n+                                load_status_sender.send(WebDriverLoadStatus::Complete)\n+                            {\n+                                warn!(\"Failed to send response of LoadUrl: {error}\");\n+                            }\n+                        } else {\n+                            warn!(\"WebView {} not found for LoadUrl command\", webview_id);\n+                        }\n                     },\n                     WebDriverCommandMsg::NewWebView(response_sender, load_status_sender) => {\n-                        info!(\"(Not Implemented) Creating new webview\");\n+                        info!(\"Creating new webview via WebDriver\");\n+                        let new_webview = self\n+                            .create_and_focus_toplevel_webview(Url::parse(\"about:blank\").unwrap());\n+\n+                        if let Err(error) = response_sender.send(new_webview.id()) {\n+                            warn!(\"Failed to send response of NewWebview: {error}\");\n+                        }\n+                        if let Some(load_status_sender) = load_status_sender {\n+                            self.set_load_status_sender(new_webview.id(), load_status_sender);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::CloseWebView(webview_id, response_sender) => {\n+                        self.close_webview(webview_id);\n+                        if let Err(error) = response_sender.send(()) {\n+                            warn!(\"Failed to send response of CloseWebView: {error}\");\n+                        }\n                     },\n                     WebDriverCommandMsg::FocusWebView(webview_id, response_sender) => {\n-                        info!(\"(Not Implemented) Focusing webview {}\", webview_id);\n+                        if self.inner().webviews.contains_key(&webview_id) {\n+                            if let Some(webview) = self.webview_by_id(webview_id) {\n+                                let focus_id = webview.focus();\n+                                info!(\"Successfully focused webview {}\", webview_id);\n+                                self.set_pending_focus(focus_id, response_sender.clone());\n+                                let _ = response_sender.send(true);\n+                            } else {\n+                                warn!(\"Webview {} not found after cleanup\", webview_id);\n+                                let _ = response_sender.send(false);\n+                            }\n+                        } else {\n+                            warn!(\"Webview {} not found for focusing\", webview_id);\n+                            let _ = response_sender.send(false);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::IsWebViewOpen(webview_id, response_sender) => {\n+                        let context = self.webview_by_id(webview_id);\n+\n+                        if let Err(error) = response_sender.send(context.is_some()) {\n+                            warn!(\"Failed to send response of IsWebViewOpen: {error}\");\n+                        }\n+                    },\n+                    WebDriverCommandMsg::IsBrowsingContextOpen(..) => {\n+                        self.servo().execute_webdriver_command(msg);\n+                    },\n+                    WebDriverCommandMsg::GetFocusedWebView(response_sender) => {\n+                        let focused_id = self\n+                            .inner()\n+                            .focused_webview_id\n+                            .and_then(|id| self.inner().webviews.get(&id).cloned());\n+\n+                        if let Err(error) = response_sender.send(focused_id.map(|w| w.id())) {\n+                            warn!(\"Failed to send response of GetFocusedWebView: {error}\");\n+                        }\n+                    },\n+                    WebDriverCommandMsg::Refresh(webview_id, load_status_sender) => {\n+                        info!(\"Refreshing webview {}\", webview_id);\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender);\n+                            webview.reload();\n+                        } else {\n+                            warn!(\"WebView {} not found for Refresh command\", webview_id);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::GoBack(webview_id, load_status_sender) => {\n+                        info!(\"Going back in webview {}\", webview_id);\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender);\n+                            webview.go_back(1);\n+                        } else {\n+                            warn!(\"WebView {} not found for GoBack command\", webview_id);\n+                        }\n+                    },\n+                    WebDriverCommandMsg::GoForward(webview_id, load_status_sender) => {\n+                        info!(\"Going forward in webview {}\", webview_id);\n+                        if let Some(webview) = self.webview_by_id(webview_id) {\n+                            self.set_load_status_sender(webview_id, load_status_sender);\n+                            webview.go_forward(1);\n+                        } else {\n+                            warn!(\"WebView {} not found for GoForward command\", webview_id);\n+                        }\n+                    },",
        "comment_created_at": "2025-08-25T07:28:12+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "To match desktop, we should `set_pending_traversal` instead of `set_load_status_sender` here\r\n\r\nhttps://github.com/servo/servo/blob/11bea7303d204f82dded355ec60e90e1735ac151/ports/servoshell/desktop/app.rs#L475-L486\r\n\r\nAnd like above, we should implement `notify_traversal_complete` to notify to WebDriver.\r\n\r\nhttps://github.com/servo/servo/blob/11bea7303d204f82dded355ec60e90e1735ac151/ports/servoshell/desktop/app_state.rs#L550-L556",
        "pr_file_module": null
      }
    ]
  }
]