[
  {
    "discussion_id": "2454196299",
    "pr_number": 39384,
    "pr_file": "components/compositing/compositor.rs",
    "created_at": "2025-10-23T07:32:35+00:00",
    "commented_code": "if let Some(webview_renderer) = self.webview_renderers.get_mut(webview_id) {\n             webview_renderer.notify_input_event(event);\n         }\n+        self.disable_lcp_calculation();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2454196299",
        "repo_full_name": "servo/servo",
        "pr_number": 39384,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2454196299",
        "commented_code": "@@ -1530,6 +1588,7 @@ impl IOCompositor {\n         if let Some(webview_renderer) = self.webview_renderers.get_mut(webview_id) {\n             webview_renderer.notify_input_event(event);\n         }\n+        self.disable_lcp_calculation();",
        "comment_created_at": "2025-10-23T07:32:35+00:00",
        "comment_author": "xiaochengh",
        "comment_body": "Is there spec text that LCP collection should be terminated after user interaction?\n\nBtw it's OK to stop it here. Just want to see some reference.",
        "pr_file_module": null
      },
      {
        "comment_id": "2454475399",
        "repo_full_name": "servo/servo",
        "pr_number": 39384,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2454196299",
        "commented_code": "@@ -1530,6 +1588,7 @@ impl IOCompositor {\n         if let Some(webview_renderer) = self.webview_renderers.get_mut(webview_id) {\n             webview_renderer.notify_input_event(event);\n         }\n+        self.disable_lcp_calculation();",
        "comment_created_at": "2025-10-23T09:21:03+00:00",
        "comment_author": "shubhamg13",
        "comment_body": "Refer Note on [When is LCP reported?](https://web.dev/articles/lcp#when-is-lcp-reported )\r\n\r\n> Note: The browser will stop reporting new entries as soon as the user interacts with the page (via a tap, scroll, or keypress), as user interaction often changes what's visible to the user (which is especially true with scrolling).\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2454214806",
    "pr_number": 39384,
    "pr_file": "components/compositing/compositor.rs",
    "created_at": "2025-10-23T07:40:28+00:00",
    "commented_code": "};\n         webview_renderer.notify_input_event_handled(input_event_id, result);\n     }\n+\n+    /// Disable LCP feature when the user interacts with the page.\n+    fn disable_lcp_calculation(&mut self) {\n+        let mut current_preferences = servo_config::prefs::get().clone();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2454214806",
        "repo_full_name": "servo/servo",
        "pr_number": 39384,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2454214806",
        "commented_code": "@@ -1641,6 +1701,16 @@ impl IOCompositor {\n         };\n         webview_renderer.notify_input_event_handled(input_event_id, result);\n     }\n+\n+    /// Disable LCP feature when the user interacts with the page.\n+    fn disable_lcp_calculation(&mut self) {\n+        let mut current_preferences = servo_config::prefs::get().clone();",
        "comment_created_at": "2025-10-23T07:40:28+00:00",
        "comment_author": "xiaochengh",
        "comment_body": "This looks wrong to me. We should stop LCP collection just for a specific `WebViewId`, but this function disables it globally and permanently.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2342376418",
    "pr_number": 39259,
    "pr_file": "ports/servoshell/desktop/app.rs",
    "created_at": "2025-09-11T21:26:20+00:00",
    "commented_code": "window.request_redraw();\n                     }\n                 }\n+\n+                let new_title = state\n+                    .focused_webview()\n+                    .and_then(|w| {\n+                        w.page_title()\n+                            .filter(|t| !t.is_empty())\n+                            .or_else(|| w.url().map(|url| url.to_string()))\n+                    })\n+                    .unwrap_or_else(|| \"Servo\".to_string());\n+\n+                if new_title != self.last_window_title {\n+                    window.set_title(&new_title);\n+                    self.last_window_title = new_title;\n+                }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2342376418",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/app.rs",
        "discussion_id": "2342376418",
        "commented_code": "@@ -244,6 +248,20 @@ impl App {\n                         window.request_redraw();\n                     }\n                 }\n+\n+                let new_title = state\n+                    .focused_webview()\n+                    .and_then(|w| {\n+                        w.page_title()\n+                            .filter(|t| !t.is_empty())\n+                            .or_else(|| w.url().map(|url| url.to_string()))\n+                    })\n+                    .unwrap_or_else(|| \"Servo\".to_string());\n+\n+                if new_title != self.last_window_title {\n+                    window.set_title(&new_title);\n+                    self.last_window_title = new_title;\n+                }",
        "comment_created_at": "2025-09-11T21:26:20+00:00",
        "comment_author": "mrobinson",
        "comment_body": "It's really odd that we have to check the title every tick of the event loop. This seems really fishy and I worry that it could hurt performance. Why not just update the title when switching tabs?",
        "pr_file_module": null
      },
      {
        "comment_id": "2342795838",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/app.rs",
        "discussion_id": "2342376418",
        "commented_code": "@@ -244,6 +248,20 @@ impl App {\n                         window.request_redraw();\n                     }\n                 }\n+\n+                let new_title = state\n+                    .focused_webview()\n+                    .and_then(|w| {\n+                        w.page_title()\n+                            .filter(|t| !t.is_empty())\n+                            .or_else(|| w.url().map(|url| url.to_string()))\n+                    })\n+                    .unwrap_or_else(|| \"Servo\".to_string());\n+\n+                if new_title != self.last_window_title {\n+                    window.set_title(&new_title);\n+                    self.last_window_title = new_title;\n+                }",
        "comment_created_at": "2025-09-12T02:36:23+00:00",
        "comment_author": "yezhizhen",
        "comment_body": "Switching tabs or when loading new url.",
        "pr_file_module": null
      },
      {
        "comment_id": "2343526361",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/app.rs",
        "discussion_id": "2342376418",
        "commented_code": "@@ -244,6 +248,20 @@ impl App {\n                         window.request_redraw();\n                     }\n                 }\n+\n+                let new_title = state\n+                    .focused_webview()\n+                    .and_then(|w| {\n+                        w.page_title()\n+                            .filter(|t| !t.is_empty())\n+                            .or_else(|| w.url().map(|url| url.to_string()))\n+                    })\n+                    .unwrap_or_else(|| \"Servo\".to_string());\n+\n+                if new_title != self.last_window_title {\n+                    window.set_title(&new_title);\n+                    self.last_window_title = new_title;\n+                }",
        "comment_created_at": "2025-09-12T09:02:22+00:00",
        "comment_author": "gterzian",
        "comment_body": "I think your comments would be fare more actionable if they came with a more detailed guide of how to improve the code(or were qualified with a \"I don't know how to improve the code and this requires independently looking into\"). I will attempt to do it below(edit: having gone through the motion, I think the current code actually makes a lot of sense, which I didn't initially expect, which is another reason to go through the motion of adding details). \r\n\r\nFocusing a webview starts with a call to [focus](https://github.com/servo/servo/blob/965e87d006ee4ac64407128e0c3d1fa104917294/components/servo/webview.rs#L302), which doesn't change the state of the UI; that happens only when the `EmbedderMsg::WebViewFocused` is received by Servo(as part of `spin_the_event_loop`), which calls [`set_focused`](https://github.com/servo/servo/blob/965e87d006ee4ac64407128e0c3d1fa104917294/components/servo/lib.rs#L746) on the webview, and which results in [calling `notify_focus_changed` on the webview delegate](https://github.com/servo/servo/blob/965e87d006ee4ac64407128e0c3d1fa104917294/components/servo/webview.rs#L282).\r\n\r\nThe desktop implementation of [that method](https://github.com/servo/servo/blob/965e87d006ee4ac64407128e0c3d1fa104917294/ports/servoshell/desktop/app_state.rs#L664) is likely a good candidate to update the state of the app. \r\n\r\nThis then still needs to propagate to ~~the native UI~~ the window. In the case of updating the native UI with up to date app state, this happens via [`update_webview_data`](https://github.com/servo/servo/blob/965e87d006ee4ac64407128e0c3d1fa104917294/ports/servoshell/desktop/minibrowser.rs#L550)(which is only called if `need_update` of `app_state.rs` is true), however, the window is not available in that context. \r\n\r\nSo updating the title of the window will require something new; I'm not sure what and this requires some independent looking into. \r\n\r\nOne way to do it would be to add a method on `app_state` that returns true if the focused webview changed, and a conditional that would update the window title in that case. \r\n\r\nThis would still result on a check at each tick of the event-loop. This seems like the way to do it really(you could request a redraw and only make the change when handling the redraw window event, but that still requires checking wether the condition to request a redraw is met, and that still needs to be done here at each tick of the event-loop). \r\n\r\nSo my conclusion is that the current code appears like the most simple and direct fix(what I sketch above fits into the UI update architecture, but that architecture does not apply to updating the window). I've only come to realize this after having looked into the details of how to implement this. \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2345932002",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/app.rs",
        "discussion_id": "2342376418",
        "commented_code": "@@ -244,6 +248,20 @@ impl App {\n                         window.request_redraw();\n                     }\n                 }\n+\n+                let new_title = state\n+                    .focused_webview()\n+                    .and_then(|w| {\n+                        w.page_title()\n+                            .filter(|t| !t.is_empty())\n+                            .or_else(|| w.url().map(|url| url.to_string()))\n+                    })\n+                    .unwrap_or_else(|| \"Servo\".to_string());\n+\n+                if new_title != self.last_window_title {\n+                    window.set_title(&new_title);\n+                    self.last_window_title = new_title;\n+                }",
        "comment_created_at": "2025-09-13T06:17:48+00:00",
        "comment_author": "mrobinson",
        "comment_body": "The answer to my question above is: The window title can be changed at the time that the tab is clicked, but the UI is updated asynchronously, so the title will briefly be out of sync with the tab -- which may or may not be a problem. Other types of UI syncing with WebView state is done by `update_webview_data` at each turn of the event loop. We should probably look at making this more efficient my only doing this when we know the WebView state has actually changed, but it's out of the scope of this change.\r\n\r\n1. Modify `update_webview_data` to take the `window: Rc<dyn WindowPortsMethod>` as an argument. It is available at the callsite.\r\n2. Modify `WindowPortsMethods::set_title` to be called `WindowPortsMethods::set_title_if_changed`.\r\n  - This would still do nothing for headless window.\r\n  - For headed windows this would compare the result of calling [`Window::title`](https://docs.rs/winit/latest/winit/window/struct.Window.html#method.title) with `WebView::page_title` and only set the title if changed. It would return true or false depending on if a change occured.\r\n 3. `update_webview_data` would call this modified method.",
        "pr_file_module": null
      },
      {
        "comment_id": "2345932223",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/app.rs",
        "discussion_id": "2342376418",
        "commented_code": "@@ -244,6 +248,20 @@ impl App {\n                         window.request_redraw();\n                     }\n                 }\n+\n+                let new_title = state\n+                    .focused_webview()\n+                    .and_then(|w| {\n+                        w.page_title()\n+                            .filter(|t| !t.is_empty())\n+                            .or_else(|| w.url().map(|url| url.to_string()))\n+                    })\n+                    .unwrap_or_else(|| \"Servo\".to_string());\n+\n+                if new_title != self.last_window_title {\n+                    window.set_title(&new_title);\n+                    self.last_window_title = new_title;\n+                }",
        "comment_created_at": "2025-09-13T06:18:49+00:00",
        "comment_author": "mrobinson",
        "comment_body": "BTW, it's really helpful to include this kind of context in the PR description when doing the initial PR so that it's more obvious why a change is being made in a certain way.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2378619872",
    "pr_number": 39478,
    "pr_file": "components/compositing/compositor.rs",
    "created_at": "2025-09-25T10:37:07+00:00",
    "commented_code": "display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2378619872",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-25T10:37:07+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I don't think we can do this...more than one WebView can be visible and only one can be focused. In addition, we want to be able to update the display list of background WebViews. Imagine two Servo windows open at the same time.\r\n\r\nWhat is the motivation for this change?",
        "pr_file_module": null
      },
      {
        "comment_id": "2378648808",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-25T10:48:45+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "In the Mosele mini-program, each navigation initiates a new webview to load the new page, while the previous page remains in the background. However, the previous page has a carousel timer that continuously generates new DisplayLists. This can lead to the webrender process being preempted.",
        "pr_file_module": null
      },
      {
        "comment_id": "2378656444",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-25T10:52:05+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "> I don't think we can do this...more than one WebView can be visible and only one can be focused. \r\n\r\nI understand what you're saying. I tried to launch multiple servo foreground webviews in openharmony but was unsuccessful. When launching multiple foreground webviews in Chromium, the animations of the unfocused webviews still proceed. Is there a way for us to determine whether a webview is in the foreground?",
        "pr_file_module": null
      },
      {
        "comment_id": "2378698449",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-25T11:04:53+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Are things improved if you call `webview.hide()` on the backgrounded `WebView`? This should prevent display lists from being produced.",
        "pr_file_module": null
      },
      {
        "comment_id": "2378827354",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-25T11:50:54+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "https://github.com/servo/servo/blob/ffdb7d366381f353e15717b9d327da76276935c3/components/servo/webview.rs#L391-L397\r\nAre you referring to this method? It seems like it's not being called anywhere now.",
        "pr_file_module": null
      },
      {
        "comment_id": "2381317852",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-26T08:15:17+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "Modify to send only the display list of the currently shown WebView.",
        "pr_file_module": null
      },
      {
        "comment_id": "2381957274",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-26T10:47:16+00:00",
        "comment_author": "mrobinson",
        "comment_body": "The idea is that the embedder should call `webivew.hide()` when it is hidden in the UI. Can you try calling `webview.hide()` in your application and see if display lists are still sent? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2384417859",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2378619872",
        "commented_code": "@@ -587,6 +587,12 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if self.webview_renderers.focused_webview_id() != Some(webview_id) {\n+                    // We only process display lists for the focused webview. This is important to\n+                    // avoid processing display lists for webviews that are not visible, which\n+                    // would cause them to consume memory and CPU time for no benefit.\n+                    return;\n+                }",
        "comment_created_at": "2025-09-28T01:10:17+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "In OpenHarmony, the current logic, each new webview will call focusWebview, which ultimately triggers `notify_focus_changed`. The `show_webview` function then displays the current webview, while `hide_all` hides other pages.However, the DisplayList will still be received.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2426758486",
    "pr_number": 39478,
    "pr_file": "components/compositing/compositor.rs",
    "created_at": "2025-10-13T16:05:19+00:00",
    "commented_code": "display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2426758486",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2426758486",
        "commented_code": "@@ -573,6 +573,9 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
        "comment_created_at": "2025-10-13T16:05:19+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Can you please move this early return right before frame generation? We want to process the new display list (and don't want to lose it), but we don't want to generate a new frame. In followup changes we can try harder to make sure that new display lists aren't generated for WebView's that are not showing.",
        "pr_file_module": null
      },
      {
        "comment_id": "2427654448",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2426758486",
        "commented_code": "@@ -573,6 +573,9 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
        "comment_created_at": "2025-10-14T01:05:57+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "Which part are you referring to when you say \"frame generation\"? Is it the generate_frame function?",
        "pr_file_module": null
      },
      {
        "comment_id": "2432108791",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2426758486",
        "commented_code": "@@ -573,6 +573,9 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
        "comment_created_at": "2025-10-15T10:51:11+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Hrm. I had forgotten that frame generation is now split into a separate message (`CompositorMsg::SendDisplayList`). This complicates things. I think we will need to ensure that `WebViews` that are not showing do not generate display lists at all. I will try to make a proposed PR today and perhaps you can let me know if it improves things.",
        "pr_file_module": null
      },
      {
        "comment_id": "2432256065",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2426758486",
        "commented_code": "@@ -573,6 +573,9 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
        "comment_created_at": "2025-10-15T11:46:16+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "Can we merge this before making any further modifications",
        "pr_file_module": null
      },
      {
        "comment_id": "2432434468",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2426758486",
        "commented_code": "@@ -573,6 +573,9 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
        "comment_created_at": "2025-10-15T12:48:27+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I am worried that simply throwing away display lists could lead to problems down the road. These display lists likely need to be processed somehow.",
        "pr_file_module": null
      },
      {
        "comment_id": "2434306639",
        "repo_full_name": "servo/servo",
        "pr_number": 39478,
        "pr_file": "components/compositing/compositor.rs",
        "discussion_id": "2426758486",
        "commented_code": "@@ -573,6 +573,9 @@ impl IOCompositor {\n                 display_list_descriptor,\n                 display_list_receiver,\n             } => {\n+                if !self.webview_renderers.is_shown(webview_id) {\n+                    return debug!(\"Ignoring display list for hidden webview {:?}\", webview_id);\n+                }",
        "comment_created_at": "2025-10-16T01:08:44+00:00",
        "comment_author": "kongbai1996",
        "comment_body": "I think that a WebView which is not shown should not need to process the DisplayList.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223829707",
    "pr_number": 38112,
    "pr_file": "components/script/dom/textdecodercommon.rs",
    "created_at": "2025-07-22T21:06:58+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::{Cell, RefCell};\n+\n+use encoding_rs::{Decoder, DecoderResult, Encoding};\n+use script_bindings::str::DOMString;\n+\n+use crate::dom::bindings::codegen::UnionTypes::ArrayBufferViewOrArrayBuffer;\n+use crate::dom::bindings::error::{Error, Fallible};\n+\n+/// The shared part of `TextDecoder` and `TextDecoderStream`\n+///\n+/// Note that other than the three attributes defined in the `TextDecoderCommon`\n+/// interface in the WebIDL, this also performs decoding.\n+///\n+/// <https://encoding.spec.whatwg.org/#textdecodercommon>\n+#[allow(non_snake_case)]\n+#[derive(JSTraceable, MallocSizeOf)]\n+pub(crate) struct TextDecoderCommon {\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-encoding>\n+    #[no_trace]\n+    encoding: &'static Encoding,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-fatal>\n+    fatal: bool,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-ignorebom>\n+    ignoreBOM: bool,\n+\n+    /// The native decoder that is used to perform decoding\n+    ///\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-decoder>\n+    #[ignore_malloc_size_of = \"defined in encoding_rs\"]\n+    #[no_trace]\n+    decoder: RefCell<Decoder>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-i-o-queue>\n+    in_stream: RefCell<Vec<u8>>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecoder-do-not-flush-flag>\n+    do_not_flush: Cell<bool>,\n+}\n+\n+#[allow(non_snake_case)]\n+impl TextDecoderCommon {\n+    pub(crate) fn new_inherited(\n+        encoding: &'static Encoding,\n+        fatal: bool,\n+        ignoreBOM: bool,\n+    ) -> TextDecoderCommon {\n+        let decoder = if ignoreBOM {\n+            encoding.new_decoder()\n+        } else {\n+            encoding.new_decoder_without_bom_handling()\n+        };\n+\n+        TextDecoderCommon {\n+            encoding,\n+            fatal,\n+            ignoreBOM,\n+            decoder: RefCell::new(decoder),\n+            in_stream: RefCell::new(Vec::new()),\n+            do_not_flush: Cell::new(false),\n+        }\n+    }\n+\n+    pub(crate) fn encoding(&self) -> DOMString {\n+        DOMString::from(self.encoding.name().to_ascii_lowercase())\n+    }\n+\n+    pub(crate) fn fatal(&self) -> bool {\n+        self.fatal\n+    }\n+\n+    pub(crate) fn ignore_bom(&self) -> bool {\n+        self.ignoreBOM\n+    }\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-decode>\n+    #[allow(unsafe_code)]\n+    pub(crate) fn decode(\n+        &self,\n+        input: Option<&ArrayBufferViewOrArrayBuffer>,\n+        do_not_flush: bool,\n+    ) -> Fallible<String> {\n+        // Step 1. If this\u2019s do not flush is false, then set this\u2019s decoder to a\n+        // new instance of this\u2019s encoding\u2019s decoder, this\u2019s I/O queue to the\n+        // I/O queue of bytes \u00ab end-of-queue \u00bb, and this\u2019s BOM seen to false.\n+        if !self.do_not_flush.get() {\n+            if self.ignoreBOM {\n+                self.decoder\n+                    .replace(self.encoding.new_decoder_without_bom_handling());\n+            } else {\n+                self.decoder.replace(self.encoding.new_decoder());\n+            }\n+            self.in_stream.replace(Vec::new());\n+        }\n+\n+        // Step 2. Set this\u2019s do not flush to options[\"stream\"].\n+        self.do_not_flush.set(do_not_flush);\n+\n+        // Step 3. If input is given, then push a copy of input to this\u2019s I/O queue.\n+        match input {\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBufferView(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBuffer(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            None => {},\n+        };",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2223829707",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/textdecodercommon.rs",
        "discussion_id": "2223829707",
        "commented_code": "@@ -0,0 +1,154 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::{Cell, RefCell};\n+\n+use encoding_rs::{Decoder, DecoderResult, Encoding};\n+use script_bindings::str::DOMString;\n+\n+use crate::dom::bindings::codegen::UnionTypes::ArrayBufferViewOrArrayBuffer;\n+use crate::dom::bindings::error::{Error, Fallible};\n+\n+/// The shared part of `TextDecoder` and `TextDecoderStream`\n+///\n+/// Note that other than the three attributes defined in the `TextDecoderCommon`\n+/// interface in the WebIDL, this also performs decoding.\n+///\n+/// <https://encoding.spec.whatwg.org/#textdecodercommon>\n+#[allow(non_snake_case)]\n+#[derive(JSTraceable, MallocSizeOf)]\n+pub(crate) struct TextDecoderCommon {\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-encoding>\n+    #[no_trace]\n+    encoding: &'static Encoding,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-fatal>\n+    fatal: bool,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-ignorebom>\n+    ignoreBOM: bool,\n+\n+    /// The native decoder that is used to perform decoding\n+    ///\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-decoder>\n+    #[ignore_malloc_size_of = \"defined in encoding_rs\"]\n+    #[no_trace]\n+    decoder: RefCell<Decoder>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-i-o-queue>\n+    in_stream: RefCell<Vec<u8>>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecoder-do-not-flush-flag>\n+    do_not_flush: Cell<bool>,\n+}\n+\n+#[allow(non_snake_case)]\n+impl TextDecoderCommon {\n+    pub(crate) fn new_inherited(\n+        encoding: &'static Encoding,\n+        fatal: bool,\n+        ignoreBOM: bool,\n+    ) -> TextDecoderCommon {\n+        let decoder = if ignoreBOM {\n+            encoding.new_decoder()\n+        } else {\n+            encoding.new_decoder_without_bom_handling()\n+        };\n+\n+        TextDecoderCommon {\n+            encoding,\n+            fatal,\n+            ignoreBOM,\n+            decoder: RefCell::new(decoder),\n+            in_stream: RefCell::new(Vec::new()),\n+            do_not_flush: Cell::new(false),\n+        }\n+    }\n+\n+    pub(crate) fn encoding(&self) -> DOMString {\n+        DOMString::from(self.encoding.name().to_ascii_lowercase())\n+    }\n+\n+    pub(crate) fn fatal(&self) -> bool {\n+        self.fatal\n+    }\n+\n+    pub(crate) fn ignore_bom(&self) -> bool {\n+        self.ignoreBOM\n+    }\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-decode>\n+    #[allow(unsafe_code)]\n+    pub(crate) fn decode(\n+        &self,\n+        input: Option<&ArrayBufferViewOrArrayBuffer>,\n+        do_not_flush: bool,\n+    ) -> Fallible<String> {\n+        // Step 1. If this\u2019s do not flush is false, then set this\u2019s decoder to a\n+        // new instance of this\u2019s encoding\u2019s decoder, this\u2019s I/O queue to the\n+        // I/O queue of bytes \u00ab end-of-queue \u00bb, and this\u2019s BOM seen to false.\n+        if !self.do_not_flush.get() {\n+            if self.ignoreBOM {\n+                self.decoder\n+                    .replace(self.encoding.new_decoder_without_bom_handling());\n+            } else {\n+                self.decoder.replace(self.encoding.new_decoder());\n+            }\n+            self.in_stream.replace(Vec::new());\n+        }\n+\n+        // Step 2. Set this\u2019s do not flush to options[\"stream\"].\n+        self.do_not_flush.set(do_not_flush);\n+\n+        // Step 3. If input is given, then push a copy of input to this\u2019s I/O queue.\n+        match input {\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBufferView(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBuffer(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            None => {},\n+        };",
        "comment_created_at": "2025-07-22T21:06:58+00:00",
        "comment_author": "gterzian",
        "comment_body": "Would be good to avoid the copy(see the note in the spec). Not sure how, could be more of a follow-up, but we should file an issue and add a TODO note. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2224874538",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/textdecodercommon.rs",
        "discussion_id": "2223829707",
        "commented_code": "@@ -0,0 +1,154 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::{Cell, RefCell};\n+\n+use encoding_rs::{Decoder, DecoderResult, Encoding};\n+use script_bindings::str::DOMString;\n+\n+use crate::dom::bindings::codegen::UnionTypes::ArrayBufferViewOrArrayBuffer;\n+use crate::dom::bindings::error::{Error, Fallible};\n+\n+/// The shared part of `TextDecoder` and `TextDecoderStream`\n+///\n+/// Note that other than the three attributes defined in the `TextDecoderCommon`\n+/// interface in the WebIDL, this also performs decoding.\n+///\n+/// <https://encoding.spec.whatwg.org/#textdecodercommon>\n+#[allow(non_snake_case)]\n+#[derive(JSTraceable, MallocSizeOf)]\n+pub(crate) struct TextDecoderCommon {\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-encoding>\n+    #[no_trace]\n+    encoding: &'static Encoding,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-fatal>\n+    fatal: bool,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-ignorebom>\n+    ignoreBOM: bool,\n+\n+    /// The native decoder that is used to perform decoding\n+    ///\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-decoder>\n+    #[ignore_malloc_size_of = \"defined in encoding_rs\"]\n+    #[no_trace]\n+    decoder: RefCell<Decoder>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-i-o-queue>\n+    in_stream: RefCell<Vec<u8>>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecoder-do-not-flush-flag>\n+    do_not_flush: Cell<bool>,\n+}\n+\n+#[allow(non_snake_case)]\n+impl TextDecoderCommon {\n+    pub(crate) fn new_inherited(\n+        encoding: &'static Encoding,\n+        fatal: bool,\n+        ignoreBOM: bool,\n+    ) -> TextDecoderCommon {\n+        let decoder = if ignoreBOM {\n+            encoding.new_decoder()\n+        } else {\n+            encoding.new_decoder_without_bom_handling()\n+        };\n+\n+        TextDecoderCommon {\n+            encoding,\n+            fatal,\n+            ignoreBOM,\n+            decoder: RefCell::new(decoder),\n+            in_stream: RefCell::new(Vec::new()),\n+            do_not_flush: Cell::new(false),\n+        }\n+    }\n+\n+    pub(crate) fn encoding(&self) -> DOMString {\n+        DOMString::from(self.encoding.name().to_ascii_lowercase())\n+    }\n+\n+    pub(crate) fn fatal(&self) -> bool {\n+        self.fatal\n+    }\n+\n+    pub(crate) fn ignore_bom(&self) -> bool {\n+        self.ignoreBOM\n+    }\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-decode>\n+    #[allow(unsafe_code)]\n+    pub(crate) fn decode(\n+        &self,\n+        input: Option<&ArrayBufferViewOrArrayBuffer>,\n+        do_not_flush: bool,\n+    ) -> Fallible<String> {\n+        // Step 1. If this\u2019s do not flush is false, then set this\u2019s decoder to a\n+        // new instance of this\u2019s encoding\u2019s decoder, this\u2019s I/O queue to the\n+        // I/O queue of bytes \u00ab end-of-queue \u00bb, and this\u2019s BOM seen to false.\n+        if !self.do_not_flush.get() {\n+            if self.ignoreBOM {\n+                self.decoder\n+                    .replace(self.encoding.new_decoder_without_bom_handling());\n+            } else {\n+                self.decoder.replace(self.encoding.new_decoder());\n+            }\n+            self.in_stream.replace(Vec::new());\n+        }\n+\n+        // Step 2. Set this\u2019s do not flush to options[\"stream\"].\n+        self.do_not_flush.set(do_not_flush);\n+\n+        // Step 3. If input is given, then push a copy of input to this\u2019s I/O queue.\n+        match input {\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBufferView(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBuffer(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            None => {},\n+        };",
        "comment_created_at": "2025-07-23T08:51:41+00:00",
        "comment_author": "minghuaw",
        "comment_body": "In the new implementation, this copying only happens if there are leftover bytes. Otherwise, it would just use the input slice directly. Any bytes that are not consumed will then be stored in the decoder's I/O queue",
        "pr_file_module": null
      },
      {
        "comment_id": "2229155681",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/textdecodercommon.rs",
        "discussion_id": "2223829707",
        "commented_code": "@@ -0,0 +1,154 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::{Cell, RefCell};\n+\n+use encoding_rs::{Decoder, DecoderResult, Encoding};\n+use script_bindings::str::DOMString;\n+\n+use crate::dom::bindings::codegen::UnionTypes::ArrayBufferViewOrArrayBuffer;\n+use crate::dom::bindings::error::{Error, Fallible};\n+\n+/// The shared part of `TextDecoder` and `TextDecoderStream`\n+///\n+/// Note that other than the three attributes defined in the `TextDecoderCommon`\n+/// interface in the WebIDL, this also performs decoding.\n+///\n+/// <https://encoding.spec.whatwg.org/#textdecodercommon>\n+#[allow(non_snake_case)]\n+#[derive(JSTraceable, MallocSizeOf)]\n+pub(crate) struct TextDecoderCommon {\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-encoding>\n+    #[no_trace]\n+    encoding: &'static Encoding,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-fatal>\n+    fatal: bool,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-ignorebom>\n+    ignoreBOM: bool,\n+\n+    /// The native decoder that is used to perform decoding\n+    ///\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-decoder>\n+    #[ignore_malloc_size_of = \"defined in encoding_rs\"]\n+    #[no_trace]\n+    decoder: RefCell<Decoder>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-i-o-queue>\n+    in_stream: RefCell<Vec<u8>>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecoder-do-not-flush-flag>\n+    do_not_flush: Cell<bool>,\n+}\n+\n+#[allow(non_snake_case)]\n+impl TextDecoderCommon {\n+    pub(crate) fn new_inherited(\n+        encoding: &'static Encoding,\n+        fatal: bool,\n+        ignoreBOM: bool,\n+    ) -> TextDecoderCommon {\n+        let decoder = if ignoreBOM {\n+            encoding.new_decoder()\n+        } else {\n+            encoding.new_decoder_without_bom_handling()\n+        };\n+\n+        TextDecoderCommon {\n+            encoding,\n+            fatal,\n+            ignoreBOM,\n+            decoder: RefCell::new(decoder),\n+            in_stream: RefCell::new(Vec::new()),\n+            do_not_flush: Cell::new(false),\n+        }\n+    }\n+\n+    pub(crate) fn encoding(&self) -> DOMString {\n+        DOMString::from(self.encoding.name().to_ascii_lowercase())\n+    }\n+\n+    pub(crate) fn fatal(&self) -> bool {\n+        self.fatal\n+    }\n+\n+    pub(crate) fn ignore_bom(&self) -> bool {\n+        self.ignoreBOM\n+    }\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-decode>\n+    #[allow(unsafe_code)]\n+    pub(crate) fn decode(\n+        &self,\n+        input: Option<&ArrayBufferViewOrArrayBuffer>,\n+        do_not_flush: bool,\n+    ) -> Fallible<String> {\n+        // Step 1. If this\u2019s do not flush is false, then set this\u2019s decoder to a\n+        // new instance of this\u2019s encoding\u2019s decoder, this\u2019s I/O queue to the\n+        // I/O queue of bytes \u00ab end-of-queue \u00bb, and this\u2019s BOM seen to false.\n+        if !self.do_not_flush.get() {\n+            if self.ignoreBOM {\n+                self.decoder\n+                    .replace(self.encoding.new_decoder_without_bom_handling());\n+            } else {\n+                self.decoder.replace(self.encoding.new_decoder());\n+            }\n+            self.in_stream.replace(Vec::new());\n+        }\n+\n+        // Step 2. Set this\u2019s do not flush to options[\"stream\"].\n+        self.do_not_flush.set(do_not_flush);\n+\n+        // Step 3. If input is given, then push a copy of input to this\u2019s I/O queue.\n+        match input {\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBufferView(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBuffer(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            None => {},\n+        };",
        "comment_created_at": "2025-07-24T17:42:47+00:00",
        "comment_author": "gterzian",
        "comment_body": "What do you mean with the new implementation? In the current code, the `extend_from_slice` call clones the data rigtht? I think to avoid the copy you'd have to store the buffer in the I/O queue, and pass slices of it to the decoder?\r\n\r\nGood for a follow-up.",
        "pr_file_module": null
      },
      {
        "comment_id": "2229903536",
        "repo_full_name": "servo/servo",
        "pr_number": 38112,
        "pr_file": "components/script/dom/textdecodercommon.rs",
        "discussion_id": "2223829707",
        "commented_code": "@@ -0,0 +1,154 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::{Cell, RefCell};\n+\n+use encoding_rs::{Decoder, DecoderResult, Encoding};\n+use script_bindings::str::DOMString;\n+\n+use crate::dom::bindings::codegen::UnionTypes::ArrayBufferViewOrArrayBuffer;\n+use crate::dom::bindings::error::{Error, Fallible};\n+\n+/// The shared part of `TextDecoder` and `TextDecoderStream`\n+///\n+/// Note that other than the three attributes defined in the `TextDecoderCommon`\n+/// interface in the WebIDL, this also performs decoding.\n+///\n+/// <https://encoding.spec.whatwg.org/#textdecodercommon>\n+#[allow(non_snake_case)]\n+#[derive(JSTraceable, MallocSizeOf)]\n+pub(crate) struct TextDecoderCommon {\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-encoding>\n+    #[no_trace]\n+    encoding: &'static Encoding,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-fatal>\n+    fatal: bool,\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-ignorebom>\n+    ignoreBOM: bool,\n+\n+    /// The native decoder that is used to perform decoding\n+    ///\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-decoder>\n+    #[ignore_malloc_size_of = \"defined in encoding_rs\"]\n+    #[no_trace]\n+    decoder: RefCell<Decoder>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecodercommon-i-o-queue>\n+    in_stream: RefCell<Vec<u8>>,\n+\n+    /// <https://encoding.spec.whatwg.org/#textdecoder-do-not-flush-flag>\n+    do_not_flush: Cell<bool>,\n+}\n+\n+#[allow(non_snake_case)]\n+impl TextDecoderCommon {\n+    pub(crate) fn new_inherited(\n+        encoding: &'static Encoding,\n+        fatal: bool,\n+        ignoreBOM: bool,\n+    ) -> TextDecoderCommon {\n+        let decoder = if ignoreBOM {\n+            encoding.new_decoder()\n+        } else {\n+            encoding.new_decoder_without_bom_handling()\n+        };\n+\n+        TextDecoderCommon {\n+            encoding,\n+            fatal,\n+            ignoreBOM,\n+            decoder: RefCell::new(decoder),\n+            in_stream: RefCell::new(Vec::new()),\n+            do_not_flush: Cell::new(false),\n+        }\n+    }\n+\n+    pub(crate) fn encoding(&self) -> DOMString {\n+        DOMString::from(self.encoding.name().to_ascii_lowercase())\n+    }\n+\n+    pub(crate) fn fatal(&self) -> bool {\n+        self.fatal\n+    }\n+\n+    pub(crate) fn ignore_bom(&self) -> bool {\n+        self.ignoreBOM\n+    }\n+\n+    /// <https://encoding.spec.whatwg.org/#dom-textdecoder-decode>\n+    #[allow(unsafe_code)]\n+    pub(crate) fn decode(\n+        &self,\n+        input: Option<&ArrayBufferViewOrArrayBuffer>,\n+        do_not_flush: bool,\n+    ) -> Fallible<String> {\n+        // Step 1. If this\u2019s do not flush is false, then set this\u2019s decoder to a\n+        // new instance of this\u2019s encoding\u2019s decoder, this\u2019s I/O queue to the\n+        // I/O queue of bytes \u00ab end-of-queue \u00bb, and this\u2019s BOM seen to false.\n+        if !self.do_not_flush.get() {\n+            if self.ignoreBOM {\n+                self.decoder\n+                    .replace(self.encoding.new_decoder_without_bom_handling());\n+            } else {\n+                self.decoder.replace(self.encoding.new_decoder());\n+            }\n+            self.in_stream.replace(Vec::new());\n+        }\n+\n+        // Step 2. Set this\u2019s do not flush to options[\"stream\"].\n+        self.do_not_flush.set(do_not_flush);\n+\n+        // Step 3. If input is given, then push a copy of input to this\u2019s I/O queue.\n+        match input {\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBufferView(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            Some(ArrayBufferViewOrArrayBuffer::ArrayBuffer(a)) => {\n+                self.in_stream\n+                    .borrow_mut()\n+                    .extend_from_slice(unsafe { a.as_slice() });\n+            },\n+            None => {},\n+        };",
        "comment_created_at": "2025-07-25T01:19:25+00:00",
        "comment_author": "minghuaw",
        "comment_body": "I meant the changes introduced in [a5bc680](https://github.com/servo/servo/pull/38112/commits/a5bc68035c2ebb32a6c2570f62021e0465e31b00). GitHub somehow didn't mark this as outdated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2028061618",
    "pr_number": 36304,
    "pr_file": "components/net/resource_thread.rs",
    "created_at": "2025-04-04T04:19:46+00:00",
    "commented_code": "}\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2028061618",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028061618",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();",
        "comment_created_at": "2025-04-04T04:19:46+00:00",
        "comment_author": "webbeef",
        "comment_body": "here and in other methods: don't create `display` until you need it.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2318580037",
    "pr_number": 38717,
    "pr_file": "components/script/dom/document.rs",
    "created_at": "2025-09-03T10:47:30+00:00",
    "commented_code": "}\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2318580037",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T10:47:30+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Hrm. I think this could end up hiding the future problems. What is the flow that causes this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2318645800",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:17:05+00:00",
        "comment_author": "sagudev",
        "comment_body": "Update the rendering does immut borrow, that trigger update the rendering which calls expire current the texture and remarks canvas as dirty.",
        "pr_file_module": null
      },
      {
        "comment_id": "2318654113",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:20:56+00:00",
        "comment_author": "mrobinson",
        "comment_body": "In order to avoid hiding issues in the future I recommend draining the dirty canvases in `fn update_the_rendering()`, stop the borrow, and only then calling `fn update_the_rendering()` on the dirty canvases.\r\n\r\nOut of curiosity, why does calling `fn update_the_rendering()` cause the canvas to become dirty again? Doesn't this mean the canvas will *always* be dirty?",
        "pr_file_module": null
      },
      {
        "comment_id": "2318676952",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:31:02+00:00",
        "comment_author": "sagudev",
        "comment_body": "> In order to avoid hiding issues in the future I recommend draining the dirty canvases in fn update_the_rendering(), stop the borrow, and only then calling fn update_the_rendering() on the dirty canvases.\r\n\r\nDrain iter holds the borrow unfortunately.",
        "pr_file_module": null
      },
      {
        "comment_id": "2318685874",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:35:09+00:00",
        "comment_author": "sagudev",
        "comment_body": "> Doesn't this mean the canvas will always be dirty?\r\n\r\nNo. This happens before layout, which clear dirty node.\r\n\r\n> Out of curiosity, why does calling fn update_the_rendering() cause the canvas to become dirty again?\r\n\r\nExpire current texture.",
        "pr_file_module": null
      },
      {
        "comment_id": "2318697695",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:40:48+00:00",
        "comment_author": "mrobinson",
        "comment_body": "> > Doesn't this mean the canvas will always be dirty?\r\n> \r\n> No. This happens before layout, which clear dirty node.\r\n\r\nEventually WebGPU canvases will only update their rendering when they are in the list of dirty canvases, so it would be better to avoid marking them dirty while we are in the process of marking them as not dirty. Even if that was not going to be the case, if you constantly add them to the list of dirty canvases, they will always be updated during layout even if it isn't necessary leading to unnecessary image updates and slowing down rendering.\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2318714277",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:48:11+00:00",
        "comment_author": "sagudev",
        "comment_body": "Ah, that's exactly why we ignore borrow problem here and return. If we are in update the rendering this canvas was already marked as dirty so we do not readd it to dirty canvases and let dirty do it's work.",
        "pr_file_module": null
      },
      {
        "comment_id": "2318729276",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T11:54:34+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Ah, I see. I think it would be better to be a bit explicit to avoid hiding future problems. Maybe pass an `updating_the_rendering` variable down to or having a `updating_the_rendering: Cell<bool>` on the struct. When this is true we wouldn't mark the canvas as dirty recursively.",
        "pr_file_module": null
      },
      {
        "comment_id": "2318747272",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/script/dom/document.rs",
        "discussion_id": "2318580037",
        "commented_code": "@@ -2632,8 +2626,14 @@ impl Document {\n     }\n \n     #[cfg(feature = \"webgpu\")]\n-    pub(crate) fn webgpu_contexts(&self) -> WebGPUContextsMap {\n-        self.webgpu_contexts.clone()\n+    pub(crate) fn add_dirty_webgpu_context(&self, context: &GPUCanvasContext) {\n+        let Ok(mut dirty_webgpu_contexts) = self.dirty_webgpu_contexts.try_borrow_mut() else {\n+            // ignore already borrowed problem, that happens when updating the rendering\n+            return;\n+        };",
        "comment_created_at": "2025-09-03T12:02:12+00:00",
        "comment_author": "sagudev",
        "comment_body": "I would like to avoid any state machine (`updating_the_rendering: Cell<bool>`), so I think I will just pass down, update_the_rendering and skip dirty altogether.",
        "pr_file_module": null
      }
    ]
  }
]