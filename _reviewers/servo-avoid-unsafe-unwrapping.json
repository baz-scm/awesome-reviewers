[
  {
    "discussion_id": "2454175771",
    "pr_number": 39384,
    "pr_file": "components/shared/compositing/largest_contentful_paint_candidate.rs",
    "created_at": "2025-10-23T07:24:43+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+//! Definitions for Largest Contentful Paint Candidate and Largest Contentful Paint.\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Clone, Copy, Debug, Deserialize, Serialize)]\n+pub enum LargestContentfulPaintType {\n+    None = -1,",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2454175771",
        "repo_full_name": "servo/servo",
        "pr_number": 39384,
        "pr_file": "components/shared/compositing/largest_contentful_paint_candidate.rs",
        "discussion_id": "2454175771",
        "commented_code": "@@ -0,0 +1,75 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+//! Definitions for Largest Contentful Paint Candidate and Largest Contentful Paint.\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Clone, Copy, Debug, Deserialize, Serialize)]\n+pub enum LargestContentfulPaintType {\n+    None = -1,",
        "comment_created_at": "2025-10-23T07:24:43+00:00",
        "comment_author": "xiaochengh",
        "comment_body": "Hmm, this seems like an antipattern in Rust...\n\nCan we get rid of `LargestContentfulPaintType::None`, `LCPCandidateID::Invalid`, and use `Option<LCPCandidate>` instead of creating an `LCPCandidate` without meaning value?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1805174785",
    "pr_number": 31746,
    "pr_file": "components/script/dom/htmlmediaelement.rs",
    "created_at": "2024-10-17T17:47:33+00:00",
    "commented_code": ".map(|holder| holder.get_frame())\n     }\n \n+    pub fn get_current_frame_data(&self) -> Option<MediaFrame> {\n+        self.video_renderer.lock().unwrap().current_frame\n+    }\n+\n+    pub fn clear_current_frame_data(&self) {\n+        self.handle_resize(None, None);\n+        self.video_renderer.lock().unwrap().current_frame = None\n+    }\n+\n+    fn handle_resize(&self, width: Option<u32>, height: Option<u32>) {\n+        if self.is::<HTMLVideoElement>() {\n+            let video_elem = self.downcast::<HTMLVideoElement>().unwrap();\n+            video_elem.resize(width, height);\n+        }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "1805174785",
        "repo_full_name": "servo/servo",
        "pr_number": 31746,
        "pr_file": "components/script/dom/htmlmediaelement.rs",
        "discussion_id": "1805174785",
        "commented_code": "@@ -1982,6 +1986,22 @@ impl HTMLMediaElement {\n             .map(|holder| holder.get_frame())\n     }\n \n+    pub fn get_current_frame_data(&self) -> Option<MediaFrame> {\n+        self.video_renderer.lock().unwrap().current_frame\n+    }\n+\n+    pub fn clear_current_frame_data(&self) {\n+        self.handle_resize(None, None);\n+        self.video_renderer.lock().unwrap().current_frame = None\n+    }\n+\n+    fn handle_resize(&self, width: Option<u32>, height: Option<u32>) {\n+        if self.is::<HTMLVideoElement>() {\n+            let video_elem = self.downcast::<HTMLVideoElement>().unwrap();\n+            video_elem.resize(width, height);\n+        }",
        "comment_created_at": "2024-10-17T17:47:33+00:00",
        "comment_author": "Loirooriol",
        "comment_body": "```suggestion\r\n        if let Some(video_elem) = self.downcast::<HTMLVideoElement>() {\r\n            video_elem.resize(width, height);\r\n        }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2413556919",
    "pr_number": 39661,
    "pr_file": "components/script/dom/html/htmlbuttonelement.rs",
    "created_at": "2025-10-08T11:33:56+00:00",
    "commented_code": "!self.upcast::<Element>().disabled_state()\n     }\n \n-    // https://html.spec.whatwg.org/multipage/#run-post-click-activation-steps\n-    fn activation_behavior(&self, _event: &Event, _target: &EventTarget, can_gc: CanGc) {\n+    // https://html.spec.whatwg.org/multipage/#the-button-element:activation-behaviour\n+    fn activation_behavior(&self, _event: &Event, target: &EventTarget, can_gc: CanGc) {\n         let ty = self.button_type.get();\n         match ty {\n-            // https://html.spec.whatwg.org/multipage/#attr-button-type-submit-state\n+            // https://html.spec.whatwg.org/multipage/#the-button-element:attr-button-type-submit-state\n             ButtonType::Submit => {\n-                // TODO: is document owner fully active?\n+                // Step 2. If element's node document is not fully active, then return.\n+                if !target\n+                    .downcast::<Node>()\n+                    .unwrap()",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2413556919",
        "repo_full_name": "servo/servo",
        "pr_number": 39661,
        "pr_file": "components/script/dom/html/htmlbuttonelement.rs",
        "discussion_id": "2413556919",
        "commented_code": "@@ -358,13 +358,21 @@ impl Activatable for HTMLButtonElement {\n         !self.upcast::<Element>().disabled_state()\n     }\n \n-    // https://html.spec.whatwg.org/multipage/#run-post-click-activation-steps\n-    fn activation_behavior(&self, _event: &Event, _target: &EventTarget, can_gc: CanGc) {\n+    // https://html.spec.whatwg.org/multipage/#the-button-element:activation-behaviour\n+    fn activation_behavior(&self, _event: &Event, target: &EventTarget, can_gc: CanGc) {\n         let ty = self.button_type.get();\n         match ty {\n-            // https://html.spec.whatwg.org/multipage/#attr-button-type-submit-state\n+            // https://html.spec.whatwg.org/multipage/#the-button-element:attr-button-type-submit-state\n             ButtonType::Submit => {\n-                // TODO: is document owner fully active?\n+                // Step 2. If element's node document is not fully active, then return.\n+                if !target\n+                    .downcast::<Node>()\n+                    .unwrap()",
        "comment_created_at": "2025-10-08T11:33:56+00:00",
        "comment_author": "mrobinson",
        "comment_body": "If it's possible that the `EventTarget` isn't a node, you should gracefully handle this failure and not panic here.\r\n\r\n```\r\nif !target.downcast::<Node>().is_none_or(|node| node.owner_document()).is_fully_active()) {\r\n    return;\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2413582233",
        "repo_full_name": "servo/servo",
        "pr_number": 39661,
        "pr_file": "components/script/dom/html/htmlbuttonelement.rs",
        "discussion_id": "2413556919",
        "commented_code": "@@ -358,13 +358,21 @@ impl Activatable for HTMLButtonElement {\n         !self.upcast::<Element>().disabled_state()\n     }\n \n-    // https://html.spec.whatwg.org/multipage/#run-post-click-activation-steps\n-    fn activation_behavior(&self, _event: &Event, _target: &EventTarget, can_gc: CanGc) {\n+    // https://html.spec.whatwg.org/multipage/#the-button-element:activation-behaviour\n+    fn activation_behavior(&self, _event: &Event, target: &EventTarget, can_gc: CanGc) {\n         let ty = self.button_type.get();\n         match ty {\n-            // https://html.spec.whatwg.org/multipage/#attr-button-type-submit-state\n+            // https://html.spec.whatwg.org/multipage/#the-button-element:attr-button-type-submit-state\n             ButtonType::Submit => {\n-                // TODO: is document owner fully active?\n+                // Step 2. If element's node document is not fully active, then return.\n+                if !target\n+                    .downcast::<Node>()\n+                    .unwrap()",
        "comment_created_at": "2025-10-08T11:44:15+00:00",
        "comment_author": "WaterWhisperer",
        "comment_body": "> If it's possible that the `EventTarget` isn't a node, you should gracefully handle this failure and not panic here.\r\n> \r\n> ```\r\n> if !target.downcast::<Node>().is_none_or(|node| node.owner_document().is_fully_active()) {\r\n>     return;\r\n> }\r\n> ```\r\n\r\nI see, thank you for your careful guidance",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2387132443",
    "pr_number": 39140,
    "pr_file": "components/servo/webview.rs",
    "created_at": "2025-09-29T08:34:09+00:00",
    "commented_code": "webview.set_animating(new_value);\n         }\n     }\n+\n+    fn rendering_group_id(&self) -> RenderingGroupId {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2387132443",
        "repo_full_name": "servo/servo",
        "pr_number": 39140,
        "pr_file": "components/servo/webview.rs",
        "discussion_id": "2387132443",
        "commented_code": "@@ -604,6 +612,14 @@ impl WebViewTrait for ServoRendererWebView {\n             webview.set_animating(new_value);\n         }\n     }\n+\n+    fn rendering_group_id(&self) -> RenderingGroupId {",
        "comment_created_at": "2025-09-29T08:34:09+00:00",
        "comment_author": "jdm",
        "comment_body": "This seems like it should be an Option instead of returning a default.",
        "pr_file_module": null
      },
      {
        "comment_id": "2387237357",
        "repo_full_name": "servo/servo",
        "pr_number": 39140,
        "pr_file": "components/servo/webview.rs",
        "discussion_id": "2387132443",
        "commented_code": "@@ -604,6 +612,14 @@ impl WebViewTrait for ServoRendererWebView {\n             webview.set_animating(new_value);\n         }\n     }\n+\n+    fn rendering_group_id(&self) -> RenderingGroupId {",
        "comment_created_at": "2025-09-29T09:09:04+00:00",
        "comment_author": "Narfinger",
        "comment_body": "So the idea is that the first RenderingGroupId is the default one and every WebView has to belong to one RenderingGroupId.\r\nI feel like using the Option here will make it more difficult throughout the codebase to keep the default RenderingGroupId consistent.",
        "pr_file_module": null
      },
      {
        "comment_id": "2387254736",
        "repo_full_name": "servo/servo",
        "pr_number": 39140,
        "pr_file": "components/servo/webview.rs",
        "discussion_id": "2387132443",
        "commented_code": "@@ -604,6 +612,14 @@ impl WebViewTrait for ServoRendererWebView {\n             webview.set_animating(new_value);\n         }\n     }\n+\n+    fn rendering_group_id(&self) -> RenderingGroupId {",
        "comment_created_at": "2025-09-29T09:14:53+00:00",
        "comment_author": "jdm",
        "comment_body": "For this particular method, we're not returning a default because no value was specified, but instead making up a value because there is no webview at all. That seems like something that callers should need to address.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230618932",
    "pr_number": 38041,
    "pr_file": "components/shared/compositing/largest_contentful_paint_candidate.rs",
    "created_at": "2025-07-25T09:24:07+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use serde::{Deserialize, Serialize};\n+use webrender_api::Epoch;\n+\n+/// Largest Contentful Paint Candidate, include image and block-level element containing text\n+#[derive(Clone, Copy, Deserialize, Serialize)]\n+pub struct LCPCandidate {\n+    /// The identity of the element.\n+    id: LCPCandidateID,\n+    /// The size of the visual area\n+    area: usize,\n+    /// The epoch when the image is drawn.\n+    epoch: Epoch,\n+}\n+\n+impl LCPCandidate {\n+    pub fn new(id: LCPCandidateID, area: usize, epoch: Epoch) -> Self {\n+        Self { id, area, epoch }\n+    }\n+\n+    #[inline]\n+    pub fn area(&self) -> usize {\n+        self.area\n+    }\n+\n+    #[inline]\n+    pub fn id(&self) -> LCPCandidateID {\n+        self.id\n+    }\n+\n+    #[inline]\n+    pub fn epoch(&self) -> Epoch {\n+        self.epoch\n+    }\n+}\n+\n+impl Default for LCPCandidate {\n+    fn default() -> Self {\n+        Self {\n+            id: LCPCandidateID::INVALID,\n+            area: 0,\n+            epoch: Epoch::invalid(),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]\n+pub struct LCPCandidateID(pub usize);\n+\n+impl LCPCandidateID {\n+    pub const INVALID: LCPCandidateID = LCPCandidateID(0);",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2230618932",
        "repo_full_name": "servo/servo",
        "pr_number": 38041,
        "pr_file": "components/shared/compositing/largest_contentful_paint_candidate.rs",
        "discussion_id": "2230618932",
        "commented_code": "@@ -0,0 +1,79 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use serde::{Deserialize, Serialize};\n+use webrender_api::Epoch;\n+\n+/// Largest Contentful Paint Candidate, include image and block-level element containing text\n+#[derive(Clone, Copy, Deserialize, Serialize)]\n+pub struct LCPCandidate {\n+    /// The identity of the element.\n+    id: LCPCandidateID,\n+    /// The size of the visual area\n+    area: usize,\n+    /// The epoch when the image is drawn.\n+    epoch: Epoch,\n+}\n+\n+impl LCPCandidate {\n+    pub fn new(id: LCPCandidateID, area: usize, epoch: Epoch) -> Self {\n+        Self { id, area, epoch }\n+    }\n+\n+    #[inline]\n+    pub fn area(&self) -> usize {\n+        self.area\n+    }\n+\n+    #[inline]\n+    pub fn id(&self) -> LCPCandidateID {\n+        self.id\n+    }\n+\n+    #[inline]\n+    pub fn epoch(&self) -> Epoch {\n+        self.epoch\n+    }\n+}\n+\n+impl Default for LCPCandidate {\n+    fn default() -> Self {\n+        Self {\n+            id: LCPCandidateID::INVALID,\n+            area: 0,\n+            epoch: Epoch::invalid(),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]\n+pub struct LCPCandidateID(pub usize);\n+\n+impl LCPCandidateID {\n+    pub const INVALID: LCPCandidateID = LCPCandidateID(0);",
        "comment_created_at": "2025-07-25T09:24:07+00:00",
        "comment_author": "xiaochengh",
        "comment_body": "```suggestion\r\n    pub const INVALID: LCPCandidateID = Default::default();\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2254604008",
        "repo_full_name": "servo/servo",
        "pr_number": 38041,
        "pr_file": "components/shared/compositing/largest_contentful_paint_candidate.rs",
        "discussion_id": "2230618932",
        "commented_code": "@@ -0,0 +1,79 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use serde::{Deserialize, Serialize};\n+use webrender_api::Epoch;\n+\n+/// Largest Contentful Paint Candidate, include image and block-level element containing text\n+#[derive(Clone, Copy, Deserialize, Serialize)]\n+pub struct LCPCandidate {\n+    /// The identity of the element.\n+    id: LCPCandidateID,\n+    /// The size of the visual area\n+    area: usize,\n+    /// The epoch when the image is drawn.\n+    epoch: Epoch,\n+}\n+\n+impl LCPCandidate {\n+    pub fn new(id: LCPCandidateID, area: usize, epoch: Epoch) -> Self {\n+        Self { id, area, epoch }\n+    }\n+\n+    #[inline]\n+    pub fn area(&self) -> usize {\n+        self.area\n+    }\n+\n+    #[inline]\n+    pub fn id(&self) -> LCPCandidateID {\n+        self.id\n+    }\n+\n+    #[inline]\n+    pub fn epoch(&self) -> Epoch {\n+        self.epoch\n+    }\n+}\n+\n+impl Default for LCPCandidate {\n+    fn default() -> Self {\n+        Self {\n+            id: LCPCandidateID::INVALID,\n+            area: 0,\n+            epoch: Epoch::invalid(),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]\n+pub struct LCPCandidateID(pub usize);\n+\n+impl LCPCandidateID {\n+    pub const INVALID: LCPCandidateID = LCPCandidateID(0);",
        "comment_created_at": "2025-08-05T14:52:59+00:00",
        "comment_author": "boluochoufeng",
        "comment_body": "> \r\n\r\ndefault() is not const fn.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2295516838",
    "pr_number": 38738,
    "pr_file": "components/script/dom/idbtransaction.rs",
    "created_at": "2025-08-23T09:13:27+00:00",
    "commented_code": "fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2295516838",
        "repo_full_name": "servo/servo",
        "pr_number": 38738,
        "pr_file": "components/script/dom/idbtransaction.rs",
        "discussion_id": "2295516838",
        "commented_code": "@@ -204,6 +206,55 @@ impl IDBTransaction {\n     fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();",
        "comment_created_at": "2025-08-23T09:13:27+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please use `expect` here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2295516967",
    "pr_number": 38738,
    "pr_file": "components/script/dom/idbtransaction.rs",
    "created_at": "2025-08-23T09:14:07+00:00",
    "commented_code": "fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();\n+\n+        // First unwrap for ipc\n+        // Second unwrap will never happen unless this db gets manually deleted somehow\n+        let auto_increment = receiver.recv().unwrap().ok()?;",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2295516967",
        "repo_full_name": "servo/servo",
        "pr_number": 38738,
        "pr_file": "components/script/dom/idbtransaction.rs",
        "discussion_id": "2295516967",
        "commented_code": "@@ -204,6 +206,55 @@ impl IDBTransaction {\n     fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();\n+\n+        // First unwrap for ipc\n+        // Second unwrap will never happen unless this db gets manually deleted somehow\n+        let auto_increment = receiver.recv().unwrap().ok()?;",
        "comment_created_at": "2025-08-23T09:14:07+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Why use `unwrap` and then `?` ?  Instead return `None`  with any failure.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2295517041",
    "pr_number": 38738,
    "pr_file": "components/script/dom/idbtransaction.rs",
    "created_at": "2025-08-23T09:14:34+00:00",
    "commented_code": "fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();\n+\n+        // First unwrap for ipc\n+        // Second unwrap will never happen unless this db gets manually deleted somehow\n+        let auto_increment = receiver.recv().unwrap().ok()?;\n+\n+        let (sender, receiver) = ipc::channel(self.global().time_profiler_chan().clone()).unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2295517041",
        "repo_full_name": "servo/servo",
        "pr_number": 38738,
        "pr_file": "components/script/dom/idbtransaction.rs",
        "discussion_id": "2295517041",
        "commented_code": "@@ -204,6 +206,55 @@ impl IDBTransaction {\n     fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();\n+\n+        // First unwrap for ipc\n+        // Second unwrap will never happen unless this db gets manually deleted somehow\n+        let auto_increment = receiver.recv().unwrap().ok()?;\n+\n+        let (sender, receiver) = ipc::channel(self.global().time_profiler_chan().clone()).unwrap();",
        "comment_created_at": "2025-08-23T09:14:34+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Use `expect` or return `None` on IPC failure.",
        "pr_file_module": null
      }
    ]
  }
]