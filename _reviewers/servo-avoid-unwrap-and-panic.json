[
  {
    "discussion_id": "2453364264",
    "pr_number": 40084,
    "pr_file": "components/script/dom/canvas/imagedata.rs",
    "created_at": "2025-10-22T21:11:12+00:00",
    "commented_code": "}\n }\n \n+impl Serializable for ImageData {\n+    type Index = ImageDataIndex;\n+    type Data = SerializableImageData;\n+\n+    /// <https://html.spec.whatwg.org/multipage/#the-imagedata-interface:serializable-objects>\n+    fn serialize(&self) -> Result<(ImageDataId, Self::Data), ()> {\n+        // Step 1 Set serialized.[[Data]] to the sub-serialization of the value of value's data attribute.\n+        let data = self.to_vec();\n+\n+        // Step 2 Set serialized.[[Width]] to the value of value's width attribute.\n+        // Step 3 Set serialized.[[Height]] to the value of value's height attribute.\n+        // Step 4 Set serialized.[[ColorSpace]] to the value of value's colorSpace attribute.\n+        // Step 5 Set serialized.[[PixelFormat]] to the value of value's pixelFormat attribute.\n+        // Note: Since we don't support Float16Array and display-p3 color space\n+        // we don't need to serialize colorSpace and pixelFormat\n+        let serialized = SerializableImageData {\n+            data,\n+            width: self.width,\n+            height: self.height,\n+        };\n+        Ok((ImageDataId::new(), serialized))\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#the-imagedata-interface:deserialization-steps>\n+    fn deserialize(\n+        owner: &GlobalScope,\n+        serialized: Self::Data,\n+        can_gc: CanGc,\n+    ) -> Result<DomRoot<Self>, ()> {\n+        // Step 1 Initialize value's data attribute to the sub-deserialization of serialized.[[Data]].\n+        // Step 2 Initialize value's width attribute to serialized.[[Width]].\n+        // Step 3 Initialize value's height attribute to serialized.[[Height]].\n+        // Step 4 Initialize value's colorSpace attribute to serialized.[[ColorSpace]].\n+        // Step 5 Initialize value's pixelFormat attribute to serialized.[[PixelFormat]].\n+        let image_data = ImageData::new(\n+            owner,\n+            serialized.width,\n+            serialized.height,\n+            Some(serialized.data),\n+            can_gc,\n+        )\n+        .unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2453364264",
        "repo_full_name": "servo/servo",
        "pr_number": 40084,
        "pr_file": "components/script/dom/canvas/imagedata.rs",
        "discussion_id": "2453364264",
        "commented_code": "@@ -210,6 +215,62 @@ impl ImageData {\n     }\n }\n \n+impl Serializable for ImageData {\n+    type Index = ImageDataIndex;\n+    type Data = SerializableImageData;\n+\n+    /// <https://html.spec.whatwg.org/multipage/#the-imagedata-interface:serializable-objects>\n+    fn serialize(&self) -> Result<(ImageDataId, Self::Data), ()> {\n+        // Step 1 Set serialized.[[Data]] to the sub-serialization of the value of value's data attribute.\n+        let data = self.to_vec();\n+\n+        // Step 2 Set serialized.[[Width]] to the value of value's width attribute.\n+        // Step 3 Set serialized.[[Height]] to the value of value's height attribute.\n+        // Step 4 Set serialized.[[ColorSpace]] to the value of value's colorSpace attribute.\n+        // Step 5 Set serialized.[[PixelFormat]] to the value of value's pixelFormat attribute.\n+        // Note: Since we don't support Float16Array and display-p3 color space\n+        // we don't need to serialize colorSpace and pixelFormat\n+        let serialized = SerializableImageData {\n+            data,\n+            width: self.width,\n+            height: self.height,\n+        };\n+        Ok((ImageDataId::new(), serialized))\n+    }\n+\n+    /// <https://html.spec.whatwg.org/multipage/#the-imagedata-interface:deserialization-steps>\n+    fn deserialize(\n+        owner: &GlobalScope,\n+        serialized: Self::Data,\n+        can_gc: CanGc,\n+    ) -> Result<DomRoot<Self>, ()> {\n+        // Step 1 Initialize value's data attribute to the sub-deserialization of serialized.[[Data]].\n+        // Step 2 Initialize value's width attribute to serialized.[[Width]].\n+        // Step 3 Initialize value's height attribute to serialized.[[Height]].\n+        // Step 4 Initialize value's colorSpace attribute to serialized.[[ColorSpace]].\n+        // Step 5 Initialize value's pixelFormat attribute to serialized.[[PixelFormat]].\n+        let image_data = ImageData::new(\n+            owner,\n+            serialized.width,\n+            serialized.height,\n+            Some(serialized.data),\n+            can_gc,\n+        )\n+        .unwrap();",
        "comment_created_at": "2025-10-22T21:11:12+00:00",
        "comment_author": "jdm",
        "comment_body": "Let's return an error instead of unwrapping.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1714968192",
    "pr_number": 33025,
    "pr_file": "components/devtools/actors/browsing_context.rs",
    "created_at": "2024-08-13T09:25:45+00:00",
    "commented_code": "let accessibility = AccessibilityActor::new(actors.new_name(\"accessibility\"));\n \n-        let css_properties = CssPropertiesActor::new(actors.new_name(\"css-properties\"));\n+        let (tx, rx) = ipc::channel().unwrap();\n+        script_sender.send(GetCssDatabase(tx)).unwrap();\n+        let properties = rx.recv().unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "1714968192",
        "repo_full_name": "servo/servo",
        "pr_number": 33025,
        "pr_file": "components/devtools/actors/browsing_context.rs",
        "discussion_id": "1714968192",
        "commented_code": "@@ -229,7 +229,10 @@ impl BrowsingContextActor {\n \n         let accessibility = AccessibilityActor::new(actors.new_name(\"accessibility\"));\n \n-        let css_properties = CssPropertiesActor::new(actors.new_name(\"css-properties\"));\n+        let (tx, rx) = ipc::channel().unwrap();\n+        script_sender.send(GetCssDatabase(tx)).unwrap();\n+        let properties = rx.recv().unwrap();",
        "comment_created_at": "2024-08-13T09:25:45+00:00",
        "comment_author": "Taym95",
        "comment_body": "should we at least use `expect` with message or print warning for `.send` and `.recv`? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1716700097",
        "repo_full_name": "servo/servo",
        "pr_number": 33025,
        "pr_file": "components/devtools/actors/browsing_context.rs",
        "discussion_id": "1714968192",
        "commented_code": "@@ -229,7 +229,10 @@ impl BrowsingContextActor {\n \n         let accessibility = AccessibilityActor::new(actors.new_name(\"accessibility\"));\n \n-        let css_properties = CssPropertiesActor::new(actors.new_name(\"css-properties\"));\n+        let (tx, rx) = ipc::channel().unwrap();\n+        script_sender.send(GetCssDatabase(tx)).unwrap();\n+        let properties = rx.recv().unwrap();",
        "comment_created_at": "2024-08-14T10:39:53+00:00",
        "comment_author": "eerii",
        "comment_body": "Definitely, I was quickly testing that everything worked but it needs some clean up. Thank you for pointing it out!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2413412070",
    "pr_number": 39715,
    "pr_file": "components/webdriver_server/elements.rs",
    "created_at": "2025-10-08T10:35:40+00:00",
    "commented_code": ".collect::<WebDriverResult<Vec<String>>>()?;\n                 format!(\"{{{}}}\", elems.join(\", \"))\n             },\n+            _ => serde_json::to_string(v).unwrap(),",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2413412070",
        "repo_full_name": "servo/servo",
        "pr_number": 39715,
        "pr_file": "components/webdriver_server/elements.rs",
        "discussion_id": "2413412070",
        "commented_code": "@@ -137,6 +133,7 @@ impl Handler {\n                     .collect::<WebDriverResult<Vec<String>>>()?;\n                 format!(\"{{{}}}\", elems.join(\", \"))\n             },\n+            _ => serde_json::to_string(v).unwrap(),",
        "comment_created_at": "2025-10-08T10:35:40+00:00",
        "comment_author": "mrobinson",
        "comment_body": "If this fails, maybe you can return a WebDriver error instead of panicking here?\r\n\r\n```suggestion\r\n            _ => serde_json::to_string(v).unwrap(),\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2028062338",
    "pr_number": 36304,
    "pr_file": "components/net/resource_thread.rs",
    "created_at": "2025-04-04T04:21:00+00:00",
    "commented_code": "}\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2028062338",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-04T04:21:00+00:00",
        "comment_author": "webbeef",
        "comment_body": "Can we not panic and deal with errors instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2030693447",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-07T08:13:31+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "Do you mean log the error instead of panic? Or is there a way to deal with the error of creating the file.",
        "pr_file_module": null
      },
      {
        "comment_id": "2031606407",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-07T16:28:49+00:00",
        "comment_author": "webbeef",
        "comment_body": "What I mean is that instead of crashing the whole page, we should bubble up an error to indicate that the storage operation failed. That can happen for various reasons (disk full, etc.) so failing to create the file is not that special.",
        "pr_file_module": null
      },
      {
        "comment_id": "2032224774",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-08T01:10:26+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "I see, then is logging the error as I did in the recent change is sufficient?",
        "pr_file_module": null
      },
      {
        "comment_id": "2032235266",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-08T01:25:56+00:00",
        "comment_author": "webbeef",
        "comment_body": "How is the api behaving if that creation failed? Will an exception be thrown at the calling site in the JS code?",
        "pr_file_module": null
      },
      {
        "comment_id": "2032288732",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-08T02:44:27+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "Hm, I do not think it will throw exception. Is there a way to throw this exception though?",
        "pr_file_module": null
      },
      {
        "comment_id": "2032303272",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-08T03:05:11+00:00",
        "comment_author": "webbeef",
        "comment_body": "Yes, for instance `setItem` is marked as a throwing function in https://github.com/servo/servo/blob/76e0b8ec063db9bdd4b0a54e366e4af415709101/components/script_bindings/webidls/Storage.webidl#L19",
        "pr_file_module": null
      },
      {
        "comment_id": "2035064180",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028062338",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);",
        "comment_created_at": "2025-04-09T10:20:18+00:00",
        "comment_author": "PotatoCP",
        "comment_body": "Ok, I have implemented the exception for creating the jsonl and json file. However there are two things remain here:\r\n\r\n1. When exiting, we cannot throw the exception (because well, the program is already exiting)\r\n2. Note that we have a [spec](https://html.spec.whatwg.org/multipage/#the-storage-interface) for `Storage.webidl`. And in this spec, we can only throw Exception (particularly QuotaExeededError) when we set item, and no other method. This meant that we cannot throw an exception when we append to `track_changes.jsonl`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2345505371",
    "pr_number": 39278,
    "pr_file": "components/script/dom/idbtransaction.rs",
    "created_at": "2025-09-12T21:57:49+00:00",
    "commented_code": ")))\n             .unwrap();\n \n-        receiver.recv().unwrap()\n+        receiver.recv().unwrap().unwrap()",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2345505371",
        "repo_full_name": "servo/servo",
        "pr_number": 39278,
        "pr_file": "components/script/dom/idbtransaction.rs",
        "discussion_id": "2345505371",
        "commented_code": "@@ -114,7 +114,7 @@ impl IDBTransaction {\n             )))\n             .unwrap();\n \n-        receiver.recv().unwrap()\n+        receiver.recv().unwrap().unwrap()",
        "comment_created_at": "2025-09-12T21:57:49+00:00",
        "comment_author": "jdm",
        "comment_body": "This just shifts the panic to another part of the engine. I'd prefer to make this method fallible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2349757303",
    "pr_number": 39320,
    "pr_file": "components/net/http_loader.rs",
    "created_at": "2025-09-15T18:10:20+00:00",
    "commented_code": "msg: ChromeToDevtoolsControlMsg,\n     devtools_chan: &Sender<DevtoolsControlMsg>,\n ) {\n-    devtools_chan\n-        .send(DevtoolsControlMsg::FromChrome(msg))\n-        .unwrap();\n+    if let Err(e) = devtools_chan.send(DevtoolsControlMsg::FromChrome(msg)) {\n+        panic!(\"{e}\");",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2349757303",
        "repo_full_name": "servo/servo",
        "pr_number": 39320,
        "pr_file": "components/net/http_loader.rs",
        "discussion_id": "2349757303",
        "commented_code": "@@ -430,9 +430,9 @@ pub fn send_request_to_devtools(\n     msg: ChromeToDevtoolsControlMsg,\n     devtools_chan: &Sender<DevtoolsControlMsg>,\n ) {\n-    devtools_chan\n-        .send(DevtoolsControlMsg::FromChrome(msg))\n-        .unwrap();\n+    if let Err(e) = devtools_chan.send(DevtoolsControlMsg::FromChrome(msg)) {\n+        panic!(\"{e}\");",
        "comment_created_at": "2025-09-15T18:10:20+00:00",
        "comment_author": "Taym95",
        "comment_body": "Replacing .unwrap() with panic!() doesn\u2019t make failure handling more \u201cgraceful\u201d, both crash the process. What we want here is either:\r\n- propagate the error to the caller, or\r\n- keep running but add good observability (log + context), or\r\n- if crashing is truly intended, use expect() with a clear, actionable message.\r\n\r\nin this case crashing is not needed and we would prefer loging:\r\n```\r\nif let Err(e) = devtools_chan.send(DevtoolsControlMsg::FromChrome(msg)) {\r\n        log::error!(\"DevTools send failed: {e}\");\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2295516748",
    "pr_number": 38738,
    "pr_file": "components/script/dom/idbtransaction.rs",
    "created_at": "2025-08-23T09:13:11+00:00",
    "commented_code": "fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2295516748",
        "repo_full_name": "servo/servo",
        "pr_number": 38738,
        "pr_file": "components/script/dom/idbtransaction.rs",
        "discussion_id": "2295516748",
        "commented_code": "@@ -204,6 +206,55 @@ impl IDBTransaction {\n     fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();",
        "comment_created_at": "2025-08-23T09:13:11+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Maybe return `None` here instead of crashing immediately on IPC failure?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2295517063",
    "pr_number": 38738,
    "pr_file": "components/script/dom/idbtransaction.rs",
    "created_at": "2025-08-23T09:14:44+00:00",
    "commented_code": "fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();\n+\n+        // First unwrap for ipc\n+        // Second unwrap will never happen unless this db gets manually deleted somehow\n+        let auto_increment = receiver.recv().unwrap().ok()?;\n+\n+        let (sender, receiver) = ipc::channel(self.global().time_profiler_chan().clone()).unwrap();\n+        let operation = SyncOperation::KeyPath(sender, origin, db_name, object_store_name);\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2295517063",
        "repo_full_name": "servo/servo",
        "pr_number": 38738,
        "pr_file": "components/script/dom/idbtransaction.rs",
        "discussion_id": "2295517063",
        "commented_code": "@@ -204,6 +206,55 @@ impl IDBTransaction {\n     fn get_idb_thread(&self) -> IpcSender<IndexedDBThreadMsg> {\n         self.global().resource_threads().sender()\n     }\n+\n+    fn get_object_store_parameters(\n+        &self,\n+        object_store_name: &DOMString,\n+    ) -> Option<IDBObjectStoreParameters> {\n+        let global = self.global();\n+        let idb_sender = global.resource_threads().sender();\n+        let (sender, receiver) = ipc::channel(global.time_profiler_chan().clone()).unwrap();\n+\n+        let origin = global.origin().immutable().clone();\n+        let db_name = self.db.get_name().to_string();\n+        let object_store_name = object_store_name.to_string();\n+\n+        let operation = SyncOperation::HasKeyGenerator(\n+            sender,\n+            origin.clone(),\n+            db_name.clone(),\n+            object_store_name.clone(),\n+        );\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();\n+\n+        // First unwrap for ipc\n+        // Second unwrap will never happen unless this db gets manually deleted somehow\n+        let auto_increment = receiver.recv().unwrap().ok()?;\n+\n+        let (sender, receiver) = ipc::channel(self.global().time_profiler_chan().clone()).unwrap();\n+        let operation = SyncOperation::KeyPath(sender, origin, db_name, object_store_name);\n+\n+        idb_sender\n+            .send(IndexedDBThreadMsg::Sync(operation))\n+            .unwrap();",
        "comment_created_at": "2025-08-23T09:14:44+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please don't crash here on failure.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2310667707",
    "pr_number": 38717,
    "pr_file": "components/webgpu/canvas_context.rs",
    "created_at": "2025-08-29T16:57:39+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+//! Main process implementation of [GPUCanvasContext](https://www.w3.org/TR/webgpu/#canvas-context)\n+\n+use std::collections::HashMap;\n+use std::ptr::NonNull;\n+use std::sync::{Arc, Mutex};\n+\n+use arrayvec::ArrayVec;\n+use base::Epoch;\n+use compositing_traits::{\n+    CrossProcessCompositorApi, ExternalImageSource, SerializableImageData,\n+    WebrenderExternalImageApi,\n+};\n+use euclid::default::Size2D;\n+use ipc_channel::ipc::IpcSender;\n+use log::warn;\n+use pixels::{IpcSnapshot, Snapshot, SnapshotAlphaMode, SnapshotPixelFormat};\n+use serde::{Deserialize, Serialize};\n+use webgpu_traits::{ContextConfiguration, PRESENTATION_BUFFER_COUNT, WebGPUContextId, WebGPUMsg};\n+use webrender_api::units::DeviceIntSize;\n+use webrender_api::{\n+    ExternalImageData, ExternalImageId, ExternalImageType, ImageDescriptor, ImageDescriptorFlags,\n+    ImageFormat, ImageKey,\n+};\n+use wgpu_core::device::HostMap;\n+use wgpu_core::global::Global;\n+use wgpu_core::id::{\n+    self, BufferId, CommandBufferId, CommandEncoderId, DeviceId, QueueId, TextureId,\n+};\n+use wgpu_core::resource::{\n+    BufferAccessError, BufferDescriptor, BufferMapOperation, CreateBufferError,\n+};\n+use wgpu_types::COPY_BYTES_PER_ROW_ALIGNMENT;\n+\n+use crate::wgt;\n+\n+pub type WGPUImageMap = Arc<Mutex<HashMap<WebGPUContextId, ContextData>>>;\n+\n+fn stride(size: Size2D<u32>, format: ImageFormat) -> u32 {\n+    (size.width * format.bytes_per_pixel() as u32).next_multiple_of(COPY_BYTES_PER_ROW_ALIGNMENT)\n+}\n+\n+fn buffer_size(size: Size2D<u32>, format: ImageFormat) -> u64 {\n+    stride(size, format) as u64 * size.height as u64\n+}\n+\n+fn image_desc(config: &ContextConfiguration) -> ImageDescriptor {\n+    ImageDescriptor {\n+        format: config.format,\n+        size: config.size.cast().cast_unit(),\n+        stride: Some(stride(config.size, config.format) as i32),\n+        offset: 0,\n+        flags: if config.is_opaque {\n+            ImageDescriptorFlags::IS_OPAQUE\n+        } else {\n+            ImageDescriptorFlags::empty()\n+        },\n+    }\n+}\n+\n+const fn image_data(context_id: WebGPUContextId) -> ExternalImageData {\n+    ExternalImageData {\n+        id: ExternalImageId(context_id.0),\n+        channel_index: 0,\n+        image_type: ExternalImageType::Buffer,\n+        normalized_uvs: false,\n+    }\n+}\n+\n+fn err<T: std::error::Error + 'static>(e: Option<T>) -> Result<(), T> {\n+    if let Some(error) = e {\n+        Err(error)\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+/// Allocated buffer on GPU device\n+#[derive(Clone, Copy, Debug)]\n+struct Buffer {\n+    device_id: DeviceId,\n+    queue_id: QueueId,\n+    size: u64,\n+}\n+\n+impl Buffer {\n+    /// Returns true if buffer is compatible with provided configuration\n+    fn has_config(&self, config: &ContextConfiguration) -> bool {\n+        config.device_id == self.device_id && self.size == buffer_size(config.size, config.format)\n+    }\n+}\n+\n+/// Mapped GPUBuffer\n+#[derive(Debug)]\n+struct MappedBuffer {\n+    buffer: Buffer,\n+    data: NonNull<u8>,\n+    len: u64,\n+    image_size: Size2D<u32>,\n+    image_format: ImageFormat,\n+    is_opaque: bool,\n+}\n+\n+// Mapped buffer ptr can be shared between threads (it's read-only)\n+unsafe impl Send for MappedBuffer {}\n+\n+impl MappedBuffer {\n+    const fn slice(&'_ self) -> &'_ [u8] {\n+        // Safety: Pointer is from wgpu, and we only use it here\n+        unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len as usize) }\n+    }\n+}\n+\n+/// State of staging buffer\n+#[derive(Debug)]\n+enum StagingBufferState {\n+    /// Initial state, buffer has yet to be created,\n+    /// only it's id is reserved\n+    Unassigned,\n+    /// Buffer is allocated on GPUDevice and ready to be used immediately\n+    Available(Buffer),\n+    /// Buffer is running mapAsync\n+    Mapping(Buffer),\n+    /// Buffer is currently actively mapped\n+    Mapped(MappedBuffer),\n+}\n+\n+/// Staging buffer used for\n+/// Texture to Buffer to CPU copying\n+#[derive(Debug)]\n+struct StagingBuffer {\n+    global: Arc<Global>,\n+    buffer_id: BufferId,\n+    state: StagingBufferState,\n+}\n+\n+impl StagingBuffer {\n+    fn new(global: Arc<Global>, buffer_id: BufferId) -> Self {\n+        Self {\n+            global,\n+            buffer_id,\n+            state: StagingBufferState::Unassigned,\n+        }\n+    }\n+\n+    const fn is_mapped(&self) -> bool {\n+        matches!(self.state, StagingBufferState::Mapped(..))\n+    }\n+\n+    /// Return true if buffer can be used directly with provided config\n+    /// without any additional work\n+    fn is_available_with_config(&self, config: &ContextConfiguration) -> bool {\n+        let StagingBufferState::Available(buffer) = &self.state else {\n+            return false;\n+        };\n+        buffer.has_config(config)\n+    }\n+\n+    /// Return true if buffer is not mapping or being mapped\n+    const fn needs_assign(&self) -> bool {\n+        matches!(\n+            self.state,\n+            StagingBufferState::Unassigned | StagingBufferState::Available(_)\n+        )\n+    }\n+\n+    /// Make buffer available by unmap/destroy and recreating it if needed\n+    fn ensure_available(&mut self, config: &ContextConfiguration) -> Result<(), CreateBufferError> {\n+        let recreate = match &self.state {\n+            StagingBufferState::Unassigned => true,\n+            StagingBufferState::Available(buffer) |\n+            StagingBufferState::Mapping(buffer) |\n+            StagingBufferState::Mapped(MappedBuffer { buffer, .. }) => {\n+                if buffer.has_config(config) {\n+                    let _ = self.global.buffer_unmap(self.buffer_id);\n+                    false\n+                } else {\n+                    self.global.buffer_drop(self.buffer_id);\n+                    true\n+                }\n+            },\n+        };\n+        if recreate {\n+            let buffer_size = buffer_size(config.size, config.format);\n+            let (_, error) = self.global.device_create_buffer(\n+                config.device_id,\n+                &BufferDescriptor {\n+                    label: None,\n+                    size: buffer_size,\n+                    usage: wgt::BufferUsages::MAP_READ | wgt::BufferUsages::COPY_DST,\n+                    mapped_at_creation: false,\n+                },\n+                Some(self.buffer_id),\n+            );\n+            err(error)?;\n+            self.state = StagingBufferState::Available(Buffer {\n+                device_id: config.device_id,\n+                queue_id: config.queue_id,\n+                size: buffer_size,\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    /// Makes buffer available and prepares command encoder\n+    /// that will copy texture to this staging buffer.\n+    ///\n+    /// Caller must submit command buffer to queue.\n+    fn prepare_load_texture_command_buffer(\n+        &mut self,\n+        texture_id: TextureId,\n+        encoder_id: CommandEncoderId,\n+        config: &ContextConfiguration,\n+    ) -> Result<CommandBufferId, Box<dyn std::error::Error>> {\n+        self.ensure_available(config)?;\n+        let StagingBufferState::Available(buffer) = &self.state else {\n+            unreachable!()\n+        };\n+        let device_id = buffer.device_id;\n+        let comm_desc = wgt::CommandEncoderDescriptor { label: None };\n+        let (encoder_id, error) =\n+            self.global\n+                .device_create_command_encoder(device_id, &comm_desc, Some(encoder_id));\n+        err(error)?;\n+        let buffer_cv = wgt::TexelCopyBufferInfo {\n+            buffer: self.buffer_id,\n+            layout: wgt::TexelCopyBufferLayout {\n+                offset: 0,\n+                bytes_per_row: Some(stride(config.size, config.format)),\n+                rows_per_image: None,\n+            },\n+        };\n+        let texture_cv = wgt::TexelCopyTextureInfo {\n+            texture: texture_id,\n+            mip_level: 0,\n+            origin: wgt::Origin3d::ZERO,\n+            aspect: wgt::TextureAspect::All,\n+        };\n+        let copy_size = wgt::Extent3d {\n+            width: config.size.width,\n+            height: config.size.height,\n+            depth_or_array_layers: 1,\n+        };\n+        self.global.command_encoder_copy_texture_to_buffer(\n+            encoder_id,\n+            &texture_cv,\n+            &buffer_cv,\n+            &copy_size,\n+        )?;\n+        let (command_buffer_id, error) = self\n+            .global\n+            .command_encoder_finish(encoder_id, &wgt::CommandBufferDescriptor::default());\n+        err(error)?;\n+        Ok(command_buffer_id)\n+    }\n+\n+    /// Unmaps buffer or cancel mapping if in progress\n+    fn unmap(&mut self) {\n+        match self.state {\n+            StagingBufferState::Unassigned | StagingBufferState::Available(_) => {},\n+            StagingBufferState::Mapping(buffer) |\n+            StagingBufferState::Mapped(MappedBuffer { buffer, .. }) => {\n+                let _ = self.global.buffer_unmap(self.buffer_id);\n+                self.state = StagingBufferState::Available(buffer)\n+            },\n+        }\n+    }\n+\n+    /// Obtains snapshot from mapped buffer\n+    fn snapshot(&self) -> Option<Snapshot> {\n+        if let StagingBufferState::Mapped(mapped) = &self.state {\n+            let format = match mapped.image_format {\n+                ImageFormat::RGBA8 => SnapshotPixelFormat::RGBA,\n+                ImageFormat::BGRA8 => SnapshotPixelFormat::BGRA,\n+                _ => unimplemented!(),\n+            };\n+            let alpha_mode = if mapped.is_opaque {\n+                SnapshotAlphaMode::AsOpaque {\n+                    premultiplied: false,\n+                }\n+            } else {\n+                SnapshotAlphaMode::Transparent {\n+                    premultiplied: true,\n+                }\n+            };\n+            let padded_byte_width = stride(mapped.image_size, mapped.image_format);\n+            let data = mapped.slice();\n+            let bytes_per_pixel = mapped.image_format.bytes_per_pixel() as usize;\n+            let mut result_unpadded =\n+                Vec::<u8>::with_capacity(mapped.image_size.area() as usize * bytes_per_pixel);\n+            for row in 0..mapped.image_size.height {\n+                let start = (row * padded_byte_width).try_into().unwrap();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2310667707",
        "repo_full_name": "servo/servo",
        "pr_number": 38717,
        "pr_file": "components/webgpu/canvas_context.rs",
        "discussion_id": "2310667707",
        "commented_code": "@@ -0,0 +1,747 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+//! Main process implementation of [GPUCanvasContext](https://www.w3.org/TR/webgpu/#canvas-context)\n+\n+use std::collections::HashMap;\n+use std::ptr::NonNull;\n+use std::sync::{Arc, Mutex};\n+\n+use arrayvec::ArrayVec;\n+use base::Epoch;\n+use compositing_traits::{\n+    CrossProcessCompositorApi, ExternalImageSource, SerializableImageData,\n+    WebrenderExternalImageApi,\n+};\n+use euclid::default::Size2D;\n+use ipc_channel::ipc::IpcSender;\n+use log::warn;\n+use pixels::{IpcSnapshot, Snapshot, SnapshotAlphaMode, SnapshotPixelFormat};\n+use serde::{Deserialize, Serialize};\n+use webgpu_traits::{ContextConfiguration, PRESENTATION_BUFFER_COUNT, WebGPUContextId, WebGPUMsg};\n+use webrender_api::units::DeviceIntSize;\n+use webrender_api::{\n+    ExternalImageData, ExternalImageId, ExternalImageType, ImageDescriptor, ImageDescriptorFlags,\n+    ImageFormat, ImageKey,\n+};\n+use wgpu_core::device::HostMap;\n+use wgpu_core::global::Global;\n+use wgpu_core::id::{\n+    self, BufferId, CommandBufferId, CommandEncoderId, DeviceId, QueueId, TextureId,\n+};\n+use wgpu_core::resource::{\n+    BufferAccessError, BufferDescriptor, BufferMapOperation, CreateBufferError,\n+};\n+use wgpu_types::COPY_BYTES_PER_ROW_ALIGNMENT;\n+\n+use crate::wgt;\n+\n+pub type WGPUImageMap = Arc<Mutex<HashMap<WebGPUContextId, ContextData>>>;\n+\n+fn stride(size: Size2D<u32>, format: ImageFormat) -> u32 {\n+    (size.width * format.bytes_per_pixel() as u32).next_multiple_of(COPY_BYTES_PER_ROW_ALIGNMENT)\n+}\n+\n+fn buffer_size(size: Size2D<u32>, format: ImageFormat) -> u64 {\n+    stride(size, format) as u64 * size.height as u64\n+}\n+\n+fn image_desc(config: &ContextConfiguration) -> ImageDescriptor {\n+    ImageDescriptor {\n+        format: config.format,\n+        size: config.size.cast().cast_unit(),\n+        stride: Some(stride(config.size, config.format) as i32),\n+        offset: 0,\n+        flags: if config.is_opaque {\n+            ImageDescriptorFlags::IS_OPAQUE\n+        } else {\n+            ImageDescriptorFlags::empty()\n+        },\n+    }\n+}\n+\n+const fn image_data(context_id: WebGPUContextId) -> ExternalImageData {\n+    ExternalImageData {\n+        id: ExternalImageId(context_id.0),\n+        channel_index: 0,\n+        image_type: ExternalImageType::Buffer,\n+        normalized_uvs: false,\n+    }\n+}\n+\n+fn err<T: std::error::Error + 'static>(e: Option<T>) -> Result<(), T> {\n+    if let Some(error) = e {\n+        Err(error)\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+/// Allocated buffer on GPU device\n+#[derive(Clone, Copy, Debug)]\n+struct Buffer {\n+    device_id: DeviceId,\n+    queue_id: QueueId,\n+    size: u64,\n+}\n+\n+impl Buffer {\n+    /// Returns true if buffer is compatible with provided configuration\n+    fn has_config(&self, config: &ContextConfiguration) -> bool {\n+        config.device_id == self.device_id && self.size == buffer_size(config.size, config.format)\n+    }\n+}\n+\n+/// Mapped GPUBuffer\n+#[derive(Debug)]\n+struct MappedBuffer {\n+    buffer: Buffer,\n+    data: NonNull<u8>,\n+    len: u64,\n+    image_size: Size2D<u32>,\n+    image_format: ImageFormat,\n+    is_opaque: bool,\n+}\n+\n+// Mapped buffer ptr can be shared between threads (it's read-only)\n+unsafe impl Send for MappedBuffer {}\n+\n+impl MappedBuffer {\n+    const fn slice(&'_ self) -> &'_ [u8] {\n+        // Safety: Pointer is from wgpu, and we only use it here\n+        unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len as usize) }\n+    }\n+}\n+\n+/// State of staging buffer\n+#[derive(Debug)]\n+enum StagingBufferState {\n+    /// Initial state, buffer has yet to be created,\n+    /// only it's id is reserved\n+    Unassigned,\n+    /// Buffer is allocated on GPUDevice and ready to be used immediately\n+    Available(Buffer),\n+    /// Buffer is running mapAsync\n+    Mapping(Buffer),\n+    /// Buffer is currently actively mapped\n+    Mapped(MappedBuffer),\n+}\n+\n+/// Staging buffer used for\n+/// Texture to Buffer to CPU copying\n+#[derive(Debug)]\n+struct StagingBuffer {\n+    global: Arc<Global>,\n+    buffer_id: BufferId,\n+    state: StagingBufferState,\n+}\n+\n+impl StagingBuffer {\n+    fn new(global: Arc<Global>, buffer_id: BufferId) -> Self {\n+        Self {\n+            global,\n+            buffer_id,\n+            state: StagingBufferState::Unassigned,\n+        }\n+    }\n+\n+    const fn is_mapped(&self) -> bool {\n+        matches!(self.state, StagingBufferState::Mapped(..))\n+    }\n+\n+    /// Return true if buffer can be used directly with provided config\n+    /// without any additional work\n+    fn is_available_with_config(&self, config: &ContextConfiguration) -> bool {\n+        let StagingBufferState::Available(buffer) = &self.state else {\n+            return false;\n+        };\n+        buffer.has_config(config)\n+    }\n+\n+    /// Return true if buffer is not mapping or being mapped\n+    const fn needs_assign(&self) -> bool {\n+        matches!(\n+            self.state,\n+            StagingBufferState::Unassigned | StagingBufferState::Available(_)\n+        )\n+    }\n+\n+    /// Make buffer available by unmap/destroy and recreating it if needed\n+    fn ensure_available(&mut self, config: &ContextConfiguration) -> Result<(), CreateBufferError> {\n+        let recreate = match &self.state {\n+            StagingBufferState::Unassigned => true,\n+            StagingBufferState::Available(buffer) |\n+            StagingBufferState::Mapping(buffer) |\n+            StagingBufferState::Mapped(MappedBuffer { buffer, .. }) => {\n+                if buffer.has_config(config) {\n+                    let _ = self.global.buffer_unmap(self.buffer_id);\n+                    false\n+                } else {\n+                    self.global.buffer_drop(self.buffer_id);\n+                    true\n+                }\n+            },\n+        };\n+        if recreate {\n+            let buffer_size = buffer_size(config.size, config.format);\n+            let (_, error) = self.global.device_create_buffer(\n+                config.device_id,\n+                &BufferDescriptor {\n+                    label: None,\n+                    size: buffer_size,\n+                    usage: wgt::BufferUsages::MAP_READ | wgt::BufferUsages::COPY_DST,\n+                    mapped_at_creation: false,\n+                },\n+                Some(self.buffer_id),\n+            );\n+            err(error)?;\n+            self.state = StagingBufferState::Available(Buffer {\n+                device_id: config.device_id,\n+                queue_id: config.queue_id,\n+                size: buffer_size,\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    /// Makes buffer available and prepares command encoder\n+    /// that will copy texture to this staging buffer.\n+    ///\n+    /// Caller must submit command buffer to queue.\n+    fn prepare_load_texture_command_buffer(\n+        &mut self,\n+        texture_id: TextureId,\n+        encoder_id: CommandEncoderId,\n+        config: &ContextConfiguration,\n+    ) -> Result<CommandBufferId, Box<dyn std::error::Error>> {\n+        self.ensure_available(config)?;\n+        let StagingBufferState::Available(buffer) = &self.state else {\n+            unreachable!()\n+        };\n+        let device_id = buffer.device_id;\n+        let comm_desc = wgt::CommandEncoderDescriptor { label: None };\n+        let (encoder_id, error) =\n+            self.global\n+                .device_create_command_encoder(device_id, &comm_desc, Some(encoder_id));\n+        err(error)?;\n+        let buffer_cv = wgt::TexelCopyBufferInfo {\n+            buffer: self.buffer_id,\n+            layout: wgt::TexelCopyBufferLayout {\n+                offset: 0,\n+                bytes_per_row: Some(stride(config.size, config.format)),\n+                rows_per_image: None,\n+            },\n+        };\n+        let texture_cv = wgt::TexelCopyTextureInfo {\n+            texture: texture_id,\n+            mip_level: 0,\n+            origin: wgt::Origin3d::ZERO,\n+            aspect: wgt::TextureAspect::All,\n+        };\n+        let copy_size = wgt::Extent3d {\n+            width: config.size.width,\n+            height: config.size.height,\n+            depth_or_array_layers: 1,\n+        };\n+        self.global.command_encoder_copy_texture_to_buffer(\n+            encoder_id,\n+            &texture_cv,\n+            &buffer_cv,\n+            &copy_size,\n+        )?;\n+        let (command_buffer_id, error) = self\n+            .global\n+            .command_encoder_finish(encoder_id, &wgt::CommandBufferDescriptor::default());\n+        err(error)?;\n+        Ok(command_buffer_id)\n+    }\n+\n+    /// Unmaps buffer or cancel mapping if in progress\n+    fn unmap(&mut self) {\n+        match self.state {\n+            StagingBufferState::Unassigned | StagingBufferState::Available(_) => {},\n+            StagingBufferState::Mapping(buffer) |\n+            StagingBufferState::Mapped(MappedBuffer { buffer, .. }) => {\n+                let _ = self.global.buffer_unmap(self.buffer_id);\n+                self.state = StagingBufferState::Available(buffer)\n+            },\n+        }\n+    }\n+\n+    /// Obtains snapshot from mapped buffer\n+    fn snapshot(&self) -> Option<Snapshot> {\n+        if let StagingBufferState::Mapped(mapped) = &self.state {\n+            let format = match mapped.image_format {\n+                ImageFormat::RGBA8 => SnapshotPixelFormat::RGBA,\n+                ImageFormat::BGRA8 => SnapshotPixelFormat::BGRA,\n+                _ => unimplemented!(),\n+            };\n+            let alpha_mode = if mapped.is_opaque {\n+                SnapshotAlphaMode::AsOpaque {\n+                    premultiplied: false,\n+                }\n+            } else {\n+                SnapshotAlphaMode::Transparent {\n+                    premultiplied: true,\n+                }\n+            };\n+            let padded_byte_width = stride(mapped.image_size, mapped.image_format);\n+            let data = mapped.slice();\n+            let bytes_per_pixel = mapped.image_format.bytes_per_pixel() as usize;\n+            let mut result_unpadded =\n+                Vec::<u8>::with_capacity(mapped.image_size.area() as usize * bytes_per_pixel);\n+            for row in 0..mapped.image_size.height {\n+                let start = (row * padded_byte_width).try_into().unwrap();",
        "comment_created_at": "2025-08-29T16:57:39+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please don't use a raw unwrap here, especially as this is running in the content process. Instead, either abort the operation with an error or produce a reasonable default value.",
        "pr_file_module": null
      }
    ]
  }
]