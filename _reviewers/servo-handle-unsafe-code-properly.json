[
  {
    "discussion_id": "2387508408",
    "pr_number": 39509,
    "pr_file": "components/script_bindings/domstring.rs",
    "created_at": "2025-09-29T10:49:41+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::borrow::{Cow, ToOwned};\n+use std::default::Default;\n+use std::ops::Deref;\n+use std::str::{CharIndices, EncodeUtf16, FromStr};\n+use std::sync::LazyLock;\n+use std::{fmt, str};\n+\n+use ascii::ToAsciiChar;\n+use html5ever::{LocalName, Namespace};\n+use js::conversions::ToJSValConvertible;\n+use js::gc::MutableHandleValue;\n+use js::jsapi::JSContext;\n+use num_traits::Zero;\n+use regex::Regex;\n+use style::Atom;\n+use style::str::HTML_SPACE_CHARACTERS;\n+\n+use crate::domstring::domstring_inner::DOMStringInner;\n+\n+#[allow(unused)]\n+fn char_to_latin1_u8(c: char) -> u8 {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[allow(unused)]\n+fn latin1_u8_to_char(c: u8) -> char {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EncodedBytes<'a> {\n+    Latin1Bytes(&'a [u8]),\n+    Utf8Bytes(&'a str),\n+}\n+\n+impl<'a> PartialEq<str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => *s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                v == *s\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for Box<EncodedBytes<'a>> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self.deref() {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+/// We encapsulate the `dangerous methods` in the inner mod. You should use\n+/// bytes set_rust_string or get_rust_string.\n+mod domstring_inner {\n+    use std::cell::OnceCell;\n+    use std::ptr::NonNull;\n+    use std::{fmt, ptr, slice};\n+\n+    use js::conversions::jsstr_to_string;\n+    use js::jsapi::{Heap, JS_GetLatin1StringCharsAndLength, JSContext, JSString};\n+    use js::rust::Trace;\n+    use malloc_size_of::MallocSizeOfOps;\n+\n+    use super::EncodedBytes;\n+    use crate::trace::RootedTraceableBox;\n+\n+    pub(super) struct DOMStringInner {\n+        rust_string: OnceCell<String>,\n+        js_context: Option<*mut JSContext>,\n+        js_string: Option<RootedTraceableBox<Heap<*mut JSString>>>,\n+    }\n+\n+    /// Safety comment: ??\n+    ///\n+    /// This method will _not_ trace the pointer if the rust string exists.\n+    /// The js string could be garbage collected and, hence, violating this\n+    /// could lead to undefined behavior\n+    unsafe impl Trace for DOMStringInner {\n+        unsafe fn trace(&self, tracer: *mut js::jsapi::JSTracer) {\n+            if self.rust_string.get().is_none() {\n+                if let Some(ref s) = self.js_string {\n+                    unsafe {\n+                        s.trace(tracer);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl malloc_size_of::MallocSizeOf for DOMStringInner {\n+        fn size_of(&self, ops: &mut MallocSizeOfOps) -> usize {\n+            if let Some(s) = self.rust_string.get() {\n+                s.size_of(ops)\n+            } else {\n+                // Managed by JS Engine\n+                0\n+            }\n+        }\n+    }\n+\n+    impl std::fmt::Debug for DOMStringInner {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"LazyDOMString\")\n+                .field(\"rust_string\", &self.rust_string)\n+                .finish()\n+        }\n+    }\n+\n+    impl Clone for DOMStringInner {\n+        fn clone(&self) -> Self {\n+            self.make_me_string();\n+            Self {\n+                rust_string: self.rust_string.clone(),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+    }\n+\n+    impl DOMStringInner {\n+        pub(super) fn new() -> DOMStringInner {\n+            DOMStringInner {\n+                rust_string: OnceCell::from(String::new()),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+\n+        /// This method will do some work if necessary but not an allocation.\n+        /// It returns the bytes either in Utf8 or Latin1 encoded, depending on the\n+        /// raw mozjs string.\n+        #[allow(unused)]\n+        pub(super) fn bytes<'a>(&'a self) -> EncodedBytes<'a> {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2387508408",
        "repo_full_name": "servo/servo",
        "pr_number": 39509,
        "pr_file": "components/script_bindings/domstring.rs",
        "discussion_id": "2387508408",
        "commented_code": "@@ -0,0 +1,628 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::borrow::{Cow, ToOwned};\n+use std::default::Default;\n+use std::ops::Deref;\n+use std::str::{CharIndices, EncodeUtf16, FromStr};\n+use std::sync::LazyLock;\n+use std::{fmt, str};\n+\n+use ascii::ToAsciiChar;\n+use html5ever::{LocalName, Namespace};\n+use js::conversions::ToJSValConvertible;\n+use js::gc::MutableHandleValue;\n+use js::jsapi::JSContext;\n+use num_traits::Zero;\n+use regex::Regex;\n+use style::Atom;\n+use style::str::HTML_SPACE_CHARACTERS;\n+\n+use crate::domstring::domstring_inner::DOMStringInner;\n+\n+#[allow(unused)]\n+fn char_to_latin1_u8(c: char) -> u8 {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[allow(unused)]\n+fn latin1_u8_to_char(c: u8) -> char {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EncodedBytes<'a> {\n+    Latin1Bytes(&'a [u8]),\n+    Utf8Bytes(&'a str),\n+}\n+\n+impl<'a> PartialEq<str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => *s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                v == *s\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for Box<EncodedBytes<'a>> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self.deref() {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+/// We encapsulate the `dangerous methods` in the inner mod. You should use\n+/// bytes set_rust_string or get_rust_string.\n+mod domstring_inner {\n+    use std::cell::OnceCell;\n+    use std::ptr::NonNull;\n+    use std::{fmt, ptr, slice};\n+\n+    use js::conversions::jsstr_to_string;\n+    use js::jsapi::{Heap, JS_GetLatin1StringCharsAndLength, JSContext, JSString};\n+    use js::rust::Trace;\n+    use malloc_size_of::MallocSizeOfOps;\n+\n+    use super::EncodedBytes;\n+    use crate::trace::RootedTraceableBox;\n+\n+    pub(super) struct DOMStringInner {\n+        rust_string: OnceCell<String>,\n+        js_context: Option<*mut JSContext>,\n+        js_string: Option<RootedTraceableBox<Heap<*mut JSString>>>,\n+    }\n+\n+    /// Safety comment: ??\n+    ///\n+    /// This method will _not_ trace the pointer if the rust string exists.\n+    /// The js string could be garbage collected and, hence, violating this\n+    /// could lead to undefined behavior\n+    unsafe impl Trace for DOMStringInner {\n+        unsafe fn trace(&self, tracer: *mut js::jsapi::JSTracer) {\n+            if self.rust_string.get().is_none() {\n+                if let Some(ref s) = self.js_string {\n+                    unsafe {\n+                        s.trace(tracer);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl malloc_size_of::MallocSizeOf for DOMStringInner {\n+        fn size_of(&self, ops: &mut MallocSizeOfOps) -> usize {\n+            if let Some(s) = self.rust_string.get() {\n+                s.size_of(ops)\n+            } else {\n+                // Managed by JS Engine\n+                0\n+            }\n+        }\n+    }\n+\n+    impl std::fmt::Debug for DOMStringInner {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"LazyDOMString\")\n+                .field(\"rust_string\", &self.rust_string)\n+                .finish()\n+        }\n+    }\n+\n+    impl Clone for DOMStringInner {\n+        fn clone(&self) -> Self {\n+            self.make_me_string();\n+            Self {\n+                rust_string: self.rust_string.clone(),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+    }\n+\n+    impl DOMStringInner {\n+        pub(super) fn new() -> DOMStringInner {\n+            DOMStringInner {\n+                rust_string: OnceCell::from(String::new()),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+\n+        /// This method will do some work if necessary but not an allocation.\n+        /// It returns the bytes either in Utf8 or Latin1 encoded, depending on the\n+        /// raw mozjs string.\n+        #[allow(unused)]\n+        pub(super) fn bytes<'a>(&'a self) -> EncodedBytes<'a> {",
        "comment_created_at": "2025-09-29T10:49:41+00:00",
        "comment_author": "jdm",
        "comment_body": "This method needs to be marked unsafe. While the string can't be garbage collected while we're borrowing the characters, it could still be mutated in a way that could invalidate the underlying buffer.",
        "pr_file_module": null
      },
      {
        "comment_id": "2387886373",
        "repo_full_name": "servo/servo",
        "pr_number": 39509,
        "pr_file": "components/script_bindings/domstring.rs",
        "discussion_id": "2387508408",
        "commented_code": "@@ -0,0 +1,628 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::borrow::{Cow, ToOwned};\n+use std::default::Default;\n+use std::ops::Deref;\n+use std::str::{CharIndices, EncodeUtf16, FromStr};\n+use std::sync::LazyLock;\n+use std::{fmt, str};\n+\n+use ascii::ToAsciiChar;\n+use html5ever::{LocalName, Namespace};\n+use js::conversions::ToJSValConvertible;\n+use js::gc::MutableHandleValue;\n+use js::jsapi::JSContext;\n+use num_traits::Zero;\n+use regex::Regex;\n+use style::Atom;\n+use style::str::HTML_SPACE_CHARACTERS;\n+\n+use crate::domstring::domstring_inner::DOMStringInner;\n+\n+#[allow(unused)]\n+fn char_to_latin1_u8(c: char) -> u8 {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[allow(unused)]\n+fn latin1_u8_to_char(c: u8) -> char {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EncodedBytes<'a> {\n+    Latin1Bytes(&'a [u8]),\n+    Utf8Bytes(&'a str),\n+}\n+\n+impl<'a> PartialEq<str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => *s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                v == *s\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for Box<EncodedBytes<'a>> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self.deref() {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+/// We encapsulate the `dangerous methods` in the inner mod. You should use\n+/// bytes set_rust_string or get_rust_string.\n+mod domstring_inner {\n+    use std::cell::OnceCell;\n+    use std::ptr::NonNull;\n+    use std::{fmt, ptr, slice};\n+\n+    use js::conversions::jsstr_to_string;\n+    use js::jsapi::{Heap, JS_GetLatin1StringCharsAndLength, JSContext, JSString};\n+    use js::rust::Trace;\n+    use malloc_size_of::MallocSizeOfOps;\n+\n+    use super::EncodedBytes;\n+    use crate::trace::RootedTraceableBox;\n+\n+    pub(super) struct DOMStringInner {\n+        rust_string: OnceCell<String>,\n+        js_context: Option<*mut JSContext>,\n+        js_string: Option<RootedTraceableBox<Heap<*mut JSString>>>,\n+    }\n+\n+    /// Safety comment: ??\n+    ///\n+    /// This method will _not_ trace the pointer if the rust string exists.\n+    /// The js string could be garbage collected and, hence, violating this\n+    /// could lead to undefined behavior\n+    unsafe impl Trace for DOMStringInner {\n+        unsafe fn trace(&self, tracer: *mut js::jsapi::JSTracer) {\n+            if self.rust_string.get().is_none() {\n+                if let Some(ref s) = self.js_string {\n+                    unsafe {\n+                        s.trace(tracer);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl malloc_size_of::MallocSizeOf for DOMStringInner {\n+        fn size_of(&self, ops: &mut MallocSizeOfOps) -> usize {\n+            if let Some(s) = self.rust_string.get() {\n+                s.size_of(ops)\n+            } else {\n+                // Managed by JS Engine\n+                0\n+            }\n+        }\n+    }\n+\n+    impl std::fmt::Debug for DOMStringInner {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"LazyDOMString\")\n+                .field(\"rust_string\", &self.rust_string)\n+                .finish()\n+        }\n+    }\n+\n+    impl Clone for DOMStringInner {\n+        fn clone(&self) -> Self {\n+            self.make_me_string();\n+            Self {\n+                rust_string: self.rust_string.clone(),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+    }\n+\n+    impl DOMStringInner {\n+        pub(super) fn new() -> DOMStringInner {\n+            DOMStringInner {\n+                rust_string: OnceCell::from(String::new()),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+\n+        /// This method will do some work if necessary but not an allocation.\n+        /// It returns the bytes either in Utf8 or Latin1 encoded, depending on the\n+        /// raw mozjs string.\n+        #[allow(unused)]\n+        pub(super) fn bytes<'a>(&'a self) -> EncodedBytes<'a> {",
        "comment_created_at": "2025-09-29T13:04:17+00:00",
        "comment_author": "Narfinger",
        "comment_body": "I don't quite understand why this should be unsafe. Can mozjs just change the layout of the string while it is borrowed? If yes, than I don't know how this can be made safe.",
        "pr_file_module": null
      },
      {
        "comment_id": "2387934337",
        "repo_full_name": "servo/servo",
        "pr_number": 39509,
        "pr_file": "components/script_bindings/domstring.rs",
        "discussion_id": "2387508408",
        "commented_code": "@@ -0,0 +1,628 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::borrow::{Cow, ToOwned};\n+use std::default::Default;\n+use std::ops::Deref;\n+use std::str::{CharIndices, EncodeUtf16, FromStr};\n+use std::sync::LazyLock;\n+use std::{fmt, str};\n+\n+use ascii::ToAsciiChar;\n+use html5ever::{LocalName, Namespace};\n+use js::conversions::ToJSValConvertible;\n+use js::gc::MutableHandleValue;\n+use js::jsapi::JSContext;\n+use num_traits::Zero;\n+use regex::Regex;\n+use style::Atom;\n+use style::str::HTML_SPACE_CHARACTERS;\n+\n+use crate::domstring::domstring_inner::DOMStringInner;\n+\n+#[allow(unused)]\n+fn char_to_latin1_u8(c: char) -> u8 {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[allow(unused)]\n+fn latin1_u8_to_char(c: u8) -> char {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EncodedBytes<'a> {\n+    Latin1Bytes(&'a [u8]),\n+    Utf8Bytes(&'a str),\n+}\n+\n+impl<'a> PartialEq<str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => *s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                v == *s\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for Box<EncodedBytes<'a>> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self.deref() {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+/// We encapsulate the `dangerous methods` in the inner mod. You should use\n+/// bytes set_rust_string or get_rust_string.\n+mod domstring_inner {\n+    use std::cell::OnceCell;\n+    use std::ptr::NonNull;\n+    use std::{fmt, ptr, slice};\n+\n+    use js::conversions::jsstr_to_string;\n+    use js::jsapi::{Heap, JS_GetLatin1StringCharsAndLength, JSContext, JSString};\n+    use js::rust::Trace;\n+    use malloc_size_of::MallocSizeOfOps;\n+\n+    use super::EncodedBytes;\n+    use crate::trace::RootedTraceableBox;\n+\n+    pub(super) struct DOMStringInner {\n+        rust_string: OnceCell<String>,\n+        js_context: Option<*mut JSContext>,\n+        js_string: Option<RootedTraceableBox<Heap<*mut JSString>>>,\n+    }\n+\n+    /// Safety comment: ??\n+    ///\n+    /// This method will _not_ trace the pointer if the rust string exists.\n+    /// The js string could be garbage collected and, hence, violating this\n+    /// could lead to undefined behavior\n+    unsafe impl Trace for DOMStringInner {\n+        unsafe fn trace(&self, tracer: *mut js::jsapi::JSTracer) {\n+            if self.rust_string.get().is_none() {\n+                if let Some(ref s) = self.js_string {\n+                    unsafe {\n+                        s.trace(tracer);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl malloc_size_of::MallocSizeOf for DOMStringInner {\n+        fn size_of(&self, ops: &mut MallocSizeOfOps) -> usize {\n+            if let Some(s) = self.rust_string.get() {\n+                s.size_of(ops)\n+            } else {\n+                // Managed by JS Engine\n+                0\n+            }\n+        }\n+    }\n+\n+    impl std::fmt::Debug for DOMStringInner {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"LazyDOMString\")\n+                .field(\"rust_string\", &self.rust_string)\n+                .finish()\n+        }\n+    }\n+\n+    impl Clone for DOMStringInner {\n+        fn clone(&self) -> Self {\n+            self.make_me_string();\n+            Self {\n+                rust_string: self.rust_string.clone(),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+    }\n+\n+    impl DOMStringInner {\n+        pub(super) fn new() -> DOMStringInner {\n+            DOMStringInner {\n+                rust_string: OnceCell::from(String::new()),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+\n+        /// This method will do some work if necessary but not an allocation.\n+        /// It returns the bytes either in Utf8 or Latin1 encoded, depending on the\n+        /// raw mozjs string.\n+        #[allow(unused)]\n+        pub(super) fn bytes<'a>(&'a self) -> EncodedBytes<'a> {",
        "comment_created_at": "2025-09-29T13:20:44+00:00",
        "comment_author": "jdm",
        "comment_body": "If the code calls bytes() and stores the result on the stack, then uses the SpiderMonkey API to change the change object (eg. append to it), that API could allocate a new buffer and free the old one. The slice on the stack would now be pointing at freed memory.",
        "pr_file_module": null
      },
      {
        "comment_id": "2387938082",
        "repo_full_name": "servo/servo",
        "pr_number": 39509,
        "pr_file": "components/script_bindings/domstring.rs",
        "discussion_id": "2387508408",
        "commented_code": "@@ -0,0 +1,628 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::borrow::{Cow, ToOwned};\n+use std::default::Default;\n+use std::ops::Deref;\n+use std::str::{CharIndices, EncodeUtf16, FromStr};\n+use std::sync::LazyLock;\n+use std::{fmt, str};\n+\n+use ascii::ToAsciiChar;\n+use html5ever::{LocalName, Namespace};\n+use js::conversions::ToJSValConvertible;\n+use js::gc::MutableHandleValue;\n+use js::jsapi::JSContext;\n+use num_traits::Zero;\n+use regex::Regex;\n+use style::Atom;\n+use style::str::HTML_SPACE_CHARACTERS;\n+\n+use crate::domstring::domstring_inner::DOMStringInner;\n+\n+#[allow(unused)]\n+fn char_to_latin1_u8(c: char) -> u8 {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[allow(unused)]\n+fn latin1_u8_to_char(c: u8) -> char {\n+    c.to_ascii_char().unwrap().into()\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EncodedBytes<'a> {\n+    Latin1Bytes(&'a [u8]),\n+    Utf8Bytes(&'a str),\n+}\n+\n+impl<'a> PartialEq<str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => *s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                v == *s\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for EncodedBytes<'a> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> PartialEq<&str> for Box<EncodedBytes<'a>> {\n+    fn eq(&self, other: &&str) -> bool {\n+        match self.deref() {\n+            EncodedBytes::Utf8Bytes(s) => s == other,\n+            EncodedBytes::Latin1Bytes(s) => {\n+                let v = s.iter().map(|c| *c as char as u8).collect::<Vec<u8>>();\n+                &String::from_utf8(v).unwrap() == other\n+            },\n+        }\n+    }\n+}\n+\n+/// We encapsulate the `dangerous methods` in the inner mod. You should use\n+/// bytes set_rust_string or get_rust_string.\n+mod domstring_inner {\n+    use std::cell::OnceCell;\n+    use std::ptr::NonNull;\n+    use std::{fmt, ptr, slice};\n+\n+    use js::conversions::jsstr_to_string;\n+    use js::jsapi::{Heap, JS_GetLatin1StringCharsAndLength, JSContext, JSString};\n+    use js::rust::Trace;\n+    use malloc_size_of::MallocSizeOfOps;\n+\n+    use super::EncodedBytes;\n+    use crate::trace::RootedTraceableBox;\n+\n+    pub(super) struct DOMStringInner {\n+        rust_string: OnceCell<String>,\n+        js_context: Option<*mut JSContext>,\n+        js_string: Option<RootedTraceableBox<Heap<*mut JSString>>>,\n+    }\n+\n+    /// Safety comment: ??\n+    ///\n+    /// This method will _not_ trace the pointer if the rust string exists.\n+    /// The js string could be garbage collected and, hence, violating this\n+    /// could lead to undefined behavior\n+    unsafe impl Trace for DOMStringInner {\n+        unsafe fn trace(&self, tracer: *mut js::jsapi::JSTracer) {\n+            if self.rust_string.get().is_none() {\n+                if let Some(ref s) = self.js_string {\n+                    unsafe {\n+                        s.trace(tracer);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl malloc_size_of::MallocSizeOf for DOMStringInner {\n+        fn size_of(&self, ops: &mut MallocSizeOfOps) -> usize {\n+            if let Some(s) = self.rust_string.get() {\n+                s.size_of(ops)\n+            } else {\n+                // Managed by JS Engine\n+                0\n+            }\n+        }\n+    }\n+\n+    impl std::fmt::Debug for DOMStringInner {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"LazyDOMString\")\n+                .field(\"rust_string\", &self.rust_string)\n+                .finish()\n+        }\n+    }\n+\n+    impl Clone for DOMStringInner {\n+        fn clone(&self) -> Self {\n+            self.make_me_string();\n+            Self {\n+                rust_string: self.rust_string.clone(),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+    }\n+\n+    impl DOMStringInner {\n+        pub(super) fn new() -> DOMStringInner {\n+            DOMStringInner {\n+                rust_string: OnceCell::from(String::new()),\n+                js_context: None,\n+                js_string: None,\n+            }\n+        }\n+\n+        /// This method will do some work if necessary but not an allocation.\n+        /// It returns the bytes either in Utf8 or Latin1 encoded, depending on the\n+        /// raw mozjs string.\n+        #[allow(unused)]\n+        pub(super) fn bytes<'a>(&'a self) -> EncodedBytes<'a> {",
        "comment_created_at": "2025-09-29T13:21:56+00:00",
        "comment_author": "jdm",
        "comment_body": "It's the same problem that the typed arrays bindings have; any view of the contents that doesn't involve copying them needs to be marked unsafe.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2310903883",
    "pr_number": 38288,
    "pr_file": "components/script/indexed_db.rs",
    "created_at": "2025-08-29T19:11:59+00:00",
    "commented_code": "IndexedDBKeyType::Number(n) => result.set(DoubleValue(*n)),\n         IndexedDBKeyType::String(s) => s.safe_to_jsval(cx, result),\n         IndexedDBKeyType::Binary(b) => b.safe_to_jsval(cx, result),\n-        IndexedDBKeyType::Date(_d) => {\n-            // TODO: implement this when Date's representation is finalized.\n-            result.set(UndefinedValue());\n+        IndexedDBKeyType::Date(d) => unsafe {\n+            // TODO: This doesn't clip the time (while firefox does)\n+            // Inner representation of clippedtime is a f64, this is safe\n+            let time: ClippedTime = std::mem::transmute(d.trunc());",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2310903883",
        "repo_full_name": "servo/servo",
        "pr_number": 38288,
        "pr_file": "components/script/indexed_db.rs",
        "discussion_id": "2310903883",
        "commented_code": "@@ -35,9 +38,16 @@ pub fn key_type_to_jsval(\n         IndexedDBKeyType::Number(n) => result.set(DoubleValue(*n)),\n         IndexedDBKeyType::String(s) => s.safe_to_jsval(cx, result),\n         IndexedDBKeyType::Binary(b) => b.safe_to_jsval(cx, result),\n-        IndexedDBKeyType::Date(_d) => {\n-            // TODO: implement this when Date's representation is finalized.\n-            result.set(UndefinedValue());\n+        IndexedDBKeyType::Date(d) => unsafe {\n+            // TODO: This doesn't clip the time (while firefox does)\n+            // Inner representation of clippedtime is a f64, this is safe\n+            let time: ClippedTime = std::mem::transmute(d.trunc());",
        "comment_created_at": "2025-08-29T19:11:59+00:00",
        "comment_author": "jdm",
        "comment_body": "We should add a function to jsglue.cpp in mozjs that calls https://github.com/servo/mozjs/blob/6a966a78b63395fdd5755553d0c0ce79ef26f9e1/mozjs-sys/mozjs/js/public/Date.h#L102 and call it here instead. Transmutes like this are a source of technical debt for future mozjs upgrades.",
        "pr_file_module": null
      },
      {
        "comment_id": "2312106923",
        "repo_full_name": "servo/servo",
        "pr_number": 38288,
        "pr_file": "components/script/indexed_db.rs",
        "discussion_id": "2310903883",
        "commented_code": "@@ -35,9 +38,16 @@ pub fn key_type_to_jsval(\n         IndexedDBKeyType::Number(n) => result.set(DoubleValue(*n)),\n         IndexedDBKeyType::String(s) => s.safe_to_jsval(cx, result),\n         IndexedDBKeyType::Binary(b) => b.safe_to_jsval(cx, result),\n-        IndexedDBKeyType::Date(_d) => {\n-            // TODO: implement this when Date's representation is finalized.\n-            result.set(UndefinedValue());\n+        IndexedDBKeyType::Date(d) => unsafe {\n+            // TODO: This doesn't clip the time (while firefox does)\n+            // Inner representation of clippedtime is a f64, this is safe\n+            let time: ClippedTime = std::mem::transmute(d.trunc());",
        "comment_created_at": "2025-08-30T21:00:26+00:00",
        "comment_author": "arihant2math",
        "comment_body": "I've fixed this in #39008 without a transmute, lets merge that first.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328727006",
    "pr_number": 39193,
    "pr_file": "components/script/dom/trustedtypepolicyfactory.rs",
    "created_at": "2025-09-07T15:20:05+00:00",
    "commented_code": "/// <https://www.w3.org/TR/trusted-types/#dom-trustedtypepolicyfactory-isscripturl>\n     #[allow(unsafe_code)]\n     fn IsScriptURL(&self, cx: JSContext, value: HandleValue) -> bool {\n-        unsafe { root_from_handlevalue::<TrustedScriptURL>(value, *cx).is_ok() }\n+        unsafe { root_from_handlevalue::<TrustedScriptURL>(value, cx).is_ok() }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2328727006",
        "repo_full_name": "servo/servo",
        "pr_number": 39193,
        "pr_file": "components/script/dom/trustedtypepolicyfactory.rs",
        "discussion_id": "2328727006",
        "commented_code": "@@ -369,7 +369,7 @@ impl TrustedTypePolicyFactoryMethods<crate::DomTypeHolder> for TrustedTypePolicy\n     /// <https://www.w3.org/TR/trusted-types/#dom-trustedtypepolicyfactory-isscripturl>\n     #[allow(unsafe_code)]\n     fn IsScriptURL(&self, cx: JSContext, value: HandleValue) -> bool {\n-        unsafe { root_from_handlevalue::<TrustedScriptURL>(value, *cx).is_ok() }\n+        unsafe { root_from_handlevalue::<TrustedScriptURL>(value, cx).is_ok() }",
        "comment_created_at": "2025-09-07T15:20:05+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Can you remove the `unsafe` block here and in other places that you call `root_from_handlevalue` now that it is not an unsafe function? Please give that a shot.\r\n",
        "pr_file_module": null
      }
    ]
  }
]