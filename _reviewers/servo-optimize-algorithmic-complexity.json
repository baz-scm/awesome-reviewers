[
  {
    "discussion_id": "2453121451",
    "pr_number": 39866,
    "pr_file": "components/script_bindings/domstring.rs",
    "created_at": "2025-10-22T19:18:27+00:00",
    "commented_code": "}\n }\n \n+/// Use this to match &str against lazydomstring efficiently.\n+/// You are only allowed to match ascii strings otherwise this macro will\n+/// lead to wrong results.\n+/// ```ignore\n+/// let s = DOMString::from_string(String::from(\"test\"));\n+/// let value = match_domstring!(s, 0,\n+/// \"test1\" => 1,\n+/// \"test2\" => 2,\n+/// \"test\" => 3,);\n+/// assert_eq!(value, 3);\n+/// ```\n+#[macro_export]\n+macro_rules! match_domstring_ascii {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2453121451",
        "repo_full_name": "servo/servo",
        "pr_number": 39866,
        "pr_file": "components/script_bindings/domstring.rs",
        "discussion_id": "2453121451",
        "commented_code": "@@ -675,6 +701,50 @@ impl From<Cow<'_, str>> for DOMString {\n     }\n }\n \n+/// Use this to match &str against lazydomstring efficiently.\n+/// You are only allowed to match ascii strings otherwise this macro will\n+/// lead to wrong results.\n+/// ```ignore\n+/// let s = DOMString::from_string(String::from(\"test\"));\n+/// let value = match_domstring!(s, 0,\n+/// \"test1\" => 1,\n+/// \"test2\" => 2,\n+/// \"test\" => 3,);\n+/// assert_eq!(value, 3);\n+/// ```\n+#[macro_export]\n+macro_rules! match_domstring_ascii {",
        "comment_created_at": "2025-10-22T19:18:27+00:00",
        "comment_author": "jdm",
        "comment_body": "I spent more time playing around with this and came up with https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=89d2abf25f4fe95d179eca01dca2df3a . The only downside I see is that we don't get to assert all the branches are ascii up front, only if we reach the branch. I think that's an ok tradeoff if it allows us to keep the default branches like normal match statements, though.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1805164254",
    "pr_number": 31746,
    "pr_file": "components/layout_2020/replaced.rs",
    "created_at": "2024-10-17T17:38:07+00:00",
    "commented_code": "browsing_context_id,\n                     }),\n                     None,\n+                    None,\n                 )\n-            } else if let Some((image_key, natural_size_in_dots)) = element.as_video() {\n+            } else if let Some((image_key, natural_size_in_dots, ratio_fallback)) =\n+                element.as_video()\n+            {\n                 (\n-                    ReplacedContentKind::Video(VideoInfo { image_key }),\n-                    Some(natural_size_in_dots),\n+                    ReplacedContentKind::Video(image_key.map(|key| VideoInfo { image_key: key })),\n+                    natural_size_in_dots,\n+                    ratio_fallback,\n                 )\n             } else {\n                 return None;\n             }\n         };\n \n-        let natural_size =\n-            natural_size_in_dots.map_or_else(NaturalSizes::empty, |naturalc_size_in_dots| {\n+        let natural_size = natural_size_in_dots.map_or_else(\n+            || NaturalSizes::empty().with_fallback(ratio_fallback),\n+            |naturalc_size_in_dots| {\n                 // FIXME: should 'image-resolution' (when implemented) be used *instead* of\n                 // `script::dom::htmlimageelement::ImageRequest::current_pixel_density`?\n                 // https://drafts.csswg.org/css-images-4/#the-image-resolution\n                 let dppx = 1.0;\n                 let width = (naturalc_size_in_dots.width as CSSFloat) / dppx;\n                 let height = (naturalc_size_in_dots.height as CSSFloat) / dppx;\n                 NaturalSizes::from_width_and_height(width, height)\n-            });\n+            },\n+        );",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "1805164254",
        "repo_full_name": "servo/servo",
        "pr_number": 31746,
        "pr_file": "components/layout_2020/replaced.rs",
        "discussion_id": "1805164254",
        "commented_code": "@@ -170,27 +180,33 @@ impl ReplacedContent {\n                         browsing_context_id,\n                     }),\n                     None,\n+                    None,\n                 )\n-            } else if let Some((image_key, natural_size_in_dots)) = element.as_video() {\n+            } else if let Some((image_key, natural_size_in_dots, ratio_fallback)) =\n+                element.as_video()\n+            {\n                 (\n-                    ReplacedContentKind::Video(VideoInfo { image_key }),\n-                    Some(natural_size_in_dots),\n+                    ReplacedContentKind::Video(image_key.map(|key| VideoInfo { image_key: key })),\n+                    natural_size_in_dots,\n+                    ratio_fallback,\n                 )\n             } else {\n                 return None;\n             }\n         };\n \n-        let natural_size =\n-            natural_size_in_dots.map_or_else(NaturalSizes::empty, |naturalc_size_in_dots| {\n+        let natural_size = natural_size_in_dots.map_or_else(\n+            || NaturalSizes::empty().with_fallback(ratio_fallback),\n+            |naturalc_size_in_dots| {\n                 // FIXME: should 'image-resolution' (when implemented) be used *instead* of\n                 // `script::dom::htmlimageelement::ImageRequest::current_pixel_density`?\n                 // https://drafts.csswg.org/css-images-4/#the-image-resolution\n                 let dppx = 1.0;\n                 let width = (naturalc_size_in_dots.width as CSSFloat) / dppx;\n                 let height = (naturalc_size_in_dots.height as CSSFloat) / dppx;\n                 NaturalSizes::from_width_and_height(width, height)\n-            });\n+            },\n+        );",
        "comment_created_at": "2024-10-17T17:38:07+00:00",
        "comment_author": "Loirooriol",
        "comment_body": "And then here this can be\r\n\r\n```rs\r\n        let natural_size = if let Some(naturalc_size_in_dots) = natural_size_in_dots {\r\n            // FIXME: should 'image-resolution' (when implemented) be used *instead* of\r\n            // `script::dom::htmlimageelement::ImageRequest::current_pixel_density`?\r\n            // https://drafts.csswg.org/css-images-4/#the-image-resolution\r\n            let dppx = 1.0;\r\n            let width = (naturalc_size_in_dots.width as CSSFloat) / dppx;\r\n            let height = (naturalc_size_in_dots.height as CSSFloat) / dppx;\r\n            NaturalSizes::from_width_and_height(width, height)\r\n        } else if needs_ratio_fallback {\r\n            let size = ReplacedContent::default_object_size(WritingMode::empty());\r\n            let ratio_fallback = size.inline.to_f32_px() / size.block.to_f32_px();\r\n            NaturalSizes::from_ratio(Some(ratio_fallback))\r\n        } else {\r\n            NaturalSizes::empty()\r\n        };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2443875436",
    "pr_number": 39072,
    "pr_file": "components/compositing/touch.rs",
    "created_at": "2025-10-20T05:56:23+00:00",
    "commented_code": "}\n     }\n \n+    pub(crate) fn currently_in_touch_sequence(&self) -> bool {\n+        self.touch_sequence_map",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2443875436",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/touch.rs",
        "discussion_id": "2443875436",
        "commented_code": "@@ -213,6 +217,14 @@ impl TouchHandler {\n         }\n     }\n \n+    pub(crate) fn currently_in_touch_sequence(&self) -> bool {\n+        self.touch_sequence_map",
        "comment_created_at": "2025-10-20T05:56:23+00:00",
        "comment_author": "mukilan",
        "comment_body": "```suggestion\r\n   self.touch_sequence_map\r\n            .get(&self.current_sequence_id)\r\n            .is_some_and(|sequence| sequence.state != TouchSequenceState::Finished)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2444290081",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/touch.rs",
        "discussion_id": "2443875436",
        "commented_code": "@@ -213,6 +217,14 @@ impl TouchHandler {\n         }\n     }\n \n+    pub(crate) fn currently_in_touch_sequence(&self) -> bool {\n+        self.touch_sequence_map",
        "comment_created_at": "2025-10-20T09:07:19+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2443880862",
    "pr_number": 39072,
    "pr_file": "components/compositing/refresh_driver.rs",
    "created_at": "2025-10-20T06:00:51+00:00",
    "commented_code": "}));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2443880862",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/refresh_driver.rs",
        "discussion_id": "2443880862",
        "commented_code": "@@ -230,3 +246,24 @@ impl TimerThread {\n             }));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
        "comment_created_at": "2025-10-20T06:00:51+00:00",
        "comment_author": "mukilan",
        "comment_body": "Seems like we can pass `new_start_frame_callback` directly as the timer's callback if it had a `+ 'static` bound. Any reason we can't or don't want to do it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2444416319",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/refresh_driver.rs",
        "discussion_id": "2443880862",
        "commented_code": "@@ -230,3 +246,24 @@ impl TimerThread {\n             }));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
        "comment_created_at": "2025-10-20T09:39:01+00:00",
        "comment_author": "mrobinson",
        "comment_body": "If I pass `impl Fn() + Send + 'static` I get this error:\r\n\r\n```\r\n`the size for values of type (dyn std::ops::Fn() + std::marker::Send + 'static) cannot be known at compilation time\r\nthe trait std::marker::Sized is not implemented for (dyn std::ops::Fn() + std::marker::Send + 'static) (rustc E0277)\r\n```\r\n\r\nIf I pass `impl Fn() + Send + 'static` I get this error:\r\n\r\n```\r\nthe trait embedder_traits::RefreshDriver is not dyn compatible\r\nonly type refresh_driver::TimerRefreshDriver implements embedder_traits::RefreshDriver; consider using it directly instead. (rustc E0038)\r\n```\r\n\r\nIt seems we need to pass a `Box`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2444448954",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/refresh_driver.rs",
        "discussion_id": "2443880862",
        "commented_code": "@@ -230,3 +246,24 @@ impl TimerThread {\n             }));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
        "comment_created_at": "2025-10-20T09:46:54+00:00",
        "comment_author": "mukilan",
        "comment_body": "@mrobinson not sure if you've seen this comment?",
        "pr_file_module": null
      },
      {
        "comment_id": "2444479941",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/refresh_driver.rs",
        "discussion_id": "2443880862",
        "commented_code": "@@ -230,3 +246,24 @@ impl TimerThread {\n             }));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
        "comment_created_at": "2025-10-20T09:55:00+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Sorry. I had the comment written, but it was still \"Pending\" in GitHub.",
        "pr_file_module": null
      },
      {
        "comment_id": "2444498001",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/refresh_driver.rs",
        "discussion_id": "2443880862",
        "commented_code": "@@ -230,3 +246,24 @@ impl TimerThread {\n             }));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
        "comment_created_at": "2025-10-20T09:58:53+00:00",
        "comment_author": "mukilan",
        "comment_body": "Hmm...not sure if expressed my intention clearly in the original comment.\r\n\r\nI mean the type for `new_start_frame_callback` can be `Box<dyn Fn() + Send + 'static>` here as well as in the trait definition of RefreshDriver and other places. That should allow passing `new_start_frame_callback` directly to `queue_timer` as it also expects a `Box<dyn Fn() + Send + 'static>`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2444523524",
        "repo_full_name": "servo/servo",
        "pr_number": 39072,
        "pr_file": "components/compositing/refresh_driver.rs",
        "discussion_id": "2443880862",
        "commented_code": "@@ -230,3 +246,24 @@ impl TimerThread {\n             }));\n     }\n }\n+\n+impl RefreshDriver for TimerRefreshDriver {\n+    fn observe_next_frame(&self, new_start_frame_callback: Box<dyn Fn() + Send>) {\n+        const FRAME_DURATION: Duration = Duration::from_millis(1000 / 120);\n+        self.queue_timer(\n+            FRAME_DURATION,\n+            Box::new(move || {",
        "comment_created_at": "2025-10-20T10:05:42+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Oh, I understand now. I've gone ahead and done this now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2440693348",
    "pr_number": 39965,
    "pr_file": "components/xpath/src/lib.rs",
    "created_at": "2025-10-17T17:33:13+00:00",
    "commented_code": "fn as_attribute(&self) -> Option<Self::Attribute>;\n     fn as_element(&self) -> Option<Self::Element>;\n     fn lookup_namespace_uri(&self, uri: Option<&str>) -> Option<String>;\n+    fn get_root_node(&self) -> Self;",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2440693348",
        "repo_full_name": "servo/servo",
        "pr_number": 39965,
        "pr_file": "components/xpath/src/lib.rs",
        "discussion_id": "2440693348",
        "commented_code": "@@ -56,6 +56,7 @@ pub trait Node: Eq + Clone + Debug {\n     fn as_attribute(&self) -> Option<Self::Attribute>;\n     fn as_element(&self) -> Option<Self::Element>;\n     fn lookup_namespace_uri(&self, uri: Option<&str>) -> Option<String>;\n+    fn get_root_node(&self) -> Self;",
        "comment_created_at": "2025-10-17T17:33:13+00:00",
        "comment_author": "simonwuelker",
        "comment_body": "I added a new trait method here because while we could traverse the node's ancestors, it is often possible to get a node's root node in `O(1)` if it is in a shadow tree or a document tree.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2336829285",
    "pr_number": 39244,
    "pr_file": "components/net/protocols/mod.rs",
    "created_at": "2025-09-10T13:47:34+00:00",
    "commented_code": "#[derive(Default)]\n pub struct ProtocolRegistry {\n-    pub(crate) handlers: HashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler\n+    pub(crate) handlers: FxHashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2336829285",
        "repo_full_name": "servo/servo",
        "pr_number": 39244,
        "pr_file": "components/net/protocols/mod.rs",
        "discussion_id": "2336829285",
        "commented_code": "@@ -68,7 +68,7 @@ pub trait ProtocolHandler: Send + Sync {\n \n #[derive(Default)]\n pub struct ProtocolRegistry {\n-    pub(crate) handlers: HashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler\n+    pub(crate) handlers: FxHashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler",
        "comment_created_at": "2025-09-10T13:47:34+00:00",
        "comment_author": "sagudev",
        "comment_body": "This is registerable only via embededer, right? I think it's okay to not use secure hashing, although I am not sure about performance (IIRC fxhash is only good for u64 or less).",
        "pr_file_module": null
      },
      {
        "comment_id": "2337253961",
        "repo_full_name": "servo/servo",
        "pr_number": 39244,
        "pr_file": "components/net/protocols/mod.rs",
        "discussion_id": "2336829285",
        "commented_code": "@@ -68,7 +68,7 @@ pub trait ProtocolHandler: Send + Sync {\n \n #[derive(Default)]\n pub struct ProtocolRegistry {\n-    pub(crate) handlers: HashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler\n+    pub(crate) handlers: FxHashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler",
        "comment_created_at": "2025-09-10T16:12:33+00:00",
        "comment_author": "Narfinger",
        "comment_body": "This benchmark: https://github.com/narfinger/hash-rs  shows that fxhash (and I assume rustc-hash is faster) beats sip up to 2048 bytes. Fnvhash beats sip up to 16 bytes. So I think the string performance is ok. But I am going to write a comment in register protocols to be safe.",
        "pr_file_module": null
      },
      {
        "comment_id": "2340467782",
        "repo_full_name": "servo/servo",
        "pr_number": 39244,
        "pr_file": "components/net/protocols/mod.rs",
        "discussion_id": "2336829285",
        "commented_code": "@@ -68,7 +68,7 @@ pub trait ProtocolHandler: Send + Sync {\n \n #[derive(Default)]\n pub struct ProtocolRegistry {\n-    pub(crate) handlers: HashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler\n+    pub(crate) handlers: FxHashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler",
        "comment_created_at": "2025-09-11T11:59:32+00:00",
        "comment_author": "nicoburns",
        "comment_body": "@Narfinger https://github.com/orlp/foldhash or https://github.com/Nicoshev/rapidhash are recommended as a fast hash for types larger than ~64-128bits (and hash functions are usually very small (<200 lines of very simple code) so having a couple in our codebase for different use cases shouldn't be a problem).",
        "pr_file_module": null
      },
      {
        "comment_id": "2340596451",
        "repo_full_name": "servo/servo",
        "pr_number": 39244,
        "pr_file": "components/net/protocols/mod.rs",
        "discussion_id": "2336829285",
        "commented_code": "@@ -68,7 +68,7 @@ pub trait ProtocolHandler: Send + Sync {\n \n #[derive(Default)]\n pub struct ProtocolRegistry {\n-    pub(crate) handlers: HashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler\n+    pub(crate) handlers: FxHashMap<String, Box<dyn ProtocolHandler>>, // Maps scheme -> handler",
        "comment_created_at": "2025-09-11T12:27:45+00:00",
        "comment_author": "Narfinger",
        "comment_body": "That might be a valid point but I think there are currently not any other cases than this here we should change the Hash Function. Rapidhash (which has a nice graph) beats fx somewhere between 8 and 12 bytes.\r\nI don't think ProtocolRegistry is that important to have fast hash functions for strings larger than 12 bytes.\r\nSo I would keep using rustc_hash for this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2366906208",
    "pr_number": 39402,
    "pr_file": "components/shared/compositing/display_list.rs",
    "created_at": "2025-09-22T06:59:26+00:00",
    "commented_code": "fn cumulative_node_transform_inner(\n         &self,\n         node: &ScrollTreeNode,\n-    ) -> (ScrollTreeNodeTransformationCache, AncestorStickyInfo) {\n-        let (parent_transforms, mut sticky_info) = match node.parent {\n-            Some(parent_id) => self.cumulative_node_transform_inner(self.get_node(parent_id)),\n-            None => (Default::default(), Default::default()),\n+    ) -> ScrollTreeNodeTransformationCache {\n+        let parent_transforms = match node.parent {\n+            Some(parent_id) => self.cumulative_node_transform(parent_id),\n+            None => Default::default(),",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2366906208",
        "repo_full_name": "servo/servo",
        "pr_number": 39402,
        "pr_file": "components/shared/compositing/display_list.rs",
        "discussion_id": "2366906208",
        "commented_code": "@@ -652,65 +648,75 @@ impl ScrollTree {\n     fn cumulative_node_transform_inner(\n         &self,\n         node: &ScrollTreeNode,\n-    ) -> (ScrollTreeNodeTransformationCache, AncestorStickyInfo) {\n-        let (parent_transforms, mut sticky_info) = match node.parent {\n-            Some(parent_id) => self.cumulative_node_transform_inner(self.get_node(parent_id)),\n-            None => (Default::default(), Default::default()),\n+    ) -> ScrollTreeNodeTransformationCache {\n+        let parent_transforms = match node.parent {\n+            Some(parent_id) => self.cumulative_node_transform(parent_id),\n+            None => Default::default(),",
        "comment_created_at": "2025-09-22T06:59:26+00:00",
        "comment_author": "mrobinson",
        "comment_body": "```suggestion\r\n        let parent_transforms = node.parent\r\n            .map(|parent_id| self.cumulative_node_transform(parent_id))\r\n            .unwrap_or_default();\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2362737317",
    "pr_number": 39385,
    "pr_file": "components/layout/query.rs",
    "created_at": "2025-09-19T12:32:43+00:00",
    "commented_code": "} else {\n         parent_fragment.offset_by_containing_block(&parent_fragment.padding_rect())\n     };\n+    if let Some(offsets) = cumulative_sticky_offsets\n+        .and_then(|_| parent_fragment.spatial_tree_node())\n+        .map(|node_id| scroll_tree.cumulative_sticky_offsets(node_id))\n+    {\n+        parent_offset_rect = parent_offset_rect.translate(offsets.map(Au::from_f32_px).cast_unit());\n+    }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2362737317",
        "repo_full_name": "servo/servo",
        "pr_number": 39385,
        "pr_file": "components/layout/query.rs",
        "discussion_id": "2362737317",
        "commented_code": "@@ -639,6 +648,12 @@ pub fn process_offset_parent_query(node: ServoLayoutNode<'_>) -> Option<OffsetPa\n     } else {\n         parent_fragment.offset_by_containing_block(&parent_fragment.padding_rect())\n     };\n+    if let Some(offsets) = cumulative_sticky_offsets\n+        .and_then(|_| parent_fragment.spatial_tree_node())\n+        .map(|node_id| scroll_tree.cumulative_sticky_offsets(node_id))\n+    {\n+        parent_offset_rect = parent_offset_rect.translate(offsets.map(Au::from_f32_px).cast_unit());\n+    }",
        "comment_created_at": "2025-09-19T12:32:43+00:00",
        "comment_author": "mrobinson",
        "comment_body": "```suggestion\r\n    let offsets = cumulative_sticky_offsets\r\n        .and_then(|_| parent_fragment.spatial_tree_node())\r\n        .map(|node_id| scroll_tree.cumulative_sticky_offsets(node_id))\r\n        .unwrap_or_default();\r\n    parent_offset_rect = parent_offset_rect.translate(offsets.map(Au::from_f32_px).cast_unit());\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2333998663",
    "pr_number": 39233,
    "pr_file": "components/script/dom/webgl/webglprogram.rs",
    "created_at": "2025-09-09T15:21:47+00:00",
    "commented_code": "let link_info = receiver.recv().unwrap();\n \n         {\n-            let mut used_locs = FnvHashSet::default();\n-            let mut used_names = FnvHashSet::default();\n+            let mut used_locs = FxHashSet::default();\n+            let mut used_names = FxHashSet::default();",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2333998663",
        "repo_full_name": "servo/servo",
        "pr_number": 39233,
        "pr_file": "components/script/dom/webgl/webglprogram.rs",
        "discussion_id": "2333998663",
        "commented_code": "@@ -180,8 +180,8 @@ impl WebGLProgram {\n         let link_info = receiver.recv().unwrap();\n \n         {\n-            let mut used_locs = FnvHashSet::default();\n-            let mut used_names = FnvHashSet::default();\n+            let mut used_locs = FxHashSet::default();\n+            let mut used_names = FxHashSet::default();",
        "comment_created_at": "2025-09-09T15:21:47+00:00",
        "comment_author": "sagudev",
        "comment_body": "I am pretty sure both of these need to be normal hashmap, because its value is computed from user input.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2280392813",
    "pr_number": 38707,
    "pr_file": "components/fonts/shapers/harfrust.rs",
    "created_at": "2025-08-16T11:51:18+00:00",
    "commented_code": "+use app_units::Au;\n+use euclid::default::Point2D;\n+use harfrust::{\n+    Feature, FontRef as HarfRustFontRef, GlyphBuffer, Script, ShaperData, Tag, UnicodeBuffer,\n+};\n+use num_traits::Zero as _;\n+use smallvec::SmallVec;\n+\n+use super::{ShapedGlyphEntry, THarfShapedGlyphData, THarfShaper, unicode_to_hb_script};\n+use crate::{Font, FontData, ShapingFlags, fixed_to_float};\n+\n+#[inline(always)]\n+fn au_from_fixed_glyph_info(i: i32, ppem: f64) -> Au {\n+    Au::from_f64_px(fixed_to_float(16, i) * ppem * 64.0)",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2280392813",
        "repo_full_name": "servo/servo",
        "pr_number": 38707,
        "pr_file": "components/fonts/shapers/harfrust.rs",
        "discussion_id": "2280392813",
        "commented_code": "@@ -0,0 +1,159 @@\n+use app_units::Au;\n+use euclid::default::Point2D;\n+use harfrust::{\n+    Feature, FontRef as HarfRustFontRef, GlyphBuffer, Script, ShaperData, Tag, UnicodeBuffer,\n+};\n+use num_traits::Zero as _;\n+use smallvec::SmallVec;\n+\n+use super::{ShapedGlyphEntry, THarfShapedGlyphData, THarfShaper, unicode_to_hb_script};\n+use crate::{Font, FontData, ShapingFlags, fixed_to_float};\n+\n+#[inline(always)]\n+fn au_from_fixed_glyph_info(i: i32, ppem: f64) -> Au {\n+    Au::from_f64_px(fixed_to_float(16, i) * ppem * 64.0)",
        "comment_created_at": "2025-08-16T11:51:18+00:00",
        "comment_author": "dfrg",
        "comment_body": "HarfRust always shapes in font units so we don\u2019t have a fixed point value here. I believe the proper code is `i as f64 * scale` where `scale` is `ppem / upem`. You can grab the `upem` value with `Shaper::units_per_em()` when you\u2019re shaping a run and precompute the scale there. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2280421011",
        "repo_full_name": "servo/servo",
        "pr_number": 38707,
        "pr_file": "components/fonts/shapers/harfrust.rs",
        "discussion_id": "2280392813",
        "commented_code": "@@ -0,0 +1,159 @@\n+use app_units::Au;\n+use euclid::default::Point2D;\n+use harfrust::{\n+    Feature, FontRef as HarfRustFontRef, GlyphBuffer, Script, ShaperData, Tag, UnicodeBuffer,\n+};\n+use num_traits::Zero as _;\n+use smallvec::SmallVec;\n+\n+use super::{ShapedGlyphEntry, THarfShapedGlyphData, THarfShaper, unicode_to_hb_script};\n+use crate::{Font, FontData, ShapingFlags, fixed_to_float};\n+\n+#[inline(always)]\n+fn au_from_fixed_glyph_info(i: i32, ppem: f64) -> Au {\n+    Au::from_f64_px(fixed_to_float(16, i) * ppem * 64.0)",
        "comment_created_at": "2025-08-16T12:52:17+00:00",
        "comment_author": "nicoburns",
        "comment_body": "This seems to have fixed things - thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2286860921",
    "pr_number": 38707,
    "pr_file": "components/fonts/shapers/harfbuzz.rs",
    "created_at": "2025-08-20T03:01:58+00:00",
    "commented_code": "features.len() as u32,\n             );\n \n-            self.save_glyph_results(text, options, glyphs, hb_buffer);\n-            hb_buffer_destroy(hb_buffer);\n+            ShapedGlyphData::new(hb_buffer)",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2286860921",
        "repo_full_name": "servo/servo",
        "pr_number": 38707,
        "pr_file": "components/fonts/shapers/harfbuzz.rs",
        "discussion_id": "2286860921",
        "commented_code": "@@ -288,183 +276,15 @@ impl Shaper {\n                 features.len() as u32,\n             );\n \n-            self.save_glyph_results(text, options, glyphs, hb_buffer);\n-            hb_buffer_destroy(hb_buffer);\n+            ShapedGlyphData::new(hb_buffer)",
        "comment_created_at": "2025-08-20T03:01:58+00:00",
        "comment_author": "d-desiatkin",
        "comment_body": "I see that here you attempt to save created buffer. If we started to do this, then we must go further and reuse cached buffer on each shape call. \r\nActually\r\n`self.save_glyph_results(text, options, glyphs, hb_buffer);`\r\nline deleted by you was added with idea of `hb_buffer` reuse in the future.\r\n\r\nSuch hb_buffer caching is done in chromium and a bunch of other implementations, because hb_buffer creation is considered to be relatively expensive operation.\r\nTo reuse the shaper we must first extract the data and then call special hb_function\r\n[hb-buffer-reset](https://harfbuzz.github.io/harfbuzz-hb-buffer.html#hb-buffer-reset)\r\n\r\nI understand that servo use another approach to shaping though. We can use same shaper from different threads. That is why this `hb_buffer` caching was never fully added here.\r\n(We do not want to protect it with synchronization primitive)\r\n\r\nI understand that this idea pursue better packaging of shaping call into some fiber or coroutine.\r\nOr some abstract task that could be executed on arbitrary thread\r\n\r\n**Updated**\r\nActually I see that you try to generalize `save_glyph_results` function to be shaper agnostic.\r\nI believe it is not the best architectural solution, it probably will be fine for harfbuzz and harfrust.\r\nBut if some new shaper will emerge, that could be problematic.\r\n\r\nI believe that what we actually want is to leave realization here and create interface on data structures level.\r\nSo we just agree on specific output of this function, and leave it as generic `Shaper` trait that each backend should implement.\r\n\r\nIdeally input arguments should also be somewhat permissive\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2288628127",
        "repo_full_name": "servo/servo",
        "pr_number": 38707,
        "pr_file": "components/fonts/shapers/harfbuzz.rs",
        "discussion_id": "2286860921",
        "commented_code": "@@ -288,183 +276,15 @@ impl Shaper {\n                 features.len() as u32,\n             );\n \n-            self.save_glyph_results(text, options, glyphs, hb_buffer);\n-            hb_buffer_destroy(hb_buffer);\n+            ShapedGlyphData::new(hb_buffer)",
        "comment_created_at": "2025-08-20T16:03:28+00:00",
        "comment_author": "d-desiatkin",
        "comment_body": "We can try to think about 1 buffer for each thread and store buffers in thread local variables",
        "pr_file_module": null
      }
    ]
  }
]