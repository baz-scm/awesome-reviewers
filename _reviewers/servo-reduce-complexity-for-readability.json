[
  {
    "discussion_id": "2443818337",
    "pr_number": 39994,
    "pr_file": "components/script/timers.rs",
    "created_at": "2025-10-20T05:00:56+00:00",
    "commented_code": "use crate::script_thread::ScriptThread;\n use crate::task_source::SendableTaskSource;\n \n+type TimerKey = i32;\n+type RunStepsDeadline = Instant;\n+type CompletionStep = Box<dyn FnOnce(&GlobalScope, CanGc) + 'static>;\n+\n+// OrderingIdentifier per spec (\"orderingIdentifier\")\n+type OrderingIdentifier = DOMString;\n+\n+// Per-ordering queue entry: (deadline_ms, sequence, handle)\n+type OrderingEntry = (u64, u64, OneshotTimerHandle);",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2443818337",
        "repo_full_name": "servo/servo",
        "pr_number": 39994,
        "pr_file": "components/script/timers.rs",
        "discussion_id": "2443818337",
        "commented_code": "@@ -43,6 +43,22 @@ use crate::script_runtime::{CanGc, IntroductionType};\n use crate::script_thread::ScriptThread;\n use crate::task_source::SendableTaskSource;\n \n+type TimerKey = i32;\n+type RunStepsDeadline = Instant;\n+type CompletionStep = Box<dyn FnOnce(&GlobalScope, CanGc) + 'static>;\n+\n+// OrderingIdentifier per spec (\"orderingIdentifier\")\n+type OrderingIdentifier = DOMString;\n+\n+// Per-ordering queue entry: (deadline_ms, sequence, handle)\n+type OrderingEntry = (u64, u64, OneshotTimerHandle);",
        "comment_created_at": "2025-10-20T05:00:56+00:00",
        "comment_author": "TimvdLippe",
        "comment_body": "Nit: make this a struct with named fields, so it is easier to distinguish the two u64",
        "pr_file_module": null
      },
      {
        "comment_id": "2447271295",
        "repo_full_name": "servo/servo",
        "pr_number": 39994,
        "pr_file": "components/script/timers.rs",
        "discussion_id": "2443818337",
        "commented_code": "@@ -43,6 +43,22 @@ use crate::script_runtime::{CanGc, IntroductionType};\n use crate::script_thread::ScriptThread;\n use crate::task_source::SendableTaskSource;\n \n+type TimerKey = i32;\n+type RunStepsDeadline = Instant;\n+type CompletionStep = Box<dyn FnOnce(&GlobalScope, CanGc) + 'static>;\n+\n+// OrderingIdentifier per spec (\"orderingIdentifier\")\n+type OrderingIdentifier = DOMString;\n+\n+// Per-ordering queue entry: (deadline_ms, sequence, handle)\n+type OrderingEntry = (u64, u64, OneshotTimerHandle);",
        "comment_created_at": "2025-10-21T08:40:03+00:00",
        "comment_author": "gterzian",
        "comment_body": "Good point",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1730284647",
    "pr_number": 33025,
    "pr_file": "components/devtools/actors/inspector/page_style.rs",
    "created_at": "2024-08-25T08:31:55+00:00",
    "commented_code": "/// The page style actor can handle the following messages:\n     ///\n-    /// - `getApplied`: Returns the applied styles for a node, placeholder\n+    /// - `getApplied`: Returns the applied styles for a node, they represent the explicit css\n+    /// rules set for them, both in the style attribute and in stylesheets.\n     ///\n-    /// - `getComputed`: Returns the computed styles for a node, placeholder\n+    /// - `getComputed`: Returns the computed styles for a node, these include all of the supported\n+    /// css properties calculated values.\n     ///\n-    /// - `getLayout`: Returns the box layout properties for a node, placeholder\n+    /// - `getLayout`: Returns the box layout properties for a node.\n     ///\n-    /// - `isPositionEditable`: Informs whether you can change a style property in the inspector\n+    /// - `isPositionEditable`: Informs whether you can change a style property in the inspector.\n     fn handle_message(",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "1730284647",
        "repo_full_name": "servo/servo",
        "pr_number": 33025,
        "pr_file": "components/devtools/actors/inspector/page_style.rs",
        "discussion_id": "1730284647",
        "commented_code": "@@ -125,13 +103,15 @@ impl Actor for PageStyleActor {\n \n     /// The page style actor can handle the following messages:\n     ///\n-    /// - `getApplied`: Returns the applied styles for a node, placeholder\n+    /// - `getApplied`: Returns the applied styles for a node, they represent the explicit css\n+    /// rules set for them, both in the style attribute and in stylesheets.\n     ///\n-    /// - `getComputed`: Returns the computed styles for a node, placeholder\n+    /// - `getComputed`: Returns the computed styles for a node, these include all of the supported\n+    /// css properties calculated values.\n     ///\n-    /// - `getLayout`: Returns the box layout properties for a node, placeholder\n+    /// - `getLayout`: Returns the box layout properties for a node.\n     ///\n-    /// - `isPositionEditable`: Informs whether you can change a style property in the inspector\n+    /// - `isPositionEditable`: Informs whether you can change a style property in the inspector.\n     fn handle_message(",
        "comment_created_at": "2024-08-25T08:31:55+00:00",
        "comment_author": "mrobinson",
        "comment_body": "This getting quite large. Would it be possible to split it into methods -- one per message?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1805105486",
    "pr_number": 31746,
    "pr_file": "components/layout_2020/dom.rs",
    "created_at": "2024-10-17T16:47:16+00:00",
    "commented_code": "Some((resource, PhysicalSize::new(width, height)))\n     }\n \n-    fn as_video(self) -> Option<(webrender_api::ImageKey, PhysicalSize<f64>)> {\n+    fn as_video(\n+        self,\n+    ) -> Option<(\n+        Option<webrender_api::ImageKey>,\n+        Option<PhysicalSize<f64>>,\n+        Option<f32>,\n+    )> {\n         let node = self.to_threadsafe();\n-        let frame_data = node.media_data()?.current_frame?;\n-        let (width, height) = (frame_data.1 as f64, frame_data.2 as f64);\n-        Some((frame_data.0, PhysicalSize::new(width, height)))\n+        let data = node.media_data()?;\n+        let natural_size = data\n+            .current_frame\n+            .as_ref()\n+            .map(|frame| (frame.width.into(), frame.height.into()))\n+            .or(data\n+                .metadata\n+                .map(|meta| (meta.width.into(), meta.height.into())))\n+            .map(|(width, height)| PhysicalSize::new(width, height));",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "1805105486",
        "repo_full_name": "servo/servo",
        "pr_number": 31746,
        "pr_file": "components/layout_2020/dom.rs",
        "discussion_id": "1805105486",
        "commented_code": "@@ -136,11 +143,32 @@ where\n         Some((resource, PhysicalSize::new(width, height)))\n     }\n \n-    fn as_video(self) -> Option<(webrender_api::ImageKey, PhysicalSize<f64>)> {\n+    fn as_video(\n+        self,\n+    ) -> Option<(\n+        Option<webrender_api::ImageKey>,\n+        Option<PhysicalSize<f64>>,\n+        Option<f32>,\n+    )> {\n         let node = self.to_threadsafe();\n-        let frame_data = node.media_data()?.current_frame?;\n-        let (width, height) = (frame_data.1 as f64, frame_data.2 as f64);\n-        Some((frame_data.0, PhysicalSize::new(width, height)))\n+        let data = node.media_data()?;\n+        let natural_size = data\n+            .current_frame\n+            .as_ref()\n+            .map(|frame| (frame.width.into(), frame.height.into()))\n+            .or(data\n+                .metadata\n+                .map(|meta| (meta.width.into(), meta.height.into())))\n+            .map(|(width, height)| PhysicalSize::new(width, height));",
        "comment_created_at": "2024-10-17T16:47:16+00:00",
        "comment_author": "Loirooriol",
        "comment_body": "Nit: I think this is a bit clearer like this:\r\n\r\n```suggestion\r\n        let natural_size = if let Some(frame) = data.current_frame {\r\n            Some(PhysicalSize::new(frame.width.into(), frame.height.into()))\r\n        } else if let Some(meta) = data.metadata {\r\n            Some(PhysicalSize::new(meta.width.into(), meta.height.into()))\r\n        } else {\r\n            None\r\n        };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2414854110",
    "pr_number": 39259,
    "pr_file": "ports/servoshell/desktop/minibrowser.rs",
    "created_at": "2025-10-08T19:42:28+00:00",
    "commented_code": "/// Updates all fields taken from the given [WebViewManager], such as the location field.\n     /// Returns true iff the egui needs an update.\n-    pub fn update_webview_data(&mut self, state: &RunningAppState) -> bool {\n+    pub fn update_webview_data(\n+        &mut self,\n+        state: &RunningAppState,\n+        window: Rc<dyn WindowPortsMethods>,\n+    ) -> bool {\n         // Note: We must use the \"bitwise OR\" (|) operator here instead of \"logical OR\" (||)\n         //       because logical OR would short-circuit if any of the functions return true.\n         //       We want to ensure that all functions are called. The \"bitwise OR\" operator\n         //       does not short-circuit.\n-        self.update_location_in_toolbar(state) |\n+        let mut egui_needs_update = self.update_location_in_toolbar(state) |\n             self.update_load_status(state) |\n-            self.update_status_text(state)\n+            self.update_status_text(state);\n+\n+        let changed = if let Some(webview) = state.focused_webview() {\n+            let title = webview\n+                .page_title()\n+                .filter(|t| !t.is_empty())\n+                .map(|t| t.to_string())\n+                .or_else(|| webview.url().map(|u| u.to_string()))\n+                .unwrap_or_else(|| \"Servo\".to_string());\n+\n+            window.set_title_if_changed(&title)\n+        } else {\n+            false\n+        };",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2414854110",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/minibrowser.rs",
        "discussion_id": "2414854110",
        "commented_code": "@@ -547,14 +547,34 @@ impl Minibrowser {\n \n     /// Updates all fields taken from the given [WebViewManager], such as the location field.\n     /// Returns true iff the egui needs an update.\n-    pub fn update_webview_data(&mut self, state: &RunningAppState) -> bool {\n+    pub fn update_webview_data(\n+        &mut self,\n+        state: &RunningAppState,\n+        window: Rc<dyn WindowPortsMethods>,\n+    ) -> bool {\n         // Note: We must use the \"bitwise OR\" (|) operator here instead of \"logical OR\" (||)\n         //       because logical OR would short-circuit if any of the functions return true.\n         //       We want to ensure that all functions are called. The \"bitwise OR\" operator\n         //       does not short-circuit.\n-        self.update_location_in_toolbar(state) |\n+        let mut egui_needs_update = self.update_location_in_toolbar(state) |\n             self.update_load_status(state) |\n-            self.update_status_text(state)\n+            self.update_status_text(state);\n+\n+        let changed = if let Some(webview) = state.focused_webview() {\n+            let title = webview\n+                .page_title()\n+                .filter(|t| !t.is_empty())\n+                .map(|t| t.to_string())\n+                .or_else(|| webview.url().map(|u| u.to_string()))\n+                .unwrap_or_else(|| \"Servo\".to_string());\n+\n+            window.set_title_if_changed(&title)\n+        } else {\n+            false\n+        };",
        "comment_created_at": "2025-10-08T19:42:28+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I think it makes sense to move this into a method called \"update_title(state)\" so that this line can just be:\r\n\r\n```\r\n        let mut egui_needs_update = self.update_location_in_toolbar(state) |\r\n            self.update_load_status(state) |\r\n            self.update_status_text(state) |\r\n            self.update_title(state);\r\n```\r\n\r\nThat way `update_title` can also use early returns.",
        "pr_file_module": null
      },
      {
        "comment_id": "2443456044",
        "repo_full_name": "servo/servo",
        "pr_number": 39259,
        "pr_file": "ports/servoshell/desktop/minibrowser.rs",
        "discussion_id": "2414854110",
        "commented_code": "@@ -547,14 +547,34 @@ impl Minibrowser {\n \n     /// Updates all fields taken from the given [WebViewManager], such as the location field.\n     /// Returns true iff the egui needs an update.\n-    pub fn update_webview_data(&mut self, state: &RunningAppState) -> bool {\n+    pub fn update_webview_data(\n+        &mut self,\n+        state: &RunningAppState,\n+        window: Rc<dyn WindowPortsMethods>,\n+    ) -> bool {\n         // Note: We must use the \"bitwise OR\" (|) operator here instead of \"logical OR\" (||)\n         //       because logical OR would short-circuit if any of the functions return true.\n         //       We want to ensure that all functions are called. The \"bitwise OR\" operator\n         //       does not short-circuit.\n-        self.update_location_in_toolbar(state) |\n+        let mut egui_needs_update = self.update_location_in_toolbar(state) |\n             self.update_load_status(state) |\n-            self.update_status_text(state)\n+            self.update_status_text(state);\n+\n+        let changed = if let Some(webview) = state.focused_webview() {\n+            let title = webview\n+                .page_title()\n+                .filter(|t| !t.is_empty())\n+                .map(|t| t.to_string())\n+                .or_else(|| webview.url().map(|u| u.to_string()))\n+                .unwrap_or_else(|| \"Servo\".to_string());\n+\n+            window.set_title_if_changed(&title)\n+        } else {\n+            false\n+        };",
        "comment_created_at": "2025-10-19T19:30:25+00:00",
        "comment_author": "Taym95",
        "comment_body": "Thanks for the review, @mrobinson. I\u2019ve come back to this PR and addressed all comments.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2432212136",
    "pr_number": 39833,
    "pr_file": "components/constellation/constellation.rs",
    "created_at": "2025-10-15T11:29:56+00:00",
    "commented_code": "},\n             Some(browsing_context) => browsing_context.pipeline_id,\n         };\n-        let source_browsing_context = match self.pipelines.get(&source_pipeline) {\n+        let source_webview = match self.pipelines.get(&source_pipeline) {\n             Some(pipeline) => pipeline.webview_id,\n             None => return warn!(\"{}: PostMessage from closed pipeline\", source_pipeline),\n         };\n+\n+        // Step 8.3: Let source be the WindowProxy object corresponding to\n+        // incumbentSettings's global object (a Window object).\n+        // Note: done here to prevent a round-trip to the constellation later,\n+        // and to prevent panic as part of that round-trip\n+        // in the case that the source would already have been closed.\n+        let mut next_iteration_pipeline = source_pipeline;\n+        let mut source_with_ancestry: Vec<BrowsingContextId> = vec![];\n+        loop {\n+            match self\n+                .pipelines\n+                .get(&next_iteration_pipeline)\n+                .and_then(|pipeline| self.browsing_contexts.get(&pipeline.browsing_context_id))\n+                .map(|ctx| (ctx.id, ctx.parent_pipeline_id))\n+            {\n+                Some((bc, Some(parent))) => {\n+                    source_with_ancestry.push(bc);\n+                    next_iteration_pipeline = parent;\n+                    continue;\n+                },\n+                Some((bc, None)) => {\n+                    source_with_ancestry.push(bc);\n+                    break;\n+                },\n+                None => {\n+                    return warn!(\n+                        \"{}: PostMessage from pipeline with closed parent\",\n+                        source_pipeline\n+                    );\n+                },\n+            }\n+        }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2432212136",
        "repo_full_name": "servo/servo",
        "pr_number": 39833,
        "pr_file": "components/constellation/constellation.rs",
        "discussion_id": "2432212136",
        "commented_code": "@@ -4263,14 +4264,46 @@ where\n             },\n             Some(browsing_context) => browsing_context.pipeline_id,\n         };\n-        let source_browsing_context = match self.pipelines.get(&source_pipeline) {\n+        let source_webview = match self.pipelines.get(&source_pipeline) {\n             Some(pipeline) => pipeline.webview_id,\n             None => return warn!(\"{}: PostMessage from closed pipeline\", source_pipeline),\n         };\n+\n+        // Step 8.3: Let source be the WindowProxy object corresponding to\n+        // incumbentSettings's global object (a Window object).\n+        // Note: done here to prevent a round-trip to the constellation later,\n+        // and to prevent panic as part of that round-trip\n+        // in the case that the source would already have been closed.\n+        let mut next_iteration_pipeline = source_pipeline;\n+        let mut source_with_ancestry: Vec<BrowsingContextId> = vec![];\n+        loop {\n+            match self\n+                .pipelines\n+                .get(&next_iteration_pipeline)\n+                .and_then(|pipeline| self.browsing_contexts.get(&pipeline.browsing_context_id))\n+                .map(|ctx| (ctx.id, ctx.parent_pipeline_id))\n+            {\n+                Some((bc, Some(parent))) => {\n+                    source_with_ancestry.push(bc);\n+                    next_iteration_pipeline = parent;\n+                    continue;\n+                },\n+                Some((bc, None)) => {\n+                    source_with_ancestry.push(bc);\n+                    break;\n+                },\n+                None => {\n+                    return warn!(\n+                        \"{}: PostMessage from pipeline with closed parent\",\n+                        source_pipeline\n+                    );\n+                },\n+            }\n+        }",
        "comment_created_at": "2025-10-15T11:29:56+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I think this can be a bit shorter and avoid the use of `loop {}` (which makes reasoning about the terminating condition a bit harder):\r\n\r\n\r\n```rust\r\n\r\n        let browsing_context_for_pipeline = |pipeline_id| {\r\n            self.pipelines\r\n                .get(&pipeline_id)\r\n                .and_then(|pipeline| self.browsing_contexts.get(&pipeline.browsing_context_id))\r\n        };\r\n\r\n        let mut maybe_browsing_context = browsing_context_for_pipeline(source_pipeline);\r\n        if maybe_browsing_context.is_none() {\r\n            return warn!(\"{source_pipeline}: PostMessage from pipeline with closed parent\");\r\n        }\r\n\r\n        let mut source_with_ancestry = vec![];\r\n        while let Some(browsing_context) = maybe_browsing_context {\r\n            source_with_ancestry.push(browsing_context.id);\r\n            maybe_browsing_context = browsing_context\r\n                .parent_pipeline_id\r\n                .and_then(browsing_context_for_pipeline);\r\n        }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1914475585",
    "pr_number": 34960,
    "pr_file": "components/constellation/constellation.rs",
    "created_at": "2025-01-14T09:08:14+00:00",
    "commented_code": "webgpus: HashMap<Host, WebGPU>,\n }\n \n+// Helper macro that returns the pipeline for a given browsing context\n+// or returns after printing a warning.\n+macro_rules! maybe_pipeline {\n+    ($this:ident, $bc_id:ident, $warn_msg:expr) => {\n+        match $this.browsing_contexts.get(&$bc_id) {\n+            Some(ctx) => ctx.pipeline_id,\n+            None => return warn!(\"{}: {}\", $bc_id, $warn_msg),\n+        }\n+    };\n+}\n+\n+// Helper macro that sends a message to the event loop of a given pipeline\n+// or returns after printing a warning.\n+macro_rules! maybe_send {\n+    ($this:ident, $pipeline_id:ident, $msg:expr, $warn_msg:expr) => {\n+        let result = match $this.pipelines.get(&$pipeline_id) {\n+            Some(pipeline) => pipeline.event_loop.send($msg),\n+            None => {\n+                return warn!(\"{}: {}\", $pipeline_id, $warn_msg);\n+            },\n+        };\n+        if let Err(e) = result {\n+            $this.handle_send_error($pipeline_id, e);\n+        }\n+    };\n+}\n+",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "1914475585",
        "repo_full_name": "servo/servo",
        "pr_number": 34960,
        "pr_file": "components/constellation/constellation.rs",
        "discussion_id": "1914475585",
        "commented_code": "@@ -259,6 +259,33 @@ struct BrowsingContextGroup {\n     webgpus: HashMap<Host, WebGPU>,\n }\n \n+// Helper macro that returns the pipeline for a given browsing context\n+// or returns after printing a warning.\n+macro_rules! maybe_pipeline {\n+    ($this:ident, $bc_id:ident, $warn_msg:expr) => {\n+        match $this.browsing_contexts.get(&$bc_id) {\n+            Some(ctx) => ctx.pipeline_id,\n+            None => return warn!(\"{}: {}\", $bc_id, $warn_msg),\n+        }\n+    };\n+}\n+\n+// Helper macro that sends a message to the event loop of a given pipeline\n+// or returns after printing a warning.\n+macro_rules! maybe_send {\n+    ($this:ident, $pipeline_id:ident, $msg:expr, $warn_msg:expr) => {\n+        let result = match $this.pipelines.get(&$pipeline_id) {\n+            Some(pipeline) => pipeline.event_loop.send($msg),\n+            None => {\n+                return warn!(\"{}: {}\", $pipeline_id, $warn_msg);\n+            },\n+        };\n+        if let Err(e) = result {\n+            $this.handle_send_error($pipeline_id, e);\n+        }\n+    };\n+}\n+",
        "comment_created_at": "2025-01-14T09:08:14+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I think we should avoid metaprogramming for these type of helpers. Please remove these or convert them into functions. I think also that `maybe_send` isn't very descriptive of what happens in a failure case. I would call them something like \"send_handling_error\" or something along those lines.",
        "pr_file_module": null
      },
      {
        "comment_id": "1915399196",
        "repo_full_name": "servo/servo",
        "pr_number": 34960,
        "pr_file": "components/constellation/constellation.rs",
        "discussion_id": "1914475585",
        "commented_code": "@@ -259,6 +259,33 @@ struct BrowsingContextGroup {\n     webgpus: HashMap<Host, WebGPU>,\n }\n \n+// Helper macro that returns the pipeline for a given browsing context\n+// or returns after printing a warning.\n+macro_rules! maybe_pipeline {\n+    ($this:ident, $bc_id:ident, $warn_msg:expr) => {\n+        match $this.browsing_contexts.get(&$bc_id) {\n+            Some(ctx) => ctx.pipeline_id,\n+            None => return warn!(\"{}: {}\", $bc_id, $warn_msg),\n+        }\n+    };\n+}\n+\n+// Helper macro that sends a message to the event loop of a given pipeline\n+// or returns after printing a warning.\n+macro_rules! maybe_send {\n+    ($this:ident, $pipeline_id:ident, $msg:expr, $warn_msg:expr) => {\n+        let result = match $this.pipelines.get(&$pipeline_id) {\n+            Some(pipeline) => pipeline.event_loop.send($msg),\n+            None => {\n+                return warn!(\"{}: {}\", $pipeline_id, $warn_msg);\n+            },\n+        };\n+        if let Err(e) = result {\n+            $this.handle_send_error($pipeline_id, e);\n+        }\n+    };\n+}\n+",
        "comment_created_at": "2025-01-14T18:20:51+00:00",
        "comment_author": "webbeef",
        "comment_body": "Converting them into functions makes it tricky to do an early return unless we change the caller signature.\r\nEg. functions returning void would have to return `Option<()>` in order to use `let pipeline_id = self.maybe_pipeline(id)?;` I can do that but that looks a bit strange to me.\r\n\r\nI agree about your naming proposal for `send_handling_error`",
        "pr_file_module": null
      },
      {
        "comment_id": "1923667708",
        "repo_full_name": "servo/servo",
        "pr_number": 34960,
        "pr_file": "components/constellation/constellation.rs",
        "discussion_id": "1914475585",
        "commented_code": "@@ -259,6 +259,33 @@ struct BrowsingContextGroup {\n     webgpus: HashMap<Host, WebGPU>,\n }\n \n+// Helper macro that returns the pipeline for a given browsing context\n+// or returns after printing a warning.\n+macro_rules! maybe_pipeline {\n+    ($this:ident, $bc_id:ident, $warn_msg:expr) => {\n+        match $this.browsing_contexts.get(&$bc_id) {\n+            Some(ctx) => ctx.pipeline_id,\n+            None => return warn!(\"{}: {}\", $bc_id, $warn_msg),\n+        }\n+    };\n+}\n+\n+// Helper macro that sends a message to the event loop of a given pipeline\n+// or returns after printing a warning.\n+macro_rules! maybe_send {\n+    ($this:ident, $pipeline_id:ident, $msg:expr, $warn_msg:expr) => {\n+        let result = match $this.pipelines.get(&$pipeline_id) {\n+            Some(pipeline) => pipeline.event_loop.send($msg),\n+            None => {\n+                return warn!(\"{}: {}\", $pipeline_id, $warn_msg);\n+            },\n+        };\n+        if let Err(e) = result {\n+            $this.handle_send_error($pipeline_id, e);\n+        }\n+    };\n+}\n+",
        "comment_created_at": "2025-01-21T12:46:52+00:00",
        "comment_author": "mrobinson",
        "comment_body": "In order to do an early return, have the function return `false` on failure and include a return statement. Returning from a function in a macro allows us to remove lines of code, but makes it very hard to follow program flow for anyone reading the code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2431719318",
        "repo_full_name": "servo/servo",
        "pr_number": 34960,
        "pr_file": "components/constellation/constellation.rs",
        "discussion_id": "1914475585",
        "commented_code": "@@ -259,6 +259,33 @@ struct BrowsingContextGroup {\n     webgpus: HashMap<Host, WebGPU>,\n }\n \n+// Helper macro that returns the pipeline for a given browsing context\n+// or returns after printing a warning.\n+macro_rules! maybe_pipeline {\n+    ($this:ident, $bc_id:ident, $warn_msg:expr) => {\n+        match $this.browsing_contexts.get(&$bc_id) {\n+            Some(ctx) => ctx.pipeline_id,\n+            None => return warn!(\"{}: {}\", $bc_id, $warn_msg),\n+        }\n+    };\n+}\n+\n+// Helper macro that sends a message to the event loop of a given pipeline\n+// or returns after printing a warning.\n+macro_rules! maybe_send {\n+    ($this:ident, $pipeline_id:ident, $msg:expr, $warn_msg:expr) => {\n+        let result = match $this.pipelines.get(&$pipeline_id) {\n+            Some(pipeline) => pipeline.event_loop.send($msg),\n+            None => {\n+                return warn!(\"{}: {}\", $pipeline_id, $warn_msg);\n+            },\n+        };\n+        if let Err(e) = result {\n+            $this.handle_send_error($pipeline_id, e);\n+        }\n+    };\n+}\n+",
        "comment_created_at": "2025-10-15T08:59:25+00:00",
        "comment_author": "TimvdLippe",
        "comment_body": "@webbeef are you still interested in contributing such a refactoring to use functions or should we close this PR? Reducing code duplications does seem a worthwhile effort to me and I agree with @mrobinson that functions are easier to read at a glance.",
        "pr_file_module": null
      },
      {
        "comment_id": "2433598021",
        "repo_full_name": "servo/servo",
        "pr_number": 34960,
        "pr_file": "components/constellation/constellation.rs",
        "discussion_id": "1914475585",
        "commented_code": "@@ -259,6 +259,33 @@ struct BrowsingContextGroup {\n     webgpus: HashMap<Host, WebGPU>,\n }\n \n+// Helper macro that returns the pipeline for a given browsing context\n+// or returns after printing a warning.\n+macro_rules! maybe_pipeline {\n+    ($this:ident, $bc_id:ident, $warn_msg:expr) => {\n+        match $this.browsing_contexts.get(&$bc_id) {\n+            Some(ctx) => ctx.pipeline_id,\n+            None => return warn!(\"{}: {}\", $bc_id, $warn_msg),\n+        }\n+    };\n+}\n+\n+// Helper macro that sends a message to the event loop of a given pipeline\n+// or returns after printing a warning.\n+macro_rules! maybe_send {\n+    ($this:ident, $pipeline_id:ident, $msg:expr, $warn_msg:expr) => {\n+        let result = match $this.pipelines.get(&$pipeline_id) {\n+            Some(pipeline) => pipeline.event_loop.send($msg),\n+            None => {\n+                return warn!(\"{}: {}\", $pipeline_id, $warn_msg);\n+            },\n+        };\n+        if let Err(e) = result {\n+            $this.handle_send_error($pipeline_id, e);\n+        }\n+    };\n+}\n+",
        "comment_created_at": "2025-10-15T18:40:36+00:00",
        "comment_author": "webbeef",
        "comment_body": "I'm not against revisiting that but I don't think @mrobinson recommendation will help much for the `maybe_pipeline` case. `send_handling_error` looks doable thought.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072697389",
    "pr_number": 36441,
    "pr_file": "components/script/dom/performancetiming.rs",
    "created_at": "2025-05-04T19:51:52+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::Cell;\n+\n+use dom_struct::dom_struct;\n+\n+use crate::dom::bindings::codegen::Bindings::PerformanceTimingBinding::PerformanceTimingMethods;\n+use crate::dom::bindings::reflector::{Reflector, reflect_dom_object};\n+use crate::dom::bindings::root::DomRoot;\n+use crate::dom::globalscope::GlobalScope;\n+use crate::script_runtime::CanGc;\n+\n+#[dom_struct]\n+pub struct PerformanceTiming {\n+    reflector_: Reflector,\n+    navigation_start: Cell<u64>,\n+    unload_event_start: Cell<u64>,\n+    unload_event_end: Cell<u64>,\n+    redirect_start: Cell<u64>,\n+    redirect_end: Cell<u64>,\n+    fetch_start: Cell<u64>,\n+    domain_lookup_start: Cell<u64>,\n+    domain_lookup_end: Cell<u64>,\n+    connect_start: Cell<u64>,\n+    connect_end: Cell<u64>,\n+    secure_connection_start: Cell<u64>,\n+    request_start: Cell<u64>,\n+    response_start: Cell<u64>,\n+    response_end: Cell<u64>,\n+    dom_loading: Cell<u64>,\n+    dom_interactive: Cell<u64>,\n+    dom_content_loaded_event_start: Cell<u64>,\n+    dom_content_loaded_event_end: Cell<u64>,\n+    dom_complete: Cell<u64>,\n+    load_event_start: Cell<u64>,\n+    load_event_end: Cell<u64>,\n+}\n+\n+#[derive(Default)]\n+pub struct PerformanceTimingBuilder {\n+    navigation_start: u64,\n+    unload_event_start: u64,\n+    unload_event_end: u64,\n+    redirect_start: u64,\n+    redirect_end: u64,\n+    fetch_start: u64,\n+    domain_lookup_start: u64,\n+    domain_lookup_end: u64,\n+    connect_start: u64,\n+    connect_end: u64,\n+    secure_connection_start: u64,\n+    request_start: u64,\n+    response_start: u64,\n+    response_end: u64,\n+    dom_loading: u64,\n+    dom_interactive: u64,\n+    dom_content_loaded_event_start: u64,\n+    dom_content_loaded_event_end: u64,\n+    dom_complete: u64,\n+    load_event_start: u64,\n+    load_event_end: u64,\n+}\n+\n+#[allow(dead_code)]\n+impl PerformanceTiming {\n+    pub fn new_inherited(config: PerformanceTimingBuilder) -> PerformanceTiming {\n+        PerformanceTiming {\n+            reflector_: Reflector::new(),\n+            navigation_start: Cell::new(config.navigation_start),\n+            unload_event_start: Cell::new(config.unload_event_start),\n+            unload_event_end: Cell::new(config.unload_event_end),\n+            redirect_start: Cell::new(config.redirect_start),\n+            redirect_end: Cell::new(config.redirect_end),\n+            fetch_start: Cell::new(config.fetch_start),\n+            domain_lookup_start: Cell::new(config.domain_lookup_start),\n+            domain_lookup_end: Cell::new(config.domain_lookup_end),\n+            connect_start: Cell::new(config.connect_start),\n+            connect_end: Cell::new(config.connect_end),\n+            secure_connection_start: Cell::new(config.secure_connection_start),\n+            request_start: Cell::new(config.request_start),\n+            response_start: Cell::new(config.response_start),\n+            response_end: Cell::new(config.response_end),\n+            dom_loading: Cell::new(config.dom_loading),\n+            dom_interactive: Cell::new(config.dom_interactive),\n+            dom_content_loaded_event_start: Cell::new(config.dom_content_loaded_event_start),\n+            dom_content_loaded_event_end: Cell::new(config.dom_content_loaded_event_end),\n+            dom_complete: Cell::new(config.dom_complete),\n+            load_event_start: Cell::new(config.load_event_start),\n+            load_event_end: Cell::new(config.load_event_end),\n+        }\n+    }\n+\n+    pub fn new(global: &GlobalScope, navigation_start: u64) -> DomRoot<PerformanceTiming> {\n+        let config = PerformanceTimingBuilder {\n+            navigation_start,\n+            ..Default::default()\n+        };",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2072697389",
        "repo_full_name": "servo/servo",
        "pr_number": 36441,
        "pr_file": "components/script/dom/performancetiming.rs",
        "discussion_id": "2072697389",
        "commented_code": "@@ -0,0 +1,282 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use std::cell::Cell;\n+\n+use dom_struct::dom_struct;\n+\n+use crate::dom::bindings::codegen::Bindings::PerformanceTimingBinding::PerformanceTimingMethods;\n+use crate::dom::bindings::reflector::{Reflector, reflect_dom_object};\n+use crate::dom::bindings::root::DomRoot;\n+use crate::dom::globalscope::GlobalScope;\n+use crate::script_runtime::CanGc;\n+\n+#[dom_struct]\n+pub struct PerformanceTiming {\n+    reflector_: Reflector,\n+    navigation_start: Cell<u64>,\n+    unload_event_start: Cell<u64>,\n+    unload_event_end: Cell<u64>,\n+    redirect_start: Cell<u64>,\n+    redirect_end: Cell<u64>,\n+    fetch_start: Cell<u64>,\n+    domain_lookup_start: Cell<u64>,\n+    domain_lookup_end: Cell<u64>,\n+    connect_start: Cell<u64>,\n+    connect_end: Cell<u64>,\n+    secure_connection_start: Cell<u64>,\n+    request_start: Cell<u64>,\n+    response_start: Cell<u64>,\n+    response_end: Cell<u64>,\n+    dom_loading: Cell<u64>,\n+    dom_interactive: Cell<u64>,\n+    dom_content_loaded_event_start: Cell<u64>,\n+    dom_content_loaded_event_end: Cell<u64>,\n+    dom_complete: Cell<u64>,\n+    load_event_start: Cell<u64>,\n+    load_event_end: Cell<u64>,\n+}\n+\n+#[derive(Default)]\n+pub struct PerformanceTimingBuilder {\n+    navigation_start: u64,\n+    unload_event_start: u64,\n+    unload_event_end: u64,\n+    redirect_start: u64,\n+    redirect_end: u64,\n+    fetch_start: u64,\n+    domain_lookup_start: u64,\n+    domain_lookup_end: u64,\n+    connect_start: u64,\n+    connect_end: u64,\n+    secure_connection_start: u64,\n+    request_start: u64,\n+    response_start: u64,\n+    response_end: u64,\n+    dom_loading: u64,\n+    dom_interactive: u64,\n+    dom_content_loaded_event_start: u64,\n+    dom_content_loaded_event_end: u64,\n+    dom_complete: u64,\n+    load_event_start: u64,\n+    load_event_end: u64,\n+}\n+\n+#[allow(dead_code)]\n+impl PerformanceTiming {\n+    pub fn new_inherited(config: PerformanceTimingBuilder) -> PerformanceTiming {\n+        PerformanceTiming {\n+            reflector_: Reflector::new(),\n+            navigation_start: Cell::new(config.navigation_start),\n+            unload_event_start: Cell::new(config.unload_event_start),\n+            unload_event_end: Cell::new(config.unload_event_end),\n+            redirect_start: Cell::new(config.redirect_start),\n+            redirect_end: Cell::new(config.redirect_end),\n+            fetch_start: Cell::new(config.fetch_start),\n+            domain_lookup_start: Cell::new(config.domain_lookup_start),\n+            domain_lookup_end: Cell::new(config.domain_lookup_end),\n+            connect_start: Cell::new(config.connect_start),\n+            connect_end: Cell::new(config.connect_end),\n+            secure_connection_start: Cell::new(config.secure_connection_start),\n+            request_start: Cell::new(config.request_start),\n+            response_start: Cell::new(config.response_start),\n+            response_end: Cell::new(config.response_end),\n+            dom_loading: Cell::new(config.dom_loading),\n+            dom_interactive: Cell::new(config.dom_interactive),\n+            dom_content_loaded_event_start: Cell::new(config.dom_content_loaded_event_start),\n+            dom_content_loaded_event_end: Cell::new(config.dom_content_loaded_event_end),\n+            dom_complete: Cell::new(config.dom_complete),\n+            load_event_start: Cell::new(config.load_event_start),\n+            load_event_end: Cell::new(config.load_event_end),\n+        }\n+    }\n+\n+    pub fn new(global: &GlobalScope, navigation_start: u64) -> DomRoot<PerformanceTiming> {\n+        let config = PerformanceTimingBuilder {\n+            navigation_start,\n+            ..Default::default()\n+        };",
        "comment_created_at": "2025-05-04T19:51:52+00:00",
        "comment_author": "jdm",
        "comment_body": "This builder type feels unnecessary right now, since we only pass in one value and there are no other users of it. Can we remove it and just set the field directly?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2427882283",
    "pr_number": 39799,
    "pr_file": "components/script/dom/trustedtypepolicyfactory.rs",
    "created_at": "2025-10-14T04:32:21+00:00",
    "commented_code": "pub(crate) static DEFAULT_SCRIPT_SINK_GROUP: &str = \"'script'\";\n \n-impl Convert<DOMString> for TrustedTypeOrString {\n-    fn convert(self) -> DOMString {\n+impl<'a> Convert<&'a DOMString> for &'a TrustedTypeOrString {\n+    fn convert(self) -> &'a DOMString {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2427882283",
        "repo_full_name": "servo/servo",
        "pr_number": 39799,
        "pr_file": "components/script/dom/trustedtypepolicyfactory.rs",
        "discussion_id": "2427882283",
        "commented_code": "@@ -38,8 +38,8 @@ pub struct TrustedTypePolicyFactory {\n \n pub(crate) static DEFAULT_SCRIPT_SINK_GROUP: &str = \"'script'\";\n \n-impl Convert<DOMString> for TrustedTypeOrString {\n-    fn convert(self) -> DOMString {\n+impl<'a> Convert<&'a DOMString> for &'a TrustedTypeOrString {\n+    fn convert(self) -> &'a DOMString {",
        "comment_created_at": "2025-10-14T04:32:21+00:00",
        "comment_author": "TimvdLippe",
        "comment_body": "Nit: given we always clone the result, let's instead return a DOMString here. That avoids the need to specify lifetime as well and cleans up the caller side.",
        "pr_file_module": null
      },
      {
        "comment_id": "2427990306",
        "repo_full_name": "servo/servo",
        "pr_number": 39799,
        "pr_file": "components/script/dom/trustedtypepolicyfactory.rs",
        "discussion_id": "2427882283",
        "commented_code": "@@ -38,8 +38,8 @@ pub struct TrustedTypePolicyFactory {\n \n pub(crate) static DEFAULT_SCRIPT_SINK_GROUP: &str = \"'script'\";\n \n-impl Convert<DOMString> for TrustedTypeOrString {\n-    fn convert(self) -> DOMString {\n+impl<'a> Convert<&'a DOMString> for &'a TrustedTypeOrString {\n+    fn convert(self) -> &'a DOMString {",
        "comment_created_at": "2025-10-14T05:56:17+00:00",
        "comment_author": "minghuaw",
        "comment_body": "Changed to always clone in eb9a4b2",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2419654285",
    "pr_number": 39767,
    "pr_file": "components/shared/base/id.rs",
    "created_at": "2025-10-10T11:44:18+00:00",
    "commented_code": "impl fmt::Debug for WebViewId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"TopLevel{:?}\", self.0)\n+        write!(f, \"RenderingGroup {}, TopLevel{}\", self.0, self.1)\n     }\n }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2419654285",
        "repo_full_name": "servo/servo",
        "pr_number": 39767,
        "pr_file": "components/shared/base/id.rs",
        "discussion_id": "2419654285",
        "commented_code": "@@ -309,7 +309,7 @@ size_of_test!(Option<WebViewId>, 12);\n \n impl fmt::Debug for WebViewId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"TopLevel{:?}\", self.0)\n+        write!(f, \"RenderingGroup {}, TopLevel{}\", self.0, self.1)\n     }\n }",
        "comment_created_at": "2025-10-10T11:44:18+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I think it would be simpler to just remove this custom `impl` and derive from `Debug` a few lines above as now we are including the entire struct.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2424718566",
    "pr_number": 39741,
    "pr_file": "components/script/dom/windowproxy.rs",
    "created_at": "2025-10-12T18:03:43+00:00",
    "commented_code": "/// <https://html.spec.whatwg.org/multipage/#delaying-load-events-mode>\n     pub(crate) fn stop_delaying_load_events_mode(&self) {\n-        self.delaying_load_events_mode.set(false);\n-        if let Some(document) = self.document() {\n-            if !document.loader().events_inhibited() {\n-                ScriptThread::mark_document_with_no_blocked_loads(&document);\n+        if self.delaying_load_events_mode.replace(false) {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2424718566",
        "repo_full_name": "servo/servo",
        "pr_number": 39741,
        "pr_file": "components/script/dom/windowproxy.rs",
        "discussion_id": "2424718566",
        "commented_code": "@@ -387,10 +387,11 @@ impl WindowProxy {\n \n     /// <https://html.spec.whatwg.org/multipage/#delaying-load-events-mode>\n     pub(crate) fn stop_delaying_load_events_mode(&self) {\n-        self.delaying_load_events_mode.set(false);\n-        if let Some(document) = self.document() {\n-            if !document.loader().events_inhibited() {\n-                ScriptThread::mark_document_with_no_blocked_loads(&document);\n+        if self.delaying_load_events_mode.replace(false) {",
        "comment_created_at": "2025-10-12T18:03:43+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Do you mind using an early return here? I think three levels of indentation makes this a bit hard to read.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2409442038",
    "pr_number": 39681,
    "pr_file": "components/fonts/platform/freetype/font.rs",
    "created_at": "2025-10-07T05:50:40+00:00",
    "commented_code": "return Err(\"Could not memory map\");\n         };\n \n-        // Variable fonts, where the font designer has provided one or more axes of\n-        // variation do not count as font synthesis and their use is not affected by\n+        // If the font face is already bold, applying synthetic bold would \"double embolden\" the font\n+        let table_provider_data = FreeTypeFaceTableProviderData::Local(\n+            Arc::new(memory_mapped_font_data),\n+            font_identifier.index(),\n+        );\n+        let face_is_bold = table_provider_data\n+            .font_ref()\n+            .and_then(|font_ref| font_ref.os2())\n+            .is_ok_and(|table| table.us_weight_class() >= SEMI_BOLD_U16);\n+\n+        // Variable fonts do not count as font synthesis and their use is not affected by\n         // the font-synthesis property.\n         //\n         // <https://www.w3.org/TR/css-fonts-4/#font-synthesis-intro>\n-        if FT_HAS_MULTIPLE_MASTERS(face.as_ptr()) {\n-            synthetic_bold = false;\n-        }\n+        let is_variable_font = FT_HAS_MULTIPLE_MASTERS(face.as_ptr());\n+\n+        let synthetic_bold = if face_is_bold || is_variable_font {\n+            false\n+        } else {\n+            synthetic_bold\n+        };",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2409442038",
        "repo_full_name": "servo/servo",
        "pr_number": 39681,
        "pr_file": "components/fonts/platform/freetype/font.rs",
        "discussion_id": "2409442038",
        "commented_code": "@@ -128,23 +131,33 @@ impl PlatformFontMethods for PlatformFont {\n             return Err(\"Could not memory map\");\n         };\n \n-        // Variable fonts, where the font designer has provided one or more axes of\n-        // variation do not count as font synthesis and their use is not affected by\n+        // If the font face is already bold, applying synthetic bold would \"double embolden\" the font\n+        let table_provider_data = FreeTypeFaceTableProviderData::Local(\n+            Arc::new(memory_mapped_font_data),\n+            font_identifier.index(),\n+        );\n+        let face_is_bold = table_provider_data\n+            .font_ref()\n+            .and_then(|font_ref| font_ref.os2())\n+            .is_ok_and(|table| table.us_weight_class() >= SEMI_BOLD_U16);\n+\n+        // Variable fonts do not count as font synthesis and their use is not affected by\n         // the font-synthesis property.\n         //\n         // <https://www.w3.org/TR/css-fonts-4/#font-synthesis-intro>\n-        if FT_HAS_MULTIPLE_MASTERS(face.as_ptr()) {\n-            synthetic_bold = false;\n-        }\n+        let is_variable_font = FT_HAS_MULTIPLE_MASTERS(face.as_ptr());\n+\n+        let synthetic_bold = if face_is_bold || is_variable_font {\n+            false\n+        } else {\n+            synthetic_bold\n+        };",
        "comment_created_at": "2025-10-07T05:50:40+00:00",
        "comment_author": "mrobinson",
        "comment_body": "I think this is easier to understand as a single statement.\r\n```suggestion\r\n        let synthetic_bold = !face_is_bold && !is_variable_font && synthetic_bold;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2028067233",
    "pr_number": 36304,
    "pr_file": "components/net/resource_thread.rs",
    "created_at": "2025-04-04T04:24:41+00:00",
    "commented_code": "}\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);\n+    }\n+}\n+\n+pub fn read_jsonl_file<T>(config_dir: &Path, filename: &str) -> Vec<T>\n+where\n+    T: for<'de> Deserialize<'de>,\n+{\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    let jsonl_iter = match json_lines::<T, _>(&path) {\n+        Ok(jsonl_iter) => jsonl_iter,\n+        Err(why) => {\n+            warn!(\"couldn't open {}: {}\", display, why);\n+            return Vec::new();\n+        },\n+    };\n+    let mut data_from_jsonl = Vec::new();\n+    for jsonl_item in jsonl_iter {\n+        match jsonl_item {\n+            Ok(jsonl_item) => data_from_jsonl.push(jsonl_item),\n+            Err(why) => warn!(\"Error when reading {}: {}\", display, why),\n+        }\n+    }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2028067233",
        "repo_full_name": "servo/servo",
        "pr_number": 36304,
        "pr_file": "components/net/resource_thread.rs",
        "discussion_id": "2028067233",
        "commented_code": "@@ -474,6 +475,49 @@ impl ResourceChannelManager {\n     }\n }\n \n+pub fn create_or_clear_file(config_dir: &Path, filename: &str) {\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    if let Err(why) = File::create(&path) {\n+        panic!(\"Fail to create {}: {}\", display, why);\n+    }\n+}\n+\n+pub fn read_jsonl_file<T>(config_dir: &Path, filename: &str) -> Vec<T>\n+where\n+    T: for<'de> Deserialize<'de>,\n+{\n+    let path = config_dir.join(filename);\n+    let display = path.display();\n+    let jsonl_iter = match json_lines::<T, _>(&path) {\n+        Ok(jsonl_iter) => jsonl_iter,\n+        Err(why) => {\n+            warn!(\"couldn't open {}: {}\", display, why);\n+            return Vec::new();\n+        },\n+    };\n+    let mut data_from_jsonl = Vec::new();\n+    for jsonl_item in jsonl_iter {\n+        match jsonl_item {\n+            Ok(jsonl_item) => data_from_jsonl.push(jsonl_item),\n+            Err(why) => warn!(\"Error when reading {}: {}\", display, why),\n+        }\n+    }",
        "comment_created_at": "2025-04-04T04:24:41+00:00",
        "comment_author": "webbeef",
        "comment_body": "You should be able to use `filter_map()` and `collect()` on `jsonl_iter` directly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284799639",
    "pr_number": 38754,
    "pr_file": "components/script/dom/element.rs",
    "created_at": "2025-08-19T10:16:50+00:00",
    "commented_code": "}\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {\n+            let ancestor = ancestor.downcast::<Element>().unwrap();\n+            // Walk up the DOM from self to find if ancestor is in the containing block chain\n+            let mut current_node = Some(DomRoot::from_ref(self.upcast::<Node>()));\n+\n+            while let Some(node) = current_node {\n+                if let Some(element) = node.downcast::<Element>() {\n+                    // If we reached the ancestor, it's in the containing block chain\n+                    if std::ptr::eq(element, ancestor) {\n+                        return true;\n+                    }\n+\n+                    // Check if this element establishes a new containing block\n+                    if let Some(style) = element.style() {\n+                        let position = style.get_box().clone_position();\n+\n+                        // If this element is absolutely or fixed positioned,\n+                        // it establishes a new containing block - stop here\n+                        if position.is_absolutely_positioned() && !std::ptr::eq(element, self) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                // Move to parent\n+                current_node = node.GetParentElement().map(DomRoot::upcast);\n+            }\n+\n+            false\n+        } else {\n+            false\n+        }\n+    }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2284799639",
        "repo_full_name": "servo/servo",
        "pr_number": 38754,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2284799639",
        "commented_code": "@@ -998,14 +1001,71 @@ impl Element {\n         }\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {\n+            let ancestor = ancestor.downcast::<Element>().unwrap();\n+            // Walk up the DOM from self to find if ancestor is in the containing block chain\n+            let mut current_node = Some(DomRoot::from_ref(self.upcast::<Node>()));\n+\n+            while let Some(node) = current_node {\n+                if let Some(element) = node.downcast::<Element>() {\n+                    // If we reached the ancestor, it's in the containing block chain\n+                    if std::ptr::eq(element, ancestor) {\n+                        return true;\n+                    }\n+\n+                    // Check if this element establishes a new containing block\n+                    if let Some(style) = element.style() {\n+                        let position = style.get_box().clone_position();\n+\n+                        // If this element is absolutely or fixed positioned,\n+                        // it establishes a new containing block - stop here\n+                        if position.is_absolutely_positioned() && !std::ptr::eq(element, self) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                // Move to parent\n+                current_node = node.GetParentElement().map(DomRoot::upcast);\n+            }\n+\n+            false\n+        } else {\n+            false\n+        }\n+    }",
        "comment_created_at": "2025-08-19T10:16:50+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please use an early return at the top of the function instead of the large nested block.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284807701",
    "pr_number": 38754,
    "pr_file": "components/script/dom/element.rs",
    "created_at": "2025-08-19T10:20:37+00:00",
    "commented_code": "}\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {\n+            let ancestor = ancestor.downcast::<Element>().unwrap();\n+            // Walk up the DOM from self to find if ancestor is in the containing block chain\n+            let mut current_node = Some(DomRoot::from_ref(self.upcast::<Node>()));\n+\n+            while let Some(node) = current_node {\n+                if let Some(element) = node.downcast::<Element>() {\n+                    // If we reached the ancestor, it's in the containing block chain\n+                    if std::ptr::eq(element, ancestor) {\n+                        return true;\n+                    }\n+\n+                    // Check if this element establishes a new containing block\n+                    if let Some(style) = element.style() {\n+                        let position = style.get_box().clone_position();\n+\n+                        // If this element is absolutely or fixed positioned,\n+                        // it establishes a new containing block - stop here\n+                        if position.is_absolutely_positioned() && !std::ptr::eq(element, self) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                // Move to parent\n+                current_node = node.GetParentElement().map(DomRoot::upcast);\n+            }\n+\n+            false\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// <https://drafts.csswg.org/cssom-view/#element-scrolling-members>\n     fn determine_scroll_into_view_position(\n         &self,\n         scrolling_node: &Node,\n         block: ScrollLogicalPosition,\n         inline: ScrollLogicalPosition,\n     ) -> ScrollPosition {\n-        let target_bounding_box = self.upcast::<Node>().content_box().unwrap_or_default();\n+        // Get the target element's stable position using offset properties\n+        let target_bounding_box = if let Some(html_element) = self.downcast::<HTMLElement>() {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2284807701",
        "repo_full_name": "servo/servo",
        "pr_number": 38754,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2284807701",
        "commented_code": "@@ -998,14 +1001,71 @@ impl Element {\n         }\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {\n+            let ancestor = ancestor.downcast::<Element>().unwrap();\n+            // Walk up the DOM from self to find if ancestor is in the containing block chain\n+            let mut current_node = Some(DomRoot::from_ref(self.upcast::<Node>()));\n+\n+            while let Some(node) = current_node {\n+                if let Some(element) = node.downcast::<Element>() {\n+                    // If we reached the ancestor, it's in the containing block chain\n+                    if std::ptr::eq(element, ancestor) {\n+                        return true;\n+                    }\n+\n+                    // Check if this element establishes a new containing block\n+                    if let Some(style) = element.style() {\n+                        let position = style.get_box().clone_position();\n+\n+                        // If this element is absolutely or fixed positioned,\n+                        // it establishes a new containing block - stop here\n+                        if position.is_absolutely_positioned() && !std::ptr::eq(element, self) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                // Move to parent\n+                current_node = node.GetParentElement().map(DomRoot::upcast);\n+            }\n+\n+            false\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// <https://drafts.csswg.org/cssom-view/#element-scrolling-members>\n     fn determine_scroll_into_view_position(\n         &self,\n         scrolling_node: &Node,\n         block: ScrollLogicalPosition,\n         inline: ScrollLogicalPosition,\n     ) -> ScrollPosition {\n-        let target_bounding_box = self.upcast::<Node>().content_box().unwrap_or_default();\n+        // Get the target element's stable position using offset properties\n+        let target_bounding_box = if let Some(html_element) = self.downcast::<HTMLElement>() {",
        "comment_created_at": "2025-08-19T10:20:37+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please use a `map()` here with `unwrap_or_else` below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284742543",
    "pr_number": 38773,
    "pr_file": "components/script/dom/element.rs",
    "created_at": "2025-08-19T09:53:56+00:00",
    "commented_code": "}\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2284742543",
        "repo_full_name": "servo/servo",
        "pr_number": 38773,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2284742543",
        "commented_code": "@@ -998,14 +1001,71 @@ impl Element {\n         }\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {",
        "comment_created_at": "2025-08-19T09:53:56+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please use an early return here instead of a bit nested if statement.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284743161",
    "pr_number": 38773,
    "pr_file": "components/script/dom/element.rs",
    "created_at": "2025-08-19T09:54:13+00:00",
    "commented_code": "}\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {\n+            let ancestor = ancestor.downcast::<Element>().unwrap();\n+            // Walk up the DOM from self to find if ancestor is in the containing block chain\n+            let mut current_node = Some(DomRoot::from_ref(self.upcast::<Node>()));\n+\n+            while let Some(node) = current_node {\n+                if let Some(element) = node.downcast::<Element>() {\n+                    // If we reached the ancestor, it's in the containing block chain\n+                    if std::ptr::eq(element, ancestor) {\n+                        return true;\n+                    }\n+\n+                    // Check if this element establishes a new containing block\n+                    if let Some(style) = element.style() {\n+                        let position = style.get_box().clone_position();\n+\n+                        // If this element is absolutely or fixed positioned,\n+                        // it establishes a new containing block - stop here\n+                        if position.is_absolutely_positioned() && !std::ptr::eq(element, self) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                // Move to parent\n+                current_node = node.GetParentElement().map(DomRoot::upcast);\n+            }\n+\n+            false\n+        } else {\n+            false\n+        }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2284743161",
        "repo_full_name": "servo/servo",
        "pr_number": 38773,
        "pr_file": "components/script/dom/element.rs",
        "discussion_id": "2284743161",
        "commented_code": "@@ -998,14 +1001,71 @@ impl Element {\n         }\n     }\n \n+    /// Check if an element is in the containing block chain for scrollIntoView\n+    /// Only elements in the containing block chain should be scrolled by scrollIntoView\n+    fn is_in_containing_block_chain(&self, ancestor: &Node) -> bool {\n+        if ancestor.is::<Document>() {\n+            true // Document viewport is always in the containing block chain\n+        } else if ancestor.is::<Element>() {\n+            let ancestor = ancestor.downcast::<Element>().unwrap();\n+            // Walk up the DOM from self to find if ancestor is in the containing block chain\n+            let mut current_node = Some(DomRoot::from_ref(self.upcast::<Node>()));\n+\n+            while let Some(node) = current_node {\n+                if let Some(element) = node.downcast::<Element>() {\n+                    // If we reached the ancestor, it's in the containing block chain\n+                    if std::ptr::eq(element, ancestor) {\n+                        return true;\n+                    }\n+\n+                    // Check if this element establishes a new containing block\n+                    if let Some(style) = element.style() {\n+                        let position = style.get_box().clone_position();\n+\n+                        // If this element is absolutely or fixed positioned,\n+                        // it establishes a new containing block - stop here\n+                        if position.is_absolutely_positioned() && !std::ptr::eq(element, self) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+\n+                // Move to parent\n+                current_node = node.GetParentElement().map(DomRoot::upcast);\n+            }\n+\n+            false\n+        } else {\n+            false\n+        }",
        "comment_created_at": "2025-08-19T09:54:13+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Please use an early return at the top of the function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2363491995",
    "pr_number": 39394,
    "pr_file": "components/script/dom/bindings/error.rs",
    "created_at": "2025-09-19T16:14:06+00:00",
    "commented_code": ") -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2363491995",
        "repo_full_name": "servo/servo",
        "pr_number": 39394,
        "pr_file": "components/script/dom/bindings/error.rs",
        "discussion_id": "2363491995",
        "commented_code": "@@ -101,7 +101,15 @@ pub(crate) fn create_dom_exception(\n ) -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
        "comment_created_at": "2025-09-19T16:14:06+00:00",
        "comment_author": "Taym95",
        "comment_body": "this looks like a copy of `Error::Syntax(Some(custom_message))` with DOMErrorName diff, can we create macro or helper to improve this code duplication? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2365803876",
        "repo_full_name": "servo/servo",
        "pr_number": 39394,
        "pr_file": "components/script/dom/bindings/error.rs",
        "discussion_id": "2363491995",
        "commented_code": "@@ -101,7 +101,15 @@ pub(crate) fn create_dom_exception(\n ) -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
        "comment_created_at": "2025-09-20T20:21:44+00:00",
        "comment_author": "rodio",
        "comment_body": "You mean something like this?\r\n```\r\npub(crate) fn create_dom_exception(\r\n    global: &GlobalScope,\r\n    result: Error,\r\n    can_gc: CanGc,\r\n) -> Result<DomRoot<DOMException>, JsEngineError> {\r\n    macro_rules! return_custom_exception {\r\n        ($dom_error_name:expr, $custom_message:ident) => {\r\n            return Ok(DOMException::new_with_custom_message(\r\n                global,\r\n                $dom_error_name,\r\n                $custom_message,\r\n                can_gc,\r\n            ));\r\n        };\r\n    }\r\n\r\n    let code = match result {\r\n        Error::IndexSize => DOMErrorName::IndexSizeError,\r\n        Error::NotFound(Some(custom_message)) => {\r\n            return_custom_exception!(DOMErrorName::NotFoundError, custom_message);\r\n        },\r\n        Error::NotFound(None) => DOMErrorName::NotFoundError,\r\n.........\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2365959652",
        "repo_full_name": "servo/servo",
        "pr_number": 39394,
        "pr_file": "components/script/dom/bindings/error.rs",
        "discussion_id": "2363491995",
        "commented_code": "@@ -101,7 +101,15 @@ pub(crate) fn create_dom_exception(\n ) -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
        "comment_created_at": "2025-09-21T05:44:38+00:00",
        "comment_author": "arihant2math",
        "comment_body": "Could you turn this into a function instead? There isn't any macro-specific functionality being used here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2366111411",
        "repo_full_name": "servo/servo",
        "pr_number": 39394,
        "pr_file": "components/script/dom/bindings/error.rs",
        "discussion_id": "2363491995",
        "commented_code": "@@ -101,7 +101,15 @@ pub(crate) fn create_dom_exception(\n ) -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
        "comment_created_at": "2025-09-21T08:44:49+00:00",
        "comment_author": "rodio",
        "comment_body": "Thanks for the suggestion! Please check the latest commit whenever you have time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2366307956",
        "repo_full_name": "servo/servo",
        "pr_number": 39394,
        "pr_file": "components/script/dom/bindings/error.rs",
        "discussion_id": "2363491995",
        "commented_code": "@@ -101,7 +101,15 @@ pub(crate) fn create_dom_exception(\n ) -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
        "comment_created_at": "2025-09-21T16:55:53+00:00",
        "comment_author": "arihant2math",
        "comment_body": "LGTM, thank you!",
        "pr_file_module": null
      },
      {
        "comment_id": "2378531058",
        "repo_full_name": "servo/servo",
        "pr_number": 39394,
        "pr_file": "components/script/dom/bindings/error.rs",
        "discussion_id": "2363491995",
        "commented_code": "@@ -101,7 +101,15 @@ pub(crate) fn create_dom_exception(\n ) -> Result<DomRoot<DOMException>, JsEngineError> {\n     let code = match result {\n         Error::IndexSize => DOMErrorName::IndexSizeError,\n-        Error::NotFound => DOMErrorName::NotFoundError,\n+        Error::NotFound(Some(custom_message)) => {",
        "comment_created_at": "2025-09-25T10:07:34+00:00",
        "comment_author": "sagudev",
        "comment_body": "I think we should just make match return `(code, maybe_message)`, but we can do this in follow up.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2259569241",
    "pr_number": 38041,
    "pr_file": "components/compositing/largest_contentful_paint.rs",
    "created_at": "2025-08-07T08:38:48+00:00",
    "commented_code": "+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use compositing_traits::largest_contentful_paint_candidate::{\n+    LCPCandidate, LargestContentfulPaint,\n+};\n+use fnv::{FnvBuildHasher, FnvHashMap};\n+use webrender_api::{Epoch, PipelineId};\n+\n+/// Holds the [`LargestContentfulPaintCalculator`] for each pipeline.\n+#[derive(Default)]\n+pub(crate) struct LargestContentfulPaintDetector {\n+    lcp_calculators: FnvHashMap<PipelineId, LargestContentfulPaintCalculator>,\n+}\n+\n+impl LargestContentfulPaintDetector {\n+    pub const fn new() -> Self {\n+        Self {\n+            lcp_calculators: FnvHashMap::with_hasher(FnvBuildHasher::new()),\n+        }\n+    }\n+\n+    pub fn append_lcp_candidate(&mut self, pipeline_id: PipelineId, candidate: LCPCandidate) {\n+        self.lcp_calculators\n+            .entry(pipeline_id)\n+            .and_modify(|calculator| calculator.lcp_candidates.push(candidate))\n+            .or_insert(LargestContentfulPaintCalculator {\n+                lcp_candidates: vec![candidate],\n+                latest_lcp: None,\n+            });\n+    }\n+\n+    pub fn calculate_largest_contentful_paint(\n+        &mut self,\n+        paint_time: CrossProcessInstant,\n+        cur_epoch: Epoch,\n+        pipeline_id: PipelineId,\n+    ) -> Option<LargestContentfulPaint> {\n+        match self.lcp_calculators.get_mut(&pipeline_id) {\n+            Some(lcp_calculator) => {\n+                lcp_calculator.calculate_largest_contentful_paint(paint_time, cur_epoch)\n+            },\n+\n+            None => None,\n+        }\n+    }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2259569241",
        "repo_full_name": "servo/servo",
        "pr_number": 38041,
        "pr_file": "components/compositing/largest_contentful_paint.rs",
        "discussion_id": "2259569241",
        "commented_code": "@@ -0,0 +1,88 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use compositing_traits::largest_contentful_paint_candidate::{\n+    LCPCandidate, LargestContentfulPaint,\n+};\n+use fnv::{FnvBuildHasher, FnvHashMap};\n+use webrender_api::{Epoch, PipelineId};\n+\n+/// Holds the [`LargestContentfulPaintCalculator`] for each pipeline.\n+#[derive(Default)]\n+pub(crate) struct LargestContentfulPaintDetector {\n+    lcp_calculators: FnvHashMap<PipelineId, LargestContentfulPaintCalculator>,\n+}\n+\n+impl LargestContentfulPaintDetector {\n+    pub const fn new() -> Self {\n+        Self {\n+            lcp_calculators: FnvHashMap::with_hasher(FnvBuildHasher::new()),\n+        }\n+    }\n+\n+    pub fn append_lcp_candidate(&mut self, pipeline_id: PipelineId, candidate: LCPCandidate) {\n+        self.lcp_calculators\n+            .entry(pipeline_id)\n+            .and_modify(|calculator| calculator.lcp_candidates.push(candidate))\n+            .or_insert(LargestContentfulPaintCalculator {\n+                lcp_candidates: vec![candidate],\n+                latest_lcp: None,\n+            });\n+    }\n+\n+    pub fn calculate_largest_contentful_paint(\n+        &mut self,\n+        paint_time: CrossProcessInstant,\n+        cur_epoch: Epoch,\n+        pipeline_id: PipelineId,\n+    ) -> Option<LargestContentfulPaint> {\n+        match self.lcp_calculators.get_mut(&pipeline_id) {\n+            Some(lcp_calculator) => {\n+                lcp_calculator.calculate_largest_contentful_paint(paint_time, cur_epoch)\n+            },\n+\n+            None => None,\n+        }\n+    }",
        "comment_created_at": "2025-08-07T08:38:48+00:00",
        "comment_author": "mrobinson",
        "comment_body": "This can be written more idiomatically with `map`:\r\n\r\n```suggestion\r\n        self.lcp_calculators.get_mut(&pipeline_id)\r\n            .map(|lcp_calculator| cp_calculator.calculate_largest_contentful_paint(paint_time, cur_epoch))\r\n    }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2366647056",
        "repo_full_name": "servo/servo",
        "pr_number": 38041,
        "pr_file": "components/compositing/largest_contentful_paint.rs",
        "discussion_id": "2259569241",
        "commented_code": "@@ -0,0 +1,88 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n+\n+use base::cross_process_instant::CrossProcessInstant;\n+use compositing_traits::largest_contentful_paint_candidate::{\n+    LCPCandidate, LargestContentfulPaint,\n+};\n+use fnv::{FnvBuildHasher, FnvHashMap};\n+use webrender_api::{Epoch, PipelineId};\n+\n+/// Holds the [`LargestContentfulPaintCalculator`] for each pipeline.\n+#[derive(Default)]\n+pub(crate) struct LargestContentfulPaintDetector {\n+    lcp_calculators: FnvHashMap<PipelineId, LargestContentfulPaintCalculator>,\n+}\n+\n+impl LargestContentfulPaintDetector {\n+    pub const fn new() -> Self {\n+        Self {\n+            lcp_calculators: FnvHashMap::with_hasher(FnvBuildHasher::new()),\n+        }\n+    }\n+\n+    pub fn append_lcp_candidate(&mut self, pipeline_id: PipelineId, candidate: LCPCandidate) {\n+        self.lcp_calculators\n+            .entry(pipeline_id)\n+            .and_modify(|calculator| calculator.lcp_candidates.push(candidate))\n+            .or_insert(LargestContentfulPaintCalculator {\n+                lcp_candidates: vec![candidate],\n+                latest_lcp: None,\n+            });\n+    }\n+\n+    pub fn calculate_largest_contentful_paint(\n+        &mut self,\n+        paint_time: CrossProcessInstant,\n+        cur_epoch: Epoch,\n+        pipeline_id: PipelineId,\n+    ) -> Option<LargestContentfulPaint> {\n+        match self.lcp_calculators.get_mut(&pipeline_id) {\n+            Some(lcp_calculator) => {\n+                lcp_calculator.calculate_largest_contentful_paint(paint_time, cur_epoch)\n+            },\n+\n+            None => None,\n+        }\n+    }",
        "comment_created_at": "2025-09-22T03:35:51+00:00",
        "comment_author": "shubhamg13",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2342362367",
    "pr_number": 39230,
    "pr_file": "components/layout/flow/inline/mod.rs",
    "created_at": "2025-09-11T21:18:20+00:00",
    "commented_code": ");\n                 self.depends_on_block_constraints |= depends_on_block_constraints;\n \n-                if !inline_formatting_context\n-                    .next_character_prevents_soft_wrap_opportunity(*offset_in_text)\n+                // TODO: need to handle TextWrapMode::Nowrap.\n+                if self.had_content_yet_for_min_content &&\n+                    !inline_formatting_context\n+                        .previous_character_prevents_soft_wrap_opportunity(*offset_in_text)\n                 {\n                     self.line_break_opportunity();\n                 }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2342362367",
        "repo_full_name": "servo/servo",
        "pr_number": 39230,
        "pr_file": "components/layout/flow/inline/mod.rs",
        "discussion_id": "2342362367",
        "commented_code": "@@ -2497,14 +2499,23 @@ impl<'layout_data> ContentSizesComputation<'layout_data> {\n                 );\n                 self.depends_on_block_constraints |= depends_on_block_constraints;\n \n-                if !inline_formatting_context\n-                    .next_character_prevents_soft_wrap_opportunity(*offset_in_text)\n+                // TODO: need to handle TextWrapMode::Nowrap.\n+                if self.had_content_yet_for_min_content &&\n+                    !inline_formatting_context\n+                        .previous_character_prevents_soft_wrap_opportunity(*offset_in_text)\n                 {\n                     self.line_break_opportunity();\n                 }",
        "comment_created_at": "2025-09-11T21:18:20+00:00",
        "comment_author": "mrobinson",
        "comment_body": "Any reason not to put the check for `had_content_yet_for_min_content` into `fn line_break_opportunity` and return early?",
        "pr_file_module": null
      },
      {
        "comment_id": "2342425918",
        "repo_full_name": "servo/servo",
        "pr_number": 39230,
        "pr_file": "components/layout/flow/inline/mod.rs",
        "discussion_id": "2342362367",
        "commented_code": "@@ -2497,14 +2499,23 @@ impl<'layout_data> ContentSizesComputation<'layout_data> {\n                 );\n                 self.depends_on_block_constraints |= depends_on_block_constraints;\n \n-                if !inline_formatting_context\n-                    .next_character_prevents_soft_wrap_opportunity(*offset_in_text)\n+                // TODO: need to handle TextWrapMode::Nowrap.\n+                if self.had_content_yet_for_min_content &&\n+                    !inline_formatting_context\n+                        .previous_character_prevents_soft_wrap_opportunity(*offset_in_text)\n                 {\n                     self.line_break_opportunity();\n                 }",
        "comment_created_at": "2025-09-11T21:56:38+00:00",
        "comment_author": "Loirooriol",
        "comment_body": "Because `forced_line_break()`  calls `line_break_opportunity()` and shouldn't check this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2295516583",
    "pr_number": 38738,
    "pr_file": "components/script/dom/idbobjectstore.rs",
    "created_at": "2025-08-23T09:12:24+00:00",
    "commented_code": "}\n \n     // https://www.w3.org/TR/IndexedDB-2/#dom-idbobjectstore-keypath\n-    // fn KeyPath(&self, _cx: SafeJSContext, _val: MutableHandleValue) {\n-    //     unimplemented!();\n-    // }\n+    fn KeyPath(&self, cx: SafeJSContext, mut ret_val: MutableHandleValue) {\n+        if let Some(key_path) = &self.key_path {\n+            match key_path {\n+                KeyPath::String(path) => {\n+                    path.safe_to_jsval(cx, ret_val);\n+                },\n+                KeyPath::StringSequence(paths) => {\n+                    paths.safe_to_jsval(cx, ret_val);\n+                },\n+            }\n+        } else {\n+            ret_val.set(NullValue());\n+        }\n+    }",
    "repo_full_name": "servo/servo",
    "discussion_comments": [
      {
        "comment_id": "2295516583",
        "repo_full_name": "servo/servo",
        "pr_number": 38738,
        "pr_file": "components/script/dom/idbobjectstore.rs",
        "discussion_id": "2295516583",
        "commented_code": "@@ -494,14 +464,25 @@ impl IDBObjectStoreMethods<crate::DomTypeHolder> for IDBObjectStore {\n     }\n \n     // https://www.w3.org/TR/IndexedDB-2/#dom-idbobjectstore-keypath\n-    // fn KeyPath(&self, _cx: SafeJSContext, _val: MutableHandleValue) {\n-    //     unimplemented!();\n-    // }\n+    fn KeyPath(&self, cx: SafeJSContext, mut ret_val: MutableHandleValue) {\n+        if let Some(key_path) = &self.key_path {\n+            match key_path {\n+                KeyPath::String(path) => {\n+                    path.safe_to_jsval(cx, ret_val);\n+                },\n+                KeyPath::StringSequence(paths) => {\n+                    paths.safe_to_jsval(cx, ret_val);\n+                },\n+            }\n+        } else {\n+            ret_val.set(NullValue());\n+        }\n+    }",
        "comment_created_at": "2025-08-23T09:12:24+00:00",
        "comment_author": "mrobinson",
        "comment_body": "This can be simplified:\r\n\r\n```suggestion\r\n    fn KeyPath(&self, cx: SafeJSContext, mut ret_val: MutableHandleValue) {\r\n       match &self.key_path {\r\n           Some(KeyPath::String(path)) =>  path.safe_to_jsval(cx, ret_val),\r\n           Some(KeyPath::StringSequence(paths)) => paths.safe_to_jsval(cx, ret_val),\r\n           None => ret_val.set(NullValue()),\r\n       }\r\n    }\r\n```",
        "pr_file_module": null
      }
    ]
  }
]