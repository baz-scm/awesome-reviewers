[
  {
    "discussion_id": "2159409926",
    "pr_number": 8308,
    "pr_file": "ee/query-service/app/server.go",
    "created_at": "2025-06-20T17:18:05+00:00",
    "commented_code": "Jwt                        *authtypes.JWT\n }\n \n-// Server runs HTTP api service\n+// Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *baserules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *baserules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n+\n+\topampServer *opamp.Server\n \n \t// Usage manager\n \tusageManager *usage.Manager\n \n-\topampServer *opamp.Server\n-\n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\tgatewayProxy, err := gateway.NewProxy(serverOptions.GatewayUrl, gateway.RoutePrefix)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tgatewayProxy, err := gateway.NewProxy(config.Gateway.URL.String(), gateway.RoutePrefix)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\treader := db.NewDataConnector(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\treader := clickhouseReader.NewReader(\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2159409926",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8308,
        "pr_file": "ee/query-service/app/server.go",
        "discussion_id": "2159409926",
        "commented_code": "@@ -58,78 +57,72 @@ type ServerOptions struct {\n \tJwt                        *authtypes.JWT\n }\n \n-// Server runs HTTP api service\n+// Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *baserules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *baserules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n+\n+\topampServer *opamp.Server\n \n \t// Usage manager\n \tusageManager *usage.Manager\n \n-\topampServer *opamp.Server\n-\n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\tgatewayProxy, err := gateway.NewProxy(serverOptions.GatewayUrl, gateway.RoutePrefix)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tgatewayProxy, err := gateway.NewProxy(config.Gateway.URL.String(), gateway.RoutePrefix)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\treader := db.NewDataConnector(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\treader := clickhouseReader.NewReader(\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,",
        "comment_created_at": "2025-06-20T17:18:05+00:00",
        "comment_author": "srikanthccv",
        "comment_body": "trying to combine the separate flux intervals into one?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159494702",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8308,
        "pr_file": "ee/query-service/app/server.go",
        "discussion_id": "2159409926",
        "commented_code": "@@ -58,78 +57,72 @@ type ServerOptions struct {\n \tJwt                        *authtypes.JWT\n }\n \n-// Server runs HTTP api service\n+// Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *baserules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *baserules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n+\n+\topampServer *opamp.Server\n \n \t// Usage manager\n \tusageManager *usage.Manager\n \n-\topampServer *opamp.Server\n-\n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\tgatewayProxy, err := gateway.NewProxy(serverOptions.GatewayUrl, gateway.RoutePrefix)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tgatewayProxy, err := gateway.NewProxy(config.Gateway.URL.String(), gateway.RoutePrefix)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\treader := db.NewDataConnector(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\treader := clickhouseReader.NewReader(\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,",
        "comment_created_at": "2025-06-20T18:30:20+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Yes the querier should control the flux interval always.\n\nIf the querier tomorrow says that \"hey, I am open to taking different flux intervals for different signals/features\", it needs to expose it as part of its config.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159412785",
    "pr_number": 8308,
    "pr_file": "pkg/query-service/app/server.go",
    "created_at": "2025-06-20T17:20:31+00:00",
    "commented_code": "\"go.uber.org/zap\"\n )\n \n-type ServerOptions struct {\n-\tConfig                     signoz.Config\n-\tHTTPHostPort               string\n-\tPrivateHostPort            string\n-\tPreferSpanMetrics          bool\n-\tCacheConfigPath            string\n-\tFluxInterval               string\n-\tFluxIntervalForTraceDetail string\n-\tCluster                    string\n-\tSigNoz                     *signoz.SigNoz\n-\tJwt                        *authtypes.JWT\n-}\n-\n // Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *rules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *rules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n \n \topampServer *opamp.Server\n \n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tintegrationsController, err := integrations.NewController(serverOptions.SigNoz.SQLStore)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tintegrationsController, err := integrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tcloudIntegrationsController, err := cloudintegrations.NewController(serverOptions.SigNoz.SQLStore)\n+\tcloudIntegrationsController, err := cloudintegrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \treader := clickhouseReader.NewReader(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,\n+\t\tsignoz.Cache,\n \t)\n \n \trm, err := makeRulesManager(\n \t\treader,\n-\t\tserverOptions.SigNoz.Cache,\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.SigNoz.Modules.OrgGetter,\n+\t\tsignoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.Modules.OrgGetter,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tfluxInterval, err := time.ParseDuration(serverOptions.FluxInterval)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tlogParsingPipelineController, err := logparsingpipeline.NewLogParsingPipelinesController(\n-\t\tserverOptions.SigNoz.SQLStore, integrationsController.GetPipelinesForInstalledIntegrations,\n+\t\tsignoz.SQLStore,\n+\t\tintegrationsController.GetPipelinesForInstalledIntegrations,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// todo(remove): remove in favour of statsreporter and analytics\n \ttelemetry.GetInstance().SetReader(reader)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2159412785",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8308,
        "pr_file": "pkg/query-service/app/server.go",
        "discussion_id": "2159412785",
        "commented_code": "@@ -42,95 +41,72 @@ import (\n \t\"go.uber.org/zap\"\n )\n \n-type ServerOptions struct {\n-\tConfig                     signoz.Config\n-\tHTTPHostPort               string\n-\tPrivateHostPort            string\n-\tPreferSpanMetrics          bool\n-\tCacheConfigPath            string\n-\tFluxInterval               string\n-\tFluxIntervalForTraceDetail string\n-\tCluster                    string\n-\tSigNoz                     *signoz.SigNoz\n-\tJwt                        *authtypes.JWT\n-}\n-\n // Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *rules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *rules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n \n \topampServer *opamp.Server\n \n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tintegrationsController, err := integrations.NewController(serverOptions.SigNoz.SQLStore)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tintegrationsController, err := integrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tcloudIntegrationsController, err := cloudintegrations.NewController(serverOptions.SigNoz.SQLStore)\n+\tcloudIntegrationsController, err := cloudintegrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \treader := clickhouseReader.NewReader(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,\n+\t\tsignoz.Cache,\n \t)\n \n \trm, err := makeRulesManager(\n \t\treader,\n-\t\tserverOptions.SigNoz.Cache,\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.SigNoz.Modules.OrgGetter,\n+\t\tsignoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.Modules.OrgGetter,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tfluxInterval, err := time.ParseDuration(serverOptions.FluxInterval)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tlogParsingPipelineController, err := logparsingpipeline.NewLogParsingPipelinesController(\n-\t\tserverOptions.SigNoz.SQLStore, integrationsController.GetPipelinesForInstalledIntegrations,\n+\t\tsignoz.SQLStore,\n+\t\tintegrationsController.GetPipelinesForInstalledIntegrations,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// todo(remove): remove in favour of statsreporter and analytics\n \ttelemetry.GetInstance().SetReader(reader)",
        "comment_created_at": "2025-06-20T17:20:31+00:00",
        "comment_author": "srikanthccv",
        "comment_body": "Some telemetry code is using the hardcoded `cluster` here https://github.com/SigNoz/signoz/blob/5b342b9b5ddf7b3789c947fcfbf5d24d84e7f617/pkg/query-service/app/clickhouseReader/reader.go#L2437, can you fix it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159494897",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8308,
        "pr_file": "pkg/query-service/app/server.go",
        "discussion_id": "2159412785",
        "commented_code": "@@ -42,95 +41,72 @@ import (\n \t\"go.uber.org/zap\"\n )\n \n-type ServerOptions struct {\n-\tConfig                     signoz.Config\n-\tHTTPHostPort               string\n-\tPrivateHostPort            string\n-\tPreferSpanMetrics          bool\n-\tCacheConfigPath            string\n-\tFluxInterval               string\n-\tFluxIntervalForTraceDetail string\n-\tCluster                    string\n-\tSigNoz                     *signoz.SigNoz\n-\tJwt                        *authtypes.JWT\n-}\n-\n // Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *rules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *rules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n \n \topampServer *opamp.Server\n \n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tintegrationsController, err := integrations.NewController(serverOptions.SigNoz.SQLStore)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tintegrationsController, err := integrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tcloudIntegrationsController, err := cloudintegrations.NewController(serverOptions.SigNoz.SQLStore)\n+\tcloudIntegrationsController, err := cloudintegrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \treader := clickhouseReader.NewReader(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,\n+\t\tsignoz.Cache,\n \t)\n \n \trm, err := makeRulesManager(\n \t\treader,\n-\t\tserverOptions.SigNoz.Cache,\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.SigNoz.Modules.OrgGetter,\n+\t\tsignoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.Modules.OrgGetter,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tfluxInterval, err := time.ParseDuration(serverOptions.FluxInterval)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tlogParsingPipelineController, err := logparsingpipeline.NewLogParsingPipelinesController(\n-\t\tserverOptions.SigNoz.SQLStore, integrationsController.GetPipelinesForInstalledIntegrations,\n+\t\tsignoz.SQLStore,\n+\t\tintegrationsController.GetPipelinesForInstalledIntegrations,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// todo(remove): remove in favour of statsreporter and analytics\n \ttelemetry.GetInstance().SetReader(reader)",
        "comment_created_at": "2025-06-20T18:30:34+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Let me check.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159524898",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8308,
        "pr_file": "pkg/query-service/app/server.go",
        "discussion_id": "2159412785",
        "commented_code": "@@ -42,95 +41,72 @@ import (\n \t\"go.uber.org/zap\"\n )\n \n-type ServerOptions struct {\n-\tConfig                     signoz.Config\n-\tHTTPHostPort               string\n-\tPrivateHostPort            string\n-\tPreferSpanMetrics          bool\n-\tCacheConfigPath            string\n-\tFluxInterval               string\n-\tFluxIntervalForTraceDetail string\n-\tCluster                    string\n-\tSigNoz                     *signoz.SigNoz\n-\tJwt                        *authtypes.JWT\n-}\n-\n // Server runs HTTP, Mux and a grpc server\n type Server struct {\n-\tserverOptions *ServerOptions\n-\truleManager   *rules.Manager\n+\tconfig      signoz.Config\n+\tsignoz      *signoz.SigNoz\n+\tjwt         *authtypes.JWT\n+\truleManager *rules.Manager\n \n \t// public http router\n-\thttpConn   net.Listener\n-\thttpServer *http.Server\n+\thttpConn     net.Listener\n+\thttpServer   *http.Server\n+\thttpHostPort string\n \n \t// private http\n-\tprivateConn net.Listener\n-\tprivateHTTP *http.Server\n+\tprivateConn     net.Listener\n+\tprivateHTTP     *http.Server\n+\tprivateHostPort string\n \n \topampServer *opamp.Server\n \n \tunavailableChannel chan healthcheck.Status\n }\n \n-// HealthCheckStatus returns health check status channel a client can subscribe to\n-func (s Server) HealthCheckStatus() chan healthcheck.Status {\n-\treturn s.unavailableChannel\n-}\n-\n // NewServer creates and initializes Server\n-func NewServer(serverOptions *ServerOptions) (*Server, error) {\n-\n-\tfluxIntervalForTraceDetail, err := time.ParseDuration(serverOptions.FluxIntervalForTraceDetail)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tintegrationsController, err := integrations.NewController(serverOptions.SigNoz.SQLStore)\n+func NewServer(config signoz.Config, signoz *signoz.SigNoz, jwt *authtypes.JWT) (*Server, error) {\n+\tintegrationsController, err := integrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tcloudIntegrationsController, err := cloudintegrations.NewController(serverOptions.SigNoz.SQLStore)\n+\tcloudIntegrationsController, err := cloudintegrations.NewController(signoz.SQLStore)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \treader := clickhouseReader.NewReader(\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.Cluster,\n-\t\tfluxIntervalForTraceDetail,\n-\t\tserverOptions.SigNoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.TelemetryStore.Cluster(),\n+\t\tconfig.Querier.FluxInterval,\n+\t\tsignoz.Cache,\n \t)\n \n \trm, err := makeRulesManager(\n \t\treader,\n-\t\tserverOptions.SigNoz.Cache,\n-\t\tserverOptions.SigNoz.SQLStore,\n-\t\tserverOptions.SigNoz.TelemetryStore,\n-\t\tserverOptions.SigNoz.Prometheus,\n-\t\tserverOptions.SigNoz.Modules.OrgGetter,\n+\t\tsignoz.Cache,\n+\t\tsignoz.SQLStore,\n+\t\tsignoz.TelemetryStore,\n+\t\tsignoz.Prometheus,\n+\t\tsignoz.Modules.OrgGetter,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tfluxInterval, err := time.ParseDuration(serverOptions.FluxInterval)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n \tlogParsingPipelineController, err := logparsingpipeline.NewLogParsingPipelinesController(\n-\t\tserverOptions.SigNoz.SQLStore, integrationsController.GetPipelinesForInstalledIntegrations,\n+\t\tsignoz.SQLStore,\n+\t\tintegrationsController.GetPipelinesForInstalledIntegrations,\n \t)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// todo(remove): remove in favour of statsreporter and analytics\n \ttelemetry.GetInstance().SetReader(reader)",
        "comment_created_at": "2025-06-20T18:56:35+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "I have marked all of those functions as deprecated. Once I get the sign off (which needs to happen before the next release, I will delete all those functions)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1919833092",
    "pr_number": 6835,
    "pr_file": "pkg/sqlstore/config.go",
    "created_at": "2025-01-17T09:44:03+00:00",
    "commented_code": "+package sqlstore\n+\n+import (\n+\t\"go.signoz.io/signoz/pkg/factory\"\n+)\n+\n+type Config struct {\n+\t// Provider is the provider to use.\n+\tProvider string `mapstructure:\"provider\"`\n+\t// Connection is the connection configuration.\n+\tConnection ConnectionConfig `mapstructure:\",squash\"`\n+\t// Sqlite is the sqlite configuration.\n+\tSqlite SqliteConfig `mapstructure:\"sqlite\"`\n+}\n+\n+type SqliteConfig struct {",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "1919833092",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 6835,
        "pr_file": "pkg/sqlstore/config.go",
        "discussion_id": "1919833092",
        "commented_code": "@@ -0,0 +1,45 @@\n+package sqlstore\n+\n+import (\n+\t\"go.signoz.io/signoz/pkg/factory\"\n+)\n+\n+type Config struct {\n+\t// Provider is the provider to use.\n+\tProvider string `mapstructure:\"provider\"`\n+\t// Connection is the connection configuration.\n+\tConnection ConnectionConfig `mapstructure:\",squash\"`\n+\t// Sqlite is the sqlite configuration.\n+\tSqlite SqliteConfig `mapstructure:\"sqlite\"`\n+}\n+\n+type SqliteConfig struct {",
        "comment_created_at": "2025-01-17T09:44:03+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "should we rename this to sqlite_config.go, since this config is towards config of sqlite ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1919853055",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 6835,
        "pr_file": "pkg/sqlstore/config.go",
        "discussion_id": "1919833092",
        "commented_code": "@@ -0,0 +1,45 @@\n+package sqlstore\n+\n+import (\n+\t\"go.signoz.io/signoz/pkg/factory\"\n+)\n+\n+type Config struct {\n+\t// Provider is the provider to use.\n+\tProvider string `mapstructure:\"provider\"`\n+\t// Connection is the connection configuration.\n+\tConnection ConnectionConfig `mapstructure:\",squash\"`\n+\t// Sqlite is the sqlite configuration.\n+\tSqlite SqliteConfig `mapstructure:\"sqlite\"`\n+}\n+\n+type SqliteConfig struct {",
        "comment_created_at": "2025-01-17T09:58:33+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "So this will contain configuration of all providers, not just sqlite.\r\nCheck `pkg/cache/config.go` once.",
        "pr_file_module": null
      },
      {
        "comment_id": "1919857416",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 6835,
        "pr_file": "pkg/sqlstore/config.go",
        "discussion_id": "1919833092",
        "commented_code": "@@ -0,0 +1,45 @@\n+package sqlstore\n+\n+import (\n+\t\"go.signoz.io/signoz/pkg/factory\"\n+)\n+\n+type Config struct {\n+\t// Provider is the provider to use.\n+\tProvider string `mapstructure:\"provider\"`\n+\t// Connection is the connection configuration.\n+\tConnection ConnectionConfig `mapstructure:\",squash\"`\n+\t// Sqlite is the sqlite configuration.\n+\tSqlite SqliteConfig `mapstructure:\"sqlite\"`\n+}\n+\n+type SqliteConfig struct {",
        "comment_created_at": "2025-01-17T10:01:37+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "lets say tomorrow we need to add postgres, will the config for that lie in this same file and Config struct will contain\r\n\r\n```\r\nPostgres PostgresConfig `mapstructure:\"postgres\"`\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1919858214",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 6835,
        "pr_file": "pkg/sqlstore/config.go",
        "discussion_id": "1919833092",
        "commented_code": "@@ -0,0 +1,45 @@\n+package sqlstore\n+\n+import (\n+\t\"go.signoz.io/signoz/pkg/factory\"\n+)\n+\n+type Config struct {\n+\t// Provider is the provider to use.\n+\tProvider string `mapstructure:\"provider\"`\n+\t// Connection is the connection configuration.\n+\tConnection ConnectionConfig `mapstructure:\",squash\"`\n+\t// Sqlite is the sqlite configuration.\n+\tSqlite SqliteConfig `mapstructure:\"sqlite\"`\n+}\n+\n+type SqliteConfig struct {",
        "comment_created_at": "2025-01-17T10:02:12+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Correct",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1726179455",
    "pr_number": 5740,
    "pr_file": "pkg/http/middleware/timeout.go",
    "created_at": "2024-08-22T03:14:08+00:00",
    "commented_code": "+package middleware\n+\n+import (\n+\t\"context\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"go.uber.org/zap\"\n+)\n+\n+const (\n+\tmaxTimeout time.Duration = 600 * time.Second",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "1726179455",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 5740,
        "pr_file": "pkg/http/middleware/timeout.go",
        "discussion_id": "1726179455",
        "commented_code": "@@ -0,0 +1,70 @@\n+package middleware\n+\n+import (\n+\t\"context\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"go.uber.org/zap\"\n+)\n+\n+const (\n+\tmaxTimeout time.Duration = 600 * time.Second",
        "comment_created_at": "2024-08-22T03:14:08+00:00",
        "comment_author": "srikanthccv",
        "comment_body": "This was configurable. I don't remember the reasoning behind it. @nityanandagohain did we want to allow max timeout to be configurable more than this?",
        "pr_file_module": null
      },
      {
        "comment_id": "1726517292",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 5740,
        "pr_file": "pkg/http/middleware/timeout.go",
        "discussion_id": "1726179455",
        "commented_code": "@@ -0,0 +1,70 @@\n+package middleware\n+\n+import (\n+\t\"context\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"go.uber.org/zap\"\n+)\n+\n+const (\n+\tmaxTimeout time.Duration = 600 * time.Second",
        "comment_created_at": "2024-08-22T07:38:15+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "The default is 600 but we allow changing that through env https://github.com/SigNoz/signoz/blob/072693d57dc802d87d3f38146f2870ab68387da0/pkg/query-service/constants/constants.go#L147",
        "pr_file_module": null
      },
      {
        "comment_id": "1726549644",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 5740,
        "pr_file": "pkg/http/middleware/timeout.go",
        "discussion_id": "1726179455",
        "commented_code": "@@ -0,0 +1,70 @@\n+package middleware\n+\n+import (\n+\t\"context\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"go.uber.org/zap\"\n+)\n+\n+const (\n+\tmaxTimeout time.Duration = 600 * time.Second",
        "comment_created_at": "2024-08-22T07:59:20+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2074027220",
    "pr_number": 7718,
    "pr_file": "pkg/query-service/app/cloudintegrations/controller.go",
    "created_at": "2025-05-05T19:08:20+00:00",
    "commented_code": "}\n \n \t// TODO(Raj): parameterized this in follow up changes\n-\tagentVersion := \"0.0.3\"\n+\tagentVersion := \"v0.0.4-alpha.14\"",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2074027220",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7718,
        "pr_file": "pkg/query-service/app/cloudintegrations/controller.go",
        "discussion_id": "2074027220",
        "commented_code": "@@ -117,7 +118,7 @@ func (c *Controller) GenerateConnectionUrl(\n \t}\n \n \t// TODO(Raj): parameterized this in follow up changes\n-\tagentVersion := \"0.0.3\"\n+\tagentVersion := \"v0.0.4-alpha.14\"",
        "comment_created_at": "2025-05-05T19:08:20+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "make change to support this through config.",
        "pr_file_module": null
      },
      {
        "comment_id": "2074773401",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7718,
        "pr_file": "pkg/query-service/app/cloudintegrations/controller.go",
        "discussion_id": "2074027220",
        "commented_code": "@@ -117,7 +118,7 @@ func (c *Controller) GenerateConnectionUrl(\n \t}\n \n \t// TODO(Raj): parameterized this in follow up changes\n-\tagentVersion := \"0.0.3\"\n+\tagentVersion := \"v0.0.4-alpha.14\"",
        "comment_created_at": "2025-05-06T05:55:16+00:00",
        "comment_author": "piyushsingariya",
        "comment_body": "It should be, but not right now, there's no updation strategy in-place.\r\n\r\nRoadmap acc to me would be = Adding more AWS Integrations -> Azure Integrations -> Filters in AWS integrations (If possible in azure too) -> Updation Strategy for AWS and Azure",
        "pr_file_module": null
      },
      {
        "comment_id": "2075044452",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7718,
        "pr_file": "pkg/query-service/app/cloudintegrations/controller.go",
        "discussion_id": "2074027220",
        "commented_code": "@@ -117,7 +118,7 @@ func (c *Controller) GenerateConnectionUrl(\n \t}\n \n \t// TODO(Raj): parameterized this in follow up changes\n-\tagentVersion := \"0.0.3\"\n+\tagentVersion := \"v0.0.4-alpha.14\"",
        "comment_created_at": "2025-05-06T09:04:44+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "I meant that we should take it from the signoz deployment config instead of hardcoded value.",
        "pr_file_module": null
      }
    ]
  }
]