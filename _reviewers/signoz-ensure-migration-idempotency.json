[
  {
    "discussion_id": "2299977496",
    "pr_number": 8513,
    "pr_file": "pkg/sqlmigration/048_update_ttl_setting.go",
    "created_at": "2025-08-26T06:55:03+00:00",
    "commented_code": "+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlschema\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type updateTTLSettingForCustomRetention struct {\n+\tsqlstore  sqlstore.SQLStore\n+\tsqlschema sqlschema.SQLSchema\n+}\n+\n+func NewUpdateTTLSettingForCustomRetentionFactory(sqlstore sqlstore.SQLStore, sqlschema sqlschema.SQLSchema) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.NewProviderFactory(factory.MustNewName(\"update_ttl_setting\"), func(ctx context.Context, providerSettings factory.ProviderSettings, config Config) (SQLMigration, error) {\n+\t\treturn newUpdateTTLSettingForCustomRetention(ctx, providerSettings, config, sqlstore, sqlschema)\n+\t})\n+}\n+\n+func newUpdateTTLSettingForCustomRetention(_ context.Context, _ factory.ProviderSettings, _ Config, sqlstore sqlstore.SQLStore, sqlschema sqlschema.SQLSchema) (SQLMigration, error) {\n+\treturn &updateTTLSettingForCustomRetention{\n+\t\tsqlstore:  sqlstore,\n+\t\tsqlschema: sqlschema,\n+\t}, nil\n+}\n+\n+func (migration *updateTTLSettingForCustomRetention) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.Register(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (migration *updateTTLSettingForCustomRetention) Up(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tdefer func() {\n+\t\t_ = tx.Rollback()\n+\t}()\n+\n+\t// Get the table and its constraints\n+\ttable, uniqueConstraints, err := migration.sqlschema.GetTable(ctx, sqlschema.TableName(\"ttl_setting\"))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Define the new column\n+\tcolumn := &sqlschema.Column{\n+\t\tName:     sqlschema.ColumnName(\"condition\"),\n+\t\tDataType: sqlschema.DataTypeText,\n+\t\tNullable: true,\n+\t}\n+\n+\tsqls := migration.sqlschema.Operator().AddColumn(table, uniqueConstraints, column, nil)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2299977496",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8513,
        "pr_file": "pkg/sqlmigration/048_update_ttl_setting.go",
        "discussion_id": "2299977496",
        "commented_code": "@@ -0,0 +1,78 @@\n+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlschema\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type updateTTLSettingForCustomRetention struct {\n+\tsqlstore  sqlstore.SQLStore\n+\tsqlschema sqlschema.SQLSchema\n+}\n+\n+func NewUpdateTTLSettingForCustomRetentionFactory(sqlstore sqlstore.SQLStore, sqlschema sqlschema.SQLSchema) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.NewProviderFactory(factory.MustNewName(\"update_ttl_setting\"), func(ctx context.Context, providerSettings factory.ProviderSettings, config Config) (SQLMigration, error) {\n+\t\treturn newUpdateTTLSettingForCustomRetention(ctx, providerSettings, config, sqlstore, sqlschema)\n+\t})\n+}\n+\n+func newUpdateTTLSettingForCustomRetention(_ context.Context, _ factory.ProviderSettings, _ Config, sqlstore sqlstore.SQLStore, sqlschema sqlschema.SQLSchema) (SQLMigration, error) {\n+\treturn &updateTTLSettingForCustomRetention{\n+\t\tsqlstore:  sqlstore,\n+\t\tsqlschema: sqlschema,\n+\t}, nil\n+}\n+\n+func (migration *updateTTLSettingForCustomRetention) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.Register(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (migration *updateTTLSettingForCustomRetention) Up(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tdefer func() {\n+\t\t_ = tx.Rollback()\n+\t}()\n+\n+\t// Get the table and its constraints\n+\ttable, uniqueConstraints, err := migration.sqlschema.GetTable(ctx, sqlschema.TableName(\"ttl_setting\"))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Define the new column\n+\tcolumn := &sqlschema.Column{\n+\t\tName:     sqlschema.ColumnName(\"condition\"),\n+\t\tDataType: sqlschema.DataTypeText,\n+\t\tNullable: true,\n+\t}\n+\n+\tsqls := migration.sqlschema.Operator().AddColumn(table, uniqueConstraints, column, nil)",
        "comment_created_at": "2025-08-26T06:55:03+00:00",
        "comment_author": "vikrantgupta25",
        "comment_body": "you don't need to pass all the table constraints here. you just need to pass the constraint you want for your column.  since it's nullable just set it as nil and don't extract the uniqueConstraints from GetTable",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2067056587",
    "pr_number": 7763,
    "pr_file": "pkg/sqlmigration/030_add_trace_funnels.go",
    "created_at": "2025-04-29T17:50:51+00:00",
    "commented_code": "+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\ttraceFunnels \"github.com/SigNoz/signoz/pkg/types/tracefunnel\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type addTraceFunnels struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func NewAddTraceFunnelsFactory(sqlstore sqlstore.SQLStore) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.\n+\t\tNewProviderFactory(factory.\n+\t\t\tMustNewName(\"add_trace_funnels\"),\n+\t\t\tfunc(ctx context.Context, providerSettings factory.ProviderSettings, config Config) (SQLMigration, error) {\n+\t\t\t\treturn newAddTraceFunnels(ctx, providerSettings, config, sqlstore)\n+\t\t\t})\n+}\n+\n+func newAddTraceFunnels(_ context.Context, _ factory.ProviderSettings, _ Config, sqlstore sqlstore.SQLStore) (SQLMigration, error) {\n+\treturn &addTraceFunnels{sqlstore: sqlstore}, nil\n+}\n+\n+func (migration *addTraceFunnels) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.\n+\t\tRegister(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (migration *addTraceFunnels) Up(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer tx.Rollback()\n+\n+\t// Create trace_funnel table with foreign key constraint inline\n+\t_, err = tx.NewCreateTable().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tForeignKey(`(\"org_id\") REFERENCES \"organizations\" (\"id\") ON DELETE CASCADE`).\n+\t\tIfNotExists().\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create trace_funnel table: %v\", err)\n+\t}\n+\n+\t// Add unique constraint for org_id and name\n+\t_, err = tx.NewRaw(`\n+\t\tCREATE UNIQUE INDEX IF NOT EXISTS idx_trace_funnel_org_id_name \n+\t\tON trace_funnel (org_id, name)\n+\t`).Exec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create unique constraint: %v\", err)\n+\t}\n+\n+\t// Create indexes\n+\t_, err = tx.NewCreateIndex().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tIndex(\"idx_trace_funnel_org_id\").\n+\t\tColumn(\"org_id\").\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create org_id index: %v\", err)\n+\t}\n+\n+\t_, err = tx.NewCreateIndex().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tIndex(\"idx_trace_funnel_created_at\").\n+\t\tColumn(\"created_at\").Exec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create created_at index: %v\", err)\n+\t}\n+\n+\tif err := tx.Commit(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (migration *addTraceFunnels) Down(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2067056587",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7763,
        "pr_file": "pkg/sqlmigration/030_add_trace_funnels.go",
        "discussion_id": "2067056587",
        "commented_code": "@@ -0,0 +1,111 @@\n+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\ttraceFunnels \"github.com/SigNoz/signoz/pkg/types/tracefunnel\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type addTraceFunnels struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func NewAddTraceFunnelsFactory(sqlstore sqlstore.SQLStore) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.\n+\t\tNewProviderFactory(factory.\n+\t\t\tMustNewName(\"add_trace_funnels\"),\n+\t\t\tfunc(ctx context.Context, providerSettings factory.ProviderSettings, config Config) (SQLMigration, error) {\n+\t\t\t\treturn newAddTraceFunnels(ctx, providerSettings, config, sqlstore)\n+\t\t\t})\n+}\n+\n+func newAddTraceFunnels(_ context.Context, _ factory.ProviderSettings, _ Config, sqlstore sqlstore.SQLStore) (SQLMigration, error) {\n+\treturn &addTraceFunnels{sqlstore: sqlstore}, nil\n+}\n+\n+func (migration *addTraceFunnels) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.\n+\t\tRegister(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (migration *addTraceFunnels) Up(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer tx.Rollback()\n+\n+\t// Create trace_funnel table with foreign key constraint inline\n+\t_, err = tx.NewCreateTable().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tForeignKey(`(\"org_id\") REFERENCES \"organizations\" (\"id\") ON DELETE CASCADE`).\n+\t\tIfNotExists().\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create trace_funnel table: %v\", err)\n+\t}\n+\n+\t// Add unique constraint for org_id and name\n+\t_, err = tx.NewRaw(`\n+\t\tCREATE UNIQUE INDEX IF NOT EXISTS idx_trace_funnel_org_id_name \n+\t\tON trace_funnel (org_id, name)\n+\t`).Exec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create unique constraint: %v\", err)\n+\t}\n+\n+\t// Create indexes\n+\t_, err = tx.NewCreateIndex().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tIndex(\"idx_trace_funnel_org_id\").\n+\t\tColumn(\"org_id\").\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create org_id index: %v\", err)\n+\t}\n+\n+\t_, err = tx.NewCreateIndex().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tIndex(\"idx_trace_funnel_created_at\").\n+\t\tColumn(\"created_at\").Exec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create created_at index: %v\", err)\n+\t}\n+\n+\tif err := tx.Commit(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (migration *addTraceFunnels) Down(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)",
        "comment_created_at": "2025-04-29T17:50:51+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Just `return nil` from here. We don't do Down migrations.",
        "pr_file_module": null
      },
      {
        "comment_id": "2102015945",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7763,
        "pr_file": "pkg/sqlmigration/030_add_trace_funnels.go",
        "discussion_id": "2067056587",
        "commented_code": "@@ -0,0 +1,111 @@\n+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\ttraceFunnels \"github.com/SigNoz/signoz/pkg/types/tracefunnel\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type addTraceFunnels struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func NewAddTraceFunnelsFactory(sqlstore sqlstore.SQLStore) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.\n+\t\tNewProviderFactory(factory.\n+\t\t\tMustNewName(\"add_trace_funnels\"),\n+\t\t\tfunc(ctx context.Context, providerSettings factory.ProviderSettings, config Config) (SQLMigration, error) {\n+\t\t\t\treturn newAddTraceFunnels(ctx, providerSettings, config, sqlstore)\n+\t\t\t})\n+}\n+\n+func newAddTraceFunnels(_ context.Context, _ factory.ProviderSettings, _ Config, sqlstore sqlstore.SQLStore) (SQLMigration, error) {\n+\treturn &addTraceFunnels{sqlstore: sqlstore}, nil\n+}\n+\n+func (migration *addTraceFunnels) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.\n+\t\tRegister(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func (migration *addTraceFunnels) Up(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer tx.Rollback()\n+\n+\t// Create trace_funnel table with foreign key constraint inline\n+\t_, err = tx.NewCreateTable().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tForeignKey(`(\"org_id\") REFERENCES \"organizations\" (\"id\") ON DELETE CASCADE`).\n+\t\tIfNotExists().\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create trace_funnel table: %v\", err)\n+\t}\n+\n+\t// Add unique constraint for org_id and name\n+\t_, err = tx.NewRaw(`\n+\t\tCREATE UNIQUE INDEX IF NOT EXISTS idx_trace_funnel_org_id_name \n+\t\tON trace_funnel (org_id, name)\n+\t`).Exec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create unique constraint: %v\", err)\n+\t}\n+\n+\t// Create indexes\n+\t_, err = tx.NewCreateIndex().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tIndex(\"idx_trace_funnel_org_id\").\n+\t\tColumn(\"org_id\").\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create org_id index: %v\", err)\n+\t}\n+\n+\t_, err = tx.NewCreateIndex().\n+\t\tModel((*traceFunnels.Funnel)(nil)).\n+\t\tIndex(\"idx_trace_funnel_created_at\").\n+\t\tColumn(\"created_at\").Exec(ctx)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create created_at index: %v\", err)\n+\t}\n+\n+\tif err := tx.Commit(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (migration *addTraceFunnels) Down(ctx context.Context, db *bun.DB) error {\n+\ttx, err := db.BeginTx(ctx, nil)",
        "comment_created_at": "2025-05-22T08:54:55+00:00",
        "comment_author": "shivanshuraj1333",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086809408",
    "pr_number": 7778,
    "pr_file": "pkg/sqlmigration/032_auth_refactor.go",
    "created_at": "2025-05-13T13:17:45+00:00",
    "commented_code": "+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\t\"database/sql\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type authRefactor struct {\n+\tstore sqlstore.SQLStore\n+}\n+\n+func NewAuthRefactorFactory(sqlstore sqlstore.SQLStore) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.NewProviderFactory(factory.MustNewName(\"auth_refactor\"), func(ctx context.Context, ps factory.ProviderSettings, c Config) (SQLMigration, error) {\n+\t\treturn newAuthRefactor(ctx, ps, c, sqlstore)\n+\t})\n+}\n+\n+func newAuthRefactor(_ context.Context, _ factory.ProviderSettings, _ Config, store sqlstore.SQLStore) (SQLMigration, error) {\n+\treturn &authRefactor{store: store}, nil\n+}\n+\n+func (migration *authRefactor) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.Register(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+type existingUser32 struct {\n+\tbun.BaseModel `bun:\"table:users\"`\n+\n+\ttypes.TimeAuditable\n+\tID                string `bun:\"id,pk,type:text\" json:\"id\"`\n+\tName              string `bun:\"name,type:text,notnull\" json:\"name\"`\n+\tEmail             string `bun:\"email,type:text,notnull,unique\" json:\"email\"`\n+\tPassword          string `bun:\"password,type:text,notnull\" json:\"-\"`\n+\tProfilePictureURL string `bun:\"profile_picture_url,type:text\" json:\"profilePictureURL\"`\n+\tRole              string `bun:\"role,type:text,notnull\" json:\"role\"`\n+\tOrgID             string `bun:\"org_id,type:text,notnull\" json:\"orgId\"`\n+}\n+\n+type FactorPassword32 struct {\n+\tbun.BaseModel `bun:\"table:factor_password\"`\n+\n+\ttypes.Identifiable\n+\ttypes.TimeAuditable\n+\tPassword  string `bun:\"password,type:text,notnull\" json:\"password\"`\n+\tTemporary bool   `bun:\"temporary,type:boolean,notnull\" json:\"temporary\"`\n+\tUserID    string `bun:\"user_id,type:text,notnull,unique,references:user(id)\" json:\"userId\"`\n+}\n+\n+type existingResetPasswordRequest32 struct {\n+\tbun.BaseModel `bun:\"table:reset_password_request\"`\n+\n+\ttypes.Identifiable\n+\tToken  string `bun:\"token,type:text,notnull\" json:\"token\"`\n+\tUserID string `bun:\"user_id,type:text,notnull,unique\" json:\"userId\"`\n+}\n+\n+type FactorResetPasswordRequest32 struct {\n+\tbun.BaseModel `bun:\"table:factor_reset_password_request\"`\n+\n+\ttypes.Identifiable\n+\tToken      string `bun:\"token,type:text,notnull\" json:\"token\"`\n+\tPasswordID string `bun:\"password_id,type:text,notnull,unique,references:factor_password(id)\" json:\"passwordId\"`\n+}\n+\n+func (migration *authRefactor) Up(ctx context.Context, db *bun.DB) error {\n+\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tdefer tx.Rollback()\n+\n+\tif _, err := tx.NewCreateTable().\n+\t\tModel(&struct {\n+\t\t\tbun.BaseModel `bun:\"table:factor_password\"`\n+\n+\t\t\ttypes.Identifiable\n+\t\t\ttypes.TimeAuditable\n+\t\t\tPassword  string `bun:\"password,type:text,notnull\" json:\"password\"`\n+\t\t\tTemporary bool   `bun:\"temporary,type:boolean,notnull\" json:\"temporary\"`\n+\t\t\tUserID    string `bun:\"user_id,type:text,notnull,unique,references:user(id)\" json:\"userId\"`\n+\t\t}{}).\n+\t\tIfNotExists().\n+\t\tExec(ctx); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// copy passwords from users table to factor_password table\n+\tmigration.CopyOldPasswordToNewPassword(ctx, tx)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2086809408",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7778,
        "pr_file": "pkg/sqlmigration/032_auth_refactor.go",
        "discussion_id": "2086809408",
        "commented_code": "@@ -0,0 +1,212 @@\n+package sqlmigration\n+\n+import (\n+\t\"context\"\n+\t\"database/sql\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/factory\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+\t\"github.com/uptrace/bun\"\n+\t\"github.com/uptrace/bun/migrate\"\n+)\n+\n+type authRefactor struct {\n+\tstore sqlstore.SQLStore\n+}\n+\n+func NewAuthRefactorFactory(sqlstore sqlstore.SQLStore) factory.ProviderFactory[SQLMigration, Config] {\n+\treturn factory.NewProviderFactory(factory.MustNewName(\"auth_refactor\"), func(ctx context.Context, ps factory.ProviderSettings, c Config) (SQLMigration, error) {\n+\t\treturn newAuthRefactor(ctx, ps, c, sqlstore)\n+\t})\n+}\n+\n+func newAuthRefactor(_ context.Context, _ factory.ProviderSettings, _ Config, store sqlstore.SQLStore) (SQLMigration, error) {\n+\treturn &authRefactor{store: store}, nil\n+}\n+\n+func (migration *authRefactor) Register(migrations *migrate.Migrations) error {\n+\tif err := migrations.Register(migration.Up, migration.Down); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+type existingUser32 struct {\n+\tbun.BaseModel `bun:\"table:users\"`\n+\n+\ttypes.TimeAuditable\n+\tID                string `bun:\"id,pk,type:text\" json:\"id\"`\n+\tName              string `bun:\"name,type:text,notnull\" json:\"name\"`\n+\tEmail             string `bun:\"email,type:text,notnull,unique\" json:\"email\"`\n+\tPassword          string `bun:\"password,type:text,notnull\" json:\"-\"`\n+\tProfilePictureURL string `bun:\"profile_picture_url,type:text\" json:\"profilePictureURL\"`\n+\tRole              string `bun:\"role,type:text,notnull\" json:\"role\"`\n+\tOrgID             string `bun:\"org_id,type:text,notnull\" json:\"orgId\"`\n+}\n+\n+type FactorPassword32 struct {\n+\tbun.BaseModel `bun:\"table:factor_password\"`\n+\n+\ttypes.Identifiable\n+\ttypes.TimeAuditable\n+\tPassword  string `bun:\"password,type:text,notnull\" json:\"password\"`\n+\tTemporary bool   `bun:\"temporary,type:boolean,notnull\" json:\"temporary\"`\n+\tUserID    string `bun:\"user_id,type:text,notnull,unique,references:user(id)\" json:\"userId\"`\n+}\n+\n+type existingResetPasswordRequest32 struct {\n+\tbun.BaseModel `bun:\"table:reset_password_request\"`\n+\n+\ttypes.Identifiable\n+\tToken  string `bun:\"token,type:text,notnull\" json:\"token\"`\n+\tUserID string `bun:\"user_id,type:text,notnull,unique\" json:\"userId\"`\n+}\n+\n+type FactorResetPasswordRequest32 struct {\n+\tbun.BaseModel `bun:\"table:factor_reset_password_request\"`\n+\n+\ttypes.Identifiable\n+\tToken      string `bun:\"token,type:text,notnull\" json:\"token\"`\n+\tPasswordID string `bun:\"password_id,type:text,notnull,unique,references:factor_password(id)\" json:\"passwordId\"`\n+}\n+\n+func (migration *authRefactor) Up(ctx context.Context, db *bun.DB) error {\n+\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tdefer tx.Rollback()\n+\n+\tif _, err := tx.NewCreateTable().\n+\t\tModel(&struct {\n+\t\t\tbun.BaseModel `bun:\"table:factor_password\"`\n+\n+\t\t\ttypes.Identifiable\n+\t\t\ttypes.TimeAuditable\n+\t\t\tPassword  string `bun:\"password,type:text,notnull\" json:\"password\"`\n+\t\t\tTemporary bool   `bun:\"temporary,type:boolean,notnull\" json:\"temporary\"`\n+\t\t\tUserID    string `bun:\"user_id,type:text,notnull,unique,references:user(id)\" json:\"userId\"`\n+\t\t}{}).\n+\t\tIfNotExists().\n+\t\tExec(ctx); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// copy passwords from users table to factor_password table\n+\tmigration.CopyOldPasswordToNewPassword(ctx, tx)",
        "comment_created_at": "2025-05-13T13:17:45+00:00",
        "comment_author": "vikrantgupta25",
        "comment_body": "copy old password to new password needs to be idempotent ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2056568774",
    "pr_number": 7684,
    "pr_file": "pkg/sqlmigration/028_update_organizations.go",
    "created_at": "2025-04-23T17:32:30+00:00",
    "commented_code": "+package sqlmigration",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2056568774",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7684,
        "pr_file": "pkg/sqlmigration/028_update_organizations.go",
        "discussion_id": "2056568774",
        "commented_code": "@@ -0,0 +1,129 @@\n+package sqlmigration",
        "comment_created_at": "2025-04-23T17:32:30+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Please use `NewDropColumn`, `NewAddColumn` instead of executing raw sql queries.\r\n\r\nEven better if we can create idempotent functions as part of our Dialect.",
        "pr_file_module": null
      }
    ]
  }
]