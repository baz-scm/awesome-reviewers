[
  {
    "discussion_id": "2098566225",
    "pr_number": 7969,
    "pr_file": "ee/licensing/licensingstore/sqllicensingstore/store.go",
    "created_at": "2025-05-20T17:55:46+00:00",
    "commented_code": "+package sqllicensingstore\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/errors\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/types/featuretypes\"\n+\t\"github.com/SigNoz/signoz/pkg/types/licensingtypes\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+)\n+\n+type store struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func New(sqlstore sqlstore.SQLStore) licensingtypes.Store {\n+\treturn &store{sqlstore}\n+}\n+\n+func (s *store) Create(ctx context.Context, storableLicense *licensingtypes.StorableLicense) error {\n+\t_, err := s.\n+\t\tsqlstore.\n+\t\tBunDB().\n+\t\tNewInsert().\n+\t\tModel(storableLicense).\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn s.sqlstore.WrapAlreadyExistsErrf(err, errors.CodeInternal, \"unable to create the license with ID: %s\", storableLicense.ID)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (s *store) Get(ctx context.Context, organizationID valuer.UUID, licenseID valuer.UUID) (*licensingtypes.StorableLicense, error) {\n+\tstorableLicense := new(licensingtypes.StorableLicense)\n+\terr := s.\n+\t\tsqlstore.\n+\t\tBunDB().\n+\t\tNewSelect().\n+\t\tModel(storableLicense).\n+\t\tWhere(\"org_id = ?\", organizationID).\n+\t\tWhere(\"id = ?\", licenseID).\n+\t\tScan(ctx)\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, errors.CodeInternal, \"unable to fetch the license with ID: %s\", licenseID)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2098566225",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7969,
        "pr_file": "ee/licensing/licensingstore/sqllicensingstore/store.go",
        "discussion_id": "2098566225",
        "commented_code": "@@ -0,0 +1,186 @@\n+package sqllicensingstore\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/errors\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/types/featuretypes\"\n+\t\"github.com/SigNoz/signoz/pkg/types/licensingtypes\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+)\n+\n+type store struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func New(sqlstore sqlstore.SQLStore) licensingtypes.Store {\n+\treturn &store{sqlstore}\n+}\n+\n+func (s *store) Create(ctx context.Context, storableLicense *licensingtypes.StorableLicense) error {\n+\t_, err := s.\n+\t\tsqlstore.\n+\t\tBunDB().\n+\t\tNewInsert().\n+\t\tModel(storableLicense).\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn s.sqlstore.WrapAlreadyExistsErrf(err, errors.CodeInternal, \"unable to create the license with ID: %s\", storableLicense.ID)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func (s *store) Get(ctx context.Context, organizationID valuer.UUID, licenseID valuer.UUID) (*licensingtypes.StorableLicense, error) {\n+\tstorableLicense := new(licensingtypes.StorableLicense)\n+\terr := s.\n+\t\tsqlstore.\n+\t\tBunDB().\n+\t\tNewSelect().\n+\t\tModel(storableLicense).\n+\t\tWhere(\"org_id = ?\", organizationID).\n+\t\tWhere(\"id = ?\", licenseID).\n+\t\tScan(ctx)\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, errors.CodeInternal, \"unable to fetch the license with ID: %s\", licenseID)",
        "comment_created_at": "2025-05-20T17:55:46+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "```suggestion\r\n\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, errors.CodeNotFound, \"unable to fetch the license with ID: %s\", licenseID)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086670798",
    "pr_number": 7718,
    "pr_file": "pkg/query-service/app/cloudintegrations/controller.go",
    "created_at": "2025-05-13T12:11:36+00:00",
    "commented_code": "}\n \n \t\tif config != nil {\n-\t\t\tservice.Config = config\n+\t\t\tdetails.Config = config\n \n \t\t\tenabled := false\n \t\t\tif config.Metrics != nil && config.Metrics.Enabled {\n \t\t\t\tenabled = true\n \t\t\t}\n \n \t\t\t// add links to service dashboards, making them clickable.\n-\t\t\tfor i, d := range service.Assets.Dashboards {\n+\t\t\tfor i, d := range definition.Assets.Dashboards {\n \t\t\t\tdashboardUuid := c.dashboardUuid(\n \t\t\t\t\tcloudProvider, serviceId, d.Id,\n \t\t\t\t)\n \t\t\t\tif enabled {\n-\t\t\t\t\tservice.Assets.Dashboards[i].Url = fmt.Sprintf(\n-\t\t\t\t\t\t\"/dashboard/%s\", dashboardUuid,\n-\t\t\t\t\t)\n+\t\t\t\t\tdefinition.Assets.Dashboards[i].Url = fmt.Sprintf(\"/dashboard/%s\", dashboardUuid)\n \t\t\t\t} else {\n-\t\t\t\t\tservice.Assets.Dashboards[i].Url = \"\"\n+\t\t\t\t\tdefinition.Assets.Dashboards[i].Url = \"\" // to unset the in-memory URL if enabled once and disabled afterwards\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn service, nil\n+\treturn &details, nil\n }\n \n type UpdateServiceConfigRequest struct {\n \tCloudAccountId string                   `json:\"cloud_account_id\"`\n \tConfig         types.CloudServiceConfig `json:\"config\"`\n }\n \n+func (u *UpdateServiceConfigRequest) Validate(def *services.Definition) error {\n+\tif def.Id != services.S3Sync && u.Config.Logs != nil && u.Config.Logs.S3Buckets != nil {\n+\t\treturn errors.Wrapf(nil, errors.TypeForbidden, errors.CodeForbidden, \"s3 buckets can only be added to service-type[%s]\", services.S3Sync)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2086670798",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7718,
        "pr_file": "pkg/query-service/app/cloudintegrations/controller.go",
        "discussion_id": "2086670798",
        "commented_code": "@@ -433,37 +428,49 @@ func (c *Controller) GetServiceDetails(\n \t\t}\n \n \t\tif config != nil {\n-\t\t\tservice.Config = config\n+\t\t\tdetails.Config = config\n \n \t\t\tenabled := false\n \t\t\tif config.Metrics != nil && config.Metrics.Enabled {\n \t\t\t\tenabled = true\n \t\t\t}\n \n \t\t\t// add links to service dashboards, making them clickable.\n-\t\t\tfor i, d := range service.Assets.Dashboards {\n+\t\t\tfor i, d := range definition.Assets.Dashboards {\n \t\t\t\tdashboardUuid := c.dashboardUuid(\n \t\t\t\t\tcloudProvider, serviceId, d.Id,\n \t\t\t\t)\n \t\t\t\tif enabled {\n-\t\t\t\t\tservice.Assets.Dashboards[i].Url = fmt.Sprintf(\n-\t\t\t\t\t\t\"/dashboard/%s\", dashboardUuid,\n-\t\t\t\t\t)\n+\t\t\t\t\tdefinition.Assets.Dashboards[i].Url = fmt.Sprintf(\"/dashboard/%s\", dashboardUuid)\n \t\t\t\t} else {\n-\t\t\t\t\tservice.Assets.Dashboards[i].Url = \"\"\n+\t\t\t\t\tdefinition.Assets.Dashboards[i].Url = \"\" // to unset the in-memory URL if enabled once and disabled afterwards\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\treturn service, nil\n+\treturn &details, nil\n }\n \n type UpdateServiceConfigRequest struct {\n \tCloudAccountId string                   `json:\"cloud_account_id\"`\n \tConfig         types.CloudServiceConfig `json:\"config\"`\n }\n \n+func (u *UpdateServiceConfigRequest) Validate(def *services.Definition) error {\n+\tif def.Id != services.S3Sync && u.Config.Logs != nil && u.Config.Logs.S3Buckets != nil {\n+\t\treturn errors.Wrapf(nil, errors.TypeForbidden, errors.CodeForbidden, \"s3 buckets can only be added to service-type[%s]\", services.S3Sync)",
        "comment_created_at": "2025-05-13T12:11:36+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "```suggestion\r\n\t\treturn errors.Newf(errors.TypeInvalidInput, errors.CodeInvalidInput, \"s3 buckets can only be added to service-type[%s]\", services.S3Sync)\r\n```\r\n\r\nIf there is no error, there is no need to wrap anything. When writing validation functions, you're trying to see whether the input given by the user is invalid or not. Throwing a `TypeInvalid` makes more sense here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066022381",
    "pr_number": 7712,
    "pr_file": "pkg/types/quickfiltertypes/filter.go",
    "created_at": "2025-04-29T10:34:04+00:00",
    "commented_code": "+package quickfiltertypes\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\tv3 \"github.com/SigNoz/signoz/pkg/query-service/model/v3\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+\t\"github.com/uptrace/bun\"\n+)\n+\n+type Signal struct {\n+\tvaluer.String\n+}\n+\n+var (\n+\tSignalTraces = Signal{valuer.NewString(\"TRACES\")}\n+\tSignalLogs   = Signal{valuer.NewString(\"LOGS\")}\n+\t//SignalMetrics     = Signal{valuer.NewString(\"METRICS\")}\n+\t//SignalInfra       = Signal{valuer.NewString(\"INFRA\")}\n+\tSignalApiMonitoring = Signal{valuer.NewString(\"API_MONITORING\")}\n+)\n+\n+// ValidSignals is a map of valid signal values\n+var ValidSignals = map[string]bool{\n+\tSignalTraces.StringValue(): true,\n+\tSignalLogs.StringValue():   true,\n+\t//SignalMetrics.StringValue():       true,\n+\t//SignalInfra.StringValue():         true,\n+\tSignalApiMonitoring.StringValue(): true,\n+}\n+\n+// IsValidSignal checks if a signal string is valid\n+func IsValidSignal(signal string) bool {\n+\treturn ValidSignals[signal]\n+}\n+\n+// SignalFromString creates a Signal from a string\n+func SignalFromString(s string) Signal {\n+\treturn Signal{valuer.NewString(s)}\n+}\n+\n+type StorableQuickFilter struct {\n+\tbun.BaseModel `bun:\"table:quick_filter\"`\n+\ttypes.Identifiable\n+\tOrgID  valuer.UUID `bun:\"org_id,type:text,notnull\"` // Changed from valuer.String to string\n+\tFilter string      `bun:\"filter,type:text,notnull\"` // Changed from valuer.String to string\n+\tSignal string      `bun:\"signal,type:text,notnull\"` // Changed from Signal to string\n+\ttypes.TimeAuditable\n+}\n+\n+type SignalFilters struct {\n+\tSignal  Signal            `json:\"signal\"`\n+\tFilters []v3.AttributeKey `json:\"filters\"`\n+}\n+\n+type UpdatableQuickFilters struct {\n+\tSignal  Signal            `json:\"signal\"`\n+\tFilters []v3.AttributeKey `json:\"filters\"`\n+}\n+\n+// Validate checks if the quick filter update request is valid\n+func (u *UpdatableQuickFilters) Validate() error {\n+\t// Validate signal\n+\tif !IsValidSignal(u.Signal.StringValue()) {\n+\t\treturn fmt.Errorf(\"invalid signal: %s\", u.Signal.StringValue())\n+\t}\n+\n+\t// Validate each filter\n+\tfor _, filter := range u.Filters {\n+\t\tif err := filter.Validate(); err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid filter: %v\", err)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func NewDefaultQuickFilter(orgID valuer.UUID) []*StorableQuickFilter {\n+\t// Define filters for TRACES\n+\ttracesFilters := []map[string]interface{}{\n+\t\t{\"key\": \"deployment.environment\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"hasError\", \"dataType\": \"bool\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"serviceName\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"rpcMethod\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"responseStatusCode\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpHost\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpMethod\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpRoute\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpUrl\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"traceID\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t}\n+\n+\t// Define filters for LOGS\n+\tlogsFilters := []map[string]interface{}{\n+\t\t{\"key\": \"severity_text\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"deployment.environment\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"serviceName\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"host.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.cluster.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.deployment.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.namespace.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.pod.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t}\n+\n+\t// Define filters for API_MONITORING\n+\tapiMonitoringFilters := []map[string]interface{}{\n+\t\t{\"key\": \"deployment.environment\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"serviceName\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"rpcMethod\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t}\n+\n+\t// Convert to JSON strings\n+\ttracesJSON, _ := json.Marshal(tracesFilters)\n+\tlogsJSON, _ := json.Marshal(logsFilters)\n+\tapiMonitoringJSON, _ := json.Marshal(apiMonitoringFilters)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2066022381",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7712,
        "pr_file": "pkg/types/quickfiltertypes/filter.go",
        "discussion_id": "2066022381",
        "commented_code": "@@ -0,0 +1,146 @@\n+package quickfiltertypes\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\tv3 \"github.com/SigNoz/signoz/pkg/query-service/model/v3\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+\t\"github.com/uptrace/bun\"\n+)\n+\n+type Signal struct {\n+\tvaluer.String\n+}\n+\n+var (\n+\tSignalTraces = Signal{valuer.NewString(\"TRACES\")}\n+\tSignalLogs   = Signal{valuer.NewString(\"LOGS\")}\n+\t//SignalMetrics     = Signal{valuer.NewString(\"METRICS\")}\n+\t//SignalInfra       = Signal{valuer.NewString(\"INFRA\")}\n+\tSignalApiMonitoring = Signal{valuer.NewString(\"API_MONITORING\")}\n+)\n+\n+// ValidSignals is a map of valid signal values\n+var ValidSignals = map[string]bool{\n+\tSignalTraces.StringValue(): true,\n+\tSignalLogs.StringValue():   true,\n+\t//SignalMetrics.StringValue():       true,\n+\t//SignalInfra.StringValue():         true,\n+\tSignalApiMonitoring.StringValue(): true,\n+}\n+\n+// IsValidSignal checks if a signal string is valid\n+func IsValidSignal(signal string) bool {\n+\treturn ValidSignals[signal]\n+}\n+\n+// SignalFromString creates a Signal from a string\n+func SignalFromString(s string) Signal {\n+\treturn Signal{valuer.NewString(s)}\n+}\n+\n+type StorableQuickFilter struct {\n+\tbun.BaseModel `bun:\"table:quick_filter\"`\n+\ttypes.Identifiable\n+\tOrgID  valuer.UUID `bun:\"org_id,type:text,notnull\"` // Changed from valuer.String to string\n+\tFilter string      `bun:\"filter,type:text,notnull\"` // Changed from valuer.String to string\n+\tSignal string      `bun:\"signal,type:text,notnull\"` // Changed from Signal to string\n+\ttypes.TimeAuditable\n+}\n+\n+type SignalFilters struct {\n+\tSignal  Signal            `json:\"signal\"`\n+\tFilters []v3.AttributeKey `json:\"filters\"`\n+}\n+\n+type UpdatableQuickFilters struct {\n+\tSignal  Signal            `json:\"signal\"`\n+\tFilters []v3.AttributeKey `json:\"filters\"`\n+}\n+\n+// Validate checks if the quick filter update request is valid\n+func (u *UpdatableQuickFilters) Validate() error {\n+\t// Validate signal\n+\tif !IsValidSignal(u.Signal.StringValue()) {\n+\t\treturn fmt.Errorf(\"invalid signal: %s\", u.Signal.StringValue())\n+\t}\n+\n+\t// Validate each filter\n+\tfor _, filter := range u.Filters {\n+\t\tif err := filter.Validate(); err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid filter: %v\", err)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func NewDefaultQuickFilter(orgID valuer.UUID) []*StorableQuickFilter {\n+\t// Define filters for TRACES\n+\ttracesFilters := []map[string]interface{}{\n+\t\t{\"key\": \"deployment.environment\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"hasError\", \"dataType\": \"bool\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"serviceName\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"rpcMethod\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"responseStatusCode\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpHost\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpMethod\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpRoute\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"httpUrl\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"traceID\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t}\n+\n+\t// Define filters for LOGS\n+\tlogsFilters := []map[string]interface{}{\n+\t\t{\"key\": \"severity_text\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"deployment.environment\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"serviceName\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"host.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.cluster.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.deployment.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.namespace.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"k8s.pod.name\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t}\n+\n+\t// Define filters for API_MONITORING\n+\tapiMonitoringFilters := []map[string]interface{}{\n+\t\t{\"key\": \"deployment.environment\", \"dataType\": \"string\", \"type\": \"resource\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"serviceName\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t\t{\"key\": \"rpcMethod\", \"dataType\": \"string\", \"type\": \"tag\", \"isColumn\": false, \"isJSON\": false},\n+\t}\n+\n+\t// Convert to JSON strings\n+\ttracesJSON, _ := json.Marshal(tracesFilters)\n+\tlogsJSON, _ := json.Marshal(logsFilters)\n+\tapiMonitoringJSON, _ := json.Marshal(apiMonitoringFilters)",
        "comment_created_at": "2025-04-29T10:34:04+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Please error check here and return an error. Even if you are 100% sure, it won't return an error, it's good practice to always error check.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070115475",
    "pr_number": 7712,
    "pr_file": "pkg/modules/quickfilter/api.go",
    "created_at": "2025-05-01T10:01:38+00:00",
    "commented_code": "+package quickfilter\n+\n+import (\n+\t\"encoding/json\"\n+\terrorsV2 \"github.com/SigNoz/signoz/pkg/errors\"\n+\t\"github.com/SigNoz/signoz/pkg/http/render\"\n+\t\"github.com/SigNoz/signoz/pkg/types/authtypes\"\n+\t\"github.com/SigNoz/signoz/pkg/types/quickfiltertypes\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+\t\"github.com/gorilla/mux\"\n+\t\"net/http\"\n+)\n+\n+type API interface {\n+\tGetQuickFilters(http.ResponseWriter, *http.Request)\n+\tUpdateQuickFilters(http.ResponseWriter, *http.Request)\n+\tGetSignalFilters(http.ResponseWriter, *http.Request)\n+}\n+\n+type quickFiltersAPI struct {\n+\tusecase Usecase\n+}\n+\n+func NewAPI(usecase Usecase) API {\n+\treturn &quickFiltersAPI{usecase: usecase}\n+}\n+\n+func (q *quickFiltersAPI) GetQuickFilters(rw http.ResponseWriter, r *http.Request) {\n+\tclaims, ok := authtypes.ClaimsFromContext(r.Context())\n+\tif ok != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeUnauthenticated, errorsV2.CodeUnauthenticated, \"unauthenticated\"))\n+\t\treturn\n+\t}\n+\n+\tfilters, err := q.usecase.GetQuickFilters(r.Context(), valuer.MustNewUUID(claims.OrgID))\n+\tif err != nil {\n+\t\trender.Error(rw, err)\n+\t\treturn\n+\t}\n+\n+\trender.Success(rw, http.StatusOK, filters)\n+}\n+\n+func (q *quickFiltersAPI) UpdateQuickFilters(rw http.ResponseWriter, r *http.Request) {\n+\tclaims, ok := authtypes.ClaimsFromContext(r.Context())\n+\tif ok != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeUnauthenticated, errorsV2.CodeUnauthenticated, \"unauthenticated\"))\n+\t\treturn\n+\t}\n+\n+\tvar req quickfiltertypes.UpdatableQuickFilters\n+\terr := json.NewDecoder(r.Body).Decode(&req)\n+\tif err != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeInvalidInput, errorsV2.CodeInvalidInput, \"invalid request body: %v\", err))\n+\t\treturn\n+\t}\n+\n+\terr = q.usecase.UpdateQuickFilters(r.Context(), valuer.MustNewUUID(claims.OrgID), req.Signal, req.Filters)\n+\tif err != nil {\n+\t\trender.Error(rw, err)\n+\t\treturn\n+\t}\n+\n+\trender.Success(rw, http.StatusNoContent, nil)\n+}\n+\n+func (q *quickFiltersAPI) GetSignalFilters(rw http.ResponseWriter, r *http.Request) {\n+\tclaims, ok := authtypes.ClaimsFromContext(r.Context())\n+\tif ok != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeUnauthenticated, errorsV2.CodeUnauthenticated, \"unauthenticated\"))\n+\t\treturn\n+\t}\n+\n+\tsignal := mux.Vars(r)[\"signal\"]\n+\tvalidatedSignal, _ := quickfiltertypes.NewSignal(signal)",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2070115475",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7712,
        "pr_file": "pkg/modules/quickfilter/api.go",
        "discussion_id": "2070115475",
        "commented_code": "@@ -0,0 +1,84 @@\n+package quickfilter\n+\n+import (\n+\t\"encoding/json\"\n+\terrorsV2 \"github.com/SigNoz/signoz/pkg/errors\"\n+\t\"github.com/SigNoz/signoz/pkg/http/render\"\n+\t\"github.com/SigNoz/signoz/pkg/types/authtypes\"\n+\t\"github.com/SigNoz/signoz/pkg/types/quickfiltertypes\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+\t\"github.com/gorilla/mux\"\n+\t\"net/http\"\n+)\n+\n+type API interface {\n+\tGetQuickFilters(http.ResponseWriter, *http.Request)\n+\tUpdateQuickFilters(http.ResponseWriter, *http.Request)\n+\tGetSignalFilters(http.ResponseWriter, *http.Request)\n+}\n+\n+type quickFiltersAPI struct {\n+\tusecase Usecase\n+}\n+\n+func NewAPI(usecase Usecase) API {\n+\treturn &quickFiltersAPI{usecase: usecase}\n+}\n+\n+func (q *quickFiltersAPI) GetQuickFilters(rw http.ResponseWriter, r *http.Request) {\n+\tclaims, ok := authtypes.ClaimsFromContext(r.Context())\n+\tif ok != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeUnauthenticated, errorsV2.CodeUnauthenticated, \"unauthenticated\"))\n+\t\treturn\n+\t}\n+\n+\tfilters, err := q.usecase.GetQuickFilters(r.Context(), valuer.MustNewUUID(claims.OrgID))\n+\tif err != nil {\n+\t\trender.Error(rw, err)\n+\t\treturn\n+\t}\n+\n+\trender.Success(rw, http.StatusOK, filters)\n+}\n+\n+func (q *quickFiltersAPI) UpdateQuickFilters(rw http.ResponseWriter, r *http.Request) {\n+\tclaims, ok := authtypes.ClaimsFromContext(r.Context())\n+\tif ok != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeUnauthenticated, errorsV2.CodeUnauthenticated, \"unauthenticated\"))\n+\t\treturn\n+\t}\n+\n+\tvar req quickfiltertypes.UpdatableQuickFilters\n+\terr := json.NewDecoder(r.Body).Decode(&req)\n+\tif err != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeInvalidInput, errorsV2.CodeInvalidInput, \"invalid request body: %v\", err))\n+\t\treturn\n+\t}\n+\n+\terr = q.usecase.UpdateQuickFilters(r.Context(), valuer.MustNewUUID(claims.OrgID), req.Signal, req.Filters)\n+\tif err != nil {\n+\t\trender.Error(rw, err)\n+\t\treturn\n+\t}\n+\n+\trender.Success(rw, http.StatusNoContent, nil)\n+}\n+\n+func (q *quickFiltersAPI) GetSignalFilters(rw http.ResponseWriter, r *http.Request) {\n+\tclaims, ok := authtypes.ClaimsFromContext(r.Context())\n+\tif ok != nil {\n+\t\trender.Error(rw, errorsV2.Newf(errorsV2.TypeUnauthenticated, errorsV2.CodeUnauthenticated, \"unauthenticated\"))\n+\t\treturn\n+\t}\n+\n+\tsignal := mux.Vars(r)[\"signal\"]\n+\tvalidatedSignal, _ := quickfiltertypes.NewSignal(signal)",
        "comment_created_at": "2025-05-01T10:01:38+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "```suggestion\r\n\tvalidatedSignal, err := quickfiltertypes.NewSignal(signal)\r\n\tif err != nil {\r\n\t        render.Error(rw, err)\r\n\t\treturn\r\n\t}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070928632",
    "pr_number": 7712,
    "pr_file": "pkg/modules/quickfilter/core/store.go",
    "created_at": "2025-05-01T23:35:25+00:00",
    "commented_code": "+package core\n+\n+import (\n+\t\"context\"\n+\t\"database/sql\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types/quickfiltertypes\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+)\n+\n+type store struct {\n+\tstore sqlstore.SQLStore\n+}\n+\n+// NewStore creates a new SQLite store for quick filters\n+func NewStore(db sqlstore.SQLStore) quickfiltertypes.QuickFilterStore {\n+\treturn &store{store: db}\n+}\n+\n+// GetQuickFilters retrieves all filters for an organization\n+func (s *store) Get(ctx context.Context, orgID valuer.UUID) ([]*quickfiltertypes.StorableQuickFilter, error) {\n+\tfilters := make([]*quickfiltertypes.StorableQuickFilter, 0)\n+\n+\terr := s.store.\n+\t\tBunDB().\n+\t\tNewSelect().\n+\t\tModel(&filters).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tOrder(\"signal ASC\").\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\treturn filters, err\n+\t}\n+\n+\treturn filters, nil\n+}\n+\n+// GetSignalFilters retrieves filters for a specific signal in an organization\n+func (s *store) GetBySignal(ctx context.Context, orgID valuer.UUID, signal string) (*quickfiltertypes.StorableQuickFilter, error) {\n+\tfilter := new(quickfiltertypes.StorableQuickFilter)\n+\n+\terr := s.store.\n+\t\tBunDB().\n+\t\tNewSelect().\n+\t\tModel(filter).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tWhere(\"signal = ?\", signal).\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\tif err == sql.ErrNoRows {\n+\t\t\treturn nil, nil",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2070928632",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7712,
        "pr_file": "pkg/modules/quickfilter/core/store.go",
        "discussion_id": "2070928632",
        "commented_code": "@@ -0,0 +1,85 @@\n+package core\n+\n+import (\n+\t\"context\"\n+\t\"database/sql\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types/quickfiltertypes\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+)\n+\n+type store struct {\n+\tstore sqlstore.SQLStore\n+}\n+\n+// NewStore creates a new SQLite store for quick filters\n+func NewStore(db sqlstore.SQLStore) quickfiltertypes.QuickFilterStore {\n+\treturn &store{store: db}\n+}\n+\n+// GetQuickFilters retrieves all filters for an organization\n+func (s *store) Get(ctx context.Context, orgID valuer.UUID) ([]*quickfiltertypes.StorableQuickFilter, error) {\n+\tfilters := make([]*quickfiltertypes.StorableQuickFilter, 0)\n+\n+\terr := s.store.\n+\t\tBunDB().\n+\t\tNewSelect().\n+\t\tModel(&filters).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tOrder(\"signal ASC\").\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\treturn filters, err\n+\t}\n+\n+\treturn filters, nil\n+}\n+\n+// GetSignalFilters retrieves filters for a specific signal in an organization\n+func (s *store) GetBySignal(ctx context.Context, orgID valuer.UUID, signal string) (*quickfiltertypes.StorableQuickFilter, error) {\n+\tfilter := new(quickfiltertypes.StorableQuickFilter)\n+\n+\terr := s.store.\n+\t\tBunDB().\n+\t\tNewSelect().\n+\t\tModel(filter).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tWhere(\"signal = ?\", signal).\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\tif err == sql.ErrNoRows {\n+\t\t\treturn nil, nil",
        "comment_created_at": "2025-05-01T23:35:25+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "```suggestion\r\nreturn nil, sqlstore.WrapNotFoundf(...)\r\n```\r\n\r\nIn go, a caller expects an error to be present. If the error is not nil, the caller will expect the next argument to be not-nil.\r\n\r\nIf you want to do something specfically on `NotFound`, use the `sqlstore.WrapNotFoundf` function. Then on the caller side, use `errors.Ast(err, errors.TypeNotFound)` to do something meaningful.",
        "pr_file_module": null
      }
    ]
  }
]