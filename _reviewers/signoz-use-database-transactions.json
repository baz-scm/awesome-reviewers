[
  {
    "discussion_id": "2239946306",
    "pr_number": 8633,
    "pr_file": "pkg/modules/tracefunnel/impltracefunnel/store.go",
    "created_at": "2025-07-29T14:01:47+00:00",
    "commented_code": "// Update updates an existing funnel\n func (store *store) Update(ctx context.Context, funnel *traceFunnels.StorableFunnel) error {\n+\t// Check if a funnel with the same name already exists in the organization (excluding current funnel)\n+\texists, err := store.",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2239946306",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8633,
        "pr_file": "pkg/modules/tracefunnel/impltracefunnel/store.go",
        "discussion_id": "2239946306",
        "commented_code": "@@ -66,17 +67,32 @@ func (store *store) Get(ctx context.Context, uuid valuer.UUID, orgID valuer.UUID\n \n // Update updates an existing funnel\n func (store *store) Update(ctx context.Context, funnel *traceFunnels.StorableFunnel) error {\n+\t// Check if a funnel with the same name already exists in the organization (excluding current funnel)\n+\texists, err := store.",
        "comment_created_at": "2025-07-29T14:01:47+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "better to use a bun transaction, and complete the thing in a single transaction, i.e checking and creating",
        "pr_file_module": null
      },
      {
        "comment_id": "2239957524",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8633,
        "pr_file": "pkg/modules/tracefunnel/impltracefunnel/store.go",
        "discussion_id": "2239946306",
        "commented_code": "@@ -66,17 +67,32 @@ func (store *store) Get(ctx context.Context, uuid valuer.UUID, orgID valuer.UUID\n \n // Update updates an existing funnel\n func (store *store) Update(ctx context.Context, funnel *traceFunnels.StorableFunnel) error {\n+\t// Check if a funnel with the same name already exists in the organization (excluding current funnel)\n+\texists, err := store.",
        "comment_created_at": "2025-07-29T14:04:11+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "eg:- https://github.com/SigNoz/signoz/blob/a3c039006f913ee62fd5a3ebcff0cdc757d6d823/pkg/modules/user/impluser/store.go#L310",
        "pr_file_module": null
      },
      {
        "comment_id": "2240285695",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8633,
        "pr_file": "pkg/modules/tracefunnel/impltracefunnel/store.go",
        "discussion_id": "2239946306",
        "commented_code": "@@ -66,17 +67,32 @@ func (store *store) Get(ctx context.Context, uuid valuer.UUID, orgID valuer.UUID\n \n // Update updates an existing funnel\n func (store *store) Update(ctx context.Context, funnel *traceFunnels.StorableFunnel) error {\n+\t// Check if a funnel with the same name already exists in the organization (excluding current funnel)\n+\texists, err := store.",
        "comment_created_at": "2025-07-29T15:52:19+00:00",
        "comment_author": "ankitnayan",
        "comment_body": "There is no need to use a transaction. Transactions are needed when you do multiple operations to the DB and you want them to suceed or fail together. The above usecase handles the error on their own and there is no need to bundle the operations as a transaction",
        "pr_file_module": null
      },
      {
        "comment_id": "2240303362",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8633,
        "pr_file": "pkg/modules/tracefunnel/impltracefunnel/store.go",
        "discussion_id": "2239946306",
        "commented_code": "@@ -66,17 +67,32 @@ func (store *store) Get(ctx context.Context, uuid valuer.UUID, orgID valuer.UUID\n \n // Update updates an existing funnel\n func (store *store) Update(ctx context.Context, funnel *traceFunnels.StorableFunnel) error {\n+\t// Check if a funnel with the same name already exists in the organization (excluding current funnel)\n+\texists, err := store.",
        "comment_created_at": "2025-07-29T15:58:21+00:00",
        "comment_author": "ankitnayan",
        "comment_body": "I checked with AI and it is still recommending to use tx to avoid race conditions. Added to both `Create` and `Update` method",
        "pr_file_module": null
      },
      {
        "comment_id": "2240305586",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 8633,
        "pr_file": "pkg/modules/tracefunnel/impltracefunnel/store.go",
        "discussion_id": "2239946306",
        "commented_code": "@@ -66,17 +67,32 @@ func (store *store) Get(ctx context.Context, uuid valuer.UUID, orgID valuer.UUID\n \n // Update updates an existing funnel\n func (store *store) Update(ctx context.Context, funnel *traceFunnels.StorableFunnel) error {\n+\t// Check if a funnel with the same name already exists in the organization (excluding current funnel)\n+\texists, err := store.",
        "comment_created_at": "2025-07-29T15:59:06+00:00",
        "comment_author": "nityanandagohain",
        "comment_body": "Yeah okay, if we did something after exists then we would have required.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2087542980",
    "pr_number": 7778,
    "pr_file": "pkg/modules/user/impluser/store.go",
    "created_at": "2025-05-13T20:03:42+00:00",
    "commented_code": "+package impluser\n+\n+import (\n+\t\"context\"\n+\t\"database/sql\"\n+\t\"time\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/errors\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+)\n+\n+type Store struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func NewStore(sqlstore sqlstore.SQLStore) types.UserStore {\n+\treturn &Store{sqlstore: sqlstore}\n+}\n+\n+// CreateBulkInvite implements types.InviteStore.\n+func (s *Store) CreateBulkInvite(ctx context.Context, invites []*types.Invite) error {\n+\t_, err := s.sqlstore.BunDB().NewInsert().\n+\t\tModel(&invites).\n+\t\tExec(ctx)\n+\n+\tif err != nil {\n+\t\treturn s.sqlstore.WrapAlreadyExistsErrf(err, types.ErrInviteAlreadyExists, \"invite with email: %s already exists in org: %s\", invites[0].Email, invites[0].OrgID)\n+\t}\n+\treturn nil\n+}\n+\n+// Delete implements types.InviteStore.\n+func (s *Store) DeleteInvite(ctx context.Context, orgID string, id valuer.UUID) error {\n+\t_, err := s.sqlstore.BunDB().NewDelete().\n+\t\tModel(&types.Invite{}).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tWhere(\"id = ?\", id).\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with id: %s does not exist in org: %s\", id.StringValue(), orgID)\n+\t}\n+\treturn nil\n+}\n+\n+// GetInviteByEmailInOrg implements types.InviteStore.\n+func (s *Store) GetInviteByEmailInOrg(ctx context.Context, orgID string, email string) (*types.Invite, error) {\n+\tvar invite types.Invite\n+\terr := s.sqlstore.BunDB().NewSelect().\n+\t\tModel(&invite).\n+\t\tWhere(\"email = ?\", email).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with email: %s does not exist in org: %s\", email, orgID)\n+\t}\n+\n+\treturn &invite, nil\n+}\n+\n+func (s *Store) GetInviteByToken(ctx context.Context, token string) (*types.GettableInvite, error) {\n+\tvar invite types.Invite\n+\terr := s.sqlstore.BunDB().NewSelect().\n+\t\tModel(&invite).\n+\t\tWhere(\"token = ?\", token).\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with token: %s does not exist\", token)\n+\t}\n+\n+\torgName, err := s.getOrgNameByID(ctx, invite.OrgID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tgettableInvite := &types.GettableInvite{\n+\t\tInvite:       invite,\n+\t\tOrganization: orgName,\n+\t}\n+\n+\treturn gettableInvite, nil\n+}\n+\n+func (s *Store) ListInvite(ctx context.Context, orgID string) ([]*types.Invite, error) {\n+\tinvites := []*types.Invite{}\n+\terr := s.sqlstore.BunDB().NewSelect().\n+\t\tModel(&invites).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tScan(ctx)\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with org id: %s does not exist\", orgID)\n+\t}\n+\treturn invites, nil\n+}\n+\n+func (s *Store) CreatePassword(ctx context.Context, password *types.FactorPassword) (*types.FactorPassword, error) {\n+\t_, err := s.sqlstore.BunDB().NewInsert().\n+\t\tModel(password).\n+\t\tExec(ctx)\n+\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapAlreadyExistsErrf(err, types.ErrPasswordAlreadyExists, \"password with user id: %s already exists\", password.UserID)\n+\t}\n+\n+\treturn password, nil\n+}\n+\n+func (s *Store) CreateUserWithPassword(ctx context.Context, user *types.User, password *types.FactorPassword) (*types.User, error) {\n+\ttx, err := s.sqlstore.BunDB().Begin()",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2087542980",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7778,
        "pr_file": "pkg/modules/user/impluser/store.go",
        "discussion_id": "2087542980",
        "commented_code": "@@ -0,0 +1,478 @@\n+package impluser\n+\n+import (\n+\t\"context\"\n+\t\"database/sql\"\n+\t\"time\"\n+\n+\t\"github.com/SigNoz/signoz/pkg/errors\"\n+\t\"github.com/SigNoz/signoz/pkg/sqlstore\"\n+\t\"github.com/SigNoz/signoz/pkg/types\"\n+\t\"github.com/SigNoz/signoz/pkg/valuer\"\n+)\n+\n+type Store struct {\n+\tsqlstore sqlstore.SQLStore\n+}\n+\n+func NewStore(sqlstore sqlstore.SQLStore) types.UserStore {\n+\treturn &Store{sqlstore: sqlstore}\n+}\n+\n+// CreateBulkInvite implements types.InviteStore.\n+func (s *Store) CreateBulkInvite(ctx context.Context, invites []*types.Invite) error {\n+\t_, err := s.sqlstore.BunDB().NewInsert().\n+\t\tModel(&invites).\n+\t\tExec(ctx)\n+\n+\tif err != nil {\n+\t\treturn s.sqlstore.WrapAlreadyExistsErrf(err, types.ErrInviteAlreadyExists, \"invite with email: %s already exists in org: %s\", invites[0].Email, invites[0].OrgID)\n+\t}\n+\treturn nil\n+}\n+\n+// Delete implements types.InviteStore.\n+func (s *Store) DeleteInvite(ctx context.Context, orgID string, id valuer.UUID) error {\n+\t_, err := s.sqlstore.BunDB().NewDelete().\n+\t\tModel(&types.Invite{}).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tWhere(\"id = ?\", id).\n+\t\tExec(ctx)\n+\tif err != nil {\n+\t\treturn s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with id: %s does not exist in org: %s\", id.StringValue(), orgID)\n+\t}\n+\treturn nil\n+}\n+\n+// GetInviteByEmailInOrg implements types.InviteStore.\n+func (s *Store) GetInviteByEmailInOrg(ctx context.Context, orgID string, email string) (*types.Invite, error) {\n+\tvar invite types.Invite\n+\terr := s.sqlstore.BunDB().NewSelect().\n+\t\tModel(&invite).\n+\t\tWhere(\"email = ?\", email).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with email: %s does not exist in org: %s\", email, orgID)\n+\t}\n+\n+\treturn &invite, nil\n+}\n+\n+func (s *Store) GetInviteByToken(ctx context.Context, token string) (*types.GettableInvite, error) {\n+\tvar invite types.Invite\n+\terr := s.sqlstore.BunDB().NewSelect().\n+\t\tModel(&invite).\n+\t\tWhere(\"token = ?\", token).\n+\t\tScan(ctx)\n+\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with token: %s does not exist\", token)\n+\t}\n+\n+\torgName, err := s.getOrgNameByID(ctx, invite.OrgID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tgettableInvite := &types.GettableInvite{\n+\t\tInvite:       invite,\n+\t\tOrganization: orgName,\n+\t}\n+\n+\treturn gettableInvite, nil\n+}\n+\n+func (s *Store) ListInvite(ctx context.Context, orgID string) ([]*types.Invite, error) {\n+\tinvites := []*types.Invite{}\n+\terr := s.sqlstore.BunDB().NewSelect().\n+\t\tModel(&invites).\n+\t\tWhere(\"org_id = ?\", orgID).\n+\t\tScan(ctx)\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapNotFoundErrf(err, types.ErrInviteNotFound, \"invite with org id: %s does not exist\", orgID)\n+\t}\n+\treturn invites, nil\n+}\n+\n+func (s *Store) CreatePassword(ctx context.Context, password *types.FactorPassword) (*types.FactorPassword, error) {\n+\t_, err := s.sqlstore.BunDB().NewInsert().\n+\t\tModel(password).\n+\t\tExec(ctx)\n+\n+\tif err != nil {\n+\t\treturn nil, s.sqlstore.WrapAlreadyExistsErrf(err, types.ErrPasswordAlreadyExists, \"password with user id: %s already exists\", password.UserID)\n+\t}\n+\n+\treturn password, nil\n+}\n+\n+func (s *Store) CreateUserWithPassword(ctx context.Context, user *types.User, password *types.FactorPassword) (*types.User, error) {\n+\ttx, err := s.sqlstore.BunDB().Begin()",
        "comment_created_at": "2025-05-13T20:03:42+00:00",
        "comment_author": "vikrantgupta25",
        "comment_body": "follow the same pattern as in sql migration here. \r\n\r\n```\r\nBeginTx()\r\n....\r\ndefer rollback\r\n...\r\ncommit \r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072416890",
    "pr_number": 7816,
    "pr_file": "pkg/sqlmigration/030_create_quick_filters.go",
    "created_at": "2025-05-03T15:39:22+00:00",
    "commented_code": "return err\n \t}\n \n-\t// For SQLite, insert each filter individually with proper conflict handling\n \tfor _, filter := range storableQuickFilters {\n-\t\t// Check if the record already exists\n-\t\texists, err := tx.NewSelect().\n-\t\t\tModel((*quickFilter)(nil)).\n-\t\t\tWhere(\"org_id = ? AND signal = ?\", filter.OrgID, filter.Signal).\n-\t\t\tExists(ctx)\n+\t\t_, err = tx.NewInsert().\n+\t\t\tModel(filter).\n+\t\t\tExec(ctx)\n+",
    "repo_full_name": "SigNoz/signoz",
    "discussion_comments": [
      {
        "comment_id": "2072416890",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7816,
        "pr_file": "pkg/sqlmigration/030_create_quick_filters.go",
        "discussion_id": "2072416890",
        "commented_code": "@@ -74,27 +74,14 @@ func (m *createQuickFilters) Up(ctx context.Context, db *bun.DB) error {\n \t\treturn err\n \t}\n \n-\t// For SQLite, insert each filter individually with proper conflict handling\n \tfor _, filter := range storableQuickFilters {\n-\t\t// Check if the record already exists\n-\t\texists, err := tx.NewSelect().\n-\t\t\tModel((*quickFilter)(nil)).\n-\t\t\tWhere(\"org_id = ? AND signal = ?\", filter.OrgID, filter.Signal).\n-\t\t\tExists(ctx)\n+\t\t_, err = tx.NewInsert().\n+\t\t\tModel(filter).\n+\t\t\tExec(ctx)\n+",
        "comment_created_at": "2025-05-03T15:39:22+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "Check for alreadyExists error here. If the error is alreadyExists, commit the transaction. Otherwise fail the migration",
        "pr_file_module": null
      },
      {
        "comment_id": "2072416999",
        "repo_full_name": "SigNoz/signoz",
        "pr_number": 7816,
        "pr_file": "pkg/sqlmigration/030_create_quick_filters.go",
        "discussion_id": "2072416890",
        "commented_code": "@@ -74,27 +74,14 @@ func (m *createQuickFilters) Up(ctx context.Context, db *bun.DB) error {\n \t\treturn err\n \t}\n \n-\t// For SQLite, insert each filter individually with proper conflict handling\n \tfor _, filter := range storableQuickFilters {\n-\t\t// Check if the record already exists\n-\t\texists, err := tx.NewSelect().\n-\t\t\tModel((*quickFilter)(nil)).\n-\t\t\tWhere(\"org_id = ? AND signal = ?\", filter.OrgID, filter.Signal).\n-\t\t\tExists(ctx)\n+\t\t_, err = tx.NewInsert().\n+\t\t\tModel(filter).\n+\t\t\tExec(ctx)\n+",
        "comment_created_at": "2025-05-03T15:39:57+00:00",
        "comment_author": "grandwizard28",
        "comment_body": "And no need for a for loop. Insert the entire array as once.",
        "pr_file_module": null
      }
    ]
  }
]