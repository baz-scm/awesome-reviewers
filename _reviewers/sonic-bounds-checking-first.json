[
  {
    "discussion_id": "1243420535",
    "pr_number": 467,
    "pr_file": "native/sort.c",
    "created_at": "2023-06-27T09:25:03+00:00",
    "commented_code": "+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline size_t min(size_t x, size_t y) {\n+    return x > y ? y : x;\n+}\n+\n+static always_inline bool less(MapPair lhs, MapPair rhs) {\n+    size_t index = 0;\n+    size_t size = min(lhs.key.len, rhs.key.len);\n+    while(index < size && *lhs.key.buf && *rhs.key.buf && *lhs.key.buf == *rhs.key.buf) {\n+        lhs.key.buf++, rhs.key.buf++;\n+        index++;\n+    }\n+\n+    return *(unsigned char *)lhs.key.buf - *(unsigned char *)rhs.key.buf < 0;",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243420535",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 467,
        "pr_file": "native/sort.c",
        "discussion_id": "1243420535",
        "commented_code": "@@ -0,0 +1,78 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline size_t min(size_t x, size_t y) {\n+    return x > y ? y : x;\n+}\n+\n+static always_inline bool less(MapPair lhs, MapPair rhs) {\n+    size_t index = 0;\n+    size_t size = min(lhs.key.len, rhs.key.len);\n+    while(index < size && *lhs.key.buf && *rhs.key.buf && *lhs.key.buf == *rhs.key.buf) {\n+        lhs.key.buf++, rhs.key.buf++;\n+        index++;\n+    }\n+\n+    return *(unsigned char *)lhs.key.buf - *(unsigned char *)rhs.key.buf < 0;",
        "comment_created_at": "2023-06-27T09:25:03+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u5728\u76f8\u7b49\u7684size \u5185\u6bd4\u8f83\u5b8c\u4e4b\u540e\uff0c\u8fd9\u91cc\u5982\u679c\u7ee7\u7eed\u505a\u5b57\u7b26\u6bd4\u8f83\uff0c\u4f1a\u51fa\u73b0\u8d8a\u754c\u3002\u8fd9\u91cc\u76f4\u63a5\u53ef\u4ee5\u5f97\u51fa\uff0c\u66f4\u957f\u7684key \u5c31\u662f\u8f83\u5927\u7684\u90a3\u4e2a\u4e86",
        "pr_file_module": null
      },
      {
        "comment_id": "1243745402",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 467,
        "pr_file": "native/sort.c",
        "discussion_id": "1243420535",
        "commented_code": "@@ -0,0 +1,78 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline size_t min(size_t x, size_t y) {\n+    return x > y ? y : x;\n+}\n+\n+static always_inline bool less(MapPair lhs, MapPair rhs) {\n+    size_t index = 0;\n+    size_t size = min(lhs.key.len, rhs.key.len);\n+    while(index < size && *lhs.key.buf && *rhs.key.buf && *lhs.key.buf == *rhs.key.buf) {\n+        lhs.key.buf++, rhs.key.buf++;\n+        index++;\n+    }\n+\n+    return *(unsigned char *)lhs.key.buf - *(unsigned char *)rhs.key.buf < 0;",
        "comment_created_at": "2023-06-27T13:30:20+00:00",
        "comment_author": "Skyseaee",
        "comment_body": "\u6211\u5728\u65b0\u7684commit\u91cc\u52a0\u4e86\u4e00\u4e2a\u5224\u65ad",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1243570692",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-27T11:17:53+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243570692",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1243570692",
        "commented_code": "@@ -0,0 +1,279 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  ",
        "comment_created_at": "2023-06-27T11:17:53+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u8fd9\u91cc\u9700\u8981\u5148\u5224\u65ad\u8d8a\u754c\uff0c\u7136\u540e\u518d\u5224\u65ad\u662f\u5426\u662f\u7a7a\u683c\u3002\u4f8b\u5982 while(!is_overflow(xxx) && is_space()), \u540e\u7eed\u68c0\u6d4b\u7a7a\u683c\u7684\u5730\u65b9\u90fd\u662f\u7c7b\u4f3c\u8fd9\u6837\u7684",
        "pr_file_module": null
      }
    ]
  }
]