[
  {
    "discussion_id": "1242259444",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-26T14:04:37+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+\n+\n+bool isSpace(char a){\n+    if( a == ' '){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool isInteger(char a){\n+\tif(a<'0' ||a>'9'){\n+\t\treturn false;\n+\t}else{\n+\t\treturn true;\n+\t}\n+}\n+\n+int charToNum(char c){\n+\treturn c-'0';\n+}\n+\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =0;\n+    \n+    while(isSpace(pos[i])){                                          //If there is a space before the beginning, eat the space first \n+    \ti++;                           \n+\t}\n+    if(pos[i] != '['){                                               //If the first one is not a left bracket, returning it directly is illegal\n+        *p = i+1;                                                    //P points to the first position after the error \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    i++;                                                             //It's a left parenthesis\n+    int k =0;                                                        //K+1 represents the number of digits in the string src\n+    int num = 0;                                                     //Num is used to store the current number \n+    while(pos[i] !='\\0'){\n+        if(k==arr->cap){                                             //If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        \t*p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        while(isSpace(pos[i])){                                      //Jump back if it's a space \n+        \ti++;             \n+\t\t}\n+\t\tif(pos[i]<'0' || pos[i]>'9'){\n+\t\t\t*p = i+1;                                    //P points to the first position after the error \n+        \tarr->len = 0;\n+\t\t\treturn ERR_INVAL;                            //The first one is not a number, it must be illegal \n+\t\t}else{\n+\t\t\tnum = charToNum(pos[i]); \n+\t\t} \n+\t\t    \n+\t\ti++; \n+\t\twhile(!isSpace(pos[i])&& pos[i] !=','){                         \n+\t\t \t  \n+\t\t\t//If it is not followed by a space or a comma, it indicates that it is a number or an error has occurred\n+\t\t\t if(isInteger(pos[i])){\t\t \t\t\n+\t\t \t\tnum = num*10 + charToNum(pos[i]);\n+        \t\ti++;\t\t\n+\t\t\t}else if(pos[i] ==']'){                      //If the right bracket is used, it can be closed and a value can be returned \n+\t\t\t\t(arr->uptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t\t}else{\n+\t\t\t\n+\t\t\t//If it's not a number or a comma, it's an error. Point to the position after the error and return ERR_ INVAL \n+\t\t\t\t*p = i+1;                                               \n+        \t\tarr->len = 0;\n+        \t\treturn ERR_INVAL;\n+\t\t\t} \n+\t\t}\n+\t\twhile(isSpace(pos[i])){\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] ==']'){\n+\t\t\t(arr->uptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t}\n+\t\tif(isInteger(pos[i])){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;\n+\t\t}\n+\t\tif(pos[i] ==','){                                                //If it's a comma, put it away \n+\t\t\t(arr->uptr)[k] = num; \n+\t\t\tk++;\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] =='\\0'){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;\n+\t\t}\t\t\t \t\t\t             \n+    }\n+}\n+\n+long decode_i64_array(const GoString* src, long* p, GoIntSlice* arr){   \n+\tchar* pos = src->buf;\n+\tint i =0;\n+\t    \n+\twhile(isSpace(pos[i])){                                             \n+\t    i++;                           \n+\t} \n+    if(pos[i] != '['){                                                  \n+        *p = i+1;                                                       \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    i++;                                                                \n+    int k =0;                                                          \n+    int num = 0;                                                        \n+    char flag ='+';                                              //Define a flag to represent the symbol of a signed number\n+    while(pos[i] !=0){\n+        if(k==arr->cap){                                                \n+        \t*p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        while(isSpace(pos[i])){                                         \n+        \ti++;             \n+\t\t}\n+\t\tif((pos[i]<'0' || pos[i]>'9') && (pos[i]!='+' && pos[i]!='-' )){\n+\t\t\t\n+\t\t\t*p = i+1;                                                   \n+        \tarr->len = 0;\n+\t\t\treturn ERR_INVAL;                        //The first one is neither a number nor a Plus\ufffdCminus sign, so it must be illegal \n+\t\t}else if(pos[i]=='+' || pos[i]=='-'){\n+\t\t\t\n+\t\t//If it is a symbol, then the symbol is fixed, and the first digit immediately after it is also stored in num and i+1 \n+\t\t\tflag =  pos[i];                           \n+\t\t\ti++;\n+\t\t\tnum = charToNum(pos[i]);\n+\t\t\t\n+\t\t}else{\n+\t\t\tnum = charToNum(pos[i]);            \n+\t\t} \n+\t\t    \n+\t\ti++; \n+\t\twhile(!isSpace(pos[i])&& pos[i] !=','){                          \n+\t\t \tif(isInteger(pos[i])){\n+\t\t \t\t\n+\t\t \t\tnum = num*10 + charToNum(pos[i]);\n+        \t\ti++;\t\t\n+\t\t\t}else if(pos[i] ==']'){                                     \n+\t\t\t    if(flag =='-'){\n+\t\t\t    \tnum = -(num);\n+\t\t\t\t}\n+\t\t\t\t(arr->iptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t\t}else{\n+\t\t\t\t*p = i+1;                                                \n+        \t\tarr->len = 0;\n+        \t\treturn ERR_INVAL;\n+\t\t\t} \n+\t\t} \n+\t\twhile(isSpace(pos[i])){\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] ==']'){\n+\t\t\t(arr->uptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t}\n+\t\tif(isInteger(pos[i])){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;\n+\t\t}\n+\t\tif(pos[i] ==','){                                                \n+\t\t\t\n+\t\t\tif(flag =='-'){\n+\t\t\t    num = -(num);\n+\t\t\t}\n+\t\t\t(arr->iptr)[k] = num; \n+\t\t\tk++;\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] =='\\0'){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1242259444",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1242259444",
        "commented_code": "@@ -0,0 +1,215 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+\n+\n+bool isSpace(char a){\n+    if( a == ' '){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool isInteger(char a){\n+\tif(a<'0' ||a>'9'){\n+\t\treturn false;\n+\t}else{\n+\t\treturn true;\n+\t}\n+}\n+\n+int charToNum(char c){\n+\treturn c-'0';\n+}\n+\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =0;\n+    \n+    while(isSpace(pos[i])){                                          //If there is a space before the beginning, eat the space first \n+    \ti++;                           \n+\t}\n+    if(pos[i] != '['){                                               //If the first one is not a left bracket, returning it directly is illegal\n+        *p = i+1;                                                    //P points to the first position after the error \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    i++;                                                             //It's a left parenthesis\n+    int k =0;                                                        //K+1 represents the number of digits in the string src\n+    int num = 0;                                                     //Num is used to store the current number \n+    while(pos[i] !='\\0'){\n+        if(k==arr->cap){                                             //If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        \t*p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        while(isSpace(pos[i])){                                      //Jump back if it's a space \n+        \ti++;             \n+\t\t}\n+\t\tif(pos[i]<'0' || pos[i]>'9'){\n+\t\t\t*p = i+1;                                    //P points to the first position after the error \n+        \tarr->len = 0;\n+\t\t\treturn ERR_INVAL;                            //The first one is not a number, it must be illegal \n+\t\t}else{\n+\t\t\tnum = charToNum(pos[i]); \n+\t\t} \n+\t\t    \n+\t\ti++; \n+\t\twhile(!isSpace(pos[i])&& pos[i] !=','){                         \n+\t\t \t  \n+\t\t\t//If it is not followed by a space or a comma, it indicates that it is a number or an error has occurred\n+\t\t\t if(isInteger(pos[i])){\t\t \t\t\n+\t\t \t\tnum = num*10 + charToNum(pos[i]);\n+        \t\ti++;\t\t\n+\t\t\t}else if(pos[i] ==']'){                      //If the right bracket is used, it can be closed and a value can be returned \n+\t\t\t\t(arr->uptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t\t}else{\n+\t\t\t\n+\t\t\t//If it's not a number or a comma, it's an error. Point to the position after the error and return ERR_ INVAL \n+\t\t\t\t*p = i+1;                                               \n+        \t\tarr->len = 0;\n+        \t\treturn ERR_INVAL;\n+\t\t\t} \n+\t\t}\n+\t\twhile(isSpace(pos[i])){\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] ==']'){\n+\t\t\t(arr->uptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t}\n+\t\tif(isInteger(pos[i])){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;\n+\t\t}\n+\t\tif(pos[i] ==','){                                                //If it's a comma, put it away \n+\t\t\t(arr->uptr)[k] = num; \n+\t\t\tk++;\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] =='\\0'){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;\n+\t\t}\t\t\t \t\t\t             \n+    }\n+}\n+\n+long decode_i64_array(const GoString* src, long* p, GoIntSlice* arr){   \n+\tchar* pos = src->buf;\n+\tint i =0;\n+\t    \n+\twhile(isSpace(pos[i])){                                             \n+\t    i++;                           \n+\t} \n+    if(pos[i] != '['){                                                  \n+        *p = i+1;                                                       \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    i++;                                                                \n+    int k =0;                                                          \n+    int num = 0;                                                        \n+    char flag ='+';                                              //Define a flag to represent the symbol of a signed number\n+    while(pos[i] !=0){\n+        if(k==arr->cap){                                                \n+        \t*p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        while(isSpace(pos[i])){                                         \n+        \ti++;             \n+\t\t}\n+\t\tif((pos[i]<'0' || pos[i]>'9') && (pos[i]!='+' && pos[i]!='-' )){\n+\t\t\t\n+\t\t\t*p = i+1;                                                   \n+        \tarr->len = 0;\n+\t\t\treturn ERR_INVAL;                        //The first one is neither a number nor a Plus\ufffdCminus sign, so it must be illegal \n+\t\t}else if(pos[i]=='+' || pos[i]=='-'){\n+\t\t\t\n+\t\t//If it is a symbol, then the symbol is fixed, and the first digit immediately after it is also stored in num and i+1 \n+\t\t\tflag =  pos[i];                           \n+\t\t\ti++;\n+\t\t\tnum = charToNum(pos[i]);\n+\t\t\t\n+\t\t}else{\n+\t\t\tnum = charToNum(pos[i]);            \n+\t\t} \n+\t\t    \n+\t\ti++; \n+\t\twhile(!isSpace(pos[i])&& pos[i] !=','){                          \n+\t\t \tif(isInteger(pos[i])){\n+\t\t \t\t\n+\t\t \t\tnum = num*10 + charToNum(pos[i]);\n+        \t\ti++;\t\t\n+\t\t\t}else if(pos[i] ==']'){                                     \n+\t\t\t    if(flag =='-'){\n+\t\t\t    \tnum = -(num);\n+\t\t\t\t}\n+\t\t\t\t(arr->iptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t\t}else{\n+\t\t\t\t*p = i+1;                                                \n+        \t\tarr->len = 0;\n+        \t\treturn ERR_INVAL;\n+\t\t\t} \n+\t\t} \n+\t\twhile(isSpace(pos[i])){\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] ==']'){\n+\t\t\t(arr->uptr)[k] = num;\n+\t\t\t\tarr->len = k+1;\n+\t\t\t\t*p = i+1;\n+\t\t\t\treturn 0;\n+\t\t}\n+\t\tif(isInteger(pos[i])){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;\n+\t\t}\n+\t\tif(pos[i] ==','){                                                \n+\t\t\t\n+\t\t\tif(flag =='-'){\n+\t\t\t    num = -(num);\n+\t\t\t}\n+\t\t\t(arr->iptr)[k] = num; \n+\t\t\tk++;\n+\t\t\ti++;\n+\t\t}\n+\t\tif(pos[i] =='\\0'){\n+\t\t\t*p = i+1;\n+\t\t\tarr->len = 0;\n+\t\t\treturn ERR_INVAL;",
        "comment_created_at": "2023-06-26T14:04:37+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u7f29\u8fdb\u9700\u8981\u7edf\u4e00\uff0c\u548cunittest\u91cc\u9762\u5bf9\u9f50\uff0c\u90fd\u6309 4\u4e2a\u7a7a\u683c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1243577999",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-27T11:24:22+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   \n+    \t//If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        if(k==arr->cap){                                     \n+            *p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        //Jump back if it's a space\n+        while(is_space(pos[i])){     \n+            i++;             \n+\t    }",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243577999",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1243577999",
        "commented_code": "@@ -0,0 +1,279 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   \n+    \t//If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        if(k==arr->cap){                                     \n+            *p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        //Jump back if it's a space\n+        while(is_space(pos[i])){     \n+            i++;             \n+\t    }",
        "comment_created_at": "2023-06-27T11:24:22+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u4ee3\u7801\u5757\u9700\u8981\u5bf9\u9f50\uff0c } \u62ec\u53f7\u8981\u5bf9\u9f50\u5230 while",
        "pr_file_module": null
      }
    ]
  }
]