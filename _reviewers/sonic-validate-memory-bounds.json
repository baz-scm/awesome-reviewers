[
  {
    "discussion_id": "1242120747",
    "pr_number": 467,
    "pr_file": "native/sort.c",
    "created_at": "2023-06-26T12:31:47+00:00",
    "commented_code": "+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline int _strcmp(const char *p,const char *q){\n+    while(*p && *q && *p == *q) {",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1242120747",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 467,
        "pr_file": "native/sort.c",
        "discussion_id": "1242120747",
        "commented_code": "@@ -0,0 +1,75 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline int _strcmp(const char *p,const char *q){\n+    while(*p && *q && *p == *q) {",
        "comment_created_at": "2023-06-26T12:31:47+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u8fd9\u91cc\u4ecd\u7136\u53ef\u80fd\u6709\u8d8a\u754c\u8bbf\u95ee\uff0c\u4f8b\u5982 p \u548c q \u662f\u5b8c\u5168\u76f8\u7b49\u7684key\uff0c\u540c\u65f6\u4e0d\u4ee5 '\\0' \u7ed3\u5c3e\uff0c\u90a3\u4e48\u5c31\u4f1a\u8bbf\u95ee\u5230\u8d8a\u754c\u7684\u5185\u5b58\u3002\u53ef\u4ee5\u5148\u5224\u65ad\u662f\u5426\u8d85\u8fc7 key.len, \u907f\u514d\u8d8a\u754c\u8bbf\u95ee",
        "pr_file_module": null
      },
      {
        "comment_id": "1242126792",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 467,
        "pr_file": "native/sort.c",
        "discussion_id": "1242120747",
        "commented_code": "@@ -0,0 +1,75 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline int _strcmp(const char *p,const char *q){\n+    while(*p && *q && *p == *q) {",
        "comment_created_at": "2023-06-26T12:37:07+00:00",
        "comment_author": "Skyseaee",
        "comment_body": "thanks, i will fix that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1243083589",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 467,
        "pr_file": "native/sort.c",
        "discussion_id": "1242120747",
        "commented_code": "@@ -0,0 +1,75 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+static always_inline int _strcmp(const char *p,const char *q){\n+    while(*p && *q && *p == *q) {",
        "comment_created_at": "2023-06-27T03:01:51+00:00",
        "comment_author": "liuq19",
        "comment_body": "ok, thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1243079393",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-27T02:52:18+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+\n+\n+bool isSpace(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool isInteger(char a){\n+    if(a<'0' ||a>'9'){\n+\treturn false;\n+    }else{\n+\treturn true;\n+    }\n+}\n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =0;",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243079393",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1243079393",
        "commented_code": "@@ -0,0 +1,210 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+\n+\n+bool isSpace(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool isInteger(char a){\n+    if(a<'0' ||a>'9'){\n+\treturn false;\n+    }else{\n+\treturn true;\n+    }\n+}\n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =0;",
        "comment_created_at": "2023-06-27T02:52:18+00:00",
        "comment_author": "liuq19",
        "comment_body": "i \u5e94\u8be5\u662f\u4ece *p \u7684\u4f4d\u7f6e\u5f00\u59cb\u7684\uff0c\u540e\u9762\u6bcf\u6b21\u89e3\u6790\u65f6\u9700\u8981\u5224\u65ad i \u662f\u5426\u8d85\u8fc7 src->len\uff0c \u9632\u6b62\u5185\u5b58\u8bbf\u95ee\u8d8a\u754c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1243573111",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-27T11:19:53+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243573111",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1243573111",
        "commented_code": "@@ -0,0 +1,279 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   ",
        "comment_created_at": "2023-06-27T11:19:53+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u8fd9\u91cc\u4e0d\u80fd\u7528 '\\0' \u5224\u65ad\u662f\u5426json \u7ed3\u675f\uff0const GoString* src\uff0c src\u4e2d\u5df2\u7ecf\u6709len\u6210\u5458\u8868\u793ajson\u957f\u5ea6\u4e86",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1243577076",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-27T11:23:41+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   \n+    \t//If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        if(k==arr->cap){                                     \n+            *p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        //Jump back if it's a space\n+        while(is_space(pos[i])){",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243577076",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1243577076",
        "commented_code": "@@ -0,0 +1,279 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   \n+    \t//If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        if(k==arr->cap){                                     \n+            *p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        //Jump back if it's a space\n+        while(is_space(pos[i])){     ",
        "comment_created_at": "2023-06-27T11:23:41+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u540c\u6837\u9700\u8981\u5148\u5224\u65ad\u662f\u5426\u8d8a\u754c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1243581032",
    "pr_number": 455,
    "pr_file": "native/goIntSlice.c",
    "created_at": "2023-06-27T11:26:20+00:00",
    "commented_code": "+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   \n+    \t//If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        if(k==arr->cap){                                     \n+            *p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        //Jump back if it's a space\n+        while(is_space(pos[i])){     \n+            i++;             \n+\t    }\n+\t    if(is_overflow(i,src->len)){\n+\t        *p = i;\n+\t        arr->len = 0;\n+\t        return ERR_INVAL;\n+\t    }\n+\t    //The first one is not a number, it must be illegal\n+\t    if(pos[i]<'0' || pos[i]>'9'){\n+\t\t*p = i;                                     \n+        \tarr->len = 0;\n+\t\treturn ERR_INVAL;                             \n+\t    }else{\n+\t\tnum = char_to_num(pos[i]); \n+\t    } \t    \n+\t    i++; \n+\t    while(!is_space(pos[i])&& pos[i] !=','){",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1243581032",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 455,
        "pr_file": "native/goIntSlice.c",
        "discussion_id": "1243581032",
        "commented_code": "@@ -0,0 +1,279 @@\n+#include <stdio.h>\n+#include <malloc.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"native.h\"\n+#include \"types.h\"\n+\n+#define ERR_INVAL       2\n+#define ERR_RECURSE_MAX 7\n+\n+typedef struct {\n+    union {                    // the pointer of u64 or i64 array \n+        int64_t*  iptr;\n+        uint64_t* uptr; \n+    };\n+    size_t len;                // the length of slice\n+    size_t cap;                // the capacity of slice \n+} GoIntSlice;\n+\n+bool is_space(char a){\n+    if( a == ' '||a == '\\t'||a == '\\r'||a == '\\n'){\n+        return true;\n+    }else{\n+        return false;\n+    }\n+}\n+\n+bool is_integer(char a){\n+    return a>='0'&& a<='9';\n+}\n+\n+bool is_overflow(int i ,size_t srclen){\n+    return i >= srclen;\n+} \n+\n+int char_to_num(char c){\n+    return c-'0';\n+}\n+\n+long decode_u64_array( const GoString* src, long* p, GoIntSlice* arr){  \n+    char* pos = src->buf;\n+    int i =*p;\n+    //If there is a space before the beginning, eat the space first\n+    while(is_space(pos[i])){                                  \n+        i++;                           \n+    }\n+    if(is_overflow(i,src->len)){\n+        *p = i;\n+\tarr->len = 0;\n+\treturn ERR_INVAL;\n+    }\n+    //If the first one is not a left bracket, returning it directly is illegal\n+    if(pos[i] != '['){\n+\t//P points to the first position after the error                                   \n+        *p = i;        \n+        arr->len = 0;\n+        return ERR_INVAL;\n+    }\n+    //when program runs here, it's a left parenthesis\n+    i++;     \n+    //K+1 represents the number of digits in the string src\n+    int k =0;\n+    //Num is used to store the current number                                                \n+    int num = 0;                                              \n+    while(pos[i] !='\\0'){                   \n+    \t//If the capacity is insufficient, return ERR_ RECURSE_ MAX\n+        if(k==arr->cap){                                     \n+            *p = i+1;\n+            return ERR_RECURSE_MAX;\n+        }\n+        //Jump back if it's a space\n+        while(is_space(pos[i])){     \n+            i++;             \n+\t    }\n+\t    if(is_overflow(i,src->len)){\n+\t        *p = i;\n+\t        arr->len = 0;\n+\t        return ERR_INVAL;\n+\t    }\n+\t    //The first one is not a number, it must be illegal\n+\t    if(pos[i]<'0' || pos[i]>'9'){\n+\t\t*p = i;                                     \n+        \tarr->len = 0;\n+\t\treturn ERR_INVAL;                             \n+\t    }else{\n+\t\tnum = char_to_num(pos[i]); \n+\t    } \t    \n+\t    i++; \n+\t    while(!is_space(pos[i])&& pos[i] !=','){                         ",
        "comment_created_at": "2023-06-27T11:26:20+00:00",
        "comment_author": "liuq19",
        "comment_body": "\u540c\u6837\u9700\u8981\u5148\u5224\u65ad\u662f\u5426\u8d8a\u754c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1234739328",
    "pr_number": 459,
    "pr_file": "native/sort.c",
    "created_at": "2023-06-20T05:04:23+00:00",
    "commented_code": "+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+int _strcmp(const char *p,const char *q){",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1234739328",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 459,
        "pr_file": "native/sort.c",
        "discussion_id": "1234739328",
        "commented_code": "@@ -0,0 +1,74 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+int _strcmp(const char *p,const char *q){",
        "comment_created_at": "2023-06-20T05:04:23+00:00",
        "comment_author": "liuq19",
        "comment_body": "*p and *q may access the invalid memory address without any bound checking.\r\nMaybe add a bound check is better. because we have known the length of key, in GoString.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1226179964",
    "pr_number": 450,
    "pr_file": "native/sort.c",
    "created_at": "2023-06-12T07:06:46+00:00",
    "commented_code": "+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+int my_strcmp(const char *p,const char *q){\n+\twhile(*p==*q && *p != '\\0'){",
    "repo_full_name": "bytedance/sonic",
    "discussion_comments": [
      {
        "comment_id": "1226179964",
        "repo_full_name": "bytedance/sonic",
        "pr_number": 450,
        "pr_file": "native/sort.c",
        "discussion_id": "1226179964",
        "commented_code": "@@ -0,0 +1,74 @@\n+#include <stdio.h>\n+\n+#include \"native.h\"\n+\n+typedef struct MapPair{\n+    GoString  key;\n+    void*     value;\n+} MapPair;\n+\n+// swap elems in MapPair\n+void swap(MapPair* lhs, MapPair* rhs) {\n+    MapPair temp;\n+    temp = *lhs;\n+    *lhs = *rhs;\n+    *rhs = temp;\n+}\n+\n+int my_strcmp(const char *p,const char *q){\n+\twhile(*p==*q && *p != '\\0'){",
        "comment_created_at": "2023-06-12T07:06:46+00:00",
        "comment_author": "liuq19",
        "comment_body": "*p or *q maybe access an invalid memory address, if p or q is not terminated by '\\0'",
        "pr_file_module": null
      }
    ]
  }
]