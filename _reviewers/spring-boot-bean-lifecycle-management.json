[
  {
    "discussion_id": "1951377864",
    "pr_number": 44187,
    "pr_file": "spring-boot-project/spring-boot-docs/src/docs/antora/modules/reference/pages/testing/testcontainers.adoc",
    "created_at": "2025-02-11T18:34:29+00:00",
    "commented_code": "It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run.\n Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.\n \n+In following sections we will describe some of the methods you can use to integrate Testcontainers with your tests.\n+\n+== Using via @Testcontainers JUnit5 extension\n+\n+The Testcontainers framework provides JUnit5 extensions, which can be used to manage containers in your tests.\n+The extension is activated by applying the\n+\n Testcontainers can be used in a Spring Boot test as follows:\n \n include-code::vanilla/MyIntegrationTests[]\n \n-This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n+This will start up a Docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n In most cases, you will need to configure the application to connect to the service running in the container.\n \n+In this case the lifecycle of the container instance is managed by Testcontainers framework, as described in official documentation.\n+\n+== Using via Spring managed beans\n+\n+The containers provided by Testcontainers framework can be managed by Spring Boot as beans.\n+This method is often used in combination with javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation].\n+\n+To use Testcontainer contains as Spring beans we need to create a configuration class declaring the container as bean:\n+\n+include-code::beandeclaration/BeanDeclarationConfig[]\n+\n+then we can start the container by importing the configuration class in the test class:\n+\n+include-code::beandeclaration/SpringTest[]\n+\n+\n+== Using via importing container declaration classes\n+\n+A common pattern with Testcontainers framework is to declare the Container instances as static fields in an interface\n+For example the following interface `MyInterface` declares two containers, one named `mongo` of type MongoDB and another named `neo` of type Neo4j:\n+\n+include-code::importcontainers/MyInterface[]\n+\n+When you have containers declared in this way, then you can have these containers managed by Spring Boot as beans.\n+All that is needed to do that is adding javadoc:org.springframework.boot.testcontainers.context.ImportTestcontainers[format=annotation] to your configuration class as in:\n+\n+include-code::importcontainers/MyConfiguration[]\n+\n+== Lifecycle of managed containers\n+\n+If you have used the annotations and extensions provided by Testcontainers framework, then the lifecycle of container instances is managed by the Testcontainers framework.\n+Please refer to the official documentation for the information about lifecycle of the containers, when managed by the Testcontainers framework.\n+\n+When the containers are managed by Spring as beans, then the lifecycle is clearly defined by Spring.\n+The container beans are created and started before the beans of other types are created.\n+This process ensures that any beans, which rely on functionality provided by the containers, can use those functionalities.\n+\n+The test containers can be started multiple times.\n+Like any other beans the test containers are created and started once per application context managed by the TestContext Framework.\n+For details about how TestContext framework manages the underlying application contexts and beans therein, please refer to the official Spring documentation.\n+\n+The container beans are stopped after the destruction of beans of other types.\n+This ensures that any beans depending on the functionalities provided by the containers are cleaned up first.\n+\n+The containers are stopped as part of the application shutdown process, managed by the TestContext framework.",
    "repo_full_name": "spring-projects/spring-boot",
    "discussion_comments": [
      {
        "comment_id": "1951377864",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 44187,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/antora/modules/reference/pages/testing/testcontainers.adoc",
        "discussion_id": "1951377864",
        "commented_code": "@@ -5,14 +5,69 @@ The https://www.testcontainers.org/[Testcontainers] library provides a way to ma\n It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run.\n Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.\n \n+In following sections we will describe some of the methods you can use to integrate Testcontainers with your tests.\n+\n+== Using via @Testcontainers JUnit5 extension\n+\n+The Testcontainers framework provides JUnit5 extensions, which can be used to manage containers in your tests.\n+The extension is activated by applying the\n+\n Testcontainers can be used in a Spring Boot test as follows:\n \n include-code::vanilla/MyIntegrationTests[]\n \n-This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n+This will start up a Docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n In most cases, you will need to configure the application to connect to the service running in the container.\n \n+In this case the lifecycle of the container instance is managed by Testcontainers framework, as described in official documentation.\n+\n+== Using via Spring managed beans\n+\n+The containers provided by Testcontainers framework can be managed by Spring Boot as beans.\n+This method is often used in combination with javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation].\n+\n+To use Testcontainer contains as Spring beans we need to create a configuration class declaring the container as bean:\n+\n+include-code::beandeclaration/BeanDeclarationConfig[]\n+\n+then we can start the container by importing the configuration class in the test class:\n+\n+include-code::beandeclaration/SpringTest[]\n+\n+\n+== Using via importing container declaration classes\n+\n+A common pattern with Testcontainers framework is to declare the Container instances as static fields in an interface\n+For example the following interface `MyInterface` declares two containers, one named `mongo` of type MongoDB and another named `neo` of type Neo4j:\n+\n+include-code::importcontainers/MyInterface[]\n+\n+When you have containers declared in this way, then you can have these containers managed by Spring Boot as beans.\n+All that is needed to do that is adding javadoc:org.springframework.boot.testcontainers.context.ImportTestcontainers[format=annotation] to your configuration class as in:\n+\n+include-code::importcontainers/MyConfiguration[]\n+\n+== Lifecycle of managed containers\n+\n+If you have used the annotations and extensions provided by Testcontainers framework, then the lifecycle of container instances is managed by the Testcontainers framework.\n+Please refer to the official documentation for the information about lifecycle of the containers, when managed by the Testcontainers framework.\n+\n+When the containers are managed by Spring as beans, then the lifecycle is clearly defined by Spring.\n+The container beans are created and started before the beans of other types are created.\n+This process ensures that any beans, which rely on functionality provided by the containers, can use those functionalities.\n+\n+The test containers can be started multiple times.\n+Like any other beans the test containers are created and started once per application context managed by the TestContext Framework.\n+For details about how TestContext framework manages the underlying application contexts and beans therein, please refer to the official Spring documentation.\n+\n+The container beans are stopped after the destruction of beans of other types.\n+This ensures that any beans depending on the functionalities provided by the containers are cleaned up first.\n+\n+The containers are stopped as part of the application shutdown process, managed by the TestContext framework.",
        "comment_created_at": "2025-02-11T18:34:29+00:00",
        "comment_author": "eddumelendez",
        "comment_body": "This part is important to highlight. In some cases, for example, using activemq, kafka, pulsar and other containers, I recommend to declare it as a beans rather than static fields because that way the application context will shutdown the client first and then the container. Otherwise, when the container shutdown first the client will throw some errors because connection has been lost.",
        "pr_file_module": null
      },
      {
        "comment_id": "1952056114",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 44187,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/antora/modules/reference/pages/testing/testcontainers.adoc",
        "discussion_id": "1951377864",
        "commented_code": "@@ -5,14 +5,69 @@ The https://www.testcontainers.org/[Testcontainers] library provides a way to ma\n It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run.\n Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.\n \n+In following sections we will describe some of the methods you can use to integrate Testcontainers with your tests.\n+\n+== Using via @Testcontainers JUnit5 extension\n+\n+The Testcontainers framework provides JUnit5 extensions, which can be used to manage containers in your tests.\n+The extension is activated by applying the\n+\n Testcontainers can be used in a Spring Boot test as follows:\n \n include-code::vanilla/MyIntegrationTests[]\n \n-This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n+This will start up a Docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n In most cases, you will need to configure the application to connect to the service running in the container.\n \n+In this case the lifecycle of the container instance is managed by Testcontainers framework, as described in official documentation.\n+\n+== Using via Spring managed beans\n+\n+The containers provided by Testcontainers framework can be managed by Spring Boot as beans.\n+This method is often used in combination with javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation].\n+\n+To use Testcontainer contains as Spring beans we need to create a configuration class declaring the container as bean:\n+\n+include-code::beandeclaration/BeanDeclarationConfig[]\n+\n+then we can start the container by importing the configuration class in the test class:\n+\n+include-code::beandeclaration/SpringTest[]\n+\n+\n+== Using via importing container declaration classes\n+\n+A common pattern with Testcontainers framework is to declare the Container instances as static fields in an interface\n+For example the following interface `MyInterface` declares two containers, one named `mongo` of type MongoDB and another named `neo` of type Neo4j:\n+\n+include-code::importcontainers/MyInterface[]\n+\n+When you have containers declared in this way, then you can have these containers managed by Spring Boot as beans.\n+All that is needed to do that is adding javadoc:org.springframework.boot.testcontainers.context.ImportTestcontainers[format=annotation] to your configuration class as in:\n+\n+include-code::importcontainers/MyConfiguration[]\n+\n+== Lifecycle of managed containers\n+\n+If you have used the annotations and extensions provided by Testcontainers framework, then the lifecycle of container instances is managed by the Testcontainers framework.\n+Please refer to the official documentation for the information about lifecycle of the containers, when managed by the Testcontainers framework.\n+\n+When the containers are managed by Spring as beans, then the lifecycle is clearly defined by Spring.\n+The container beans are created and started before the beans of other types are created.\n+This process ensures that any beans, which rely on functionality provided by the containers, can use those functionalities.\n+\n+The test containers can be started multiple times.\n+Like any other beans the test containers are created and started once per application context managed by the TestContext Framework.\n+For details about how TestContext framework manages the underlying application contexts and beans therein, please refer to the official Spring documentation.\n+\n+The container beans are stopped after the destruction of beans of other types.\n+This ensures that any beans depending on the functionalities provided by the containers are cleaned up first.\n+\n+The containers are stopped as part of the application shutdown process, managed by the TestContext framework.",
        "comment_created_at": "2025-02-12T06:29:45+00:00",
        "comment_author": "thecooldrop",
        "comment_body": "I understand that you would like to have a concrete example in addition to the general explanation already provided, so that the readers can more clearly understand the \"why\" behind usage. Is my understanding correct?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1957265632",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 44187,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/antora/modules/reference/pages/testing/testcontainers.adoc",
        "discussion_id": "1951377864",
        "commented_code": "@@ -5,14 +5,69 @@ The https://www.testcontainers.org/[Testcontainers] library provides a way to ma\n It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run.\n Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.\n \n+In following sections we will describe some of the methods you can use to integrate Testcontainers with your tests.\n+\n+== Using via @Testcontainers JUnit5 extension\n+\n+The Testcontainers framework provides JUnit5 extensions, which can be used to manage containers in your tests.\n+The extension is activated by applying the\n+\n Testcontainers can be used in a Spring Boot test as follows:\n \n include-code::vanilla/MyIntegrationTests[]\n \n-This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n+This will start up a Docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n In most cases, you will need to configure the application to connect to the service running in the container.\n \n+In this case the lifecycle of the container instance is managed by Testcontainers framework, as described in official documentation.\n+\n+== Using via Spring managed beans\n+\n+The containers provided by Testcontainers framework can be managed by Spring Boot as beans.\n+This method is often used in combination with javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation].\n+\n+To use Testcontainer contains as Spring beans we need to create a configuration class declaring the container as bean:\n+\n+include-code::beandeclaration/BeanDeclarationConfig[]\n+\n+then we can start the container by importing the configuration class in the test class:\n+\n+include-code::beandeclaration/SpringTest[]\n+\n+\n+== Using via importing container declaration classes\n+\n+A common pattern with Testcontainers framework is to declare the Container instances as static fields in an interface\n+For example the following interface `MyInterface` declares two containers, one named `mongo` of type MongoDB and another named `neo` of type Neo4j:\n+\n+include-code::importcontainers/MyInterface[]\n+\n+When you have containers declared in this way, then you can have these containers managed by Spring Boot as beans.\n+All that is needed to do that is adding javadoc:org.springframework.boot.testcontainers.context.ImportTestcontainers[format=annotation] to your configuration class as in:\n+\n+include-code::importcontainers/MyConfiguration[]\n+\n+== Lifecycle of managed containers\n+\n+If you have used the annotations and extensions provided by Testcontainers framework, then the lifecycle of container instances is managed by the Testcontainers framework.\n+Please refer to the official documentation for the information about lifecycle of the containers, when managed by the Testcontainers framework.\n+\n+When the containers are managed by Spring as beans, then the lifecycle is clearly defined by Spring.\n+The container beans are created and started before the beans of other types are created.\n+This process ensures that any beans, which rely on functionality provided by the containers, can use those functionalities.\n+\n+The test containers can be started multiple times.\n+Like any other beans the test containers are created and started once per application context managed by the TestContext Framework.\n+For details about how TestContext framework manages the underlying application contexts and beans therein, please refer to the official Spring documentation.\n+\n+The container beans are stopped after the destruction of beans of other types.\n+This ensures that any beans depending on the functionalities provided by the containers are cleaned up first.\n+\n+The containers are stopped as part of the application shutdown process, managed by the TestContext framework.",
        "comment_created_at": "2025-02-16T08:06:59+00:00",
        "comment_author": "thecooldrop",
        "comment_body": "Added as tips and notes.",
        "pr_file_module": null
      },
      {
        "comment_id": "1960061342",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 44187,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/antora/modules/reference/pages/testing/testcontainers.adoc",
        "discussion_id": "1951377864",
        "commented_code": "@@ -5,14 +5,69 @@ The https://www.testcontainers.org/[Testcontainers] library provides a way to ma\n It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run.\n Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.\n \n+In following sections we will describe some of the methods you can use to integrate Testcontainers with your tests.\n+\n+== Using via @Testcontainers JUnit5 extension\n+\n+The Testcontainers framework provides JUnit5 extensions, which can be used to manage containers in your tests.\n+The extension is activated by applying the\n+\n Testcontainers can be used in a Spring Boot test as follows:\n \n include-code::vanilla/MyIntegrationTests[]\n \n-This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n+This will start up a Docker container running Neo4j (if Docker is running locally) before any of the tests are run.\n In most cases, you will need to configure the application to connect to the service running in the container.\n \n+In this case the lifecycle of the container instance is managed by Testcontainers framework, as described in official documentation.\n+\n+== Using via Spring managed beans\n+\n+The containers provided by Testcontainers framework can be managed by Spring Boot as beans.\n+This method is often used in combination with javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation].\n+\n+To use Testcontainer contains as Spring beans we need to create a configuration class declaring the container as bean:\n+\n+include-code::beandeclaration/BeanDeclarationConfig[]\n+\n+then we can start the container by importing the configuration class in the test class:\n+\n+include-code::beandeclaration/SpringTest[]\n+\n+\n+== Using via importing container declaration classes\n+\n+A common pattern with Testcontainers framework is to declare the Container instances as static fields in an interface\n+For example the following interface `MyInterface` declares two containers, one named `mongo` of type MongoDB and another named `neo` of type Neo4j:\n+\n+include-code::importcontainers/MyInterface[]\n+\n+When you have containers declared in this way, then you can have these containers managed by Spring Boot as beans.\n+All that is needed to do that is adding javadoc:org.springframework.boot.testcontainers.context.ImportTestcontainers[format=annotation] to your configuration class as in:\n+\n+include-code::importcontainers/MyConfiguration[]\n+\n+== Lifecycle of managed containers\n+\n+If you have used the annotations and extensions provided by Testcontainers framework, then the lifecycle of container instances is managed by the Testcontainers framework.\n+Please refer to the official documentation for the information about lifecycle of the containers, when managed by the Testcontainers framework.\n+\n+When the containers are managed by Spring as beans, then the lifecycle is clearly defined by Spring.\n+The container beans are created and started before the beans of other types are created.\n+This process ensures that any beans, which rely on functionality provided by the containers, can use those functionalities.\n+\n+The test containers can be started multiple times.\n+Like any other beans the test containers are created and started once per application context managed by the TestContext Framework.\n+For details about how TestContext framework manages the underlying application contexts and beans therein, please refer to the official Spring documentation.\n+\n+The container beans are stopped after the destruction of beans of other types.\n+This ensures that any beans depending on the functionalities provided by the containers are cleaned up first.\n+\n+The containers are stopped as part of the application shutdown process, managed by the TestContext framework.",
        "comment_created_at": "2025-02-18T16:06:21+00:00",
        "comment_author": "eddumelendez",
        "comment_body": "tips and notes are great! my examples were only to provide an explanation about the issue en general. \ud83d\udc4d\ud83c\udffd ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1285873931",
    "pr_number": 34763,
    "pr_file": "spring-boot-project/spring-boot-docs/src/docs/asciidoc/messaging/pulsar.adoc",
    "created_at": "2023-08-07T13:32:25+00:00",
    "commented_code": "+[[messaging.pulsar]]\n+== Apache Pulsar Support\n+https://pulsar.apache.org/[Apache Pulsar] is supported by providing auto-configuration of the {spring-pulsar-docs}[Spring for Apache Pulsar] project.\n+\n+Spring Boot will auto-configure and register the classic (imperative) Spring Pulsar components when `org.springframework.pulsar:spring-pulsar` is on the classpath.\n+It will do the same for the reactive components when `org.springframework.pulsar:spring-pulsar-reactive` is on the classpath.\n+\n+There are `spring-boot-starter-pulsar` and `spring-boot-starter-pulsar-reactive` \"`Starters`\" for conveniently collecting the dependencies for imperative and reactive use, respectively.\n+\n+TIP: The Reactive auto-configuration relies on the imperative auto-configuration and therefore the reactive starter includes the imperative starter.\n+As such, the imperative components are auto-configured and available in both reactive and imperative scenarios.\n+However, using the imperative components in a fully reactive app is not recommended as it could cause blocking issues.",
    "repo_full_name": "spring-projects/spring-boot",
    "discussion_comments": [
      {
        "comment_id": "1285873931",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 34763,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/asciidoc/messaging/pulsar.adoc",
        "discussion_id": "1285873931",
        "commented_code": "@@ -0,0 +1,132 @@\n+[[messaging.pulsar]]\n+== Apache Pulsar Support\n+https://pulsar.apache.org/[Apache Pulsar] is supported by providing auto-configuration of the {spring-pulsar-docs}[Spring for Apache Pulsar] project.\n+\n+Spring Boot will auto-configure and register the classic (imperative) Spring Pulsar components when `org.springframework.pulsar:spring-pulsar` is on the classpath.\n+It will do the same for the reactive components when `org.springframework.pulsar:spring-pulsar-reactive` is on the classpath.\n+\n+There are `spring-boot-starter-pulsar` and `spring-boot-starter-pulsar-reactive` \"`Starters`\" for conveniently collecting the dependencies for imperative and reactive use, respectively.\n+\n+TIP: The Reactive auto-configuration relies on the imperative auto-configuration and therefore the reactive starter includes the imperative starter.\n+As such, the imperative components are auto-configured and available in both reactive and imperative scenarios.\n+However, using the imperative components in a fully reactive app is not recommended as it could cause blocking issues.",
        "comment_created_at": "2023-08-07T13:32:25+00:00",
        "comment_author": "wilkinsona",
        "comment_body": "Is it possible to not expose the imperative components as beans in a reactive app?",
        "pr_file_module": null
      },
      {
        "comment_id": "1286220943",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 34763,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/asciidoc/messaging/pulsar.adoc",
        "discussion_id": "1285873931",
        "commented_code": "@@ -0,0 +1,132 @@\n+[[messaging.pulsar]]\n+== Apache Pulsar Support\n+https://pulsar.apache.org/[Apache Pulsar] is supported by providing auto-configuration of the {spring-pulsar-docs}[Spring for Apache Pulsar] project.\n+\n+Spring Boot will auto-configure and register the classic (imperative) Spring Pulsar components when `org.springframework.pulsar:spring-pulsar` is on the classpath.\n+It will do the same for the reactive components when `org.springframework.pulsar:spring-pulsar-reactive` is on the classpath.\n+\n+There are `spring-boot-starter-pulsar` and `spring-boot-starter-pulsar-reactive` \"`Starters`\" for conveniently collecting the dependencies for imperative and reactive use, respectively.\n+\n+TIP: The Reactive auto-configuration relies on the imperative auto-configuration and therefore the reactive starter includes the imperative starter.\n+As such, the imperative components are auto-configured and available in both reactive and imperative scenarios.\n+However, using the imperative components in a fully reactive app is not recommended as it could cause blocking issues.",
        "comment_created_at": "2023-08-07T17:58:32+00:00",
        "comment_author": "onobc",
        "comment_body": "Not as it is currently written. It would be quite the effort to do this. The reactive components leverage the reactive client which adapts the original client (which is imperative and auto-configured). I believe there are other technologies auto-configured in Boot whose reactive components leverage the imperative ones, no?",
        "pr_file_module": null
      },
      {
        "comment_id": "1286716347",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 34763,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/asciidoc/messaging/pulsar.adoc",
        "discussion_id": "1285873931",
        "commented_code": "@@ -0,0 +1,132 @@\n+[[messaging.pulsar]]\n+== Apache Pulsar Support\n+https://pulsar.apache.org/[Apache Pulsar] is supported by providing auto-configuration of the {spring-pulsar-docs}[Spring for Apache Pulsar] project.\n+\n+Spring Boot will auto-configure and register the classic (imperative) Spring Pulsar components when `org.springframework.pulsar:spring-pulsar` is on the classpath.\n+It will do the same for the reactive components when `org.springframework.pulsar:spring-pulsar-reactive` is on the classpath.\n+\n+There are `spring-boot-starter-pulsar` and `spring-boot-starter-pulsar-reactive` \"`Starters`\" for conveniently collecting the dependencies for imperative and reactive use, respectively.\n+\n+TIP: The Reactive auto-configuration relies on the imperative auto-configuration and therefore the reactive starter includes the imperative starter.\n+As such, the imperative components are auto-configured and available in both reactive and imperative scenarios.\n+However, using the imperative components in a fully reactive app is not recommended as it could cause blocking issues.",
        "comment_created_at": "2023-08-08T07:30:03+00:00",
        "comment_author": "wilkinsona",
        "comment_body": "> The reactive components leverage the reactive client which adapts the original client (which is imperative and auto-configured)\r\n\r\nI wonder if the original, imperative client has to be a bean in the reactive case. Perhaps it does for ease of configuration property binding and the like. Not something to worry about for this PR, but probably worth revisiting down the road before 3.2 GAs.\r\n\r\n>  there are other technologies auto-configured in Boot whose reactive components leverage the imperative ones, no?\r\n\r\nWe have some situations where there's a low-level bean that's shared between imperative and reactive (Elasticsearch client transport and the ElasticsearchClient and ReactiveElasticsearchClient that use it, for example) but I can't think of a situation where we have an imperative bean that we expect applications to use extensively that's then wrapped by a reactive bean. I may well be forgetting something though.",
        "pr_file_module": null
      },
      {
        "comment_id": "1287477338",
        "repo_full_name": "spring-projects/spring-boot",
        "pr_number": 34763,
        "pr_file": "spring-boot-project/spring-boot-docs/src/docs/asciidoc/messaging/pulsar.adoc",
        "discussion_id": "1285873931",
        "commented_code": "@@ -0,0 +1,132 @@\n+[[messaging.pulsar]]\n+== Apache Pulsar Support\n+https://pulsar.apache.org/[Apache Pulsar] is supported by providing auto-configuration of the {spring-pulsar-docs}[Spring for Apache Pulsar] project.\n+\n+Spring Boot will auto-configure and register the classic (imperative) Spring Pulsar components when `org.springframework.pulsar:spring-pulsar` is on the classpath.\n+It will do the same for the reactive components when `org.springframework.pulsar:spring-pulsar-reactive` is on the classpath.\n+\n+There are `spring-boot-starter-pulsar` and `spring-boot-starter-pulsar-reactive` \"`Starters`\" for conveniently collecting the dependencies for imperative and reactive use, respectively.\n+\n+TIP: The Reactive auto-configuration relies on the imperative auto-configuration and therefore the reactive starter includes the imperative starter.\n+As such, the imperative components are auto-configured and available in both reactive and imperative scenarios.\n+However, using the imperative components in a fully reactive app is not recommended as it could cause blocking issues.",
        "comment_created_at": "2023-08-08T18:02:55+00:00",
        "comment_author": "onobc",
        "comment_body": "> I wonder if the original, imperative client has to be a bean in the reactive case. Perhaps it does for ease of configuration property binding and the like. Not something to worry about for this PR, but probably worth revisiting down the road before 3.2 GAs.\r\n\r\nI'm happy to take a look and revisit in that timeframe.",
        "pr_file_module": null
      }
    ]
  }
]