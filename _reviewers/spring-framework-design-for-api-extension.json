[
  {
    "discussion_id": "1598411500",
    "pr_number": 32804,
    "pr_file": "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
    "created_at": "2024-05-13T12:40:49+00:00",
    "commented_code": "* and if it is then the argument values will be appropriately packaged into an array.\n \t * @param mv the method visitor where code should be generated\n \t * @param cf the current codeflow\n-\t * @param member the method or constructor for which arguments are being set up\n+\t * @param executable the method or constructor for which arguments are being set up\n \t * @param arguments the expression nodes for the expression supplied argument values\n \t */\n-\tprotected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1598411500",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 32804,
        "pr_file": "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
        "discussion_id": "1598411500",
        "commented_code": "@@ -214,62 +213,67 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException\n \t * and if it is then the argument values will be appropriately packaged into an array.\n \t * @param mv the method visitor where code should be generated\n \t * @param cf the current codeflow\n-\t * @param member the method or constructor for which arguments are being set up\n+\t * @param executable the method or constructor for which arguments are being set up\n \t * @param arguments the expression nodes for the expression supplied argument values\n \t */\n-\tprotected static void generateCodeForArguments(MethodVisitor mv, CodeFlow cf, Member member, SpelNodeImpl[] arguments) {",
        "comment_created_at": "2024-05-13T12:40:49+00:00",
        "comment_author": "sbrannen",
        "comment_body": "Since this is a `protected` method in a `public` type, we cannot simply change the method signature.\r\n\r\nInstead, we would need to introduce an overloaded variant that accepts `Executable` and deprecate the existing variant that accepts `Member`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "401557025",
    "pr_number": 24700,
    "pr_file": "spring-web/src/main/java/org/springframework/http/client/reactive/HttpComponentsClientHttpConnector.java",
    "created_at": "2020-04-01T11:52:37+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.client.reactive;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.hc.client5.http.cookie.BasicCookieStore;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.client5.http.impl.async.HttpAsyncClients;\n+import org.apache.hc.client5.http.protocol.HttpClientContext;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.ContentType;\n+import org.apache.hc.core5.http.HttpResponse;\n+import org.apache.hc.core5.http.Message;\n+import org.apache.hc.core5.http.nio.support.BasicRequestProducer;\n+import org.apache.hc.core5.reactive.ReactiveEntityProducer;\n+import org.apache.hc.core5.reactive.ReactiveResponseConsumer;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.DefaultDataBufferFactory;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.lang.Nullable;\n+\n+/**\n+ * {@link ClientHttpConnector} implementation for the Apache HttpComponents HttpClient 5.x.\n+ *\n+ * @author Martin Tarj\u00e1nyi\n+ * @since 5.3\n+ * @see <a href=\"https://hc.apache.org/index.html\">Apache HttpComponents</a>\n+ */\n+public class HttpComponentsClientHttpConnector implements ClientHttpConnector {\n+\n+\tprivate final CloseableHttpAsyncClient client;\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Supplier<? extends HttpClientContext> contextSupplier;\n+\n+\n+\t/**\n+\t * Default constructor that creates and starts a new instance of {@link CloseableHttpAsyncClient}.\n+\t */\n+\tpublic HttpComponentsClientHttpConnector() {\n+\t\tthis(HttpAsyncClients.createDefault());\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance.\n+\t * @param client the client to use\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client) {\n+\t\tthis(client, HttpClientContext::create);\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance\n+\t * and a {@link HttpClientContext} supplier lambda which is called before each request\n+\t * and passed to the client.\n+\t * @param client the client to use\n+\t * @param contextSupplier a {@link HttpClientContext} supplier\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client,\n+\t\t\tSupplier<? extends HttpClientContext> contextSupplier) {\n+\n+\t\tthis.dataBufferFactory = new DefaultDataBufferFactory();\n+\t\tthis.contextSupplier = contextSupplier;\n+\t\tthis.client = client;\n+\t\tthis.client.start();\n+\t}\n+\n+\n+\t@Override\n+\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n+\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n+\n+\t\tHttpClientContext context = this.contextSupplier.get();",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "401557025",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24700,
        "pr_file": "spring-web/src/main/java/org/springframework/http/client/reactive/HttpComponentsClientHttpConnector.java",
        "discussion_id": "401557025",
        "commented_code": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.client.reactive;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.hc.client5.http.cookie.BasicCookieStore;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.client5.http.impl.async.HttpAsyncClients;\n+import org.apache.hc.client5.http.protocol.HttpClientContext;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.ContentType;\n+import org.apache.hc.core5.http.HttpResponse;\n+import org.apache.hc.core5.http.Message;\n+import org.apache.hc.core5.http.nio.support.BasicRequestProducer;\n+import org.apache.hc.core5.reactive.ReactiveEntityProducer;\n+import org.apache.hc.core5.reactive.ReactiveResponseConsumer;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.DefaultDataBufferFactory;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.lang.Nullable;\n+\n+/**\n+ * {@link ClientHttpConnector} implementation for the Apache HttpComponents HttpClient 5.x.\n+ *\n+ * @author Martin Tarj\u00e1nyi\n+ * @since 5.3\n+ * @see <a href=\"https://hc.apache.org/index.html\">Apache HttpComponents</a>\n+ */\n+public class HttpComponentsClientHttpConnector implements ClientHttpConnector {\n+\n+\tprivate final CloseableHttpAsyncClient client;\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Supplier<? extends HttpClientContext> contextSupplier;\n+\n+\n+\t/**\n+\t * Default constructor that creates and starts a new instance of {@link CloseableHttpAsyncClient}.\n+\t */\n+\tpublic HttpComponentsClientHttpConnector() {\n+\t\tthis(HttpAsyncClients.createDefault());\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance.\n+\t * @param client the client to use\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client) {\n+\t\tthis(client, HttpClientContext::create);\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance\n+\t * and a {@link HttpClientContext} supplier lambda which is called before each request\n+\t * and passed to the client.\n+\t * @param client the client to use\n+\t * @param contextSupplier a {@link HttpClientContext} supplier\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client,\n+\t\t\tSupplier<? extends HttpClientContext> contextSupplier) {\n+\n+\t\tthis.dataBufferFactory = new DefaultDataBufferFactory();\n+\t\tthis.contextSupplier = contextSupplier;\n+\t\tthis.client = client;\n+\t\tthis.client.start();\n+\t}\n+\n+\n+\t@Override\n+\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n+\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n+\n+\t\tHttpClientContext context = this.contextSupplier.get();",
        "comment_created_at": "2020-04-01T11:52:37+00:00",
        "comment_author": "poutsma",
        "comment_body": "I live the idea of using a function (instead of overloadable method) for getting the `HttpContext`, but I think it would be even nicer if the user would have access to the method and URI, since these are available here anyway. So a `BiFunction<HttpMethod, URI, HttpClientContext>` instead of a `Supplier<HttpClientContext>`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "401613592",
    "pr_number": 24700,
    "pr_file": "spring-web/src/main/java/org/springframework/http/client/reactive/HttpComponentsClientHttpConnector.java",
    "created_at": "2020-04-01T13:27:11+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.client.reactive;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.hc.client5.http.cookie.BasicCookieStore;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.client5.http.impl.async.HttpAsyncClients;\n+import org.apache.hc.client5.http.protocol.HttpClientContext;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.ContentType;\n+import org.apache.hc.core5.http.HttpResponse;\n+import org.apache.hc.core5.http.Message;\n+import org.apache.hc.core5.http.nio.support.BasicRequestProducer;\n+import org.apache.hc.core5.reactive.ReactiveEntityProducer;\n+import org.apache.hc.core5.reactive.ReactiveResponseConsumer;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.DefaultDataBufferFactory;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.lang.Nullable;\n+\n+/**\n+ * {@link ClientHttpConnector} implementation for the Apache HttpComponents HttpClient 5.x.\n+ *\n+ * @author Martin Tarj\u00e1nyi\n+ * @since 5.3\n+ * @see <a href=\"https://hc.apache.org/index.html\">Apache HttpComponents</a>\n+ */\n+public class HttpComponentsClientHttpConnector implements ClientHttpConnector {\n+\n+\tprivate final CloseableHttpAsyncClient client;\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Supplier<? extends HttpClientContext> contextSupplier;\n+\n+\n+\t/**\n+\t * Default constructor that creates and starts a new instance of {@link CloseableHttpAsyncClient}.\n+\t */\n+\tpublic HttpComponentsClientHttpConnector() {\n+\t\tthis(HttpAsyncClients.createDefault());\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance.\n+\t * @param client the client to use\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client) {\n+\t\tthis(client, HttpClientContext::create);\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance\n+\t * and a {@link HttpClientContext} supplier lambda which is called before each request\n+\t * and passed to the client.\n+\t * @param client the client to use\n+\t * @param contextSupplier a {@link HttpClientContext} supplier\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client,\n+\t\t\tSupplier<? extends HttpClientContext> contextSupplier) {\n+\n+\t\tthis.dataBufferFactory = new DefaultDataBufferFactory();\n+\t\tthis.contextSupplier = contextSupplier;\n+\t\tthis.client = client;\n+\t\tthis.client.start();\n+\t}\n+\n+\n+\t@Override\n+\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n+\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n+\n+\t\tHttpClientContext context = this.contextSupplier.get();\n+\n+\t\tif (context.getCookieStore() == null) {\n+\t\t\tcontext.setCookieStore(new BasicCookieStore());\n+\t\t}\n+\n+\t\tHttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,\n+\t\t\t\tcontext, this.dataBufferFactory);\n+\n+\t\treturn requestCallback.apply(request).then(Mono.defer(() -> execute(request, context)));\n+\t}\n+\n+\tprivate Mono<ClientHttpResponse> execute(HttpComponentsClientHttpRequest request, HttpClientContext context) {\n+\t\tFlux<ByteBuffer> byteBufferFlux = request.getByteBufferFlux();\n+\n+\t\tReactiveEntityProducer reactiveEntityProducer = createReactiveEntityProducer(request, byteBufferFlux);\n+\n+\t\tBasicRequestProducer basicRequestProducer = new BasicRequestProducer(request.getHttpRequest(),\n+\t\t\t\treactiveEntityProducer);\n+",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "401613592",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24700,
        "pr_file": "spring-web/src/main/java/org/springframework/http/client/reactive/HttpComponentsClientHttpConnector.java",
        "discussion_id": "401613592",
        "commented_code": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.client.reactive;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.hc.client5.http.cookie.BasicCookieStore;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.client5.http.impl.async.HttpAsyncClients;\n+import org.apache.hc.client5.http.protocol.HttpClientContext;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.ContentType;\n+import org.apache.hc.core5.http.HttpResponse;\n+import org.apache.hc.core5.http.Message;\n+import org.apache.hc.core5.http.nio.support.BasicRequestProducer;\n+import org.apache.hc.core5.reactive.ReactiveEntityProducer;\n+import org.apache.hc.core5.reactive.ReactiveResponseConsumer;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.DefaultDataBufferFactory;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.lang.Nullable;\n+\n+/**\n+ * {@link ClientHttpConnector} implementation for the Apache HttpComponents HttpClient 5.x.\n+ *\n+ * @author Martin Tarj\u00e1nyi\n+ * @since 5.3\n+ * @see <a href=\"https://hc.apache.org/index.html\">Apache HttpComponents</a>\n+ */\n+public class HttpComponentsClientHttpConnector implements ClientHttpConnector {\n+\n+\tprivate final CloseableHttpAsyncClient client;\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Supplier<? extends HttpClientContext> contextSupplier;\n+\n+\n+\t/**\n+\t * Default constructor that creates and starts a new instance of {@link CloseableHttpAsyncClient}.\n+\t */\n+\tpublic HttpComponentsClientHttpConnector() {\n+\t\tthis(HttpAsyncClients.createDefault());\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance.\n+\t * @param client the client to use\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client) {\n+\t\tthis(client, HttpClientContext::create);\n+\t}\n+\n+\t/**\n+\t * Constructor with a pre-configured {@link CloseableHttpAsyncClient} instance\n+\t * and a {@link HttpClientContext} supplier lambda which is called before each request\n+\t * and passed to the client.\n+\t * @param client the client to use\n+\t * @param contextSupplier a {@link HttpClientContext} supplier\n+\t */\n+\tpublic HttpComponentsClientHttpConnector(CloseableHttpAsyncClient client,\n+\t\t\tSupplier<? extends HttpClientContext> contextSupplier) {\n+\n+\t\tthis.dataBufferFactory = new DefaultDataBufferFactory();\n+\t\tthis.contextSupplier = contextSupplier;\n+\t\tthis.client = client;\n+\t\tthis.client.start();\n+\t}\n+\n+\n+\t@Override\n+\tpublic Mono<ClientHttpResponse> connect(HttpMethod method, URI uri,\n+\t\t\tFunction<? super ClientHttpRequest, Mono<Void>> requestCallback) {\n+\n+\t\tHttpClientContext context = this.contextSupplier.get();\n+\n+\t\tif (context.getCookieStore() == null) {\n+\t\t\tcontext.setCookieStore(new BasicCookieStore());\n+\t\t}\n+\n+\t\tHttpComponentsClientHttpRequest request = new HttpComponentsClientHttpRequest(method, uri,\n+\t\t\t\tcontext, this.dataBufferFactory);\n+\n+\t\treturn requestCallback.apply(request).then(Mono.defer(() -> execute(request, context)));\n+\t}\n+\n+\tprivate Mono<ClientHttpResponse> execute(HttpComponentsClientHttpRequest request, HttpClientContext context) {\n+\t\tFlux<ByteBuffer> byteBufferFlux = request.getByteBufferFlux();\n+\n+\t\tReactiveEntityProducer reactiveEntityProducer = createReactiveEntityProducer(request, byteBufferFlux);\n+\n+\t\tBasicRequestProducer basicRequestProducer = new BasicRequestProducer(request.getHttpRequest(),\n+\t\t\t\treactiveEntityProducer);\n+",
        "comment_created_at": "2020-04-01T13:27:11+00:00",
        "comment_author": "poutsma",
        "comment_body": "Rather than extract body and headers from `HttpComponentsClientHttpRequest`, we should have a `toRequestProducer` on that class instead, which contains all this code together with `createReactiveEntityProducer` below, and which returns a `BasicRequestProducer`. That way, all we have to do here is invoke that method.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "842880598",
    "pr_number": 28224,
    "pr_file": "spring-beans/src/main/java/org/springframework/beans/PropertyAccessor.java",
    "created_at": "2022-04-05T14:50:09+00:00",
    "commented_code": "* occurred for specific properties during the batch update. This exception bundles\n \t * all individual PropertyAccessExceptions. All other properties will have been\n \t * successfully updated.\n+\t * @throws NoDefaultValuePropertyException if a default value of null is attempted to\n+\t * be bound to a target parameter.\n \t */\n-\tvoid setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)\n+\tvoid setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid, boolean ignoreNoDefaultValue)",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "842880598",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28224,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/PropertyAccessor.java",
        "discussion_id": "842880598",
        "commented_code": "@@ -228,8 +228,10 @@ void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown)\n \t * occurred for specific properties during the batch update. This exception bundles\n \t * all individual PropertyAccessExceptions. All other properties will have been\n \t * successfully updated.\n+\t * @throws NoDefaultValuePropertyException if a default value of null is attempted to\n+\t * be bound to a target parameter.\n \t */\n-\tvoid setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)\n+\tvoid setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid, boolean ignoreNoDefaultValue)",
        "comment_created_at": "2022-04-05T14:50:09+00:00",
        "comment_author": "sbrannen",
        "comment_body": "I have not investigated the claims in this issue or the rest of this PR; however, based on a quick glance I can say that this change is not permissible since it changes the signature of a public API.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "927419903",
    "pr_number": 28401,
    "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
    "created_at": "2022-07-22T08:29:33+00:00",
    "commented_code": "mapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "927419903",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28401,
        "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
        "discussion_id": "927419903",
        "commented_code": "@@ -217,6 +244,32 @@ private ObjectReader getObjectReader(\n \t\t\t\tmapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
        "comment_created_at": "2022-07-22T08:29:33+00:00",
        "comment_author": "rstoyanchev",
        "comment_body": "Is the `Mono` customize variant really needed, or could we eliminate one level of nesting here?",
        "pr_file_module": null
      },
      {
        "comment_id": "928772098",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28401,
        "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
        "discussion_id": "927419903",
        "commented_code": "@@ -217,6 +244,32 @@ private ObjectReader getObjectReader(\n \t\t\t\tmapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
        "comment_created_at": "2022-07-25T11:24:32+00:00",
        "comment_author": "jlaber",
        "comment_body": "This was done intentionally so that if someone extending the class wanted to customize leveraging data in the Reactor Context they could.  They would be able to do something like this:\r\n\r\n```\r\n@Override\r\nprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType, ResolvableType elementType, @Nullable Map<String, Object> hints) {\r\n\treturn Mono.deferContextual(ctx -> {\r\n\t    if(ctx.getOrDefault(\"something\", false) {\r\n\t        // customize reader\r\n\t    }\r\n\t    return reader;\r\n\t});\r\n}\r\n```\r\n\r\nI have an actual use case for this.",
        "pr_file_module": null
      },
      {
        "comment_id": "971186797",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28401,
        "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
        "discussion_id": "927419903",
        "commented_code": "@@ -217,6 +244,32 @@ private ObjectReader getObjectReader(\n \t\t\t\tmapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
        "comment_created_at": "2022-09-14T18:55:12+00:00",
        "comment_author": "rstoyanchev",
        "comment_body": "Apologies for the delay. I'm still not too keen on a `Mono` and a `flatMap` for a local method. To provide access to the Reactor Context, I would prefer if the top-level method accessed the `ContextView` and provided to the protected customization methods. For example: \r\n```java\r\nreturn Flux.deferContextual(context -> {\r\n\tObjectReader reader = getObjectReader(mapper, elementType, hints);\r\n\tcustomizeReader(reader, mimeType, elementType, hints, context);\r\n\t// ...\r\n});\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "971189835",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28401,
        "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
        "discussion_id": "927419903",
        "commented_code": "@@ -217,6 +244,32 @@ private ObjectReader getObjectReader(\n \t\t\t\tmapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
        "comment_created_at": "2022-09-14T18:58:02+00:00",
        "comment_author": "rstoyanchev",
        "comment_body": "If you're okay with that, I can make those changes, .",
        "pr_file_module": null
      },
      {
        "comment_id": "971342293",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28401,
        "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
        "discussion_id": "927419903",
        "commented_code": "@@ -217,6 +244,32 @@ private ObjectReader getObjectReader(\n \t\t\t\tmapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
        "comment_created_at": "2022-09-14T22:14:54+00:00",
        "comment_author": "jlaber",
        "comment_body": "What you suggested makes total sense. If you are comfortable making the change, I'm good with it.",
        "pr_file_module": null
      },
      {
        "comment_id": "972063367",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 28401,
        "pr_file": "spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Decoder.java",
        "discussion_id": "927419903",
        "commented_code": "@@ -217,6 +244,32 @@ private ObjectReader getObjectReader(\n \t\t\t\tmapper.readerFor(javaType);\n \t}\n \n+\t/**\n+\t * Provides the ability for subclasses to customize the {@link ObjectReader} for deserialization from a stream.\n+\t * @param reader the {@link ObjectReader} available for customization\n+\t * @param mimeType the MIME type associated with the input stream\n+\t * @param elementType the expected type of elements in the output stream\n+\t * @param hints additional information about how to do encode\n+\t * @return the customized {@link ObjectReader}\n+\t */\n+\tprotected Mono<ObjectReader> customizeReaderFromStream(@NonNull ObjectReader reader, @Nullable MimeType mimeType,\n+\t\t\tResolvableType elementType, @Nullable Map<String, Object> hints) {\n+\t\treturn Mono.just(customizeReader(reader, mimeType, elementType, hints));\n+\t}",
        "comment_created_at": "2022-09-15T14:30:19+00:00",
        "comment_author": "rstoyanchev",
        "comment_body": "Sounds good, thanks.",
        "pr_file_module": null
      }
    ]
  }
]