[
  {
    "discussion_id": "484157702",
    "pr_number": 25715,
    "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
    "created_at": "2020-09-07T02:48:48+00:00",
    "commented_code": "* @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "484157702",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157702",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
        "comment_created_at": "2020-09-07T02:48:48+00:00",
        "comment_author": "wind57",
        "comment_body": "upper-case; java naming convention ",
        "pr_file_module": null
      },
      {
        "comment_id": "484158247",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157702",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
        "comment_created_at": "2020-09-07T02:51:35+00:00",
        "comment_author": "wind57",
        "comment_body": "the thing is, when you add these `Class<?>` to a static cache - you make them GC roots, forever, in this case. Unless there is serious proof that this allocation is perf critical, this might harm more then fix. ",
        "pr_file_module": null
      },
      {
        "comment_id": "484501433",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157702",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
        "comment_created_at": "2020-09-07T15:49:05+00:00",
        "comment_author": "kostya05983",
        "comment_body": "Thanks, use Class<?> getName as a key.",
        "pr_file_module": null
      },
      {
        "comment_id": "484557370",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157702",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
        "comment_created_at": "2020-09-07T20:04:40+00:00",
        "comment_author": "wind57",
        "comment_body": "that's... not what I meant. I mean the fact that you declare a `private static final Map... ` means that you declare an additional GC root. In general, you should not think about these details and just code the way it is easier to read.\r\n\r\nLet's change the angle of this PR a bit, may be that will make more sense. _Why_ is there a need to fix _anything_ here? Because on each invocation there will be a new instance allocated, right? And let me ask you then - why is that bad? Or is it bad at all? ",
        "pr_file_module": null
      },
      {
        "comment_id": "484966349",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157702",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
        "comment_created_at": "2020-09-08T14:30:37+00:00",
        "comment_author": "kostya05983",
        "comment_body": "Yes, we have an instance allocated on each invocation but also we call ConversionUtils.getEnumType(targetType) for each invocation. When we use static cache we save small amount of time on this operations, but we need some warm up the server to work it the fastest way. Also, I want notice that ConversionUtils.getEnum() have a cycle inside. Also, we lost some memory 'cause of cache. I'l be glad if you say some words about how harmful GC root can be.\r\n\r\nSo, I want just to save some time in conversions by this pr.",
        "pr_file_module": null
      },
      {
        "comment_id": "484975714",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157702",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();",
        "comment_created_at": "2020-09-08T14:42:47+00:00",
        "comment_author": "wind57",
        "comment_body": " - I was not saying that the addition of this Map is _harmful_; all I said is that I am not convinced this is something that needs to be \"fixed\". The allocation of such a small Object looks like a very tiny optimization (especially considering that the world is moving towards concurrent GCs, like `Shenandoah` or `ZGC` - where these allocations will not even matter).\r\n\r\n- do you have any proof that you are saving some time, actually? and of course even if that is true, you are paying with memory for that. But now that you add a GC root - you are also _adding_ time for the scanning itself (though it will be very, very little; and for most GCs it will be concurrent).\r\n\r\n - overall, as I said initially, this has to be coded in manner that is easier to read and not think (much) about the details above. I thought that may be you have done some experiments and have some numbers, thus the initial questions.\r\n\r\n- let me also emphasize that I am _pro_ this PR, FYI.  As such, I would like you to revert that key in the map to be a `Class<?>` and not a String. Let's see what the project owners will say. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "484157751",
    "pr_number": 25715,
    "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
    "created_at": "2020-09-07T02:49:04+00:00",
    "commented_code": "* @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();\n \n \t@Override\n \tpublic <T extends Number> Converter<Number, T> getConverter(Class<T> targetType) {\n-\t\treturn new NumberToNumber<>(targetType);\n+\t\tNumberToNumber converter = cache.get(targetType);\n+\t\tif (converter == null) {",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "484157751",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157751",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();\n \n \t@Override\n \tpublic <T extends Number> Converter<Number, T> getConverter(Class<T> targetType) {\n-\t\treturn new NumberToNumber<>(targetType);\n+\t\tNumberToNumber converter = cache.get(targetType);\n+\t\tif (converter == null) {",
        "comment_created_at": "2020-09-07T02:49:04+00:00",
        "comment_author": "wind57",
        "comment_body": "`Map::computeIfAbsent` instead ",
        "pr_file_module": null
      },
      {
        "comment_id": "484501848",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25715,
        "pr_file": "spring-core/src/main/java/org/springframework/core/convert/support/NumberToNumberConverterFactory.java",
        "discussion_id": "484157751",
        "commented_code": "@@ -40,11 +43,18 @@\n  * @see java.math.BigDecimal\n  * @see NumberUtils\n  */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n final class NumberToNumberConverterFactory implements ConverterFactory<Number, Number>, ConditionalConverter {\n+\tprivate final static Map<Class<?>, NumberToNumber<?>> cache = new ConcurrentHashMap<>();\n \n \t@Override\n \tpublic <T extends Number> Converter<Number, T> getConverter(Class<T> targetType) {\n-\t\treturn new NumberToNumber<>(targetType);\n+\t\tNumberToNumber converter = cache.get(targetType);\n+\t\tif (converter == null) {",
        "comment_created_at": "2020-09-07T15:50:04+00:00",
        "comment_author": "kostya05983",
        "comment_body": "Now code is simpler! Thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "771245994",
    "pr_number": 24104,
    "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
    "created_at": "2021-12-17T09:48:36+00:00",
    "commented_code": "try {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "771245994",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24104,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "discussion_id": "771245994",
        "commented_code": "@@ -182,11 +183,18 @@\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);",
        "comment_created_at": "2021-12-17T09:48:36+00:00",
        "comment_author": "sdeleuze",
        "comment_body": "Given the fact that https://github.com/JetBrains/kotlin/pull/2855 has been closed because in practice it brings no benefit, is that part still relevant from your POV and if yes, could you elaborate on why and provide a JMH benchmark to quantify the gains?",
        "pr_file_module": null
      },
      {
        "comment_id": "923549301",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24104,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "discussion_id": "771245994",
        "commented_code": "@@ -182,11 +183,18 @@\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);",
        "comment_created_at": "2022-07-18T16:05:34+00:00",
        "comment_author": "stsypanov",
        "comment_body": "Hi, here's the benchmark:\r\n```kotlin\r\n@State(Scope.Thread)\r\n@BenchmarkMode(Mode.AverageTime)\r\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\nopen class MyBenchmark {\r\n    private val noArgConstructor = TestClass1::class.java.getDeclaredConstructor()\r\n    private val constructor = TestClass2::class.java.getDeclaredConstructor(Int::class.java, String::class.java)\r\n\r\n    @Benchmark\r\n    fun emptyConstructor(): Any {\r\n        return BeanUtils.instantiateClass(noArgConstructor)\r\n    }\r\n\r\n    @Benchmark\r\n    fun nonEmptyConstructor(): Any {\r\n        return BeanUtils.instantiateClass(constructor, 1, \"str\")\r\n    }\r\n\r\n    class TestClass1()\r\n\r\n    class TestClass2(int: Int, string: String)\r\n}\r\n```\r\nResults:\r\n```\r\nbefore\r\n\r\nBenchmark                                                         Mode  Cnt     Score    Error   Units\r\nMyBenchmark.emptyConstructor                                      avgt  100    52,279 ?  1,089   ns/op\r\nMyBenchmark.emptyConstructor:?gc.alloc.rate.norm                  avgt  100   140,815 ?  2,499    B/op\r\nMyBenchmark.nonEmptyConstructor                                   avgt  100   272,787 ?  3,971   ns/op\r\nMyBenchmark.nonEmptyConstructor:?gc.alloc.rate.norm               avgt  100   985,684 ?  4,364    B/op\r\n\r\nafter\r\n\r\nBenchmark                                                         Mode  Cnt     Score    Error   Units\r\nMyBenchmark.emptyConstructor                                      avgt  100    50,635 ?  0,870   ns/op\r\nMyBenchmark.emptyConstructor:?gc.alloc.rate.norm                  avgt  100    91,853 ?  2,329    B/op\r\nMyBenchmark.nonEmptyConstructor                                   avgt  100   265,335 ?  5,555   ns/op\r\nMyBenchmark.nonEmptyConstructor:?gc.alloc.rate.norm               avgt  100   988,885 ?  3,272    B/op\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "771246624",
    "pr_number": 24104,
    "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
    "created_at": "2021-12-17T09:49:27+00:00",
    "commented_code": "try {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);\n+\t\t\t\t}\n \t\t\t\treturn KotlinDelegate.instantiateClass(ctor, args);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tint constructorParamCount = ctor.getParameterCount();\n+\t\t\t\tAssert.isTrue(args.length <= constructorParamCount, \"Can't specify more arguments than constructor parameters\");\n+\t\t\t\tif (constructorParamCount == 0) {\n+\t\t\t\t\treturn ctor.newInstance();",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "771246624",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24104,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "discussion_id": "771246624",
        "commented_code": "@@ -182,11 +183,18 @@\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);\n+\t\t\t\t}\n \t\t\t\treturn KotlinDelegate.instantiateClass(ctor, args);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tint constructorParamCount = ctor.getParameterCount();\n+\t\t\t\tAssert.isTrue(args.length <= constructorParamCount, \"Can't specify more arguments than constructor parameters\");\n+\t\t\t\tif (constructorParamCount == 0) {\n+\t\t\t\t\treturn ctor.newInstance();",
        "comment_created_at": "2021-12-17T09:49:27+00:00",
        "comment_author": "sdeleuze",
        "comment_body": "Could you please provide a JMH benchmark of the gains?",
        "pr_file_module": null
      },
      {
        "comment_id": "771274108",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24104,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "discussion_id": "771246624",
        "commented_code": "@@ -182,11 +183,18 @@\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);\n+\t\t\t\t}\n \t\t\t\treturn KotlinDelegate.instantiateClass(ctor, args);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tint constructorParamCount = ctor.getParameterCount();\n+\t\t\t\tAssert.isTrue(args.length <= constructorParamCount, \"Can't specify more arguments than constructor parameters\");\n+\t\t\t\tif (constructorParamCount == 0) {\n+\t\t\t\t\treturn ctor.newInstance();",
        "comment_created_at": "2021-12-17T10:16:55+00:00",
        "comment_author": "stsypanov",
        "comment_body": "Yeah, I'll try to. The immediate gain here is that we don't allocate a new array calling `ctor.getParameterTypes()` for zero-arg constructor case",
        "pr_file_module": null
      },
      {
        "comment_id": "916960949",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24104,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "discussion_id": "771246624",
        "commented_code": "@@ -182,11 +183,18 @@\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);\n+\t\t\t\t}\n \t\t\t\treturn KotlinDelegate.instantiateClass(ctor, args);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tint constructorParamCount = ctor.getParameterCount();\n+\t\t\t\tAssert.isTrue(args.length <= constructorParamCount, \"Can't specify more arguments than constructor parameters\");\n+\t\t\t\tif (constructorParamCount == 0) {\n+\t\t\t\t\treturn ctor.newInstance();",
        "comment_created_at": "2022-07-08T16:11:02+00:00",
        "comment_author": "sdeleuze",
        "comment_body": "I am still interested by concrete data points with JMH benchmarks before and after the proposed change, could you please provide that?",
        "pr_file_module": null
      },
      {
        "comment_id": "923560563",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24104,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "discussion_id": "771246624",
        "commented_code": "@@ -182,11 +183,18 @@\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(ctor);\n \t\t\tif (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\t\t\tif (ObjectUtils.isEmpty(args)) {\n+\t\t\t\t\treturn KotlinDelegate.instantiateClass(ctor);\n+\t\t\t\t}\n \t\t\t\treturn KotlinDelegate.instantiateClass(ctor, args);\n \t\t\t}\n \t\t\telse {\n+\t\t\t\tint constructorParamCount = ctor.getParameterCount();\n+\t\t\t\tAssert.isTrue(args.length <= constructorParamCount, \"Can't specify more arguments than constructor parameters\");\n+\t\t\t\tif (constructorParamCount == 0) {\n+\t\t\t\t\treturn ctor.newInstance();",
        "comment_created_at": "2022-07-18T16:17:22+00:00",
        "comment_author": "stsypanov",
        "comment_body": "Here's the benchmark:\r\n```java\r\n@State(Scope.Thread)\r\n@BenchmarkMode(Mode.AverageTime)\r\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\npublic class MyBenchmark {\r\n    private Constructor<TestClass1> noArgConstructor;\r\n    private Constructor<TestClass2> constructor;\r\n\r\n    @Setup\r\n    public void setUp() throws NoSuchMethodException {\r\n        noArgConstructor = TestClass1.class.getDeclaredConstructor();\r\n        constructor = TestClass2.class.getDeclaredConstructor(int.class, String.class);\r\n    }\r\n\r\n    @Benchmark\r\n    public Object emptyConstructor() {\r\n        return BeanUtils.instantiateClass(noArgConstructor);\r\n    }\r\n\r\n    @Benchmark\r\n    public Object nonEmptyConstructor() {\r\n        return BeanUtils.instantiateClass(constructor, 1, \"str\");\r\n    }\r\n\r\n    static class TestClass1{\r\n    };\r\n\r\n    static class TestClass2 {\r\n        private final int value1;\r\n        private final String value2;\r\n\r\n        TestClass2(int value1, String value2) {\r\n            this.value1 = value1;\r\n            this.value2 = value2;\r\n        }\r\n    }\r\n}\r\n```\r\nAnd results:\r\n```\r\nbaseline\r\nBenchmark                                                         Mode  Cnt     Score     Error   Units\r\nMyBenchmark.emptyConstructor                                      avgt   40     9,880 \u00b1   0,630   ns/op\r\nMyBenchmark.emptyConstructor:\u00b7gc.alloc.rate.norm                  avgt   40    32,003 \u00b1   0,001    B/op\r\nMyBenchmark.nonEmptyConstructor                                   avgt   40    11,937 \u00b1   0,131   ns/op\r\nMyBenchmark.nonEmptyConstructor:\u00b7gc.alloc.rate.norm               avgt   40    48,004 \u00b1   0,001    B/op\r\n\r\npatched\r\n\r\nBenchmark                                                         Mode  Cnt     Score    Error   Units\r\nMyBenchmark.emptyConstructor                                      avgt   40     5,968 \u00b1  0,112   ns/op\r\nMyBenchmark.emptyConstructor:\u00b7gc.alloc.rate.norm                  avgt   40    16,002 \u00b1  0,001    B/op\r\nMyBenchmark.nonEmptyConstructor                                   avgt   40    11,922 \u00b1  0,255   ns/op\r\nMyBenchmark.nonEmptyConstructor:\u00b7gc.alloc.rate.norm               avgt   40    48,004 \u00b1  0,001    B/op\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "448375424",
    "pr_number": 25298,
    "pr_file": "spring-messaging/src/jmh/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryBenchmark.java",
    "created_at": "2020-07-01T13:47:49+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.messaging.simp.broker;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.simp.SimpMessageHeaderAccessor;\n+import org.springframework.messaging.simp.SimpMessageType;\n+import org.springframework.messaging.support.MessageBuilder;\n+import org.springframework.util.MultiValueMap;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, warmups = 1)\n+@Threads(4)\n+@Measurement(iterations = 3, time = 2)\n+@Warmup(time = 1, iterations = 3)\n+public class DefaultSubscriptionRegistryBenchmark {\n+\n+\t@State(Scope.Benchmark)\n+\tpublic static class ServerState {\n+\t\t@Param(\"1000\")\n+\t\tpublic int numberOfSessions;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int subscriptionsPerSession;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int numberOfDestinations;\n+\n+\t\tpublic DefaultSubscriptionRegistry registry;\n+\n+\t\tpublic String[] destinations;\n+\n+\t\tpublic String[] sessionIds;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup() {\n+\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n+\n+\t\t\tthis.destinations = IntStream.range(0, this.numberOfDestinations)\n+\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tthis.sessionIds = IntStream.range(0, this.numberOfSessions)\n+\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tfor (String sessionId : this.sessionIds) {\n+\t\t\t\tregisterSubscriptions(sessionId, this.subscriptionsPerSession);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void registerSubscriptions(String sessionId, int subscriptionCount) {\n+\t\t\tfor (int subscription = 0; subscription < subscriptionCount; subscription++) {\n+\t\t\t\tString destination = getDestinationForSubscription(subscription);\n+\t\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, \"subscription\" + subscription, destination));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getDestinationForSubscription(int subscription) {\n+\t\t\treturn this.destinations[subscription % this.destinations.length];\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class Requests {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameDestination;\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameSession;\n+\n+\t\tpublic String session;\n+\n+\t\tpublic Message<?> subscribe;\n+\n+\t\tpublic String findDestination;\n+\n+\t\tpublic Message<?> unsubscribe;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tint someInteger = counter.getAndIncrement();\n+\t\t\tif (this.sameSession) {\n+\t\t\t\tthis.session = serverState.sessionIds[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.session = serverState.sessionIds[someInteger % serverState.sessionIds.length];\n+\t\t\t}\n+\t\t\tString subscription = String.valueOf(someInteger);\n+\t\t\tString destination;\n+\t\t\tif (this.sameDestination) {\n+\t\t\t\tdestination = serverState.destinations[0];\n+\t\t\t\tthis.findDestination = serverState.destinations[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t\tthis.findDestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t}\n+\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, destination);\n+\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n+\t\t}\n+\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class UnregisterAllSubscriptionRequest {\n+\n+\t\t@Param(\"20\")\n+\t\tpublic int subscriptionCount;\n+\n+\t\tpublic String session;\n+\n+\t\t@Setup(Level.Invocation)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.session = UUID.randomUUID().toString();\n+\t\t\tserverState.registerSubscriptions(this.session, this.subscriptionCount);\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class FindRequest {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\tpublic String destination;\n+\n+\t\tpublic Message<?> message;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.destination = serverState.destinations[this.counter.getAndIncrement() % serverState.destinations.length];\n+\t\t\tthis.message = null;\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void registerSubscription(ServerState serverState, Requests request) {",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "448375424",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25298,
        "pr_file": "spring-messaging/src/jmh/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryBenchmark.java",
        "discussion_id": "448375424",
        "commented_code": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.messaging.simp.broker;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.simp.SimpMessageHeaderAccessor;\n+import org.springframework.messaging.simp.SimpMessageType;\n+import org.springframework.messaging.support.MessageBuilder;\n+import org.springframework.util.MultiValueMap;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, warmups = 1)\n+@Threads(4)\n+@Measurement(iterations = 3, time = 2)\n+@Warmup(time = 1, iterations = 3)\n+public class DefaultSubscriptionRegistryBenchmark {\n+\n+\t@State(Scope.Benchmark)\n+\tpublic static class ServerState {\n+\t\t@Param(\"1000\")\n+\t\tpublic int numberOfSessions;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int subscriptionsPerSession;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int numberOfDestinations;\n+\n+\t\tpublic DefaultSubscriptionRegistry registry;\n+\n+\t\tpublic String[] destinations;\n+\n+\t\tpublic String[] sessionIds;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup() {\n+\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n+\n+\t\t\tthis.destinations = IntStream.range(0, this.numberOfDestinations)\n+\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tthis.sessionIds = IntStream.range(0, this.numberOfSessions)\n+\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tfor (String sessionId : this.sessionIds) {\n+\t\t\t\tregisterSubscriptions(sessionId, this.subscriptionsPerSession);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void registerSubscriptions(String sessionId, int subscriptionCount) {\n+\t\t\tfor (int subscription = 0; subscription < subscriptionCount; subscription++) {\n+\t\t\t\tString destination = getDestinationForSubscription(subscription);\n+\t\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, \"subscription\" + subscription, destination));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getDestinationForSubscription(int subscription) {\n+\t\t\treturn this.destinations[subscription % this.destinations.length];\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class Requests {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameDestination;\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameSession;\n+\n+\t\tpublic String session;\n+\n+\t\tpublic Message<?> subscribe;\n+\n+\t\tpublic String findDestination;\n+\n+\t\tpublic Message<?> unsubscribe;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tint someInteger = counter.getAndIncrement();\n+\t\t\tif (this.sameSession) {\n+\t\t\t\tthis.session = serverState.sessionIds[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.session = serverState.sessionIds[someInteger % serverState.sessionIds.length];\n+\t\t\t}\n+\t\t\tString subscription = String.valueOf(someInteger);\n+\t\t\tString destination;\n+\t\t\tif (this.sameDestination) {\n+\t\t\t\tdestination = serverState.destinations[0];\n+\t\t\t\tthis.findDestination = serverState.destinations[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t\tthis.findDestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t}\n+\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, destination);\n+\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n+\t\t}\n+\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class UnregisterAllSubscriptionRequest {\n+\n+\t\t@Param(\"20\")\n+\t\tpublic int subscriptionCount;\n+\n+\t\tpublic String session;\n+\n+\t\t@Setup(Level.Invocation)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.session = UUID.randomUUID().toString();\n+\t\t\tserverState.registerSubscriptions(this.session, this.subscriptionCount);\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class FindRequest {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\tpublic String destination;\n+\n+\t\tpublic Message<?> message;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.destination = serverState.destinations[this.counter.getAndIncrement() % serverState.destinations.length];\n+\t\t\tthis.message = null;\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void registerSubscription(ServerState serverState, Requests request) {",
        "comment_created_at": "2020-07-01T13:47:49+00:00",
        "comment_author": "bclozel",
        "comment_body": "Benchmark methods should either return a value or use `Blackhole` to consume values produced by the benchmark method. Without that, we're at risk that the JVM performs dead code elimination. See https://github.com/spring-projects/spring-framework/wiki/Micro-Benchmarks for more information.\r\n\r\nThe register/unregister subscriptions return `void`, but using `Blackhole` on `findSubscriptionsInternal` should do the trick.",
        "pr_file_module": null
      },
      {
        "comment_id": "449159061",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25298,
        "pr_file": "spring-messaging/src/jmh/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryBenchmark.java",
        "discussion_id": "448375424",
        "commented_code": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.messaging.simp.broker;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.simp.SimpMessageHeaderAccessor;\n+import org.springframework.messaging.simp.SimpMessageType;\n+import org.springframework.messaging.support.MessageBuilder;\n+import org.springframework.util.MultiValueMap;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, warmups = 1)\n+@Threads(4)\n+@Measurement(iterations = 3, time = 2)\n+@Warmup(time = 1, iterations = 3)\n+public class DefaultSubscriptionRegistryBenchmark {\n+\n+\t@State(Scope.Benchmark)\n+\tpublic static class ServerState {\n+\t\t@Param(\"1000\")\n+\t\tpublic int numberOfSessions;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int subscriptionsPerSession;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int numberOfDestinations;\n+\n+\t\tpublic DefaultSubscriptionRegistry registry;\n+\n+\t\tpublic String[] destinations;\n+\n+\t\tpublic String[] sessionIds;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup() {\n+\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n+\n+\t\t\tthis.destinations = IntStream.range(0, this.numberOfDestinations)\n+\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tthis.sessionIds = IntStream.range(0, this.numberOfSessions)\n+\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tfor (String sessionId : this.sessionIds) {\n+\t\t\t\tregisterSubscriptions(sessionId, this.subscriptionsPerSession);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void registerSubscriptions(String sessionId, int subscriptionCount) {\n+\t\t\tfor (int subscription = 0; subscription < subscriptionCount; subscription++) {\n+\t\t\t\tString destination = getDestinationForSubscription(subscription);\n+\t\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, \"subscription\" + subscription, destination));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getDestinationForSubscription(int subscription) {\n+\t\t\treturn this.destinations[subscription % this.destinations.length];\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class Requests {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameDestination;\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameSession;\n+\n+\t\tpublic String session;\n+\n+\t\tpublic Message<?> subscribe;\n+\n+\t\tpublic String findDestination;\n+\n+\t\tpublic Message<?> unsubscribe;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tint someInteger = counter.getAndIncrement();\n+\t\t\tif (this.sameSession) {\n+\t\t\t\tthis.session = serverState.sessionIds[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.session = serverState.sessionIds[someInteger % serverState.sessionIds.length];\n+\t\t\t}\n+\t\t\tString subscription = String.valueOf(someInteger);\n+\t\t\tString destination;\n+\t\t\tif (this.sameDestination) {\n+\t\t\t\tdestination = serverState.destinations[0];\n+\t\t\t\tthis.findDestination = serverState.destinations[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t\tthis.findDestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t}\n+\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, destination);\n+\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n+\t\t}\n+\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class UnregisterAllSubscriptionRequest {\n+\n+\t\t@Param(\"20\")\n+\t\tpublic int subscriptionCount;\n+\n+\t\tpublic String session;\n+\n+\t\t@Setup(Level.Invocation)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.session = UUID.randomUUID().toString();\n+\t\t\tserverState.registerSubscriptions(this.session, this.subscriptionCount);\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class FindRequest {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\tpublic String destination;\n+\n+\t\tpublic Message<?> message;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.destination = serverState.destinations[this.counter.getAndIncrement() % serverState.destinations.length];\n+\t\t\tthis.message = null;\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void registerSubscription(ServerState serverState, Requests request) {",
        "comment_created_at": "2020-07-02T17:12:29+00:00",
        "comment_author": "trim09",
        "comment_body": "thanks for this finding, I will add the blackhole",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "448377179",
    "pr_number": 25298,
    "pr_file": "spring-messaging/src/jmh/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryBenchmark.java",
    "created_at": "2020-07-01T13:50:32+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.messaging.simp.broker;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.simp.SimpMessageHeaderAccessor;\n+import org.springframework.messaging.simp.SimpMessageType;\n+import org.springframework.messaging.support.MessageBuilder;\n+import org.springframework.util.MultiValueMap;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, warmups = 1)\n+@Threads(4)\n+@Measurement(iterations = 3, time = 2)\n+@Warmup(time = 1, iterations = 3)\n+public class DefaultSubscriptionRegistryBenchmark {\n+\n+\t@State(Scope.Benchmark)\n+\tpublic static class ServerState {\n+\t\t@Param(\"1000\")\n+\t\tpublic int numberOfSessions;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int subscriptionsPerSession;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int numberOfDestinations;\n+\n+\t\tpublic DefaultSubscriptionRegistry registry;\n+\n+\t\tpublic String[] destinations;\n+\n+\t\tpublic String[] sessionIds;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup() {\n+\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n+\n+\t\t\tthis.destinations = IntStream.range(0, this.numberOfDestinations)\n+\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tthis.sessionIds = IntStream.range(0, this.numberOfSessions)\n+\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tfor (String sessionId : this.sessionIds) {\n+\t\t\t\tregisterSubscriptions(sessionId, this.subscriptionsPerSession);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void registerSubscriptions(String sessionId, int subscriptionCount) {\n+\t\t\tfor (int subscription = 0; subscription < subscriptionCount; subscription++) {\n+\t\t\t\tString destination = getDestinationForSubscription(subscription);\n+\t\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, \"subscription\" + subscription, destination));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getDestinationForSubscription(int subscription) {\n+\t\t\treturn this.destinations[subscription % this.destinations.length];\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class Requests {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameDestination;\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameSession;\n+\n+\t\tpublic String session;\n+\n+\t\tpublic Message<?> subscribe;\n+\n+\t\tpublic String findDestination;\n+\n+\t\tpublic Message<?> unsubscribe;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tint someInteger = counter.getAndIncrement();\n+\t\t\tif (this.sameSession) {\n+\t\t\t\tthis.session = serverState.sessionIds[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.session = serverState.sessionIds[someInteger % serverState.sessionIds.length];\n+\t\t\t}\n+\t\t\tString subscription = String.valueOf(someInteger);\n+\t\t\tString destination;\n+\t\t\tif (this.sameDestination) {\n+\t\t\t\tdestination = serverState.destinations[0];\n+\t\t\t\tthis.findDestination = serverState.destinations[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t\tthis.findDestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t}\n+\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, destination);\n+\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n+\t\t}\n+\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class UnregisterAllSubscriptionRequest {\n+\n+\t\t@Param(\"20\")\n+\t\tpublic int subscriptionCount;\n+\n+\t\tpublic String session;\n+\n+\t\t@Setup(Level.Invocation)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.session = UUID.randomUUID().toString();\n+\t\t\tserverState.registerSubscriptions(this.session, this.subscriptionCount);\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class FindRequest {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\tpublic String destination;\n+\n+\t\tpublic Message<?> message;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.destination = serverState.destinations[this.counter.getAndIncrement() % serverState.destinations.length];\n+\t\t\tthis.message = null;\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void registerSubscription(ServerState serverState, Requests request) {\n+\t\tserverState.registry.registerSubscription(request.subscribe);\n+\t\tserverState.registry.findSubscriptionsInternal(request.findDestination, null);\n+\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n+\t}\n+\n+\t@Benchmark\n+\tpublic void unregisterSession(ServerState serverState, UnregisterAllSubscriptionRequest request) {",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "448377179",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25298,
        "pr_file": "spring-messaging/src/jmh/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryBenchmark.java",
        "discussion_id": "448377179",
        "commented_code": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.messaging.simp.broker;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.simp.SimpMessageHeaderAccessor;\n+import org.springframework.messaging.simp.SimpMessageType;\n+import org.springframework.messaging.support.MessageBuilder;\n+import org.springframework.util.MultiValueMap;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, warmups = 1)\n+@Threads(4)\n+@Measurement(iterations = 3, time = 2)\n+@Warmup(time = 1, iterations = 3)\n+public class DefaultSubscriptionRegistryBenchmark {\n+\n+\t@State(Scope.Benchmark)\n+\tpublic static class ServerState {\n+\t\t@Param(\"1000\")\n+\t\tpublic int numberOfSessions;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int subscriptionsPerSession;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int numberOfDestinations;\n+\n+\t\tpublic DefaultSubscriptionRegistry registry;\n+\n+\t\tpublic String[] destinations;\n+\n+\t\tpublic String[] sessionIds;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup() {\n+\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n+\n+\t\t\tthis.destinations = IntStream.range(0, this.numberOfDestinations)\n+\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tthis.sessionIds = IntStream.range(0, this.numberOfSessions)\n+\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tfor (String sessionId : this.sessionIds) {\n+\t\t\t\tregisterSubscriptions(sessionId, this.subscriptionsPerSession);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void registerSubscriptions(String sessionId, int subscriptionCount) {\n+\t\t\tfor (int subscription = 0; subscription < subscriptionCount; subscription++) {\n+\t\t\t\tString destination = getDestinationForSubscription(subscription);\n+\t\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, \"subscription\" + subscription, destination));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getDestinationForSubscription(int subscription) {\n+\t\t\treturn this.destinations[subscription % this.destinations.length];\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class Requests {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameDestination;\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameSession;\n+\n+\t\tpublic String session;\n+\n+\t\tpublic Message<?> subscribe;\n+\n+\t\tpublic String findDestination;\n+\n+\t\tpublic Message<?> unsubscribe;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tint someInteger = counter.getAndIncrement();\n+\t\t\tif (this.sameSession) {\n+\t\t\t\tthis.session = serverState.sessionIds[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.session = serverState.sessionIds[someInteger % serverState.sessionIds.length];\n+\t\t\t}\n+\t\t\tString subscription = String.valueOf(someInteger);\n+\t\t\tString destination;\n+\t\t\tif (this.sameDestination) {\n+\t\t\t\tdestination = serverState.destinations[0];\n+\t\t\t\tthis.findDestination = serverState.destinations[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t\tthis.findDestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t}\n+\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, destination);\n+\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n+\t\t}\n+\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class UnregisterAllSubscriptionRequest {\n+\n+\t\t@Param(\"20\")\n+\t\tpublic int subscriptionCount;\n+\n+\t\tpublic String session;\n+\n+\t\t@Setup(Level.Invocation)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.session = UUID.randomUUID().toString();\n+\t\t\tserverState.registerSubscriptions(this.session, this.subscriptionCount);\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class FindRequest {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\tpublic String destination;\n+\n+\t\tpublic Message<?> message;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.destination = serverState.destinations[this.counter.getAndIncrement() % serverState.destinations.length];\n+\t\t\tthis.message = null;\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void registerSubscription(ServerState serverState, Requests request) {\n+\t\tserverState.registry.registerSubscription(request.subscribe);\n+\t\tserverState.registry.findSubscriptionsInternal(request.findDestination, null);\n+\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n+\t}\n+\n+\t@Benchmark\n+\tpublic void unregisterSession(ServerState serverState, UnregisterAllSubscriptionRequest request) {",
        "comment_created_at": "2020-07-01T13:50:32+00:00",
        "comment_author": "bclozel",
        "comment_body": "without a way to consume the result of the operation (maybe consuming the list of subscriptions after unregistering?), maybe removing the benchmark is the best course of action...",
        "pr_file_module": null
      },
      {
        "comment_id": "449211939",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25298,
        "pr_file": "spring-messaging/src/jmh/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistryBenchmark.java",
        "discussion_id": "448377179",
        "commented_code": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.messaging.simp.broker;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.simp.SimpMessageHeaderAccessor;\n+import org.springframework.messaging.simp.SimpMessageType;\n+import org.springframework.messaging.support.MessageBuilder;\n+import org.springframework.util.MultiValueMap;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, warmups = 1)\n+@Threads(4)\n+@Measurement(iterations = 3, time = 2)\n+@Warmup(time = 1, iterations = 3)\n+public class DefaultSubscriptionRegistryBenchmark {\n+\n+\t@State(Scope.Benchmark)\n+\tpublic static class ServerState {\n+\t\t@Param(\"1000\")\n+\t\tpublic int numberOfSessions;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int subscriptionsPerSession;\n+\n+\t\t@Param(\"10\")\n+\t\tpublic int numberOfDestinations;\n+\n+\t\tpublic DefaultSubscriptionRegistry registry;\n+\n+\t\tpublic String[] destinations;\n+\n+\t\tpublic String[] sessionIds;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup() {\n+\t\t\tthis.registry = new DefaultSubscriptionRegistry();\n+\n+\t\t\tthis.destinations = IntStream.range(0, this.numberOfDestinations)\n+\t\t\t\t\t.mapToObj(i -> \"/some/destination/\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tthis.sessionIds = IntStream.range(0, this.numberOfSessions)\n+\t\t\t\t\t.mapToObj(i -> \"sessionId_\" + i)\n+\t\t\t\t\t.toArray(String[]::new);\n+\n+\t\t\tfor (String sessionId : this.sessionIds) {\n+\t\t\t\tregisterSubscriptions(sessionId, this.subscriptionsPerSession);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void registerSubscriptions(String sessionId, int subscriptionCount) {\n+\t\t\tfor (int subscription = 0; subscription < subscriptionCount; subscription++) {\n+\t\t\t\tString destination = getDestinationForSubscription(subscription);\n+\t\t\t\tthis.registry.registerSubscription(subscribeMessage(sessionId, \"subscription\" + subscription, destination));\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getDestinationForSubscription(int subscription) {\n+\t\t\treturn this.destinations[subscription % this.destinations.length];\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class Requests {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameDestination;\n+\n+\t\t@Param({\"false\", \"true\"})\n+\t\tboolean sameSession;\n+\n+\t\tpublic String session;\n+\n+\t\tpublic Message<?> subscribe;\n+\n+\t\tpublic String findDestination;\n+\n+\t\tpublic Message<?> unsubscribe;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tint someInteger = counter.getAndIncrement();\n+\t\t\tif (this.sameSession) {\n+\t\t\t\tthis.session = serverState.sessionIds[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.session = serverState.sessionIds[someInteger % serverState.sessionIds.length];\n+\t\t\t}\n+\t\t\tString subscription = String.valueOf(someInteger);\n+\t\t\tString destination;\n+\t\t\tif (this.sameDestination) {\n+\t\t\t\tdestination = serverState.destinations[0];\n+\t\t\t\tthis.findDestination = serverState.destinations[0];\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t\tthis.findDestination = serverState.destinations[someInteger % serverState.destinations.length];\n+\t\t\t}\n+\t\t\tthis.subscribe = subscribeMessage(this.session, subscription, destination);\n+\t\t\tthis.unsubscribe = unsubscribeMessage(this.session, subscription);\n+\t\t}\n+\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class UnregisterAllSubscriptionRequest {\n+\n+\t\t@Param(\"20\")\n+\t\tpublic int subscriptionCount;\n+\n+\t\tpublic String session;\n+\n+\t\t@Setup(Level.Invocation)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.session = UUID.randomUUID().toString();\n+\t\t\tserverState.registerSubscriptions(this.session, this.subscriptionCount);\n+\t\t}\n+\t}\n+\n+\t@State(Scope.Thread)\n+\tpublic static class FindRequest {\n+\t\tpublic static final AtomicInteger counter = new AtomicInteger();\n+\n+\t\tpublic String destination;\n+\n+\t\tpublic Message<?> message;\n+\n+\t\t@Setup(Level.Trial)\n+\t\tpublic void doSetup(ServerState serverState) {\n+\t\t\tthis.destination = serverState.destinations[this.counter.getAndIncrement() % serverState.destinations.length];\n+\t\t\tthis.message = null;\n+\t\t}\n+\t}\n+\n+\t@Benchmark\n+\tpublic void registerSubscription(ServerState serverState, Requests request) {\n+\t\tserverState.registry.registerSubscription(request.subscribe);\n+\t\tserverState.registry.findSubscriptionsInternal(request.findDestination, null);\n+\t\tserverState.registry.unregisterSubscription(request.unsubscribe);\n+\t}\n+\n+\t@Benchmark\n+\tpublic void unregisterSession(ServerState serverState, UnregisterAllSubscriptionRequest request) {",
        "comment_created_at": "2020-07-02T18:58:45+00:00",
        "comment_author": "trim09",
        "comment_body": "Your are right, the JVM eliminated that code and when I add a findSubscriptionsInternal() the \"performance\" dropped. Not it looks like it is measuring something meaningful. Good finding, thank you. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "369800836",
    "pr_number": 24406,
    "pr_file": "spring-web/src/main/java/org/springframework/http/RequestEntity.java",
    "created_at": "2020-01-22T21:01:55+00:00",
    "commented_code": "* @return the URL as a {@code URI}\n \t */\n \tpublic URI getUrl() {\n-\t\treturn this.url;\n+\t\tif (uriTemplate == null) {\n+\t\t\treturn this.url;\n+\t\t}\n+\n+\t\tfinal DefaultUriBuilderFactory defaultUriBuilderFactory = new DefaultUriBuilderFactory();\n+\t\tdefaultUriBuilderFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT);\n+\t\treturn defaultUriBuilderFactory.expand(uriTemplate.toString(), uriVariables);",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "369800836",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24406,
        "pr_file": "spring-web/src/main/java/org/springframework/http/RequestEntity.java",
        "discussion_id": "369800836",
        "commented_code": "@@ -169,9 +195,27 @@ public HttpMethod getMethod() {\n \t * @return the URL as a {@code URI}\n \t */\n \tpublic URI getUrl() {\n-\t\treturn this.url;\n+\t\tif (uriTemplate == null) {\n+\t\t\treturn this.url;\n+\t\t}\n+\n+\t\tfinal DefaultUriBuilderFactory defaultUriBuilderFactory = new DefaultUriBuilderFactory();\n+\t\tdefaultUriBuilderFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT);\n+\t\treturn defaultUriBuilderFactory.expand(uriTemplate.toString(), uriVariables);",
        "comment_created_at": "2020-01-22T21:01:55+00:00",
        "comment_author": "rstoyanchev",
        "comment_body": "This factory be a default instance, not customized, and it should be a static variable so it is not re-created for every request.",
        "pr_file_module": null
      },
      {
        "comment_id": "370033519",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24406,
        "pr_file": "spring-web/src/main/java/org/springframework/http/RequestEntity.java",
        "discussion_id": "369800836",
        "commented_code": "@@ -169,9 +195,27 @@ public HttpMethod getMethod() {\n \t * @return the URL as a {@code URI}\n \t */\n \tpublic URI getUrl() {\n-\t\treturn this.url;\n+\t\tif (uriTemplate == null) {\n+\t\t\treturn this.url;\n+\t\t}\n+\n+\t\tfinal DefaultUriBuilderFactory defaultUriBuilderFactory = new DefaultUriBuilderFactory();\n+\t\tdefaultUriBuilderFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT);\n+\t\treturn defaultUriBuilderFactory.expand(uriTemplate.toString(), uriVariables);",
        "comment_created_at": "2020-01-23T10:16:54+00:00",
        "comment_author": "parviz-93",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1473749978",
    "pr_number": 32097,
    "pr_file": "spring-web/src/main/java/org/springframework/http/server/reactive/JettyCoreServerHttpRequest.java",
    "created_at": "2024-02-01T03:22:38+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.server.reactive;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.io.Content;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.reactivestreams.FlowAdapters;\n+import reactor.core.publisher.Flux;\n+\n+import org.springframework.core.io.buffer.DataBuffer;\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.PooledDataBuffer;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.server.RequestPath;\n+import org.springframework.http.support.JettyHeadersAdapter;\n+import org.springframework.lang.Nullable;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+import org.springframework.util.StringUtils;\n+\n+import static org.springframework.http.server.reactive.AbstractServerHttpRequest.QUERY_PATTERN;\n+\n+/**\n+ * Adapt an Eclipse Jetty {@link Request} to a {@link org.springframework.http.server.ServerHttpRequest}.\n+ *\n+ * @author Greg Wilkins\n+ * @since 6.2\n+ */\n+// TODO: extend AbstractServerHttpRequest for websocket.\n+class JettyCoreServerHttpRequest implements ServerHttpRequest {\n+\tprivate static final MultiValueMap<String, String> EMPTY_QUERY = CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<>());\n+\n+\tprivate static final MultiValueMap<String, HttpCookie> EMPTY_COOKIES = CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<>());\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Request request;\n+\n+\tprivate final HttpHeaders headers;\n+\n+\tprivate final RequestPath path;\n+\n+\t@Nullable\n+\tprivate URI uri;\n+\n+\t@Nullable\n+\tMultiValueMap<String, String> queryParameters;\n+\n+\t@Nullable\n+\tprivate MultiValueMap<String, HttpCookie> cookies;\n+\n+\tpublic JettyCoreServerHttpRequest(DataBufferFactory dataBufferFactory, Request request) {\n+\t\tthis.dataBufferFactory = dataBufferFactory;\n+\t\tthis.request = request;\n+\t\tthis.headers = new HttpHeaders(new JettyHeadersAdapter(request.getHeaders()));\n+\t\tthis.path = RequestPath.parse(request.getHttpURI().getPath(), request.getContext().getContextPath());\n+\t}\n+\n+\t@Override\n+\tpublic HttpHeaders getHeaders() {\n+\t\treturn this.headers;\n+\t}\n+\n+\t@Override\n+\tpublic HttpMethod getMethod() {\n+\t\treturn HttpMethod.valueOf(this.request.getMethod());\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI() {\n+\t\tif (this.uri == null) {\n+\t\t\tthis.uri = this.request.getHttpURI().toURI();\n+\t\t}\n+\t\treturn this.uri;\n+\t}\n+\n+\t@Override\n+\tpublic Flux<DataBuffer> getBody() {\n+\t\t// We access the request body as a Flow.Publisher, which is wrapped as an org.reactivestreams.Publisher and\n+\t\t// then wrapped as a Flux.   The chunks are converted to RetainedDataBuffers with wrapping and can be\n+\t\t// retained within a call to onNext.\n+\n+\t\t// TODO find a better way to release after each onNext call to a subscriber\n+\t\tDataBufferReleaser releaser = new DataBufferReleaser();\n+\t\treturn Flux.from(FlowAdapters.toPublisher(Content.Source.asPublisher(this.request)))\n+\t\t\t\t.map(this::wrap)\n+\t\t\t\t.doOnNext(releaser::onNext)\n+\t\t\t\t.doOnComplete(releaser::onComplete);",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1473749978",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 32097,
        "pr_file": "spring-web/src/main/java/org/springframework/http/server/reactive/JettyCoreServerHttpRequest.java",
        "discussion_id": "1473749978",
        "commented_code": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2002-2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.server.reactive;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.io.Content;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.reactivestreams.FlowAdapters;\n+import reactor.core.publisher.Flux;\n+\n+import org.springframework.core.io.buffer.DataBuffer;\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.PooledDataBuffer;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.server.RequestPath;\n+import org.springframework.http.support.JettyHeadersAdapter;\n+import org.springframework.lang.Nullable;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+import org.springframework.util.StringUtils;\n+\n+import static org.springframework.http.server.reactive.AbstractServerHttpRequest.QUERY_PATTERN;\n+\n+/**\n+ * Adapt an Eclipse Jetty {@link Request} to a {@link org.springframework.http.server.ServerHttpRequest}.\n+ *\n+ * @author Greg Wilkins\n+ * @since 6.2\n+ */\n+// TODO: extend AbstractServerHttpRequest for websocket.\n+class JettyCoreServerHttpRequest implements ServerHttpRequest {\n+\tprivate static final MultiValueMap<String, String> EMPTY_QUERY = CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<>());\n+\n+\tprivate static final MultiValueMap<String, HttpCookie> EMPTY_COOKIES = CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<>());\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Request request;\n+\n+\tprivate final HttpHeaders headers;\n+\n+\tprivate final RequestPath path;\n+\n+\t@Nullable\n+\tprivate URI uri;\n+\n+\t@Nullable\n+\tMultiValueMap<String, String> queryParameters;\n+\n+\t@Nullable\n+\tprivate MultiValueMap<String, HttpCookie> cookies;\n+\n+\tpublic JettyCoreServerHttpRequest(DataBufferFactory dataBufferFactory, Request request) {\n+\t\tthis.dataBufferFactory = dataBufferFactory;\n+\t\tthis.request = request;\n+\t\tthis.headers = new HttpHeaders(new JettyHeadersAdapter(request.getHeaders()));\n+\t\tthis.path = RequestPath.parse(request.getHttpURI().getPath(), request.getContext().getContextPath());\n+\t}\n+\n+\t@Override\n+\tpublic HttpHeaders getHeaders() {\n+\t\treturn this.headers;\n+\t}\n+\n+\t@Override\n+\tpublic HttpMethod getMethod() {\n+\t\treturn HttpMethod.valueOf(this.request.getMethod());\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI() {\n+\t\tif (this.uri == null) {\n+\t\t\tthis.uri = this.request.getHttpURI().toURI();\n+\t\t}\n+\t\treturn this.uri;\n+\t}\n+\n+\t@Override\n+\tpublic Flux<DataBuffer> getBody() {\n+\t\t// We access the request body as a Flow.Publisher, which is wrapped as an org.reactivestreams.Publisher and\n+\t\t// then wrapped as a Flux.   The chunks are converted to RetainedDataBuffers with wrapping and can be\n+\t\t// retained within a call to onNext.\n+\n+\t\t// TODO find a better way to release after each onNext call to a subscriber\n+\t\tDataBufferReleaser releaser = new DataBufferReleaser();\n+\t\treturn Flux.from(FlowAdapters.toPublisher(Content.Source.asPublisher(this.request)))\n+\t\t\t\t.map(this::wrap)\n+\t\t\t\t.doOnNext(releaser::onNext)\n+\t\t\t\t.doOnComplete(releaser::onComplete);",
        "comment_created_at": "2024-02-01T03:22:38+00:00",
        "comment_author": "gregw",
        "comment_body": "@lachlan-roberts @sbordet  previous comment still applies to this version.  This is a little better, but holds onto a databuffer until the next one arrives, which by definition prevents the previous buffer being reused.  We really want to release after onNext has been called.",
        "pr_file_module": null
      },
      {
        "comment_id": "1474218750",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 32097,
        "pr_file": "spring-web/src/main/java/org/springframework/http/server/reactive/JettyCoreServerHttpRequest.java",
        "discussion_id": "1473749978",
        "commented_code": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2002-2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.server.reactive;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Matcher;\n+\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.io.Content;\n+import org.eclipse.jetty.io.EndPoint;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.reactivestreams.FlowAdapters;\n+import reactor.core.publisher.Flux;\n+\n+import org.springframework.core.io.buffer.DataBuffer;\n+import org.springframework.core.io.buffer.DataBufferFactory;\n+import org.springframework.core.io.buffer.PooledDataBuffer;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.server.RequestPath;\n+import org.springframework.http.support.JettyHeadersAdapter;\n+import org.springframework.lang.Nullable;\n+import org.springframework.util.CollectionUtils;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+import org.springframework.util.StringUtils;\n+\n+import static org.springframework.http.server.reactive.AbstractServerHttpRequest.QUERY_PATTERN;\n+\n+/**\n+ * Adapt an Eclipse Jetty {@link Request} to a {@link org.springframework.http.server.ServerHttpRequest}.\n+ *\n+ * @author Greg Wilkins\n+ * @since 6.2\n+ */\n+// TODO: extend AbstractServerHttpRequest for websocket.\n+class JettyCoreServerHttpRequest implements ServerHttpRequest {\n+\tprivate static final MultiValueMap<String, String> EMPTY_QUERY = CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<>());\n+\n+\tprivate static final MultiValueMap<String, HttpCookie> EMPTY_COOKIES = CollectionUtils.unmodifiableMultiValueMap(new LinkedMultiValueMap<>());\n+\n+\tprivate final DataBufferFactory dataBufferFactory;\n+\n+\tprivate final Request request;\n+\n+\tprivate final HttpHeaders headers;\n+\n+\tprivate final RequestPath path;\n+\n+\t@Nullable\n+\tprivate URI uri;\n+\n+\t@Nullable\n+\tMultiValueMap<String, String> queryParameters;\n+\n+\t@Nullable\n+\tprivate MultiValueMap<String, HttpCookie> cookies;\n+\n+\tpublic JettyCoreServerHttpRequest(DataBufferFactory dataBufferFactory, Request request) {\n+\t\tthis.dataBufferFactory = dataBufferFactory;\n+\t\tthis.request = request;\n+\t\tthis.headers = new HttpHeaders(new JettyHeadersAdapter(request.getHeaders()));\n+\t\tthis.path = RequestPath.parse(request.getHttpURI().getPath(), request.getContext().getContextPath());\n+\t}\n+\n+\t@Override\n+\tpublic HttpHeaders getHeaders() {\n+\t\treturn this.headers;\n+\t}\n+\n+\t@Override\n+\tpublic HttpMethod getMethod() {\n+\t\treturn HttpMethod.valueOf(this.request.getMethod());\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI() {\n+\t\tif (this.uri == null) {\n+\t\t\tthis.uri = this.request.getHttpURI().toURI();\n+\t\t}\n+\t\treturn this.uri;\n+\t}\n+\n+\t@Override\n+\tpublic Flux<DataBuffer> getBody() {\n+\t\t// We access the request body as a Flow.Publisher, which is wrapped as an org.reactivestreams.Publisher and\n+\t\t// then wrapped as a Flux.   The chunks are converted to RetainedDataBuffers with wrapping and can be\n+\t\t// retained within a call to onNext.\n+\n+\t\t// TODO find a better way to release after each onNext call to a subscriber\n+\t\tDataBufferReleaser releaser = new DataBufferReleaser();\n+\t\treturn Flux.from(FlowAdapters.toPublisher(Content.Source.asPublisher(this.request)))\n+\t\t\t\t.map(this::wrap)\n+\t\t\t\t.doOnNext(releaser::onNext)\n+\t\t\t\t.doOnComplete(releaser::onComplete);",
        "comment_created_at": "2024-02-01T10:38:57+00:00",
        "comment_author": "gregw",
        "comment_body": "@lachlan-roberts fixed it!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1062027209",
    "pr_number": 29742,
    "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
    "created_at": "2023-01-05T01:46:21+00:00",
    "commented_code": "}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1062027209",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 29742,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
        "discussion_id": "1062027209",
        "commented_code": "@@ -107,15 +107,20 @@ protected boolean needsRefresh(Class<?> clazz) {\n \t}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());",
        "comment_created_at": "2023-01-05T01:46:21+00:00",
        "comment_author": "vlsi",
        "comment_body": "This should be size*4/3 to avoid hash resizes in the for loop below",
        "pr_file_module": null
      },
      {
        "comment_id": "1062028570",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 29742,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
        "discussion_id": "1062027209",
        "commented_code": "@@ -107,15 +107,20 @@ protected boolean needsRefresh(Class<?> clazz) {\n \t}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());",
        "comment_created_at": "2023-01-05T01:48:08+00:00",
        "comment_author": "vlsi",
        "comment_body": "See https://richardstartin.github.io/posts/5-java-mundane-performance-tricks#size-hashmaps-whenever-possible",
        "pr_file_module": null
      },
      {
        "comment_id": "1062274697",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 29742,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
        "discussion_id": "1062027209",
        "commented_code": "@@ -107,15 +107,20 @@ protected boolean needsRefresh(Class<?> clazz) {\n \t}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());",
        "comment_created_at": "2023-01-05T09:34:33+00:00",
        "comment_author": "Dunemaster",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1064101481",
    "pr_number": 29742,
    "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
    "created_at": "2023-01-08T08:25:34+00:00",
    "commented_code": "}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size()*4/3);",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1064101481",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 29742,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
        "discussion_id": "1064101481",
        "commented_code": "@@ -107,15 +107,20 @@ protected boolean needsRefresh(Class<?> clazz) {\n \t}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size()*4/3);",
        "comment_created_at": "2023-01-08T08:25:34+00:00",
        "comment_author": "mjd507",
        "comment_body": "**size * 4 / 3 + 1** should be better for handling table resize corner cases. (like if the original size is 100, the capacity should be 134 instead of 133).\r\n\r\nand for this PR, I don't think we need to specifically handle the empty list case as well as specify the capacity, it makes the code a little bit dirty. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1064107878",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 29742,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.java",
        "discussion_id": "1064101481",
        "commented_code": "@@ -107,15 +107,20 @@ protected boolean needsRefresh(Class<?> clazz) {\n \t}\n \n \tpublic void checkConfigMembers(RootBeanDefinition beanDefinition) {\n-\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size());\n-\t\tfor (InjectedElement element : this.injectedElements) {\n-\t\t\tMember member = element.getMember();\n-\t\t\tif (!beanDefinition.isExternallyManagedConfigMember(member)) {\n-\t\t\t\tbeanDefinition.registerExternallyManagedConfigMember(member);\n-\t\t\t\tcheckedElements.add(element);\n+\t\tif (this.injectedElements.isEmpty()) {\n+\t\t\tthis.checkedElements = Set.of();\n+\t\t}\n+\t\telse {\n+\t\t\tSet<InjectedElement> checkedElements = new LinkedHashSet<>(this.injectedElements.size()*4/3);",
        "comment_created_at": "2023-01-08T09:12:09+00:00",
        "comment_author": "Dunemaster",
        "comment_body": ">and for this PR, I don't think we need to specifically handle the empty list case as well as specify the capacity, it makes the code a little bit dirty.\r\n\r\nThe data from memory dump shows otherwise.  Memory is wasted on numerous empty lists",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "344122550",
    "pr_number": 23582,
    "pr_file": "spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java",
    "created_at": "2019-11-08T11:00:33+00:00",
    "commented_code": "this.host = uriComponents.getHost();\n \t\t\tthis.port = (port == -1 ? (this.secure ? 443 : 80) : port);\n \n+\t\t\tUriComponents remoteUriComponents = UriComponentsBuilder.newInstance()\n+\t\t\t\t\t.host(request.getRemoteHost())\n+\t\t\t\t\t.port(request.getRemotePort())\n+\t\t\t\t\t.adaptFromForwardedForHeader(httpRequest.getHeaders())\n+\t\t\t\t\t.build();",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "344122550",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 23582,
        "pr_file": "spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java",
        "discussion_id": "344122550",
        "commented_code": "@@ -242,6 +251,16 @@ public String getHeader(String name) {\n \t\t\tthis.host = uriComponents.getHost();\n \t\t\tthis.port = (port == -1 ? (this.secure ? 443 : 80) : port);\n \n+\t\t\tUriComponents remoteUriComponents = UriComponentsBuilder.newInstance()\n+\t\t\t\t\t.host(request.getRemoteHost())\n+\t\t\t\t\t.port(request.getRemotePort())\n+\t\t\t\t\t.adaptFromForwardedForHeader(httpRequest.getHeaders())\n+\t\t\t\t\t.build();",
        "comment_created_at": "2019-11-08T11:00:33+00:00",
        "comment_author": "rstoyanchev",
        "comment_body": "It is worth applying some sort of check if this even needs to be done, e.g. \"X-Forwarded-For\" and/or an indexOf scan to see if \"Forward\" has a \"for\" attribute. In hot paths especially we need to reduce Object creation. The same applies for the use of Optional.",
        "pr_file_module": null
      }
    ]
  }
]