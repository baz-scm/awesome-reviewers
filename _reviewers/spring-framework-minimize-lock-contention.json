[
  {
    "discussion_id": "1629713055",
    "pr_number": 32097,
    "pr_file": "spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketSession.java",
    "created_at": "2024-06-06T14:59:54+00:00",
    "commented_code": "/**\n  * Spring {@link WebSocketSession} implementation that adapts to a Jetty\n- * WebSocket {@link org.eclipse.jetty.websocket.api.Session}.\n+ * WebSocket {@link Session}.\n  *\n  * @author Violeta Georgieva\n  * @author Rossen Stoyanchev\n  * @since 5.0\n  */\n-public class JettyWebSocketSession extends AbstractListenerWebSocketSession<Session> {\n+@SuppressWarnings(\"NullAway\")\n+public class JettyWebSocketSession extends AbstractWebSocketSession<Session> {\n+\n+\tprivate final Flux<WebSocketMessage> flux;\n+\tprivate final Sinks.One<CloseStatus> closeStatusSink = Sinks.one();\n+\tprivate final Lock lock = new ReentrantLock();",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1629713055",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 32097,
        "pr_file": "spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/JettyWebSocketSession.java",
        "discussion_id": "1629713055",
        "commented_code": "@@ -36,13 +43,26 @@\n \n /**\n  * Spring {@link WebSocketSession} implementation that adapts to a Jetty\n- * WebSocket {@link org.eclipse.jetty.websocket.api.Session}.\n+ * WebSocket {@link Session}.\n  *\n  * @author Violeta Georgieva\n  * @author Rossen Stoyanchev\n  * @since 5.0\n  */\n-public class JettyWebSocketSession extends AbstractListenerWebSocketSession<Session> {\n+@SuppressWarnings(\"NullAway\")\n+public class JettyWebSocketSession extends AbstractWebSocketSession<Session> {\n+\n+\tprivate final Flux<WebSocketMessage> flux;\n+\tprivate final Sinks.One<CloseStatus> closeStatusSink = Sinks.one();\n+\tprivate final Lock lock = new ReentrantLock();",
        "comment_created_at": "2024-06-06T14:59:54+00:00",
        "comment_author": "simonbasle",
        "comment_body": "This `Lock` got my attention because pessimistic locking is usually not the first go-to method in Reactive Streams. Instead it's usually some sort of optimistic locking with a CAS loop.\r\n\r\nThat said, the lock protects 2 critical sections that represent quick state checks and updates. There is precedent for that sort of things, e.g. in `Reactor`, so in that case I think it is fine (although care will need to be exercised if the code is modified or new usage of the lock is introduced).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "503437946",
    "pr_number": 25899,
    "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
    "created_at": "2020-10-12T17:31:57+00:00",
    "commented_code": "}\n \t\t\t\tsynchronized (this) {\n \t\t\t\t\tif (!this.cached) {\n+\t\t\t\t\t\tObject cachedFieldValue = null;\n \t\t\t\t\t\tif (value != null || this.required) {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n+\t\t\t\t\t\t\tcachedFieldValue = desc;\n \t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n \t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n \t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n \t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName) &&\n \t\t\t\t\t\t\t\t\t\tbeanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n-\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n+\t\t\t\t\t\t\t\t\tcachedFieldValue = new ShortcutDependencyDescriptor(\n \t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.cachedFieldValue = cachedFieldValue;",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "503437946",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25899,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "discussion_id": "503437946",
        "commented_code": "@@ -644,21 +644,20 @@ protected void inject(Object bean, @Nullable String beanName, @Nullable Property\n \t\t\t\t}\n \t\t\t\tsynchronized (this) {\n \t\t\t\t\tif (!this.cached) {\n+\t\t\t\t\t\tObject cachedFieldValue = null;\n \t\t\t\t\t\tif (value != null || this.required) {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n+\t\t\t\t\t\t\tcachedFieldValue = desc;\n \t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n \t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n \t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n \t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName) &&\n \t\t\t\t\t\t\t\t\t\tbeanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n-\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n+\t\t\t\t\t\t\t\t\tcachedFieldValue = new ShortcutDependencyDescriptor(\n \t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.cachedFieldValue = cachedFieldValue;",
        "comment_created_at": "2020-10-12T17:31:57+00:00",
        "comment_author": "wind57",
        "comment_body": "hmm, but `cachedFieldValue` _and_ `cached` is `volatile`? A volatile write (`this.cached = true`) ensures that all _subsequent_ reads that see this write, will also observer a fully and initialized `cachedFieldValue`... what I am missing? ",
        "pr_file_module": null
      },
      {
        "comment_id": "503754739",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25899,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "discussion_id": "503437946",
        "commented_code": "@@ -644,21 +644,20 @@ protected void inject(Object bean, @Nullable String beanName, @Nullable Property\n \t\t\t\t}\n \t\t\t\tsynchronized (this) {\n \t\t\t\t\tif (!this.cached) {\n+\t\t\t\t\t\tObject cachedFieldValue = null;\n \t\t\t\t\t\tif (value != null || this.required) {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n+\t\t\t\t\t\t\tcachedFieldValue = desc;\n \t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n \t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n \t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n \t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName) &&\n \t\t\t\t\t\t\t\t\t\tbeanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n-\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n+\t\t\t\t\t\t\t\t\tcachedFieldValue = new ShortcutDependencyDescriptor(\n \t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.cachedFieldValue = cachedFieldValue;",
        "comment_created_at": "2020-10-13T08:15:15+00:00",
        "comment_author": "stsypanov",
        "comment_body": "Nothing changes here as of seeing `cachedFieldValue`, because 1) we are inside of synchronized block and 2) `cachedFieldValue` is anyway assigned. Here I try to avoid the case when we assign `this.cachedFieldValue = desc;` (line 648 in original code) and then reassign it with `new ShortcutDependencyDescriptor()` (line 654 in original code) which is redundant. Instead we can write the values into an intermediate variable and then write it into volatile field only once",
        "pr_file_module": null
      },
      {
        "comment_id": "504017500",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25899,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "discussion_id": "503437946",
        "commented_code": "@@ -644,21 +644,20 @@ protected void inject(Object bean, @Nullable String beanName, @Nullable Property\n \t\t\t\t}\n \t\t\t\tsynchronized (this) {\n \t\t\t\t\tif (!this.cached) {\n+\t\t\t\t\t\tObject cachedFieldValue = null;\n \t\t\t\t\t\tif (value != null || this.required) {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n+\t\t\t\t\t\t\tcachedFieldValue = desc;\n \t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n \t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n \t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n \t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName) &&\n \t\t\t\t\t\t\t\t\t\tbeanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n-\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n+\t\t\t\t\t\t\t\t\tcachedFieldValue = new ShortcutDependencyDescriptor(\n \t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.cachedFieldValue = cachedFieldValue;",
        "comment_created_at": "2020-10-13T14:51:36+00:00",
        "comment_author": "wind57",
        "comment_body": "may be I was not clear enough, sorry. I perfectly understand what you are trying to do - yes, it also makes sense. No question about it. There is a minor problem with your reasoning (or wording) : indeed you are doing the _write_ in a `synchronized` block, but the _read_ happens outside:\r\n\r\n```\r\nif (this.cached) {\r\n\tvalue = resolvedCachedArgument(beanName, this.cachedFieldValue);\r\n}\r\n```\r\n\r\nanyway, that is not the point I was trying to make. \r\n\r\nMy question is rather different, why keep `cachedFieldValue` as `volatile`? It surely looks like `cached` being `volatile` would be enough.  Does that make sense now?",
        "pr_file_module": null
      },
      {
        "comment_id": "505359080",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25899,
        "pr_file": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "discussion_id": "503437946",
        "commented_code": "@@ -644,21 +644,20 @@ protected void inject(Object bean, @Nullable String beanName, @Nullable Property\n \t\t\t\t}\n \t\t\t\tsynchronized (this) {\n \t\t\t\t\tif (!this.cached) {\n+\t\t\t\t\t\tObject cachedFieldValue = null;\n \t\t\t\t\t\tif (value != null || this.required) {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n+\t\t\t\t\t\t\tcachedFieldValue = desc;\n \t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n \t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n \t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n \t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName) &&\n \t\t\t\t\t\t\t\t\t\tbeanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n-\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n+\t\t\t\t\t\t\t\t\tcachedFieldValue = new ShortcutDependencyDescriptor(\n \t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tthis.cachedFieldValue = cachedFieldValue;",
        "comment_created_at": "2020-10-15T08:48:28+00:00",
        "comment_author": "stsypanov",
        "comment_body": "Yes,now I clearly understand your point. I'd keep `cachedFieldValue`volatile because it's not a bottleneck, and there's a risk of breaking the code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "449294821",
    "pr_number": 25298,
    "pr_file": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java",
    "created_at": "2020-07-02T22:35:20+00:00",
    "commented_code": "}\n \t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n \t\tallMatches.forEach((sessionId, subIds) -> {\n-\t\t\tfor (String subId : subIds) {\n-\t\t\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId);\n-\t\t\t\tif (info == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tSubscription sub = info.getSubscription(subId);\n-\t\t\t\tif (sub == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tExpression expression = sub.getSelectorExpression();\n-\t\t\t\tif (expression == null) {\n-\t\t\t\t\tresult.add(sessionId, subId);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tif (Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {\n-\t\t\t\t\t\tresult.add(sessionId, subId);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tcatch (SpelEvaluationException ex) {\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Failed to evaluate selector: \" + ex.getMessage());\n+\t\t\tSessionSubscriptionInfo subscriptions = this.subscriptionRegistry.getSubscriptions(sessionId);\n+\t\t\tif (subscriptions != null) {\n+\t\t\t\tfor (String subId : subIds) {\n+\t\t\t\t\tSubscription subscription = subscriptions.getSubscription(subId);\n+\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelectorExpression(), message)) {\n+\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\tlogger.debug(\"Failed to evaluate selector\", ex);\n-\t\t\t\t}\n \t\t\t}\n \t\t});\n+\n \t\treturn result;\n \t}\n \n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"DefaultSubscriptionRegistry[\" + this.destinationCache + \", \" + this.subscriptionRegistry + \"]\";\n+\tprivate boolean evaluateExpression(@Nullable Expression expression, Message<?> message) {\n+\t\tboolean result = false;\n+\t\ttry {\n+\t\t\tif (expression == null || Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {\n+\t\t\t\tresult = true;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (SpelEvaluationException ex) {\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Failed to evaluate selector: \" + ex.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Throwable ex) {\n+\t\t\tlogger.debug(\"Failed to evaluate selector\", ex);\n+\t\t}\n+\t\treturn result;\n \t}\n \n-\n \t/**\n \t * A cache for destinations previously resolved via\n \t * {@link DefaultSubscriptionRegistry#findSubscriptionsInternal(String, Message)}.\n \t */\n-\tprivate class DestinationCache {\n+\tprivate final class DestinationCache {\n \n \t\t/** Map from destination to {@code <sessionId, subscriptionId>} for fast look-ups. */\n-\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> accessCache =\n+\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> destinationCache =\n \t\t\t\tnew ConcurrentHashMap<>(DEFAULT_CACHE_LIMIT);\n \n-\t\t/** Map from destination to {@code <sessionId, subscriptionId>} with locking. */\n-\t\t@SuppressWarnings(\"serial\")\n-\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> updateCache =\n-\t\t\t\tnew LinkedHashMap<String, LinkedMultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT, 0.75f, true) {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, LinkedMultiValueMap<String, String>> eldest) {\n-\t\t\t\t\t\tif (size() > getCacheLimit()) {\n-\t\t\t\t\t\t\taccessCache.remove(eldest.getKey());\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\n-\n-\t\tpublic LinkedMultiValueMap<String, String> getSubscriptions(String destination, Message<?> message) {\n-\t\t\tLinkedMultiValueMap<String, String> result = this.accessCache.get(destination);\n-\t\t\tif (result == null) {\n-\t\t\t\tsynchronized (this.updateCache) {\n-\t\t\t\t\tresult = new LinkedMultiValueMap<>();\n-\t\t\t\t\tfor (SessionSubscriptionInfo info : subscriptionRegistry.getAllSubscriptions()) {\n-\t\t\t\t\t\tfor (String destinationPattern : info.getDestinations()) {\n-\t\t\t\t\t\t\tif (getPathMatcher().match(destinationPattern, destination)) {\n-\t\t\t\t\t\t\t\tfor (Subscription sub : info.getSubscriptions(destinationPattern)) {\n-\t\t\t\t\t\t\t\t\tresult.add(info.sessionId, sub.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (!result.isEmpty()) {\n-\t\t\t\t\t\tthis.updateCache.put(destination, result.deepCopy());\n-\t\t\t\t\t\tthis.accessCache.put(destination, result);\n+\t\tprivate final Queue<String> cacheEvictionPolicy = new LinkedBlockingQueue<>();",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "449294821",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25298,
        "pr_file": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java",
        "discussion_id": "449294821",
        "commented_code": "@@ -208,304 +214,250 @@ public void unregisterAllSubscriptions(String sessionId) {\n \t\t}\n \t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n \t\tallMatches.forEach((sessionId, subIds) -> {\n-\t\t\tfor (String subId : subIds) {\n-\t\t\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId);\n-\t\t\t\tif (info == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tSubscription sub = info.getSubscription(subId);\n-\t\t\t\tif (sub == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tExpression expression = sub.getSelectorExpression();\n-\t\t\t\tif (expression == null) {\n-\t\t\t\t\tresult.add(sessionId, subId);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tif (Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {\n-\t\t\t\t\t\tresult.add(sessionId, subId);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tcatch (SpelEvaluationException ex) {\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Failed to evaluate selector: \" + ex.getMessage());\n+\t\t\tSessionSubscriptionInfo subscriptions = this.subscriptionRegistry.getSubscriptions(sessionId);\n+\t\t\tif (subscriptions != null) {\n+\t\t\t\tfor (String subId : subIds) {\n+\t\t\t\t\tSubscription subscription = subscriptions.getSubscription(subId);\n+\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelectorExpression(), message)) {\n+\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\tlogger.debug(\"Failed to evaluate selector\", ex);\n-\t\t\t\t}\n \t\t\t}\n \t\t});\n+\n \t\treturn result;\n \t}\n \n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"DefaultSubscriptionRegistry[\" + this.destinationCache + \", \" + this.subscriptionRegistry + \"]\";\n+\tprivate boolean evaluateExpression(@Nullable Expression expression, Message<?> message) {\n+\t\tboolean result = false;\n+\t\ttry {\n+\t\t\tif (expression == null || Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {\n+\t\t\t\tresult = true;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (SpelEvaluationException ex) {\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Failed to evaluate selector: \" + ex.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Throwable ex) {\n+\t\t\tlogger.debug(\"Failed to evaluate selector\", ex);\n+\t\t}\n+\t\treturn result;\n \t}\n \n-\n \t/**\n \t * A cache for destinations previously resolved via\n \t * {@link DefaultSubscriptionRegistry#findSubscriptionsInternal(String, Message)}.\n \t */\n-\tprivate class DestinationCache {\n+\tprivate final class DestinationCache {\n \n \t\t/** Map from destination to {@code <sessionId, subscriptionId>} for fast look-ups. */\n-\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> accessCache =\n+\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> destinationCache =\n \t\t\t\tnew ConcurrentHashMap<>(DEFAULT_CACHE_LIMIT);\n \n-\t\t/** Map from destination to {@code <sessionId, subscriptionId>} with locking. */\n-\t\t@SuppressWarnings(\"serial\")\n-\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> updateCache =\n-\t\t\t\tnew LinkedHashMap<String, LinkedMultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT, 0.75f, true) {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, LinkedMultiValueMap<String, String>> eldest) {\n-\t\t\t\t\t\tif (size() > getCacheLimit()) {\n-\t\t\t\t\t\t\taccessCache.remove(eldest.getKey());\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\n-\n-\t\tpublic LinkedMultiValueMap<String, String> getSubscriptions(String destination, Message<?> message) {\n-\t\t\tLinkedMultiValueMap<String, String> result = this.accessCache.get(destination);\n-\t\t\tif (result == null) {\n-\t\t\t\tsynchronized (this.updateCache) {\n-\t\t\t\t\tresult = new LinkedMultiValueMap<>();\n-\t\t\t\t\tfor (SessionSubscriptionInfo info : subscriptionRegistry.getAllSubscriptions()) {\n-\t\t\t\t\t\tfor (String destinationPattern : info.getDestinations()) {\n-\t\t\t\t\t\t\tif (getPathMatcher().match(destinationPattern, destination)) {\n-\t\t\t\t\t\t\t\tfor (Subscription sub : info.getSubscriptions(destinationPattern)) {\n-\t\t\t\t\t\t\t\t\tresult.add(info.sessionId, sub.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (!result.isEmpty()) {\n-\t\t\t\t\t\tthis.updateCache.put(destination, result.deepCopy());\n-\t\t\t\t\t\tthis.accessCache.put(destination, result);\n+\t\tprivate final Queue<String> cacheEvictionPolicy = new LinkedBlockingQueue<>();",
        "comment_created_at": "2020-07-02T22:35:20+00:00",
        "comment_author": "trim09",
        "comment_body": "I did some perf testing of \"LinkedBlockingQueue vs ConcurrentLinkedQueue\" and I have no clear winner.\r\nI think ConcurrentLinkedQueue.size() would cause lots of CPU cache miss while traversing through the whole linked list. That is something I don't know hot to test on local machine without some bigger test preparation. That is why I left LinkedBlockingQueue there, but I will change it to ConcurrentLinkedQueue if you like it more.",
        "pr_file_module": null
      },
      {
        "comment_id": "449769839",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25298,
        "pr_file": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java",
        "discussion_id": "449294821",
        "commented_code": "@@ -208,304 +214,250 @@ public void unregisterAllSubscriptions(String sessionId) {\n \t\t}\n \t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<>(allMatches.size());\n \t\tallMatches.forEach((sessionId, subIds) -> {\n-\t\t\tfor (String subId : subIds) {\n-\t\t\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId);\n-\t\t\t\tif (info == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tSubscription sub = info.getSubscription(subId);\n-\t\t\t\tif (sub == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tExpression expression = sub.getSelectorExpression();\n-\t\t\t\tif (expression == null) {\n-\t\t\t\t\tresult.add(sessionId, subId);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\ttry {\n-\t\t\t\t\tif (Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {\n-\t\t\t\t\t\tresult.add(sessionId, subId);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tcatch (SpelEvaluationException ex) {\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Failed to evaluate selector: \" + ex.getMessage());\n+\t\t\tSessionSubscriptionInfo subscriptions = this.subscriptionRegistry.getSubscriptions(sessionId);\n+\t\t\tif (subscriptions != null) {\n+\t\t\t\tfor (String subId : subIds) {\n+\t\t\t\t\tSubscription subscription = subscriptions.getSubscription(subId);\n+\t\t\t\t\tif (subscription != null && evaluateExpression(subscription.getSelectorExpression(), message)) {\n+\t\t\t\t\t\tresult.add(sessionId, subscription.getId());\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tcatch (Throwable ex) {\n-\t\t\t\t\tlogger.debug(\"Failed to evaluate selector\", ex);\n-\t\t\t\t}\n \t\t\t}\n \t\t});\n+\n \t\treturn result;\n \t}\n \n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"DefaultSubscriptionRegistry[\" + this.destinationCache + \", \" + this.subscriptionRegistry + \"]\";\n+\tprivate boolean evaluateExpression(@Nullable Expression expression, Message<?> message) {\n+\t\tboolean result = false;\n+\t\ttry {\n+\t\t\tif (expression == null || Boolean.TRUE.equals(expression.getValue(messageEvalContext, message, Boolean.class))) {\n+\t\t\t\tresult = true;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (SpelEvaluationException ex) {\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Failed to evaluate selector: \" + ex.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Throwable ex) {\n+\t\t\tlogger.debug(\"Failed to evaluate selector\", ex);\n+\t\t}\n+\t\treturn result;\n \t}\n \n-\n \t/**\n \t * A cache for destinations previously resolved via\n \t * {@link DefaultSubscriptionRegistry#findSubscriptionsInternal(String, Message)}.\n \t */\n-\tprivate class DestinationCache {\n+\tprivate final class DestinationCache {\n \n \t\t/** Map from destination to {@code <sessionId, subscriptionId>} for fast look-ups. */\n-\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> accessCache =\n+\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> destinationCache =\n \t\t\t\tnew ConcurrentHashMap<>(DEFAULT_CACHE_LIMIT);\n \n-\t\t/** Map from destination to {@code <sessionId, subscriptionId>} with locking. */\n-\t\t@SuppressWarnings(\"serial\")\n-\t\tprivate final Map<String, LinkedMultiValueMap<String, String>> updateCache =\n-\t\t\t\tnew LinkedHashMap<String, LinkedMultiValueMap<String, String>>(DEFAULT_CACHE_LIMIT, 0.75f, true) {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, LinkedMultiValueMap<String, String>> eldest) {\n-\t\t\t\t\t\tif (size() > getCacheLimit()) {\n-\t\t\t\t\t\t\taccessCache.remove(eldest.getKey());\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\treturn false;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t};\n-\n-\n-\t\tpublic LinkedMultiValueMap<String, String> getSubscriptions(String destination, Message<?> message) {\n-\t\t\tLinkedMultiValueMap<String, String> result = this.accessCache.get(destination);\n-\t\t\tif (result == null) {\n-\t\t\t\tsynchronized (this.updateCache) {\n-\t\t\t\t\tresult = new LinkedMultiValueMap<>();\n-\t\t\t\t\tfor (SessionSubscriptionInfo info : subscriptionRegistry.getAllSubscriptions()) {\n-\t\t\t\t\t\tfor (String destinationPattern : info.getDestinations()) {\n-\t\t\t\t\t\t\tif (getPathMatcher().match(destinationPattern, destination)) {\n-\t\t\t\t\t\t\t\tfor (Subscription sub : info.getSubscriptions(destinationPattern)) {\n-\t\t\t\t\t\t\t\t\tresult.add(info.sessionId, sub.getId());\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (!result.isEmpty()) {\n-\t\t\t\t\t\tthis.updateCache.put(destination, result.deepCopy());\n-\t\t\t\t\t\tthis.accessCache.put(destination, result);\n+\t\tprivate final Queue<String> cacheEvictionPolicy = new LinkedBlockingQueue<>();",
        "comment_created_at": "2020-07-04T12:36:33+00:00",
        "comment_author": "trim09",
        "comment_body": "finally, I used ConcurrentLinkedQueue and AtomicInteger to maintain the size.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "392868900",
    "pr_number": 24469,
    "pr_file": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
    "created_at": "2020-03-16T09:03:20+00:00",
    "commented_code": "private final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();\n \n-\t\tprivate final ReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\tprivate final Lock readLock;\n+\n+\t\tprivate final Lock writeLock;\n \n \t\tprivate final Function<K, V> generator;\n \n+\t\tprivate volatile int size = 0;\n+\n \t\tpublic ConcurrentLruCache(int maxSize, Function<K, V> generator) {\n \t\t\tAssert.isTrue(maxSize > 0, \"LRU max size should be positive\");\n \t\t\tAssert.notNull(generator, \"Generator function should not be null\");\n \t\t\tthis.maxSize = maxSize;\n \t\t\tthis.generator = generator;\n+\n+\t\t\tReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\t\tthis.readLock = lock.readLock();\n+\t\t\tthis.writeLock = lock.writeLock();\n \t\t}\n \n \t\tpublic V get(K key) {\n-\t\t\tthis.lock.readLock().lock();\n-\t\t\ttry {\n-\t\t\t\tif (this.queue.size() < this.maxSize / 2) {\n-\t\t\t\t\tV cached = this.cache.get(key);\n-\t\t\t\t\tif (cached != null) {\n-\t\t\t\t\t\treturn cached;\n-\t\t\t\t\t}\n+\t\t\tV cached;\n+\n+\t\t\tif ((cached = this.cache.get(key)) != null) {\n+\t\t\t\tif (this.size < this.maxSize / 2) {\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\telse if (this.queue.remove(key)) {\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tthis.readLock.lock();\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.readLock.unlock();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tthis.lock.readLock().unlock();\n-\t\t\t}\n-\t\t\tthis.lock.writeLock().lock();\n+\n+\t\t\tthis.writeLock.lock();\n \t\t\ttry {\n \t\t\t\t// retrying in case of concurrent reads on the same key\n-\t\t\t\tif (this.queue.remove(key)) {\n+\t\t\t\tif ((cached = this.cache.get(key)) != null) {\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\tif (this.queue.size() == this.maxSize) {\n+\n+\t\t\t\tint cacheSize = this.size;\n+\t\t\t\tif (cacheSize == this.maxSize) {",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "392868900",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24469,
        "pr_file": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "discussion_id": "392868900",
        "commented_code": "@@ -420,54 +421,71 @@ public static String generateMultipartBoundaryString() {\n \n \t\tprivate final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();\n \n-\t\tprivate final ReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\tprivate final Lock readLock;\n+\n+\t\tprivate final Lock writeLock;\n \n \t\tprivate final Function<K, V> generator;\n \n+\t\tprivate volatile int size = 0;\n+\n \t\tpublic ConcurrentLruCache(int maxSize, Function<K, V> generator) {\n \t\t\tAssert.isTrue(maxSize > 0, \"LRU max size should be positive\");\n \t\t\tAssert.notNull(generator, \"Generator function should not be null\");\n \t\t\tthis.maxSize = maxSize;\n \t\t\tthis.generator = generator;\n+\n+\t\t\tReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\t\tthis.readLock = lock.readLock();\n+\t\t\tthis.writeLock = lock.writeLock();\n \t\t}\n \n \t\tpublic V get(K key) {\n-\t\t\tthis.lock.readLock().lock();\n-\t\t\ttry {\n-\t\t\t\tif (this.queue.size() < this.maxSize / 2) {\n-\t\t\t\t\tV cached = this.cache.get(key);\n-\t\t\t\t\tif (cached != null) {\n-\t\t\t\t\t\treturn cached;\n-\t\t\t\t\t}\n+\t\t\tV cached;\n+\n+\t\t\tif ((cached = this.cache.get(key)) != null) {\n+\t\t\t\tif (this.size < this.maxSize / 2) {\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\telse if (this.queue.remove(key)) {\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tthis.readLock.lock();\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.readLock.unlock();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tthis.lock.readLock().unlock();\n-\t\t\t}\n-\t\t\tthis.lock.writeLock().lock();\n+\n+\t\t\tthis.writeLock.lock();\n \t\t\ttry {\n \t\t\t\t// retrying in case of concurrent reads on the same key\n-\t\t\t\tif (this.queue.remove(key)) {\n+\t\t\t\tif ((cached = this.cache.get(key)) != null) {\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\tif (this.queue.size() == this.maxSize) {\n+\n+\t\t\t\tint cacheSize = this.size;\n+\t\t\t\tif (cacheSize == this.maxSize) {",
        "comment_created_at": "2020-03-16T09:03:20+00:00",
        "comment_author": "Percy0601",
        "comment_body": "Recommended to use >= instead of ==, Even if there is a problem with the write lock, it will not cause NOT LIMIT Cache",
        "pr_file_module": null
      },
      {
        "comment_id": "393446141",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24469,
        "pr_file": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "discussion_id": "392868900",
        "commented_code": "@@ -420,54 +421,71 @@ public static String generateMultipartBoundaryString() {\n \n \t\tprivate final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();\n \n-\t\tprivate final ReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\tprivate final Lock readLock;\n+\n+\t\tprivate final Lock writeLock;\n \n \t\tprivate final Function<K, V> generator;\n \n+\t\tprivate volatile int size = 0;\n+\n \t\tpublic ConcurrentLruCache(int maxSize, Function<K, V> generator) {\n \t\t\tAssert.isTrue(maxSize > 0, \"LRU max size should be positive\");\n \t\t\tAssert.notNull(generator, \"Generator function should not be null\");\n \t\t\tthis.maxSize = maxSize;\n \t\t\tthis.generator = generator;\n+\n+\t\t\tReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\t\tthis.readLock = lock.readLock();\n+\t\t\tthis.writeLock = lock.writeLock();\n \t\t}\n \n \t\tpublic V get(K key) {\n-\t\t\tthis.lock.readLock().lock();\n-\t\t\ttry {\n-\t\t\t\tif (this.queue.size() < this.maxSize / 2) {\n-\t\t\t\t\tV cached = this.cache.get(key);\n-\t\t\t\t\tif (cached != null) {\n-\t\t\t\t\t\treturn cached;\n-\t\t\t\t\t}\n+\t\t\tV cached;\n+\n+\t\t\tif ((cached = this.cache.get(key)) != null) {\n+\t\t\t\tif (this.size < this.maxSize / 2) {\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\telse if (this.queue.remove(key)) {\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tthis.readLock.lock();\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.readLock.unlock();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tthis.lock.readLock().unlock();\n-\t\t\t}\n-\t\t\tthis.lock.writeLock().lock();\n+\n+\t\t\tthis.writeLock.lock();\n \t\t\ttry {\n \t\t\t\t// retrying in case of concurrent reads on the same key\n-\t\t\t\tif (this.queue.remove(key)) {\n+\t\t\t\tif ((cached = this.cache.get(key)) != null) {\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\tif (this.queue.size() == this.maxSize) {\n+\n+\t\t\t\tint cacheSize = this.size;\n+\t\t\t\tif (cacheSize == this.maxSize) {",
        "comment_created_at": "2020-03-17T05:01:37+00:00",
        "comment_author": "bananayong",
        "comment_body": "I don't understand how is it possible to occur a problem with write lock.",
        "pr_file_module": null
      },
      {
        "comment_id": "393469478",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24469,
        "pr_file": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "discussion_id": "392868900",
        "commented_code": "@@ -420,54 +421,71 @@ public static String generateMultipartBoundaryString() {\n \n \t\tprivate final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();\n \n-\t\tprivate final ReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\tprivate final Lock readLock;\n+\n+\t\tprivate final Lock writeLock;\n \n \t\tprivate final Function<K, V> generator;\n \n+\t\tprivate volatile int size = 0;\n+\n \t\tpublic ConcurrentLruCache(int maxSize, Function<K, V> generator) {\n \t\t\tAssert.isTrue(maxSize > 0, \"LRU max size should be positive\");\n \t\t\tAssert.notNull(generator, \"Generator function should not be null\");\n \t\t\tthis.maxSize = maxSize;\n \t\t\tthis.generator = generator;\n+\n+\t\t\tReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\t\tthis.readLock = lock.readLock();\n+\t\t\tthis.writeLock = lock.writeLock();\n \t\t}\n \n \t\tpublic V get(K key) {\n-\t\t\tthis.lock.readLock().lock();\n-\t\t\ttry {\n-\t\t\t\tif (this.queue.size() < this.maxSize / 2) {\n-\t\t\t\t\tV cached = this.cache.get(key);\n-\t\t\t\t\tif (cached != null) {\n-\t\t\t\t\t\treturn cached;\n-\t\t\t\t\t}\n+\t\t\tV cached;\n+\n+\t\t\tif ((cached = this.cache.get(key)) != null) {\n+\t\t\t\tif (this.size < this.maxSize / 2) {\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\telse if (this.queue.remove(key)) {\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tthis.readLock.lock();\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.readLock.unlock();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tthis.lock.readLock().unlock();\n-\t\t\t}\n-\t\t\tthis.lock.writeLock().lock();\n+\n+\t\t\tthis.writeLock.lock();\n \t\t\ttry {\n \t\t\t\t// retrying in case of concurrent reads on the same key\n-\t\t\t\tif (this.queue.remove(key)) {\n+\t\t\t\tif ((cached = this.cache.get(key)) != null) {\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\tif (this.queue.size() == this.maxSize) {\n+\n+\t\t\t\tint cacheSize = this.size;\n+\t\t\t\tif (cacheSize == this.maxSize) {",
        "comment_created_at": "2020-03-17T06:36:57+00:00",
        "comment_author": "bananayong",
        "comment_body": "Reordered `V value = this.generator.apply(key);` line, To prevent size inconsistency in case generator throws any exception.",
        "pr_file_module": null
      },
      {
        "comment_id": "394068908",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 24469,
        "pr_file": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "discussion_id": "392868900",
        "commented_code": "@@ -420,54 +421,71 @@ public static String generateMultipartBoundaryString() {\n \n \t\tprivate final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();\n \n-\t\tprivate final ReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\tprivate final Lock readLock;\n+\n+\t\tprivate final Lock writeLock;\n \n \t\tprivate final Function<K, V> generator;\n \n+\t\tprivate volatile int size = 0;\n+\n \t\tpublic ConcurrentLruCache(int maxSize, Function<K, V> generator) {\n \t\t\tAssert.isTrue(maxSize > 0, \"LRU max size should be positive\");\n \t\t\tAssert.notNull(generator, \"Generator function should not be null\");\n \t\t\tthis.maxSize = maxSize;\n \t\t\tthis.generator = generator;\n+\n+\t\t\tReadWriteLock lock = new ReentrantReadWriteLock();\n+\t\t\tthis.readLock = lock.readLock();\n+\t\t\tthis.writeLock = lock.writeLock();\n \t\t}\n \n \t\tpublic V get(K key) {\n-\t\t\tthis.lock.readLock().lock();\n-\t\t\ttry {\n-\t\t\t\tif (this.queue.size() < this.maxSize / 2) {\n-\t\t\t\t\tV cached = this.cache.get(key);\n-\t\t\t\t\tif (cached != null) {\n-\t\t\t\t\t\treturn cached;\n-\t\t\t\t\t}\n+\t\t\tV cached;\n+\n+\t\t\tif ((cached = this.cache.get(key)) != null) {\n+\t\t\t\tif (this.size < this.maxSize / 2) {\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\telse if (this.queue.remove(key)) {\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tthis.readLock.lock();\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tthis.readLock.unlock();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tthis.lock.readLock().unlock();\n-\t\t\t}\n-\t\t\tthis.lock.writeLock().lock();\n+\n+\t\t\tthis.writeLock.lock();\n \t\t\ttry {\n \t\t\t\t// retrying in case of concurrent reads on the same key\n-\t\t\t\tif (this.queue.remove(key)) {\n+\t\t\t\tif ((cached = this.cache.get(key)) != null) {\n \t\t\t\t\tthis.queue.add(key);\n-\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t\tthis.queue.remove(key);\n+\t\t\t\t\treturn cached;\n \t\t\t\t}\n-\t\t\t\tif (this.queue.size() == this.maxSize) {\n+\n+\t\t\t\tint cacheSize = this.size;\n+\t\t\t\tif (cacheSize == this.maxSize) {",
        "comment_created_at": "2020-03-18T02:10:30+00:00",
        "comment_author": "Percy0601",
        "comment_body": "OK, Understand",
        "pr_file_module": null
      }
    ]
  }
]