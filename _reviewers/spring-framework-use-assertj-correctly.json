[
  {
    "discussion_id": "787882233",
    "pr_number": 27945,
    "pr_file": "spring-context/src/test/java/org/springframework/context/groovy/GroovyBeanDefinitionReaderTests.java",
    "created_at": "2022-01-19T15:43:18+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2019 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.context.groovy;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import groovy.lang.GroovyShell;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.aop.SpringProxy;\n+import org.springframework.beans.factory.ObjectFactory;\n+import org.springframework.beans.factory.config.Scope;\n+import org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader;\n+import org.springframework.context.support.GenericApplicationContext;\n+import org.springframework.context.support.GenericGroovyApplicationContext;\n+import org.springframework.core.io.ByteArrayResource;\n+import org.springframework.stereotype.Component;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+public class GroovyBeanDefinitionReaderTests {\n+\n+\t@Test\n+\tvoid importSpringXml() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\t\tbeans {\n+\t\t\t\timportBeans \"classpath:org/springframework/context/groovy/test.xml\"\n+\t\t\t}\n+\t\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tvar foo = appCtx.getBean(\"foo\");\n+\t\tassertThat(foo).isEqualTo(\"hello\");\n+\t}\n+\n+\t@Test\n+\tvoid importBeansFromGroovy() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\t\tbeans {\n+\t\t\t\timportBeans \"classpath:org/springframework/context/groovy/applicationContext.groovy\"\n+\t\t\t}\n+\t\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tvar foo = appCtx.getBean(\"foo\");\n+\t\tassertThat(foo).isEqualTo(\"hello\");\n+\t}\n+\n+\t@Test\n+\tvoid singletonPropertyOnBeanDefinition() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy;\n+\t\tbeans {\n+\t\t\tsingletonBean(Bean1) { bean ->\n+\t\t\t\tbean.singleton = true\n+\t\t\t}\n+\t\t\tnonSingletonBean(Bean1) { bean ->\n+\t\t\t\tbean.singleton = false\n+\t\t\t}\n+\t\t\tunSpecifiedScopeBean(Bean1)\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat(appCtx.isSingleton(\"singletonBean\")).isTrue().as(\"singletonBean should have been a singleton\");\n+\t\tassertThat(appCtx.isSingleton(\"nonSingletonBean\")).isFalse().as(\"nonSingletonBean should not have been a singleton\");\n+\t\tassertThat(appCtx.isSingleton(\"unSpecifiedScopeBean\")).isTrue().as(\"unSpecifiedScopeBean should not have been a singleton\");\n+\t}\n+\n+\t@Test\n+\tvoid inheritPropertiesFromAbstractBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy;\n+\t\tbeans {\n+\t\t\tmyB(Bean1){\n+\t\t\t\tperson = \"wombat\"\n+\t\t\t}\n+\n+\t\t\tmyAbstractA(Bean2){ bean ->\n+\t\t\t\tbean.\"abstract\" = true\n+\t\t\t\tage = 10\n+\t\t\t\tbean1 = myB\n+\t\t\t}\n+\t\t\tmyConcreteB {\n+\t\t\t\tit.parent = myAbstractA\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tBean2 bean = (Bean2) appCtx.getBean(\"myConcreteB\");\n+\t\tassertThat(bean.age).isEqualTo(10);\n+\t\tassertThat(bean.bean1).isNotNull();\n+\t}\n+\n+\t@Test\n+\tvoid contextComponentScanSpringTag() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tbeans {\n+\t\t\txmlns context:\"http://www.springframework.org/schema/context\"\n+\n+\t\t\tcontext.'component-scan'( 'base-package':\"org.springframework.context.groovy\" )\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tvar p = appCtx.getBean(\"person\");\n+\t\tassertThat(p).isInstanceOf(AdvisedPerson.class);\n+\t}\n+\n+\t@Test\n+\tvoid useSpringNamespaceAsMethod() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy;\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\n+\t\t\tfred(AdvisedPerson) {\n+\t\t\t\tname = \"Fred\"\n+\t\t\t\tage = 45\n+\t\t\t}\n+\t\t\tbirthdayCardSenderAspect(BirthdayCardSender)\n+\n+\t\t\taop {\n+\t\t\t\tconfig(\"proxy-target-class\":true) {\n+\t\t\t\t\taspect( id:\"sendBirthdayCard\",ref:\"birthdayCardSenderAspect\" ) {\n+\t\t\t\t\t\tafter method:\"onBirthday\", pointcut: \"execution(void org.springframework.context.groovy.AdvisedPerson.birthday()) and this(person)\"\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tAdvisedPerson fred = (AdvisedPerson) appCtx.getBean(\"fred\");\n+\t\tassertThat(fred).isInstanceOf(SpringProxy.class);\n+\t\tfred.birthday();\n+\n+\t\tBirthdayCardSender birthDaySender = (BirthdayCardSender) appCtx.getBean(\"birthdayCardSenderAspect\");\n+\n+\t\tassertThat(birthDaySender.peopleSentCards).hasSize(1);\n+\t\tassertThat(birthDaySender.peopleSentCards.get(0).getName()).isEqualTo(\"Fred\");\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Test\n+\tvoid useTwoSpringNamespaces() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\tTestScope scope = new TestScope();\n+\t\tappCtx.getBeanFactory().registerScope(\"test\", scope);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\t\t\txmlns util:\"http://www.springframework.org/schema/util\"\n+\t\t\tscopedList(Bean1) { bean ->\n+\t\t\t\tbean.scope = \"test\"\n+\t\t\t\taop.'scoped-proxy'()\n+\t\t\t}\n+\t\t\tutil.list(id: 'foo') {\n+\t\t\t\tvalue 'one'\n+\t\t\t\tvalue 'two'\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat((List<String>)appCtx.getBean(\"foo\")).contains(\"one\", \"two\");\n+\n+\t\tassertThat(appCtx.getBean(\"scopedList\")).isNotNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\n+\t\t// should only be true because bean not initialized until proxy called\n+\t\tassertThat(scope.instanceCount).isEqualTo(2);\n+\n+\t\tappCtx = new GenericApplicationContext();\n+\t\treader = new GroovyBeanDefinitionReader(appCtx);\n+\t\tappCtx.getBeanFactory().registerScope(\"test\", scope);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\timport java.util.ArrayList\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\",\n+\t\t\t\tutil:\"http://www.springframework.org/schema/util\"\n+\t\t\tscopedList(Bean1) { bean ->\n+\t\t\t\tbean.scope = \"test\"\n+\t\t\t\taop.'scoped-proxy'()\n+\t\t\t}\n+\t\t\tutil.list(id: 'foo') {\n+\t\t\t\tvalue 'one'\n+\t\t\t\tvalue 'two'\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat((List<String>)appCtx.getBean(\"foo\")).contains(\"one\", \"two\");\n+\n+\t\tassertThat(appCtx.getBean(\"scopedList\")).isNotNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\n+\t\t// should only be true because bean not initialized until proxy called\n+\t\tassertThat(scope.instanceCount).isEqualTo(4);\n+\t}\n+\n+\t@Test\n+\tvoid springAopSupport() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\n+\t\t\tfred(AdvisedPerson) {\n+\t\t\t\tname = \"Fred\"\n+\t\t\t\tage = 45\n+\t\t\t}\n+\t\t\tbirthdayCardSenderAspect(BirthdayCardSender)\n+\n+\t\t\taop.config(\"proxy-target-class\":true) {\n+\t\t\t\taspect( id:\"sendBirthdayCard\",ref:\"birthdayCardSenderAspect\" ) {\n+\t\t\t\t\tafter method:\"onBirthday\", pointcut: \"execution(void org.springframework.context.groovy.AdvisedPerson.birthday()) and this(person)\"\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tAdvisedPerson fred = (AdvisedPerson) appCtx.getBean(\"fred\");\n+\t\tassertThat(fred).isInstanceOf(SpringProxy.class);\n+\t\tfred.birthday();\n+\n+\t\tBirthdayCardSender birthDaySender = (BirthdayCardSender) appCtx.getBean(\"birthdayCardSenderAspect\");\n+\n+\t\tassertThat(birthDaySender.peopleSentCards).hasSize(1);\n+\t\tassertThat(birthDaySender.peopleSentCards.get(0).getName()).isEqualTo(\"Fred\");\n+\t}\n+\n+\t@Test\n+\tvoid springScopedProxyBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\tTestScope scope = new TestScope();\n+\t\tappCtx.getBeanFactory().registerScope(\"test\", scope);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\t\t\tscopedList(Bean1) { bean ->\n+\t\t\t\tbean.scope = \"test\"\n+\t\t\t\taop.'scoped-proxy'()\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat(appCtx.getBean(\"scopedList\")).isNotNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\n+\t\t// should only be true because bean not initialized until proxy called\n+\t\tassertThat(scope.instanceCount).isEqualTo(2);\n+\t}\n+\n+\t@Test\n+\tvoid springNamespaceBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns util: 'http://www.springframework.org/schema/util'\n+\t\t\tutil.list(id: 'foo') {\n+\t\t\t\tvalue 'one'\n+\t\t\t\tvalue 'two'\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat((List<String>)appCtx.getBean(\"foo\")).contains(\"one\", \"two\");\n+\t}\n+\n+\t@Test\n+\tvoid namedArgumentConstructor() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tholyGrail(HolyGrailQuest)\n+\t\t\tknights(KnightOfTheRoundTable, \"Camelot\", leader:\"lancelot\", quest: holyGrail)\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tKnightOfTheRoundTable knights = (KnightOfTheRoundTable) appCtx.getBean(\"knights\");\n+\t\tHolyGrailQuest quest = (HolyGrailQuest) appCtx.getBean(\"holyGrail\");\n+\n+\t\tassertThat(knights.getName()).isEqualTo(\"Camelot\");\n+\t\tassertThat(knights.leader).isEqualTo(\"lancelot\");\n+\t\tassertThat(knights.quest).isEqualTo(quest);\n+\t}\n+\n+\t@Test\n+\tvoid abstractBeanDefinition() {\n+\t\tvar appCtx = new GenericGroovyApplicationContext();\n+\t\tappCtx.getReader().loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tabstractBean {\n+\t\t\t\tleader = \"Lancelot\"\n+\t\t\t}\n+\t\t\tquest(HolyGrailQuest)\n+\t\t\tknights(KnightOfTheRoundTable, \"Camelot\") { bean ->\n+\t\t\t\tbean.parent = abstractBean\n+\t\t\t\tquest = quest\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tKnightOfTheRoundTable knights = (KnightOfTheRoundTable) appCtx.getProperty(\"knights\");\n+\t\tassertThat(knights).isNotNull();\n+\t\tassertThatExceptionOfType(org.springframework.beans.factory.BeanIsAbstractException.class).isThrownBy(() ->\n+\t\t\tappCtx.getProperty(\"abstractBean\"));\n+\t\tassertThat(knights.leader).isEqualTo(\"Lancelot\");\n+\t}\n+\n+\t@Test\n+\tvoid abstractBeanDefinitionWithClass() {\n+\t\tvar appCtx = new GenericGroovyApplicationContext();\n+\t\tappCtx.getReader().loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tabstractBean(KnightOfTheRoundTable) { bean ->\n+\t\t\t\tbean.'abstract' = true\n+\t\t\t\tleader = \"Lancelot\"\n+\t\t\t}\n+\t\t\tquest(HolyGrailQuest)\n+\t\t\tknights(\"Camelot\") { bean ->\n+\t\t\t\tbean.parent = abstractBean\n+\t\t\t\tquest = quest\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThatExceptionOfType(org.springframework.beans.factory.BeanIsAbstractException.class).isThrownBy(() ->\n+\t\t\tappCtx.getProperty(\"abstractBean\"));\n+\n+\t\tKnightOfTheRoundTable knights = (KnightOfTheRoundTable) appCtx.getProperty(\"knights\");\n+\t\tassertThat(knights).isNotNull();\n+\t\tassertThat(knights.leader).isEqualTo(\"Lancelot\");\n+\t}\n+\n+\t@Test\n+\tvoid scopes() {\n+\t\tvar appCtx = new GenericGroovyApplicationContext();\n+\t\tappCtx.getReader().loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tmyBean(ScopeTestBean) { bean ->\n+\t\t\t\tbean.scope = \"prototype\"\n+\t\t\t}\n+\t\t\tmyBean2(ScopeTestBean)\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tvar b1 = appCtx.getProperty(\"myBean\");\n+\t\tvar b2 = appCtx.getProperty(\"myBean\");\n+\n+\t\tassert b1 != b2;\n+\n+\t\tb1 = appCtx.getProperty(\"myBean2\");\n+\t\tb2 = appCtx.getProperty(\"myBean2\");\n+\n+\t\tassertThat(b1).isEqualTo(b2);\n+\t}\n+\n+\t@Test\n+\tvoid simpleBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tbean1(Bean1) {\n+\t\t\t\tperson = \"homer\"\n+\t\t\t\tage = 45\n+\t\t\t\tprops = [overweight:\"true\", height:\"1.8m\"]\n+\t\t\t\tchildren = [\"bart\", \"lisa\"]\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassert appCtx.containsBean(\"bean1\");\n+\t\tBean1 bean1 = (Bean1) appCtx.getBean(\"bean1\");\n+\n+\t\tassertThat(bean1.person).isEqualTo(\"homer\");\n+\t\tassertThat(bean1.age).isEqualTo(45);\n+\t\tassertThat(bean1.props.getProperty(\"overweight\")).isEqualTo(\"true\");\n+\t\tassertThat(bean1.props.getProperty(\"height\")).isEqualTo(\"1.8m\");\n+\t\tassertThat(bean1.children).contains(\"bart\", \"lisa\");\n+\n+\t}\n+\n+\t@Test\n+\tvoid beanWithParentRef() {\n+\t\tvar parentAppCtx = new GenericApplicationContext();\n+\t\tvar parentBeanReader = new GroovyBeanDefinitionReader(parentAppCtx);\n+\t\tparentBeanReader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\thomer(Bean1) {\n+\t\t\t\tperson = \"homer\"\n+\t\t\t\tage = 45\n+\t\t\t\tprops = [overweight:true, height:\"1.8m\"]\n+\t\t\t\tchildren = [\"bart\", \"lisa\"]\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tparentAppCtx.refresh();\n+\n+\t\tvar appCtx = new GenericApplicationContext(parentAppCtx);\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tbart(Bean2) {\n+\t\t\t\tperson = \"bart\"\n+\t\t\t\tparent = ref(\"homer\", true)\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassert appCtx.containsBean(\"bart\");",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "787882233",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 27945,
        "pr_file": "spring-context/src/test/java/org/springframework/context/groovy/GroovyBeanDefinitionReaderTests.java",
        "discussion_id": "787882233",
        "commented_code": "@@ -0,0 +1,1299 @@\n+/*\n+ * Copyright 2002-2019 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.context.groovy;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import groovy.lang.GroovyShell;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.aop.SpringProxy;\n+import org.springframework.beans.factory.ObjectFactory;\n+import org.springframework.beans.factory.config.Scope;\n+import org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader;\n+import org.springframework.context.support.GenericApplicationContext;\n+import org.springframework.context.support.GenericGroovyApplicationContext;\n+import org.springframework.core.io.ByteArrayResource;\n+import org.springframework.stereotype.Component;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+public class GroovyBeanDefinitionReaderTests {\n+\n+\t@Test\n+\tvoid importSpringXml() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\t\tbeans {\n+\t\t\t\timportBeans \"classpath:org/springframework/context/groovy/test.xml\"\n+\t\t\t}\n+\t\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tvar foo = appCtx.getBean(\"foo\");\n+\t\tassertThat(foo).isEqualTo(\"hello\");\n+\t}\n+\n+\t@Test\n+\tvoid importBeansFromGroovy() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\t\tbeans {\n+\t\t\t\timportBeans \"classpath:org/springframework/context/groovy/applicationContext.groovy\"\n+\t\t\t}\n+\t\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tvar foo = appCtx.getBean(\"foo\");\n+\t\tassertThat(foo).isEqualTo(\"hello\");\n+\t}\n+\n+\t@Test\n+\tvoid singletonPropertyOnBeanDefinition() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy;\n+\t\tbeans {\n+\t\t\tsingletonBean(Bean1) { bean ->\n+\t\t\t\tbean.singleton = true\n+\t\t\t}\n+\t\t\tnonSingletonBean(Bean1) { bean ->\n+\t\t\t\tbean.singleton = false\n+\t\t\t}\n+\t\t\tunSpecifiedScopeBean(Bean1)\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat(appCtx.isSingleton(\"singletonBean\")).isTrue().as(\"singletonBean should have been a singleton\");\n+\t\tassertThat(appCtx.isSingleton(\"nonSingletonBean\")).isFalse().as(\"nonSingletonBean should not have been a singleton\");\n+\t\tassertThat(appCtx.isSingleton(\"unSpecifiedScopeBean\")).isTrue().as(\"unSpecifiedScopeBean should not have been a singleton\");\n+\t}\n+\n+\t@Test\n+\tvoid inheritPropertiesFromAbstractBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy;\n+\t\tbeans {\n+\t\t\tmyB(Bean1){\n+\t\t\t\tperson = \"wombat\"\n+\t\t\t}\n+\n+\t\t\tmyAbstractA(Bean2){ bean ->\n+\t\t\t\tbean.\"abstract\" = true\n+\t\t\t\tage = 10\n+\t\t\t\tbean1 = myB\n+\t\t\t}\n+\t\t\tmyConcreteB {\n+\t\t\t\tit.parent = myAbstractA\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tBean2 bean = (Bean2) appCtx.getBean(\"myConcreteB\");\n+\t\tassertThat(bean.age).isEqualTo(10);\n+\t\tassertThat(bean.bean1).isNotNull();\n+\t}\n+\n+\t@Test\n+\tvoid contextComponentScanSpringTag() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tbeans {\n+\t\t\txmlns context:\"http://www.springframework.org/schema/context\"\n+\n+\t\t\tcontext.'component-scan'( 'base-package':\"org.springframework.context.groovy\" )\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tvar p = appCtx.getBean(\"person\");\n+\t\tassertThat(p).isInstanceOf(AdvisedPerson.class);\n+\t}\n+\n+\t@Test\n+\tvoid useSpringNamespaceAsMethod() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy;\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\n+\t\t\tfred(AdvisedPerson) {\n+\t\t\t\tname = \"Fred\"\n+\t\t\t\tage = 45\n+\t\t\t}\n+\t\t\tbirthdayCardSenderAspect(BirthdayCardSender)\n+\n+\t\t\taop {\n+\t\t\t\tconfig(\"proxy-target-class\":true) {\n+\t\t\t\t\taspect( id:\"sendBirthdayCard\",ref:\"birthdayCardSenderAspect\" ) {\n+\t\t\t\t\t\tafter method:\"onBirthday\", pointcut: \"execution(void org.springframework.context.groovy.AdvisedPerson.birthday()) and this(person)\"\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tAdvisedPerson fred = (AdvisedPerson) appCtx.getBean(\"fred\");\n+\t\tassertThat(fred).isInstanceOf(SpringProxy.class);\n+\t\tfred.birthday();\n+\n+\t\tBirthdayCardSender birthDaySender = (BirthdayCardSender) appCtx.getBean(\"birthdayCardSenderAspect\");\n+\n+\t\tassertThat(birthDaySender.peopleSentCards).hasSize(1);\n+\t\tassertThat(birthDaySender.peopleSentCards.get(0).getName()).isEqualTo(\"Fred\");\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Test\n+\tvoid useTwoSpringNamespaces() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\tTestScope scope = new TestScope();\n+\t\tappCtx.getBeanFactory().registerScope(\"test\", scope);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\t\t\txmlns util:\"http://www.springframework.org/schema/util\"\n+\t\t\tscopedList(Bean1) { bean ->\n+\t\t\t\tbean.scope = \"test\"\n+\t\t\t\taop.'scoped-proxy'()\n+\t\t\t}\n+\t\t\tutil.list(id: 'foo') {\n+\t\t\t\tvalue 'one'\n+\t\t\t\tvalue 'two'\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat((List<String>)appCtx.getBean(\"foo\")).contains(\"one\", \"two\");\n+\n+\t\tassertThat(appCtx.getBean(\"scopedList\")).isNotNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\n+\t\t// should only be true because bean not initialized until proxy called\n+\t\tassertThat(scope.instanceCount).isEqualTo(2);\n+\n+\t\tappCtx = new GenericApplicationContext();\n+\t\treader = new GroovyBeanDefinitionReader(appCtx);\n+\t\tappCtx.getBeanFactory().registerScope(\"test\", scope);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\timport java.util.ArrayList\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\",\n+\t\t\t\tutil:\"http://www.springframework.org/schema/util\"\n+\t\t\tscopedList(Bean1) { bean ->\n+\t\t\t\tbean.scope = \"test\"\n+\t\t\t\taop.'scoped-proxy'()\n+\t\t\t}\n+\t\t\tutil.list(id: 'foo') {\n+\t\t\t\tvalue 'one'\n+\t\t\t\tvalue 'two'\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat((List<String>)appCtx.getBean(\"foo\")).contains(\"one\", \"two\");\n+\n+\t\tassertThat(appCtx.getBean(\"scopedList\")).isNotNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\n+\t\t// should only be true because bean not initialized until proxy called\n+\t\tassertThat(scope.instanceCount).isEqualTo(4);\n+\t}\n+\n+\t@Test\n+\tvoid springAopSupport() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\n+\t\t\tfred(AdvisedPerson) {\n+\t\t\t\tname = \"Fred\"\n+\t\t\t\tage = 45\n+\t\t\t}\n+\t\t\tbirthdayCardSenderAspect(BirthdayCardSender)\n+\n+\t\t\taop.config(\"proxy-target-class\":true) {\n+\t\t\t\taspect( id:\"sendBirthdayCard\",ref:\"birthdayCardSenderAspect\" ) {\n+\t\t\t\t\tafter method:\"onBirthday\", pointcut: \"execution(void org.springframework.context.groovy.AdvisedPerson.birthday()) and this(person)\"\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\n+\t\tappCtx.refresh();\n+\n+\t\tAdvisedPerson fred = (AdvisedPerson) appCtx.getBean(\"fred\");\n+\t\tassertThat(fred).isInstanceOf(SpringProxy.class);\n+\t\tfred.birthday();\n+\n+\t\tBirthdayCardSender birthDaySender = (BirthdayCardSender) appCtx.getBean(\"birthdayCardSenderAspect\");\n+\n+\t\tassertThat(birthDaySender.peopleSentCards).hasSize(1);\n+\t\tassertThat(birthDaySender.peopleSentCards.get(0).getName()).isEqualTo(\"Fred\");\n+\t}\n+\n+\t@Test\n+\tvoid springScopedProxyBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\n+\t\tTestScope scope = new TestScope();\n+\t\tappCtx.getBeanFactory().registerScope(\"test\", scope);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns aop:\"http://www.springframework.org/schema/aop\"\n+\t\t\tscopedList(Bean1) { bean ->\n+\t\t\t\tbean.scope = \"test\"\n+\t\t\t\taop.'scoped-proxy'()\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat(appCtx.getBean(\"scopedList\")).isNotNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\t\tassertThat(((Bean1)appCtx.getBean(\"scopedList\")).getPerson()).isNull();\n+\n+\t\t// should only be true because bean not initialized until proxy called\n+\t\tassertThat(scope.instanceCount).isEqualTo(2);\n+\t}\n+\n+\t@Test\n+\tvoid springNamespaceBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\txmlns util: 'http://www.springframework.org/schema/util'\n+\t\t\tutil.list(id: 'foo') {\n+\t\t\t\tvalue 'one'\n+\t\t\t\tvalue 'two'\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThat((List<String>)appCtx.getBean(\"foo\")).contains(\"one\", \"two\");\n+\t}\n+\n+\t@Test\n+\tvoid namedArgumentConstructor() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tholyGrail(HolyGrailQuest)\n+\t\t\tknights(KnightOfTheRoundTable, \"Camelot\", leader:\"lancelot\", quest: holyGrail)\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tKnightOfTheRoundTable knights = (KnightOfTheRoundTable) appCtx.getBean(\"knights\");\n+\t\tHolyGrailQuest quest = (HolyGrailQuest) appCtx.getBean(\"holyGrail\");\n+\n+\t\tassertThat(knights.getName()).isEqualTo(\"Camelot\");\n+\t\tassertThat(knights.leader).isEqualTo(\"lancelot\");\n+\t\tassertThat(knights.quest).isEqualTo(quest);\n+\t}\n+\n+\t@Test\n+\tvoid abstractBeanDefinition() {\n+\t\tvar appCtx = new GenericGroovyApplicationContext();\n+\t\tappCtx.getReader().loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tabstractBean {\n+\t\t\t\tleader = \"Lancelot\"\n+\t\t\t}\n+\t\t\tquest(HolyGrailQuest)\n+\t\t\tknights(KnightOfTheRoundTable, \"Camelot\") { bean ->\n+\t\t\t\tbean.parent = abstractBean\n+\t\t\t\tquest = quest\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tKnightOfTheRoundTable knights = (KnightOfTheRoundTable) appCtx.getProperty(\"knights\");\n+\t\tassertThat(knights).isNotNull();\n+\t\tassertThatExceptionOfType(org.springframework.beans.factory.BeanIsAbstractException.class).isThrownBy(() ->\n+\t\t\tappCtx.getProperty(\"abstractBean\"));\n+\t\tassertThat(knights.leader).isEqualTo(\"Lancelot\");\n+\t}\n+\n+\t@Test\n+\tvoid abstractBeanDefinitionWithClass() {\n+\t\tvar appCtx = new GenericGroovyApplicationContext();\n+\t\tappCtx.getReader().loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tabstractBean(KnightOfTheRoundTable) { bean ->\n+\t\t\t\tbean.'abstract' = true\n+\t\t\t\tleader = \"Lancelot\"\n+\t\t\t}\n+\t\t\tquest(HolyGrailQuest)\n+\t\t\tknights(\"Camelot\") { bean ->\n+\t\t\t\tbean.parent = abstractBean\n+\t\t\t\tquest = quest\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassertThatExceptionOfType(org.springframework.beans.factory.BeanIsAbstractException.class).isThrownBy(() ->\n+\t\t\tappCtx.getProperty(\"abstractBean\"));\n+\n+\t\tKnightOfTheRoundTable knights = (KnightOfTheRoundTable) appCtx.getProperty(\"knights\");\n+\t\tassertThat(knights).isNotNull();\n+\t\tassertThat(knights.leader).isEqualTo(\"Lancelot\");\n+\t}\n+\n+\t@Test\n+\tvoid scopes() {\n+\t\tvar appCtx = new GenericGroovyApplicationContext();\n+\t\tappCtx.getReader().loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tmyBean(ScopeTestBean) { bean ->\n+\t\t\t\tbean.scope = \"prototype\"\n+\t\t\t}\n+\t\t\tmyBean2(ScopeTestBean)\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tvar b1 = appCtx.getProperty(\"myBean\");\n+\t\tvar b2 = appCtx.getProperty(\"myBean\");\n+\n+\t\tassert b1 != b2;\n+\n+\t\tb1 = appCtx.getProperty(\"myBean2\");\n+\t\tb2 = appCtx.getProperty(\"myBean2\");\n+\n+\t\tassertThat(b1).isEqualTo(b2);\n+\t}\n+\n+\t@Test\n+\tvoid simpleBean() {\n+\t\tvar appCtx = new GenericApplicationContext();\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tbean1(Bean1) {\n+\t\t\t\tperson = \"homer\"\n+\t\t\t\tage = 45\n+\t\t\t\tprops = [overweight:\"true\", height:\"1.8m\"]\n+\t\t\t\tchildren = [\"bart\", \"lisa\"]\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassert appCtx.containsBean(\"bean1\");\n+\t\tBean1 bean1 = (Bean1) appCtx.getBean(\"bean1\");\n+\n+\t\tassertThat(bean1.person).isEqualTo(\"homer\");\n+\t\tassertThat(bean1.age).isEqualTo(45);\n+\t\tassertThat(bean1.props.getProperty(\"overweight\")).isEqualTo(\"true\");\n+\t\tassertThat(bean1.props.getProperty(\"height\")).isEqualTo(\"1.8m\");\n+\t\tassertThat(bean1.children).contains(\"bart\", \"lisa\");\n+\n+\t}\n+\n+\t@Test\n+\tvoid beanWithParentRef() {\n+\t\tvar parentAppCtx = new GenericApplicationContext();\n+\t\tvar parentBeanReader = new GroovyBeanDefinitionReader(parentAppCtx);\n+\t\tparentBeanReader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\thomer(Bean1) {\n+\t\t\t\tperson = \"homer\"\n+\t\t\t\tage = 45\n+\t\t\t\tprops = [overweight:true, height:\"1.8m\"]\n+\t\t\t\tchildren = [\"bart\", \"lisa\"]\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tparentAppCtx.refresh();\n+\n+\t\tvar appCtx = new GenericApplicationContext(parentAppCtx);\n+\t\tvar reader = new GroovyBeanDefinitionReader(appCtx);\n+\t\treader.loadBeanDefinitions(new ByteArrayResource((\"\"\"\n+\t\tpackage org.springframework.context.groovy\n+\t\tbeans {\n+\t\t\tbart(Bean2) {\n+\t\t\t\tperson = \"bart\"\n+\t\t\t\tparent = ref(\"homer\", true)\n+\t\t\t}\n+\t\t}\n+\t\t\"\"\").getBytes()));\n+\t\tappCtx.refresh();\n+\n+\t\tassert appCtx.containsBean(\"bart\");",
        "comment_created_at": "2022-01-19T15:43:18+00:00",
        "comment_author": "sbrannen",
        "comment_body": "Please replace all `assert` statements with AssertJ assertions.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1359291909",
    "pr_number": 31389,
    "pr_file": "spring-aop/src/test/java/org/springframework/aop/framework/ProxyFactoryWithIntroductionInterceptorTests.java",
    "created_at": "2023-10-14T09:58:19+00:00",
    "commented_code": "+package java.org.springframework.aop.framework;\n+\n+import org.junit.jupiter.api.Assertions;",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1359291909",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 31389,
        "pr_file": "spring-aop/src/test/java/org/springframework/aop/framework/ProxyFactoryWithIntroductionInterceptorTests.java",
        "discussion_id": "1359291909",
        "commented_code": "@@ -0,0 +1,175 @@\n+package java.org.springframework.aop.framework;\n+\n+import org.junit.jupiter.api.Assertions;",
        "comment_created_at": "2023-10-14T09:58:19+00:00",
        "comment_author": "sbrannen",
        "comment_body": "Please use AssertJ for assertions.\r\n\r\nThe build will fail if you attempt to use JUnit Jupiter's `Assertions` class.\r\n\r\nSpeaking of which, please run a full build locally before submitting a PR (`./gradlew check`) to ensure that the build succeeds.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1539427409",
    "pr_number": 26478,
    "pr_file": "spring-expression/src/test/java/org/springframework/expression/spel/PropertyAccessTests.java",
    "created_at": "2024-03-26T14:57:59+00:00",
    "commented_code": "assertThat(ctx.getPropertyAccessors()).hasSize(2);\n \t}\n \n+\t@Test\n+\tpublic void testAddingRemovingIndexAccessors() {\n+\t\tStandardEvaluationContext ctx = new StandardEvaluationContext();\n+\t\tList<IndexAccessor> indexAccessors = ctx.getIndexAccessors();\n+\t\tassertThat(indexAccessors.size()).isEqualTo(0);\n+\t\tJsonIndexAccessor jsonIndexAccessor=new JsonIndexAccessor();\n+\t\tctx.addIndexAccessor(jsonIndexAccessor);\n+\t\tassertThat(indexAccessors.size()).isEqualTo(1);",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1539427409",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 26478,
        "pr_file": "spring-expression/src/test/java/org/springframework/expression/spel/PropertyAccessTests.java",
        "discussion_id": "1539427409",
        "commented_code": "@@ -144,6 +150,25 @@ void addingAndRemovingAccessors() {\n \t\tassertThat(ctx.getPropertyAccessors()).hasSize(2);\n \t}\n \n+\t@Test\n+\tpublic void testAddingRemovingIndexAccessors() {\n+\t\tStandardEvaluationContext ctx = new StandardEvaluationContext();\n+\t\tList<IndexAccessor> indexAccessors = ctx.getIndexAccessors();\n+\t\tassertThat(indexAccessors.size()).isEqualTo(0);\n+\t\tJsonIndexAccessor jsonIndexAccessor=new JsonIndexAccessor();\n+\t\tctx.addIndexAccessor(jsonIndexAccessor);\n+\t\tassertThat(indexAccessors.size()).isEqualTo(1);",
        "comment_created_at": "2024-03-26T14:57:59+00:00",
        "comment_author": "sbrannen",
        "comment_body": "When we check the size of a collection using AssertJ, we prefer to use `assertThat(list).hasSize(...)`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1342154360",
    "pr_number": 27285,
    "pr_file": "spring-test/src/test/java/org/springframework/test/context/jdbc/AfterTestClassSqlScriptsTests.java",
    "created_at": "2023-10-01T15:55:41+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.test.context.jdbc;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.core.Ordered;\n+import org.springframework.jdbc.BadSqlGrammarException;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.test.annotation.Commit;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestContext;\n+import org.springframework.test.context.TestExecutionListener;\n+import org.springframework.test.context.TestExecutionListeners;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+import org.springframework.test.context.transaction.TestContextTransactionUtils;\n+\n+/**\n+ * Verifies that {@link Sql @Sql} with {@link Sql.ExecutionPhase#AFTER_TEST_CLASS} is run after all tests in the class\n+ * have been run.\n+ *\n+ * @author Andreas Ahlenstorf\n+ * @since 6.1\n+ */\n+@SpringJUnitConfig(PopulatedSchemaDatabaseConfig.class)\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\n+@Sql(value = {\"drop-schema.sql\"}, executionPhase = Sql.ExecutionPhase.AFTER_TEST_CLASS)\n+@TestExecutionListeners(\n+\t\tvalue = AfterTestClassSqlScriptsTests.VerifyTestExecutionListener.class,\n+\t\tmergeMode = TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS\n+)\n+class AfterTestClassSqlScriptsTests extends AbstractTransactionalTests {\n+\n+\t@Test\n+\t@Order(1)\n+\t@Sql(scripts = \"data-add-catbert.sql\")\n+\t@Commit\n+\tvoid databaseHasBeenInitialized() {\n+\t\tassertUsers(\"Catbert\");\n+\t}\n+\n+\t@Test\n+\t@Order(2)\n+\t@Sql(scripts = \"data-add-dogbert.sql\")\n+\t@Commit\n+\tvoid databaseIsNotWipedBetweenTests() {\n+\t\tassertUsers(\"Catbert\", \"Dogbert\");\n+\t}\n+\n+\tstatic class VerifyTestExecutionListener implements TestExecutionListener, Ordered {\n+\n+\t\t@Override\n+\t\tpublic void afterTestClass(TestContext testContext) throws Exception {\n+\t\t\tDataSource dataSource = TestContextTransactionUtils.retrieveDataSource(testContext, null);\n+\t\t\ttry {\n+\t\t\t\tnew JdbcTemplate(dataSource).queryForList(\"SELECT name FROM user\", String.class);\n+\t\t\t\tthrow new AssertionError(\"BadSqlGrammarException should have been thrown.\");\n+\t\t\t}\n+\t\t\tcatch (BadSqlGrammarException expected) {\n+\t\t\t}",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1342154360",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 27285,
        "pr_file": "spring-test/src/test/java/org/springframework/test/context/jdbc/AfterTestClassSqlScriptsTests.java",
        "discussion_id": "1342154360",
        "commented_code": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2002-2023 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.test.context.jdbc;\n+\n+import javax.sql.DataSource;\n+\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+\n+import org.springframework.core.Ordered;\n+import org.springframework.jdbc.BadSqlGrammarException;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.test.annotation.Commit;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.TestContext;\n+import org.springframework.test.context.TestExecutionListener;\n+import org.springframework.test.context.TestExecutionListeners;\n+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n+import org.springframework.test.context.transaction.TestContextTransactionUtils;\n+\n+/**\n+ * Verifies that {@link Sql @Sql} with {@link Sql.ExecutionPhase#AFTER_TEST_CLASS} is run after all tests in the class\n+ * have been run.\n+ *\n+ * @author Andreas Ahlenstorf\n+ * @since 6.1\n+ */\n+@SpringJUnitConfig(PopulatedSchemaDatabaseConfig.class)\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\n+@Sql(value = {\"drop-schema.sql\"}, executionPhase = Sql.ExecutionPhase.AFTER_TEST_CLASS)\n+@TestExecutionListeners(\n+\t\tvalue = AfterTestClassSqlScriptsTests.VerifyTestExecutionListener.class,\n+\t\tmergeMode = TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS\n+)\n+class AfterTestClassSqlScriptsTests extends AbstractTransactionalTests {\n+\n+\t@Test\n+\t@Order(1)\n+\t@Sql(scripts = \"data-add-catbert.sql\")\n+\t@Commit\n+\tvoid databaseHasBeenInitialized() {\n+\t\tassertUsers(\"Catbert\");\n+\t}\n+\n+\t@Test\n+\t@Order(2)\n+\t@Sql(scripts = \"data-add-dogbert.sql\")\n+\t@Commit\n+\tvoid databaseIsNotWipedBetweenTests() {\n+\t\tassertUsers(\"Catbert\", \"Dogbert\");\n+\t}\n+\n+\tstatic class VerifyTestExecutionListener implements TestExecutionListener, Ordered {\n+\n+\t\t@Override\n+\t\tpublic void afterTestClass(TestContext testContext) throws Exception {\n+\t\t\tDataSource dataSource = TestContextTransactionUtils.retrieveDataSource(testContext, null);\n+\t\t\ttry {\n+\t\t\t\tnew JdbcTemplate(dataSource).queryForList(\"SELECT name FROM user\", String.class);\n+\t\t\t\tthrow new AssertionError(\"BadSqlGrammarException should have been thrown.\");\n+\t\t\t}\n+\t\t\tcatch (BadSqlGrammarException expected) {\n+\t\t\t}",
        "comment_created_at": "2023-10-01T15:55:41+00:00",
        "comment_author": "sbrannen",
        "comment_body": "Please replace with an AssertJ assertion along the lines of `assertThatExceptionOfType(BadSqlGrammarException.class).isThrownBy(...)`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "432517673",
    "pr_number": 25160,
    "pr_file": "spring-core/src/test/java/org/springframework/util/MultiValueMapRelatedTests.java",
    "created_at": "2020-05-29T14:22:08+00:00",
    "commented_code": "+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.util;\n+\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * @author Mihai Dumitrescu\n+ * @author Arjen Poutsma\n+ * @author Juergen Hoeller\n+ */\n+class MultiValueMapRelatedTests {\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid add(MultiValueMap<String, String> objectUnderTest) {\n+\t\tint startingSize = objectUnderTest.size();\n+\t\tobjectUnderTest.add(\"key\", \"value1\");\n+\t\tobjectUnderTest.add(\"key\", \"value2\");\n+\t\tassertThat(objectUnderTest).hasSize(startingSize + 1);\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\", \"value2\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid addIfAbsentWhenAbsent(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.addIfAbsent(\"key\", \"value1\");\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid addIfAbsentWhenPresent(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.add(\"key\", \"value1\");\n+\t\tobjectUnderTest.addIfAbsent(\"key\", \"value2\");\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid set(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.set(\"key\", \"value1\");\n+\t\tobjectUnderTest.set(\"key\", \"value2\");\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value2\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid addAll(MultiValueMap<String, String> objectUnderTest) {\n+\t\tint  startingSize = objectUnderTest.size();\n+\n+\t\tobjectUnderTest.add(\"key\", \"value1\");\n+\t\tobjectUnderTest.addAll(\"key\", Arrays.asList(\"value2\", \"value3\"));\n+\t\tassertThat(objectUnderTest).hasSize(startingSize + 1);\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\", \"value2\", \"value3\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\t@Disabled(\"to be fixed in gh-25140\")\n+\tvoid addAllWithEmptyList(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.addAll(\"key\", Collections.emptyList());\n+\t\tassertThat(objectUnderTest).hasSize(1);\n+\t\tassertThat(objectUnderTest.get(\"key\")).isEmpty();\n+\t\tassertThat(objectUnderTest.getFirst(\"key\")).isNull();\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid getFirst(MultiValueMap<String, String> objectUnderTest) {\n+\t\tList<String> values = new ArrayList<>(2);\n+\t\tvalues.add(\"value1\");\n+\t\tvalues.add(\"value2\");\n+\t\tobjectUnderTest.put(\"key\", values);\n+\t\tassertThat(objectUnderTest.getFirst(\"key\")).isEqualTo(\"value1\");\n+\t\tassertThat(objectUnderTest.getFirst(\"other\")).isNull();\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid toSingleValueMap(MultiValueMap<String, String> objectUnderTest) {\n+\n+\t\tint startingSize = objectUnderTest.size();\n+\n+\t\tList<String> values = new ArrayList<>(2);\n+\t\tvalues.add(\"value1\");\n+\t\tvalues.add(\"value2\");\n+\t\tobjectUnderTest.put(\"key\", values);\n+\t\tMap<String, String> singleValueMap = objectUnderTest.toSingleValueMap();\n+\t\tassertThat(singleValueMap).hasSize(startingSize + 1);\n+\t\tassertThat(singleValueMap.get(\"key\")).isEqualTo(\"value1\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\t@Disabled(\"to be fixed in gh-25140\")\n+\tvoid toSingleValueMapWithEmptyList(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.put(\"key\", Collections.emptyList());\n+\t\tMap<String, String> singleValueMap = objectUnderTest.toSingleValueMap();\n+\t\tassertThat(singleValueMap).isEmpty();\n+\t\tassertThat(singleValueMap.get(\"key\")).isNull();\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid equalsOnExistingValues(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.clear();\n+\t\tobjectUnderTest.set(\"key1\", \"value1\");\n+\t\tassertThat(objectUnderTest).isEqualTo(objectUnderTest);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid equalsOnEmpty(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.clear();\n+\t\tobjectUnderTest.set(\"key1\", \"value1\");\n+\t\tMultiValueMap<String, String> o1 = new LinkedMultiValueMap<>();\n+\t\to1.set(\"key1\", \"value1\");\n+\t\tassertThat(o1).isEqualTo(objectUnderTest);\n+\t\tassertThat(objectUnderTest).isEqualTo(o1);\n+\t\tMap<String, List<String>> o2 = new HashMap<>();\n+\t\to2.put(\"key1\", Collections.singletonList(\"value1\"));\n+\t\tassertThat(o2).isEqualTo(objectUnderTest);\n+\t\tassertThat(objectUnderTest).isEqualTo(o2);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid canNotChangeAnUnmodifiableMultiValueMap(MultiValueMap<String, String> objectUnderTest) {\n+\t\tMultiValueMap<String, String> asUnmodifiableMultiValueMap = CollectionUtils.unmodifiableMultiValueMap(objectUnderTest);\n+\t\tAssertions.assertAll(",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "432517673",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25160,
        "pr_file": "spring-core/src/test/java/org/springframework/util/MultiValueMapRelatedTests.java",
        "discussion_id": "432517673",
        "commented_code": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2002-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.util;\n+\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * @author Mihai Dumitrescu\n+ * @author Arjen Poutsma\n+ * @author Juergen Hoeller\n+ */\n+class MultiValueMapRelatedTests {\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid add(MultiValueMap<String, String> objectUnderTest) {\n+\t\tint startingSize = objectUnderTest.size();\n+\t\tobjectUnderTest.add(\"key\", \"value1\");\n+\t\tobjectUnderTest.add(\"key\", \"value2\");\n+\t\tassertThat(objectUnderTest).hasSize(startingSize + 1);\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\", \"value2\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid addIfAbsentWhenAbsent(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.addIfAbsent(\"key\", \"value1\");\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid addIfAbsentWhenPresent(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.add(\"key\", \"value1\");\n+\t\tobjectUnderTest.addIfAbsent(\"key\", \"value2\");\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid set(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.set(\"key\", \"value1\");\n+\t\tobjectUnderTest.set(\"key\", \"value2\");\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value2\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid addAll(MultiValueMap<String, String> objectUnderTest) {\n+\t\tint  startingSize = objectUnderTest.size();\n+\n+\t\tobjectUnderTest.add(\"key\", \"value1\");\n+\t\tobjectUnderTest.addAll(\"key\", Arrays.asList(\"value2\", \"value3\"));\n+\t\tassertThat(objectUnderTest).hasSize(startingSize + 1);\n+\t\tassertThat(objectUnderTest.get(\"key\")).containsExactly(\"value1\", \"value2\", \"value3\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\t@Disabled(\"to be fixed in gh-25140\")\n+\tvoid addAllWithEmptyList(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.addAll(\"key\", Collections.emptyList());\n+\t\tassertThat(objectUnderTest).hasSize(1);\n+\t\tassertThat(objectUnderTest.get(\"key\")).isEmpty();\n+\t\tassertThat(objectUnderTest.getFirst(\"key\")).isNull();\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid getFirst(MultiValueMap<String, String> objectUnderTest) {\n+\t\tList<String> values = new ArrayList<>(2);\n+\t\tvalues.add(\"value1\");\n+\t\tvalues.add(\"value2\");\n+\t\tobjectUnderTest.put(\"key\", values);\n+\t\tassertThat(objectUnderTest.getFirst(\"key\")).isEqualTo(\"value1\");\n+\t\tassertThat(objectUnderTest.getFirst(\"other\")).isNull();\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid toSingleValueMap(MultiValueMap<String, String> objectUnderTest) {\n+\n+\t\tint startingSize = objectUnderTest.size();\n+\n+\t\tList<String> values = new ArrayList<>(2);\n+\t\tvalues.add(\"value1\");\n+\t\tvalues.add(\"value2\");\n+\t\tobjectUnderTest.put(\"key\", values);\n+\t\tMap<String, String> singleValueMap = objectUnderTest.toSingleValueMap();\n+\t\tassertThat(singleValueMap).hasSize(startingSize + 1);\n+\t\tassertThat(singleValueMap.get(\"key\")).isEqualTo(\"value1\");\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\t@Disabled(\"to be fixed in gh-25140\")\n+\tvoid toSingleValueMapWithEmptyList(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.put(\"key\", Collections.emptyList());\n+\t\tMap<String, String> singleValueMap = objectUnderTest.toSingleValueMap();\n+\t\tassertThat(singleValueMap).isEmpty();\n+\t\tassertThat(singleValueMap.get(\"key\")).isNull();\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid equalsOnExistingValues(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.clear();\n+\t\tobjectUnderTest.set(\"key1\", \"value1\");\n+\t\tassertThat(objectUnderTest).isEqualTo(objectUnderTest);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid equalsOnEmpty(MultiValueMap<String, String> objectUnderTest) {\n+\t\tobjectUnderTest.clear();\n+\t\tobjectUnderTest.set(\"key1\", \"value1\");\n+\t\tMultiValueMap<String, String> o1 = new LinkedMultiValueMap<>();\n+\t\to1.set(\"key1\", \"value1\");\n+\t\tassertThat(o1).isEqualTo(objectUnderTest);\n+\t\tassertThat(objectUnderTest).isEqualTo(o1);\n+\t\tMap<String, List<String>> o2 = new HashMap<>();\n+\t\to2.put(\"key1\", Collections.singletonList(\"value1\"));\n+\t\tassertThat(o2).isEqualTo(objectUnderTest);\n+\t\tassertThat(objectUnderTest).isEqualTo(o2);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"objectsUnderTest\")\n+\tvoid canNotChangeAnUnmodifiableMultiValueMap(MultiValueMap<String, String> objectUnderTest) {\n+\t\tMultiValueMap<String, String> asUnmodifiableMultiValueMap = CollectionUtils.unmodifiableMultiValueMap(objectUnderTest);\n+\t\tAssertions.assertAll(",
        "comment_created_at": "2020-05-29T14:22:08+00:00",
        "comment_author": "sbrannen",
        "comment_body": "It is not permissible to use JUnit Jupiter's `Assertions`. Doing so will actually fail the build.\r\n\r\nThus, please switch to AssertJ assertions and be sure to execute `./gradlew check` to verify that you don't have any Checkstyle violations in this regard.\r\n\r\nNote: if you want something similar to `assertAll`, you may wish to use `SoftAssertions` from AssertJ.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1135756118",
    "pr_number": 25316,
    "pr_file": "spring-expression/src/test/java/org/springframework/expression/spel/support/ReflectionHelperTests.java",
    "created_at": "2023-03-14T15:38:13+00:00",
    "commented_code": "field.write(ctx, tester, \"field\", null));\n \t}\n \n+\t@Test\n+\tvoid testReflectiveMethodResolver() throws AccessException {\n+\t\tMethodResolver resolver=new ReflectiveMethodResolver();\n+\t\tStandardEvaluationContext evaluationContext = new StandardEvaluationContext();\n+\t\tObject obj= Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class<?>[]{Runnable.class}, new InvocationHandler() {\n+\t\t\t@Override\n+\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t});\n+\t\tMethodExecutor mexec=resolver.resolve(evaluationContext,obj,\"toString\",new ArrayList<>());\n+\t\tAssert.notNull(mexec,\"MethodExecutor should not be empty.\");",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "1135756118",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25316,
        "pr_file": "spring-expression/src/test/java/org/springframework/expression/spel/support/ReflectionHelperTests.java",
        "discussion_id": "1135756118",
        "commented_code": "@@ -364,6 +364,19 @@ public void testOptimalReflectivePropertyAccessor() throws Exception {\n \t\t\t\tfield.write(ctx, tester, \"field\", null));\n \t}\n \n+\t@Test\n+\tvoid testReflectiveMethodResolver() throws AccessException {\n+\t\tMethodResolver resolver=new ReflectiveMethodResolver();\n+\t\tStandardEvaluationContext evaluationContext = new StandardEvaluationContext();\n+\t\tObject obj= Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class<?>[]{Runnable.class}, new InvocationHandler() {\n+\t\t\t@Override\n+\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t});\n+\t\tMethodExecutor mexec=resolver.resolve(evaluationContext,obj,\"toString\",new ArrayList<>());\n+\t\tAssert.notNull(mexec,\"MethodExecutor should not be empty.\");",
        "comment_created_at": "2023-03-14T15:38:13+00:00",
        "comment_author": "sbrannen",
        "comment_body": "We use AssertJ for test assertions, not Spring's `org.springframework.util.Assert` class.\r\n\r\nIn any case, I'll make that change when merging the PR.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "438933891",
    "pr_number": 25239,
    "pr_file": "spring-core/src/test/java/org/springframework/util/AssertTests.java",
    "created_at": "2020-06-11T16:57:59+00:00",
    "commented_code": ".withMessage(null);\n \t}\n \n+\t@Test\n+\tvoid noNullElementsWithCollection() {\n+\t\tAssert.noNullElements(asList(\"foo\", \"bar\"), \"enigma\");",
    "repo_full_name": "spring-projects/spring-framework",
    "discussion_comments": [
      {
        "comment_id": "438933891",
        "repo_full_name": "spring-projects/spring-framework",
        "pr_number": 25239,
        "pr_file": "spring-core/src/test/java/org/springframework/util/AssertTests.java",
        "discussion_id": "438933891",
        "commented_code": "@@ -401,6 +402,57 @@ void noNullElementsWithNullElementsAndNullMessageSupplier() {\n \t\t\t.withMessage(null);\n \t}\n \n+\t@Test\n+\tvoid noNullElementsWithCollection() {\n+\t\tAssert.noNullElements(asList(\"foo\", \"bar\"), \"enigma\");",
        "comment_created_at": "2020-06-11T16:57:59+00:00",
        "comment_author": "sbrannen",
        "comment_body": "For all assertions that are expected not to throw an exception, please rework them to use the following AssertJ construct, where `{}` is the code in question.\r\n\r\n```java\r\nassertThatCode(() -> {}).doesNotThrowAnyException();\r\n```",
        "pr_file_module": null
      }
    ]
  }
]