[
  {
    "discussion_id": "1960104748",
    "pr_number": 499,
    "pr_file": "lib/a11y/utils.ts",
    "created_at": "2025-02-18T16:32:33+00:00",
    "commented_code": "},\n             },\n           });\n-        });\n-    } catch (e) {\n-      logger({\n-        category: \"action\",\n-        message: \"error scrolling element into view\",\n-        level: 1,\n-        auxiliary: {\n-          error: {\n-            value: e.message,\n-            type: \"string\",\n-          },\n-          trace: {\n-            value: e.stack,\n-            type: \"string\",\n-          },\n-          xpath: {\n-            value: xpath,\n-            type: \"string\",\n-          },\n-        },\n-      });\n \n-      throw new PlaywrightCommandException(e.message);\n-    }\n-  } else if (method === \"fill\" || method === \"type\") {\n-    try {\n-      await locator.fill(\"\");\n-      await locator.click();\n-      const text = args[0]?.toString();\n-      for (const char of text) {\n-        await stagehandPage.keyboard.type(char, {\n-          delay: Math.random() * 50 + 25,\n-        });\n+          throw new PlaywrightCommandException(e.message);\n+        }\n+        break;\n       }\n-    } catch (e) {\n-      logger({\n-        category: \"action\",\n-        message: \"error filling element\",\n-        level: 1,\n-        auxiliary: {\n-          error: {\n-            value: e.message,\n-            type: \"string\",\n-          },\n-          trace: {\n-            value: e.stack,\n-            type: \"string\",\n-          },\n-          xpath: {\n-            value: xpath,\n-            type: \"string\",\n-          },\n-        },\n-      });\n+      case \"fill\": // fall through to type\n+      case \"type\": {\n+        try {\n+          await locator.fill(\"\");\n+          await locator.click();\n+          const text = args[0]?.toString();\n+          for (const char of text) {\n+            await stagehandPage.keyboard.type(char, {\n+              delay: Math.random() * 50 + 25,\n+            });\n+          }\n+        } catch (e) {\n+          logger({\n+            category: \"action\",\n+            message: \"error filling element\",\n+            level: 1,\n+            auxiliary: {\n+              error: {\n+                value: e.message,\n+                type: \"string\",\n+              },\n+              trace: {\n+                value: e.stack,\n+                type: \"string\",\n+              },\n+              xpath: {\n+                value: xpath,\n+                type: \"string\",\n+              },\n+            },\n+          });\n \n-      throw new PlaywrightCommandException(e.message);\n-    }\n-  } else if (method === \"press\") {\n-    try {\n-      const key = args[0]?.toString();\n-      await stagehandPage.keyboard.press(key);\n-    } catch (e) {\n-      logger({\n-        category: \"action\",\n-        message: \"error pressing key\",\n-        level: 1,\n-        auxiliary: {\n-          error: {\n-            value: e.message,\n-            type: \"string\",\n-          },\n-          trace: {\n-            value: e.stack,\n-            type: \"string\",\n+          throw new PlaywrightCommandException(e.message);\n+        }\n+        break;\n+      }\n+      // Handle navigation if a new page is opened\n+      case \"click\": {\n+        logger({\n+          category: \"action\",\n+          message: \"clicking element, checking for page navigation\",\n+          level: 1,\n+          auxiliary: {\n+            xpath: {\n+              value: xpath,\n+              type: \"string\",\n+            },\n           },\n-          key: {\n-            value: args[0]?.toString() ?? \"unknown\",\n-            type: \"string\",\n+        });\n+\n+        const newOpenedTab = await Promise.race([\n+          new Promise<Page | null>((resolve) => {\n+            Promise.resolve(stagehandPage.context()).then((context) => {\n+              context.once(\"page\", (page: Page) => resolve(page));\n+              setTimeout(() => resolve(null), 1_500);\n+            });\n+          }),\n+        ]);\n+\n+        logger({\n+          category: \"action\",\n+          message: \"clicked element\",\n+          level: 1,\n+          auxiliary: {\n+            newOpenedTab: {\n+              value: newOpenedTab ? \"opened a new tab\" : \"no new tabs opened\",\n+              type: \"string\",\n+            },\n           },\n-        },\n-      });\n+        });\n \n-      throw new PlaywrightCommandException(e.message);\n+        if (newOpenedTab) {\n+          logger({\n+            category: \"action\",\n+            message: \"new page detected (new tab) with URL\",\n+            level: 1,\n+            auxiliary: {\n+              url: {\n+                value: newOpenedTab.url(),\n+                type: \"string\",\n+              },\n+            },\n+          });\n+          await newOpenedTab.close();\n+          await stagehandPage.goto(newOpenedTab.url());\n+          await stagehandPage.waitForLoadState(\"domcontentloaded\");\n+        }\n+\n+        await Promise.race([\n+          stagehandPage.waitForLoadState(\"networkidle\"),\n+          new Promise((resolve) => setTimeout(resolve, 5_000)),\n+        ]).catch((e) => {\n+          logger({\n+            category: \"action\",\n+            message: \"network idle timeout hit\",\n+            level: 1,\n+            auxiliary: {\n+              trace: {\n+                value: e.stack,\n+                type: \"string\",\n+              },\n+              message: {\n+                value: e.message,\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        });\n+\n+        logger({\n+          category: \"action\",\n+          message: \"finished waiting for (possible) page navigation\",\n+          level: 1,\n+        });\n+\n+        if (stagehandPage.url() !== initialUrl) {\n+          logger({\n+            category: \"action\",\n+            message: \"new page detected with URL\",\n+            level: 1,\n+            auxiliary: {\n+              url: {\n+                value: stagehandPage.url(),\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        }\n+        break;\n+      }\n+      case \"press\": {\n+        try {\n+          const key = args[0]?.toString();\n+          await stagehandPage.keyboard.press(key);\n+        } catch (e) {\n+          logger({\n+            category: \"action\",\n+            message: \"error pressing key\",\n+            level: 1,\n+            auxiliary: {\n+              error: {\n+                value: e.message,\n+                type: \"string\",\n+              },\n+              trace: {\n+                value: e.stack,\n+                type: \"string\",\n+              },\n+              key: {\n+                value: args[0]?.toString() ?? \"unknown\",\n+                type: \"string\",\n+              },\n+            },\n+          });\n+\n+          throw new PlaywrightCommandException(e.message);\n+        }\n+        break;\n+      }\n+      default: {\n+        throw exhaustiveMatchingGuard(action);\n+      }",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1960104748",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 499,
        "pr_file": "lib/a11y/utils.ts",
        "discussion_id": "1960104748",
        "commented_code": "@@ -501,89 +533,173 @@ export async function performPlaywrightMethod(\n               },\n             },\n           });\n-        });\n-    } catch (e) {\n-      logger({\n-        category: \"action\",\n-        message: \"error scrolling element into view\",\n-        level: 1,\n-        auxiliary: {\n-          error: {\n-            value: e.message,\n-            type: \"string\",\n-          },\n-          trace: {\n-            value: e.stack,\n-            type: \"string\",\n-          },\n-          xpath: {\n-            value: xpath,\n-            type: \"string\",\n-          },\n-        },\n-      });\n \n-      throw new PlaywrightCommandException(e.message);\n-    }\n-  } else if (method === \"fill\" || method === \"type\") {\n-    try {\n-      await locator.fill(\"\");\n-      await locator.click();\n-      const text = args[0]?.toString();\n-      for (const char of text) {\n-        await stagehandPage.keyboard.type(char, {\n-          delay: Math.random() * 50 + 25,\n-        });\n+          throw new PlaywrightCommandException(e.message);\n+        }\n+        break;\n       }\n-    } catch (e) {\n-      logger({\n-        category: \"action\",\n-        message: \"error filling element\",\n-        level: 1,\n-        auxiliary: {\n-          error: {\n-            value: e.message,\n-            type: \"string\",\n-          },\n-          trace: {\n-            value: e.stack,\n-            type: \"string\",\n-          },\n-          xpath: {\n-            value: xpath,\n-            type: \"string\",\n-          },\n-        },\n-      });\n+      case \"fill\": // fall through to type\n+      case \"type\": {\n+        try {\n+          await locator.fill(\"\");\n+          await locator.click();\n+          const text = args[0]?.toString();\n+          for (const char of text) {\n+            await stagehandPage.keyboard.type(char, {\n+              delay: Math.random() * 50 + 25,\n+            });\n+          }\n+        } catch (e) {\n+          logger({\n+            category: \"action\",\n+            message: \"error filling element\",\n+            level: 1,\n+            auxiliary: {\n+              error: {\n+                value: e.message,\n+                type: \"string\",\n+              },\n+              trace: {\n+                value: e.stack,\n+                type: \"string\",\n+              },\n+              xpath: {\n+                value: xpath,\n+                type: \"string\",\n+              },\n+            },\n+          });\n \n-      throw new PlaywrightCommandException(e.message);\n-    }\n-  } else if (method === \"press\") {\n-    try {\n-      const key = args[0]?.toString();\n-      await stagehandPage.keyboard.press(key);\n-    } catch (e) {\n-      logger({\n-        category: \"action\",\n-        message: \"error pressing key\",\n-        level: 1,\n-        auxiliary: {\n-          error: {\n-            value: e.message,\n-            type: \"string\",\n-          },\n-          trace: {\n-            value: e.stack,\n-            type: \"string\",\n+          throw new PlaywrightCommandException(e.message);\n+        }\n+        break;\n+      }\n+      // Handle navigation if a new page is opened\n+      case \"click\": {\n+        logger({\n+          category: \"action\",\n+          message: \"clicking element, checking for page navigation\",\n+          level: 1,\n+          auxiliary: {\n+            xpath: {\n+              value: xpath,\n+              type: \"string\",\n+            },\n           },\n-          key: {\n-            value: args[0]?.toString() ?? \"unknown\",\n-            type: \"string\",\n+        });\n+\n+        const newOpenedTab = await Promise.race([\n+          new Promise<Page | null>((resolve) => {\n+            Promise.resolve(stagehandPage.context()).then((context) => {\n+              context.once(\"page\", (page: Page) => resolve(page));\n+              setTimeout(() => resolve(null), 1_500);\n+            });\n+          }),\n+        ]);\n+\n+        logger({\n+          category: \"action\",\n+          message: \"clicked element\",\n+          level: 1,\n+          auxiliary: {\n+            newOpenedTab: {\n+              value: newOpenedTab ? \"opened a new tab\" : \"no new tabs opened\",\n+              type: \"string\",\n+            },\n           },\n-        },\n-      });\n+        });\n \n-      throw new PlaywrightCommandException(e.message);\n+        if (newOpenedTab) {\n+          logger({\n+            category: \"action\",\n+            message: \"new page detected (new tab) with URL\",\n+            level: 1,\n+            auxiliary: {\n+              url: {\n+                value: newOpenedTab.url(),\n+                type: \"string\",\n+              },\n+            },\n+          });\n+          await newOpenedTab.close();\n+          await stagehandPage.goto(newOpenedTab.url());\n+          await stagehandPage.waitForLoadState(\"domcontentloaded\");\n+        }\n+\n+        await Promise.race([\n+          stagehandPage.waitForLoadState(\"networkidle\"),\n+          new Promise((resolve) => setTimeout(resolve, 5_000)),\n+        ]).catch((e) => {\n+          logger({\n+            category: \"action\",\n+            message: \"network idle timeout hit\",\n+            level: 1,\n+            auxiliary: {\n+              trace: {\n+                value: e.stack,\n+                type: \"string\",\n+              },\n+              message: {\n+                value: e.message,\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        });\n+\n+        logger({\n+          category: \"action\",\n+          message: \"finished waiting for (possible) page navigation\",\n+          level: 1,\n+        });\n+\n+        if (stagehandPage.url() !== initialUrl) {\n+          logger({\n+            category: \"action\",\n+            message: \"new page detected with URL\",\n+            level: 1,\n+            auxiliary: {\n+              url: {\n+                value: stagehandPage.url(),\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        }\n+        break;\n+      }\n+      case \"press\": {\n+        try {\n+          const key = args[0]?.toString();\n+          await stagehandPage.keyboard.press(key);\n+        } catch (e) {\n+          logger({\n+            category: \"action\",\n+            message: \"error pressing key\",\n+            level: 1,\n+            auxiliary: {\n+              error: {\n+                value: e.message,\n+                type: \"string\",\n+              },\n+              trace: {\n+                value: e.stack,\n+                type: \"string\",\n+              },\n+              key: {\n+                value: args[0]?.toString() ?? \"unknown\",\n+                type: \"string\",\n+              },\n+            },\n+          });\n+\n+          throw new PlaywrightCommandException(e.message);\n+        }\n+        break;\n+      }\n+      default: {\n+        throw exhaustiveMatchingGuard(action);\n+      }",
        "comment_created_at": "2025-02-18T16:32:33+00:00",
        "comment_author": "eastlondoner",
        "comment_body": "this makes this a type safe switch statement. Every defined action must be implemented or this will not compile",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1960210856",
    "pr_number": 499,
    "pr_file": "lib/handlers/actHandler.ts",
    "created_at": "2025-02-18T17:38:01+00:00",
    "commented_code": "}\n       }\n \n+      if (\"result\" in response) {\n+        let actionCompleted = false;\n+\n+        const newStepString =\n+          (!steps.endsWith(\"\n\") ? \"\n\" : \"\") +\n+          `## Step: Communicated findings\n` +\n+          `  Findings: ${response.result}\n` +\n+          `  Commentary: ${response.commentary}\n`;\n+        steps += newStepString;\n+\n+        if (response.completed) {\n+          actionCompleted = true;\n+        }\n+\n+        if (!actionCompleted) {\n+          this.logger({\n+            category: \"action\",\n+            message: \"continuing to next action step\",\n+            level: 1,\n+          });\n+\n+          return this.act({\n+            action,\n+            steps,\n+            llmClient,\n+            chunksSeen,\n+            requestId,\n+            variables,\n+            previousSelectors: [...previousSelectors],\n+            skipActionCacheForThisStep: false,\n+            domSettleTimeoutMs,\n+          });\n+        } else {\n+          return {\n+            success: true,\n+            message: `Action completed successfully: ${response.result}`,\n+            action: action,\n+          };\n+        }\n+      }\n       // Action found, proceed to execute\n       const elementId = response[\"element\"];\n-      const xpaths = selectorMap[elementId];\n+\n+      // If elementId is null, use the document body as the root element\n+      let xpaths: string[];\n+      if (elementId === null) {\n+        xpaths = [\"//body\"];\n+      } else {\n+        xpaths = selectorMap[elementId] ?? [];\n+      }",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1960210856",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 499,
        "pr_file": "lib/handlers/actHandler.ts",
        "discussion_id": "1960210856",
        "commented_code": "@@ -1235,18 +1312,68 @@ export class StagehandActHandler {\n         }\n       }\n \n+      if (\"result\" in response) {\n+        let actionCompleted = false;\n+\n+        const newStepString =\n+          (!steps.endsWith(\"\\n\") ? \"\\n\" : \"\") +\n+          `## Step: Communicated findings\\n` +\n+          `  Findings: ${response.result}\\n` +\n+          `  Commentary: ${response.commentary}\\n`;\n+        steps += newStepString;\n+\n+        if (response.completed) {\n+          actionCompleted = true;\n+        }\n+\n+        if (!actionCompleted) {\n+          this.logger({\n+            category: \"action\",\n+            message: \"continuing to next action step\",\n+            level: 1,\n+          });\n+\n+          return this.act({\n+            action,\n+            steps,\n+            llmClient,\n+            chunksSeen,\n+            requestId,\n+            variables,\n+            previousSelectors: [...previousSelectors],\n+            skipActionCacheForThisStep: false,\n+            domSettleTimeoutMs,\n+          });\n+        } else {\n+          return {\n+            success: true,\n+            message: `Action completed successfully: ${response.result}`,\n+            action: action,\n+          };\n+        }\n+      }\n       // Action found, proceed to execute\n       const elementId = response[\"element\"];\n-      const xpaths = selectorMap[elementId];\n+\n+      // If elementId is null, use the document body as the root element\n+      let xpaths: string[];\n+      if (elementId === null) {\n+        xpaths = [\"//body\"];\n+      } else {\n+        xpaths = selectorMap[elementId] ?? [];\n+      }",
        "comment_created_at": "2025-02-18T17:38:01+00:00",
        "comment_author": "eastlondoner",
        "comment_body": "handle the case where the tool call sets the elementId to null",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1868286394",
    "pr_number": 269,
    "pr_file": "evals/index.eval.ts",
    "created_at": "2024-12-03T19:35:23+00:00",
    "commented_code": "\"laroche_form\",\n   \"arxiv\",\n   \"amazon_add_to_cart\",\n-  \"extract_press_releases\"\n+  \"extract_press_releases\",\n   // \"expedia\"\n ];\n \n-const generateSummary = async (summary: any, results: any[]) => {\n+const generateSummary = async (\n+  summary: { scores?: Record<string, { score: number | null }> },\n+  results: Array<{\n+    input: EvalInput;\n+    output?: boolean | { _success: boolean };\n+  }>,\n+) => {",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1868286394",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 269,
        "pr_file": "evals/index.eval.ts",
        "discussion_id": "1868286394",
        "commented_code": "@@ -1585,17 +1607,26 @@ const testcases = [\n   \"laroche_form\",\n   \"arxiv\",\n   \"amazon_add_to_cart\",\n-  \"extract_press_releases\"\n+  \"extract_press_releases\",\n   // \"expedia\"\n ];\n \n-const generateSummary = async (summary: any, results: any[]) => {\n+const generateSummary = async (\n+  summary: { scores?: Record<string, { score: number | null }> },\n+  results: Array<{\n+    input: EvalInput;\n+    output?: boolean | { _success: boolean };\n+  }>,\n+) => {",
        "comment_created_at": "2024-12-03T19:35:23+00:00",
        "comment_author": "kamath",
        "comment_body": "```suggestion\r\n  results: {\r\n    input: EvalInput;\r\n    output?: boolean | { _success: boolean };\r\n  }[],\r\n) => {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1868564868",
    "pr_number": 269,
    "pr_file": "lib/llm/AnthropicClient.ts",
    "created_at": "2024-12-04T01:16:31+00:00",
    "commented_code": "},\n           },\n         });\n-        return cachedResponse;\n+        return cachedResponse as T;",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1868564868",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 269,
        "pr_file": "lib/llm/AnthropicClient.ts",
        "discussion_id": "1868564868",
        "commented_code": "@@ -79,7 +87,7 @@ export class AnthropicClient extends LLMClient {\n             },\n           },\n         });\n-        return cachedResponse;\n+        return cachedResponse as T;",
        "comment_created_at": "2024-12-04T01:16:31+00:00",
        "comment_author": "kamath",
        "comment_body": "can we do something like `const cacheOptions: AnthropicTransformedResponse | undefined = this.cache.get...` to avoid `as` forced typecast",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1868568824",
    "pr_number": 269,
    "pr_file": "lib/llm/AnthropicClient.ts",
    "created_at": "2024-12-04T01:23:20+00:00",
    "commented_code": "this.cache.set(cacheOptions, result, options.requestId);\n         }\n \n-        return result;\n+        return result as T;",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1868568824",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 269,
        "pr_file": "lib/llm/AnthropicClient.ts",
        "discussion_id": "1868568824",
        "commented_code": "@@ -261,7 +299,7 @@ export class AnthropicClient extends LLMClient {\n           this.cache.set(cacheOptions, result, options.requestId);\n         }\n \n-        return result;\n+        return result as T;",
        "comment_created_at": "2024-12-04T01:23:20+00:00",
        "comment_author": "kamath",
        "comment_body": "I like how earlier you said \"we can cast because...\" - either add that or do something like `const result: AnthropicTransformedResponse`",
        "pr_file_module": null
      }
    ]
  }
]