[
  {
    "discussion_id": "1941467167",
    "pr_number": 459,
    "pr_file": "lib/a11y/utils.ts",
    "created_at": "2025-02-04T16:07:35+00:00",
    "commented_code": "};\n }\n \n+/**\n+ * Retrieves the full accessibility tree via CDP and transforms it into a hierarchical structure.\n+ */\n export async function getAccessibilityTree(\n   page: StagehandPage,\n   logger: (logLine: LogLine) => void,\n-) {\n+): Promise<TreeResult> {\n   await page.enableCDP(\"Accessibility\");\n \n   try {\n+    // Fetch the full accessibility tree from Chrome DevTools Protocol\n     const { nodes } = await page.sendCDP<{ nodes: AXNode[] }>(\n       \"Accessibility.getFullAXTree\",\n     );\n \n-    // Extract specific sources\n+    // For each node with a backendDOMNodeId, resolve it\n+    for (const node of nodes) {\n+      // Convert the AX role to a plain string (since .value is optional)\n+      const role = node.role?.value;\n+\n+      if (node.backendDOMNodeId !== undefined) {\n+        try {\n+          // 1) Resolve the node to a Runtime object\n+          const { object } = await page.sendCDP<{\n+            object: { objectId?: string };\n+          }>(\"DOM.resolveNode\", {\n+            backendNodeId: node.backendDOMNodeId,\n+          });\n+\n+          if (object && object.objectId) {\n+            // 2) If valid, fetch the XPath (optional)\n+            try {\n+              const xpath = await getXPathByResolvedObjectId(\n+                await page.getCDPClient(),\n+                object.objectId,\n+              );\n+              node.xpath = xpath;\n+            } catch (xpathError) {\n+              logger({\n+                category: \"observation\",\n+                message: `Error fetching XPath for node ${node.backendDOMNodeId}`,\n+                level: 2,\n+                auxiliary: {\n+                  error: {\n+                    value: xpathError.message,\n+                    type: \"string\",\n+                  },\n+                },\n+              });\n+            }\n+\n+            // 3) If role is 'generic' or 'none' (or name is missing),\n+            //    we call a function on the element to get its tagName.\n+            if (role === \"generic\" || role === \"none\") {\n+              try {\n+                const { result } = await page.sendCDP<{\n+                  result: { type: string; value?: string };\n+                }>(\"Runtime.callFunctionOn\", {\n+                  objectId: object.objectId,\n+                  functionDeclaration: `\n+                    function() {\n+                      // \"this\" is the DOM element. Return its tagName in lowercase\n+                      return this.tagName ? this.tagName.toLowerCase() : \"\";\n+                    }\n+                  `,\n+                  returnByValue: true,\n+                });\n+\n+                // If we got a tagName, store it in node.name\n+                if (result?.value) {\n+                  // Overwrite node.role, so it won't be \"generic\" or empty\n+                  node.role = { value: result.value };\n+                }\n+              } catch (tagNameError) {\n+                // If we can't resolve the tagName, log and skip\n+                logger({\n+                  category: \"observation\",\n+                  message: `Could not fetch tagName for node ${node.backendDOMNodeId}`,\n+                  level: 2,\n+                  auxiliary: {\n+                    error: {\n+                      value: tagNameError.message,\n+                      type: \"string\",\n+                    },\n+                  },\n+                });\n+              }\n+            }\n+          }\n+        } catch (resolveError) {\n+          logger({\n+            category: \"observation\",\n+            message: `Could not resolve DOM node ID ${node.backendDOMNodeId}`,\n+            level: 2,\n+            auxiliary: {\n+              error: {\n+                value: resolveError.message,\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        }\n+      }\n+    }\n+\n+    // Now build the final hierarchical structure (including updated .name if replaced by tagName)\n     const sources = nodes.map((node) => ({\n       role: node.role?.value,\n       name: node.name?.value,\n       description: node.description?.value,\n       value: node.value?.value,\n       nodeId: node.nodeId,\n+      backendDOMNodeId: node.backendDOMNodeId,\n       parentId: node.parentId,\n       childIds: node.childIds,\n+      xpath: node.xpath,",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1941467167",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 459,
        "pr_file": "lib/a11y/utils.ts",
        "discussion_id": "1941467167",
        "commented_code": "@@ -137,26 +149,122 @@ export function buildHierarchicalTree(nodes: AccessibilityNode[]): TreeResult {\n   };\n }\n \n+/**\n+ * Retrieves the full accessibility tree via CDP and transforms it into a hierarchical structure.\n+ */\n export async function getAccessibilityTree(\n   page: StagehandPage,\n   logger: (logLine: LogLine) => void,\n-) {\n+): Promise<TreeResult> {\n   await page.enableCDP(\"Accessibility\");\n \n   try {\n+    // Fetch the full accessibility tree from Chrome DevTools Protocol\n     const { nodes } = await page.sendCDP<{ nodes: AXNode[] }>(\n       \"Accessibility.getFullAXTree\",\n     );\n \n-    // Extract specific sources\n+    // For each node with a backendDOMNodeId, resolve it\n+    for (const node of nodes) {\n+      // Convert the AX role to a plain string (since .value is optional)\n+      const role = node.role?.value;\n+\n+      if (node.backendDOMNodeId !== undefined) {\n+        try {\n+          // 1) Resolve the node to a Runtime object\n+          const { object } = await page.sendCDP<{\n+            object: { objectId?: string };\n+          }>(\"DOM.resolveNode\", {\n+            backendNodeId: node.backendDOMNodeId,\n+          });\n+\n+          if (object && object.objectId) {\n+            // 2) If valid, fetch the XPath (optional)\n+            try {\n+              const xpath = await getXPathByResolvedObjectId(\n+                await page.getCDPClient(),\n+                object.objectId,\n+              );\n+              node.xpath = xpath;\n+            } catch (xpathError) {\n+              logger({\n+                category: \"observation\",\n+                message: `Error fetching XPath for node ${node.backendDOMNodeId}`,\n+                level: 2,\n+                auxiliary: {\n+                  error: {\n+                    value: xpathError.message,\n+                    type: \"string\",\n+                  },\n+                },\n+              });\n+            }\n+\n+            // 3) If role is 'generic' or 'none' (or name is missing),\n+            //    we call a function on the element to get its tagName.\n+            if (role === \"generic\" || role === \"none\") {\n+              try {\n+                const { result } = await page.sendCDP<{\n+                  result: { type: string; value?: string };\n+                }>(\"Runtime.callFunctionOn\", {\n+                  objectId: object.objectId,\n+                  functionDeclaration: `\n+                    function() {\n+                      // \"this\" is the DOM element. Return its tagName in lowercase\n+                      return this.tagName ? this.tagName.toLowerCase() : \"\";\n+                    }\n+                  `,\n+                  returnByValue: true,\n+                });\n+\n+                // If we got a tagName, store it in node.name\n+                if (result?.value) {\n+                  // Overwrite node.role, so it won't be \"generic\" or empty\n+                  node.role = { value: result.value };\n+                }\n+              } catch (tagNameError) {\n+                // If we can't resolve the tagName, log and skip\n+                logger({\n+                  category: \"observation\",\n+                  message: `Could not fetch tagName for node ${node.backendDOMNodeId}`,\n+                  level: 2,\n+                  auxiliary: {\n+                    error: {\n+                      value: tagNameError.message,\n+                      type: \"string\",\n+                    },\n+                  },\n+                });\n+              }\n+            }\n+          }\n+        } catch (resolveError) {\n+          logger({\n+            category: \"observation\",\n+            message: `Could not resolve DOM node ID ${node.backendDOMNodeId}`,\n+            level: 2,\n+            auxiliary: {\n+              error: {\n+                value: resolveError.message,\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        }\n+      }\n+    }\n+\n+    // Now build the final hierarchical structure (including updated .name if replaced by tagName)\n     const sources = nodes.map((node) => ({\n       role: node.role?.value,\n       name: node.name?.value,\n       description: node.description?.value,\n       value: node.value?.value,\n       nodeId: node.nodeId,\n+      backendDOMNodeId: node.backendDOMNodeId,\n       parentId: node.parentId,\n       childIds: node.childIds,\n+      xpath: node.xpath,",
        "comment_created_at": "2025-02-04T16:07:35+00:00",
        "comment_author": "miguelg719",
        "comment_body": "for large websites it makes sense to compute the xpaths at runtime for the candidates selected by observe",
        "pr_file_module": null
      },
      {
        "comment_id": "1943963569",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 459,
        "pr_file": "lib/a11y/utils.ts",
        "discussion_id": "1941467167",
        "commented_code": "@@ -137,26 +149,122 @@ export function buildHierarchicalTree(nodes: AccessibilityNode[]): TreeResult {\n   };\n }\n \n+/**\n+ * Retrieves the full accessibility tree via CDP and transforms it into a hierarchical structure.\n+ */\n export async function getAccessibilityTree(\n   page: StagehandPage,\n   logger: (logLine: LogLine) => void,\n-) {\n+): Promise<TreeResult> {\n   await page.enableCDP(\"Accessibility\");\n \n   try {\n+    // Fetch the full accessibility tree from Chrome DevTools Protocol\n     const { nodes } = await page.sendCDP<{ nodes: AXNode[] }>(\n       \"Accessibility.getFullAXTree\",\n     );\n \n-    // Extract specific sources\n+    // For each node with a backendDOMNodeId, resolve it\n+    for (const node of nodes) {\n+      // Convert the AX role to a plain string (since .value is optional)\n+      const role = node.role?.value;\n+\n+      if (node.backendDOMNodeId !== undefined) {\n+        try {\n+          // 1) Resolve the node to a Runtime object\n+          const { object } = await page.sendCDP<{\n+            object: { objectId?: string };\n+          }>(\"DOM.resolveNode\", {\n+            backendNodeId: node.backendDOMNodeId,\n+          });\n+\n+          if (object && object.objectId) {\n+            // 2) If valid, fetch the XPath (optional)\n+            try {\n+              const xpath = await getXPathByResolvedObjectId(\n+                await page.getCDPClient(),\n+                object.objectId,\n+              );\n+              node.xpath = xpath;\n+            } catch (xpathError) {\n+              logger({\n+                category: \"observation\",\n+                message: `Error fetching XPath for node ${node.backendDOMNodeId}`,\n+                level: 2,\n+                auxiliary: {\n+                  error: {\n+                    value: xpathError.message,\n+                    type: \"string\",\n+                  },\n+                },\n+              });\n+            }\n+\n+            // 3) If role is 'generic' or 'none' (or name is missing),\n+            //    we call a function on the element to get its tagName.\n+            if (role === \"generic\" || role === \"none\") {\n+              try {\n+                const { result } = await page.sendCDP<{\n+                  result: { type: string; value?: string };\n+                }>(\"Runtime.callFunctionOn\", {\n+                  objectId: object.objectId,\n+                  functionDeclaration: `\n+                    function() {\n+                      // \"this\" is the DOM element. Return its tagName in lowercase\n+                      return this.tagName ? this.tagName.toLowerCase() : \"\";\n+                    }\n+                  `,\n+                  returnByValue: true,\n+                });\n+\n+                // If we got a tagName, store it in node.name\n+                if (result?.value) {\n+                  // Overwrite node.role, so it won't be \"generic\" or empty\n+                  node.role = { value: result.value };\n+                }\n+              } catch (tagNameError) {\n+                // If we can't resolve the tagName, log and skip\n+                logger({\n+                  category: \"observation\",\n+                  message: `Could not fetch tagName for node ${node.backendDOMNodeId}`,\n+                  level: 2,\n+                  auxiliary: {\n+                    error: {\n+                      value: tagNameError.message,\n+                      type: \"string\",\n+                    },\n+                  },\n+                });\n+              }\n+            }\n+          }\n+        } catch (resolveError) {\n+          logger({\n+            category: \"observation\",\n+            message: `Could not resolve DOM node ID ${node.backendDOMNodeId}`,\n+            level: 2,\n+            auxiliary: {\n+              error: {\n+                value: resolveError.message,\n+                type: \"string\",\n+              },\n+            },\n+          });\n+        }\n+      }\n+    }\n+\n+    // Now build the final hierarchical structure (including updated .name if replaced by tagName)\n     const sources = nodes.map((node) => ({\n       role: node.role?.value,\n       name: node.name?.value,\n       description: node.description?.value,\n       value: node.value?.value,\n       nodeId: node.nodeId,\n+      backendDOMNodeId: node.backendDOMNodeId,\n       parentId: node.parentId,\n       childIds: node.childIds,\n+      xpath: node.xpath,",
        "comment_created_at": "2025-02-06T02:03:13+00:00",
        "comment_author": "seanmcguire12",
        "comment_body": "yeah nice catch, we arent precomputing them, i'll take them out of the AXNode type since they are unused",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1915823362",
    "pr_number": 405,
    "pr_file": "lib/dom/process.ts",
    "created_at": "2025-01-15T01:17:20+00:00",
    "commented_code": "return node.nodeType === Node.TEXT_NODE && Boolean(node.textContent?.trim());\n }\n \n+function getMainScrollableElement(): HTMLElement {\n+  // Default to <html> (document.documentElement)\n+  let mainScrollable: HTMLElement = document.documentElement;\n+  let maxScrollableArea = 0;\n+\n+  // Find the largest candidate",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1915823362",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 405,
        "pr_file": "lib/dom/process.ts",
        "discussion_id": "1915823362",
        "commented_code": "@@ -9,6 +9,85 @@ export function isTextNode(node: Node): node is Text {\n   return node.nodeType === Node.TEXT_NODE && Boolean(node.textContent?.trim());\n }\n \n+function getMainScrollableElement(): HTMLElement {\n+  // Default to <html> (document.documentElement)\n+  let mainScrollable: HTMLElement = document.documentElement;\n+  let maxScrollableArea = 0;\n+\n+  // Find the largest candidate",
        "comment_created_at": "2025-01-15T01:17:20+00:00",
        "comment_author": "kamath",
        "comment_body": "so this is basically just getting literally the biggest element and marking that main? using this approach should totally be opt-in; i feel like this can get funky super fast",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1864024709",
    "pr_number": 201,
    "pr_file": "lib/handlers/extractHandler.ts",
    "created_at": "2024-11-30T01:00:50+00:00",
    "commented_code": "await this.waitForSettledDom(domSettleTimeoutMs);\n     await this.startDomDebug();\n-    const { outputString, chunk, chunks } = await this.stagehand.page.evaluate(\n-      (chunksSeen?: number[]) => window.processDom(chunksSeen ?? []),\n-      chunksSeen,\n-    );\n+\n+    const originalDOM = await this.stagehand.page.evaluate(() => window.storeDOM());\n+\n+    const { selectorMap }: { selectorMap: Record<number, string[]> } =\n+      await this.stagehand.page.evaluate(() => window.processAllOfDom());\n \n     this.logger({\n       category: \"extraction\",\n-      message: \"received output from processDom.\",\n-      auxiliary: {\n-        chunk: {\n-          value: chunk.toString(),\n-          type: \"integer\",\n-        },\n-        chunks_left: {\n-          value: (chunks.length - chunksSeen.length).toString(),\n-          type: \"integer\",\n-        },\n-        chunks_total: {\n-          value: chunks.length.toString(),\n-          type: \"integer\",\n-        },\n-      },\n+      message: `received output from processAllOfDom. selectorMap has ${Object.keys(selectorMap).length} entries`,\n+      level: 1,\n     });\n+    const PROXIMITY_THRESHOLD = 10;\n+    await this.stagehand.page.evaluate(() => window.createTextBoundingBoxes());\n+    const pageWidth = await this.stagehand.page.evaluate(() => window.innerWidth);\n+    const pageHeight = await this.stagehand.page.evaluate(() => window.innerHeight);\n+\n+    const seenAnnotations = new Map();\n+    const textAnnotations: TextAnnotation[] = [];\n+\n+    for (const xpaths of Object.values(selectorMap)) {\n+      const xpath = xpaths[0];\n+\n+      const boundingBoxes: Array<{\n+        text: string;\n+        left: number;\n+        top: number;\n+        width: number;\n+        height: number;\n+      }> = await this.stagehand.page.evaluate(\n+        (xpath) => window.getElementBoundingBoxes(xpath),\n+        xpath\n+      );\n+\n+      for (const box of boundingBoxes) {\n+        const text = box.text;\n+\n+        let annotationsForText = seenAnnotations.get(text);\n+        if (!annotationsForText) {\n+          annotationsForText = [];\n+          seenAnnotations.set(text, annotationsForText);\n+        }\n+\n+        const isDuplicate = annotationsForText.some((annotation) => {\n+          const dx = annotation.x - (box.left + box.width / 2);\n+          const dy = annotation.y - (box.top + box.height / 2);\n+          const distance = Math.sqrt(dx * dx + dy * dy);\n+          return distance < PROXIMITY_THRESHOLD;",
    "repo_full_name": "browserbase/stagehand",
    "discussion_comments": [
      {
        "comment_id": "1864024709",
        "repo_full_name": "browserbase/stagehand",
        "pr_number": 201,
        "pr_file": "lib/handlers/extractHandler.ts",
        "discussion_id": "1864024709",
        "commented_code": "@@ -85,46 +83,99 @@ export class StagehandExtractHandler {\n \n     await this.waitForSettledDom(domSettleTimeoutMs);\n     await this.startDomDebug();\n-    const { outputString, chunk, chunks } = await this.stagehand.page.evaluate(\n-      (chunksSeen?: number[]) => window.processDom(chunksSeen ?? []),\n-      chunksSeen,\n-    );\n+\n+    const originalDOM = await this.stagehand.page.evaluate(() => window.storeDOM());\n+\n+    const { selectorMap }: { selectorMap: Record<number, string[]> } =\n+      await this.stagehand.page.evaluate(() => window.processAllOfDom());\n \n     this.logger({\n       category: \"extraction\",\n-      message: \"received output from processDom.\",\n-      auxiliary: {\n-        chunk: {\n-          value: chunk.toString(),\n-          type: \"integer\",\n-        },\n-        chunks_left: {\n-          value: (chunks.length - chunksSeen.length).toString(),\n-          type: \"integer\",\n-        },\n-        chunks_total: {\n-          value: chunks.length.toString(),\n-          type: \"integer\",\n-        },\n-      },\n+      message: `received output from processAllOfDom. selectorMap has ${Object.keys(selectorMap).length} entries`,\n+      level: 1,\n     });\n+    const PROXIMITY_THRESHOLD = 10;\n+    await this.stagehand.page.evaluate(() => window.createTextBoundingBoxes());\n+    const pageWidth = await this.stagehand.page.evaluate(() => window.innerWidth);\n+    const pageHeight = await this.stagehand.page.evaluate(() => window.innerHeight);\n+\n+    const seenAnnotations = new Map();\n+    const textAnnotations: TextAnnotation[] = [];\n+\n+    for (const xpaths of Object.values(selectorMap)) {\n+      const xpath = xpaths[0];\n+\n+      const boundingBoxes: Array<{\n+        text: string;\n+        left: number;\n+        top: number;\n+        width: number;\n+        height: number;\n+      }> = await this.stagehand.page.evaluate(\n+        (xpath) => window.getElementBoundingBoxes(xpath),\n+        xpath\n+      );\n+\n+      for (const box of boundingBoxes) {\n+        const text = box.text;\n+\n+        let annotationsForText = seenAnnotations.get(text);\n+        if (!annotationsForText) {\n+          annotationsForText = [];\n+          seenAnnotations.set(text, annotationsForText);\n+        }\n+\n+        const isDuplicate = annotationsForText.some((annotation) => {\n+          const dx = annotation.x - (box.left + box.width / 2);\n+          const dy = annotation.y - (box.top + box.height / 2);\n+          const distance = Math.sqrt(dx * dx + dy * dy);\n+          return distance < PROXIMITY_THRESHOLD;",
        "comment_created_at": "2024-11-30T01:00:50+00:00",
        "comment_author": "kamath",
        "comment_body": "Check for deduping by checking bounding box + same word; this works but doesn't get rid of all of them. Not sure why but there are situations where it'll fail (won't remove duplicates or will still add). \r\n\r\nThus, add proximity threshold to give you a tolerance for deduping. This is hacky. Is \"10\" 10px?",
        "pr_file_module": null
      }
    ]
  }
]