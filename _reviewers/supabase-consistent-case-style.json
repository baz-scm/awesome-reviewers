[
  {
    "discussion_id": "2078474790",
    "pr_number": 35318,
    "pr_file": "apps/studio/pages/api/ai/sql/generate-v3.ts",
    "created_at": "2025-05-07T20:51:18+00:00",
    "commented_code": "const cookie = req.headers.cookie\n   const authorization = req.headers.authorization\n+  const accessToken = authorization?.replace('Bearer ', '')\n+\n+  if (!accessToken) {\n+    return res.status(401).json({ error: 'Authorization token is required' })\n+  }\n+\n+  let mcpTools: Record<string, Tool<any, any>> = {}\n+  let wrappedExecuteSqlTool: Tool<any, any> | undefined = undefined\n+  let schemasResult: any[] = []\n \n   try {\n-    const { result: schemas } = includeSchemaMetadata\n-      ? await executeSql(\n-          {\n-            projectRef,\n-            connectionString,\n-            sql: pgMetaSchemasList.sql,\n-          },\n-          undefined,\n-          {\n-            'Content-Type': 'application/json',\n-            ...(cookie && { cookie }),\n-            ...(authorization && { Authorization: authorization }),\n-          }\n+    // Fetch MCP client and tools only if opt-in level is not 'disabled'\n+    if (aiOptInLevel !== 'disabled') {\n+      const mcpClient = await createSupabaseMCPClient({\n+        accessToken,\n+        projectRef,\n+      })\n+\n+      let availableMcpTools = await mcpClient.tools()\n+      const disallowedTools = ['execute_sql', 'apply_migration', 'get_logs']\n+      const privacyMessage =\n+        'Fetching data requires a higher privacy level. Please enable this in your org settings'\n+\n+      if (aiOptInLevel === 'schema') {\n+        mcpTools = Object.fromEntries(\n+          Object.entries(availableMcpTools).map(([key, toolInstance]) => {\n+            if (disallowedTools.includes(key)) {\n+              return [\n+                key,\n+                {\n+                  ...toolInstance,\n+                  execute: async (_args: any, _context: any) => ({ status: privacyMessage }),\n+                },\n+              ]\n+            }\n+            return [key, toolInstance]\n+          })\n         )\n-      : { result: [] }\n+      } else if (aiOptInLevel === 'schema_and_data') {\n+        mcpTools = availableMcpTools\n+\n+        const originalExecuteSqlTool = mcpTools.execute_sql as Tool<any, any> | undefined\n+\n+        if (originalExecuteSqlTool) {\n+          wrappedExecuteSqlTool = tool({\n+            description: originalExecuteSqlTool.description,\n+            parameters: originalExecuteSqlTool.parameters,\n+            execute: async (args, context) => {\n+              if (!originalExecuteSqlTool.execute) {\n+                throw new Error('Original execute_sql tool has no execute function.')\n+              }\n+              const originalResult = await originalExecuteSqlTool.execute(args, context)\n+              const manualToolCallId = `manual_${crypto.randomUUID()}`\n+\n+              if (originalResult && typeof originalResult === 'object') {\n+                ;(originalResult as any).manualToolCallId = manualToolCallId\n+              } else {\n+                console.warn('execute_sql result is not an object, cannot add manualToolCallId')\n+                return {\n+                  error: 'Internal error: Unexpected tool result format',\n+                  manualToolCallId: manualToolCallId,\n+                }\n+              }\n+\n+              return originalResult\n+            },\n+          })\n+        } else {\n+          console.warn('execute_sql tool not found in mcpTools.')\n+        }\n+      }\n+\n+      const { result: fetchedSchemas } = await executeSql(\n+        {\n+          projectRef,\n+          connectionString,\n+          sql: pgMetaSchemasList.sql,\n+        },\n+        undefined,\n+        {\n+          'Content-Type': 'application/json',\n+          ...(cookie && { cookie }),\n+          ...(authorization && { Authorization: authorization }),\n+        }\n+      )\n+      schemasResult = fetchedSchemas\n+    }\n+\n+    const displayQuery = tool({\n+      description:\n+        'Displays SQL query results (table or chart) or renders SQL for write/DDL operations. Use this for all query display needs. Optionally references a previous execute_sql call via manualToolCallId for displaying SELECT results.',\n+      parameters: z.object({\n+        manualToolCallId: z\n+          .string()\n+          .optional()\n+          .describe(\n+            'The manual ID from the corresponding execute_sql result (for SELECT queries).'\n+          ),\n+        sql: z.string().describe('The SQL query.'),\n+        label: z\n+          .string()\n+          .describe(\n+            'The title or label for this query block (e.g., \"Users Over Time\", \"Create Users Table\").'\n+          ),\n+        view: z\n+          .enum(['table', 'chart'])\n+          .optional()\n+          .describe(\n+            'Display mode for SELECT results: table or chart. Required if manualToolCallId is provided.'\n+          ),\n+        xAxis: z.string().optional().describe('Key for the x-axis (required if view is chart).'),\n+        yAxis: z.string().optional().describe('Key for the y-axis (required if view is chart).'),\n+      }),\n+      execute: async (args) => {\n+        const statusMessage = args.manualToolCallId\n+          ? 'Tool call sent to client for rendering SELECT results.'\n+          : 'Tool call sent to client for rendering write/DDL query.'\n+        return { status: statusMessage }\n+      },\n+    })\n+\n+    const displayEdgeFunction = tool({\n+      description: 'Renders the code for a Supabase Edge Function for the user to deploy manually.',\n+      parameters: z.object({\n+        name: z\n+          .string()\n+          .describe('The URL-friendly name of the Edge Function (e.g., \"my-function\").'),\n+        code: z.string().describe('The TypeScript code for the Edge Function.'),\n+      }),\n+      execute: async (args) => {\n+        return { status: 'Tool call sent to client for rendering.' }\n+      },\n+    })\n+\n+    const allTools = {\n+      ...mcpTools,\n+      ...(wrappedExecuteSqlTool && { execute_sql: wrappedExecuteSqlTool }),\n+      displayQuery,\n+      displayEdgeFunction,",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2078474790",
        "repo_full_name": "supabase/supabase",
        "pr_number": 35318,
        "pr_file": "apps/studio/pages/api/ai/sql/generate-v3.ts",
        "discussion_id": "2078474790",
        "commented_code": "@@ -39,128 +48,302 @@ async function handlePost(req: NextApiRequest, res: NextApiResponse) {\n \n   const cookie = req.headers.cookie\n   const authorization = req.headers.authorization\n+  const accessToken = authorization?.replace('Bearer ', '')\n+\n+  if (!accessToken) {\n+    return res.status(401).json({ error: 'Authorization token is required' })\n+  }\n+\n+  let mcpTools: Record<string, Tool<any, any>> = {}\n+  let wrappedExecuteSqlTool: Tool<any, any> | undefined = undefined\n+  let schemasResult: any[] = []\n \n   try {\n-    const { result: schemas } = includeSchemaMetadata\n-      ? await executeSql(\n-          {\n-            projectRef,\n-            connectionString,\n-            sql: pgMetaSchemasList.sql,\n-          },\n-          undefined,\n-          {\n-            'Content-Type': 'application/json',\n-            ...(cookie && { cookie }),\n-            ...(authorization && { Authorization: authorization }),\n-          }\n+    // Fetch MCP client and tools only if opt-in level is not 'disabled'\n+    if (aiOptInLevel !== 'disabled') {\n+      const mcpClient = await createSupabaseMCPClient({\n+        accessToken,\n+        projectRef,\n+      })\n+\n+      let availableMcpTools = await mcpClient.tools()\n+      const disallowedTools = ['execute_sql', 'apply_migration', 'get_logs']\n+      const privacyMessage =\n+        'Fetching data requires a higher privacy level. Please enable this in your org settings'\n+\n+      if (aiOptInLevel === 'schema') {\n+        mcpTools = Object.fromEntries(\n+          Object.entries(availableMcpTools).map(([key, toolInstance]) => {\n+            if (disallowedTools.includes(key)) {\n+              return [\n+                key,\n+                {\n+                  ...toolInstance,\n+                  execute: async (_args: any, _context: any) => ({ status: privacyMessage }),\n+                },\n+              ]\n+            }\n+            return [key, toolInstance]\n+          })\n         )\n-      : { result: [] }\n+      } else if (aiOptInLevel === 'schema_and_data') {\n+        mcpTools = availableMcpTools\n+\n+        const originalExecuteSqlTool = mcpTools.execute_sql as Tool<any, any> | undefined\n+\n+        if (originalExecuteSqlTool) {\n+          wrappedExecuteSqlTool = tool({\n+            description: originalExecuteSqlTool.description,\n+            parameters: originalExecuteSqlTool.parameters,\n+            execute: async (args, context) => {\n+              if (!originalExecuteSqlTool.execute) {\n+                throw new Error('Original execute_sql tool has no execute function.')\n+              }\n+              const originalResult = await originalExecuteSqlTool.execute(args, context)\n+              const manualToolCallId = `manual_${crypto.randomUUID()}`\n+\n+              if (originalResult && typeof originalResult === 'object') {\n+                ;(originalResult as any).manualToolCallId = manualToolCallId\n+              } else {\n+                console.warn('execute_sql result is not an object, cannot add manualToolCallId')\n+                return {\n+                  error: 'Internal error: Unexpected tool result format',\n+                  manualToolCallId: manualToolCallId,\n+                }\n+              }\n+\n+              return originalResult\n+            },\n+          })\n+        } else {\n+          console.warn('execute_sql tool not found in mcpTools.')\n+        }\n+      }\n+\n+      const { result: fetchedSchemas } = await executeSql(\n+        {\n+          projectRef,\n+          connectionString,\n+          sql: pgMetaSchemasList.sql,\n+        },\n+        undefined,\n+        {\n+          'Content-Type': 'application/json',\n+          ...(cookie && { cookie }),\n+          ...(authorization && { Authorization: authorization }),\n+        }\n+      )\n+      schemasResult = fetchedSchemas\n+    }\n+\n+    const displayQuery = tool({\n+      description:\n+        'Displays SQL query results (table or chart) or renders SQL for write/DDL operations. Use this for all query display needs. Optionally references a previous execute_sql call via manualToolCallId for displaying SELECT results.',\n+      parameters: z.object({\n+        manualToolCallId: z\n+          .string()\n+          .optional()\n+          .describe(\n+            'The manual ID from the corresponding execute_sql result (for SELECT queries).'\n+          ),\n+        sql: z.string().describe('The SQL query.'),\n+        label: z\n+          .string()\n+          .describe(\n+            'The title or label for this query block (e.g., \"Users Over Time\", \"Create Users Table\").'\n+          ),\n+        view: z\n+          .enum(['table', 'chart'])\n+          .optional()\n+          .describe(\n+            'Display mode for SELECT results: table or chart. Required if manualToolCallId is provided.'\n+          ),\n+        xAxis: z.string().optional().describe('Key for the x-axis (required if view is chart).'),\n+        yAxis: z.string().optional().describe('Key for the y-axis (required if view is chart).'),\n+      }),\n+      execute: async (args) => {\n+        const statusMessage = args.manualToolCallId\n+          ? 'Tool call sent to client for rendering SELECT results.'\n+          : 'Tool call sent to client for rendering write/DDL query.'\n+        return { status: statusMessage }\n+      },\n+    })\n+\n+    const displayEdgeFunction = tool({\n+      description: 'Renders the code for a Supabase Edge Function for the user to deploy manually.',\n+      parameters: z.object({\n+        name: z\n+          .string()\n+          .describe('The URL-friendly name of the Edge Function (e.g., \"my-function\").'),\n+        code: z.string().describe('The TypeScript code for the Edge Function.'),\n+      }),\n+      execute: async (args) => {\n+        return { status: 'Tool call sent to client for rendering.' }\n+      },\n+    })\n+\n+    const allTools = {\n+      ...mcpTools,\n+      ...(wrappedExecuteSqlTool && { execute_sql: wrappedExecuteSqlTool }),\n+      displayQuery,\n+      displayEdgeFunction,",
        "comment_created_at": "2025-05-07T20:51:18+00:00",
        "comment_author": "gregnr",
        "comment_body": "Perhaps we switch to snake_case to be consistent with MCP? Our MCP server chose snake_case to match the ecosystem. There's also a (very small) argument to be made that snake_case performs better across models since many models have a lot of Python training data.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2139352070",
    "pr_number": 36298,
    "pr_file": "apps/studio/components/interfaces/Settings/Logs/Logs.utils.ts",
    "created_at": "2025-06-11T06:53:23+00:00",
    "commented_code": "case 'supavisor_logs':\n       return `select id, ${table}.timestamp, event_message from ${table} ${joins} ${where} ${orderBy} limit ${limit}`\n \n+    case 'unified_logs':\n+      return `\n+\n+-- edge logs\n+select \n+  id,\n+  el.timestamp as timestamp,\n+  'edge' as log_type,\n+  CAST(edge_logs_response.status_code AS STRING) as code,\n+  'undefined' as level,\n+  edge_logs_request.path as path,\n+  'undefined' as event_message,\n+  edge_logs_request.method as method,\n+  authorization_payload.role as api_role,\n+  COALESCE(sb.auth_user, null) as auth_user,\n+from edge_logs as el\n+cross join unnest(metadata) as edge_logs_metadata\n+cross join unnest(edge_logs_metadata.request) as edge_logs_request\n+cross join unnest(edge_logs_metadata.response) as edge_logs_response\n+left join unnest(edge_logs_request.sb) as sb\n+left join unnest(sb.jwt) as jwt\n+left join unnest(jwt.authorization) as auth\n+left join unnest(auth.payload) as authorization_payload\n+\n+union all\n+\n+-- postgres logs\n+select \n+  id,\n+  pgl.timestamp as timestamp,\n+  'postgres' as log_type,\n+  pgl_parsed.sql_state_code as code,\n+  'undefined' as level,\n+  null as path,\n+  'undefined' as event_message,\n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+from postgres_logs as pgl\n+cross join unnest(pgl.metadata) as pgl_metadata\n+cross join unnest(pgl_metadata.parsed) as pgl_parsed\n+\n+union all \n+\n+-- function event logs\n+select \n+  id, \n+  fl.timestamp as timestamp,\n+  'function logs' as log_type,\n+  'undefined' as code,\n+  fl_metadata.level as level,\n+  null as path,\n+  fl.event_message as event_message, \n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+  -- fl_metadata.function_id as function_id, \n+  -- fl_metadata.event_type as event_type, \n+from function_logs as fl\n+cross join unnest(metadata) as fl_metadata\n+\n+union all\n+\n+-- function edge logs\n+select \n+  id, \n+  fel.timestamp as timestamp,\n+  'edge function' as log_type,\n+  CAST(fel_response.status_code as STRING) as code,\n+  'undefined' as level,\n+  fel_request.url as path,\n+  'undefined' as event_message,\n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+  -- fel.event_message as event_message,\n+  -- fel_request.path as path,\n+  -- fel_metadata.function_id as function_id,\n+  -- fel_metadata.execution_time_ms as execution_time_ms, \n+  -- fel_metadata.deployment_id as deployment_id, \n+  -- fel_metadata.version as version \n+from function_edge_logs as fel\n+cross join unnest(metadata) as fel_metadata\n+cross join unnest(fel_metadata.response) as fel_response\n+cross join unnest(fel_metadata.request) as fel_request\n+\n+union all\n+\n+-- OLDER QUERY FOR AUTH LOGS\n+--\n+-- auth logs\n+-- select \n+--  id, \n+--  al.timestamp as timestamp, \n+--  'auth' as log_type,\n+--  REGEXP_EXTRACT(al_metadata.msg, r'^(\\d+):') as code, \n+--  -- 'undefined' as code, \n+--  al_metadata.level as level, \n+--  al_metadata.path as path, \n+--  'undefined' as event_message,\n+  -- al_metadata.status as status, \n+  -- 'undefined' as method,\n+-- from auth_logs as al\n+-- cross join unnest(metadata) as al_metadata\n+\n+-- NEW QUERY FOR AUTH LOGS\n+-- THIS USES EDGE LOGS AS WELL TO GET STATUS AND PATH\n+--\n+select\n+  al.id as id, \n+  el_in_al.timestamp as timestamp, \n+  el_in_al_request.path as path, \n+  'auth' as log_type,\n+  CAST(el_in_al_response.status_code as STRING) as code,\n+  'undefined' as level,\n+  null as path,\n+  el_in_al_request.method as method,\n+  authorization_payload.role as api_role,\n+  COALESCE(sb.auth_user, null) as auth_user,\n+from auth_logs as al\n+cross join unnest(metadata) as al_metadata left join (\n+  edge_logs as el_in_al\n+    cross join unnest (metadata) as el_in_al_metadata \n+    cross join unnest (el_in_al_metadata. response) as el_in_al_response \n+    cross join unnest (el_in_al_response.headers) as el_in_al_response_headers \n+    cross join unnest (el_in_al_metadata. request) as el_in_al_request\n+    left join unnest(el_in_al_request.sb) as sb\n+    left join unnest(sb.jwt) as jwt\n+    left join unnest(jwt.authorization) as auth\n+    left join unnest(auth.payload) as authorization_payload\n+)\n+on al_metadata. request_id = el_in_al_response_headers.cf_ray\n+-- filter out auth logs without a request_id\n+-- it looks like most auth logs are logged twice, one of them has a request_id\n+where al_metadata.request_id is not null\n+\n+union all\n+\n+-- supavisor logs\n+select \n+  id, \n+  svl.timestamp as timestamp, \n+  'supavisor' as log_type,\n+  'undefined' as code,\n+  svl_metadata.level as level,\n+  null as path,\n+  'undefined' as event_message,\n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+from supavisor_logs as svl\n+cross join unnest(metadata) as svl_metadata\n+\n+union all\n+\n+-- pg_upgrade logs\n+select \n+  id, \n+  pgul.timestamp as timestamp,\n+  'postgres upgrade' as log_type,",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2139352070",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36298,
        "pr_file": "apps/studio/components/interfaces/Settings/Logs/Logs.utils.ts",
        "discussion_id": "2139352070",
        "commented_code": "@@ -205,6 +205,181 @@ limit ${limit}\n     case 'supavisor_logs':\n       return `select id, ${table}.timestamp, event_message from ${table} ${joins} ${where} ${orderBy} limit ${limit}`\n \n+    case 'unified_logs':\n+      return `\n+\n+-- edge logs\n+select \n+  id,\n+  el.timestamp as timestamp,\n+  'edge' as log_type,\n+  CAST(edge_logs_response.status_code AS STRING) as code,\n+  'undefined' as level,\n+  edge_logs_request.path as path,\n+  'undefined' as event_message,\n+  edge_logs_request.method as method,\n+  authorization_payload.role as api_role,\n+  COALESCE(sb.auth_user, null) as auth_user,\n+from edge_logs as el\n+cross join unnest(metadata) as edge_logs_metadata\n+cross join unnest(edge_logs_metadata.request) as edge_logs_request\n+cross join unnest(edge_logs_metadata.response) as edge_logs_response\n+left join unnest(edge_logs_request.sb) as sb\n+left join unnest(sb.jwt) as jwt\n+left join unnest(jwt.authorization) as auth\n+left join unnest(auth.payload) as authorization_payload\n+\n+union all\n+\n+-- postgres logs\n+select \n+  id,\n+  pgl.timestamp as timestamp,\n+  'postgres' as log_type,\n+  pgl_parsed.sql_state_code as code,\n+  'undefined' as level,\n+  null as path,\n+  'undefined' as event_message,\n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+from postgres_logs as pgl\n+cross join unnest(pgl.metadata) as pgl_metadata\n+cross join unnest(pgl_metadata.parsed) as pgl_parsed\n+\n+union all \n+\n+-- function event logs\n+select \n+  id, \n+  fl.timestamp as timestamp,\n+  'function logs' as log_type,\n+  'undefined' as code,\n+  fl_metadata.level as level,\n+  null as path,\n+  fl.event_message as event_message, \n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+  -- fl_metadata.function_id as function_id, \n+  -- fl_metadata.event_type as event_type, \n+from function_logs as fl\n+cross join unnest(metadata) as fl_metadata\n+\n+union all\n+\n+-- function edge logs\n+select \n+  id, \n+  fel.timestamp as timestamp,\n+  'edge function' as log_type,\n+  CAST(fel_response.status_code as STRING) as code,\n+  'undefined' as level,\n+  fel_request.url as path,\n+  'undefined' as event_message,\n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+  -- fel.event_message as event_message,\n+  -- fel_request.path as path,\n+  -- fel_metadata.function_id as function_id,\n+  -- fel_metadata.execution_time_ms as execution_time_ms, \n+  -- fel_metadata.deployment_id as deployment_id, \n+  -- fel_metadata.version as version \n+from function_edge_logs as fel\n+cross join unnest(metadata) as fel_metadata\n+cross join unnest(fel_metadata.response) as fel_response\n+cross join unnest(fel_metadata.request) as fel_request\n+\n+union all\n+\n+-- OLDER QUERY FOR AUTH LOGS\n+--\n+-- auth logs\n+-- select \n+--  id, \n+--  al.timestamp as timestamp, \n+--  'auth' as log_type,\n+--  REGEXP_EXTRACT(al_metadata.msg, r'^(\\d+):') as code, \n+--  -- 'undefined' as code, \n+--  al_metadata.level as level, \n+--  al_metadata.path as path, \n+--  'undefined' as event_message,\n+  -- al_metadata.status as status, \n+  -- 'undefined' as method,\n+-- from auth_logs as al\n+-- cross join unnest(metadata) as al_metadata\n+\n+-- NEW QUERY FOR AUTH LOGS\n+-- THIS USES EDGE LOGS AS WELL TO GET STATUS AND PATH\n+--\n+select\n+  al.id as id, \n+  el_in_al.timestamp as timestamp, \n+  el_in_al_request.path as path, \n+  'auth' as log_type,\n+  CAST(el_in_al_response.status_code as STRING) as code,\n+  'undefined' as level,\n+  null as path,\n+  el_in_al_request.method as method,\n+  authorization_payload.role as api_role,\n+  COALESCE(sb.auth_user, null) as auth_user,\n+from auth_logs as al\n+cross join unnest(metadata) as al_metadata left join (\n+  edge_logs as el_in_al\n+    cross join unnest (metadata) as el_in_al_metadata \n+    cross join unnest (el_in_al_metadata. response) as el_in_al_response \n+    cross join unnest (el_in_al_response.headers) as el_in_al_response_headers \n+    cross join unnest (el_in_al_metadata. request) as el_in_al_request\n+    left join unnest(el_in_al_request.sb) as sb\n+    left join unnest(sb.jwt) as jwt\n+    left join unnest(jwt.authorization) as auth\n+    left join unnest(auth.payload) as authorization_payload\n+)\n+on al_metadata. request_id = el_in_al_response_headers.cf_ray\n+-- filter out auth logs without a request_id\n+-- it looks like most auth logs are logged twice, one of them has a request_id\n+where al_metadata.request_id is not null\n+\n+union all\n+\n+-- supavisor logs\n+select \n+  id, \n+  svl.timestamp as timestamp, \n+  'supavisor' as log_type,\n+  'undefined' as code,\n+  svl_metadata.level as level,\n+  null as path,\n+  'undefined' as event_message,\n+  'undefined' as method,\n+  'api_role' as api_role,\n+  null as auth_user,\n+from supavisor_logs as svl\n+cross join unnest(metadata) as svl_metadata\n+\n+union all\n+\n+-- pg_upgrade logs\n+select \n+  id, \n+  pgul.timestamp as timestamp,\n+  'postgres upgrade' as log_type,",
        "comment_created_at": "2025-06-11T06:53:23+00:00",
        "comment_author": "Ziinc",
        "comment_body": "possibly snake case for log_type? ",
        "pr_file_module": null
      }
    ]
  }
]