[
  {
    "discussion_id": "1222032247",
    "pr_number": 13745,
    "pr_file": "apps/docs/pages/guides/auth/column-level-security.mdx",
    "created_at": "2023-06-07T18:52:18+00:00",
    "commented_code": "+import Layout from '~/layouts/DefaultGuideLayout'\n+\n+export const meta = {\n+  id: 'column-level-security',\n+  title: 'Column Level Security',\n+  description: 'Secure your data using Postgres Column Level Security.',\n+}\n+\n+Sometimes you want to restrict access to specific columns in your database.\n+For example, let's assume you have a `posts` table with the following columns:\n+- `id`\n+- `user_id`\n+- `title`\n+- `content`\n+- `created_at`\n+- `updated_at`\n+\n+It's fairly easy to restrict updates to the user who created it using [RLS](/docs/guides/auth#row-level-security), with the following policy:\n+\n+```sql\n+create a policy \"Allow update for owners\"\n+  on posts for update\n+  using (auth.uid() = user_id);\n+```\n+\n+However, this gives the post owner full access to update the row, including:\n+- `id`\n+- `user_id`\n+- `created_at` and `updated_at` (which should be set automatically)\n+\n+To restrict access to these columns, you can use [Privileges](https://www.postgresql.org/docs/current/ddl-priv.html).\n+\n+There are two types of privileges in PostgreSQL:\n+1. **table-level**: Grants the privilege on all columns in the table.\n+2. **column-level** Grants the privilege on a specific column in the table.\n+\n+You can have both types of privileges on the same table. If you have both, and you revoke the column-level privilege, the table-level privilege will still be in effect.\n+\n+By default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` role can update all the columns in the table.\n+\n+```sql\n+revoke update on table public.posts from authenticated;",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "1222032247",
        "repo_full_name": "supabase/supabase",
        "pr_number": 13745,
        "pr_file": "apps/docs/pages/guides/auth/column-level-security.mdx",
        "discussion_id": "1222032247",
        "commented_code": "@@ -0,0 +1,63 @@\n+import Layout from '~/layouts/DefaultGuideLayout'\n+\n+export const meta = {\n+  id: 'column-level-security',\n+  title: 'Column Level Security',\n+  description: 'Secure your data using Postgres Column Level Security.',\n+}\n+\n+Sometimes you want to restrict access to specific columns in your database.\n+For example, let's assume you have a `posts` table with the following columns:\n+- `id`\n+- `user_id`\n+- `title`\n+- `content`\n+- `created_at`\n+- `updated_at`\n+\n+It's fairly easy to restrict updates to the user who created it using [RLS](/docs/guides/auth#row-level-security), with the following policy:\n+\n+```sql\n+create a policy \"Allow update for owners\"\n+  on posts for update\n+  using (auth.uid() = user_id);\n+```\n+\n+However, this gives the post owner full access to update the row, including:\n+- `id`\n+- `user_id`\n+- `created_at` and `updated_at` (which should be set automatically)\n+\n+To restrict access to these columns, you can use [Privileges](https://www.postgresql.org/docs/current/ddl-priv.html).\n+\n+There are two types of privileges in PostgreSQL:\n+1. **table-level**: Grants the privilege on all columns in the table.\n+2. **column-level** Grants the privilege on a specific column in the table.\n+\n+You can have both types of privileges on the same table. If you have both, and you revoke the column-level privilege, the table-level privilege will still be in effect.\n+\n+By default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` role can update all the columns in the table.\n+\n+```sql\n+revoke update on table public.posts from authenticated;",
        "comment_created_at": "2023-06-07T18:52:18+00:00",
        "comment_author": "steve-chavez",
        "comment_body": "Here it would be good to be clear about the `anon` role having the `UPDATE` privilege by default as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "1222032937",
        "repo_full_name": "supabase/supabase",
        "pr_number": 13745,
        "pr_file": "apps/docs/pages/guides/auth/column-level-security.mdx",
        "discussion_id": "1222032247",
        "commented_code": "@@ -0,0 +1,63 @@\n+import Layout from '~/layouts/DefaultGuideLayout'\n+\n+export const meta = {\n+  id: 'column-level-security',\n+  title: 'Column Level Security',\n+  description: 'Secure your data using Postgres Column Level Security.',\n+}\n+\n+Sometimes you want to restrict access to specific columns in your database.\n+For example, let's assume you have a `posts` table with the following columns:\n+- `id`\n+- `user_id`\n+- `title`\n+- `content`\n+- `created_at`\n+- `updated_at`\n+\n+It's fairly easy to restrict updates to the user who created it using [RLS](/docs/guides/auth#row-level-security), with the following policy:\n+\n+```sql\n+create a policy \"Allow update for owners\"\n+  on posts for update\n+  using (auth.uid() = user_id);\n+```\n+\n+However, this gives the post owner full access to update the row, including:\n+- `id`\n+- `user_id`\n+- `created_at` and `updated_at` (which should be set automatically)\n+\n+To restrict access to these columns, you can use [Privileges](https://www.postgresql.org/docs/current/ddl-priv.html).\n+\n+There are two types of privileges in PostgreSQL:\n+1. **table-level**: Grants the privilege on all columns in the table.\n+2. **column-level** Grants the privilege on a specific column in the table.\n+\n+You can have both types of privileges on the same table. If you have both, and you revoke the column-level privilege, the table-level privilege will still be in effect.\n+\n+By default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` role can update all the columns in the table.\n+\n+```sql\n+revoke update on table public.posts from authenticated;",
        "comment_created_at": "2023-06-07T18:53:09+00:00",
        "comment_author": "steve-chavez",
        "comment_body": "```suggestion\r\nBy default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` and `anon` roles can update all the columns in the table.\r\n\r\n```sql\r\nrevoke update on table public.posts from authenticated;\r\nrevoke update on table public.posts from anon;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1223469827",
        "repo_full_name": "supabase/supabase",
        "pr_number": 13745,
        "pr_file": "apps/docs/pages/guides/auth/column-level-security.mdx",
        "discussion_id": "1222032247",
        "commented_code": "@@ -0,0 +1,63 @@\n+import Layout from '~/layouts/DefaultGuideLayout'\n+\n+export const meta = {\n+  id: 'column-level-security',\n+  title: 'Column Level Security',\n+  description: 'Secure your data using Postgres Column Level Security.',\n+}\n+\n+Sometimes you want to restrict access to specific columns in your database.\n+For example, let's assume you have a `posts` table with the following columns:\n+- `id`\n+- `user_id`\n+- `title`\n+- `content`\n+- `created_at`\n+- `updated_at`\n+\n+It's fairly easy to restrict updates to the user who created it using [RLS](/docs/guides/auth#row-level-security), with the following policy:\n+\n+```sql\n+create a policy \"Allow update for owners\"\n+  on posts for update\n+  using (auth.uid() = user_id);\n+```\n+\n+However, this gives the post owner full access to update the row, including:\n+- `id`\n+- `user_id`\n+- `created_at` and `updated_at` (which should be set automatically)\n+\n+To restrict access to these columns, you can use [Privileges](https://www.postgresql.org/docs/current/ddl-priv.html).\n+\n+There are two types of privileges in PostgreSQL:\n+1. **table-level**: Grants the privilege on all columns in the table.\n+2. **column-level** Grants the privilege on a specific column in the table.\n+\n+You can have both types of privileges on the same table. If you have both, and you revoke the column-level privilege, the table-level privilege will still be in effect.\n+\n+By default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` role can update all the columns in the table.\n+\n+```sql\n+revoke update on table public.posts from authenticated;",
        "comment_created_at": "2023-06-08T19:38:24+00:00",
        "comment_author": "steve-chavez",
        "comment_body": "@saltcod This is not yet addressed ^. Pinging in case you miss it.\r\n\r\n**Edit**: Sorry, thought you were the author of the PR :sweat_smile: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1222105853",
    "pr_number": 13745,
    "pr_file": "apps/docs/pages/guides/auth/column-level-security.mdx",
    "created_at": "2023-06-07T20:12:13+00:00",
    "commented_code": "+import Layout from '~/layouts/DefaultGuideLayout'\n+\n+export const meta = {\n+  id: 'column-level-security',\n+  title: 'Column Level Security',\n+  description: 'Secure your data using Postgres Column Level Security.',\n+}\n+\n+Sometimes you want to restrict access to specific columns in your database.\n+For example, let's assume you have a `posts` table with the following columns:\n+- `id`\n+- `user_id`\n+- `title`\n+- `content`\n+- `created_at`\n+- `updated_at`\n+\n+It's fairly easy to restrict updates to the user who created it using [RLS](/docs/guides/auth#row-level-security), with the following policy:\n+\n+```sql\n+create a policy \"Allow update for owners\"\n+  on posts for update\n+  using (auth.uid() = user_id);\n+```\n+\n+However, this gives the post owner full access to update the row, including:\n+- `id`\n+- `user_id`\n+- `created_at` and `updated_at` (which should be set automatically)\n+\n+## Privileges\n+\n+To restrict access to these columns, you can use [Privileges](https://www.postgresql.org/docs/current/ddl-priv.html).\n+\n+There are two types of privileges in PostgreSQL:\n+1. **table-level**: Grants the privilege on all columns in the table.\n+2. **column-level** Grants the privilege on a specific column in the table.\n+\n+You can have both types of privileges on the same table. If you have both, and you revoke the column-level privilege, the table-level privilege will still be in effect.\n+\n+By default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` role can update all the columns in the table.\n+\n+```sql\n+revoke update on table public.posts from authenticated;\n+grant update (title, content) on table public.posts to authenticated;\n+```\n+\n+In the above example, we are revoking the table-level `UPDATE` privilege from the `authenticated` role and granting a column-level `UPDATE` privilege on the `title` and `content` columns.\n+\n+Now, let's say we want to restrict access to updating the `title` column as well:\n+\n+```sql\n+revoke update (title) on table public.posts from authenticated;\n+```\n+\n+This time, we are revoking the column-level `UPDATE` privilege of the `title` column from the `authenticated` role. We didn't need to revoke the table-level `UPDATE` privilege because it's already revoked.\n+\n+\n+## GUI\n+Maintaining all the privileges without a tool can be difficult and error-prone.\n+Luckily, you can view and edit the privileges in the [Supabase Studio](https://app.supabase.com/project/_/auth/privileges).",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "1222105853",
        "repo_full_name": "supabase/supabase",
        "pr_number": 13745,
        "pr_file": "apps/docs/pages/guides/auth/column-level-security.mdx",
        "discussion_id": "1222105853",
        "commented_code": "@@ -0,0 +1,65 @@\n+import Layout from '~/layouts/DefaultGuideLayout'\n+\n+export const meta = {\n+  id: 'column-level-security',\n+  title: 'Column Level Security',\n+  description: 'Secure your data using Postgres Column Level Security.',\n+}\n+\n+Sometimes you want to restrict access to specific columns in your database.\n+For example, let's assume you have a `posts` table with the following columns:\n+- `id`\n+- `user_id`\n+- `title`\n+- `content`\n+- `created_at`\n+- `updated_at`\n+\n+It's fairly easy to restrict updates to the user who created it using [RLS](/docs/guides/auth#row-level-security), with the following policy:\n+\n+```sql\n+create a policy \"Allow update for owners\"\n+  on posts for update\n+  using (auth.uid() = user_id);\n+```\n+\n+However, this gives the post owner full access to update the row, including:\n+- `id`\n+- `user_id`\n+- `created_at` and `updated_at` (which should be set automatically)\n+\n+## Privileges\n+\n+To restrict access to these columns, you can use [Privileges](https://www.postgresql.org/docs/current/ddl-priv.html).\n+\n+There are two types of privileges in PostgreSQL:\n+1. **table-level**: Grants the privilege on all columns in the table.\n+2. **column-level** Grants the privilege on a specific column in the table.\n+\n+You can have both types of privileges on the same table. If you have both, and you revoke the column-level privilege, the table-level privilege will still be in effect.\n+\n+By default, our table will have a table-level `UPDATE` privilege, which means that the `authenticated` role can update all the columns in the table.\n+\n+```sql\n+revoke update on table public.posts from authenticated;\n+grant update (title, content) on table public.posts to authenticated;\n+```\n+\n+In the above example, we are revoking the table-level `UPDATE` privilege from the `authenticated` role and granting a column-level `UPDATE` privilege on the `title` and `content` columns.\n+\n+Now, let's say we want to restrict access to updating the `title` column as well:\n+\n+```sql\n+revoke update (title) on table public.posts from authenticated;\n+```\n+\n+This time, we are revoking the column-level `UPDATE` privilege of the `title` column from the `authenticated` role. We didn't need to revoke the table-level `UPDATE` privilege because it's already revoked.\n+\n+\n+## GUI\n+Maintaining all the privileges without a tool can be difficult and error-prone.\n+Luckily, you can view and edit the privileges in the [Supabase Studio](https://app.supabase.com/project/_/auth/privileges).",
        "comment_created_at": "2023-06-07T20:12:13+00:00",
        "comment_author": "kiwicopple",
        "comment_body": "Does this route exist? I'm getting a 404.\r\n\r\nEven if it does exist, I think we should remove this section, or instead add 2 sections:\r\n\r\n- Managing roles using the Dashboard\r\n- Managing roles using Migrations\r\n\r\nWe should be nudging people to use Migrations wherever possible",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2014805314",
    "pr_number": 34439,
    "pr_file": "apps/docs/content/guides/auth/third-party/clerk.mdx",
    "created_at": "2025-03-26T18:41:45+00:00",
    "commented_code": "+---\n+id: 'auth-third-party-clerk'\n+title: 'Clerk'\n+subtitle: 'Use Clerk with your Supabase project'\n+---\n+\n+Clerk can be used as a third-party authentication provider alongside Supabase Auth, or standalone, with your Supabase project.\n+\n+## Getting started\n+\n+Getting started is incredibly easy. Start off by visiting [Clerk's Connect with Supabase page](https://dashboard.clerk.com/setup/supabase) to configure your Clerk instance for Supabase compatibility.\n+\n+Finally add a [new Third-Party Auth integration with Clerk](/dashboard/project/_/auth/third-party) in the Supabase dashboard.\n+\n+### Setting up the Supabase CLI\n+\n+In the CLI add the following config to your `supabase/config.toml` file:\n+\n+```toml\n+[auth.third_party.clerk]\n+enabled = true\n+domain = \"example.clerk.accounts.dev\"\n+```\n+\n+### Manually configuring your Clerk instance\n+\n+If you are not able to use [Clerk's Connect with Supabase page](https://dashboard.clerk.com/setup/supabase) to easily configure your Clerk instance for working with Supabase, follow these steps.\n+\n+All Clerk [session tokens](https://clerk.com/docs/backend-requests/resources/session-tokens) you send to Supabase must contain a `role` claim. End-users who are authenticated should have the `authenticated` value. In some cases you may wish to change the role to match your advanced Postgres setup.\n+\n+Follow Clerk's guide on [customizing the session token](https://clerk.com/docs/backend-requests/custom-session-token) to add or modify the `role` claim based on your project's needs.\n+\n+Once all Clerk session tokens for your instance contain the `role` claim, add a [new Third-Party Auth integration with Clerk](/dashboard/project/_/auth/third-party) in the Supabase dashboard or register it in the CLI as instructed above.\n+\n+## Setup the Supabase client library\n+\n+<Tabs type=\"underlined\" queryGroup=\"clerk-create-client\">\n+\n+<TabPanel id=\"ts\" label=\"TypeScript\">\n+\n+```typescript\n+import { createClient } from '@supabase/supabase-js'\n+\n+const supabase = createClient('https://<supabase-project>.supabase.co', 'SUPABASE_ANON_KEY', {\n+  accessToken: () => {\n+    return Clerk.session?.getToken()\n+  },\n+})\n+```\n+\n+</TabPanel>\n+\n+<TabPanel id=\"dart\" label=\"Flutter\">\n+\n+```dart\n+import 'package:clerk_flutter/clerk_flutter.dart';\n+import 'package:supabase_flutter/supabase_flutter.dart';\n+...\n+\n+await Supabase.initialize(\n+  url: 'SUPABASE_URL',\n+  anonKey: 'SUPABASE_ANON_KEY',\n+  accessToken: () async {\n+    final token = await ClerkAuth.of(context).sessionToken();\n+    return token.jwt;\n+  },\n+);\n+```\n+\n+</TabPanel>\n+\n+<TabPanel id=\"swift\" label=\"Swift (iOS)\">\n+\n+```swift\n+import Clerk\n+import Supabase\n+\n+let supabase = SupabaseClient(\n+  supabaseURL: URL(string: \"https://project-ref.supabase.io\")!,\n+  supabaseKey: \"supabase.anon.key\",\n+  options: SupabaseClientOptions(\n+    auth: SupabaseClientOptions.AuthOptions(\n+      accessToken: {\n+        try await Clerk.shared.session?.getToken()?.jwt\n+      }\n+    )\n+  )\n+)\n+```\n+\n+</TabPanel>\n+\n+</Tabs>\n+\n+## Using RLS policies\n+\n+Once you've configured the Supabase client library to use Clerk session tokens, you can use RLS policies to secure access to your project's database, Storage objects and Realtime channels.\n+\n+The recommended way to design RLS policies with Clerk is to use claims present in your Clerk session token to allow or reject access to your project's data. Check [Clerk's docs](https://clerk.com/docs/backend-requests/resources/session-tokens) on the available JWT claims and their values.\n+\n+### Example: Check user organization role\n+\n+```sql\n+create policy \"Only organization admins can insert in table\"\n+  on table_name\n+  to authenticated\n+  with check (\n+    (auth.jwt()->>'org_role' = 'org:admin')\n+      and\n+    (organization_id = auth.jwt()->>'org_id')",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2014805314",
        "repo_full_name": "supabase/supabase",
        "pr_number": 34439,
        "pr_file": "apps/docs/content/guides/auth/third-party/clerk.mdx",
        "discussion_id": "2014805314",
        "commented_code": "@@ -0,0 +1,142 @@\n+---\n+id: 'auth-third-party-clerk'\n+title: 'Clerk'\n+subtitle: 'Use Clerk with your Supabase project'\n+---\n+\n+Clerk can be used as a third-party authentication provider alongside Supabase Auth, or standalone, with your Supabase project.\n+\n+## Getting started\n+\n+Getting started is incredibly easy. Start off by visiting [Clerk's Connect with Supabase page](https://dashboard.clerk.com/setup/supabase) to configure your Clerk instance for Supabase compatibility.\n+\n+Finally add a [new Third-Party Auth integration with Clerk](/dashboard/project/_/auth/third-party) in the Supabase dashboard.\n+\n+### Setting up the Supabase CLI\n+\n+In the CLI add the following config to your `supabase/config.toml` file:\n+\n+```toml\n+[auth.third_party.clerk]\n+enabled = true\n+domain = \"example.clerk.accounts.dev\"\n+```\n+\n+### Manually configuring your Clerk instance\n+\n+If you are not able to use [Clerk's Connect with Supabase page](https://dashboard.clerk.com/setup/supabase) to easily configure your Clerk instance for working with Supabase, follow these steps.\n+\n+All Clerk [session tokens](https://clerk.com/docs/backend-requests/resources/session-tokens) you send to Supabase must contain a `role` claim. End-users who are authenticated should have the `authenticated` value. In some cases you may wish to change the role to match your advanced Postgres setup.\n+\n+Follow Clerk's guide on [customizing the session token](https://clerk.com/docs/backend-requests/custom-session-token) to add or modify the `role` claim based on your project's needs.\n+\n+Once all Clerk session tokens for your instance contain the `role` claim, add a [new Third-Party Auth integration with Clerk](/dashboard/project/_/auth/third-party) in the Supabase dashboard or register it in the CLI as instructed above.\n+\n+## Setup the Supabase client library\n+\n+<Tabs type=\"underlined\" queryGroup=\"clerk-create-client\">\n+\n+<TabPanel id=\"ts\" label=\"TypeScript\">\n+\n+```typescript\n+import { createClient } from '@supabase/supabase-js'\n+\n+const supabase = createClient('https://<supabase-project>.supabase.co', 'SUPABASE_ANON_KEY', {\n+  accessToken: () => {\n+    return Clerk.session?.getToken()\n+  },\n+})\n+```\n+\n+</TabPanel>\n+\n+<TabPanel id=\"dart\" label=\"Flutter\">\n+\n+```dart\n+import 'package:clerk_flutter/clerk_flutter.dart';\n+import 'package:supabase_flutter/supabase_flutter.dart';\n+...\n+\n+await Supabase.initialize(\n+  url: 'SUPABASE_URL',\n+  anonKey: 'SUPABASE_ANON_KEY',\n+  accessToken: () async {\n+    final token = await ClerkAuth.of(context).sessionToken();\n+    return token.jwt;\n+  },\n+);\n+```\n+\n+</TabPanel>\n+\n+<TabPanel id=\"swift\" label=\"Swift (iOS)\">\n+\n+```swift\n+import Clerk\n+import Supabase\n+\n+let supabase = SupabaseClient(\n+  supabaseURL: URL(string: \"https://project-ref.supabase.io\")!,\n+  supabaseKey: \"supabase.anon.key\",\n+  options: SupabaseClientOptions(\n+    auth: SupabaseClientOptions.AuthOptions(\n+      accessToken: {\n+        try await Clerk.shared.session?.getToken()?.jwt\n+      }\n+    )\n+  )\n+)\n+```\n+\n+</TabPanel>\n+\n+</Tabs>\n+\n+## Using RLS policies\n+\n+Once you've configured the Supabase client library to use Clerk session tokens, you can use RLS policies to secure access to your project's database, Storage objects and Realtime channels.\n+\n+The recommended way to design RLS policies with Clerk is to use claims present in your Clerk session token to allow or reject access to your project's data. Check [Clerk's docs](https://clerk.com/docs/backend-requests/resources/session-tokens) on the available JWT claims and their values.\n+\n+### Example: Check user organization role\n+\n+```sql\n+create policy \"Only organization admins can insert in table\"\n+  on table_name\n+  to authenticated\n+  with check (\n+    (auth.jwt()->>'org_role' = 'org:admin')\n+      and\n+    (organization_id = auth.jwt()->>'org_id')",
        "comment_created_at": "2025-03-26T18:41:45+00:00",
        "comment_author": "charislam",
        "comment_body": "```suggestion\r\n    (organization_id = (select auth.jwt()->>'org_id'))\r\n```",
        "pr_file_module": null
      }
    ]
  }
]