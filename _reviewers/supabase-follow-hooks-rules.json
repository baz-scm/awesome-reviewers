[
  {
    "discussion_id": "2098475245",
    "pr_number": 35774,
    "pr_file": "apps/studio/components/grid/components/footer/pagination/Pagination.tsx",
    "created_at": "2025-05-20T17:05:26+00:00",
    "commented_code": "}\n   }, [id])\n \n+  useEffect(() => {\n+    // If the count query encountered a timeout error with exact count\n+    // turn off the exact count to rely on approximate\n+    if (isError && snap.enforceExactCount && error.code === 408) {",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2098475245",
        "repo_full_name": "supabase/supabase",
        "pr_number": 35774,
        "pr_file": "apps/studio/components/grid/components/footer/pagination/Pagination.tsx",
        "discussion_id": "2098475245",
        "commented_code": "@@ -133,6 +133,14 @@ const Pagination = () => {\n     }\n   }, [id])\n \n+  useEffect(() => {\n+    // If the count query encountered a timeout error with exact count\n+    // turn off the exact count to rely on approximate\n+    if (isError && snap.enforceExactCount && error.code === 408) {",
        "comment_created_at": "2025-05-20T17:05:26+00:00",
        "comment_author": "alaister",
        "comment_body": "If you don't want to include `snap.enforceExactCount` and `error.code` in the dependency array, you should wrap them in `useLatest()` outside the `useEffect` so we don't accidentally read stale values here!",
        "pr_file_module": null
      },
      {
        "comment_id": "2099517892",
        "repo_full_name": "supabase/supabase",
        "pr_number": 35774,
        "pr_file": "apps/studio/components/grid/components/footer/pagination/Pagination.tsx",
        "discussion_id": "2098475245",
        "commented_code": "@@ -133,6 +133,14 @@ const Pagination = () => {\n     }\n   }, [id])\n \n+  useEffect(() => {\n+    // If the count query encountered a timeout error with exact count\n+    // turn off the exact count to rely on approximate\n+    if (isError && snap.enforceExactCount && error.code === 408) {",
        "comment_created_at": "2025-05-21T07:01:23+00:00",
        "comment_author": "avallete",
        "comment_body": "Oh ! I was wondering since `snap.setPage` wasn't a deps here: https://github.com/supabase/supabase/pull/35774/files#diff-357ec6b1c5b04e3a99a116ebe222a9682dc4cbb1ab1bc175202db3a6fb6193c6R124-R132\r\n\r\nI wondered if maybe there was some case where we don't wanna mention all dependencies (methods, derived properties, ...).\r\n\r\nBut I don't mind declaring them all in the array of dependencies. Good spot. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071560900",
    "pr_number": 35384,
    "pr_file": "apps/studio/lib/telemetry.tsx",
    "created_at": "2025-05-02T12:44:48+00:00",
    "commented_code": "+import { PageTelemetry } from 'common'\n+import GroupsTelemetry from 'components/ui/GroupsTelemetry'\n+import { API_URL, IS_PLATFORM } from 'lib/constants'\n+import { useConsentToast } from 'ui-patterns/consent'\n+\n+export function Telemetry() {\n+  // Although this is \"technically\" breaking the rules of hooks\n+  // IS_PLATFORM never changes within a session, so this won't cause any issues\n+  // eslint-disable-next-line react-hooks/rules-of-hooks\n+  const { hasAcceptedConsent } = IS_PLATFORM ? useConsentToast() : { hasAcceptedConsent: true }",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2071560900",
        "repo_full_name": "supabase/supabase",
        "pr_number": 35384,
        "pr_file": "apps/studio/lib/telemetry.tsx",
        "discussion_id": "2071560900",
        "commented_code": "@@ -0,0 +1,22 @@\n+import { PageTelemetry } from 'common'\n+import GroupsTelemetry from 'components/ui/GroupsTelemetry'\n+import { API_URL, IS_PLATFORM } from 'lib/constants'\n+import { useConsentToast } from 'ui-patterns/consent'\n+\n+export function Telemetry() {\n+  // Although this is \"technically\" breaking the rules of hooks\n+  // IS_PLATFORM never changes within a session, so this won't cause any issues\n+  // eslint-disable-next-line react-hooks/rules-of-hooks\n+  const { hasAcceptedConsent } = IS_PLATFORM ? useConsentToast() : { hasAcceptedConsent: true }",
        "comment_created_at": "2025-05-02T12:44:48+00:00",
        "comment_author": "jordienr",
        "comment_body": "you could use an { enabled: bool } argument in the hook to enable/disable it conditionally without breaking the hook law\r\n\r\nuseConsentToast({ enabled: IS_PLATFORM })",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2039724409",
    "pr_number": 33310,
    "pr_file": "apps/studio/components/ui/Charts/ComposedChartHandler.tsx",
    "created_at": "2025-04-11T15:01:16+00:00",
    "commented_code": "+import { useRouter } from 'next/router'\n+import React, { PropsWithChildren, useState, useMemo, useEffect, useRef } from 'react'\n+import { cn } from 'ui'\n+\n+import { AnalyticsInterval, DataPoint } from 'data/analytics/constants'\n+import {\n+  InfraMonitoringAttribute,\n+  useInfraMonitoringQuery,\n+} from 'data/analytics/infra-monitoring-query'\n+import {\n+  ProjectDailyStatsAttribute,\n+  useProjectDailyStatsQuery,\n+} from 'data/analytics/project-daily-stats-query'\n+import { Loader2 } from 'lucide-react'\n+import { useDatabaseSelectorStateSnapshot } from 'state/database-selector'\n+import { WarningIcon } from 'ui'\n+import type { ChartData } from './Charts.types'\n+import Panel from 'components/ui/Panel'\n+import { useChartHighlight } from './useChartHighlight'\n+import type { UpdateDateRange } from 'pages/project/[ref]/reports/database'\n+import ComposedChart from './ComposedChart'\n+\n+type Provider = 'infra-monitoring' | 'daily-stats'\n+\n+export type MultiAttribute = {\n+  attribute: string\n+  provider: Provider\n+  label?: string\n+  color?: string\n+  format?: 'percent' | 'number'\n+  description?: string\n+  docsLink?: string\n+  isMaxValue?: boolean\n+  type?: 'line' | 'area-bar'\n+  omitFromTotal?: boolean\n+  tooltip?: string\n+}\n+\n+interface ComposedChartHandlerProps {\n+  id?: string\n+  label: string\n+  attributes: MultiAttribute[]\n+  startDate: string\n+  endDate: string\n+  interval: string\n+  customDateFormat?: string\n+  defaultChartStyle?: 'bar' | 'line' | 'stackedAreaLine'\n+  hideChartType?: boolean\n+  data?: ChartData\n+  isLoading?: boolean\n+  format?: string\n+  highlightedValue?: string | number\n+  className?: string\n+  showTooltip?: boolean\n+  showLegend?: boolean\n+  showTotal?: boolean\n+  showMaxValue?: boolean\n+  updateDateRange: UpdateDateRange\n+  valuePrecision?: number\n+  isVisible?: boolean\n+}\n+\n+/**\n+ * Wrapper component that handles intersection observer logic for lazy loading\n+ */\n+const LazyChartWrapper = ({ children }: PropsWithChildren) => {\n+  const [isVisible, setIsVisible] = useState(false)\n+  const ref = useRef<HTMLDivElement>(null)\n+\n+  useEffect(() => {\n+    const observer = new IntersectionObserver(\n+      ([entry]) => {\n+        if (entry.isIntersecting) {\n+          setIsVisible(true)\n+          observer.disconnect()\n+        }\n+      },\n+      {\n+        rootMargin: '150px 0px', // Start loading before the component enters viewport\n+        threshold: 0,\n+      }\n+    )\n+\n+    const currentRef = ref.current\n+    if (currentRef) {\n+      observer.observe(currentRef)\n+    }\n+\n+    return () => {\n+      if (currentRef) {\n+        observer.unobserve(currentRef)\n+      }\n+    }\n+  }, [])\n+\n+  return <div ref={ref}>{React.cloneElement(children as React.ReactElement, { isVisible })}</div>\n+}\n+\n+// Create a custom hook to fetch data based on attributes\n+const useAttributeQueries = (\n+  attributes: MultiAttribute[],\n+  ref: string | string[] | undefined,\n+  startDate: string,\n+  endDate: string,\n+  interval: AnalyticsInterval,\n+  databaseIdentifier: string | undefined,\n+  data: ChartData | undefined,\n+  isVisible: boolean\n+) => {\n+  // Use individual hooks for each attribute instead of using map\n+  const results = []\n+\n+  // We need to use separate hooks for each possible attribute\n+  // This ensures hooks are called unconditionally at the top level\n+  for (let i = 0; i < attributes.length; i++) {\n+    const attr = attributes[i]\n+\n+    if (attr.provider === 'daily-stats') {\n+      // Must use hook directly, not in a conditional or loop\n+      const dailyStatsQuery = useProjectDailyStatsQuery(",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2039724409",
        "repo_full_name": "supabase/supabase",
        "pr_number": 33310,
        "pr_file": "apps/studio/components/ui/Charts/ComposedChartHandler.tsx",
        "discussion_id": "2039724409",
        "commented_code": "@@ -0,0 +1,344 @@\n+import { useRouter } from 'next/router'\n+import React, { PropsWithChildren, useState, useMemo, useEffect, useRef } from 'react'\n+import { cn } from 'ui'\n+\n+import { AnalyticsInterval, DataPoint } from 'data/analytics/constants'\n+import {\n+  InfraMonitoringAttribute,\n+  useInfraMonitoringQuery,\n+} from 'data/analytics/infra-monitoring-query'\n+import {\n+  ProjectDailyStatsAttribute,\n+  useProjectDailyStatsQuery,\n+} from 'data/analytics/project-daily-stats-query'\n+import { Loader2 } from 'lucide-react'\n+import { useDatabaseSelectorStateSnapshot } from 'state/database-selector'\n+import { WarningIcon } from 'ui'\n+import type { ChartData } from './Charts.types'\n+import Panel from 'components/ui/Panel'\n+import { useChartHighlight } from './useChartHighlight'\n+import type { UpdateDateRange } from 'pages/project/[ref]/reports/database'\n+import ComposedChart from './ComposedChart'\n+\n+type Provider = 'infra-monitoring' | 'daily-stats'\n+\n+export type MultiAttribute = {\n+  attribute: string\n+  provider: Provider\n+  label?: string\n+  color?: string\n+  format?: 'percent' | 'number'\n+  description?: string\n+  docsLink?: string\n+  isMaxValue?: boolean\n+  type?: 'line' | 'area-bar'\n+  omitFromTotal?: boolean\n+  tooltip?: string\n+}\n+\n+interface ComposedChartHandlerProps {\n+  id?: string\n+  label: string\n+  attributes: MultiAttribute[]\n+  startDate: string\n+  endDate: string\n+  interval: string\n+  customDateFormat?: string\n+  defaultChartStyle?: 'bar' | 'line' | 'stackedAreaLine'\n+  hideChartType?: boolean\n+  data?: ChartData\n+  isLoading?: boolean\n+  format?: string\n+  highlightedValue?: string | number\n+  className?: string\n+  showTooltip?: boolean\n+  showLegend?: boolean\n+  showTotal?: boolean\n+  showMaxValue?: boolean\n+  updateDateRange: UpdateDateRange\n+  valuePrecision?: number\n+  isVisible?: boolean\n+}\n+\n+/**\n+ * Wrapper component that handles intersection observer logic for lazy loading\n+ */\n+const LazyChartWrapper = ({ children }: PropsWithChildren) => {\n+  const [isVisible, setIsVisible] = useState(false)\n+  const ref = useRef<HTMLDivElement>(null)\n+\n+  useEffect(() => {\n+    const observer = new IntersectionObserver(\n+      ([entry]) => {\n+        if (entry.isIntersecting) {\n+          setIsVisible(true)\n+          observer.disconnect()\n+        }\n+      },\n+      {\n+        rootMargin: '150px 0px', // Start loading before the component enters viewport\n+        threshold: 0,\n+      }\n+    )\n+\n+    const currentRef = ref.current\n+    if (currentRef) {\n+      observer.observe(currentRef)\n+    }\n+\n+    return () => {\n+      if (currentRef) {\n+        observer.unobserve(currentRef)\n+      }\n+    }\n+  }, [])\n+\n+  return <div ref={ref}>{React.cloneElement(children as React.ReactElement, { isVisible })}</div>\n+}\n+\n+// Create a custom hook to fetch data based on attributes\n+const useAttributeQueries = (\n+  attributes: MultiAttribute[],\n+  ref: string | string[] | undefined,\n+  startDate: string,\n+  endDate: string,\n+  interval: AnalyticsInterval,\n+  databaseIdentifier: string | undefined,\n+  data: ChartData | undefined,\n+  isVisible: boolean\n+) => {\n+  // Use individual hooks for each attribute instead of using map\n+  const results = []\n+\n+  // We need to use separate hooks for each possible attribute\n+  // This ensures hooks are called unconditionally at the top level\n+  for (let i = 0; i < attributes.length; i++) {\n+    const attr = attributes[i]\n+\n+    if (attr.provider === 'daily-stats') {\n+      // Must use hook directly, not in a conditional or loop\n+      const dailyStatsQuery = useProjectDailyStatsQuery(",
        "comment_created_at": "2025-04-11T15:01:16+00:00",
        "comment_author": "fsansalvadore",
        "comment_body": "@jordienr do you have any suggestion on how _not_ to break the \"rule of hooks\" here?\r\n\r\nI need to trigger a `useProjectDailyStatsQuery` or a `useInfraMonitoringQuery` for every separate metric in the \"ComposedCharts\" (for example, in \"Memory usage\" chart there would be ram used, ram cache and buffers, ram free, etc). Hence why I'm using a loop here.\r\n\r\nThis is what is triggering the typecheck error. (The app works fine though)\r\nFor context, this loop was previously in a .map function, then I tried using a \"for loop\" but it didn't fix the rule of hooks breaking.\r\n\r\nIdeally these separate metrics should be combined in a single query and then parsed and extrapolated in the frontend. But that would be a separate task for the near future.",
        "pr_file_module": null
      },
      {
        "comment_id": "2039757786",
        "repo_full_name": "supabase/supabase",
        "pr_number": 33310,
        "pr_file": "apps/studio/components/ui/Charts/ComposedChartHandler.tsx",
        "discussion_id": "2039724409",
        "commented_code": "@@ -0,0 +1,344 @@\n+import { useRouter } from 'next/router'\n+import React, { PropsWithChildren, useState, useMemo, useEffect, useRef } from 'react'\n+import { cn } from 'ui'\n+\n+import { AnalyticsInterval, DataPoint } from 'data/analytics/constants'\n+import {\n+  InfraMonitoringAttribute,\n+  useInfraMonitoringQuery,\n+} from 'data/analytics/infra-monitoring-query'\n+import {\n+  ProjectDailyStatsAttribute,\n+  useProjectDailyStatsQuery,\n+} from 'data/analytics/project-daily-stats-query'\n+import { Loader2 } from 'lucide-react'\n+import { useDatabaseSelectorStateSnapshot } from 'state/database-selector'\n+import { WarningIcon } from 'ui'\n+import type { ChartData } from './Charts.types'\n+import Panel from 'components/ui/Panel'\n+import { useChartHighlight } from './useChartHighlight'\n+import type { UpdateDateRange } from 'pages/project/[ref]/reports/database'\n+import ComposedChart from './ComposedChart'\n+\n+type Provider = 'infra-monitoring' | 'daily-stats'\n+\n+export type MultiAttribute = {\n+  attribute: string\n+  provider: Provider\n+  label?: string\n+  color?: string\n+  format?: 'percent' | 'number'\n+  description?: string\n+  docsLink?: string\n+  isMaxValue?: boolean\n+  type?: 'line' | 'area-bar'\n+  omitFromTotal?: boolean\n+  tooltip?: string\n+}\n+\n+interface ComposedChartHandlerProps {\n+  id?: string\n+  label: string\n+  attributes: MultiAttribute[]\n+  startDate: string\n+  endDate: string\n+  interval: string\n+  customDateFormat?: string\n+  defaultChartStyle?: 'bar' | 'line' | 'stackedAreaLine'\n+  hideChartType?: boolean\n+  data?: ChartData\n+  isLoading?: boolean\n+  format?: string\n+  highlightedValue?: string | number\n+  className?: string\n+  showTooltip?: boolean\n+  showLegend?: boolean\n+  showTotal?: boolean\n+  showMaxValue?: boolean\n+  updateDateRange: UpdateDateRange\n+  valuePrecision?: number\n+  isVisible?: boolean\n+}\n+\n+/**\n+ * Wrapper component that handles intersection observer logic for lazy loading\n+ */\n+const LazyChartWrapper = ({ children }: PropsWithChildren) => {\n+  const [isVisible, setIsVisible] = useState(false)\n+  const ref = useRef<HTMLDivElement>(null)\n+\n+  useEffect(() => {\n+    const observer = new IntersectionObserver(\n+      ([entry]) => {\n+        if (entry.isIntersecting) {\n+          setIsVisible(true)\n+          observer.disconnect()\n+        }\n+      },\n+      {\n+        rootMargin: '150px 0px', // Start loading before the component enters viewport\n+        threshold: 0,\n+      }\n+    )\n+\n+    const currentRef = ref.current\n+    if (currentRef) {\n+      observer.observe(currentRef)\n+    }\n+\n+    return () => {\n+      if (currentRef) {\n+        observer.unobserve(currentRef)\n+      }\n+    }\n+  }, [])\n+\n+  return <div ref={ref}>{React.cloneElement(children as React.ReactElement, { isVisible })}</div>\n+}\n+\n+// Create a custom hook to fetch data based on attributes\n+const useAttributeQueries = (\n+  attributes: MultiAttribute[],\n+  ref: string | string[] | undefined,\n+  startDate: string,\n+  endDate: string,\n+  interval: AnalyticsInterval,\n+  databaseIdentifier: string | undefined,\n+  data: ChartData | undefined,\n+  isVisible: boolean\n+) => {\n+  // Use individual hooks for each attribute instead of using map\n+  const results = []\n+\n+  // We need to use separate hooks for each possible attribute\n+  // This ensures hooks are called unconditionally at the top level\n+  for (let i = 0; i < attributes.length; i++) {\n+    const attr = attributes[i]\n+\n+    if (attr.provider === 'daily-stats') {\n+      // Must use hook directly, not in a conditional or loop\n+      const dailyStatsQuery = useProjectDailyStatsQuery(",
        "comment_created_at": "2025-04-11T15:22:35+00:00",
        "comment_author": "fsansalvadore",
        "comment_body": "I guess we could create a `useInfraMonitoringQueries` or something for the specific case of firing multiple queries at once?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2020572606",
    "pr_number": 34509,
    "pr_file": "apps/studio/components/ui/AIAssistantPanel/AIAssistant.tsx",
    "created_at": "2025-03-31T08:04:14+00:00",
    "commented_code": "key={message.id}\n             message={message}\n             isLoading={isChatLoading && message.id === chatMessages[chatMessages.length - 1].id}\n+            onResults={(props) => snap.updateMessage({ id: message.id, ...props })}",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2020572606",
        "repo_full_name": "supabase/supabase",
        "pr_number": 34509,
        "pr_file": "apps/studio/components/ui/AIAssistantPanel/AIAssistant.tsx",
        "discussion_id": "2020572606",
        "commented_code": "@@ -168,6 +181,7 @@ export const AIAssistant = ({ className }: AIAssistantProps) => {\n             key={message.id}\n             message={message}\n             isLoading={isChatLoading && message.id === chatMessages[chatMessages.length - 1].id}\n+            onResults={(props) => snap.updateMessage({ id: message.id, ...props })}",
        "comment_created_at": "2025-03-31T08:04:14+00:00",
        "comment_author": "alaister",
        "comment_body": "Since you're using a memoized component here, this should also be memo'd so it doesn't break the memoization – wrap it in `useCallback` :)",
        "pr_file_module": null
      }
    ]
  }
]