[
  {
    "discussion_id": "2159980386",
    "pr_number": 36567,
    "pr_file": "apps/docs/content/guides/auth/auth-hooks/before-user-created-hook.mdx",
    "created_at": "2025-06-21T08:44:20+00:00",
    "commented_code": "+---\n+id: 'before-user-created-hook'\n+title: 'Before User Created Hook'\n+subtitle: 'Prevent unwanted signups by inspecting and rejecting user creation requests'\n+---\n+\n+This hook runs before a new user is created. It allows developers to inspect the incoming user object and optionally reject the request. Use this to enforce custom signup policies that Supabase Auth does not handle natively - such as blocking disposable email domains, restricting access by region or IP, or requiring that users belong to a specific email domain.\n+\n+The hook is triggered any time a new user would be created - including traditional email signups (signUp()), OAuth flows (signIn(\\{ provider \\})), SSO (signInWithSSO()), IdP-initiated SAML flows, and anonymous sign-ins. Before the user is inserted into the auth.users table, the payload is passed to your configured hook endpoint for evaluation.\n+\n+You can implement this hook using an HTTP endpoint or a Postgres function. If the hook returns an error object, the signup is denied and the user is not created. If the hook responds successfully (HTTP 200 or 204 with no error), the request proceeds as usual. This gives you full control over which users are allowed to register — and the flexibility to apply that logic server-side.\n+\n+**Inputs**\n+\n+Supabase Auth will send a payload containing these fields to your hook:\n+\n+| Field    | Type     | Description                                                                               |\n+| -------- | -------- | ----------------------------------------------------------------------------------------- |\n+| `header` | `object` | Metadata about the request. Includes IP address, request ID, and hook type.               |\n+| `user`   | `object` | The user record that is about to be created. Matches the shape of the `auth.users` table. |\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+>\n+<TabPanel id=\"password-verification-attempt-json\" label=\"JSON\">\n+\n+```json\n+{\n+  \"header\": {\n+    \"uuid\": \"8b34dcdd-9df1-4c10-850a-b3277c653040\",\n+    \"time\": \"2025-04-29T13:13:24.755552-07:00\",\n+    \"name\": \"before-user-created\",\n+    \"ip_address\": \"127.0.0.1\",\n+  },\n+  \"user\": {\n+    \"id\": \"ff7fc9ae-3b1b-4642-9241-64adb9848a03\",\n+    \"aud\": \"authenticated\",\n+    \"role\": \"\",\n+    \"email\": \"valid.email@supabase.com\",\n+    \"phone\": \"\",\n+    \"app_metadata\": {\n+      \"provider\": \"email\",\n+      \"providers\": [\"email\"]\n+    },\n+    \"user_metadata\": {},\n+    \"identities\": [],\n+    \"created_at\": \"0001-01-01T00:00:00Z\",\n+    \"updated_at\": \"0001-01-01T00:00:00Z\",\n+    \"is_anonymous\": false\n+  }\n+}\n+```\n+\n+</TabPanel>\n+<TabPanel id=\"password-verification-attempt-json-schema\" label=\"JSON Schema\">\n+\n+```json\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"header\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"uuid\": {\n+          \"type\": \"string\",\n+          \"format\": \"uuid\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"format\": \"date-time\"\n+        },\n+        \"ip_address\": {\n+          \"type\": \"string\",\n+          \"format\": \"ipv4\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"enum\": [\"before-user-created\"]\n+        },\n+      },\n+      \"required\": [\"uuid\", \"time\", \"ip_address\", \"name\"]\n+    },\n+    \"user\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n+        \"aud\": { \"type\": \"string\" },\n+        \"role\": { \"type\": \"string\" },\n+        \"email\": { \"type\": \"string\", \"format\": \"email\" },\n+        \"phone\": { \"type\": \"string\" },\n+        \"app_metadata\": {\n+          \"type\": \"object\",\n+          \"properties\": {\n+            \"provider\": { \"type\": \"string\" },\n+            \"providers\": {\n+              \"type\": \"array\",\n+              \"items\": { \"type\": \"string\" }\n+            }\n+          },\n+          \"required\": [\"provider\", \"providers\"]\n+        },\n+        \"user_metadata\": { \"type\": \"object\" },\n+        \"identities\": {\n+          \"type\": \"array\",\n+          \"items\": { \"type\": \"object\" }\n+        },\n+        \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"is_anonymous\": { \"type\": \"boolean\" }\n+      },\n+      \"required\": [\n+        \"id\", \"aud\", \"role\", \"email\", \"phone\", \"app_metadata\",\n+        \"user_metadata\", \"identities\", \"created_at\", \"updated_at\", \"is_anonymous\"\n+      ]\n+    }\n+  },\n+  \"required\": [\"header\", \"user\"]\n+}\n+```\n+\n+</TabPanel>\n+</Tabs>\n+\n+**Outputs**\n+\n+Your hook must return a response that either allows or blocks the signup request.\n+\n+| Field    | Type      | Description                                                                                           |\n+| -------- | --------- | ----------------------------------------------------------------------------------------------------- |\n+| `error`  | `object`  | (Optional) Return this to reject the signup. Includes a code, message, and optional HTTP status code. |\n+\n+Returning an empty object with a `200` or `204` status code allows the request to proceed. Returning a JSON response with an `error` object and a `4xx` status code blocks the request and propagates the error message to the client. See the [error handling documentation](/docs/guides/auth/auth-hooks#error-handling) for more details.\n+\n+**Allow the signup**\n+\n+```json\n+{}\n+```\n+\n+or with a `204 No Content` response:\n+\n+```http\n+HTTP/1.1 204 No Content\n+```\n+\n+**Reject the signup with an error**\n+\n+```json\n+{\n+  \"error\": {\n+    \"http_code\": 400,\n+    \"message\": \"Only company emails are allowed to sign up.\"\n+  }\n+}\n+```\n+\n+This response will block the user creation and return the error message to the client that attempted signup.\n+\n+**Examples**\n+\n+Each of the following examples shows how to use the `before-user-created` hook to control signup behavior. Each use case includes both a HTTP implementation (e.g. using an Edge Function) and a SQL implementation (Postgres function).\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql\"\n+  queryGroup=\"language\"\n+>\n+\n+\n+<TabPanel id=\"sql\" label=\"SQL\">\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql-allow-by-domain\"\n+>\n+\n+\n+<TabPanel id=\"sql-allow-by-domain\" label=\"Allow by Domain\">\n+Allow signups only from specific domains like supabase.com or example.test. Reject all others. This is useful for private/internal apps, enterprise gating, or invite-only beta access.\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the email address in the `user.email` field\n+\n+```sql\n+create or replace function public.hook_enforce_email_domain(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  email text;\n+  domain text;\n+begin\n+  email := event->'user'->>'email';\n+  domain := split_part(email, '@', 2);\n+\n+  if domain not in ('supabase.com', 'example.test') then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Please sign up with a company email address.',\n+        'http_code', 400\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_enforce_email_domain\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_enforce_email_domain\n+  from authenticated, anon, public;\n+```\n+</TabPanel>\n+\n+\n+<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or CIDR\">\n+Block user signups originating from IP ranges using CIDR notation. This allows you to restrict access from entire networks (e.g. cloud provider subnets, countries, or VPN exit nodes) as well as individual IP addresses (/32).",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2159980386",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36567,
        "pr_file": "apps/docs/content/guides/auth/auth-hooks/before-user-created-hook.mdx",
        "discussion_id": "2159980386",
        "commented_code": "@@ -0,0 +1,488 @@\n+---\n+id: 'before-user-created-hook'\n+title: 'Before User Created Hook'\n+subtitle: 'Prevent unwanted signups by inspecting and rejecting user creation requests'\n+---\n+\n+This hook runs before a new user is created. It allows developers to inspect the incoming user object and optionally reject the request. Use this to enforce custom signup policies that Supabase Auth does not handle natively - such as blocking disposable email domains, restricting access by region or IP, or requiring that users belong to a specific email domain.\n+\n+The hook is triggered any time a new user would be created - including traditional email signups (signUp()), OAuth flows (signIn(\\{ provider \\})), SSO (signInWithSSO()), IdP-initiated SAML flows, and anonymous sign-ins. Before the user is inserted into the auth.users table, the payload is passed to your configured hook endpoint for evaluation.\n+\n+You can implement this hook using an HTTP endpoint or a Postgres function. If the hook returns an error object, the signup is denied and the user is not created. If the hook responds successfully (HTTP 200 or 204 with no error), the request proceeds as usual. This gives you full control over which users are allowed to register — and the flexibility to apply that logic server-side.\n+\n+**Inputs**\n+\n+Supabase Auth will send a payload containing these fields to your hook:\n+\n+| Field    | Type     | Description                                                                               |\n+| -------- | -------- | ----------------------------------------------------------------------------------------- |\n+| `header` | `object` | Metadata about the request. Includes IP address, request ID, and hook type.               |\n+| `user`   | `object` | The user record that is about to be created. Matches the shape of the `auth.users` table. |\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+>\n+<TabPanel id=\"password-verification-attempt-json\" label=\"JSON\">\n+\n+```json\n+{\n+  \"header\": {\n+    \"uuid\": \"8b34dcdd-9df1-4c10-850a-b3277c653040\",\n+    \"time\": \"2025-04-29T13:13:24.755552-07:00\",\n+    \"name\": \"before-user-created\",\n+    \"ip_address\": \"127.0.0.1\",\n+  },\n+  \"user\": {\n+    \"id\": \"ff7fc9ae-3b1b-4642-9241-64adb9848a03\",\n+    \"aud\": \"authenticated\",\n+    \"role\": \"\",\n+    \"email\": \"valid.email@supabase.com\",\n+    \"phone\": \"\",\n+    \"app_metadata\": {\n+      \"provider\": \"email\",\n+      \"providers\": [\"email\"]\n+    },\n+    \"user_metadata\": {},\n+    \"identities\": [],\n+    \"created_at\": \"0001-01-01T00:00:00Z\",\n+    \"updated_at\": \"0001-01-01T00:00:00Z\",\n+    \"is_anonymous\": false\n+  }\n+}\n+```\n+\n+</TabPanel>\n+<TabPanel id=\"password-verification-attempt-json-schema\" label=\"JSON Schema\">\n+\n+```json\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"header\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"uuid\": {\n+          \"type\": \"string\",\n+          \"format\": \"uuid\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"format\": \"date-time\"\n+        },\n+        \"ip_address\": {\n+          \"type\": \"string\",\n+          \"format\": \"ipv4\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"enum\": [\"before-user-created\"]\n+        },\n+      },\n+      \"required\": [\"uuid\", \"time\", \"ip_address\", \"name\"]\n+    },\n+    \"user\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n+        \"aud\": { \"type\": \"string\" },\n+        \"role\": { \"type\": \"string\" },\n+        \"email\": { \"type\": \"string\", \"format\": \"email\" },\n+        \"phone\": { \"type\": \"string\" },\n+        \"app_metadata\": {\n+          \"type\": \"object\",\n+          \"properties\": {\n+            \"provider\": { \"type\": \"string\" },\n+            \"providers\": {\n+              \"type\": \"array\",\n+              \"items\": { \"type\": \"string\" }\n+            }\n+          },\n+          \"required\": [\"provider\", \"providers\"]\n+        },\n+        \"user_metadata\": { \"type\": \"object\" },\n+        \"identities\": {\n+          \"type\": \"array\",\n+          \"items\": { \"type\": \"object\" }\n+        },\n+        \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"is_anonymous\": { \"type\": \"boolean\" }\n+      },\n+      \"required\": [\n+        \"id\", \"aud\", \"role\", \"email\", \"phone\", \"app_metadata\",\n+        \"user_metadata\", \"identities\", \"created_at\", \"updated_at\", \"is_anonymous\"\n+      ]\n+    }\n+  },\n+  \"required\": [\"header\", \"user\"]\n+}\n+```\n+\n+</TabPanel>\n+</Tabs>\n+\n+**Outputs**\n+\n+Your hook must return a response that either allows or blocks the signup request.\n+\n+| Field    | Type      | Description                                                                                           |\n+| -------- | --------- | ----------------------------------------------------------------------------------------------------- |\n+| `error`  | `object`  | (Optional) Return this to reject the signup. Includes a code, message, and optional HTTP status code. |\n+\n+Returning an empty object with a `200` or `204` status code allows the request to proceed. Returning a JSON response with an `error` object and a `4xx` status code blocks the request and propagates the error message to the client. See the [error handling documentation](/docs/guides/auth/auth-hooks#error-handling) for more details.\n+\n+**Allow the signup**\n+\n+```json\n+{}\n+```\n+\n+or with a `204 No Content` response:\n+\n+```http\n+HTTP/1.1 204 No Content\n+```\n+\n+**Reject the signup with an error**\n+\n+```json\n+{\n+  \"error\": {\n+    \"http_code\": 400,\n+    \"message\": \"Only company emails are allowed to sign up.\"\n+  }\n+}\n+```\n+\n+This response will block the user creation and return the error message to the client that attempted signup.\n+\n+**Examples**\n+\n+Each of the following examples shows how to use the `before-user-created` hook to control signup behavior. Each use case includes both a HTTP implementation (e.g. using an Edge Function) and a SQL implementation (Postgres function).\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql\"\n+  queryGroup=\"language\"\n+>\n+\n+\n+<TabPanel id=\"sql\" label=\"SQL\">\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql-allow-by-domain\"\n+>\n+\n+\n+<TabPanel id=\"sql-allow-by-domain\" label=\"Allow by Domain\">\n+Allow signups only from specific domains like supabase.com or example.test. Reject all others. This is useful for private/internal apps, enterprise gating, or invite-only beta access.\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the email address in the `user.email` field\n+\n+```sql\n+create or replace function public.hook_enforce_email_domain(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  email text;\n+  domain text;\n+begin\n+  email := event->'user'->>'email';\n+  domain := split_part(email, '@', 2);\n+\n+  if domain not in ('supabase.com', 'example.test') then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Please sign up with a company email address.',\n+        'http_code', 400\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_enforce_email_domain\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_enforce_email_domain\n+  from authenticated, anon, public;\n+```\n+</TabPanel>\n+\n+\n+<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or CIDR\">\n+Block user signups originating from IP ranges using CIDR notation. This allows you to restrict access from entire networks (e.g. cloud provider subnets, countries, or VPN exit nodes) as well as individual IP addresses (/32).",
        "comment_created_at": "2025-06-21T08:44:20+00:00",
        "comment_author": "hf",
        "comment_body": "```suggestion\r\n<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or range of IP\">\r\n\r\nThis example shows how you might restrict sign up from a single IP address or a range of them. [Postgres has native support](https://www.postgresql.org/docs/current/datatype-net-types.html) for [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) -- a method of representing IP address ranges.\r\n\r\nFor instance: `123.123.123.123/32` represents only a single IP address, while `123.123.123.0/24` means all IP addresses starting with `123.123.123.`.\r\n```\r\n\r\nBeing conscious that not all of our customers -- especially when vibe coding -- have been to CS school and know what CIDR / how networking works.",
        "pr_file_module": null
      },
      {
        "comment_id": "2162596510",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36567,
        "pr_file": "apps/docs/content/guides/auth/auth-hooks/before-user-created-hook.mdx",
        "discussion_id": "2159980386",
        "commented_code": "@@ -0,0 +1,488 @@\n+---\n+id: 'before-user-created-hook'\n+title: 'Before User Created Hook'\n+subtitle: 'Prevent unwanted signups by inspecting and rejecting user creation requests'\n+---\n+\n+This hook runs before a new user is created. It allows developers to inspect the incoming user object and optionally reject the request. Use this to enforce custom signup policies that Supabase Auth does not handle natively - such as blocking disposable email domains, restricting access by region or IP, or requiring that users belong to a specific email domain.\n+\n+The hook is triggered any time a new user would be created - including traditional email signups (signUp()), OAuth flows (signIn(\\{ provider \\})), SSO (signInWithSSO()), IdP-initiated SAML flows, and anonymous sign-ins. Before the user is inserted into the auth.users table, the payload is passed to your configured hook endpoint for evaluation.\n+\n+You can implement this hook using an HTTP endpoint or a Postgres function. If the hook returns an error object, the signup is denied and the user is not created. If the hook responds successfully (HTTP 200 or 204 with no error), the request proceeds as usual. This gives you full control over which users are allowed to register — and the flexibility to apply that logic server-side.\n+\n+**Inputs**\n+\n+Supabase Auth will send a payload containing these fields to your hook:\n+\n+| Field    | Type     | Description                                                                               |\n+| -------- | -------- | ----------------------------------------------------------------------------------------- |\n+| `header` | `object` | Metadata about the request. Includes IP address, request ID, and hook type.               |\n+| `user`   | `object` | The user record that is about to be created. Matches the shape of the `auth.users` table. |\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+>\n+<TabPanel id=\"password-verification-attempt-json\" label=\"JSON\">\n+\n+```json\n+{\n+  \"header\": {\n+    \"uuid\": \"8b34dcdd-9df1-4c10-850a-b3277c653040\",\n+    \"time\": \"2025-04-29T13:13:24.755552-07:00\",\n+    \"name\": \"before-user-created\",\n+    \"ip_address\": \"127.0.0.1\",\n+  },\n+  \"user\": {\n+    \"id\": \"ff7fc9ae-3b1b-4642-9241-64adb9848a03\",\n+    \"aud\": \"authenticated\",\n+    \"role\": \"\",\n+    \"email\": \"valid.email@supabase.com\",\n+    \"phone\": \"\",\n+    \"app_metadata\": {\n+      \"provider\": \"email\",\n+      \"providers\": [\"email\"]\n+    },\n+    \"user_metadata\": {},\n+    \"identities\": [],\n+    \"created_at\": \"0001-01-01T00:00:00Z\",\n+    \"updated_at\": \"0001-01-01T00:00:00Z\",\n+    \"is_anonymous\": false\n+  }\n+}\n+```\n+\n+</TabPanel>\n+<TabPanel id=\"password-verification-attempt-json-schema\" label=\"JSON Schema\">\n+\n+```json\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"header\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"uuid\": {\n+          \"type\": \"string\",\n+          \"format\": \"uuid\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"format\": \"date-time\"\n+        },\n+        \"ip_address\": {\n+          \"type\": \"string\",\n+          \"format\": \"ipv4\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"enum\": [\"before-user-created\"]\n+        },\n+      },\n+      \"required\": [\"uuid\", \"time\", \"ip_address\", \"name\"]\n+    },\n+    \"user\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n+        \"aud\": { \"type\": \"string\" },\n+        \"role\": { \"type\": \"string\" },\n+        \"email\": { \"type\": \"string\", \"format\": \"email\" },\n+        \"phone\": { \"type\": \"string\" },\n+        \"app_metadata\": {\n+          \"type\": \"object\",\n+          \"properties\": {\n+            \"provider\": { \"type\": \"string\" },\n+            \"providers\": {\n+              \"type\": \"array\",\n+              \"items\": { \"type\": \"string\" }\n+            }\n+          },\n+          \"required\": [\"provider\", \"providers\"]\n+        },\n+        \"user_metadata\": { \"type\": \"object\" },\n+        \"identities\": {\n+          \"type\": \"array\",\n+          \"items\": { \"type\": \"object\" }\n+        },\n+        \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"is_anonymous\": { \"type\": \"boolean\" }\n+      },\n+      \"required\": [\n+        \"id\", \"aud\", \"role\", \"email\", \"phone\", \"app_metadata\",\n+        \"user_metadata\", \"identities\", \"created_at\", \"updated_at\", \"is_anonymous\"\n+      ]\n+    }\n+  },\n+  \"required\": [\"header\", \"user\"]\n+}\n+```\n+\n+</TabPanel>\n+</Tabs>\n+\n+**Outputs**\n+\n+Your hook must return a response that either allows or blocks the signup request.\n+\n+| Field    | Type      | Description                                                                                           |\n+| -------- | --------- | ----------------------------------------------------------------------------------------------------- |\n+| `error`  | `object`  | (Optional) Return this to reject the signup. Includes a code, message, and optional HTTP status code. |\n+\n+Returning an empty object with a `200` or `204` status code allows the request to proceed. Returning a JSON response with an `error` object and a `4xx` status code blocks the request and propagates the error message to the client. See the [error handling documentation](/docs/guides/auth/auth-hooks#error-handling) for more details.\n+\n+**Allow the signup**\n+\n+```json\n+{}\n+```\n+\n+or with a `204 No Content` response:\n+\n+```http\n+HTTP/1.1 204 No Content\n+```\n+\n+**Reject the signup with an error**\n+\n+```json\n+{\n+  \"error\": {\n+    \"http_code\": 400,\n+    \"message\": \"Only company emails are allowed to sign up.\"\n+  }\n+}\n+```\n+\n+This response will block the user creation and return the error message to the client that attempted signup.\n+\n+**Examples**\n+\n+Each of the following examples shows how to use the `before-user-created` hook to control signup behavior. Each use case includes both a HTTP implementation (e.g. using an Edge Function) and a SQL implementation (Postgres function).\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql\"\n+  queryGroup=\"language\"\n+>\n+\n+\n+<TabPanel id=\"sql\" label=\"SQL\">\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql-allow-by-domain\"\n+>\n+\n+\n+<TabPanel id=\"sql-allow-by-domain\" label=\"Allow by Domain\">\n+Allow signups only from specific domains like supabase.com or example.test. Reject all others. This is useful for private/internal apps, enterprise gating, or invite-only beta access.\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the email address in the `user.email` field\n+\n+```sql\n+create or replace function public.hook_enforce_email_domain(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  email text;\n+  domain text;\n+begin\n+  email := event->'user'->>'email';\n+  domain := split_part(email, '@', 2);\n+\n+  if domain not in ('supabase.com', 'example.test') then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Please sign up with a company email address.',\n+        'http_code', 400\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_enforce_email_domain\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_enforce_email_domain\n+  from authenticated, anon, public;\n+```\n+</TabPanel>\n+\n+\n+<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or CIDR\">\n+Block user signups originating from IP ranges using CIDR notation. This allows you to restrict access from entire networks (e.g. cloud provider subnets, countries, or VPN exit nodes) as well as individual IP addresses (/32).",
        "comment_created_at": "2025-06-23T21:58:52+00:00",
        "comment_author": "cstockton",
        "comment_body": "Good idea, I've updated all mentions of CIDR",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159982350",
    "pr_number": 36567,
    "pr_file": "apps/docs/content/guides/auth/auth-hooks/before-user-created-hook.mdx",
    "created_at": "2025-06-21T08:55:42+00:00",
    "commented_code": "+---\n+id: 'before-user-created-hook'\n+title: 'Before User Created Hook'\n+subtitle: 'Prevent unwanted signups by inspecting and rejecting user creation requests'\n+---\n+\n+This hook runs before a new user is created. It allows developers to inspect the incoming user object and optionally reject the request. Use this to enforce custom signup policies that Supabase Auth does not handle natively - such as blocking disposable email domains, restricting access by region or IP, or requiring that users belong to a specific email domain.\n+\n+The hook is triggered any time a new user would be created - including traditional email signups (signUp()), OAuth flows (signIn(\\{ provider \\})), SSO (signInWithSSO()), IdP-initiated SAML flows, and anonymous sign-ins. Before the user is inserted into the auth.users table, the payload is passed to your configured hook endpoint for evaluation.\n+\n+You can implement this hook using an HTTP endpoint or a Postgres function. If the hook returns an error object, the signup is denied and the user is not created. If the hook responds successfully (HTTP 200 or 204 with no error), the request proceeds as usual. This gives you full control over which users are allowed to register — and the flexibility to apply that logic server-side.\n+\n+**Inputs**\n+\n+Supabase Auth will send a payload containing these fields to your hook:\n+\n+| Field    | Type     | Description                                                                               |\n+| -------- | -------- | ----------------------------------------------------------------------------------------- |\n+| `header` | `object` | Metadata about the request. Includes IP address, request ID, and hook type.               |\n+| `user`   | `object` | The user record that is about to be created. Matches the shape of the `auth.users` table. |\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+>\n+<TabPanel id=\"password-verification-attempt-json\" label=\"JSON\">\n+\n+```json\n+{\n+  \"header\": {\n+    \"uuid\": \"8b34dcdd-9df1-4c10-850a-b3277c653040\",\n+    \"time\": \"2025-04-29T13:13:24.755552-07:00\",\n+    \"name\": \"before-user-created\",\n+    \"ip_address\": \"127.0.0.1\",\n+  },\n+  \"user\": {\n+    \"id\": \"ff7fc9ae-3b1b-4642-9241-64adb9848a03\",\n+    \"aud\": \"authenticated\",\n+    \"role\": \"\",\n+    \"email\": \"valid.email@supabase.com\",\n+    \"phone\": \"\",\n+    \"app_metadata\": {\n+      \"provider\": \"email\",\n+      \"providers\": [\"email\"]\n+    },\n+    \"user_metadata\": {},\n+    \"identities\": [],\n+    \"created_at\": \"0001-01-01T00:00:00Z\",\n+    \"updated_at\": \"0001-01-01T00:00:00Z\",\n+    \"is_anonymous\": false\n+  }\n+}\n+```\n+\n+</TabPanel>\n+<TabPanel id=\"password-verification-attempt-json-schema\" label=\"JSON Schema\">\n+\n+```json\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"header\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"uuid\": {\n+          \"type\": \"string\",\n+          \"format\": \"uuid\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"format\": \"date-time\"\n+        },\n+        \"ip_address\": {\n+          \"type\": \"string\",\n+          \"format\": \"ipv4\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"enum\": [\"before-user-created\"]\n+        },\n+      },\n+      \"required\": [\"uuid\", \"time\", \"ip_address\", \"name\"]\n+    },\n+    \"user\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n+        \"aud\": { \"type\": \"string\" },\n+        \"role\": { \"type\": \"string\" },\n+        \"email\": { \"type\": \"string\", \"format\": \"email\" },\n+        \"phone\": { \"type\": \"string\" },\n+        \"app_metadata\": {\n+          \"type\": \"object\",\n+          \"properties\": {\n+            \"provider\": { \"type\": \"string\" },\n+            \"providers\": {\n+              \"type\": \"array\",\n+              \"items\": { \"type\": \"string\" }\n+            }\n+          },\n+          \"required\": [\"provider\", \"providers\"]\n+        },\n+        \"user_metadata\": { \"type\": \"object\" },\n+        \"identities\": {\n+          \"type\": \"array\",\n+          \"items\": { \"type\": \"object\" }\n+        },\n+        \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"is_anonymous\": { \"type\": \"boolean\" }\n+      },\n+      \"required\": [\n+        \"id\", \"aud\", \"role\", \"email\", \"phone\", \"app_metadata\",\n+        \"user_metadata\", \"identities\", \"created_at\", \"updated_at\", \"is_anonymous\"\n+      ]\n+    }\n+  },\n+  \"required\": [\"header\", \"user\"]\n+}\n+```\n+\n+</TabPanel>\n+</Tabs>\n+\n+**Outputs**\n+\n+Your hook must return a response that either allows or blocks the signup request.\n+\n+| Field    | Type      | Description                                                                                           |\n+| -------- | --------- | ----------------------------------------------------------------------------------------------------- |\n+| `error`  | `object`  | (Optional) Return this to reject the signup. Includes a code, message, and optional HTTP status code. |\n+\n+Returning an empty object with a `200` or `204` status code allows the request to proceed. Returning a JSON response with an `error` object and a `4xx` status code blocks the request and propagates the error message to the client. See the [error handling documentation](/docs/guides/auth/auth-hooks#error-handling) for more details.\n+\n+**Allow the signup**\n+\n+```json\n+{}\n+```\n+\n+or with a `204 No Content` response:\n+\n+```http\n+HTTP/1.1 204 No Content\n+```\n+\n+**Reject the signup with an error**\n+\n+```json\n+{\n+  \"error\": {\n+    \"http_code\": 400,\n+    \"message\": \"Only company emails are allowed to sign up.\"\n+  }\n+}\n+```\n+\n+This response will block the user creation and return the error message to the client that attempted signup.\n+\n+**Examples**\n+\n+Each of the following examples shows how to use the `before-user-created` hook to control signup behavior. Each use case includes both a HTTP implementation (e.g. using an Edge Function) and a SQL implementation (Postgres function).\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql\"\n+  queryGroup=\"language\"\n+>\n+\n+\n+<TabPanel id=\"sql\" label=\"SQL\">\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql-allow-by-domain\"\n+>\n+\n+\n+<TabPanel id=\"sql-allow-by-domain\" label=\"Allow by Domain\">\n+Allow signups only from specific domains like supabase.com or example.test. Reject all others. This is useful for private/internal apps, enterprise gating, or invite-only beta access.\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the email address in the `user.email` field\n+\n+```sql\n+create or replace function public.hook_enforce_email_domain(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  email text;\n+  domain text;\n+begin\n+  email := event->'user'->>'email';\n+  domain := split_part(email, '@', 2);\n+\n+  if domain not in ('supabase.com', 'example.test') then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Please sign up with a company email address.',\n+        'http_code', 400\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_enforce_email_domain\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_enforce_email_domain\n+  from authenticated, anon, public;\n+```\n+</TabPanel>\n+\n+\n+<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or CIDR\">\n+Block user signups originating from IP ranges using CIDR notation. This allows you to restrict access from entire networks (e.g. cloud provider subnets, countries, or VPN exit nodes) as well as individual IP addresses (/32).\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the ip address in the `header.ip_address` field\n+\n+This example uses PostgreSQL’s built-in `inet` and `<<` CIDR operators:\n+```sql\n+create or replace function public.hook_block_signup_by_cidr(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  ip inet;\n+begin\n+  ip := event->'header'->>'ip_address';\n+\n+  if ip::inet << '192.168.0.0/16'::cidr\n+     or ip::inet << '10.0.0.0/8'::cidr\n+     or ip::inet << '172.168.1.100/24'::cidr\n+     or ip::inet << '172.168.1.210/32'::cidr then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Signups are not allowed from your network.',\n+        'http_code', 403\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_block_signup_by_cidr\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_block_signup_by_cidr\n+  from authenticated, anon, public;\n+```",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2159982350",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36567,
        "pr_file": "apps/docs/content/guides/auth/auth-hooks/before-user-created-hook.mdx",
        "discussion_id": "2159982350",
        "commented_code": "@@ -0,0 +1,488 @@\n+---\n+id: 'before-user-created-hook'\n+title: 'Before User Created Hook'\n+subtitle: 'Prevent unwanted signups by inspecting and rejecting user creation requests'\n+---\n+\n+This hook runs before a new user is created. It allows developers to inspect the incoming user object and optionally reject the request. Use this to enforce custom signup policies that Supabase Auth does not handle natively - such as blocking disposable email domains, restricting access by region or IP, or requiring that users belong to a specific email domain.\n+\n+The hook is triggered any time a new user would be created - including traditional email signups (signUp()), OAuth flows (signIn(\\{ provider \\})), SSO (signInWithSSO()), IdP-initiated SAML flows, and anonymous sign-ins. Before the user is inserted into the auth.users table, the payload is passed to your configured hook endpoint for evaluation.\n+\n+You can implement this hook using an HTTP endpoint or a Postgres function. If the hook returns an error object, the signup is denied and the user is not created. If the hook responds successfully (HTTP 200 or 204 with no error), the request proceeds as usual. This gives you full control over which users are allowed to register — and the flexibility to apply that logic server-side.\n+\n+**Inputs**\n+\n+Supabase Auth will send a payload containing these fields to your hook:\n+\n+| Field    | Type     | Description                                                                               |\n+| -------- | -------- | ----------------------------------------------------------------------------------------- |\n+| `header` | `object` | Metadata about the request. Includes IP address, request ID, and hook type.               |\n+| `user`   | `object` | The user record that is about to be created. Matches the shape of the `auth.users` table. |\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+>\n+<TabPanel id=\"password-verification-attempt-json\" label=\"JSON\">\n+\n+```json\n+{\n+  \"header\": {\n+    \"uuid\": \"8b34dcdd-9df1-4c10-850a-b3277c653040\",\n+    \"time\": \"2025-04-29T13:13:24.755552-07:00\",\n+    \"name\": \"before-user-created\",\n+    \"ip_address\": \"127.0.0.1\",\n+  },\n+  \"user\": {\n+    \"id\": \"ff7fc9ae-3b1b-4642-9241-64adb9848a03\",\n+    \"aud\": \"authenticated\",\n+    \"role\": \"\",\n+    \"email\": \"valid.email@supabase.com\",\n+    \"phone\": \"\",\n+    \"app_metadata\": {\n+      \"provider\": \"email\",\n+      \"providers\": [\"email\"]\n+    },\n+    \"user_metadata\": {},\n+    \"identities\": [],\n+    \"created_at\": \"0001-01-01T00:00:00Z\",\n+    \"updated_at\": \"0001-01-01T00:00:00Z\",\n+    \"is_anonymous\": false\n+  }\n+}\n+```\n+\n+</TabPanel>\n+<TabPanel id=\"password-verification-attempt-json-schema\" label=\"JSON Schema\">\n+\n+```json\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"header\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"uuid\": {\n+          \"type\": \"string\",\n+          \"format\": \"uuid\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"format\": \"date-time\"\n+        },\n+        \"ip_address\": {\n+          \"type\": \"string\",\n+          \"format\": \"ipv4\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"enum\": [\"before-user-created\"]\n+        },\n+      },\n+      \"required\": [\"uuid\", \"time\", \"ip_address\", \"name\"]\n+    },\n+    \"user\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n+        \"aud\": { \"type\": \"string\" },\n+        \"role\": { \"type\": \"string\" },\n+        \"email\": { \"type\": \"string\", \"format\": \"email\" },\n+        \"phone\": { \"type\": \"string\" },\n+        \"app_metadata\": {\n+          \"type\": \"object\",\n+          \"properties\": {\n+            \"provider\": { \"type\": \"string\" },\n+            \"providers\": {\n+              \"type\": \"array\",\n+              \"items\": { \"type\": \"string\" }\n+            }\n+          },\n+          \"required\": [\"provider\", \"providers\"]\n+        },\n+        \"user_metadata\": { \"type\": \"object\" },\n+        \"identities\": {\n+          \"type\": \"array\",\n+          \"items\": { \"type\": \"object\" }\n+        },\n+        \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"is_anonymous\": { \"type\": \"boolean\" }\n+      },\n+      \"required\": [\n+        \"id\", \"aud\", \"role\", \"email\", \"phone\", \"app_metadata\",\n+        \"user_metadata\", \"identities\", \"created_at\", \"updated_at\", \"is_anonymous\"\n+      ]\n+    }\n+  },\n+  \"required\": [\"header\", \"user\"]\n+}\n+```\n+\n+</TabPanel>\n+</Tabs>\n+\n+**Outputs**\n+\n+Your hook must return a response that either allows or blocks the signup request.\n+\n+| Field    | Type      | Description                                                                                           |\n+| -------- | --------- | ----------------------------------------------------------------------------------------------------- |\n+| `error`  | `object`  | (Optional) Return this to reject the signup. Includes a code, message, and optional HTTP status code. |\n+\n+Returning an empty object with a `200` or `204` status code allows the request to proceed. Returning a JSON response with an `error` object and a `4xx` status code blocks the request and propagates the error message to the client. See the [error handling documentation](/docs/guides/auth/auth-hooks#error-handling) for more details.\n+\n+**Allow the signup**\n+\n+```json\n+{}\n+```\n+\n+or with a `204 No Content` response:\n+\n+```http\n+HTTP/1.1 204 No Content\n+```\n+\n+**Reject the signup with an error**\n+\n+```json\n+{\n+  \"error\": {\n+    \"http_code\": 400,\n+    \"message\": \"Only company emails are allowed to sign up.\"\n+  }\n+}\n+```\n+\n+This response will block the user creation and return the error message to the client that attempted signup.\n+\n+**Examples**\n+\n+Each of the following examples shows how to use the `before-user-created` hook to control signup behavior. Each use case includes both a HTTP implementation (e.g. using an Edge Function) and a SQL implementation (Postgres function).\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql\"\n+  queryGroup=\"language\"\n+>\n+\n+\n+<TabPanel id=\"sql\" label=\"SQL\">\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql-allow-by-domain\"\n+>\n+\n+\n+<TabPanel id=\"sql-allow-by-domain\" label=\"Allow by Domain\">\n+Allow signups only from specific domains like supabase.com or example.test. Reject all others. This is useful for private/internal apps, enterprise gating, or invite-only beta access.\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the email address in the `user.email` field\n+\n+```sql\n+create or replace function public.hook_enforce_email_domain(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  email text;\n+  domain text;\n+begin\n+  email := event->'user'->>'email';\n+  domain := split_part(email, '@', 2);\n+\n+  if domain not in ('supabase.com', 'example.test') then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Please sign up with a company email address.',\n+        'http_code', 400\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_enforce_email_domain\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_enforce_email_domain\n+  from authenticated, anon, public;\n+```\n+</TabPanel>\n+\n+\n+<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or CIDR\">\n+Block user signups originating from IP ranges using CIDR notation. This allows you to restrict access from entire networks (e.g. cloud provider subnets, countries, or VPN exit nodes) as well as individual IP addresses (/32).\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the ip address in the `header.ip_address` field\n+\n+This example uses PostgreSQL’s built-in `inet` and `<<` CIDR operators:\n+```sql\n+create or replace function public.hook_block_signup_by_cidr(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  ip inet;\n+begin\n+  ip := event->'header'->>'ip_address';\n+\n+  if ip::inet << '192.168.0.0/16'::cidr\n+     or ip::inet << '10.0.0.0/8'::cidr\n+     or ip::inet << '172.168.1.100/24'::cidr\n+     or ip::inet << '172.168.1.210/32'::cidr then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Signups are not allowed from your network.',\n+        'http_code', 403\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_block_signup_by_cidr\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_block_signup_by_cidr\n+  from authenticated, anon, public;\n+```",
        "comment_created_at": "2025-06-21T08:55:42+00:00",
        "comment_author": "hf",
        "comment_body": "Could we make this example more practical by framing it differently, something that'll give customers direct value?\r\n\r\nSuggestion:\r\n\r\n- Provide them with a table structure `create table private.auth_ip_blocklist (blocked_range cidr, created_at timestamp)` \r\n- Change the example to use the table instead\r\n- Instruct them to add / remove from the table instead of changing the function constantly\r\n\r\nThis example should also prime LLMs to better answer questions about blocking IP addresses.",
        "pr_file_module": null
      },
      {
        "comment_id": "2180812656",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36567,
        "pr_file": "apps/docs/content/guides/auth/auth-hooks/before-user-created-hook.mdx",
        "discussion_id": "2159982350",
        "commented_code": "@@ -0,0 +1,488 @@\n+---\n+id: 'before-user-created-hook'\n+title: 'Before User Created Hook'\n+subtitle: 'Prevent unwanted signups by inspecting and rejecting user creation requests'\n+---\n+\n+This hook runs before a new user is created. It allows developers to inspect the incoming user object and optionally reject the request. Use this to enforce custom signup policies that Supabase Auth does not handle natively - such as blocking disposable email domains, restricting access by region or IP, or requiring that users belong to a specific email domain.\n+\n+The hook is triggered any time a new user would be created - including traditional email signups (signUp()), OAuth flows (signIn(\\{ provider \\})), SSO (signInWithSSO()), IdP-initiated SAML flows, and anonymous sign-ins. Before the user is inserted into the auth.users table, the payload is passed to your configured hook endpoint for evaluation.\n+\n+You can implement this hook using an HTTP endpoint or a Postgres function. If the hook returns an error object, the signup is denied and the user is not created. If the hook responds successfully (HTTP 200 or 204 with no error), the request proceeds as usual. This gives you full control over which users are allowed to register — and the flexibility to apply that logic server-side.\n+\n+**Inputs**\n+\n+Supabase Auth will send a payload containing these fields to your hook:\n+\n+| Field    | Type     | Description                                                                               |\n+| -------- | -------- | ----------------------------------------------------------------------------------------- |\n+| `header` | `object` | Metadata about the request. Includes IP address, request ID, and hook type.               |\n+| `user`   | `object` | The user record that is about to be created. Matches the shape of the `auth.users` table. |\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+>\n+<TabPanel id=\"password-verification-attempt-json\" label=\"JSON\">\n+\n+```json\n+{\n+  \"header\": {\n+    \"uuid\": \"8b34dcdd-9df1-4c10-850a-b3277c653040\",\n+    \"time\": \"2025-04-29T13:13:24.755552-07:00\",\n+    \"name\": \"before-user-created\",\n+    \"ip_address\": \"127.0.0.1\",\n+  },\n+  \"user\": {\n+    \"id\": \"ff7fc9ae-3b1b-4642-9241-64adb9848a03\",\n+    \"aud\": \"authenticated\",\n+    \"role\": \"\",\n+    \"email\": \"valid.email@supabase.com\",\n+    \"phone\": \"\",\n+    \"app_metadata\": {\n+      \"provider\": \"email\",\n+      \"providers\": [\"email\"]\n+    },\n+    \"user_metadata\": {},\n+    \"identities\": [],\n+    \"created_at\": \"0001-01-01T00:00:00Z\",\n+    \"updated_at\": \"0001-01-01T00:00:00Z\",\n+    \"is_anonymous\": false\n+  }\n+}\n+```\n+\n+</TabPanel>\n+<TabPanel id=\"password-verification-attempt-json-schema\" label=\"JSON Schema\">\n+\n+```json\n+{\n+  \"type\": \"object\",\n+  \"properties\": {\n+    \"header\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"uuid\": {\n+          \"type\": \"string\",\n+          \"format\": \"uuid\"\n+        },\n+        \"time\": {\n+          \"type\": \"string\",\n+          \"format\": \"date-time\"\n+        },\n+        \"ip_address\": {\n+          \"type\": \"string\",\n+          \"format\": \"ipv4\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"enum\": [\"before-user-created\"]\n+        },\n+      },\n+      \"required\": [\"uuid\", \"time\", \"ip_address\", \"name\"]\n+    },\n+    \"user\": {\n+      \"type\": \"object\",\n+      \"properties\": {\n+        \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n+        \"aud\": { \"type\": \"string\" },\n+        \"role\": { \"type\": \"string\" },\n+        \"email\": { \"type\": \"string\", \"format\": \"email\" },\n+        \"phone\": { \"type\": \"string\" },\n+        \"app_metadata\": {\n+          \"type\": \"object\",\n+          \"properties\": {\n+            \"provider\": { \"type\": \"string\" },\n+            \"providers\": {\n+              \"type\": \"array\",\n+              \"items\": { \"type\": \"string\" }\n+            }\n+          },\n+          \"required\": [\"provider\", \"providers\"]\n+        },\n+        \"user_metadata\": { \"type\": \"object\" },\n+        \"identities\": {\n+          \"type\": \"array\",\n+          \"items\": { \"type\": \"object\" }\n+        },\n+        \"created_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"updated_at\": { \"type\": \"string\", \"format\": \"date-time\" },\n+        \"is_anonymous\": { \"type\": \"boolean\" }\n+      },\n+      \"required\": [\n+        \"id\", \"aud\", \"role\", \"email\", \"phone\", \"app_metadata\",\n+        \"user_metadata\", \"identities\", \"created_at\", \"updated_at\", \"is_anonymous\"\n+      ]\n+    }\n+  },\n+  \"required\": [\"header\", \"user\"]\n+}\n+```\n+\n+</TabPanel>\n+</Tabs>\n+\n+**Outputs**\n+\n+Your hook must return a response that either allows or blocks the signup request.\n+\n+| Field    | Type      | Description                                                                                           |\n+| -------- | --------- | ----------------------------------------------------------------------------------------------------- |\n+| `error`  | `object`  | (Optional) Return this to reject the signup. Includes a code, message, and optional HTTP status code. |\n+\n+Returning an empty object with a `200` or `204` status code allows the request to proceed. Returning a JSON response with an `error` object and a `4xx` status code blocks the request and propagates the error message to the client. See the [error handling documentation](/docs/guides/auth/auth-hooks#error-handling) for more details.\n+\n+**Allow the signup**\n+\n+```json\n+{}\n+```\n+\n+or with a `204 No Content` response:\n+\n+```http\n+HTTP/1.1 204 No Content\n+```\n+\n+**Reject the signup with an error**\n+\n+```json\n+{\n+  \"error\": {\n+    \"http_code\": 400,\n+    \"message\": \"Only company emails are allowed to sign up.\"\n+  }\n+}\n+```\n+\n+This response will block the user creation and return the error message to the client that attempted signup.\n+\n+**Examples**\n+\n+Each of the following examples shows how to use the `before-user-created` hook to control signup behavior. Each use case includes both a HTTP implementation (e.g. using an Edge Function) and a SQL implementation (Postgres function).\n+\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql\"\n+  queryGroup=\"language\"\n+>\n+\n+\n+<TabPanel id=\"sql\" label=\"SQL\">\n+<Tabs\n+  scrollable\n+  size=\"small\"\n+  type=\"underlined\"\n+  defaultActiveId=\"sql-allow-by-domain\"\n+>\n+\n+\n+<TabPanel id=\"sql-allow-by-domain\" label=\"Allow by Domain\">\n+Allow signups only from specific domains like supabase.com or example.test. Reject all others. This is useful for private/internal apps, enterprise gating, or invite-only beta access.\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the email address in the `user.email` field\n+\n+```sql\n+create or replace function public.hook_enforce_email_domain(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  email text;\n+  domain text;\n+begin\n+  email := event->'user'->>'email';\n+  domain := split_part(email, '@', 2);\n+\n+  if domain not in ('supabase.com', 'example.test') then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Please sign up with a company email address.',\n+        'http_code', 400\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_enforce_email_domain\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_enforce_email_domain\n+  from authenticated, anon, public;\n+```\n+</TabPanel>\n+\n+\n+<TabPanel id=\"sql-block-by-cidr\" label=\"Block by IP or CIDR\">\n+Block user signups originating from IP ranges using CIDR notation. This allows you to restrict access from entire networks (e.g. cloud provider subnets, countries, or VPN exit nodes) as well as individual IP addresses (/32).\n+\n+The `before-user-created` hook solves this by:\n+* Detecting that a user is about to be created\n+* Providing the ip address in the `header.ip_address` field\n+\n+This example uses PostgreSQL’s built-in `inet` and `<<` CIDR operators:\n+```sql\n+create or replace function public.hook_block_signup_by_cidr(event jsonb)\n+returns jsonb\n+language plpgsql\n+as $$\n+declare\n+  ip inet;\n+begin\n+  ip := event->'header'->>'ip_address';\n+\n+  if ip::inet << '192.168.0.0/16'::cidr\n+     or ip::inet << '10.0.0.0/8'::cidr\n+     or ip::inet << '172.168.1.100/24'::cidr\n+     or ip::inet << '172.168.1.210/32'::cidr then\n+    return jsonb_build_object(\n+      'error', jsonb_build_object(\n+        'message', 'Signups are not allowed from your network.',\n+        'http_code', 403\n+      )\n+    );\n+  end if;\n+\n+  return '{}'::jsonb;\n+end;\n+$$;\n+\n+grant execute\n+  on function public.hook_block_signup_by_cidr\n+  to supabase_auth_admin;\n+\n+revoke execute\n+  on function public.hook_block_signup_by_cidr\n+  from authenticated, anon, public;\n+```",
        "comment_created_at": "2025-07-02T19:20:44+00:00",
        "comment_author": "cstockton",
        "comment_body": "I've updated it as suggested",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2104687122",
    "pr_number": 35856,
    "pr_file": "apps/docs/content/guides/realtime/subscribing-to-database-changes.mdx",
    "created_at": "2025-05-23T14:12:19+00:00",
    "commented_code": "## Using Broadcast\n \n-To automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger.\n+To automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger. This function will use a private channel and needs broadcast authorization RLS policies met.",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2104687122",
        "repo_full_name": "supabase/supabase",
        "pr_number": 35856,
        "pr_file": "apps/docs/content/guides/realtime/subscribing-to-database-changes.mdx",
        "discussion_id": "2104687122",
        "commented_code": "@@ -13,7 +13,7 @@ You can use Supabase to subscribe to real-time database changes. There are two o\n \n ## Using Broadcast\n \n-To automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger.\n+To automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger. This function will use a private channel and needs broadcast authorization RLS policies met.",
        "comment_created_at": "2025-05-23T14:12:19+00:00",
        "comment_author": "charislam",
        "comment_body": "```suggestion\r\nTo automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger. This function will use a private channel and needs broadcast authorization RLS policies to be met.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2013479044",
    "pr_number": 34393,
    "pr_file": "apps/docs/content/guides/realtime/subscribing-to-database-changes.mdx",
    "created_at": "2025-03-26T06:37:11+00:00",
    "commented_code": "---\n id: 'subscribing-to-database-changes'\n title: 'Subscribing to Database Changes'\n+subtitle: 'Listen to database changes in real-time from your website or application.'\n description: 'Listen to database changes in real-time from your website or application.'\n sidebar_label: 'Videos'\n ---\n \n-Supabase allows you to subscribe to real-time changes on your database from your client application.\n+You can use Supabase to subscribe to real-time database changes. There are two options available:\n \n-You can listen to database changes using the [Postgres Changes](/docs/guides/realtime/postgres-changes) extension.\n-The following video shows how you can enable this feature for your tables.\n+1. [Broadcast](/docs/guides/realtime/broadcast). This is the recommended method for scalability and security.\n+1. [Postgres Changes](/docs/guides/realtime/postgres-changes). This is a simpler method that requires no setup on your part, although generally less-scalable.\n \n-## Demo\n+## Using Broadcast\n+\n+To automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger.\n+\n+### Broadcast Authorization\n+\n+[Realtime Authorization](/docs/guides/realtime/authorization) is required for receiving Broadcast messages. This is an example of a policy that allows authenticated users to listen to messages from topics:\n+\n+{/* prettier-ignore */}\n+```sql\n+create policy \"Authenticated users can receive broadcasts\"\n+on \"realtime\".\"messages\"\n+for select\n+to authenticated\n+using ( true );\n+```\n+\n+### Create a trigger function\n+\n+Let's create a function that we can call any time a record is created, updated, or deleted. This function will make use of some of Postgres's native [trigger variables](https://www.postgresql.org/docs/current/plpgsql-trigger.html#PLPGSQL-DML-TRIGGER). For this example, we want to have a topic with the name `topic:<record id>` to which we're going to broadcast events.\n+\n+{/* prettier-ignore */}\n+```sql\n+create or replace public.your_table_changes() \n+returns trigger \n+language plpgsql\n+as $$\n+begin\n+  perform realtime.broadcast_changes(\n+    'topic:' || NEW.id::text, -- topic - the topic to which we're broadcasting\n+    TG_OP,                    -- event - the event that triggered the function\n+    TG_OP,                    -- operation - the operation that triggered the function\n+    TG_TABLE_NAME,            -- table - the table that caused the trigger\n+    TG_TABLE_SCHEMA,          -- schema - the schema of the table that caused the trigger\n+    NEW,                      -- new record - the record after the change\n+    OLD                       -- old record - the record before the change\n+  );\n+  return null;\n+end;\n+$$;\n+```\n+\n+### Create a trigger\n+\n+Let's set up a trigger so the function is executed after any changes to the table.\n+\n+{/* prettier-ignore */}\n+```sql\n+create trigger handle_your_table_changes\n+after insert or update or delete \n+on public.your_table\n+for each row\n+execute function your_table_changes ();\n+```\n+\n+#### Listening on client side\n+\n+Finally, client side will requires to be set up to listen to the topic `topic:<record id>` to receive the events. Do not forget that you will need `private` set to true in this scenario as we are using `realtime.broadcast_changes` to send the messages.",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2013479044",
        "repo_full_name": "supabase/supabase",
        "pr_number": 34393,
        "pr_file": "apps/docs/content/guides/realtime/subscribing-to-database-changes.mdx",
        "discussion_id": "2013479044",
        "commented_code": "@@ -1,27 +1,101 @@\n ---\n id: 'subscribing-to-database-changes'\n title: 'Subscribing to Database Changes'\n+subtitle: 'Listen to database changes in real-time from your website or application.'\n description: 'Listen to database changes in real-time from your website or application.'\n sidebar_label: 'Videos'\n ---\n \n-Supabase allows you to subscribe to real-time changes on your database from your client application.\n+You can use Supabase to subscribe to real-time database changes. There are two options available:\n \n-You can listen to database changes using the [Postgres Changes](/docs/guides/realtime/postgres-changes) extension.\n-The following video shows how you can enable this feature for your tables.\n+1. [Broadcast](/docs/guides/realtime/broadcast). This is the recommended method for scalability and security.\n+1. [Postgres Changes](/docs/guides/realtime/postgres-changes). This is a simpler method that requires no setup on your part, although generally less-scalable.\n \n-## Demo\n+## Using Broadcast\n+\n+To automatically send messages when a record is created, updated, or deleted, we can attach a [Postgres trigger](/docs/guides/database/postgres/triggers) to any table. Supabase Realtime provides a `realtime.broadcast_changes()` function which we can use in conjunction with a trigger.\n+\n+### Broadcast Authorization\n+\n+[Realtime Authorization](/docs/guides/realtime/authorization) is required for receiving Broadcast messages. This is an example of a policy that allows authenticated users to listen to messages from topics:\n+\n+{/* prettier-ignore */}\n+```sql\n+create policy \"Authenticated users can receive broadcasts\"\n+on \"realtime\".\"messages\"\n+for select\n+to authenticated\n+using ( true );\n+```\n+\n+### Create a trigger function\n+\n+Let's create a function that we can call any time a record is created, updated, or deleted. This function will make use of some of Postgres's native [trigger variables](https://www.postgresql.org/docs/current/plpgsql-trigger.html#PLPGSQL-DML-TRIGGER). For this example, we want to have a topic with the name `topic:<record id>` to which we're going to broadcast events.\n+\n+{/* prettier-ignore */}\n+```sql\n+create or replace public.your_table_changes() \n+returns trigger \n+language plpgsql\n+as $$\n+begin\n+  perform realtime.broadcast_changes(\n+    'topic:' || NEW.id::text, -- topic - the topic to which we're broadcasting\n+    TG_OP,                    -- event - the event that triggered the function\n+    TG_OP,                    -- operation - the operation that triggered the function\n+    TG_TABLE_NAME,            -- table - the table that caused the trigger\n+    TG_TABLE_SCHEMA,          -- schema - the schema of the table that caused the trigger\n+    NEW,                      -- new record - the record after the change\n+    OLD                       -- old record - the record before the change\n+  );\n+  return null;\n+end;\n+$$;\n+```\n+\n+### Create a trigger\n+\n+Let's set up a trigger so the function is executed after any changes to the table.\n+\n+{/* prettier-ignore */}\n+```sql\n+create trigger handle_your_table_changes\n+after insert or update or delete \n+on public.your_table\n+for each row\n+execute function your_table_changes ();\n+```\n+\n+#### Listening on client side\n+\n+Finally, client side will requires to be set up to listen to the topic `topic:<record id>` to receive the events. Do not forget that you will need `private` set to true in this scenario as we are using `realtime.broadcast_changes` to send the messages.",
        "comment_created_at": "2025-03-26T06:37:11+00:00",
        "comment_author": "charislam",
        "comment_body": "```suggestion\r\nFinally, on the client side, listen to the topic `topic:<record_id>` to receive the events. Remember to set the channel as a private channel, since `realtime.broadcast_changes` uses Realtime Authorization.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]