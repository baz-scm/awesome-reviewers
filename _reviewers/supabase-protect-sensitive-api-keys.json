[
  {
    "discussion_id": "2182919943",
    "pr_number": 36798,
    "pr_file": "apps/docs/content/guides/functions/storage-caching.mdx",
    "created_at": "2025-07-03T14:19:29+00:00",
    "commented_code": "---\n id: 'storage-caching'\n title: 'Integrating with Supabase Storage'\n-description: 'Integrate Edge Functions with Supabase Storage to cache images on the Edge (CDN).'\n-video: 'https://www.youtube.com/v/wW6L52v9Ldo'\n+description: 'Integrate Edge Functions with Supabase Storage.'\n+tocVideo: 'wW6L52v9Ldo'\n ---\n \n-<div class=\"video-container\">\n-  <iframe\n-    src=\"https://www.youtube-nocookie.com/embed/wW6L52v9Ldo\"\n-    frameBorder=\"1\"\n-    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n-    allowFullScreen\n-  ></iframe>\n-</div>\n+Edge Functions work seamlessly with [Supabase Storage](/docs/guides/storage). This allows you to:\n \n-Integrate Edge Functions with Supabase Storage to cache images on the Edge (CDN). [View on GitHub](https://github.com/supabase/supabase/tree/master/examples/edge-functions/supabase/functions/og-image-with-storage-cdn).\n+- Upload generated content directly from your functions\n+- Implement cache-first patterns for better performance\n+- Serve files with built-in CDN capabilities\n+\n+---\n+\n+## Basic file operations\n+\n+Use the Supabase client to upload files directly from your Edge Functions. You'll need the service role key for server-side storage operations:\n+\n+```typescript\n+import { createClient } from 'npm:@supabase/supabase-js@2'\n+\n+Deno.serve(async (req) => {\n+  const supabaseAdmin = createClient(\n+    Deno.env.get('SUPABASE_URL') ?? '',\n+    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n+  )\n+\n+  // Generate your content\n+  const fileContent = await generateImage()\n+\n+  // Upload to storage\n+  const { data, error } = await supabaseAdmin.storage\n+    .from('images')\n+    .upload(`generated/${filename}.png`, fileContent.body!, {\n+      contentType: 'image/png',\n+      cacheControl: '3600',\n+      upsert: false,\n+    })\n+\n+  if (error) {\n+    throw error\n+  }\n+\n+  return new Response(JSON.stringify({ path: data.path }))\n+})\n+```\n+\n+<Admonition type=\"caution\">\n+  Always use the `SUPABASE_SERVICE_ROLE_KEY` for server-side operations. Never expose this key in\n+  client-side code!\n+</Admonition>",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2182919943",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36798,
        "pr_file": "apps/docs/content/guides/functions/storage-caching.mdx",
        "discussion_id": "2182919943",
        "commented_code": "@@ -1,17 +1,108 @@\n ---\n id: 'storage-caching'\n title: 'Integrating with Supabase Storage'\n-description: 'Integrate Edge Functions with Supabase Storage to cache images on the Edge (CDN).'\n-video: 'https://www.youtube.com/v/wW6L52v9Ldo'\n+description: 'Integrate Edge Functions with Supabase Storage.'\n+tocVideo: 'wW6L52v9Ldo'\n ---\n \n-<div class=\"video-container\">\n-  <iframe\n-    src=\"https://www.youtube-nocookie.com/embed/wW6L52v9Ldo\"\n-    frameBorder=\"1\"\n-    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n-    allowFullScreen\n-  ></iframe>\n-</div>\n+Edge Functions work seamlessly with [Supabase Storage](/docs/guides/storage). This allows you to:\n \n-Integrate Edge Functions with Supabase Storage to cache images on the Edge (CDN). [View on GitHub](https://github.com/supabase/supabase/tree/master/examples/edge-functions/supabase/functions/og-image-with-storage-cdn).\n+- Upload generated content directly from your functions\n+- Implement cache-first patterns for better performance\n+- Serve files with built-in CDN capabilities\n+\n+---\n+\n+## Basic file operations\n+\n+Use the Supabase client to upload files directly from your Edge Functions. You'll need the service role key for server-side storage operations:\n+\n+```typescript\n+import { createClient } from 'npm:@supabase/supabase-js@2'\n+\n+Deno.serve(async (req) => {\n+  const supabaseAdmin = createClient(\n+    Deno.env.get('SUPABASE_URL') ?? '',\n+    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n+  )\n+\n+  // Generate your content\n+  const fileContent = await generateImage()\n+\n+  // Upload to storage\n+  const { data, error } = await supabaseAdmin.storage\n+    .from('images')\n+    .upload(`generated/${filename}.png`, fileContent.body!, {\n+      contentType: 'image/png',\n+      cacheControl: '3600',\n+      upsert: false,\n+    })\n+\n+  if (error) {\n+    throw error\n+  }\n+\n+  return new Response(JSON.stringify({ path: data.path }))\n+})\n+```\n+\n+<Admonition type=\"caution\">\n+  Always use the `SUPABASE_SERVICE_ROLE_KEY` for server-side operations. Never expose this key in\n+  client-side code!\n+</Admonition>",
        "comment_created_at": "2025-07-03T14:19:29+00:00",
        "comment_author": "charislam",
        "comment_body": "```suggestion\n<Admonition type=\"caution\">\n\nAlways use the `SUPABASE_SERVICE_ROLE_KEY` for server-side operations. Never expose this key in client-side code!\n\n</Admonition>\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142963649",
    "pr_number": 36331,
    "pr_file": "apps/docs/content/guides/api/api-keys.mdx",
    "created_at": "2025-06-12T14:43:47+00:00",
    "commented_code": "---\n id: 'api-keys'\n-title: 'Understanding API Keys'\n-description: 'Securing your Data API with Postgres Row Level Security.'\n+title: 'Understanding API keys'\n+description: \"First-layer protection for your project's data\"\n ---\n \n-Supabase provides two default keys when you create a project: an `anon` key, and a `service_role` key. You can find both keys in the [API Settings](https://supabase.com/dashboard/project/_/settings/api).\n+Supabase gives you fine-grained control over which application components are allowed to access your project through API keys.\n \n-The data APIs are designed to work with Postgres Row Level Security (RLS). These keys both map to Postgres roles. You can find an `anon` user and a `service_role` user in the [Roles](http://supabase.com/dashboard/project/_/database/roles) section of the dashboard.\n+API keys provide the first layer of authentication for data access. Auth then builds upon that. This chart covers the differences:\n \n-The keys are both long-lived JWTs. If you decode these keys, you will see that they contain the \"role\", an \"issued date\", and an \"expiry date\" ~10 years in the future.\n+| Responsibility                     | Question                           | Answer                                             |\n+| ---------------------------------- | ---------------------------------- | -------------------------------------------------- |\n+| API keys                           | **What** is accessing the project? | Web page, mobile app, server, Edge Function...     |\n+| [Supabase Auth](/docs/guides/auth) | **Who** is accessing the project?  | Monica, Jian Yang, Gavin, Dinesh, Laurie, Fiona... |\n \n-```json\n-{\n-  \"role\": \"anon\",\n-  \"iat\": 1625137684,\n-  \"exp\": 1940713684\n-}\n-```\n+## Overview\n \n-## The `anon` key\n+An API key authenticates an application component to give it access to Supabase services. An application component might be a web page, a mobile app, or a server. The API key _does not_ distinguish between users, only between applications.\n \n-The `anon` key has very few privileges. You can use it in your [RLS policies](/docs/guides/database/postgres/row-level-security) to allow unauthenticated access. For example, this policy will allow unauthenticated access to the `profiles` table:\n+There are 4 types of API keys that can be used with Supabase:\n \n-```sql\n-create policy \"Allow public access\" on profiles to anon for\n-select\n-  using (true);\n-```\n+| Type                                                       | Format                                                           | Privileges | Availability                                              | Use                                                                                                                                                                                                                                                                                               |\n+| ---------------------------------------------------------- | ---------------------------------------------------------------- | ---------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n+| Publishable&nbsp;key                                       | <span className=\"!whitespace-nowrap\">`sb_publishable_...`</span> | Low        | Platform                                                  | Safe to expose online: web page, mobile or desktop app, GitHub actions, CLIs, source code.                                                                                                                                                                                                        |\n+| Secret&nbsp;keys                                           | <span className=\"!whitespace-nowrap\">`sb_secret_...`</span>      | Elevated   | Platform                                                  | **Only use in backend components of your app:** servers, already secured APIs (admin panels), [Edge Functions](/docs/guides/functions), microservices, etc. They provide _full access_ to your project's data, bypassing [Row Level Security](/docs/guides/database/postgres/row-level-security). |\n+| <span className=\"!whitespace-nowrap\">`anon`</span>         | JWT (long lived)                                                 | Low        | <span className=\"!whitespace-nowrap\">Platform, CLI</span> | Exactly like the publishable key.                                                                                                                                                                                                                                                                 |\n+| <span className=\"!whitespace-nowrap\">`service_role`</span> | JWT (long lived)                                                 | Elevated   | <span className=\"!whitespace-nowrap\">Platform, CLI</span> | Exactly like secret keys.                                                                                                                                                                                                                                                                         |\n \n-And similarly for disallowing access:\n+<Admonition type=\"note\">\n \n-```sql\n-create policy \"Disallow public access\" on profiles to anon for\n-select\n-  using (false);\n-```\n+`anon` and `service_role` keys are based on the project's JWT secret. They are generated when your project is created and can only be changed when you rotate the JWT secret. This can cause significant issues in production applications. Use the publishable and secret keys instead.\n \n-If you are using [Supabase Auth](/docs/guides/auth/overview), then the `anon` role will automatically update to `authenticated` once a user is logged in:\n+</Admonition>\n+\n+## `anon` and publishable keys\n+\n+The `anon` and publishable keys secure the public components of your application. Public components run in environments where it is impossible to secure any secrets. These include:\n+\n+- Web pages, where the key is bundled in source code.\n+- Mobile or desktop applications, where the key is bundled inside the compiled packages or executables.\n+- CLI, scripts, tools, or other pre-built executables.\n+- Other publicly available APIs that return the key without prior additional authorization.\n+\n+These environments are always considered public because anyone can retrieve the key from the source code or build artifacts. Obfuscation can increase the difficulty, but never eliminate the possibility. (In general, obfuscation, Turing test challenges, and specialized knowledge do not count as authorization for the purpose of securing secrets.)\n+\n+### Interaction with Supabase Auth\n+\n+Using the `anon` or publishable key does not mean that your user is anonymous. (Thinking of both these keys as publishable rather than `anon` makes the mental model clearer.)\n+\n+Your application can be authenticated with the publishable key, while your user is authenticated (via Supabase Auth) with their personal JWT:\n+\n+| Key             | User logged in via Supabase Auth | Postgres role used for RLS, etc. |\n+| --------------- | -------------------------------- | -------------------------------- |\n+| Publishable key | No                               | `anon`                           |\n+| `anon`          | No                               | `anon`                           |\n+| Publishable key | Yes                              | `authenticated`                  |\n+| `anon`          | Yes                              | `authenticated`                  |\n+\n+### Protection\n+\n+These keys provide first-layer protection to your project's data, performance and bill, such as:\n+\n+- Providing basic Denial-of-Service protection, by requiring a minimal threshold of knowledge.\n+- Protecting your bill by ignoring bots, scrapers, automated vulnerability scanners and other well meaning or random Internet activity.\n+\n+### Security considerations\n+\n+The publishable and `anon` keys are not intended to protect from the following, since key retrieval is always possible from a public component:\n \n-```sql\n-create policy \"Allow access to authenticated users\" on profiles to authenticated for\n-select\n-  using (true);\n-```\n+- Static or dynamic code analysis and reverse engineering attempts.\n+- Use of the Network inspector in the browser.\n+- Cross-site request forgery, cross-site scripting, phishing attacks.\n+- Man-in-the-middle attacks.\n \n-## The `service_role` key\n+When using the publishable or `anon` key, access to your project's data is guarded by Postgres via the built-in `anon` and `authenticated` roles. For full protection make sure:\n \n-The \"service_role\" is a predefined Postgres role with elevated privileges, designed to perform various administrative and service-related tasks. It can bypass Row Level Security, so it should only be used on a private server.\n+- You have enabled Row Level Security on all tables.\n+- You regularly review your Row Level Security policies for permissions granted to the `anon` and `authenticated` roles.\n+- You do not modify the role's attributes without understanding the changes you are making.\n+\n+Your project's [Security Advisor](/dashboard/project/_/advisors/security) constantly checks for common security problems with the built-in Postgres roles. Make sure you carefully review each finding before dismissing it.\n+\n+## `service_role` and secret keys\n+\n+Unlike the `anon` and publishable key, the `service_role` and secret keys allow elevated access to your project's data. It is meant to be used only in secure, developer-controlled components of your application, such as:\n+\n+- Servers that implement prior authorization themselves, such as Edge Functions, microservices, traditional or specialized web servers.\n+- Periodic jobs, queue processors, topic subscribers.\n+- Admin and back-office tools, with prior authorization checks only.\n+- Data processing pipelines, such as for analytics, reports, backups, or database syncrhonization.\n \n <Admonition type=\"caution\">\n \n-Never expose the `service_role` key in a browser or anywhere where a user can see it.\n+Never expose your `service_role` and secret keys publicly. Your data is at risk. **Do not:**\n+\n+- Add in web pages, public documents, source code, bundle in executables or packages for mobile, desktop or CLI apps.\n+- Send over chat applications, email or SMS to your peers.\n+- Never use in a browser, even on `localhost`!\n+- Do not pass in URLs or query params, as these are often logged.\n+- Be careful passing them in request headers without prior log sanitization.\n+- Take extra care logging even potentially **invalid API keys**. Simple typos might reveal the real key in the future.\n+- Reveal, copy, use or manipulate on hardware devices without full disk encryption and which you do not directly own or control (such as public computers, friend's laptop, etc.)\n+\n+Ensure you handle them with care and using [secure coding practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/stable-en/).\n \n </Admonition>\n \n-A common use case for the `service_role` key is running data analytics jobs on the backend. To support joins on user id, it is often useful to grant the service role read access to `auth.users` table.\n+Secret keys and the `service_role` JWT-based API key authorize access to your project's data via the built-in `service_role` Postgres role. By design, this role has full access to your project's data. It also uses the [`BYPASSRLS` attribute](https://www.postgresql.org/docs/current/ddl-rowsecurity.html#:~:text=BYPASSRLS), skipping any and all Row Level Security policies you attach.\n+\n+The secret key is an improvement over the old JWT-based `service_role` key, and we recommend using it where possible. It adds more checks to prevent misuse, specifically:\n+\n+- You cannot use a secret key in the browser (matches on the `User-Agent` header) and it will always reply with HTTP 401 Unauthorized.\n+- You don't need to have any secret keys if you are not using them.\n+\n+### Best practices for handling secret keys\n+\n+Below are some starting guidelines on how to securely work with secret keys:\n+\n+- Always work with secret keys on computers you fully own or control.\n+- Use secure & encrypted send tools to share API keys with others (often provided by good password managers), but prefer the [API Keys](/dashboard/project/_/settings/api-keys/new) dashboard instead.\n+- Prefer encrypting them when stored in files or environment variables.\n+- Do not add in source control, especially for CI scripts and tools. Prefer using the tool's native secrets capability instead.\n+- Prefer using a separate secret key for each separate backend component of your application, so that if one is found to be vulnerable or to have leaked the key you will only need to change it and not all.\n+- Even though a secret key will always return HTTP 401 Unauthorized error when used in a browser, it does not mean that attackers will not use it with other tools. Delete immediately!\n+- If you must include them in logs, log the first few random characters (but never more than 6).\n+- If you wish to log or store which valid API key was used, store it as a SHA256 hash.\n+\n+### What to do if a secret key or `service_role` has been leaked or compromised?\n+\n+Don't rush if this has happened, or you are suspecting it has. Make sure you have fully considered the situation and have remediated the root cause of the suspicion or vulnerability **first**. Consider using the [OWASP Risk Rating Methodology](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology) as an easy way to identify the severity of the incident and to plan your next steps.\n+\n+Rotating a secret key (`sb_secret_...`) is easy and painless. Use the [API Keys](/dashboard/project/_/settings/api-keys/new) dashboard to create a new secret API key, then replace it with the compromised key. Once all components are using the new key, delete the compromised one.\n+\n+**Deleting a secret key is irreversible and once done it will be gone forever.**\n+\n+If you are still using the JWT-based `service_role` key, there are two options.\n+\n+1. **Strongly recommended:** Replace the `service_role` key with a new secret key instead. Follow the guide from above as if you are rotating an existing secret key.\n+2. [Rotate your project's JWT secret.](/dashboard/project/_/settings/api) This operation is only recommended if you suspect that the JWT secret has leaked itself. Consider switching your `anon` JWT-based key to the publishable key, and all `service_role` JWT-based keys to secret keys. Only then rotate the JWT secret. Check the FAQ below if you use the JWT-based keys in mobile, desktop or CLI applications!\n+\n+## Known limitations and compatibility differences\n+\n+As the publishable and secret keys are no longer JWT-based, there are some known limitations and compatibility differences that you may need to plan for:\n+\n+- You cannot send a publishable or secret key in the `Authorization: Bearer ...` header, except if the value exactly equals the `apikey` header. In this case, your request will be forwarded down to your project's database, but will be rejected as the value is not a JWT.\n+- Edge Functions **only support JWT verification** via the `anon` and `service_role` JWT-based API keys. You will need to use the `--no-verify-jwt` option when using publishable and secret keys. The Supabase platform does not verify the `apikey` header when using Edge Functions in this way. Implement your own `apikey`-header authorization logic inside the Edge Function code itself.\n+- Public Realtime connections are limited to 24 hours in duration, unless the connection is upgraded and further maintained with user-level authentication via Supabase Auth or a supported Third-Party Auth provider.\n+\n+## Frequently asked questions\n+\n+{/* supa-mdx-lint-disable Rule004ExcludeWords */}\n+\n+### I am using JWT-based `anon` key in a mobile, desktop, or CLI application and need to rotate my `service_role` JWT secret?\n+\n+If you know or suspect that the JWT secret itself is leaked, refer to the section on [rotating the JWT](#what-to-do-if-a-secret-key-or-servicerole-has-leaked).",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2142963649",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36331,
        "pr_file": "apps/docs/content/guides/api/api-keys.mdx",
        "discussion_id": "2142963649",
        "commented_code": "@@ -1,66 +1,199 @@\n ---\n id: 'api-keys'\n-title: 'Understanding API Keys'\n-description: 'Securing your Data API with Postgres Row Level Security.'\n+title: 'Understanding API keys'\n+description: \"First-layer protection for your project's data\"\n ---\n \n-Supabase provides two default keys when you create a project: an `anon` key, and a `service_role` key. You can find both keys in the [API Settings](https://supabase.com/dashboard/project/_/settings/api).\n+Supabase gives you fine-grained control over which application components are allowed to access your project through API keys.\n \n-The data APIs are designed to work with Postgres Row Level Security (RLS). These keys both map to Postgres roles. You can find an `anon` user and a `service_role` user in the [Roles](http://supabase.com/dashboard/project/_/database/roles) section of the dashboard.\n+API keys provide the first layer of authentication for data access. Auth then builds upon that. This chart covers the differences:\n \n-The keys are both long-lived JWTs. If you decode these keys, you will see that they contain the \"role\", an \"issued date\", and an \"expiry date\" ~10 years in the future.\n+| Responsibility                     | Question                           | Answer                                             |\n+| ---------------------------------- | ---------------------------------- | -------------------------------------------------- |\n+| API keys                           | **What** is accessing the project? | Web page, mobile app, server, Edge Function...     |\n+| [Supabase Auth](/docs/guides/auth) | **Who** is accessing the project?  | Monica, Jian Yang, Gavin, Dinesh, Laurie, Fiona... |\n \n-```json\n-{\n-  \"role\": \"anon\",\n-  \"iat\": 1625137684,\n-  \"exp\": 1940713684\n-}\n-```\n+## Overview\n \n-## The `anon` key\n+An API key authenticates an application component to give it access to Supabase services. An application component might be a web page, a mobile app, or a server. The API key _does not_ distinguish between users, only between applications.\n \n-The `anon` key has very few privileges. You can use it in your [RLS policies](/docs/guides/database/postgres/row-level-security) to allow unauthenticated access. For example, this policy will allow unauthenticated access to the `profiles` table:\n+There are 4 types of API keys that can be used with Supabase:\n \n-```sql\n-create policy \"Allow public access\" on profiles to anon for\n-select\n-  using (true);\n-```\n+| Type                                                       | Format                                                           | Privileges | Availability                                              | Use                                                                                                                                                                                                                                                                                               |\n+| ---------------------------------------------------------- | ---------------------------------------------------------------- | ---------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n+| Publishable&nbsp;key                                       | <span className=\"!whitespace-nowrap\">`sb_publishable_...`</span> | Low        | Platform                                                  | Safe to expose online: web page, mobile or desktop app, GitHub actions, CLIs, source code.                                                                                                                                                                                                        |\n+| Secret&nbsp;keys                                           | <span className=\"!whitespace-nowrap\">`sb_secret_...`</span>      | Elevated   | Platform                                                  | **Only use in backend components of your app:** servers, already secured APIs (admin panels), [Edge Functions](/docs/guides/functions), microservices, etc. They provide _full access_ to your project's data, bypassing [Row Level Security](/docs/guides/database/postgres/row-level-security). |\n+| <span className=\"!whitespace-nowrap\">`anon`</span>         | JWT (long lived)                                                 | Low        | <span className=\"!whitespace-nowrap\">Platform, CLI</span> | Exactly like the publishable key.                                                                                                                                                                                                                                                                 |\n+| <span className=\"!whitespace-nowrap\">`service_role`</span> | JWT (long lived)                                                 | Elevated   | <span className=\"!whitespace-nowrap\">Platform, CLI</span> | Exactly like secret keys.                                                                                                                                                                                                                                                                         |\n \n-And similarly for disallowing access:\n+<Admonition type=\"note\">\n \n-```sql\n-create policy \"Disallow public access\" on profiles to anon for\n-select\n-  using (false);\n-```\n+`anon` and `service_role` keys are based on the project's JWT secret. They are generated when your project is created and can only be changed when you rotate the JWT secret. This can cause significant issues in production applications. Use the publishable and secret keys instead.\n \n-If you are using [Supabase Auth](/docs/guides/auth/overview), then the `anon` role will automatically update to `authenticated` once a user is logged in:\n+</Admonition>\n+\n+## `anon` and publishable keys\n+\n+The `anon` and publishable keys secure the public components of your application. Public components run in environments where it is impossible to secure any secrets. These include:\n+\n+- Web pages, where the key is bundled in source code.\n+- Mobile or desktop applications, where the key is bundled inside the compiled packages or executables.\n+- CLI, scripts, tools, or other pre-built executables.\n+- Other publicly available APIs that return the key without prior additional authorization.\n+\n+These environments are always considered public because anyone can retrieve the key from the source code or build artifacts. Obfuscation can increase the difficulty, but never eliminate the possibility. (In general, obfuscation, Turing test challenges, and specialized knowledge do not count as authorization for the purpose of securing secrets.)\n+\n+### Interaction with Supabase Auth\n+\n+Using the `anon` or publishable key does not mean that your user is anonymous. (Thinking of both these keys as publishable rather than `anon` makes the mental model clearer.)\n+\n+Your application can be authenticated with the publishable key, while your user is authenticated (via Supabase Auth) with their personal JWT:\n+\n+| Key             | User logged in via Supabase Auth | Postgres role used for RLS, etc. |\n+| --------------- | -------------------------------- | -------------------------------- |\n+| Publishable key | No                               | `anon`                           |\n+| `anon`          | No                               | `anon`                           |\n+| Publishable key | Yes                              | `authenticated`                  |\n+| `anon`          | Yes                              | `authenticated`                  |\n+\n+### Protection\n+\n+These keys provide first-layer protection to your project's data, performance and bill, such as:\n+\n+- Providing basic Denial-of-Service protection, by requiring a minimal threshold of knowledge.\n+- Protecting your bill by ignoring bots, scrapers, automated vulnerability scanners and other well meaning or random Internet activity.\n+\n+### Security considerations\n+\n+The publishable and `anon` keys are not intended to protect from the following, since key retrieval is always possible from a public component:\n \n-```sql\n-create policy \"Allow access to authenticated users\" on profiles to authenticated for\n-select\n-  using (true);\n-```\n+- Static or dynamic code analysis and reverse engineering attempts.\n+- Use of the Network inspector in the browser.\n+- Cross-site request forgery, cross-site scripting, phishing attacks.\n+- Man-in-the-middle attacks.\n \n-## The `service_role` key\n+When using the publishable or `anon` key, access to your project's data is guarded by Postgres via the built-in `anon` and `authenticated` roles. For full protection make sure:\n \n-The \"service_role\" is a predefined Postgres role with elevated privileges, designed to perform various administrative and service-related tasks. It can bypass Row Level Security, so it should only be used on a private server.\n+- You have enabled Row Level Security on all tables.\n+- You regularly review your Row Level Security policies for permissions granted to the `anon` and `authenticated` roles.\n+- You do not modify the role's attributes without understanding the changes you are making.\n+\n+Your project's [Security Advisor](/dashboard/project/_/advisors/security) constantly checks for common security problems with the built-in Postgres roles. Make sure you carefully review each finding before dismissing it.\n+\n+## `service_role` and secret keys\n+\n+Unlike the `anon` and publishable key, the `service_role` and secret keys allow elevated access to your project's data. It is meant to be used only in secure, developer-controlled components of your application, such as:\n+\n+- Servers that implement prior authorization themselves, such as Edge Functions, microservices, traditional or specialized web servers.\n+- Periodic jobs, queue processors, topic subscribers.\n+- Admin and back-office tools, with prior authorization checks only.\n+- Data processing pipelines, such as for analytics, reports, backups, or database syncrhonization.\n \n <Admonition type=\"caution\">\n \n-Never expose the `service_role` key in a browser or anywhere where a user can see it.\n+Never expose your `service_role` and secret keys publicly. Your data is at risk. **Do not:**\n+\n+- Add in web pages, public documents, source code, bundle in executables or packages for mobile, desktop or CLI apps.\n+- Send over chat applications, email or SMS to your peers.\n+- Never use in a browser, even on `localhost`!\n+- Do not pass in URLs or query params, as these are often logged.\n+- Be careful passing them in request headers without prior log sanitization.\n+- Take extra care logging even potentially **invalid API keys**. Simple typos might reveal the real key in the future.\n+- Reveal, copy, use or manipulate on hardware devices without full disk encryption and which you do not directly own or control (such as public computers, friend's laptop, etc.)\n+\n+Ensure you handle them with care and using [secure coding practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/stable-en/).\n \n </Admonition>\n \n-A common use case for the `service_role` key is running data analytics jobs on the backend. To support joins on user id, it is often useful to grant the service role read access to `auth.users` table.\n+Secret keys and the `service_role` JWT-based API key authorize access to your project's data via the built-in `service_role` Postgres role. By design, this role has full access to your project's data. It also uses the [`BYPASSRLS` attribute](https://www.postgresql.org/docs/current/ddl-rowsecurity.html#:~:text=BYPASSRLS), skipping any and all Row Level Security policies you attach.\n+\n+The secret key is an improvement over the old JWT-based `service_role` key, and we recommend using it where possible. It adds more checks to prevent misuse, specifically:\n+\n+- You cannot use a secret key in the browser (matches on the `User-Agent` header) and it will always reply with HTTP 401 Unauthorized.\n+- You don't need to have any secret keys if you are not using them.\n+\n+### Best practices for handling secret keys\n+\n+Below are some starting guidelines on how to securely work with secret keys:\n+\n+- Always work with secret keys on computers you fully own or control.\n+- Use secure & encrypted send tools to share API keys with others (often provided by good password managers), but prefer the [API Keys](/dashboard/project/_/settings/api-keys/new) dashboard instead.\n+- Prefer encrypting them when stored in files or environment variables.\n+- Do not add in source control, especially for CI scripts and tools. Prefer using the tool's native secrets capability instead.\n+- Prefer using a separate secret key for each separate backend component of your application, so that if one is found to be vulnerable or to have leaked the key you will only need to change it and not all.\n+- Even though a secret key will always return HTTP 401 Unauthorized error when used in a browser, it does not mean that attackers will not use it with other tools. Delete immediately!\n+- If you must include them in logs, log the first few random characters (but never more than 6).\n+- If you wish to log or store which valid API key was used, store it as a SHA256 hash.\n+\n+### What to do if a secret key or `service_role` has been leaked or compromised?\n+\n+Don't rush if this has happened, or you are suspecting it has. Make sure you have fully considered the situation and have remediated the root cause of the suspicion or vulnerability **first**. Consider using the [OWASP Risk Rating Methodology](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology) as an easy way to identify the severity of the incident and to plan your next steps.\n+\n+Rotating a secret key (`sb_secret_...`) is easy and painless. Use the [API Keys](/dashboard/project/_/settings/api-keys/new) dashboard to create a new secret API key, then replace it with the compromised key. Once all components are using the new key, delete the compromised one.\n+\n+**Deleting a secret key is irreversible and once done it will be gone forever.**\n+\n+If you are still using the JWT-based `service_role` key, there are two options.\n+\n+1. **Strongly recommended:** Replace the `service_role` key with a new secret key instead. Follow the guide from above as if you are rotating an existing secret key.\n+2. [Rotate your project's JWT secret.](/dashboard/project/_/settings/api) This operation is only recommended if you suspect that the JWT secret has leaked itself. Consider switching your `anon` JWT-based key to the publishable key, and all `service_role` JWT-based keys to secret keys. Only then rotate the JWT secret. Check the FAQ below if you use the JWT-based keys in mobile, desktop or CLI applications!\n+\n+## Known limitations and compatibility differences\n+\n+As the publishable and secret keys are no longer JWT-based, there are some known limitations and compatibility differences that you may need to plan for:\n+\n+- You cannot send a publishable or secret key in the `Authorization: Bearer ...` header, except if the value exactly equals the `apikey` header. In this case, your request will be forwarded down to your project's database, but will be rejected as the value is not a JWT.\n+- Edge Functions **only support JWT verification** via the `anon` and `service_role` JWT-based API keys. You will need to use the `--no-verify-jwt` option when using publishable and secret keys. The Supabase platform does not verify the `apikey` header when using Edge Functions in this way. Implement your own `apikey`-header authorization logic inside the Edge Function code itself.\n+- Public Realtime connections are limited to 24 hours in duration, unless the connection is upgraded and further maintained with user-level authentication via Supabase Auth or a supported Third-Party Auth provider.\n+\n+## Frequently asked questions\n+\n+{/* supa-mdx-lint-disable Rule004ExcludeWords */}\n+\n+### I am using JWT-based `anon` key in a mobile, desktop, or CLI application and need to rotate my `service_role` JWT secret?\n+\n+If you know or suspect that the JWT secret itself is leaked, refer to the section on [rotating the JWT](#what-to-do-if-a-secret-key-or-servicerole-has-leaked).",
        "comment_created_at": "2025-06-12T14:43:47+00:00",
        "comment_author": "cemalkilic",
        "comment_body": "```suggestion\r\nIf you know or suspect that the JWT secret itself is leaked, refer to the section on [rotating the JWT](#what-to-do-if-a-secret-key-or-servicerole-has-been-leaked-or-compromised).\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2114226656",
    "pr_number": 36016,
    "pr_file": "apps/docs/content/guides/database/hardening-data-api.mdx",
    "created_at": "2025-05-29T15:38:18+00:00",
    "commented_code": "title: 'Hardening the Data API'\n ---\n \n-Your database's automatically generated Data API exposes the `public` schema by default. If your `public` schema is used by other tools as a default space, you might want to lock down this schema. This helps prevent accidental exposure of data that's automatically added to `public`.\n+Your database's auto-generated Data API exposes the `public` schema by default. You can change this to any schema in your database, or even disable the Data API completely.\n+\n+Any tables that are accesible through the Data API _must_ have [Row Level Security](/docs/guides/database/postgres/row-level-security) enabled. Row Level Security (RLS) is enabled by default when you create tables from the Supabase Dashboard.",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2114226656",
        "repo_full_name": "supabase/supabase",
        "pr_number": 36016,
        "pr_file": "apps/docs/content/guides/database/hardening-data-api.mdx",
        "discussion_id": "2114226656",
        "commented_code": "@@ -2,7 +2,24 @@\n title: 'Hardening the Data API'\n ---\n \n-Your database's automatically generated Data API exposes the `public` schema by default. If your `public` schema is used by other tools as a default space, you might want to lock down this schema. This helps prevent accidental exposure of data that's automatically added to `public`.\n+Your database's auto-generated Data API exposes the `public` schema by default. You can change this to any schema in your database, or even disable the Data API completely.\n+\n+Any tables that are accesible through the Data API _must_ have [Row Level Security](/docs/guides/database/postgres/row-level-security) enabled. Row Level Security (RLS) is enabled by default when you create tables from the Supabase Dashboard.",
        "comment_created_at": "2025-05-29T15:38:18+00:00",
        "comment_author": "charislam",
        "comment_body": "```suggestion\r\nAny tables that are accessible through the Data API _must_ have [Row Level Security](/docs/guides/database/postgres/row-level-security) enabled. Row Level Security (RLS) is enabled by default when you create tables from the Supabase Dashboard. If you create a table using the SQL editor or your own SQL client or migration runner, you_must_ enable RLS yourself.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086872813",
    "pr_number": 35529,
    "pr_file": "apps/docs/.gitignore",
    "created_at": "2025-05-13T13:46:12+00:00",
    "commented_code": "# Copied examples folder\n /examples/\n+\n+# Sentry Config File\n+.env.sentry-build-plugin",
    "repo_full_name": "supabase/supabase",
    "discussion_comments": [
      {
        "comment_id": "2086872813",
        "repo_full_name": "supabase/supabase",
        "pr_number": 35529,
        "pr_file": "apps/docs/.gitignore",
        "discussion_id": "2086872813",
        "commented_code": "@@ -33,3 +33,6 @@ public/llms/\n \n # Copied examples folder\n /examples/\n+\n+# Sentry Config File\n+.env.sentry-build-plugin",
        "comment_created_at": "2025-05-13T13:46:12+00:00",
        "comment_author": "avallete",
        "comment_body": "**suggestion**\r\n\r\nAdd the `.sentryclirc` to the gitignored files\r\n\r\n```suggestion\r\n.env.sentry-build-plugin\r\n.sentryclirc\r\n```\r\n\r\nJust to make sure this doesn't happen by mistake: https://github.com/search?q=path%3A.sentryclirc+token%3Dsntrys&type=code&ref=advsearch\r\n",
        "pr_file_module": null
      }
    ]
  }
]