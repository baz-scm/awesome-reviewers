[
  {
    "discussion_id": "1981586630",
    "pr_number": 15450,
    "pr_file": "packages/svelte/src/compiler/phases/2-analyze/css/css-analyze.js",
    "created_at": "2025-03-05T15:06:50+00:00",
    "commented_code": "if (idx !== -1) {\n \t\t\t\t\tis_global_block = true;\n+\t\t\t\t\tif (i === 0) {\n+\t\t\t\t\t\tif (is_unscoped_global(context.path) && node.block.children.length > 0) {\n+\t\t\t\t\t\t\tcontext.state.has_global_unscoped.value = true;",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1981586630",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15450,
        "pr_file": "packages/svelte/src/compiler/phases/2-analyze/css/css-analyze.js",
        "discussion_id": "1981586630",
        "commented_code": "@@ -184,6 +221,11 @@ const css_visitors = {\n \n \t\t\t\tif (idx !== -1) {\n \t\t\t\t\tis_global_block = true;\n+\t\t\t\t\tif (i === 0) {\n+\t\t\t\t\t\tif (is_unscoped_global(context.path) && node.block.children.length > 0) {\n+\t\t\t\t\t\t\tcontext.state.has_global_unscoped.value = true;",
        "comment_created_at": "2025-03-05T15:06:50+00:00",
        "comment_author": "dominikg",
        "comment_body": "once this has flipped to true you don't need to evaluate more selectors",
        "pr_file_module": null
      },
      {
        "comment_id": "1981641931",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15450,
        "pr_file": "packages/svelte/src/compiler/phases/2-analyze/css/css-analyze.js",
        "discussion_id": "1981586630",
        "commented_code": "@@ -184,6 +221,11 @@ const css_visitors = {\n \n \t\t\t\tif (idx !== -1) {\n \t\t\t\t\tis_global_block = true;\n+\t\t\t\t\tif (i === 0) {\n+\t\t\t\t\t\tif (is_unscoped_global(context.path) && node.block.children.length > 0) {\n+\t\t\t\t\t\t\tcontext.state.has_global_unscoped.value = true;",
        "comment_created_at": "2025-03-05T15:27:31+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "correct...i will still need to loop to do the rest of the analysis but i can guard the usage if it's already true...fixed it in the last commit",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1841341602",
    "pr_number": 14269,
    "pr_file": "packages/svelte/src/compiler/phases/utils.js",
    "created_at": "2024-11-14T00:01:53+00:00",
    "commented_code": "+/** @import { AST, Binding } from '#compiler' */\n+/** @import { Scope } from './scope' */\n+/** @import * as ESTree from 'estree' */\n+\n+import { walk } from 'zimmerframe';\n+\n+/**\n+ * @param {ESTree.Expression} expr\n+ */\n+export function extract_identifiers(expr) {\n+\t/** @type {ESTree.Identifier[]} */\n+\tlet nodes = [];\n+\n+\twalk(\n+\t\texpr,\n+\t\t{},\n+\t\t{\n+\t\t\tIdentifier(node, { path }) {\n+\t\t\t\tconst parent = path.at(-1);\n+\t\t\t\tif (parent?.type !== 'MemberExpression' || parent.property !== node || parent.computed) {\n+\t\t\t\t\tnodes.push(node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t);\n+\n+\treturn nodes;\n+}\n+",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1841341602",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14269,
        "pr_file": "packages/svelte/src/compiler/phases/utils.js",
        "discussion_id": "1841341602",
        "commented_code": "@@ -0,0 +1,81 @@\n+/** @import { AST, Binding } from '#compiler' */\n+/** @import { Scope } from './scope' */\n+/** @import * as ESTree from 'estree' */\n+\n+import { walk } from 'zimmerframe';\n+\n+/**\n+ * @param {ESTree.Expression} expr\n+ */\n+export function extract_identifiers(expr) {\n+\t/** @type {ESTree.Identifier[]} */\n+\tlet nodes = [];\n+\n+\twalk(\n+\t\texpr,\n+\t\t{},\n+\t\t{\n+\t\t\tIdentifier(node, { path }) {\n+\t\t\t\tconst parent = path.at(-1);\n+\t\t\t\tif (parent?.type !== 'MemberExpression' || parent.property !== node || parent.computed) {\n+\t\t\t\t\tnodes.push(node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t);\n+\n+\treturn nodes;\n+}\n+",
        "comment_created_at": "2024-11-14T00:01:53+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "Walking is expensive, we want to do it as infrequently as possible. Luckily we don't need this function anyway, since the necessary information exists on `value.metadata.expression.dependencies`.\r\n\r\nAs a side-note, the check in the `Identifier` visitor is insufficient. If you want to know if an identifier is a _reference_ then you can use [`is-reference`](https://github.com/Rich-Harris/is-reference/)\r\n\r\n```suggestion\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1841352964",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14269,
        "pr_file": "packages/svelte/src/compiler/phases/utils.js",
        "discussion_id": "1841341602",
        "commented_code": "@@ -0,0 +1,81 @@\n+/** @import { AST, Binding } from '#compiler' */\n+/** @import { Scope } from './scope' */\n+/** @import * as ESTree from 'estree' */\n+\n+import { walk } from 'zimmerframe';\n+\n+/**\n+ * @param {ESTree.Expression} expr\n+ */\n+export function extract_identifiers(expr) {\n+\t/** @type {ESTree.Identifier[]} */\n+\tlet nodes = [];\n+\n+\twalk(\n+\t\texpr,\n+\t\t{},\n+\t\t{\n+\t\t\tIdentifier(node, { path }) {\n+\t\t\t\tconst parent = path.at(-1);\n+\t\t\t\tif (parent?.type !== 'MemberExpression' || parent.property !== node || parent.computed) {\n+\t\t\t\t\tnodes.push(node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t);\n+\n+\treturn nodes;\n+}\n+",
        "comment_created_at": "2024-11-14T00:19:01+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "...although `value.metadata.expression.dependencies` excludes globals, which means that things like `{location}` get inlined incorrectly. We may need to treat globals as bindings",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1763445115",
    "pr_number": 13282,
    "pr_file": "packages/svelte/src/internal/client/runtime.js",
    "created_at": "2024-09-17T15:21:49+00:00",
    "commented_code": "effect = effect.parent;\n \t\tvar flags = effect.f;\n \n+\t\t// Branch effects are not part of the reactive signal graph as they can never have\n+\t\t// dependencies. As such, we can use effects can be CLEAN or MAYBE_DIRTY to signal\n+\t\t// that they contain an effect that is dirty and needs visiting in `process_effects`,\n+\t\t// and if not we can skip the branch entirely. This also doubles as being able to\n+\t\t// skip propagation up the graph in `schedule_effect` if we encounter a branch that\n+\t\t// is already MAYBE_DIRTY.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1763445115",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13282,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1763445115",
        "commented_code": "@@ -586,6 +586,12 @@ export function schedule_effect(signal) {\n \t\teffect = effect.parent;\n \t\tvar flags = effect.f;\n \n+\t\t// Branch effects are not part of the reactive signal graph as they can never have\n+\t\t// dependencies. As such, we can use effects can be CLEAN or MAYBE_DIRTY to signal\n+\t\t// that they contain an effect that is dirty and needs visiting in `process_effects`,\n+\t\t// and if not we can skip the branch entirely. This also doubles as being able to\n+\t\t// skip propagation up the graph in `schedule_effect` if we encounter a branch that\n+\t\t// is already MAYBE_DIRTY.",
        "comment_created_at": "2024-09-17T15:21:49+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "Still trying to wrap my head round this, it's very cryptic. If I understand correctly, we're saying that since branch effects have no dependencies and can therefore never be dirty, we can (ab)use the `MAYBE_DIRTY` flag on branches to stop traversing upwards to the root. Is that right?\r\n\r\nIf so, it feels suboptimal \u2014 it means we traverse upwards unnecessarily until we hit a branch, and it means we call `check_dirtiness` for branches unnecessarily. What if we had an `EFFECT_HAS_DIRTY_CHILDREN` flag or similar instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "1763458474",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13282,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1763445115",
        "commented_code": "@@ -586,6 +586,12 @@ export function schedule_effect(signal) {\n \t\teffect = effect.parent;\n \t\tvar flags = effect.f;\n \n+\t\t// Branch effects are not part of the reactive signal graph as they can never have\n+\t\t// dependencies. As such, we can use effects can be CLEAN or MAYBE_DIRTY to signal\n+\t\t// that they contain an effect that is dirty and needs visiting in `process_effects`,\n+\t\t// and if not we can skip the branch entirely. This also doubles as being able to\n+\t\t// skip propagation up the graph in `schedule_effect` if we encounter a branch that\n+\t\t// is already MAYBE_DIRTY.",
        "comment_created_at": "2024-09-17T15:30:32+00:00",
        "comment_author": "trueadm",
        "comment_body": ">  If I understand correctly, we're saying that since branch effects have no dependencies and can therefore never be dirty, we can (ab)use the MAYBE_DIRTY flag on branches to stop traversing upwards to the root. Is that right?\r\n\r\nNot entirely, it's mainly to avoid traversing it in `process_effects` which is where the real expense is as that's a full tree search without this optimisation in place.\r\n\r\n> If so, it feels suboptimal \u2014 it means we traverse upwards unnecessarily until we hit a branch, and it means we call check_dirtiness for branches unnecessarily.\r\n\r\nWe hit a branch traversing up almost always 1 or 2 levels, it's actually very effective.\r\n\r\n> What if we had an EFFECT_HAS_DIRTY_CHILDREN flag or similar instead?\r\n\r\nThat would just mean having more code in the codebase. I don't understand why this is a problem, this code has been around since we've had effect scheduling based on roots.",
        "pr_file_module": null
      },
      {
        "comment_id": "1763479698",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13282,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1763445115",
        "commented_code": "@@ -586,6 +586,12 @@ export function schedule_effect(signal) {\n \t\teffect = effect.parent;\n \t\tvar flags = effect.f;\n \n+\t\t// Branch effects are not part of the reactive signal graph as they can never have\n+\t\t// dependencies. As such, we can use effects can be CLEAN or MAYBE_DIRTY to signal\n+\t\t// that they contain an effect that is dirty and needs visiting in `process_effects`,\n+\t\t// and if not we can skip the branch entirely. This also doubles as being able to\n+\t\t// skip propagation up the graph in `schedule_effect` if we encounter a branch that\n+\t\t// is already MAYBE_DIRTY.",
        "comment_created_at": "2024-09-17T15:44:59+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "> That would just mean having more code in the codebase\r\n\r\nWould it? It seems we could probably _simplify_ `process_effects` if 'this effect is/could be dirty' and 'this effect has dirty children' were separate concepts, instead of needing to check `is_branch` at numerous points inside that function. And `schedule_effect` would get simpler, especially since we wouldn't need a chunky comment explaining what's going on.\r\n\r\nThe performance benefits might be negligible but the real win would be more self-explanatory code, I think",
        "pr_file_module": null
      },
      {
        "comment_id": "1763564665",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13282,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1763445115",
        "commented_code": "@@ -586,6 +586,12 @@ export function schedule_effect(signal) {\n \t\teffect = effect.parent;\n \t\tvar flags = effect.f;\n \n+\t\t// Branch effects are not part of the reactive signal graph as they can never have\n+\t\t// dependencies. As such, we can use effects can be CLEAN or MAYBE_DIRTY to signal\n+\t\t// that they contain an effect that is dirty and needs visiting in `process_effects`,\n+\t\t// and if not we can skip the branch entirely. This also doubles as being able to\n+\t\t// skip propagation up the graph in `schedule_effect` if we encounter a branch that\n+\t\t// is already MAYBE_DIRTY.",
        "comment_created_at": "2024-09-17T16:45:02+00:00",
        "comment_author": "trueadm",
        "comment_body": "I added `EFFECT_HAS_DIRTY_CHILDREN`. Feel free to refactor `process_effects` as I'm in the middle of another rabbit hole.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1817879625",
    "pr_number": 13951,
    "pr_file": "packages/svelte/src/reactivity/map.js",
    "created_at": "2024-10-26T16:16:57+00:00",
    "commented_code": "increment(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1817879625",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T16:16:57+00:00",
        "comment_author": "trueadm",
        "comment_body": "If you make a `Set` out of `version.reactions` then this will only be an O(n) operation.",
        "pr_file_module": null
      },
      {
        "comment_id": "1817879887",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T16:18:44+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "I thought of this but didn't want to touch too much without validating this idea first...do you think it's the right approach?",
        "pr_file_module": null
      },
      {
        "comment_id": "1817880275",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T16:21:41+00:00",
        "comment_author": "trueadm",
        "comment_body": "Yes, I actually thought about doing this when I first implemented the fix. Then I couldn't find I test case where it mattered, so I went for the simpler approach. So clearly the more complex was needed after-all. I used a Set to improve the performance \u2013 but only if `version.reactions` was not null, otherwise I did a short path that avoided any iterations entirely.",
        "pr_file_module": null
      },
      {
        "comment_id": "1817880719",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T16:24:30+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "Ok let me do it now",
        "pr_file_module": null
      },
      {
        "comment_id": "1817891052",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T17:03:47+00:00",
        "comment_author": "trueadm",
        "comment_body": "Sorry, I didn't mean changing `reactions` to a Set, I meant locally making a Set of the array and using that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1817891351",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T17:06:52+00:00",
        "comment_author": "trueadm",
        "comment_body": "I was thinking:\r\n\r\n```js\r\nvar v_reactions = version.reactions === null ? null : new Set(version.reactions)\r\nvar needs_version_increase = v_reactions === null || !s.reactions?.every((r) => v_reactions.has(r));\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1817891518",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13951,
        "pr_file": "packages/svelte/src/reactivity/map.js",
        "discussion_id": "1817879625",
        "commented_code": "@@ -102,12 +103,10 @@ export class SvelteMap extends Map {\n \t\t\tincrement(version);\n \t\t} else if (prev_res !== value) {\n \t\t\tincrement(s);\n-\t\t\t// If no one listening to this property and is listening to the version, or\n-\t\t\t// the inverse, then we should increment the version to be safe\n-\t\t\tif (\n-\t\t\t\t(s.reactions === null && version.reactions !== null) ||\n-\t\t\t\t(s.reactions !== null && version.reactions === null)\n-\t\t\t) {\n+\n+\t\t\t// if not every reaction of s is a reaction of version we need to also include version\n+\t\t\tconst needs_version_increase = !s.reactions?.every((r) => version.reactions?.includes(r));",
        "comment_created_at": "2024-10-26T17:08:12+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "Ohhh gotcha",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1765757482",
    "pr_number": 13315,
    "pr_file": "packages/svelte/src/internal/client/runtime.js",
    "created_at": "2024-09-18T21:41:47+00:00",
    "commented_code": "main_loop: while (current_effect !== null) {\n \t\tvar flags = current_effect.f;\n-\t\tvar is_active = (flags & INERT) === 0;\n \t\tvar is_branch = (flags & BRANCH_EFFECT) !== 0;\n-\t\tvar is_clean = (flags & CLEAN) !== 0;\n-\t\tvar child = current_effect.first;\n+\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1765757482",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13315,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1765757482",
        "commented_code": "@@ -624,23 +618,21 @@ function process_effects(effect, collected_effects) {\n \n \tmain_loop: while (current_effect !== null) {\n \t\tvar flags = current_effect.f;\n-\t\tvar is_active = (flags & INERT) === 0;\n \t\tvar is_branch = (flags & BRANCH_EFFECT) !== 0;\n-\t\tvar is_clean = (flags & CLEAN) !== 0;\n-\t\tvar child = current_effect.first;\n+\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;",
        "comment_created_at": "2024-09-18T21:41:47+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "we could do this instead which would presumably be a tiny bit faster, but less readable\r\n\r\n```suggestion\r\n\t\tvar is_skippable_branch = (flags & (CLEAN | BRANCH_EFFECT)) === (CLEAN | BRANCH_EFFECT);\r\n```",
        "pr_file_module": null
      }
    ]
  }
]