[
  {
    "discussion_id": "2160099295",
    "pr_number": 16171,
    "pr_file": "packages/svelte/src/internal/client/dom/blocks/boundary.js",
    "created_at": "2025-06-21T17:44:11+00:00",
    "commented_code": "did_reset = true;\n \n+\t\t\t\tif (calling_on_error) {\n+\t\t\t\t\tw.reset_misuse();\n+\t\t\t\t\tthrow error;\n+\t\t\t\t}\n+\n \t\t\t\tpause_effect(boundary_effect);\n \n \t\t\t\twith_boundary(boundary, () => {\n \t\t\t\t\tis_creating_fallback = false;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tboundary_effect = branch(() => boundary_fn(anchor));\n-\t\t\t\t\t} catch (error) {\n-\t\t\t\t\t\t// If the new subtree immediately throws during mount, warn the dev.\n-\t\t\t\t\t\tw.reset_misuse();\n-\t\t\t\t\t\tthrow error;\n-\t\t\t\t\t}\n+\t\t\t\t\tboundary_effect = branch(() => boundary_fn(anchor));\n \t\t\t\t});\n \t\t\t};\n \n \t\t\tvar previous_reaction = active_reaction;\n \n \t\t\ttry {\n \t\t\t\tset_active_reaction(null);\n+\t\t\t\tcalling_on_error = true;\n \t\t\t\tonerror?.(error, reset);",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2160099295",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 16171,
        "pr_file": "packages/svelte/src/internal/client/dom/blocks/boundary.js",
        "discussion_id": "2160099295",
        "commented_code": "@@ -84,37 +95,30 @@ export function boundary(node, props, boundary_fn) {\n \n \t\t\t\tdid_reset = true;\n \n+\t\t\t\tif (calling_on_error) {\n+\t\t\t\t\tw.reset_misuse();\n+\t\t\t\t\tthrow error;\n+\t\t\t\t}\n+\n \t\t\t\tpause_effect(boundary_effect);\n \n \t\t\t\twith_boundary(boundary, () => {\n \t\t\t\t\tis_creating_fallback = false;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tboundary_effect = branch(() => boundary_fn(anchor));\n-\t\t\t\t\t} catch (error) {\n-\t\t\t\t\t\t// If the new subtree immediately throws during mount, warn the dev.\n-\t\t\t\t\t\tw.reset_misuse();\n-\t\t\t\t\t\tthrow error;\n-\t\t\t\t\t}\n+\t\t\t\t\tboundary_effect = branch(() => boundary_fn(anchor));\n \t\t\t\t});\n \t\t\t};\n \n \t\t\tvar previous_reaction = active_reaction;\n \n \t\t\ttry {\n \t\t\t\tset_active_reaction(null);\n+\t\t\t\tcalling_on_error = true;\n \t\t\t\tonerror?.(error, reset);",
        "comment_created_at": "2025-06-21T17:44:11+00:00",
        "comment_author": "raythurnvoid",
        "comment_body": "@Rich-Harris People might want to auto-fix the state of the application inside the onerror for instance they might decide to show an error snackbar and reset a form without any confirmation from the user",
        "pr_file_module": null
      },
      {
        "comment_id": "2161242976",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 16171,
        "pr_file": "packages/svelte/src/internal/client/dom/blocks/boundary.js",
        "discussion_id": "2160099295",
        "commented_code": "@@ -84,37 +95,30 @@ export function boundary(node, props, boundary_fn) {\n \n \t\t\t\tdid_reset = true;\n \n+\t\t\t\tif (calling_on_error) {\n+\t\t\t\t\tw.reset_misuse();\n+\t\t\t\t\tthrow error;\n+\t\t\t\t}\n+\n \t\t\t\tpause_effect(boundary_effect);\n \n \t\t\t\twith_boundary(boundary, () => {\n \t\t\t\t\tis_creating_fallback = false;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tboundary_effect = branch(() => boundary_fn(anchor));\n-\t\t\t\t\t} catch (error) {\n-\t\t\t\t\t\t// If the new subtree immediately throws during mount, warn the dev.\n-\t\t\t\t\t\tw.reset_misuse();\n-\t\t\t\t\t\tthrow error;\n-\t\t\t\t\t}\n+\t\t\t\t\tboundary_effect = branch(() => boundary_fn(anchor));\n \t\t\t\t});\n \t\t\t};\n \n \t\t\tvar previous_reaction = active_reaction;\n \n \t\t\ttry {\n \t\t\t\tset_active_reaction(null);\n+\t\t\t\tcalling_on_error = true;\n \t\t\t\tonerror?.(error, reset);",
        "comment_created_at": "2025-06-23T10:17:10+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "It won't work \u2014 the update is still in progress and everything gets torn. The `svelte_boundary_reset_onerror` message has an example of fixing it by waiting for a `tick()` before calling `reset()`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2042384618",
    "pr_number": 15494,
    "pr_file": "packages/svelte/src/compiler/phases/scope.js",
    "created_at": "2025-04-14T15:22:31+00:00",
    "commented_code": "}\n }\n \n+class Evaluation {\n+\t/** @type {Set<any>} */\n+\tvalues = new Set();\n+\n+\t/**\n+\t * True if there is exactly one possible value\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_known = true;\n+\n+\t/**\n+\t * True if the value is known to not be null/undefined\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_defined = true;\n+\n+\t/**\n+\t * True if the value is known to be a string\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_string = true;\n+\n+\t/**\n+\t * True if the value is known to be a number\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_number = true;\n+\n+\t/**\n+\t * @readonly\n+\t * @type {any}\n+\t */\n+\tvalue = undefined;\n+\n+\t/**\n+\t *\n+\t * @param {Scope} scope\n+\t * @param {Expression} expression\n+\t */\n+\tconstructor(scope, expression) {\n+\t\tswitch (expression.type) {\n+\t\t\tcase 'Literal':\n+\t\t\t\tthis.values.add(expression.value);\n+\t\t\t\tbreak;\n+\n+\t\t\tcase 'Identifier':\n+\t\t\t\tvar binding = scope.get(expression.name);\n+\n+\t\t\t\tif (binding) {\n+\t\t\t\t\tif (\n+\t\t\t\t\t\tbinding.initial?.type === 'CallExpression' &&\n+\t\t\t\t\t\tget_rune(binding.initial, scope) === '$props.id'\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tthis.values.add(STRING);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst is_prop =\n+\t\t\t\t\t\tbinding.kind === 'prop' ||\n+\t\t\t\t\t\tbinding.kind === 'rest_prop' ||\n+\t\t\t\t\t\tbinding.kind === 'bindable_prop';\n+\n+\t\t\t\t\tif (!binding.updated && binding.initial !== null && !is_prop) {\n+\t\t\t\t\t\tconst evaluation = binding.scope.evaluate(/** @type {Expression} */ (binding.initial));\n+\t\t\t\t\t\tfor (const value of evaluation.values) {\n+\t\t\t\t\t\t\tthis.values.add(value);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// TODO each index is always defined\n+\t\t\t\t}\n+\n+\t\t\t\t// TODO glean what we can from reassignments\n+\t\t\t\t// TODO one day, expose props and imports somehow\n+\n+\t\t\t\tthis.values.add(UNKNOWN);\n+\t\t\t\tbreak;\n+\n+\t\t\tcase 'BinaryExpression':\n+\t\t\t\tvar a = scope.evaluate(/** @type {Expression} */ (expression.left)); // `left` cannot be `PrivateIdentifier` unless operator is `in`\n+\t\t\t\tvar b = scope.evaluate(expression.right);\n+\n+\t\t\t\tif (a.is_known && b.is_known) {\n+\t\t\t\t\tthis.values.add(binary[expression.operator](a.value, b.value));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (expression.operator) {\n+\t\t\t\t\tcase '!=':\n+\t\t\t\t\tcase '!==':\n+\t\t\t\t\tcase '<':\n+\t\t\t\t\tcase '<=':\n+\t\t\t\t\tcase '>':\n+\t\t\t\t\tcase '>=':\n+\t\t\t\t\tcase '==':\n+\t\t\t\t\tcase '===':\n+\t\t\t\t\tcase 'in':\n+\t\t\t\t\tcase 'instanceof':\n+\t\t\t\t\t\tthis.values.add(true);\n+\t\t\t\t\t\tthis.values.add(false);\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase '%':\n+\t\t\t\t\tcase '&':\n+\t\t\t\t\tcase '*':\n+\t\t\t\t\tcase '**':\n+\t\t\t\t\tcase '-':\n+\t\t\t\t\tcase '/':\n+\t\t\t\t\tcase '<<':\n+\t\t\t\t\tcase '>>':\n+\t\t\t\t\tcase '>>>':\n+\t\t\t\t\tcase '^':\n+\t\t\t\t\tcase '|':\n+\t\t\t\t\t\tthis.values.add(NUMBER);\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase '+':\n+\t\t\t\t\t\tif (a.is_string || b.is_string) {\n+\t\t\t\t\t\t\tthis.values.add(STRING);\n+\t\t\t\t\t\t} else if (a.is_number && b.is_number) {\n+\t\t\t\t\t\t\tthis.values.add(NUMBER);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tthis.values.add(STRING);\n+\t\t\t\t\t\t\tthis.values.add(NUMBER);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\t// @ts-expect-error we can't guard against future operators without\n+\t\t\t\t\t\t// TypeScript getting confused\n+\t\t\t\t\t\tthrow new Error(`Unknown operator ${expression.operator}`);",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2042384618",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15494,
        "pr_file": "packages/svelte/src/compiler/phases/scope.js",
        "discussion_id": "2042384618",
        "commented_code": "@@ -100,6 +104,261 @@ export class Binding {\n \t}\n }\n \n+class Evaluation {\n+\t/** @type {Set<any>} */\n+\tvalues = new Set();\n+\n+\t/**\n+\t * True if there is exactly one possible value\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_known = true;\n+\n+\t/**\n+\t * True if the value is known to not be null/undefined\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_defined = true;\n+\n+\t/**\n+\t * True if the value is known to be a string\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_string = true;\n+\n+\t/**\n+\t * True if the value is known to be a number\n+\t * @readonly\n+\t * @type {boolean}\n+\t */\n+\tis_number = true;\n+\n+\t/**\n+\t * @readonly\n+\t * @type {any}\n+\t */\n+\tvalue = undefined;\n+\n+\t/**\n+\t *\n+\t * @param {Scope} scope\n+\t * @param {Expression} expression\n+\t */\n+\tconstructor(scope, expression) {\n+\t\tswitch (expression.type) {\n+\t\t\tcase 'Literal':\n+\t\t\t\tthis.values.add(expression.value);\n+\t\t\t\tbreak;\n+\n+\t\t\tcase 'Identifier':\n+\t\t\t\tvar binding = scope.get(expression.name);\n+\n+\t\t\t\tif (binding) {\n+\t\t\t\t\tif (\n+\t\t\t\t\t\tbinding.initial?.type === 'CallExpression' &&\n+\t\t\t\t\t\tget_rune(binding.initial, scope) === '$props.id'\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tthis.values.add(STRING);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst is_prop =\n+\t\t\t\t\t\tbinding.kind === 'prop' ||\n+\t\t\t\t\t\tbinding.kind === 'rest_prop' ||\n+\t\t\t\t\t\tbinding.kind === 'bindable_prop';\n+\n+\t\t\t\t\tif (!binding.updated && binding.initial !== null && !is_prop) {\n+\t\t\t\t\t\tconst evaluation = binding.scope.evaluate(/** @type {Expression} */ (binding.initial));\n+\t\t\t\t\t\tfor (const value of evaluation.values) {\n+\t\t\t\t\t\t\tthis.values.add(value);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// TODO each index is always defined\n+\t\t\t\t}\n+\n+\t\t\t\t// TODO glean what we can from reassignments\n+\t\t\t\t// TODO one day, expose props and imports somehow\n+\n+\t\t\t\tthis.values.add(UNKNOWN);\n+\t\t\t\tbreak;\n+\n+\t\t\tcase 'BinaryExpression':\n+\t\t\t\tvar a = scope.evaluate(/** @type {Expression} */ (expression.left)); // `left` cannot be `PrivateIdentifier` unless operator is `in`\n+\t\t\t\tvar b = scope.evaluate(expression.right);\n+\n+\t\t\t\tif (a.is_known && b.is_known) {\n+\t\t\t\t\tthis.values.add(binary[expression.operator](a.value, b.value));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (expression.operator) {\n+\t\t\t\t\tcase '!=':\n+\t\t\t\t\tcase '!==':\n+\t\t\t\t\tcase '<':\n+\t\t\t\t\tcase '<=':\n+\t\t\t\t\tcase '>':\n+\t\t\t\t\tcase '>=':\n+\t\t\t\t\tcase '==':\n+\t\t\t\t\tcase '===':\n+\t\t\t\t\tcase 'in':\n+\t\t\t\t\tcase 'instanceof':\n+\t\t\t\t\t\tthis.values.add(true);\n+\t\t\t\t\t\tthis.values.add(false);\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase '%':\n+\t\t\t\t\tcase '&':\n+\t\t\t\t\tcase '*':\n+\t\t\t\t\tcase '**':\n+\t\t\t\t\tcase '-':\n+\t\t\t\t\tcase '/':\n+\t\t\t\t\tcase '<<':\n+\t\t\t\t\tcase '>>':\n+\t\t\t\t\tcase '>>>':\n+\t\t\t\t\tcase '^':\n+\t\t\t\t\tcase '|':\n+\t\t\t\t\t\tthis.values.add(NUMBER);\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tcase '+':\n+\t\t\t\t\t\tif (a.is_string || b.is_string) {\n+\t\t\t\t\t\t\tthis.values.add(STRING);\n+\t\t\t\t\t\t} else if (a.is_number && b.is_number) {\n+\t\t\t\t\t\t\tthis.values.add(NUMBER);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tthis.values.add(STRING);\n+\t\t\t\t\t\t\tthis.values.add(NUMBER);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\t// @ts-expect-error we can't guard against future operators without\n+\t\t\t\t\t\t// TypeScript getting confused\n+\t\t\t\t\t\tthrow new Error(`Unknown operator ${expression.operator}`);",
        "comment_created_at": "2025-04-14T15:22:31+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "I'd rather have us warn here and add `UNKNOWN`, else people might be stuck with not using certain operators once they land if they can't upgrade to a version that supports it (people could be on v5 and we only add the operator in v6)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1835174996",
    "pr_number": 14211,
    "pr_file": "packages/svelte/src/internal/client/runtime.js",
    "created_at": "2024-11-09T00:28:41+00:00",
    "commented_code": "return false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1835174996",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-09T00:28:41+00:00",
        "comment_author": "AbhiPrasad",
        "comment_body": "Technically throwing non-error objects still works in this scenario, which means that typing `error` as an `Error` is strictly not correct. The react `componentDidCatch` lifecycle hook used to do this, and it's fixing it's types to be `unknown` in it's next major: https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/69436#discussion-6555763.\r\n\r\nIf you do something like `throw 123;` you end up getting an error thrown by this code:\r\n\r\n```\r\nWeakSet value 123 must be an object\r\n  \r\n  in $effect.pre\r\n  in ChildThird.svelte\r\n  in ChildSecond.svelte\r\n  in ChildFirst.svelte\r\n  in App.svelte\r\n\r\nhandle_error@playground:output:1585:18 update_effect@playground:output:1804:16 process_effects@playground:output:1980:22 flush_queued_root_effects@playground:output:1863:20 process_deferred@playground:output:1916:28 handle_error@playground:output:1585:18 update_effect@playground:output:1804:16 process_effects@playground:output:1980:22 flush_queued_root_effects@playground:output:1863:20 process_deferred@playground:output:1916:28\r\n```\r\n\r\nshould we try to guard against this here? It also means that accessing error properties in `onerror` might causing more errors to be thrown.\r\n\r\nIf we do end up guarding it here, we might have to make `onerror` take `unknown` instead of `Error` as it's first argument. This is something I PR'd into React earlier this year, it's going to be fixed with the next React major: https://github.com/DefinitelyTyped/DefinitelyTyped/pull/69434",
        "pr_file_module": null
      },
      {
        "comment_id": "1835332211",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-09T10:03:31+00:00",
        "comment_author": "trueadm",
        "comment_body": "Good point. We now only handle errors only and with anything else we re-throw them.",
        "pr_file_module": null
      },
      {
        "comment_id": "1835391059",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-09T14:04:08+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "I think that's the wrong conclusion. If something is thrown we catch it, no exceptions (ha). So I'd rather adjust the catch logic to not have a stack in that case and also adjust the types to `unknown`",
        "pr_file_module": null
      },
      {
        "comment_id": "1835477108",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-09T17:34:34+00:00",
        "comment_author": "trueadm",
        "comment_body": "It\u2019s a bit more complicated than that we use the WeakSet to avoid re-applying propagation on the error. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1836579394",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-11T12:14:35+00:00",
        "comment_author": "trueadm",
        "comment_body": "We could allow objects to be thrown with this, but I can't see any way we can make this work with primitives. I considered using a Map, but there's no ideal place to clear the Map without possibly causing other problems?",
        "pr_file_module": null
      },
      {
        "comment_id": "1836754097",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-11T14:28:06+00:00",
        "comment_author": "trueadm",
        "comment_body": "Actually I have another approach, will push that now.",
        "pr_file_module": null
      },
      {
        "comment_id": "1836789994",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-11T14:44:58+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "Just as a thought: What if we wrap non-errors in an error object and put the original on some property? Or does that mess with user expectations too much? Not sure if doing that would help you have nicer/smaller logic in the code. It would at least help with attaching a stack, though that's probably not the most important thing.\r\n(feel free to resolve the conversation again if you think what we have now is better than wrapping the error)",
        "pr_file_module": null
      },
      {
        "comment_id": "1836808632",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14211,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1835174996",
        "commented_code": "@@ -228,15 +229,63 @@ export function check_dirtiness(reaction) {\n \treturn false;\n }\n \n+/**\n+ * @param {Error} error\n+ * @param {Effect} effect\n+ */\n+function propagate_error(error, effect) {\n+\t/** @type {Effect | null} */\n+\tvar current = effect;\n+\twhile (current !== null) {\n+\t\t/** @type {Effect | null} */\n+\t\tvar parent = current.parent;\n+\n+\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n+\t\t\ttry {\n+\t\t\t\t// @ts-ignore\n+\t\t\t\tcurrent.fn(error);\n+\t\t\t} catch {\n+\t\t\t\t// Remove boundary flag from effect\n+\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n+\t\t\t\tcurrent = parent;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tcurrent = parent;\n+\t}\n+\n+\tthrow error;\n+}\n+\n+/**\n+ * @param {Effect} effect\n+ */\n+function should_rethrow_error(effect) {\n+\treturn (\n+\t\t(effect.f & DESTROYED) === 0 &&\n+\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n+\t);\n+}\n+\n /**\n  * @param {Error} error\n  * @param {Effect} effect\n  * @param {ComponentContext | null} component_context\n  */\n-function handle_error(error, effect, component_context) {\n-\t// Given we don't yet have error boundaries, we will just always throw.\n-\tif (!DEV || handled_errors.has(error) || component_context === null) {\n-\t\tthrow error;\n+export function handle_error(error, effect, component_context) {\n+\tif (handled_errors.has(error)) {\n+\t\tif (should_rethrow_error(effect)) {\n+\t\t\tthrow error;\n+\t\t}\n+\t\treturn;\n+\t}\n+\n+\thandled_errors.add(error);",
        "comment_created_at": "2024-11-11T14:57:42+00:00",
        "comment_author": "trueadm",
        "comment_body": "I considered that, but it had the unfortunate side-effect of us needing to ensure we unwrapped the error again in all the different places that it can escape. So it ended up adding just as much code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1756370730",
    "pr_number": 13216,
    "pr_file": "packages/svelte/src/internal/client/dev/equality.js",
    "created_at": "2024-09-12T08:17:17+00:00",
    "commented_code": "* @returns {boolean}\n  */\n export function strict_equals(a, b, equal = true) {\n-\tif ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {\n-\t\tw.state_proxy_equality_mismatch(equal ? '===' : '!==');\n-\t}\n+\ttry {",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1756370730",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13216,
        "pr_file": "packages/svelte/src/internal/client/dev/equality.js",
        "discussion_id": "1756370730",
        "commented_code": "@@ -78,9 +78,11 @@ export function init_array_prototype_warnings() {\n  * @returns {boolean}\n  */\n export function strict_equals(a, b, equal = true) {\n-\tif ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {\n-\t\tw.state_proxy_equality_mismatch(equal ? '===' : '!==');\n-\t}\n+\ttry {",
        "comment_created_at": "2024-09-12T08:17:17+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\n\t// try-catch needed because this tries to read properties of `a` and `b`,\r\n\t// which could be disallowed for example in a secure context\r\n\ttry {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1732451500",
    "pr_number": 13034,
    "pr_file": "packages/svelte/src/internal/server/index.js",
    "created_at": "2024-08-27T09:14:06+00:00",
    "commented_code": "on_destroy = [];\n \tpayload.out += BLOCK_OPEN;\n \n+\t// prevent parent/child element state being corrupted by a bad render\n+\treset_elements();",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1732451500",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13034,
        "pr_file": "packages/svelte/src/internal/server/index.js",
        "discussion_id": "1732451500",
        "commented_code": "@@ -100,6 +101,9 @@ export function render(component, options = {}) {\n \ton_destroy = [];\n \tpayload.out += BLOCK_OPEN;\n \n+\t// prevent parent/child element state being corrupted by a bad render\n+\treset_elements();",
        "comment_created_at": "2024-08-27T09:14:06+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\n\tif (DEV) {\r\n\t\t// prevent parent/child element state being corrupted by a bad render\r\n\t\treset_elements();\r\n\t}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]