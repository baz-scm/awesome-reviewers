[
  {
    "discussion_id": "1911787183",
    "pr_number": 14799,
    "pr_file": "documentation/docs/98-reference/21-svelte-reactivity.md",
    "created_at": "2025-01-11T01:17:48+00:00",
    "commented_code": "<input bind:value={url.href} />\n ```\n \n+The utilities provided in `svelte/reactivity` are automatically reactive with respect to their properties and methods, as seen in the previous example. As such, they don't need to be wrapped in `$state`. However, if a variable is reassigned, it needs to be wrapped in a `$state` in order for this reassignement to be reactive.\n+\n+```svelte\n+<script>\n+\timport { SvelteURL } from 'svelte/reactivity';\n+\n+\tlet url = $state(new SvelteURL('https://example.com/path'));\n+</script>\n+\n+<!-- these are reactive... -->\n+Protocol: {url?.protocol ?? \"ftp:\"}\n+<br>\n+Hostname: {url?.hostname ?? \"svelte.dev\"}\n+<br>\n+Path: {url?.pathname ?? \"\"}\n+\n+<hr />\n+\n+<!-- ...even when reassigning -->\n+<button\n+\tonclick={() => {\n+\t\turl = undefined;\n+\t}}\n+>\n+\tErase\n+</button>\n+```\n+\n+In a similar manner, the values stored inside e.g. `SvelteMap` are not automatically reactive, so if more complex values such as objects are used, they need to be wrapped in a `$state` in order to make their properties reactive as well. Alternatively, the whole object can be rewritten on update, which may actually lead to better performance than deep reactive `$state`.\n+\n+```svelte\n+<script>\n+\timport { SvelteMap } from 'svelte/reactivity';\n+\n+\tconst people = new SvelteMap();\n+\n+\tconst alice = {name: \"Alice\", age: 18};\n+\tpeople.set(\"alice\", alice);\n+\n+\tconst bob = $state({name: \"Bob\", age: 21});\n+\tpeople.set(\"bob\", bob);\n+</script>\n+\n+{#each people.entries() as [id, person] (id)}\n+\tName: {person.name}\n+\t<br>\n+\tAge: {person.age}\n+\t<br>\n+\t<br>\n+{/each}\n+\n+<hr />\n+\n+<!-- This will NOT propagate reactively -->\n+<button\n+\tonclick={() => {\n+\t\tpeople.get(\"alice\").age++;\n+\t}}\n+>\n+\tAlice's birthday\n+</button>\n+\n+<!-- This WILL propagate reactively -->",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1911787183",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14799,
        "pr_file": "documentation/docs/98-reference/21-svelte-reactivity.md",
        "discussion_id": "1911787183",
        "commented_code": "@@ -22,4 +22,97 @@ Svelte provides reactive versions of various built-ins like `SvelteMap`, `Svelte\n <input bind:value={url.href} />\n ```\n \n+The utilities provided in `svelte/reactivity` are automatically reactive with respect to their properties and methods, as seen in the previous example. As such, they don't need to be wrapped in `$state`. However, if a variable is reassigned, it needs to be wrapped in a `$state` in order for this reassignement to be reactive.\n+\n+```svelte\n+<script>\n+\timport { SvelteURL } from 'svelte/reactivity';\n+\n+\tlet url = $state(new SvelteURL('https://example.com/path'));\n+</script>\n+\n+<!-- these are reactive... -->\n+Protocol: {url?.protocol ?? \"ftp:\"}\n+<br>\n+Hostname: {url?.hostname ?? \"svelte.dev\"}\n+<br>\n+Path: {url?.pathname ?? \"\"}\n+\n+<hr />\n+\n+<!-- ...even when reassigning -->\n+<button\n+\tonclick={() => {\n+\t\turl = undefined;\n+\t}}\n+>\n+\tErase\n+</button>\n+```\n+\n+In a similar manner, the values stored inside e.g. `SvelteMap` are not automatically reactive, so if more complex values such as objects are used, they need to be wrapped in a `$state` in order to make their properties reactive as well. Alternatively, the whole object can be rewritten on update, which may actually lead to better performance than deep reactive `$state`.\n+\n+```svelte\n+<script>\n+\timport { SvelteMap } from 'svelte/reactivity';\n+\n+\tconst people = new SvelteMap();\n+\n+\tconst alice = {name: \"Alice\", age: 18};\n+\tpeople.set(\"alice\", alice);\n+\n+\tconst bob = $state({name: \"Bob\", age: 21});\n+\tpeople.set(\"bob\", bob);\n+</script>\n+\n+{#each people.entries() as [id, person] (id)}\n+\tName: {person.name}\n+\t<br>\n+\tAge: {person.age}\n+\t<br>\n+\t<br>\n+{/each}\n+\n+<hr />\n+\n+<!-- This will NOT propagate reactively -->\n+<button\n+\tonclick={() => {\n+\t\tpeople.get(\"alice\").age++;\n+\t}}\n+>\n+\tAlice's birthday\n+</button>\n+\n+<!-- This WILL propagate reactively -->",
        "comment_created_at": "2025-01-11T01:17:48+00:00",
        "comment_author": "taitulism",
        "comment_body": "I believe this should be \"will NOT\", like with Alice , no?\r\n![image](https://github.com/user-attachments/assets/703d2458-158d-4662-b2c0-29a5ee335f3b)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1911794281",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14799,
        "pr_file": "documentation/docs/98-reference/21-svelte-reactivity.md",
        "discussion_id": "1911787183",
        "commented_code": "@@ -22,4 +22,97 @@ Svelte provides reactive versions of various built-ins like `SvelteMap`, `Svelte\n <input bind:value={url.href} />\n ```\n \n+The utilities provided in `svelte/reactivity` are automatically reactive with respect to their properties and methods, as seen in the previous example. As such, they don't need to be wrapped in `$state`. However, if a variable is reassigned, it needs to be wrapped in a `$state` in order for this reassignement to be reactive.\n+\n+```svelte\n+<script>\n+\timport { SvelteURL } from 'svelte/reactivity';\n+\n+\tlet url = $state(new SvelteURL('https://example.com/path'));\n+</script>\n+\n+<!-- these are reactive... -->\n+Protocol: {url?.protocol ?? \"ftp:\"}\n+<br>\n+Hostname: {url?.hostname ?? \"svelte.dev\"}\n+<br>\n+Path: {url?.pathname ?? \"\"}\n+\n+<hr />\n+\n+<!-- ...even when reassigning -->\n+<button\n+\tonclick={() => {\n+\t\turl = undefined;\n+\t}}\n+>\n+\tErase\n+</button>\n+```\n+\n+In a similar manner, the values stored inside e.g. `SvelteMap` are not automatically reactive, so if more complex values such as objects are used, they need to be wrapped in a `$state` in order to make their properties reactive as well. Alternatively, the whole object can be rewritten on update, which may actually lead to better performance than deep reactive `$state`.\n+\n+```svelte\n+<script>\n+\timport { SvelteMap } from 'svelte/reactivity';\n+\n+\tconst people = new SvelteMap();\n+\n+\tconst alice = {name: \"Alice\", age: 18};\n+\tpeople.set(\"alice\", alice);\n+\n+\tconst bob = $state({name: \"Bob\", age: 21});\n+\tpeople.set(\"bob\", bob);\n+</script>\n+\n+{#each people.entries() as [id, person] (id)}\n+\tName: {person.name}\n+\t<br>\n+\tAge: {person.age}\n+\t<br>\n+\t<br>\n+{/each}\n+\n+<hr />\n+\n+<!-- This will NOT propagate reactively -->\n+<button\n+\tonclick={() => {\n+\t\tpeople.get(\"alice\").age++;\n+\t}}\n+>\n+\tAlice's birthday\n+</button>\n+\n+<!-- This WILL propagate reactively -->",
        "comment_created_at": "2025-01-11T01:36:10+00:00",
        "comment_author": "Leonidaz",
        "comment_body": "changes to bob will be reactive because the value of the map's \"bob\" is a deeply reactive signal via `$state()`",
        "pr_file_module": null
      },
      {
        "comment_id": "1911964656",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14799,
        "pr_file": "documentation/docs/98-reference/21-svelte-reactivity.md",
        "discussion_id": "1911787183",
        "commented_code": "@@ -22,4 +22,97 @@ Svelte provides reactive versions of various built-ins like `SvelteMap`, `Svelte\n <input bind:value={url.href} />\n ```\n \n+The utilities provided in `svelte/reactivity` are automatically reactive with respect to their properties and methods, as seen in the previous example. As such, they don't need to be wrapped in `$state`. However, if a variable is reassigned, it needs to be wrapped in a `$state` in order for this reassignement to be reactive.\n+\n+```svelte\n+<script>\n+\timport { SvelteURL } from 'svelte/reactivity';\n+\n+\tlet url = $state(new SvelteURL('https://example.com/path'));\n+</script>\n+\n+<!-- these are reactive... -->\n+Protocol: {url?.protocol ?? \"ftp:\"}\n+<br>\n+Hostname: {url?.hostname ?? \"svelte.dev\"}\n+<br>\n+Path: {url?.pathname ?? \"\"}\n+\n+<hr />\n+\n+<!-- ...even when reassigning -->\n+<button\n+\tonclick={() => {\n+\t\turl = undefined;\n+\t}}\n+>\n+\tErase\n+</button>\n+```\n+\n+In a similar manner, the values stored inside e.g. `SvelteMap` are not automatically reactive, so if more complex values such as objects are used, they need to be wrapped in a `$state` in order to make their properties reactive as well. Alternatively, the whole object can be rewritten on update, which may actually lead to better performance than deep reactive `$state`.\n+\n+```svelte\n+<script>\n+\timport { SvelteMap } from 'svelte/reactivity';\n+\n+\tconst people = new SvelteMap();\n+\n+\tconst alice = {name: \"Alice\", age: 18};\n+\tpeople.set(\"alice\", alice);\n+\n+\tconst bob = $state({name: \"Bob\", age: 21});\n+\tpeople.set(\"bob\", bob);\n+</script>\n+\n+{#each people.entries() as [id, person] (id)}\n+\tName: {person.name}\n+\t<br>\n+\tAge: {person.age}\n+\t<br>\n+\t<br>\n+{/each}\n+\n+<hr />\n+\n+<!-- This will NOT propagate reactively -->\n+<button\n+\tonclick={() => {\n+\t\tpeople.get(\"alice\").age++;\n+\t}}\n+>\n+\tAlice's birthday\n+</button>\n+\n+<!-- This WILL propagate reactively -->",
        "comment_created_at": "2025-01-11T10:59:43+00:00",
        "comment_author": "marekdedic",
        "comment_body": "Agree wit @Leonidaz, the big difference is here:\r\n\r\n![image](https://github.com/user-attachments/assets/981fa152-79a6-41aa-a6c3-783b9f077fe1)\r\n\r\nbut maybe this is a sign that the explanation is not clear enough, @taitulism any tips for what would make it clearer?",
        "pr_file_module": null
      },
      {
        "comment_id": "1912020415",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14799,
        "pr_file": "documentation/docs/98-reference/21-svelte-reactivity.md",
        "discussion_id": "1911787183",
        "commented_code": "@@ -22,4 +22,97 @@ Svelte provides reactive versions of various built-ins like `SvelteMap`, `Svelte\n <input bind:value={url.href} />\n ```\n \n+The utilities provided in `svelte/reactivity` are automatically reactive with respect to their properties and methods, as seen in the previous example. As such, they don't need to be wrapped in `$state`. However, if a variable is reassigned, it needs to be wrapped in a `$state` in order for this reassignement to be reactive.\n+\n+```svelte\n+<script>\n+\timport { SvelteURL } from 'svelte/reactivity';\n+\n+\tlet url = $state(new SvelteURL('https://example.com/path'));\n+</script>\n+\n+<!-- these are reactive... -->\n+Protocol: {url?.protocol ?? \"ftp:\"}\n+<br>\n+Hostname: {url?.hostname ?? \"svelte.dev\"}\n+<br>\n+Path: {url?.pathname ?? \"\"}\n+\n+<hr />\n+\n+<!-- ...even when reassigning -->\n+<button\n+\tonclick={() => {\n+\t\turl = undefined;\n+\t}}\n+>\n+\tErase\n+</button>\n+```\n+\n+In a similar manner, the values stored inside e.g. `SvelteMap` are not automatically reactive, so if more complex values such as objects are used, they need to be wrapped in a `$state` in order to make their properties reactive as well. Alternatively, the whole object can be rewritten on update, which may actually lead to better performance than deep reactive `$state`.\n+\n+```svelte\n+<script>\n+\timport { SvelteMap } from 'svelte/reactivity';\n+\n+\tconst people = new SvelteMap();\n+\n+\tconst alice = {name: \"Alice\", age: 18};\n+\tpeople.set(\"alice\", alice);\n+\n+\tconst bob = $state({name: \"Bob\", age: 21});\n+\tpeople.set(\"bob\", bob);\n+</script>\n+\n+{#each people.entries() as [id, person] (id)}\n+\tName: {person.name}\n+\t<br>\n+\tAge: {person.age}\n+\t<br>\n+\t<br>\n+{/each}\n+\n+<hr />\n+\n+<!-- This will NOT propagate reactively -->\n+<button\n+\tonclick={() => {\n+\t\tpeople.get(\"alice\").age++;\n+\t}}\n+>\n+\tAlice's birthday\n+</button>\n+\n+<!-- This WILL propagate reactively -->",
        "comment_created_at": "2025-01-11T12:46:48+00:00",
        "comment_author": "taitulism",
        "comment_body": "I think I missed the assignment difference because both seem generally the same on a quick skim (line length wise).\r\n\r\nTo make it clearer I would:\r\n```js\r\n\t// reactive object\r\n\tconst alice = $state({name: \"Alice\", age: 18}); \r\n\t\r\n\t// plain object\r\n\tconst bob = {name: \"Bob\", age: 21};\r\n\r\n\tpeople.set(\"alice\", alice);\r\n\tpeople.set(\"bob\", bob);\r\n```\r\nNow Alice is the reactive one.\r\n\r\nAnd if I may suggest the rest:\r\n```js\r\n\timport { SvelteMap } from 'svelte/reactivity';\r\n\r\n\tconst people = new SvelteMap();\r\n\r\n\t// reactive object\r\n\tconst alice = $state({name: \"Alice\", age: 18}); \r\n\t\r\n\t// plain object\r\n\tconst bob = {name: \"Bob\", age: 21};\r\n\r\n\tpeople.set(\"alice\", alice);\r\n\tpeople.set(\"bob\", bob);\r\n\r\n\tconst happyBirthday = (personName) => {\r\n\t\t// This will propagate reactively for reactive Alice but not for plain old Bob\r\n\t\tpeople.get(personName).age++;\r\n\r\n\t\t// To update plain objects like Bob, replace them with new ones (immutable update)\r\n\t\tconst oldValue = people.get(personName);\r\n\t\tpeople.set(personName, {...oldValue, age: oldValue.age + 1});\r\n\t}\r\n</script>\r\n\r\n{#each people.entries() as [id, person] (id)}\r\n\t<div>\r\n\t\t<div>Name: {person.name}</div>\r\n\t\t<div> Age: {person.age}</div>\r\n\t\t<button onclick={() => happyBirthday(person.name)}>\r\n\t\t\tHappy Birthday\r\n\t\t</button>\r\n\t</div>\r\n{/each}\r\n```\r\n\r\nIf it looks too \"texty\", maybe moving the `happyBirthday` logic back to the HTML's onclick would ease it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1912261691",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14799,
        "pr_file": "documentation/docs/98-reference/21-svelte-reactivity.md",
        "discussion_id": "1911787183",
        "commented_code": "@@ -22,4 +22,97 @@ Svelte provides reactive versions of various built-ins like `SvelteMap`, `Svelte\n <input bind:value={url.href} />\n ```\n \n+The utilities provided in `svelte/reactivity` are automatically reactive with respect to their properties and methods, as seen in the previous example. As such, they don't need to be wrapped in `$state`. However, if a variable is reassigned, it needs to be wrapped in a `$state` in order for this reassignement to be reactive.\n+\n+```svelte\n+<script>\n+\timport { SvelteURL } from 'svelte/reactivity';\n+\n+\tlet url = $state(new SvelteURL('https://example.com/path'));\n+</script>\n+\n+<!-- these are reactive... -->\n+Protocol: {url?.protocol ?? \"ftp:\"}\n+<br>\n+Hostname: {url?.hostname ?? \"svelte.dev\"}\n+<br>\n+Path: {url?.pathname ?? \"\"}\n+\n+<hr />\n+\n+<!-- ...even when reassigning -->\n+<button\n+\tonclick={() => {\n+\t\turl = undefined;\n+\t}}\n+>\n+\tErase\n+</button>\n+```\n+\n+In a similar manner, the values stored inside e.g. `SvelteMap` are not automatically reactive, so if more complex values such as objects are used, they need to be wrapped in a `$state` in order to make their properties reactive as well. Alternatively, the whole object can be rewritten on update, which may actually lead to better performance than deep reactive `$state`.\n+\n+```svelte\n+<script>\n+\timport { SvelteMap } from 'svelte/reactivity';\n+\n+\tconst people = new SvelteMap();\n+\n+\tconst alice = {name: \"Alice\", age: 18};\n+\tpeople.set(\"alice\", alice);\n+\n+\tconst bob = $state({name: \"Bob\", age: 21});\n+\tpeople.set(\"bob\", bob);\n+</script>\n+\n+{#each people.entries() as [id, person] (id)}\n+\tName: {person.name}\n+\t<br>\n+\tAge: {person.age}\n+\t<br>\n+\t<br>\n+{/each}\n+\n+<hr />\n+\n+<!-- This will NOT propagate reactively -->\n+<button\n+\tonclick={() => {\n+\t\tpeople.get(\"alice\").age++;\n+\t}}\n+>\n+\tAlice's birthday\n+</button>\n+\n+<!-- This WILL propagate reactively -->",
        "comment_created_at": "2025-01-11T22:17:32+00:00",
        "comment_author": "marekdedic",
        "comment_body": "Thanks, in the end I did something a little bit in between :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1170165888",
    "pr_number": 8495,
    "pr_file": "site/content/docs/03-template-syntax.md",
    "created_at": "2023-04-18T14:56:02+00:00",
    "commented_code": "---\n \n-Slots can be rendered zero or more times and can pass values *back* to the parent using props. The parent exposes the values to the slot template using the `let:` directive.\n+Slots can be rendered zero or more times.\n \n+The `let:` directive gives a slot template access to variables defined in the component that they are provided to.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1170165888",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 8495,
        "pr_file": "site/content/docs/03-template-syntax.md",
        "discussion_id": "1170165888",
        "commented_code": "@@ -1600,22 +1600,30 @@ Note that explicitly passing in an empty named slot will add that slot's name to\n \n ---\n \n-Slots can be rendered zero or more times and can pass values *back* to the parent using props. The parent exposes the values to the slot template using the `let:` directive.\n+Slots can be rendered zero or more times.\n \n+The `let:` directive gives a slot template access to variables defined in the component that they are provided to.",
        "comment_created_at": "2023-04-18T14:56:02+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "I find this sentence much harder to read/parse than the previous one. Can we find some kind of middle ground between what was there before and what's proposed?",
        "pr_file_module": null
      },
      {
        "comment_id": "1191666887",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 8495,
        "pr_file": "site/content/docs/03-template-syntax.md",
        "discussion_id": "1170165888",
        "commented_code": "@@ -1600,22 +1600,30 @@ Note that explicitly passing in an empty named slot will add that slot's name to\n \n ---\n \n-Slots can be rendered zero or more times and can pass values *back* to the parent using props. The parent exposes the values to the slot template using the `let:` directive.\n+Slots can be rendered zero or more times.\n \n+The `let:` directive gives a slot template access to variables defined in the component that they are provided to.",
        "comment_created_at": "2023-05-11T20:38:49+00:00",
        "comment_author": "ghostdevv",
        "comment_body": "```suggestion\r\nThe `let:` directive gives a slot template access to variables passed down by the parent component.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1741261738",
    "pr_number": 13017,
    "pr_file": "documentation/blog/2024-09-01-whats-new-in-svelte-september-2024.md",
    "created_at": "2024-09-02T21:54:47+00:00",
    "commented_code": "+---\n+title: \"What's new in Svelte: September 2024\"\n+description: 'More useful `svelte:options` and `:global`, plus the deprecation of `<svelte:component>` in Svelte 5'\n+author: Dani Sandoval\n+authorURL: https://dreamindani.com\n+---\n+\n+A bunch of updates to Svelte dropped in the last few weeks, plus a few quality of life improvements in the Svelte language tools.\n+\n+Let's take a look...\n+\n+## What's new in Svelte and Language Tools\n+\n+- `$state.frozen` has been replaced with `$state.raw` (**5.0.0-next.218**, [Docs](https://svelte-5-preview.vercel.app/docs/runes#state-raw), [#12808](https://github.com/sveltejs/svelte/pull/12808))\n+- `$state.is` has been removed. RIP, little guy ([#12916](https://github.com/sveltejs/svelte/pull/12916))\n+- `$state.link` was added, experimented with, and then removed (**5.0.0-next.229 - 232**, [#12545](https://github.com/sveltejs/svelte/pull/12545) and [#12943](https://github.com/sveltejs/svelte/pull/12943))\n+- `svelte:options` lets you do a per-component css injection (**5.0.0-next.209**, [#12660](https://github.com/sveltejs/svelte/pull/12660))\n+- `<svelte:component>` is now unnecessary in runes mode and has now been deprecated (**5.0.0-next.203/217**, [#12646](https://github.com/sveltejs/svelte/pull/12646) and [#12694](https://github.com/sveltejs/svelte/pull/12694))",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1741261738",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13017,
        "pr_file": "documentation/blog/2024-09-01-whats-new-in-svelte-september-2024.md",
        "discussion_id": "1741261738",
        "commented_code": "@@ -0,0 +1,85 @@\n+---\n+title: \"What's new in Svelte: September 2024\"\n+description: 'More useful `svelte:options` and `:global`, plus the deprecation of `<svelte:component>` in Svelte 5'\n+author: Dani Sandoval\n+authorURL: https://dreamindani.com\n+---\n+\n+A bunch of updates to Svelte dropped in the last few weeks, plus a few quality of life improvements in the Svelte language tools.\n+\n+Let's take a look...\n+\n+## What's new in Svelte and Language Tools\n+\n+- `$state.frozen` has been replaced with `$state.raw` (**5.0.0-next.218**, [Docs](https://svelte-5-preview.vercel.app/docs/runes#state-raw), [#12808](https://github.com/sveltejs/svelte/pull/12808))\n+- `$state.is` has been removed. RIP, little guy ([#12916](https://github.com/sveltejs/svelte/pull/12916))\n+- `$state.link` was added, experimented with, and then removed (**5.0.0-next.229 - 232**, [#12545](https://github.com/sveltejs/svelte/pull/12545) and [#12943](https://github.com/sveltejs/svelte/pull/12943))\n+- `svelte:options` lets you do a per-component css injection (**5.0.0-next.209**, [#12660](https://github.com/sveltejs/svelte/pull/12660))\n+- `<svelte:component>` is now unnecessary in runes mode and has now been deprecated (**5.0.0-next.203/217**, [#12646](https://github.com/sveltejs/svelte/pull/12646) and [#12694](https://github.com/sveltejs/svelte/pull/12694))",
        "comment_created_at": "2024-09-02T21:54:47+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\n- `<svelte:component>` is now unnecessary in runes mode and therefore is deprecated (**5.0.0-next.203/217**, [#12646](https://github.com/sveltejs/svelte/pull/12646) and [#12694](https://github.com/sveltejs/svelte/pull/12694))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1723617584",
    "pr_number": 12929,
    "pr_file": "sites/svelte-5-preview/src/routes/docs/content/01-api/03-snippets.md",
    "created_at": "2024-08-20T16:29:20+00:00",
    "commented_code": "In Svelte 4, content can be passed to components using [slots](https://svelte.dev/docs/special-elements#slot). Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5.\n \n They continue to work, however, and you can mix and match snippets and slots in your components.\n+\n+When using custom elements, you should still use `<slot />` like before. In a future version, when Svelte removes its internal version of slots, it will leave those slot as-is, i.e. output a regular DOM tag instead of transforming it.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1723617584",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12929,
        "pr_file": "sites/svelte-5-preview/src/routes/docs/content/01-api/03-snippets.md",
        "discussion_id": "1723617584",
        "commented_code": "@@ -265,3 +265,5 @@ In advanced scenarios, you may need to create a snippet programmatically. For th\n In Svelte 4, content can be passed to components using [slots](https://svelte.dev/docs/special-elements#slot). Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5.\n \n They continue to work, however, and you can mix and match snippets and slots in your components.\n+\n+When using custom elements, you should still use `<slot />` like before. In a future version, when Svelte removes its internal version of slots, it will leave those slot as-is, i.e. output a regular DOM tag instead of transforming it.",
        "comment_created_at": "2024-08-20T16:29:20+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\nWhen using custom elements, you should still use `<slot />` like before. In a future version, when Svelte removes its internal version of slots, it will leave those slots as-is, i.e. output a regular DOM tag instead of transforming it.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]