[
  {
    "discussion_id": "2225992373",
    "pr_number": 16485,
    "pr_file": "packages/svelte/src/internal/client/runtime.js",
    "created_at": "2025-07-23T15:38:59+00:00",
    "commented_code": "try {\n \t\treaction.f |= REACTION_IS_UPDATING;\n-\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n+\t\tvar fn = /** @type {Function} */ (reaction.fn);",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2225992373",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 16485,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "2225992373",
        "commented_code": "@@ -284,7 +284,8 @@ export function update_reaction(reaction) {\n \n \ttry {\n \t\treaction.f |= REACTION_IS_UPDATING;\n-\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n+\t\tvar fn = /** @type {Function} */ (reaction.fn);",
        "comment_created_at": "2025-07-23T15:38:59+00:00",
        "comment_author": "sandersn",
        "comment_body": "Typescript errors on `(0, reaction.fn)()`--which is wrong, in my opinion--but in TS5 the cast syntax squelches this error for some reason. I split the line to avoid the comma expression but I'm not completely sure it's equivalent. It might be better to put a `// @ts-ignore` on the original line.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175446465",
    "pr_number": 16255,
    "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js",
    "created_at": "2025-06-30T16:12:38+00:00",
    "commented_code": "return sequence;\n }\n+\n+/**\n+ * Wraps a statement/expression with dev stack tracking in dev mode\n+ * @param {CallExpression} call_expression - The function call to wrap (e.g., $.if, $.each, etc.)\n+ * @param {{ start?: number }} node - AST node for location info\n+ * @param {'component' | 'if' | 'each' | 'await' | 'key'} type - Type of block/component\n+ * @param {Record<string, number | string>} [additional] - Any additional properties to add to the dev stack entry\n+ * @returns {Statement} - Statement with or without dev stack wrapping\n+ */\n+export function with_dev_stack(call_expression, node, type, additional) {\n+\tif (!dev) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\tconst location = node.start && locator(node.start);\n+\tif (!location) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\treturn b.stmt(\n+\t\tb.call(\n+\t\t\t'$.with_dev_stack',\n+\t\t\tb.arrow([], b.block([b.stmt(call_expression)])),\n+\t\t\tb.literal(type),\n+\t\t\tb.literal(filename),\n+\t\t\tb.literal(location.line),\n+\t\t\tb.literal(location.column),\n+\t\t\tadditional\n+\t\t\t\t? b.object(Object.entries(additional).map(([key, value]) => b.init(key, b.literal(value))))\n+\t\t\t\t: b.null",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2175446465",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 16255,
        "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js",
        "discussion_id": "2175446465",
        "commented_code": "@@ -394,3 +394,36 @@ export function build_expression(context, expression, metadata, state = context.\n \n \treturn sequence;\n }\n+\n+/**\n+ * Wraps a statement/expression with dev stack tracking in dev mode\n+ * @param {CallExpression} call_expression - The function call to wrap (e.g., $.if, $.each, etc.)\n+ * @param {{ start?: number }} node - AST node for location info\n+ * @param {'component' | 'if' | 'each' | 'await' | 'key'} type - Type of block/component\n+ * @param {Record<string, number | string>} [additional] - Any additional properties to add to the dev stack entry\n+ * @returns {Statement} - Statement with or without dev stack wrapping\n+ */\n+export function with_dev_stack(call_expression, node, type, additional) {\n+\tif (!dev) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\tconst location = node.start && locator(node.start);\n+\tif (!location) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\treturn b.stmt(\n+\t\tb.call(\n+\t\t\t'$.with_dev_stack',\n+\t\t\tb.arrow([], b.block([b.stmt(call_expression)])),\n+\t\t\tb.literal(type),\n+\t\t\tb.literal(filename),\n+\t\t\tb.literal(location.line),\n+\t\t\tb.literal(location.column),\n+\t\t\tadditional\n+\t\t\t\t? b.object(Object.entries(additional).map(([key, value]) => b.init(key, b.literal(value))))\n+\t\t\t\t: b.null",
        "comment_created_at": "2025-06-30T16:12:38+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "we can use `&&` here because trailing undefined arguments to `b.call` are ignored\r\n\r\n```suggestion\r\n\t\t\tadditional && b.object(Object.entries(additional).map(([k, v]) => b.init(k, b.literal(v))))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175450365",
    "pr_number": 16255,
    "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js",
    "created_at": "2025-06-30T16:15:09+00:00",
    "commented_code": "return sequence;\n }\n+\n+/**\n+ * Wraps a statement/expression with dev stack tracking in dev mode\n+ * @param {CallExpression} call_expression - The function call to wrap (e.g., $.if, $.each, etc.)\n+ * @param {{ start?: number }} node - AST node for location info\n+ * @param {'component' | 'if' | 'each' | 'await' | 'key'} type - Type of block/component\n+ * @param {Record<string, number | string>} [additional] - Any additional properties to add to the dev stack entry\n+ * @returns {Statement} - Statement with or without dev stack wrapping\n+ */\n+export function with_dev_stack(call_expression, node, type, additional) {\n+\tif (!dev) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\tconst location = node.start && locator(node.start);\n+\tif (!location) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\treturn b.stmt(\n+\t\tb.call(\n+\t\t\t'$.with_dev_stack',\n+\t\t\tb.arrow([], b.block([b.stmt(call_expression)])),",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2175450365",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 16255,
        "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js",
        "discussion_id": "2175450365",
        "commented_code": "@@ -394,3 +394,36 @@ export function build_expression(context, expression, metadata, state = context.\n \n \treturn sequence;\n }\n+\n+/**\n+ * Wraps a statement/expression with dev stack tracking in dev mode\n+ * @param {CallExpression} call_expression - The function call to wrap (e.g., $.if, $.each, etc.)\n+ * @param {{ start?: number }} node - AST node for location info\n+ * @param {'component' | 'if' | 'each' | 'await' | 'key'} type - Type of block/component\n+ * @param {Record<string, number | string>} [additional] - Any additional properties to add to the dev stack entry\n+ * @returns {Statement} - Statement with or without dev stack wrapping\n+ */\n+export function with_dev_stack(call_expression, node, type, additional) {\n+\tif (!dev) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\tconst location = node.start && locator(node.start);\n+\tif (!location) {\n+\t\treturn b.stmt(call_expression);\n+\t}\n+\n+\treturn b.stmt(\n+\t\tb.call(\n+\t\t\t'$.with_dev_stack',\n+\t\t\tb.arrow([], b.block([b.stmt(call_expression)])),",
        "comment_created_at": "2025-06-30T16:15:09+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "using an implicit return will keep the statement on a single line in many cases \r\n\r\n```suggestion\r\n\t\t\tb.arrow([], call_expression),\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2100674293",
    "pr_number": 15538,
    "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/transform-template/to-string.js",
    "created_at": "2025-05-21T16:05:51+00:00",
    "commented_code": "+/**\n+ * @import { TemplateOperations } from \"../types.js\"\n+ */\n+import { is_void } from '../../../../../utils.js';\n+\n+/**\n+ * @param {TemplateOperations} items\n+ */\n+export function template_to_string(items) {\n+\tlet elements = [];\n+\n+\t/**\n+\t * @type {Array<Element>}\n+\t */\n+\tlet elements_stack = [];\n+\n+\t/**\n+\t * @type {Element | undefined}\n+\t */\n+\tlet last_current_element;\n+\n+\tfor (let instruction of items) {\n+\t\t// on push element we add the element to the stack, from this moment on every insert will\n+\t\t// happen on the last element in the stack\n+\t\tif (instruction.kind === 'push_element' && last_current_element) {\n+\t\t\telements_stack.push(last_current_element);\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// we closed one element, we remove it from the stack\n+\t\tif (instruction.kind === 'pop_element') {\n+\t\t\telements_stack.pop();\n+\t\t\tcontinue;\n+\t\t}\n+\t\t/**\n+\t\t * @type {Node | void}\n+\t\t */\n+\t\t// @ts-expect-error we can't be here if `swap_current_element` but TS doesn't know that\n+\t\tconst value = map[instruction.kind](\n+\t\t\t...[\n+\t\t\t\t// for set prop we need to send the last element (not the one in the stack since\n+\t\t\t\t// it get's added to the stack only after the push_element instruction)\n+\t\t\t\t...(instruction.kind === 'set_prop' ? [last_current_element] : []),\n+\t\t\t\t...(instruction.args ?? [])\n+\t\t\t]\n+\t\t);\n+\t\t// with set_prop we don't need to do anything else, in all other cases we also need to\n+\t\t// append the element/node/anchor to the current active element or push it in the elements array\n+\t\tif (instruction.kind !== 'set_prop') {\n+\t\t\tif (elements_stack.length >= 1 && value) {\n+\t\t\t\tmap.insert(/** @type {Element} */ (elements_stack.at(-1)), value);\n+\t\t\t} else if (value) {\n+\t\t\t\telements.push(value);\n+\t\t\t}\n+\t\t\t// keep track of the last created element (it will be pushed to the stack after the props are set)\n+\t\t\tif (instruction.kind === 'create_element') {\n+\t\t\t\tlast_current_element = /** @type {Element} */ (value);\n+\t\t\t}\n+\t\t}\n+\t}",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2100674293",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15538,
        "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/transform-template/to-string.js",
        "discussion_id": "2100674293",
        "commented_code": "@@ -0,0 +1,183 @@\n+/**\n+ * @import { TemplateOperations } from \"../types.js\"\n+ */\n+import { is_void } from '../../../../../utils.js';\n+\n+/**\n+ * @param {TemplateOperations} items\n+ */\n+export function template_to_string(items) {\n+\tlet elements = [];\n+\n+\t/**\n+\t * @type {Array<Element>}\n+\t */\n+\tlet elements_stack = [];\n+\n+\t/**\n+\t * @type {Element | undefined}\n+\t */\n+\tlet last_current_element;\n+\n+\tfor (let instruction of items) {\n+\t\t// on push element we add the element to the stack, from this moment on every insert will\n+\t\t// happen on the last element in the stack\n+\t\tif (instruction.kind === 'push_element' && last_current_element) {\n+\t\t\telements_stack.push(last_current_element);\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// we closed one element, we remove it from the stack\n+\t\tif (instruction.kind === 'pop_element') {\n+\t\t\telements_stack.pop();\n+\t\t\tcontinue;\n+\t\t}\n+\t\t/**\n+\t\t * @type {Node | void}\n+\t\t */\n+\t\t// @ts-expect-error we can't be here if `swap_current_element` but TS doesn't know that\n+\t\tconst value = map[instruction.kind](\n+\t\t\t...[\n+\t\t\t\t// for set prop we need to send the last element (not the one in the stack since\n+\t\t\t\t// it get's added to the stack only after the push_element instruction)\n+\t\t\t\t...(instruction.kind === 'set_prop' ? [last_current_element] : []),\n+\t\t\t\t...(instruction.args ?? [])\n+\t\t\t]\n+\t\t);\n+\t\t// with set_prop we don't need to do anything else, in all other cases we also need to\n+\t\t// append the element/node/anchor to the current active element or push it in the elements array\n+\t\tif (instruction.kind !== 'set_prop') {\n+\t\t\tif (elements_stack.length >= 1 && value) {\n+\t\t\t\tmap.insert(/** @type {Element} */ (elements_stack.at(-1)), value);\n+\t\t\t} else if (value) {\n+\t\t\t\telements.push(value);\n+\t\t\t}\n+\t\t\t// keep track of the last created element (it will be pushed to the stack after the props are set)\n+\t\t\tif (instruction.kind === 'create_element') {\n+\t\t\t\tlast_current_element = /** @type {Element} */ (value);\n+\t\t\t}\n+\t\t}\n+\t}",
        "comment_created_at": "2025-05-21T16:05:51+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "in my experience it's vanishingly rare that this kind of indirection makes sense compared to writing more obvious code. if we do this...\r\n\r\n```suggestion\r\n\t/**\r\n\t * @template {Node} T\r\n\t * @param {T} child\r\n\t */\r\n\tfunction insert(child) {\r\n\t\tif (last_current_element) {\r\n\t\t\tlast_current_element.children ??= [];\r\n\t\t\tlast_current_element.children.push(child);\r\n\t\t} else {\r\n\t\t\telements.push(/** @type {Element} */ (child));\r\n\t\t}\r\n\r\n\t\treturn child;\r\n\t}\r\n\r\n\tfor (let instruction of items) {\r\n\t\tswitch (instruction.kind) {\r\n\t\t\tcase 'push_element':\r\n\t\t\t\telements_stack.push(/** @type {Element} */ (last_current_element));\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'pop_element':\r\n\t\t\t\telements_stack.pop();\r\n\t\t\t\tlast_current_element = elements_stack.at(-1);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'create_element':\r\n\t\t\t\tlast_current_element = insert({\r\n\t\t\t\t\tkind: 'element',\r\n\t\t\t\t\telement: /** @type {string[]} */ (instruction.args)[0]\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'create_text':\r\n\t\t\t\tinsert({\r\n\t\t\t\t\tkind: 'text',\r\n\t\t\t\t\tvalue: /** @type {string[]} */ (instruction.args)[0]\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'create_anchor':\r\n\t\t\t\tinsert({\r\n\t\t\t\t\tkind: 'anchor',\r\n\t\t\t\t\tdata: instruction.args?.[0]\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'set_prop': {\r\n\t\t\t\tconst el = /** @type {Element} */ (last_current_element);\r\n\t\t\t\tconst [prop, value] = /** @type {string[]} */ (instruction.args);\r\n\t\t\t\tel.props ??= {};\r\n\t\t\t\tel.props[prop] = value;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2100685502",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15538,
        "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/transform-template/to-string.js",
        "discussion_id": "2100674293",
        "commented_code": "@@ -0,0 +1,183 @@\n+/**\n+ * @import { TemplateOperations } from \"../types.js\"\n+ */\n+import { is_void } from '../../../../../utils.js';\n+\n+/**\n+ * @param {TemplateOperations} items\n+ */\n+export function template_to_string(items) {\n+\tlet elements = [];\n+\n+\t/**\n+\t * @type {Array<Element>}\n+\t */\n+\tlet elements_stack = [];\n+\n+\t/**\n+\t * @type {Element | undefined}\n+\t */\n+\tlet last_current_element;\n+\n+\tfor (let instruction of items) {\n+\t\t// on push element we add the element to the stack, from this moment on every insert will\n+\t\t// happen on the last element in the stack\n+\t\tif (instruction.kind === 'push_element' && last_current_element) {\n+\t\t\telements_stack.push(last_current_element);\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// we closed one element, we remove it from the stack\n+\t\tif (instruction.kind === 'pop_element') {\n+\t\t\telements_stack.pop();\n+\t\t\tcontinue;\n+\t\t}\n+\t\t/**\n+\t\t * @type {Node | void}\n+\t\t */\n+\t\t// @ts-expect-error we can't be here if `swap_current_element` but TS doesn't know that\n+\t\tconst value = map[instruction.kind](\n+\t\t\t...[\n+\t\t\t\t// for set prop we need to send the last element (not the one in the stack since\n+\t\t\t\t// it get's added to the stack only after the push_element instruction)\n+\t\t\t\t...(instruction.kind === 'set_prop' ? [last_current_element] : []),\n+\t\t\t\t...(instruction.args ?? [])\n+\t\t\t]\n+\t\t);\n+\t\t// with set_prop we don't need to do anything else, in all other cases we also need to\n+\t\t// append the element/node/anchor to the current active element or push it in the elements array\n+\t\tif (instruction.kind !== 'set_prop') {\n+\t\t\tif (elements_stack.length >= 1 && value) {\n+\t\t\t\tmap.insert(/** @type {Element} */ (elements_stack.at(-1)), value);\n+\t\t\t} else if (value) {\n+\t\t\t\telements.push(value);\n+\t\t\t}\n+\t\t\t// keep track of the last created element (it will be pushed to the stack after the props are set)\n+\t\t\tif (instruction.kind === 'create_element') {\n+\t\t\t\tlast_current_element = /** @type {Element} */ (value);\n+\t\t\t}\n+\t\t}\n+\t}",
        "comment_created_at": "2025-05-21T16:11:59+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "I think it makes sense...I got carried away \ud83d\ude05",
        "pr_file_module": null
      },
      {
        "comment_id": "2100697051",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15538,
        "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/transform-template/to-string.js",
        "discussion_id": "2100674293",
        "commented_code": "@@ -0,0 +1,183 @@\n+/**\n+ * @import { TemplateOperations } from \"../types.js\"\n+ */\n+import { is_void } from '../../../../../utils.js';\n+\n+/**\n+ * @param {TemplateOperations} items\n+ */\n+export function template_to_string(items) {\n+\tlet elements = [];\n+\n+\t/**\n+\t * @type {Array<Element>}\n+\t */\n+\tlet elements_stack = [];\n+\n+\t/**\n+\t * @type {Element | undefined}\n+\t */\n+\tlet last_current_element;\n+\n+\tfor (let instruction of items) {\n+\t\t// on push element we add the element to the stack, from this moment on every insert will\n+\t\t// happen on the last element in the stack\n+\t\tif (instruction.kind === 'push_element' && last_current_element) {\n+\t\t\telements_stack.push(last_current_element);\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// we closed one element, we remove it from the stack\n+\t\tif (instruction.kind === 'pop_element') {\n+\t\t\telements_stack.pop();\n+\t\t\tcontinue;\n+\t\t}\n+\t\t/**\n+\t\t * @type {Node | void}\n+\t\t */\n+\t\t// @ts-expect-error we can't be here if `swap_current_element` but TS doesn't know that\n+\t\tconst value = map[instruction.kind](\n+\t\t\t...[\n+\t\t\t\t// for set prop we need to send the last element (not the one in the stack since\n+\t\t\t\t// it get's added to the stack only after the push_element instruction)\n+\t\t\t\t...(instruction.kind === 'set_prop' ? [last_current_element] : []),\n+\t\t\t\t...(instruction.args ?? [])\n+\t\t\t]\n+\t\t);\n+\t\t// with set_prop we don't need to do anything else, in all other cases we also need to\n+\t\t// append the element/node/anchor to the current active element or push it in the elements array\n+\t\tif (instruction.kind !== 'set_prop') {\n+\t\t\tif (elements_stack.length >= 1 && value) {\n+\t\t\t\tmap.insert(/** @type {Element} */ (elements_stack.at(-1)), value);\n+\t\t\t} else if (value) {\n+\t\t\t\telements.push(value);\n+\t\t\t}\n+\t\t\t// keep track of the last created element (it will be pushed to the stack after the props are set)\n+\t\t\tif (instruction.kind === 'create_element') {\n+\t\t\t\tlast_current_element = /** @type {Element} */ (value);\n+\t\t\t}\n+\t\t}\n+\t}",
        "comment_created_at": "2025-05-21T16:17:36+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "Pushed a new commit with the change, now I'm gonna convert the other too",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1979313049",
    "pr_number": 15418,
    "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/visitors/shared/element.js",
    "created_at": "2025-03-04T12:17:05+00:00",
    "commented_code": "class_directives.find((directive) => directive.metadata.expression.has_state) !== null;\n \t}\n \n+\tif (style_directives.length) {\n+\t\tvalues.push(\n+\t\t\tb.prop(\n+\t\t\t\t'init',\n+\t\t\t\tb.array([b.id('$.STYLE')]),\n+\t\t\t\tbuild_style_directives_object(style_directives, context)\n+\t\t\t)\n+\t\t);\n+\n+\t\tis_dynamic ||=\n+\t\t\tstyle_directives.find((directive) => directive.metadata.expression.has_state) !== null;",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1979313049",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15418,
        "pr_file": "packages/svelte/src/compiler/phases/3-transform/client/visitors/shared/element.js",
        "discussion_id": "1979313049",
        "commented_code": "@@ -83,6 +84,19 @@ export function build_set_attributes(\n \t\t\tclass_directives.find((directive) => directive.metadata.expression.has_state) !== null;\n \t}\n \n+\tif (style_directives.length) {\n+\t\tvalues.push(\n+\t\t\tb.prop(\n+\t\t\t\t'init',\n+\t\t\t\tb.array([b.id('$.STYLE')]),\n+\t\t\t\tbuild_style_directives_object(style_directives, context)\n+\t\t\t)\n+\t\t);\n+\n+\t\tis_dynamic ||=\n+\t\t\tstyle_directives.find((directive) => directive.metadata.expression.has_state) !== null;",
        "comment_created_at": "2025-03-04T12:17:05+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\n\t\t\tstyle_directives.some((directive) => directive.metadata.expression.has_state);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952555367",
    "pr_number": 15275,
    "pr_file": "packages/svelte/src/internal/client/runtime.js",
    "created_at": "2025-02-12T12:27:39+00:00",
    "commented_code": "* @param {Effect} effect\n  * @param {number} [depth]\n  */\n-function schedule_possible_effect_self_invalidation(signal, effect, depth = 0) {\n+function schedule_possible_effect_self_invalidation(\n+\tsignal,\n+\teffect,\n+\tdepth = 0,",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1952555367",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15275,
        "pr_file": "packages/svelte/src/internal/client/runtime.js",
        "discussion_id": "1952555367",
        "commented_code": "@@ -371,17 +371,28 @@ export function handle_error(error, effect, previous_effect, component_context)\n  * @param {Effect} effect\n  * @param {number} [depth]\n  */\n-function schedule_possible_effect_self_invalidation(signal, effect, depth = 0) {\n+function schedule_possible_effect_self_invalidation(\n+\tsignal,\n+\teffect,\n+\tdepth = 0,",
        "comment_created_at": "2025-02-12T12:27:39+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "Can we use a boolean instead of a number here? Seems like it's only used within one if block",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1906247505",
    "pr_number": 14945,
    "pr_file": "packages/svelte/src/internal/client/dev/tracing.js",
    "created_at": "2025-01-08T02:11:48+00:00",
    "commented_code": "const type = (signal.f & DERIVED) !== 0 ? '$derived' : '$state';\n \tconst current_reaction = /** @type {Reaction} */ (active_reaction);\n \tconst status =\n-\t\tsignal.version > current_reaction.version || current_reaction.version === 0 ? 'dirty' : 'clean';\n+\t\tsignal.w_version > current_reaction.w_version || current_reaction.w_version === 0\n+\t\t\t? 'dirty'\n+\t\t\t: 'clean';",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1906247505",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14945,
        "pr_file": "packages/svelte/src/internal/client/dev/tracing.js",
        "discussion_id": "1906247505",
        "commented_code": "@@ -43,7 +43,9 @@ function log_entry(signal, entry) {\n \tconst type = (signal.f & DERIVED) !== 0 ? '$derived' : '$state';\n \tconst current_reaction = /** @type {Reaction} */ (active_reaction);\n \tconst status =\n-\t\tsignal.version > current_reaction.version || current_reaction.version === 0 ? 'dirty' : 'clean';\n+\t\tsignal.w_version > current_reaction.w_version || current_reaction.w_version === 0\n+\t\t\t? 'dirty'\n+\t\t\t: 'clean';",
        "comment_created_at": "2025-01-08T02:11:48+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "unrelated to the PR but I hadn't noticed this code before \u2014 any reason we're using an enum here rather than a boolean? Feels like it could be this instead, with a corresponding change on line 53:\r\n\r\n```js\r\nconst dirty = signal.w_version > current_reaction.w_version || current_reaction.w_version === 0;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1869904623",
    "pr_number": 14549,
    "pr_file": "packages/svelte/src/internal/client/dom/blocks/if.js",
    "created_at": "2024-12-04T16:32:37+00:00",
    "commented_code": "var flags = elseif ? EFFECT_TRANSPARENT : 0;\n \n-\tblock(() => {\n-\t\tif (condition === (condition = !!get_condition())) return;\n+\tvar has_branch = false;\n+\n+\tconst set_branch = (/** @type {0 | 1} */ flag, /** @type {(anchor: Node) => void} */ fn) => {\n+\t\thas_branch = true;\n+\t\tupdate_branch(flag === 0, fn);\n+\t};",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1869904623",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14549,
        "pr_file": "packages/svelte/src/internal/client/dom/blocks/if.js",
        "discussion_id": "1869904623",
        "commented_code": "@@ -37,8 +35,18 @@ export function if_block(node, get_condition, consequent_fn, alternate_fn = null\n \n \tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n \n-\tblock(() => {\n-\t\tif (condition === (condition = !!get_condition())) return;\n+\tvar has_branch = false;\n+\n+\tconst set_branch = (/** @type {0 | 1} */ flag, /** @type {(anchor: Node) => void} */ fn) => {\n+\t\thas_branch = true;\n+\t\tupdate_branch(flag === 0, fn);\n+\t};",
        "comment_created_at": "2024-12-04T16:32:37+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "What's the reason to use `0 | 1` instead of booleans here? If the signature was this...\r\n\r\n```suggestion\r\n\tconst set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = false) => {\r\n\t\thas_branch = true;\r\n\t\tupdate_branch(flag, fn);\r\n\t};\r\n```\r\n\r\n...then in the common case where there's no alternate, we could generate this code \u2014 a small win but it feels like it better reflects the binary nature of `if` blocks\r\n\r\n```diff\r\n$.if(node, ($$branch) => {\r\n-\tif (Math.random() < 0.5) $$branch(0, consequent);\r\n+\tif (Math.random() < 0.5) $$branch(consequent);\r\n});\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1723894375",
    "pr_number": 12930,
    "pr_file": "packages/svelte/src/internal/client/reactivity/sources.js",
    "created_at": "2024-08-20T19:43:40+00:00",
    "commented_code": "var runes = is_runes();\n \tvar length = reactions.length;\n+\tvar to_maybe_dirty = (status & MAYBE_DIRTY) !== 0;",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1723894375",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12930,
        "pr_file": "packages/svelte/src/internal/client/reactivity/sources.js",
        "discussion_id": "1723894375",
        "commented_code": "@@ -189,6 +189,7 @@ function mark_reactions(signal, status) {\n \n \tvar runes = is_runes();\n \tvar length = reactions.length;\n+\tvar to_maybe_dirty = (status & MAYBE_DIRTY) !== 0;",
        "comment_created_at": "2024-08-20T19:43:40+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "storing this feels like overkill when we only need to do `status === MAYBE_DIRTY` below (no need for bitwise shenanigans)\r\n\r\n```suggestion\r\n```",
        "pr_file_module": null
      }
    ]
  }
]