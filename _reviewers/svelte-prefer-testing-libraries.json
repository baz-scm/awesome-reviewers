[
  {
    "discussion_id": "1691335187",
    "pr_number": 12600,
    "pr_file": "documentation/docs/05-misc/02-testing.md",
    "created_at": "2024-07-25T12:09:22+00:00",
    "commented_code": "title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration-testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. We recommend using [Vitest](https://vitest.dev/) for these kinds of tests (this assumes you use Vite for bundling your application).\n+\n+To get started, install Vitest (`npm install vitest -D`) and JSDOM (a library that shims DOM APIs, `npm install jsdom -D`). Then adjust your `vite.config.js` such that you can simulate a browser environment for testing Svelte components on the client:\n+\n+```js\n+/// file: vitest.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1691335187",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691335187",
        "commented_code": "@@ -2,7 +2,155 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration-testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. We recommend using [Vitest](https://vitest.dev/) for these kinds of tests (this assumes you use Vite for bundling your application).\n+\n+To get started, install Vitest (`npm install vitest -D`) and JSDOM (a library that shims DOM APIs, `npm install jsdom -D`). Then adjust your `vite.config.js` such that you can simulate a browser environment for testing Svelte components on the client:\n+\n+```js\n+/// file: vitest.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {",
        "comment_created_at": "2024-07-25T12:09:22+00:00",
        "comment_author": "dominikg",
        "comment_body": "if we want to recommend/document component testing, it should be using testing-library/svelte  - not just as a link at the bottom but within the code example. And then at the bottom say \"you can also mount components yourself but thats  low level and somewhat brittle, see <link to mount>\"",
        "pr_file_module": null
      },
      {
        "comment_id": "1691399783",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691335187",
        "commented_code": "@@ -2,7 +2,155 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration-testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. We recommend using [Vitest](https://vitest.dev/) for these kinds of tests (this assumes you use Vite for bundling your application).\n+\n+To get started, install Vitest (`npm install vitest -D`) and JSDOM (a library that shims DOM APIs, `npm install jsdom -D`). Then adjust your `vite.config.js` such that you can simulate a browser environment for testing Svelte components on the client:\n+\n+```js\n+/// file: vitest.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {",
        "comment_created_at": "2024-07-25T12:58:25+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "I think it's important to have a low level example to not immediately abstract away stuff. Then they have an easier time reasoning about the abstraction",
        "pr_file_module": null
      },
      {
        "comment_id": "1691435587",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691335187",
        "commented_code": "@@ -2,7 +2,155 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration-testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. We recommend using [Vitest](https://vitest.dev/) for these kinds of tests (this assumes you use Vite for bundling your application).\n+\n+To get started, install Vitest (`npm install vitest -D`) and JSDOM (a library that shims DOM APIs, `npm install jsdom -D`). Then adjust your `vite.config.js` such that you can simulate a browser environment for testing Svelte components on the client:\n+\n+```js\n+/// file: vitest.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {",
        "comment_created_at": "2024-07-25T13:22:13+00:00",
        "comment_author": "dominikg",
        "comment_body": "this is too low level. people would come up with their own abstractions as the testing-library link is easy to overlook. If you want the example this prominent, testing library should at least be called out before and in a colorful block so that people use that by default. This is not something you want to bikeshed",
        "pr_file_module": null
      },
      {
        "comment_id": "1693046221",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691335187",
        "commented_code": "@@ -2,7 +2,155 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration-testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. We recommend using [Vitest](https://vitest.dev/) for these kinds of tests (this assumes you use Vite for bundling your application).\n+\n+To get started, install Vitest (`npm install vitest -D`) and JSDOM (a library that shims DOM APIs, `npm install jsdom -D`). Then adjust your `vite.config.js` such that you can simulate a browser environment for testing Svelte components on the client:\n+\n+```js\n+/// file: vitest.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {",
        "comment_created_at": "2024-07-26T13:15:09+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "The reading flow is better if first the underlying primitive is shown and then the abstraction on top - I added a code example showing how to rewrite it using the testing library, to make the benefits more obvious.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1691708890",
    "pr_number": 12600,
    "pr_file": "documentation/docs/05-misc/02-testing.md",
    "created_at": "2024-07-25T15:50:46+00:00",
    "commented_code": "title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration tests using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and JSDOM (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>0</button>\");\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector(\"button\")!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>1</button>\");\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+## E2E tests using Playwright\n+\n+E2E (short for \"end to end\") tests allow you to test your full application through the eyes of the user. This section uses [Playwright](https://playwright.dev/) as an example, but you can also use other solutions like [Cypress](https://www.cypress.io/) or [NightwatchJS](https://nightwatchjs.org/).\n+\n+To get start with Playwright, either let you guide by [their VS Code extension](https://playwright.dev/docs/getting-started-vscode), or install it from the command line using `npm init playwright`. It is also part of the setup CLI when you run `npm create svelte`.\n+\n+After you've done that, you should have a `tests` folder and a playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port:\n+\n+```js\n+/// file: playwright.config.js\n+const config = {\n+\twebServer: {\n+\t\tcommand: 'npm run build && npm run preview',\n+\t\tport: 4173\n+\t},\n+\ttestDir: 'tests',\n+\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n+};\n+\n+export default config;\n+```\n+\n+You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.\n+\n+```js\n+/// file: tests/hello-world.spec.js\n+import { expect, test } from '@playwright/test';\n+\n+test('home page has expected h1', async ({ page }) => {\n+\tawait page.goto('/');\n+\tawait expect(page.locator('h1')).toBeVisible();\n+});\n+```",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1691708890",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691708890",
        "commented_code": "@@ -2,7 +2,156 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration tests using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and JSDOM (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>0</button>\");\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector(\"button\")!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>1</button>\");\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+## E2E tests using Playwright\n+\n+E2E (short for \"end to end\") tests allow you to test your full application through the eyes of the user. This section uses [Playwright](https://playwright.dev/) as an example, but you can also use other solutions like [Cypress](https://www.cypress.io/) or [NightwatchJS](https://nightwatchjs.org/).\n+\n+To get start with Playwright, either let you guide by [their VS Code extension](https://playwright.dev/docs/getting-started-vscode), or install it from the command line using `npm init playwright`. It is also part of the setup CLI when you run `npm create svelte`.\n+\n+After you've done that, you should have a `tests` folder and a playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port:\n+\n+```js\n+/// file: playwright.config.js\n+const config = {\n+\twebServer: {\n+\t\tcommand: 'npm run build && npm run preview',\n+\t\tport: 4173\n+\t},\n+\ttestDir: 'tests',\n+\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n+};\n+\n+export default config;\n+```\n+\n+You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.\n+\n+```js\n+/// file: tests/hello-world.spec.js\n+import { expect, test } from '@playwright/test';\n+\n+test('home page has expected h1', async ({ page }) => {\n+\tawait page.goto('/');\n+\tawait expect(page.locator('h1')).toBeVisible();\n+});\n+```",
        "comment_created_at": "2024-07-25T15:50:46+00:00",
        "comment_author": "benmccann",
        "comment_body": "I think component testing deserves its own section if it's mentioned at all. I wouldn't recommend installing jsdom above as it's tremendously more complicated than just doing that. You run into all kinds of complications with slots (maybe better with snippets?), events and `use:`, `bind:`, DX of programattically instantiating components, etc. We purposefully avoided setting up component testing in `create-svelte` because the solutions all sucked so badly. I hesitate to recommend anyone component test their Svelte components at the current time. We need to put real effort into making it better and would be doing a disservice to recommend folks use it currently.\r\n\r\n```suggestion\r\n\r\n## Component testing\r\n\r\nTwo approaches to component testing are to [use jsdom with Vitest](https://github.com/wd-David/svelte-component-test-recipes) or to use [@playwright/experimental-ct-svelte](https://playwright.dev/docs/test-components). `create-svelte` currently does not setup component testing as these approaches are under active development by the community.\r\n\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1691886564",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691708890",
        "commented_code": "@@ -2,7 +2,156 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration tests using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and JSDOM (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>0</button>\");\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector(\"button\")!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>1</button>\");\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+## E2E tests using Playwright\n+\n+E2E (short for \"end to end\") tests allow you to test your full application through the eyes of the user. This section uses [Playwright](https://playwright.dev/) as an example, but you can also use other solutions like [Cypress](https://www.cypress.io/) or [NightwatchJS](https://nightwatchjs.org/).\n+\n+To get start with Playwright, either let you guide by [their VS Code extension](https://playwright.dev/docs/getting-started-vscode), or install it from the command line using `npm init playwright`. It is also part of the setup CLI when you run `npm create svelte`.\n+\n+After you've done that, you should have a `tests` folder and a playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port:\n+\n+```js\n+/// file: playwright.config.js\n+const config = {\n+\twebServer: {\n+\t\tcommand: 'npm run build && npm run preview',\n+\t\tport: 4173\n+\t},\n+\ttestDir: 'tests',\n+\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n+};\n+\n+export default config;\n+```\n+\n+You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.\n+\n+```js\n+/// file: tests/hello-world.spec.js\n+import { expect, test } from '@playwright/test';\n+\n+test('home page has expected h1', async ({ page }) => {\n+\tawait page.goto('/');\n+\tawait expect(page.locator('h1')).toBeVisible();\n+});\n+```",
        "comment_created_at": "2024-07-25T17:45:39+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "- you can programmatically instantiate slots now using `createRawSnippet`\r\n- what is the problem with events/use/bind?\r\n- \"DX of programmatically intantiating components\" - what is so bad about it? I mean, yes it's not as nice as declaratively doing that, but doing `mount`/`unmount` isn't so bad? And when it comes to selecting elements in order to interact with them, it's always going to be a bit of legwork (in e2e testing, too)",
        "pr_file_module": null
      },
      {
        "comment_id": "1692007999",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691708890",
        "commented_code": "@@ -2,7 +2,156 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration tests using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and JSDOM (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>0</button>\");\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector(\"button\")!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>1</button>\");\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+## E2E tests using Playwright\n+\n+E2E (short for \"end to end\") tests allow you to test your full application through the eyes of the user. This section uses [Playwright](https://playwright.dev/) as an example, but you can also use other solutions like [Cypress](https://www.cypress.io/) or [NightwatchJS](https://nightwatchjs.org/).\n+\n+To get start with Playwright, either let you guide by [their VS Code extension](https://playwright.dev/docs/getting-started-vscode), or install it from the command line using `npm init playwright`. It is also part of the setup CLI when you run `npm create svelte`.\n+\n+After you've done that, you should have a `tests` folder and a playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port:\n+\n+```js\n+/// file: playwright.config.js\n+const config = {\n+\twebServer: {\n+\t\tcommand: 'npm run build && npm run preview',\n+\t\tport: 4173\n+\t},\n+\ttestDir: 'tests',\n+\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n+};\n+\n+export default config;\n+```\n+\n+You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.\n+\n+```js\n+/// file: tests/hello-world.spec.js\n+import { expect, test } from '@playwright/test';\n+\n+test('home page has expected h1', async ({ page }) => {\n+\tawait page.goto('/');\n+\tawait expect(page.locator('h1')).toBeVisible();\n+});\n+```",
        "comment_created_at": "2024-07-25T19:18:15+00:00",
        "comment_author": "benmccann",
        "comment_body": "> what is the problem with events/use/bind?\r\n\r\nI don't know if it's changed in Svelte 5, but in Svelte 4 there is no programmatic interface to test `bind:`, `use:`, slots, or the context API\r\n\r\n> \"DX of programmatically intantiating components\" - what is so bad about it? I mean, yes it's not as nice as declaratively doing that, but doing mount/unmount isn't so bad? And when it comes to selecting elements in order to interact with them, it's always going to be a bit of legwork (in e2e testing, too)\r\n\r\nIt's not just instantiating but using features like slots/events/use/bind/context. I can only tell you what the experience was like in Svelte 4 as I haven't seen it in Svelte 5, but I think any docs for component testing would need to show how to do those things.",
        "pr_file_module": null
      },
      {
        "comment_id": "1693007941",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1691708890",
        "commented_code": "@@ -2,7 +2,156 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use, so you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit/Integration tests using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and JSDOM (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from \"svelte\";\n+import { expect, test } from \"vitest\";\n+import Component from \"./Component.svelte\";\n+\n+test(\"Component\", () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>0</button>\");\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector(\"button\")!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe(\"<button>1</button>\");\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+## E2E tests using Playwright\n+\n+E2E (short for \"end to end\") tests allow you to test your full application through the eyes of the user. This section uses [Playwright](https://playwright.dev/) as an example, but you can also use other solutions like [Cypress](https://www.cypress.io/) or [NightwatchJS](https://nightwatchjs.org/).\n+\n+To get start with Playwright, either let you guide by [their VS Code extension](https://playwright.dev/docs/getting-started-vscode), or install it from the command line using `npm init playwright`. It is also part of the setup CLI when you run `npm create svelte`.\n+\n+After you've done that, you should have a `tests` folder and a playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port:\n+\n+```js\n+/// file: playwright.config.js\n+const config = {\n+\twebServer: {\n+\t\tcommand: 'npm run build && npm run preview',\n+\t\tport: 4173\n+\t},\n+\ttestDir: 'tests',\n+\ttestMatch: /(.+\\.)?(test|spec)\\.[jt]s/\n+};\n+\n+export default config;\n+```\n+\n+You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions.\n+\n+```js\n+/// file: tests/hello-world.spec.js\n+import { expect, test } from '@playwright/test';\n+\n+test('home page has expected h1', async ({ page }) => {\n+\tawait page.goto('/');\n+\tawait expect(page.locator('h1')).toBeVisible();\n+});\n+```",
        "comment_created_at": "2024-07-26T12:43:05+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "The way to go about all these cases is to create a wrapper component that tests the actual component - I don't see a problem with that. It's how you would have to do this in _any_ framework.\r\nFurthermore, just not documenting how to do component testing because it's cumbersome sounds wrong. Testing components in isolation is something you'd want to do especially when creating a component library, for example. I'm open to having a `> Don't overdo this as component tests are generally harder to maintain` note at the end of the section.\r\nI'll adjust the docs to mention both these things.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1692050396",
    "pr_number": 12600,
    "pr_file": "documentation/docs/05-misc/02-testing.md",
    "created_at": "2024-07-25T20:02:26+00:00",
    "commented_code": "title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button')!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1692050396",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1692050396",
        "commented_code": "@@ -2,7 +2,156 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest and jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D vitest jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to prefer the browser condition. Svelte uses a so-called exports map\n+\t// which loads different code depending on the environment - we want to load the browser environment.\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, then interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's mount API\n+\tconst comp = mount(Component, {\n+\t\ttarget: document.body, // document.body is available thanks to JSDOM\n+\t\tprops: { initial: 0 },\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button')!.click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(comp);\n+});\n+\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle - the structure of your component might change and you then may need to adjust your query selectors more often than not. Solutions like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help you facilitate this problem.",
        "comment_created_at": "2024-07-25T20:02:26+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "```suggestion\r\nWhile the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1693635702",
    "pr_number": 12600,
    "pr_file": "documentation/docs/05-misc/02-testing.md",
    "created_at": "2024-07-26T21:53:11+00:00",
    "commented_code": "title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest:\n+\n+```bash\n+npm install -D vitest\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```diff\n+/// file: vite.config.js\n+- import { defineConfig } from 'vite';\n++ import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({ /* ... */ })\n+```\n+\n+You can now write unit tests for code inside your `.js/.ts` files:\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.js';\n+\n+test('Multiplier', () => {\n+\tlet double = multiplier(0, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tdouble.set(5);\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+### Component testing\n+\n+It is possible to test your components in isolation using Vitest.\n+\n+> Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\n+\n+To get started, install jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's `mount` API\n+\tconst component = mount(Component, {\n+\t\ttarget: document.body, // `document` exists because of jsdom\n+\t\tprops: { initial: 0 }\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button').click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(component);\n+});\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests. The above test could be rewritten like this:\n+\n+```js\n+/// file: component.test.js\n+import { render, screen } from '@testing-library/svelte';\n+import userEvent from '@testing-library/user-event';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', async () => {\n+\tconst user = userEvent.setup();\n+\trender(Component);",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1693635702",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1693635702",
        "commented_code": "@@ -2,7 +2,217 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest:\n+\n+```bash\n+npm install -D vitest\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```diff\n+/// file: vite.config.js\n+- import { defineConfig } from 'vite';\n++ import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({ /* ... */ })\n+```\n+\n+You can now write unit tests for code inside your `.js/.ts` files:\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.js';\n+\n+test('Multiplier', () => {\n+\tlet double = multiplier(0, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tdouble.set(5);\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+### Component testing\n+\n+It is possible to test your components in isolation using Vitest.\n+\n+> Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\n+\n+To get started, install jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's `mount` API\n+\tconst component = mount(Component, {\n+\t\ttarget: document.body, // `document` exists because of jsdom\n+\t\tprops: { initial: 0 }\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button').click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(component);\n+});\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests. The above test could be rewritten like this:\n+\n+```js\n+/// file: component.test.js\n+import { render, screen } from '@testing-library/svelte';\n+import userEvent from '@testing-library/user-event';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', async () => {\n+\tconst user = userEvent.setup();\n+\trender(Component);",
        "comment_created_at": "2024-07-26T21:53:11+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "how does it know when to unmount it?",
        "pr_file_module": null
      },
      {
        "comment_id": "1693638716",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1693635702",
        "commented_code": "@@ -2,7 +2,217 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest:\n+\n+```bash\n+npm install -D vitest\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```diff\n+/// file: vite.config.js\n+- import { defineConfig } from 'vite';\n++ import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({ /* ... */ })\n+```\n+\n+You can now write unit tests for code inside your `.js/.ts` files:\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.js';\n+\n+test('Multiplier', () => {\n+\tlet double = multiplier(0, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tdouble.set(5);\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+### Component testing\n+\n+It is possible to test your components in isolation using Vitest.\n+\n+> Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\n+\n+To get started, install jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's `mount` API\n+\tconst component = mount(Component, {\n+\t\ttarget: document.body, // `document` exists because of jsdom\n+\t\tprops: { initial: 0 }\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button').click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(component);\n+});\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests. The above test could be rewritten like this:\n+\n+```js\n+/// file: component.test.js\n+import { render, screen } from '@testing-library/svelte';\n+import userEvent from '@testing-library/user-event';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', async () => {\n+\tconst user = userEvent.setup();\n+\trender(Component);",
        "comment_created_at": "2024-07-26T21:58:52+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "It's explained in their [setup docs](https://testing-library.com/docs/svelte-testing-library/setup/#vitest) - they add a teardown behind the scenes. Didn't want to get into details here which would just mean repeating their docs, rather visualize how the resulting code is more robust to changes and more through the lens of a user.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1693636036",
    "pr_number": 12600,
    "pr_file": "documentation/docs/05-misc/02-testing.md",
    "created_at": "2024-07-26T21:53:51+00:00",
    "commented_code": "title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest:\n+\n+```bash\n+npm install -D vitest\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```diff\n+/// file: vite.config.js\n+- import { defineConfig } from 'vite';\n++ import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({ /* ... */ })\n+```\n+\n+You can now write unit tests for code inside your `.js/.ts` files:\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.js';\n+\n+test('Multiplier', () => {\n+\tlet double = multiplier(0, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tdouble.set(5);\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+### Component testing\n+\n+It is possible to test your components in isolation using Vitest.\n+\n+> Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\n+\n+To get started, install jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's `mount` API\n+\tconst component = mount(Component, {\n+\t\ttarget: document.body, // `document` exists because of jsdom\n+\t\tprops: { initial: 0 }\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button').click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(component);\n+});\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests. The above test could be rewritten like this:\n+\n+```js\n+/// file: component.test.js\n+import { render, screen } from '@testing-library/svelte';\n+import userEvent from '@testing-library/user-event';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', async () => {\n+\tconst user = userEvent.setup();\n+\trender(Component);\n+\n+\tconst button = screen.getByRole('button');\n+\texpect(button).toHaveTextContent(0);\n+\n+\tawait user.click(button);\n+\texpect(button).toHaveTextContent(1);\n+});\n+```\n+\n+When writing component tests that test two-way-bindings, context or snippet props, it's best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some [examples](https://testing-library.com/docs/svelte-testing-library/example) on how to achieve that.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1693636036",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 12600,
        "pr_file": "documentation/docs/05-misc/02-testing.md",
        "discussion_id": "1693636036",
        "commented_code": "@@ -2,7 +2,217 @@\n title: Testing\n ---\n \n-- component testing basics\n-- rune testing basics\n-- vitest setup\n-- e2e\n+Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use \u2014 you can write unit tests, integration tests, and end-to-end tests using solutions like Vitest, Jasmine, Cypress and Playwright.\n+\n+## Unit and integration testing using Vitest\n+\n+Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite (including via SvelteKit), we recommend using [Vitest](https://vitest.dev/).\n+\n+To get started, install Vitest:\n+\n+```bash\n+npm install -D vitest\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```diff\n+/// file: vite.config.js\n+- import { defineConfig } from 'vite';\n++ import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({ /* ... */ })\n+```\n+\n+You can now write unit tests for code inside your `.js/.ts` files:\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.js';\n+\n+test('Multiplier', () => {\n+\tlet double = multiplier(0, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tdouble.set(5);\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+### Using runes inside your test files\n+\n+It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename (e.g `multiplier.svelte.test.js`). After that, you can use runes inside your tests.\n+\n+```js\n+/// file: counter.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { multiplier } from './multiplier.svelte.js';\n+\n+test('Multiplier', () => {\n+\tlet count = $state(0);\n+\tlet double = multiplier(() => count, 2);\n+\n+\texpect(double.value).toEqual(0);\n+\n+\tcount = 5;\n+\n+\texpect(double.value).toEqual(10);\n+});\n+```\n+\n+If the tested code uses effects, you need to wrap the test inside `$effect.root` to create a scope in which these are properly captured.\n+\n+```js\n+/// file: logger.svelte.test.js\n+import { flushSync } from 'svelte';\n+import { expect, test } from 'vitest';\n+import { logger } from './logger.svelte.js';\n+\n+test('Effect', () => {\n+\tconst cleanup = $effect.root(() => {\n+\t\tlet count = $state(0);\n+\n+\t\t// logger uses an $effect to log updates of its input\n+\t\tlet log = logger(() => count);\n+\n+\t\t// effects normally run after a microtask,\n+\t\t// use flushSync to execute all pending effects synchronously\n+\t\tflushSync();\n+\t\texpect(log.value).toEqual([0]);\n+\n+\t\tcount = 1;\n+\t\tflushSync();\n+\n+\t\texpect(log.value).toEqual([0, 1]);\n+\t});\n+\n+\tcleanup();\n+});\n+```\n+\n+### Component testing\n+\n+It is possible to test your components in isolation using Vitest.\n+\n+> Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component\n+\n+To get started, install jsdom (a library that shims DOM APIs):\n+\n+```bash\n+npm install -D jsdom\n+```\n+\n+Then adjust your `vite.config.js`:\n+\n+```js\n+/// file: vite.config.js\n+import { defineConfig } from 'vitest/config';\n+\n+export default defineConfig({\n+\tplugins: [\n+\t\t/* ... */\n+\t],\n+\ttest: {\n+\t\t// If you are testing components client-side, you need to setup a DOM environment.\n+\t\t// If not all your files should have this environment, you can use a\n+\t\t// `// @vitest-environment jsdom` comment at the top of the test files instead.\n+\t\tenvironment: 'jsdom'\n+\t},\n+\t// Tell Vitest to use the `browser` entry points in `package.json` files, even though it's running in Node\n+\tresolve: process.env.VITEST\n+\t\t? {\n+\t\t\t\tconditions: ['browser']\n+\t\t\t}\n+\t\t: undefined\n+});\n+```\n+\n+After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:\n+\n+```js\n+/// file: component.test.js\n+import { flushSync, mount, unmount } from 'svelte';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', () => {\n+\t// Instantiate the component using Svelte's `mount` API\n+\tconst component = mount(Component, {\n+\t\ttarget: document.body, // `document` exists because of jsdom\n+\t\tprops: { initial: 0 }\n+\t});\n+\n+\texpect(document.body.innerHTML).toBe('<button>0</button>');\n+\n+\t// Click the button, then flush the changes so you can synchronously write expectations\n+\tdocument.body.querySelector('button').click();\n+\tflushSync();\n+\n+\texpect(document.body.innerHTML).toBe('<button>1</button>');\n+\n+\t// Remove the component from the DOM\n+\tunmount(component);\n+});\n+```\n+\n+While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like [@testing-library/svelte](https://testing-library.com/docs/svelte-testing-library/intro/) can help streamline your tests. The above test could be rewritten like this:\n+\n+```js\n+/// file: component.test.js\n+import { render, screen } from '@testing-library/svelte';\n+import userEvent from '@testing-library/user-event';\n+import { expect, test } from 'vitest';\n+import Component from './Component.svelte';\n+\n+test('Component', async () => {\n+\tconst user = userEvent.setup();\n+\trender(Component);\n+\n+\tconst button = screen.getByRole('button');\n+\texpect(button).toHaveTextContent(0);\n+\n+\tawait user.click(button);\n+\texpect(button).toHaveTextContent(1);\n+});\n+```\n+\n+When writing component tests that test two-way-bindings, context or snippet props, it's best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some [examples](https://testing-library.com/docs/svelte-testing-library/example) on how to achieve that.",
        "comment_created_at": "2024-07-26T21:53:51+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "```suggestion\r\nWhen writing component tests that involve two-way bindings, context or snippet props, it's best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some [examples](https://testing-library.com/docs/svelte-testing-library/example).\r\n```",
        "pr_file_module": null
      }
    ]
  }
]