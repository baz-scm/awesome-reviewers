[
  {
    "discussion_id": "2205211391",
    "pr_number": 15844,
    "pr_file": "packages/svelte/src/internal/client/dom/elements/bindings/input.js",
    "created_at": "2025-07-14T15:25:14+00:00",
    "commented_code": "var value = get();\n \n+\t\tif (input === document.activeElement) {",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2205211391",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15844,
        "pr_file": "packages/svelte/src/internal/client/dom/elements/bindings/input.js",
        "discussion_id": "2205211391",
        "commented_code": "@@ -64,6 +64,10 @@ export function bind_value(input, get, set = get) {\n \n \t\tvar value = get();\n \n+\t\tif (input === document.activeElement) {",
        "comment_created_at": "2025-07-14T15:25:14+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "what's the reason for this change? Can't imagine this breaking anyone to be fair",
        "pr_file_module": null
      },
      {
        "comment_id": "2205267032",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15844,
        "pr_file": "packages/svelte/src/internal/client/dom/elements/bindings/input.js",
        "discussion_id": "2205211391",
        "commented_code": "@@ -64,6 +64,10 @@ export function bind_value(input, get, set = get) {\n \n \t\tvar value = get();\n \n+\t\tif (input === document.activeElement) {",
        "comment_created_at": "2025-07-14T15:51:59+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "in a case like this, if you type 'potato' and then `find('p')` resolves, Svelte will replace the input contents with 'p' because that's the `query` that goes with the resolved promise. Most of the time that's what you want, but it's absolutely _not_ what you want if the input itself was the source of the change \u2014\u00a0instead you want the UI to 'catch up' to a focused input\r\n\r\n```svelte\r\n<input bind:value={query}>\r\n<p>{await find(query)}</p>\r\n```\r\n\r\nadded an explanatory comment",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177819246",
    "pr_number": 16270,
    "pr_file": "packages/svelte/src/internal/client/reactivity/props.js",
    "created_at": "2025-07-01T14:50:02+00:00",
    "commented_code": "if (!runes || !mutation || legacy_parent || is_store_sub) {\n \t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n \t\t\t\t}\n+\n \t\t\t\treturn value;\n-\t\t\t} else {\n-\t\t\t\treturn getter();\n \t\t\t}\n+\n+\t\t\treturn getter();\n \t\t};\n \t}\n \n-\t// hard mode. this is where it gets ugly \u2014 the value in the child should\n-\t// synchronize with the parent, but it should also be possible to temporarily\n-\t// set the value to something else locally.\n-\tvar from_child = false;\n-\tvar was_from_child = false;\n-\n-\t// The derived returns the current value. The underlying mutable\n-\t// source is written to from various places to persist this value.\n-\tvar inner_current_value = mutable_source(prop_value);\n-\tvar current_value = derived(() => {\n-\t\tvar parent_value = getter();\n-\t\tvar child_value = get(inner_current_value);\n-\n-\t\tif (from_child) {\n-\t\t\tfrom_child = false;\n-\t\t\twas_from_child = true;\n-\t\t\treturn child_value;\n-\t\t}\n-\n-\t\twas_from_child = false;\n-\t\treturn (inner_current_value.v = parent_value);\n-\t});\n-\n-\t// Ensure we eagerly capture the initial value if it's bindable\n-\tif (bindable) {\n-\t\tget(current_value);\n-\t}\n+\t// prop is written to, but there's no binding, which means we\n+\t// create a derived that we can write to locally\n+\tvar d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(getter);\n \n-\tif (!immutable) current_value.equals = safe_equals;\n+\t// Capture the initial value if it's bindable\n+\tif (bindable) get(d);\n \n \treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n-\t\t// legacy nonsense \u2014 need to ensure the source is invalidated when necessary\n-\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n-\t\tif (captured_signals !== null) {\n-\t\t\t// set this so that we don't reset to the parent value if `d`\n-\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n-\t\t\t// than because the parent or child value changed)\n-\t\t\tfrom_child = was_from_child;\n-\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n-\t\t\tgetter();\n-\t\t\tget(inner_current_value);\n-\t\t}\n-\n \t\tif (arguments.length > 0) {\n-\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n-\n-\t\t\tif (!current_value.equals(new_value)) {\n-\t\t\t\tfrom_child = true;\n-\t\t\t\tset(inner_current_value, new_value);\n-\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n-\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n-\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n-\t\t\t\t\tfallback_value = new_value;\n-\t\t\t\t}\n+\t\t\tconst new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;\n \n-\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n-\t\t\t\t\treturn value;\n-\t\t\t\t}\n+\t\t\tset(d, new_value);\n \n-\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n+\t\t\tif (fallback_value !== undefined) {\n+\t\t\t\tfallback_value = new_value;\n \t\t\t}\n \n \t\t\treturn value;\n \t\t}\n \n-\t\tif (has_destroyed_component_ctx(current_value)) {\n-\t\t\treturn current_value.v;\n+\t\t// TODO is this still necessary post-#16263?",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "2177819246",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 16270,
        "pr_file": "packages/svelte/src/internal/client/reactivity/props.js",
        "discussion_id": "2177819246",
        "commented_code": "@@ -352,82 +346,39 @@ export function prop(props, key, flags, fallback) {\n \t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n \t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n \t\t\t\t}\n+\n \t\t\t\treturn value;\n-\t\t\t} else {\n-\t\t\t\treturn getter();\n \t\t\t}\n+\n+\t\t\treturn getter();\n \t\t};\n \t}\n \n-\t// hard mode. this is where it gets ugly \u2014 the value in the child should\n-\t// synchronize with the parent, but it should also be possible to temporarily\n-\t// set the value to something else locally.\n-\tvar from_child = false;\n-\tvar was_from_child = false;\n-\n-\t// The derived returns the current value. The underlying mutable\n-\t// source is written to from various places to persist this value.\n-\tvar inner_current_value = mutable_source(prop_value);\n-\tvar current_value = derived(() => {\n-\t\tvar parent_value = getter();\n-\t\tvar child_value = get(inner_current_value);\n-\n-\t\tif (from_child) {\n-\t\t\tfrom_child = false;\n-\t\t\twas_from_child = true;\n-\t\t\treturn child_value;\n-\t\t}\n-\n-\t\twas_from_child = false;\n-\t\treturn (inner_current_value.v = parent_value);\n-\t});\n-\n-\t// Ensure we eagerly capture the initial value if it's bindable\n-\tif (bindable) {\n-\t\tget(current_value);\n-\t}\n+\t// prop is written to, but there's no binding, which means we\n+\t// create a derived that we can write to locally\n+\tvar d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(getter);\n \n-\tif (!immutable) current_value.equals = safe_equals;\n+\t// Capture the initial value if it's bindable\n+\tif (bindable) get(d);\n \n \treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n-\t\t// legacy nonsense \u2014 need to ensure the source is invalidated when necessary\n-\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n-\t\tif (captured_signals !== null) {\n-\t\t\t// set this so that we don't reset to the parent value if `d`\n-\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n-\t\t\t// than because the parent or child value changed)\n-\t\t\tfrom_child = was_from_child;\n-\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n-\t\t\tgetter();\n-\t\t\tget(inner_current_value);\n-\t\t}\n-\n \t\tif (arguments.length > 0) {\n-\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n-\n-\t\t\tif (!current_value.equals(new_value)) {\n-\t\t\t\tfrom_child = true;\n-\t\t\t\tset(inner_current_value, new_value);\n-\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n-\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n-\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n-\t\t\t\t\tfallback_value = new_value;\n-\t\t\t\t}\n+\t\t\tconst new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;\n \n-\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n-\t\t\t\t\treturn value;\n-\t\t\t\t}\n+\t\t\tset(d, new_value);\n \n-\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n+\t\t\tif (fallback_value !== undefined) {\n+\t\t\t\tfallback_value = new_value;\n \t\t\t}\n \n \t\t\treturn value;\n \t\t}\n \n-\t\tif (has_destroyed_component_ctx(current_value)) {\n-\t\t\treturn current_value.v;\n+\t\t// TODO is this still necessary post-#16263?",
        "comment_created_at": "2025-07-01T14:50:02+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "Pretty sure yes because things not read in a teardown can still cause bugs as seen in https://github.com/sveltejs/svelte/issues/16072 - we might need to make props signals after all, gonna investigate that soon",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1793467509",
    "pr_number": 13542,
    "pr_file": "packages/svelte/src/internal/client/render.js",
    "created_at": "2024-10-09T12:50:17+00:00",
    "commented_code": "* @returns {void}\n  */\n export function set_text(text, value) {\n+\t// For objects, we apply string coercion before diffing",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1793467509",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13542,
        "pr_file": "packages/svelte/src/internal/client/render.js",
        "discussion_id": "1793467509",
        "commented_code": "@@ -48,11 +48,13 @@ export function set_should_intro(value) {\n  * @returns {void}\n  */\n export function set_text(text, value) {\n+\t// For objects, we apply string coercion before diffing",
        "comment_created_at": "2024-10-09T12:50:17+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\r\n```",
        "pr_file_module": null
      }
    ]
  }
]