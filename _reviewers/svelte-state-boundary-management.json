[
  {
    "discussion_id": "1930993136",
    "pr_number": 15107,
    "pr_file": "documentation/docs/02-runes/05-$effect.md",
    "created_at": "2025-01-27T18:16:56+00:00",
    "commented_code": "title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1930993136",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-01-27T18:16:56+00:00",
        "comment_author": "Rich-Harris",
        "comment_body": "this wording feels a bit strong. if we're so adamant that you shouldn't update state inside an effect, why do we allow it? it also feels quite vague \u2014 what is the nightmare exactly? it would be good if we could articulate _why_ we warn against this",
        "pr_file_module": null
      },
      {
        "comment_id": "1932882413",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-01-28T21:30:05+00:00",
        "comment_author": "benmccann",
        "comment_body": "> if we're so adamant that you shouldn't update state inside an effect, why do we allow it?\r\n\r\nI would love if someone could answer why we allow it. It causes so many problems and we could save users from themselves",
        "pr_file_module": null
      },
      {
        "comment_id": "1933683590",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-01-29T11:08:18+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "Because it is unavoidable in some scenarios. Angular actually had a setting where writing inside effects was disallowed and they removed it because it caused so many headaches (and didn't actually help, most people just turned on the option)",
        "pr_file_module": null
      },
      {
        "comment_id": "1937539140",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-01-31T16:01:16+00:00",
        "comment_author": "benmccann",
        "comment_body": "It might be useful to have an example of where it is unavoidable. I have yet to see such a scenario - though it can sometimes be tricky to figure out how to write the code in such a way where you avoid it (e.g. needing the trick Paolo was sharing) and I frequently see people using it as a shortcut",
        "pr_file_module": null
      },
      {
        "comment_id": "1945450513",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-06T21:11:52+00:00",
        "comment_author": "ahkelly",
        "comment_body": "What is the correct solution then to https://github.com/sveltejs/kit/issues/12999 if not 3.2? I would never need to use $effect() if this was solved. Offering the boiler plate \"use a callback\" as an option has not worked for me in very specific situations.",
        "pr_file_module": null
      },
      {
        "comment_id": "1945486274",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-06T21:25:04+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "That's state in a derived:\r\n\r\n```svelte\r\n<script>\r\n    let { data } = $props();\r\n    let writable_data = $derived.by(()=>{\r\n        let ret = $state({ current: data.value });\r\n        return ret;\r\n    });\r\n</script>\r\n\r\n<button on click={()=>writable_data.current++}>+1</button>",
        "pr_file_module": null
      },
      {
        "comment_id": "1945524259",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-06T21:49:32+00:00",
        "comment_author": "ahkelly",
        "comment_body": "Ignoring how ugly that workaround is :) in a brief test, this appears to only work in the same scenarios as a callback does and does not catch the edge cases that $effect() does. It appears that when complex async requests are made as a result of an action data is invalidated before some of these async functions have completed thus the $derived does not see the final updated data.",
        "pr_file_module": null
      },
      {
        "comment_id": "1945607810",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-06T23:22:23+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "Can you provide a repl?",
        "pr_file_module": null
      },
      {
        "comment_id": "1946661004",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-07T14:55:46+00:00",
        "comment_author": "ahkelly",
        "comment_body": "Sorry, I acutely understand that telling you something \"doesn't work like it used to in svelte 4\" is of very little help to troubleshooting it. I will need to think about how to structure a repl. Currently the steps \"simplified\" are as follows\r\n\r\n1. Click a button to request to print an order.\r\n2. The report is generated from an `api/report/server.js` endpoint call.\r\n3. The report is sent to a print utility (which adds the report to a hidden iframe for printing and then essentially `.print()` is triggered.\r\n4. Once printed 2 database tables are updated with a) the \"print task has been completed\" and b) a \"status\" in the original order.\r\n5. A status button on the original order for print status turns green after it receives the invalidated/updated data from the load function that returns the new values saved to the db from step 4 above. I understand this can be done by managing a separating state object for these statuses which is what I am currently now doing, which I didn't have to do in svelte 4. However even this `$state` object is not updated until I either 1) manually invalidate the load data or I add an update of the `$state` status in an effect essentially\r\n```\r\n$effect(() => {\r\n  order_tasks_state.printed = data?.order_array?.recordset[0]?.soPreferencePrint;\r\n}\r\n```\r\nSo its seems that svelte 5's reading of the \"auto/kit\" invalidated data has changed or is happening earlier than previous.",
        "pr_file_module": null
      },
      {
        "comment_id": "1946698420",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-07T15:18:40+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "So yeah, you cannot write directly to `data`...but with my suggestion you don't have to write to data, you have to write to the `writable_data` that is the returned from the `$derived.by`...the `$derived.by` dance is only important to make sure that whenever `data` is invalidated by sveltekit it will reset to the \"right\" value.",
        "pr_file_module": null
      },
      {
        "comment_id": "1946727762",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-07T15:38:09+00:00",
        "comment_author": "ahkelly",
        "comment_body": "I understand what you are saying but I am not writing to data but reading from the data. Using `$derived.by` is not picking up the newest invalidated data in certain circumstances like I note above. In these situations only `$effect` is picking up the change. In 95%+ of situations simply using `data.variable_name` will always give you the reactive data value like it did 100% of the time in svelte 4. In the other 5%, which you can find numerous reports in the discord of the same since the svelte 5 migration only using `$effect` works as noted in the issue I provided as well as here https://github.com/sveltejs/svelte/issues/14536#issuecomment-2515644138. \r\n\r\nI only waste bandwidth here on this as the maintainers seem hellbent on removing `$effect` (and seemingly `bind:`), which I am ok with but they need to first fix these lingering edge cases that are new to svelte 5/kit. I apologize for the interruption and wasting of your time on this, please don't waste anymore time on it as I am sure others (than me) with more influence/understanding of the issue will eventually solve/revert it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1947142910",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-07T20:26:40+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "> Using $derived.by is not picking up the newest invalidated data in certain circumstances like I note above\r\n\r\nWhat i'm asking you then is to open an issue with the reproduction of this...because to me it doesn't make sense since the dependency resolution for both derived and effect is the same. If you can provide such example it would be very valuable since if this is a bug we need to fix it. The steps to reproduce you provided are vague and i don't see why doing them with derived instead of effect should change anything.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1947174967",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-07T20:50:06+00:00",
        "comment_author": "ahkelly",
        "comment_body": "Completely understand and thank you. I will endeavour to come up with a generic reproduction but not sure how I simulate the data request to our backend in a repl.",
        "pr_file_module": null
      },
      {
        "comment_id": "1947177274",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-02-07T20:52:17+00:00",
        "comment_author": "paoloricciuti",
        "comment_body": "You can use https://sveltelab.dev to make a sveltekit reproduction...and obviously your backend should not be involved in the minimal reproduction. Just try to reproduce the \"async behavior\" you are seeing",
        "pr_file_module": null
      },
      {
        "comment_id": "2008204491",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 15107,
        "pr_file": "documentation/docs/02-runes/05-$effect.md",
        "discussion_id": "1930993136",
        "commented_code": "@@ -2,15 +2,11 @@\n title: $effect\n ---\n \n-Effects are what make your application _do things_. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside [`untrack`](svelte#untrack)), and re-runs the function when that state later changes.\n+Effects are used for making your application perform _actions_. You might use it to do things like call a third-party library, draw on a `<canvas>` element, or make a network request. It's important to distinguish these actions from updating state, which should not be done inside an effect.\n \n-Most of the effects in a Svelte app are created by Svelte itself \u2014 they're the bits that update the text in `<h1>hello {name}!</h1>` when `name` changes, for example.\n+> [!NOTE] Your application will become a nightmare to deal with almost immediately if you try to update state inside an effect. If you're tempted to use an effect to update state, see [when not to use `$effect`](#When-not-to-use-$effect) to learn about alternative approaches.",
        "comment_created_at": "2025-03-21T19:23:38+00:00",
        "comment_author": "benmccann",
        "comment_body": "Addressed in https://github.com/sveltejs/svelte/pull/15570",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1854635626",
    "pr_number": 14311,
    "pr_file": "documentation/docs/02-runes/02-$state.md",
    "created_at": "2024-11-22T20:43:26+00:00",
    "commented_code": "This can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state (for example, a raw array of reactive objects).\n \n+## Passing `$state` across boundaries\n+\n+Since there's no wrapper around `$state` or `$state.raw` (or [`$derived`]($derived)), you have to be aware of keeping reactivity alive when passing it across boundaries, e.g. when you pass a reactive object into or out of a function. The most succinct way of thinking about this is to treat `$state` and `$state.raw` (and [`$derived`]($derived)) as \"just JavaScript\", and reuse the knowledge of how normal JavaScript variables work when crossing boundaries. Take the following example:\n+\n+```js\n+// @errors: 7006\n+function createTodo(initial) {\n+\tlet text = initial;\n+\tlet done = false;\n+\treturn {\n+\t\ttext,\n+\t\tdone,\n+\t\tlog: () => console.log(text, done)\n+\t}\n+}\n+\n+const todo = createTodo('wrong');\n+todo.log(); // logs \"'wrong', false\"\n+todo.done = true;\n+todo.log(); // still logs \"'wrong', false\"\n+```\n+\n+The value change does not propagate back into the function body of `createTodo`, because `text` and `done` are read at the point of return, and are therefore a fixed value. To make that work, we have to bring the read and write into the scope of the function body. This can be done via getter/setters or via function calls:\n+\n+```js\n+// @errors: 7006\n+function createTodo(initial) {\n+\tlet text = initial;\n+\tlet done = false;\n+\treturn {\n+\t\t// using getter/setter\n+\t\tget text() { return text },\n+\t\tset text(v) { text = v },\n+\t\t// using functions\n+\t\tisDone() { return done },\n+\t\ttoggle() { done = !done },\n+\t\t// log\n+\t\tlog: () => console.log(text, done)\n+\t}\n+}\n+\n+const todo = createTodo('right');\n+todo.log(); // logs \"'right', false\"\n+todo.text = 'changed'; // invokes the setter\n+todo.toggle(); // invokes the function\n+todo.log(); // logs \"'changed', true\"\n+```\n+\n+What you could also do is to instead create an object and return that as a whole. While the variable itself is fixed in time, its properties are not, and so they can be changed from the outside and the changes are observable from within the function:\n+\n+```js\n+// @errors: 7006\n+function createTodo(initial) {\n+\tconst todo = { text: initial, done: false }\n+\treturn {\n+\t\ttodo,\n+\t\tlog: () => console.log(todo.text, todo.done)\n+\t}\n+}\n+\n+const todo = createTodo('right');\n+todo.log(); // logs \"'right', false\"\n+todo.todo.done = true; // mutates the object\n+todo.log(); // logs \"'right', true\"\n+```\n+\n+Classes are similar, their properties are \"live\" due to the `this` context:\n+\n+```js\n+// @errors: 7006\n+class Todo {\n+\tdone = false;\n+\ttext;\n+\n+\tconstructor(text) {\n+\t\tthis.text = text;\n+\t}\n+\n+\tlog() {\n+\t\tconsole.log(this.done, this.text)\n+\t}\n+}\n+\n+const todo = new Todo('right');\n+todo.log(); // logs \"'right', false\"\n+todo.done = true;\n+todo.log(); // logs \"'right', true\"\n+```\n+\n+Notice how we didn't use _any_ Svelte specifics, this is just regular JavaScript semantics. `$state` and `$state.raw` (and [`$derived`]($derived)) don't change these, they just add reactivity on top, so that when you change a variable something can happen in reaction to it.\n+\n+As a consequence, the answer to preserving reactivity across boundaries is to use getters/setters or functions (in case of `$state`, `$state.raw` and `$derived`) or an object with mutable properties (in case of `$state`), or a class with reactive properties.",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1854635626",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 14311,
        "pr_file": "documentation/docs/02-runes/02-$state.md",
        "discussion_id": "1854635626",
        "commented_code": "@@ -111,6 +137,165 @@ person = {\n \n This can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state (for example, a raw array of reactive objects).\n \n+## Passing `$state` across boundaries\n+\n+Since there's no wrapper around `$state` or `$state.raw` (or [`$derived`]($derived)), you have to be aware of keeping reactivity alive when passing it across boundaries, e.g. when you pass a reactive object into or out of a function. The most succinct way of thinking about this is to treat `$state` and `$state.raw` (and [`$derived`]($derived)) as \"just JavaScript\", and reuse the knowledge of how normal JavaScript variables work when crossing boundaries. Take the following example:\n+\n+```js\n+// @errors: 7006\n+function createTodo(initial) {\n+\tlet text = initial;\n+\tlet done = false;\n+\treturn {\n+\t\ttext,\n+\t\tdone,\n+\t\tlog: () => console.log(text, done)\n+\t}\n+}\n+\n+const todo = createTodo('wrong');\n+todo.log(); // logs \"'wrong', false\"\n+todo.done = true;\n+todo.log(); // still logs \"'wrong', false\"\n+```\n+\n+The value change does not propagate back into the function body of `createTodo`, because `text` and `done` are read at the point of return, and are therefore a fixed value. To make that work, we have to bring the read and write into the scope of the function body. This can be done via getter/setters or via function calls:\n+\n+```js\n+// @errors: 7006\n+function createTodo(initial) {\n+\tlet text = initial;\n+\tlet done = false;\n+\treturn {\n+\t\t// using getter/setter\n+\t\tget text() { return text },\n+\t\tset text(v) { text = v },\n+\t\t// using functions\n+\t\tisDone() { return done },\n+\t\ttoggle() { done = !done },\n+\t\t// log\n+\t\tlog: () => console.log(text, done)\n+\t}\n+}\n+\n+const todo = createTodo('right');\n+todo.log(); // logs \"'right', false\"\n+todo.text = 'changed'; // invokes the setter\n+todo.toggle(); // invokes the function\n+todo.log(); // logs \"'changed', true\"\n+```\n+\n+What you could also do is to instead create an object and return that as a whole. While the variable itself is fixed in time, its properties are not, and so they can be changed from the outside and the changes are observable from within the function:\n+\n+```js\n+// @errors: 7006\n+function createTodo(initial) {\n+\tconst todo = { text: initial, done: false }\n+\treturn {\n+\t\ttodo,\n+\t\tlog: () => console.log(todo.text, todo.done)\n+\t}\n+}\n+\n+const todo = createTodo('right');\n+todo.log(); // logs \"'right', false\"\n+todo.todo.done = true; // mutates the object\n+todo.log(); // logs \"'right', true\"\n+```\n+\n+Classes are similar, their properties are \"live\" due to the `this` context:\n+\n+```js\n+// @errors: 7006\n+class Todo {\n+\tdone = false;\n+\ttext;\n+\n+\tconstructor(text) {\n+\t\tthis.text = text;\n+\t}\n+\n+\tlog() {\n+\t\tconsole.log(this.done, this.text)\n+\t}\n+}\n+\n+const todo = new Todo('right');\n+todo.log(); // logs \"'right', false\"\n+todo.done = true;\n+todo.log(); // logs \"'right', true\"\n+```\n+\n+Notice how we didn't use _any_ Svelte specifics, this is just regular JavaScript semantics. `$state` and `$state.raw` (and [`$derived`]($derived)) don't change these, they just add reactivity on top, so that when you change a variable something can happen in reaction to it.\n+\n+As a consequence, the answer to preserving reactivity across boundaries is to use getters/setters or functions (in case of `$state`, `$state.raw` and `$derived`) or an object with mutable properties (in case of `$state`), or a class with reactive properties.",
        "comment_created_at": "2024-11-22T20:43:26+00:00",
        "comment_author": "benmccann",
        "comment_body": "```suggestion\r\nAs a consequence, the answer to preserving reactivity across boundaries is to use getters/setters or functions (in case of `$state`, `$state.raw` and `$derived`), an object with mutable properties (in case of `$state`), or a class with reactive properties.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1824199374",
    "pr_number": 13994,
    "pr_file": "documentation/docs/02-runes/05-$props.md",
    "created_at": "2024-10-31T10:07:02+00:00",
    "commented_code": "</button>\n ```\n \n+Prop variables are not automatically deeply reactive. What happens when mutating one of their properties depends on what the parent passed in. For example if the parent passed a non-reactive POJO as a prop, setting a property of that object in the child will not cause the component to update ([demo](/playground/untitled#H4sIAAAAAAAAE3VPS07DMBC9yshCaiuqBLYhjoQ4Q1eEReJOVIMztuJJBbJ8d-IkEqXQ5bx53yCo6VEU4kCs2eBR7EWnDXpRvAbBXy79EjDhK_PZucyf0XDC2sbjf7iyxEg82YjSq0E7rmqqWffODgwvJ22O0A22h02Wz9cq3TzVVOY_CioXrm3fUbEMQdmRuICHGCGvpiDGTxYFDyPG_Y3Cl_6_K199bpQ2yBDWBhBBwp0brPPb3Z-u7chsCSwpo9WHDNsdyApCMslzODUeyAJ23WSUsMUymyfBvYTHmmKcI2e9LyBcUmKKWyKulr_Fb2Z_SHPIAQAA)):\n+\n+```svelte\n+<--- file: App.svelte --->\n+<script>\n+\timport Child from './Child.svelte';\n+\n+\tlet object = $state({count: 0});\n+</script>\n+\n+<Child {object} />\n+```\n+\n+```svelte\n+<--- file: Child.svelte --->\n+<script>\n+\tlet { object } = $props();\n+</script>\n+\n+<button onclick={() => {\n+\t// has no effect\n+\tobject.count += 1\n+}}>\n+\tclicks: {object.count}\n+</button>\n+```\n+\n+However if the value passed in by the parent component is itself a deeply reactive state object, then it will be deeply reactive in the child, too ([demo](/playground/untitled#H4sIAAAAAAAAE3WQwU7DMBBEf2VlITUVVQLXkERC_YaeCIfE2aoujm3FGwqy_O_YcSug0KNnx7Nv1jHVjchKtlMkSOLANmwvJFpWvjhGnybOohD0s_PZmNy-o6So9Z3F_3SuFaGiEMMqyydhqGlVS2I0eiLYHoQcYD_pEVZ5sbzOX1dPwRaMEgl0f0ROUMOdpY4wc1zPikp48OvgqorvXFWlRJe-eCiawED4QaykaUa_udHl5-rfba4mN_pETHcB9RHVTNrY7C9gPxNpBVpxKfhb7bI11A24GFIUcBJSAu9mi0AHhKUo9Cj1CUjDbIbQP1rTpjzN72t4bJX3C8kSa8vLCZLFR4q0-eogr_4LN7sC9foBAAA=)):\n+\n+```svelte\n+<--- file: App.svelte --->\n+<script>\n+\timport Child from './Child.svelte';\n+\n+\tlet object = $state({count: 0});\n+</script>\n+\n+<Child {object} />\n+```\n+\n+```svelte\n+<--- file: Child.svelte --->\n+<script>\n+\tlet { object } = $props();\n+</script>\n+\n+<button onclick={() => {\n+\t// will cause the count below to update\n+\tobject.count += 1\n+}}>\n+\tclicks: {object.count}\n+</button>\n+```\n+",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1824199374",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13994,
        "pr_file": "documentation/docs/02-runes/05-$props.md",
        "discussion_id": "1824199374",
        "commented_code": "@@ -94,6 +92,60 @@ References to a prop inside a component update when the prop itself updates \u2014\n </button>\n ```\n \n+Prop variables are not automatically deeply reactive. What happens when mutating one of their properties depends on what the parent passed in. For example if the parent passed a non-reactive POJO as a prop, setting a property of that object in the child will not cause the component to update ([demo](/playground/untitled#H4sIAAAAAAAAE3VPS07DMBC9yshCaiuqBLYhjoQ4Q1eEReJOVIMztuJJBbJ8d-IkEqXQ5bx53yCo6VEU4kCs2eBR7EWnDXpRvAbBXy79EjDhK_PZucyf0XDC2sbjf7iyxEg82YjSq0E7rmqqWffODgwvJ22O0A22h02Wz9cq3TzVVOY_CioXrm3fUbEMQdmRuICHGCGvpiDGTxYFDyPG_Y3Cl_6_K199bpQ2yBDWBhBBwp0brPPb3Z-u7chsCSwpo9WHDNsdyApCMslzODUeyAJ23WSUsMUymyfBvYTHmmKcI2e9LyBcUmKKWyKulr_Fb2Z_SHPIAQAA)):\n+\n+```svelte\n+<--- file: App.svelte --->\n+<script>\n+\timport Child from './Child.svelte';\n+\n+\tlet object = $state({count: 0});\n+</script>\n+\n+<Child {object} />\n+```\n+\n+```svelte\n+<--- file: Child.svelte --->\n+<script>\n+\tlet { object } = $props();\n+</script>\n+\n+<button onclick={() => {\n+\t// has no effect\n+\tobject.count += 1\n+}}>\n+\tclicks: {object.count}\n+</button>\n+```\n+\n+However if the value passed in by the parent component is itself a deeply reactive state object, then it will be deeply reactive in the child, too ([demo](/playground/untitled#H4sIAAAAAAAAE3WQwU7DMBBEf2VlITUVVQLXkERC_YaeCIfE2aoujm3FGwqy_O_YcSug0KNnx7Nv1jHVjchKtlMkSOLANmwvJFpWvjhGnybOohD0s_PZmNy-o6So9Z3F_3SuFaGiEMMqyydhqGlVS2I0eiLYHoQcYD_pEVZ5sbzOX1dPwRaMEgl0f0ROUMOdpY4wc1zPikp48OvgqorvXFWlRJe-eCiawED4QaykaUa_udHl5-rfba4mN_pETHcB9RHVTNrY7C9gPxNpBVpxKfhb7bI11A24GFIUcBJSAu9mi0AHhKUo9Cj1CUjDbIbQP1rTpjzN72t4bJX3C8kSa8vLCZLFR4q0-eogr_4LN7sC9foBAAA=)):\n+\n+```svelte\n+<--- file: App.svelte --->\n+<script>\n+\timport Child from './Child.svelte';\n+\n+\tlet object = $state({count: 0});\n+</script>\n+\n+<Child {object} />\n+```\n+\n+```svelte\n+<--- file: Child.svelte --->\n+<script>\n+\tlet { object } = $props();\n+</script>\n+\n+<button onclick={() => {\n+\t// will cause the count below to update\n+\tobject.count += 1\n+}}>\n+\tclicks: {object.count}\n+</button>\n+```\n+",
        "comment_created_at": "2024-10-31T10:07:02+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "````suggestion\r\n\r\nThe fallback value of a prop not declared with `$bindable` is treated like a non-reactive POJO, and therefore also doesn't update the component when mutating its properties.\r\n\r\n```svelte\r\n<--- file: Child.svelte --->\r\n<script>\r\n\tlet { object = { count = 0 } } = $props();\r\n</script>\r\n<button onclick={() => {\r\n\t// has no effect if the fallback value is used\r\n\tobject.count += 1\r\n}}>\r\n\tclicks: {object.count}\r\n</button>\r\n```\r\n\r\nIn general, mutating props is discouraged, instead use callback props to make it easier to reason about state and changes to that state. If parent and child should share (and be allowed to mutate) the same object, then use the [$bindable]($bindable) rune.\r\n\r\n````",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1824200957",
    "pr_number": 13994,
    "pr_file": "documentation/docs/02-runes/05-$props.md",
    "created_at": "2024-10-31T10:08:16+00:00",
    "commented_code": "let { adjective = 'happy' } = $props();\n ```",
    "repo_full_name": "sveltejs/svelte",
    "discussion_comments": [
      {
        "comment_id": "1824200957",
        "repo_full_name": "sveltejs/svelte",
        "pr_number": 13994,
        "pr_file": "documentation/docs/02-runes/05-$props.md",
        "discussion_id": "1824200957",
        "commented_code": "@@ -44,8 +44,6 @@ Destructuring allows us to declare fallback values, which are used if the parent\n let { adjective = 'happy' } = $props();\n ```\n ",
        "comment_created_at": "2024-10-31T10:08:16+00:00",
        "comment_author": "dummdidumm",
        "comment_body": "```suggestion\r\n\r\n> [!NOTE] Fallback values are not turned into reactive state proxies (see [Updating props](#Updating-props) for more info)\r\n\r\n```",
        "pr_file_module": null
      }
    ]
  }
]