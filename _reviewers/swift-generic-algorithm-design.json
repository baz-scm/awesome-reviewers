[
  {
    "discussion_id": "287050803",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-05-23T17:21:43+00:00",
    "commented_code": "{",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "287050803",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "287050803",
        "commented_code": "@@ -0,0 +1,1108 @@\n+{",
        "comment_created_at": "2019-05-23T17:21:43+00:00",
        "comment_author": "bartchr808",
        "comment_body": "<p>(regarding `FilterPredicate`)</p><p><strong>Eugene:</strong></p><blockquote>Why not use a function type instead?</blockquote><p><strong>Bart:</strong></p><blockquote>That's definitely another option! I thought of using another protocol, but it can be a bit overkill here.&nbsp;</blockquote><blockquote><br></blockquote><blockquote>Let me know what you think, as to whether just have a function, keep it with the protocol, or show both examples.</blockquote>\n\n _Reply via <a href='https://app.reviewnb.com/tensorflow/swift/pull/187/discussion/'>ReviewNB</a>_ <div id='ReviewNBCommentContext-DoNotDelete' style='display:none' data-state='OPEN' data-cellIndex='33'/>",
        "pr_file_module": null
      },
      {
        "comment_id": "287436632",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "287050803",
        "commented_code": "@@ -0,0 +1,1108 @@\n+{",
        "comment_created_at": "2019-05-24T16:41:47+00:00",
        "comment_author": "bartchr808",
        "comment_body": "@burmako Wanted to see what you think",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "310343661",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-08-03T08:08:29+00:00",
    "commented_code": "{\n  \"nbformat\": 4,\n  \"nbformat_minor\": 0,\n  \"metadata\": {\n    \"colab\": {\n      \"name\": \"protocol.ipynb\",\n      \"version\": \"0.3.2\",\n      \"provenance\": [],\n      \"collapsed_sections\": []\n    },\n    \"language_info\": {\n      \"file_extension\": \".swift\",\n      \"mimetype\": \"text/x-swift\",\n      \"name\": \"swift\",\n      \"version\": \"\"\n    },\n    \"kernelspec\": {\n      \"display_name\": \"Swift\",\n      \"language\": \"swift\",\n      \"name\": \"swift\"\n    }\n  },\n  \"cells\": [\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"ZloPIuRHn97X\"\n      },\n      \"source\": [\n        \"##### Copyright 2019 The TensorFlow Authors. [Licensed under the Apache License, Version 2.0](#scrollTo=Afd8bu4xJOgh).\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"colab_type\": \"code\",\n        \"id\": \"tNgCmfUvJNoF\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"#@title Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); { display-mode: \\\"form\\\" }\\n\",\n        \"// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\",\n        \"// you may not use this file except in compliance with the License.\\n\",\n        \"// You may obtain a copy of the License at\\n\",\n        \"//\\n\",\n        \"// https://www.apache.org/licenses/LICENSE-2.0\\n\",\n        \"//\\n\",\n        \"// Unless required by applicable law or agreed to in writing, software\\n\",\n        \"// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\",\n        \"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\",\n        \"// See the License for the specific language governing permissions and\\n\",\n        \"// limitations under the License.\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"AlvdCHw5JGyx\"\n      },\n      \"source\": [\n        \"<table class=\\\"tfo-notebook-buttons\\\" align=\\\"left\\\">\\n\",\n        \"  <td>\\n\",\n        \"    <a target=\\\"_blank\\\" href=\\\"https://www.tensorflow.org/swift/tutorials/protocol_oriented_generics\\\"><img src=\\\"https://www.tensorflow.org/images/tf_logo_32px.png\\\" />View on TensorFlow.org</a>\\n\",\n        \"  </td>\\n\",\n        \"  <td>\\n\",\n        \"    <a target=\\\"_blank\\\" href=\\\"https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/colab_logo_32px.png\\\" />Run in Google Colab</a>\\n\",\n        \"  </td>\\n\",\n        \"  <td>\\n\",\n        \"    <a target=\\\"_blank\\\" href=\\\"https://github.com/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/GitHub-Mark-32px.png\\\" />View source on GitHub</a>\\n\",\n        \"  </td>\\n\",\n        \"</table>\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"c_1u7JSBMx3x\"\n      },\n      \"source\": [\n        \"# Protocol-oriented programming & generics\\n\",\n        \"\\n\",\n        \"This tutorial will go over protocol-oriented programming, and different examples of how they can be used with generics in day to day examples.\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"LP0gMw56TlvH\"\n      },\n      \"source\": [\n        \"## Protocols\\n\",\n        \"\\n\",\n        \"Inheritence is a powerful way to organize code in programming languages that allows you to share code between multiple components of the program.\\n\",\n        \"\\n\",\n        \"In Swift, there are different ways to express inheritence. One of those ways you may be familiar with already - class inheritence. However, Swift has another way - protocols.\\n\",\n        \"\\n\",\n        \"In this tutorial, we will explore protocols - an alternative to subclassing that allows you to achieve similar goals through different tradeoffs. In Swift, protocols contain multiple abstract members. Classes, structs and enums can conform to multiple protocols and the conformance relationship can be established retroactively. All that enables some designs that aren't easily expressible in Swift using subclassing. We will walk through the idioms that support the use of protocols (extensions and protocol constraints), as well as the limitations of protocols.\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"5AIIH5Q59b41\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Swift ðŸ’–'s value types!\\n\",\n        \"\\n\",\n        \"In addition to classes which have reference semantics, Swift supports enums and structs that are passed by value. Enums and structs support many features provided by classes. Let's take a look!\\n\",\n        \"\\n\",\n        \"Firstly let's look at how enums are similar to classes.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"zCN0Uc0w-gng\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"4dbad5e2-fad0-4be9-f6f2-bf9982c94893\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 51\n        }\n      },\n      \"source\": [\n        \"enum Color: String {\\n\",\n        \"    case red = \\\"red\\\"\\n\",\n        \"    case green = \\\"green\\\"\\n\",\n        \"    case blue = \\\"blue\\\"\\n\",\n        \"    // A computed property. Note that enums cannot contain stored properties.\\n\",\n        \"    var giveHint: String {\\n\",\n        \"        switch self {\\n\",\n        \"            case .red:\\n\",\n        \"                return \\\"Roses are this color.\\\"\\n\",\n        \"            case .green:\\n\",\n        \"                return \\\"Grass is this color.\\\"\\n\",\n        \"            case .blue:\\n\",\n        \"                return \\\"The ocean is this color.\\\"\\n\",\n        \"        }\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    // An initializer like for classes.\\n\",\n        \"    init?(color: String) {\\n\",\n        \"        switch color {\\n\",\n        \"        case \\\"red\\\":\\n\",\n        \"            self = .red\\n\",\n        \"        case \\\"green\\\":\\n\",\n        \"            self = .green\\n\",\n        \"        case \\\"blue\\\":\\n\",\n        \"            self = .blue\\n\",\n        \"        default:\\n\",\n        \"            return nil\\n\",\n        \"        }\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Can extend the enum as well!\\n\",\n        \"extension Color {\\n\",\n        \"    // A function.\\n\",\n        \"    func giveHintFunc() -> String {\\n\",\n        \"        return self.giveHint\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let c = Color.red\\n\",\n        \"print(\\\"Give me a hint for c: \\\\(c.giveHintFunc())\\\")\\n\",\n        \"\\n\",\n        \"let invalidColor = Color(color: \\\"orange\\\")\\n\",\n        \"print(\\\"is invalidColor nil: \\\\(invalidColor == nil)\\\")\"\n      ],\n      \"execution_count\": 2,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"Give me a hint for c: Roses are this color.\\r\\n\",\n            \"is invalidColor nil: true\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"ueiGy9gCgypk\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Now let's look at structs. Notice that we cannot inherit structs, but we can use protocols instead.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"ns4qCE1pg3uJ\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"a1e4403e-abcf-4b76-c3e5-e34b0da33c7f\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 68\n        }\n      },\n      \"source\": [\n        \"struct FastCar {\\n\",\n        \"    // Can have variables and constants as stored properties.\\n\",\n        \"    var color: Color\\n\",\n        \"    let horsePower: Int\\n\",\n        \"    // Can have computed properties.\\n\",\n        \"    var watts: Float {\\n\",\n        \"       return Float(horsePower) * 745.7\\n\",\n        \"    }\\n\",\n        \"    // Can have lazy variables like in classes!\\n\",\n        \"    lazy var titleCaseColorString: String = {\\n\",\n        \"        let colorString = color.rawValue\\n\",\n        \"        return colorString.prefix(1).uppercased() + \\n\",\n        \"               colorString.lowercased().dropFirst()\\n\",\n        \"    }()\\n\",\n        \"    // A function.\\n\",\n        \"    func description() -> String {\\n\",\n        \"        return \\\"This is a \\\\(color) car with \\\\(horsePower) horse power!\\\"\\n\",\n        \"    }\\n\",\n        \"    // Can create a variety of initializers.\\n\",\n        \"    init(color: Color, horsePower: Int) {\\n\",\n        \"        self.color = color\\n\",\n        \"        self.horsePower = horsePower\\n\",\n        \"    }\\n\",\n        \"    // Can define extra initializers other than the default one.\\n\",\n        \"    init?(color: String, horsePower: Int) {\\n\",\n        \"        guard let enumColor = Color(color: color) else {\\n\",\n        \"            return nil\\n\",\n        \"        }\\n\",\n        \"        self.color = enumColor\\n\",\n        \"        self.horsePower = horsePower\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"var car = FastCar(color: .red, horsePower: 250)\\n\",\n        \"print(car.description())\\n\",\n        \"print(\\\"Horse power in watts: \\\\(car.watts)\\\")\\n\",\n        \"print(car.titleCaseColorString)\"\n      ],\n      \"execution_count\": 3,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"This is a red car with 250 horse power!\\r\\n\",\n            \"Horse power in watts: 186425.0\\r\\n\",\n            \"Red\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"1Hw8bpQIlaWT\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Finally let's see how they are pass by value types unlike classes:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"C67qzGBVlhdo\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"848838f7-0122-469f-e8c1-2f90bffe2f23\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 51\n        }\n      },\n      \"source\": [\n        \"// Notice we have no problem modifying a constant class with \\n\",\n        \"// variable properties.\\n\",\n        \"class A {\\n\",\n        \"  var a = \\\"a\\\"\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo(_ a: A) {\\n\",\n        \"  a.a = \\\"foo\\\"\\n\",\n        \"}\\n\",\n        \"let a = A()\\n\",\n        \"print(a.a)\\n\",\n        \"foo(a)\\n\",\n        \"print(a.a)\\n\",\n        \"\\n\",\n        \"/* \\n\",\n        \"Uncomment the following code to see how an error is thrown.\\n\",\n        \"Structs are implicitly passed by value, so we cannot modify it.\\n\",\n        \"> \\\"error: cannot assign to property: 'car' is a 'let' constant\\\"\\n\",\n        \"*/\\n\",\n        \"\\n\",\n        \"// func modify(car: Car, toColor color: Color) -> Void {\\n\",\n        \"//   car.color = color\\n\",\n        \"// }\\n\",\n        \"\\n\",\n        \"// car = Car(color: .red, horsePower: 250)\\n\",\n        \"// print(car.description())\\n\",\n        \"// modify(car: &car, toColor: .blue)\\n\",\n        \"// print(car.description())\\n\"\n      ],\n      \"execution_count\": 4,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"a\\r\\n\",\n            \"foo\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"0BNxC5RyoKM7\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Let's use protocols\\n\",\n        \"\\n\",\n        \"Let's start by creating protocols for different cars.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"3ZSm1uTWoJ0h\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"protocol Car {\\n\",\n        \"    var color: Color { get set }\\n\",\n        \"    var price: Int { get }\\n\",\n        \"    func turnOn()\\n\",\n        \"    mutating func drive()\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"protocol Electric {\\n\",\n        \"    mutating func recharge()\\n\",\n        \"    // percentage of the battery level, 0-100%.\\n\",\n        \"    var batteryLevel: Int { get set }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"protocol Gas {\\n\",\n        \"    mutating func refill()\\n\",\n        \"    // # of liters the car is holding, varies b/w models.\\n\",\n        \"    var gasLevelLiters: Int { get set }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"aV_F6MyLps3h\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"In an object-oriented world (with no multiple inheritance), you may have made `Electric` and `Gas` abstract classes then used class inheritance to make both inherit from `Car`, and then have a specific car model be a base class. However, here both are completely separate protocols with **zero** coupling! This makes the entire system more flexible in how you design it.\\n\",\n        \"\\n\",\n        \"Let's define a Tesla:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"LkGRtwz3psrP\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"struct TeslaModelS: Car, Electric {\\n\",\n        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n        \"    let price: Int\\n\",\n        \"    var batteryLevel: Int\\n\",\n        \"    \\n\",\n        \"    func turnOn() {\\n\",\n        \"        print(\\\"Starting all systems!\\\")\\n\",\n        \"    }\\n\",\n        \"\\n\",\n        \"    mutating func drive() {\\n\",\n        \"        print(\\\"Self driving engaged!\\\")\\n\",\n        \"        batteryLevel -= 8\\n\",\n        \"    }\\n\",\n        \"\\n\",\n        \"    mutating func recharge() {\\n\",\n        \"        print(\\\"Recharging the battery...\\\")\\n\",\n        \"        batteryLevel = 100\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"var tesla = TeslaModelS(color: .red, price: 110000, batteryLevel: 100)\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"K5KB0IGLrkcm\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"This specifies a new struct `TeslaModelS` that conforms to both protocols `Car` and `Electric`.\\n\",\n        \"\\n\",\n        \"Now letâ€™s define a gas powered car:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"GPLKFUAOrMp-\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"struct Mustang: Car, Gas{\\n\",\n        \"    var color: Color\\n\",\n        \"    let price: Int\\n\",\n        \"    var gasLevelLiters: Int\\n\",\n        \"    \\n\",\n        \"    func turnOn() {\\n\",\n        \"        print(\\\"Starting all systems!\\\")\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func drive() {\\n\",\n        \"        print(\\\"Time to drive!\\\")\\n\",\n        \"        gasLevelLiters -= 1\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func refill() {\\n\",\n        \"        print(\\\"Filling the tank...\\\")\\n\",\n        \"        gasLevelLiters = 25\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"var mustang = Mustang(color: .red, price: 30000, gasLevelLiters: 25)\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"jrbCRkglsi_d\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"### Extend protocols with default behaviors\\n\",\n        \"\\n\",\n        \"What you can notice from the examples is that we have some redundancy. Every time we recharge an electric car, we need to set the battery percentage level to 100. Since all electric cars have a max capacity of 100%, but gas cars vary between gas tank capacity, we can default the level to 100 for electric cars.\\n\",\n        \"\\n\",\n        \"This is where extensions in Swift can come in handy:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"NiHUJxXMtzSg\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"extension Electric {\\n\",\n        \"    mutating func recharge() {\\n\",\n        \"        print(\\\"Recharging the battery...\\\")\\n\",\n        \"        batteryLevel = 100\\n\",\n        \"    }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"v8QbTb9NxWqI\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"So now, any new electric car we create will set the battery to 100 when we recharge it. Thus, we have just been able to decorate classes, structs, and enums with unique and default behavior.\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"VIXakqxtvkp_\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"![Protocol Comic](https://koenig-media.raywenderlich.com/uploads/2015/06/protocols-extend.png)\\n\",\n        \"\\n\",\n        \"Thanks to [Ray Wenderlich](https://www.raywenderlich.com/814-introducing-protocol-oriented-programming-in-swift-3) for the comic!\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"MAo8n3zUR8Q9\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, one thing to watch out for is the following. In our first implementation, we define `foo()` as a default implementation on `A`, but not make it required in the protocol. So when we call `a.foo()`, we get \\\"`A default`\\\" printed.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"koP20_C9R7ps\",\n        \"colab_type\": \"code\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 34\n        },\n        \"outputId\": \"0e6375dd-f42c-4285-a9db-15b7a0477609\"\n      },\n      \"source\": [\n        \"protocol Default {}\\n\",\n        \"\\n\",\n        \"extension Default {\\n\",\n        \"    func foo() { print(\\\"A default\\\")}\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct DefaultStruct: Default {\\n\",\n        \"    func foo() {\\n\",\n        \"        print(\\\"Inst\\\")\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let a: Default = DefaultStruct()\\n\",\n        \"a.foo()\"\n      ],\n      \"execution_count\": 9,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"A default\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"uSE5IWF_Sdet\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, if we make `foo()` required on `A`, we get \\\"`Inst`\\\".\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"DJ8jstIWSoUP\",\n        \"colab_type\": \"code\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 34\n        },\n        \"outputId\": \"5c586323-f630-4d08-c2a8-b32a16d94c45\"\n      },\n      \"source\": [\n        \"protocol Default {\\n\",\n        \"    func foo()\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"extension Default {\\n\",\n        \"    func foo() { \\n\",\n        \"        print(\\\"A default\\\")\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct DefaultStruct: Default {\\n\",\n        \"    func foo() {\\n\",\n        \"        print(\\\"Inst\\\")\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let a: Default = DefaultStruct()\\n\",\n        \"a.foo()\"\n      ],\n      \"execution_count\": 10,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"Inst\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"XC1juXPzZV8Q\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"This occurs due to a difference between static dispatch in the first example and static dispatch in the second on protocols in Swift. For more info, refer to the following [Medium post](https://medium.com/@PavloShadov/https-medium-com-pavloshadov-swift-protocols-magic-of-dynamic-static-methods-dispatches-dfe0e0c85509).\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"HzB0XC0wwMLD\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"### Overriding default behavior\\n\",\n        \"\\n\",\n        \"However, if we want to, we can still override the default behavior. One important thing to note is that this [doesnâ€™t support dynamic dispatch](https://stackoverflow.com/questions/44703205/swift-protocol-extension-method-is-called-instead-of-method-implemented-in-subcl).\\n\",\n        \"\\n\",\n        \"Letâ€™s say we have an older version of an electric car, so the battery health has been reduced to 90%.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"CaIZhcsVyBKz\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"struct OldElectric: Car, Electric {\\n\",\n        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n        \"    let price: Int\\n\",\n        \"    var batteryLevel: Int\\n\",\n        \"    \\n\",\n        \"    func turnOn() {\\n\",\n        \"        print(\\\"Starting all systems!\\\")\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func drive() {\\n\",\n        \"        print(\\\"Self driving engaged!\\\")\\n\",\n        \"        batteryLevel -= 8\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func reCharge() {\\n\",\n        \"        print(\\\"Recharging the battery...\\\")\\n\",\n        \"        batteryLevel = 90\\n\",\n        \"    }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"c_Xmw5cDy_rZ\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Standard library uses of protocols\\n\",\n        \"\\n\",\n        \"Now that we have an idea how protocols in Swift work, let's go through some typical examples of using the standard library protocols.\\n\",\n        \"\\n\",\n        \"### Extend the standard library\\n\",\n        \"Let's see how we can add additional functionality to types that exist in Swift already. Since types in Swift aren't built in, but are part of the standard library as structs, this is easy to do.\\n\",\n        \"\\n\",\n        \"Let's try and do binary search on an array of elements, while also making sure to check that the array is sorted.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"-Jfn3P3P1RDt\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"8082bcd1-a13b-440e-d592-c4018ddf17f4\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 68\n        }\n      },\n      \"source\": [\n        \"extension Collection where Element: Comparable {\\n\",\n        \"    // Verify that a `Collection` is sorted.\\n\",\n        \"    func isSorted(_ order: (Element, Element) -> Bool) -> Bool {\\n\",\n        \"        var i = index(startIndex, offsetBy: 1)\\n\",\n        \"        \\n\",\n        \"        while i < endIndex {\\n\",\n        \"            // The longer way of calling a binary function like `<(_:_:)`, \\n\",\n        \"            // `<=(_:_:)`, `==(_:_:)`, etc.\\n\",\n        \"            guard order(self[index(i, offsetBy: -1)], self[i]) else {\\n\",\n        \"                return false\\n\",\n        \"            }\\n\",\n        \"            i = index(after: i)\\n\",\n        \"        }\\n\",\n        \"        return true\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    // Perform binary search on a `Collection`, verifying it is sorted.\\n\",\n        \"    func binarySearch(_ element: Element) -> Index? {\\n\",\n        \"        guard self.isSorted(<=) else {\\n\",\n        \"            return nil\\n\",\n        \"        }\\n\",\n        \"        \\n\",\n        \"        var low = startIndex\\n\",\n        \"        var high = endIndex\\n\",\n        \"        \\n\",\n        \"        while low <= high {\\n\",\n        \"            let mid = index(low, offsetBy: distance(from: low, to: high)/2)\\n\",\n        \"\\n\",\n        \"            if self[mid] == element {\\n\",\n        \"                return mid\\n\",\n        \"            } else if self[mid] < element {\\n\",\n        \"                low = index(after: mid)\\n\",\n        \"            } else {\\n\",\n        \"                high = index(mid, offsetBy: -1)\\n\",\n        \"            }\\n\",\n        \"        }\\n\",\n        \"        \\n\",\n        \"        return nil\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"print([2, 2, 5, 7, 11, 13, 17].binarySearch(5)!)\\n\",\n        \"print([\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"].binarySearch(\\\"b\\\")!)\\n\",\n        \"print([1.1, 2.2, 3.3, 4.4, 5.5].binarySearch(3.3)!)\"\n      ],\n      \"execution_count\": 12,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"2\\r\\n\",\n            \"1\\r\\n\",\n            \"2\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"CIh7qyFVqlaH\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"We do this by extending the [`Collection`](https://developer.apple.com/documentation/swift/collection) protocol which defines _\\\"a sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.\\\"_ Since arrays can be indexed using the square bracket notation, this is the protocol we want to extend.\\n\",\n        \"\\n\",\n        \"Similarly, we only want to add this utility function to arrays whose elements can be compared. This is the reason why we have `where Element: Comparable`. \\n\",\n        \"\\n\",\n        \"The `where` clause is a part of Swift's type system, which we will cover soon, but in short lets us add additional requirements to the extension we are writing, such as to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.\\n\",\n        \"\\n\",\n        \"[`Element`](https://developer.apple.com/documentation/swift/sequence/2908099-element) is the associated type of the elements in a `Collection`-conforming type. `Element` is defined within the [`Sequence`](https://developer.apple.com/documentation/swift/sequence) protocol, but since `Collection` inherits from `Sequence`, it inherits the `Element` associated type.\\n\",\n        \"\\n\",\n        \"[`Comparable`](https://developer.apple.com/documentation/swift/comparable) is a protocol that defines _\\\"a type that can be compared using the relational operators `<`, `<=`, `>=`, and `>`.\\\"_. Since we are performing binary search on a sorted `Collection`, this of course has to be true or else we don't know whether to recurse/iterate left or right in the binary search.\\n\",\n        \"\\n\",\n        \"As a side note about the implementation,  for more info on the `index(_:offsetBy:)` function that was used, refer to the following [documentation](https://developer.apple.com/documentation/swift/string/1786175-index).\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"TmqFx2layKs7\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Generics + protocols = ðŸ’¥\\n\",\n        \"Generics and protocols can be a powerful tool if used correctly to avoid duplicate code.\\n\",\n        \"\\n\",\n        \"Firstly, look over another tutorial, [A Swift Tour](https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/a_swift_tour.ipynb), which briefly covers generics at the end of the Colab book.\\n\",\n        \"\\n\",\n        \"Assuming you have a general idea about generics, let's quickly take a look at some advanced uses.\\n\",\n        \"\\n\",\n        \"When a single type has multiple requirements such as a type conforming to several protocols, you have several options at your disposal:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"HIjkHLGtz268\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"ac91c112-777a-4c4e-dbe2-8044d1735c26\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 102\n        }\n      },\n      \"source\": [\n        \"typealias ComparableReal = Comparable & FloatingPoint\\n\",\n        \"\\n\",\n        \"func foo1<T: ComparableReal>(a: T, b: T) -> Bool {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo2<T: Comparable & FloatingPoint>(a: T, b: T) -> Bool {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo3<T>(a: T, b: T) -> Bool where T: ComparableReal {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo4<T>(a: T, b: T) -> Bool where T: Comparable & FloatingPoint {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo5<T: FloatingPoint>(a: T, b: T) -> Bool where T: Comparable {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"print(foo1(a: 1, b: 2))\\n\",\n        \"print(foo2(a: 1, b: 2))\\n\",\n        \"print(foo3(a: 1, b: 2))\\n\",\n        \"print(foo4(a: 1, b: 2))\\n\",\n        \"print(foo5(a: 1, b: 2))\"\n      ],\n      \"execution_count\": 13,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"false\\r\\n\",\n            \"false\\r\\n\",\n            \"false\\r\\n\",\n            \"false\\r\\n\",\n            \"false\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"DMCioS9Dz5Fh\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Notice the use of `typealias` at the top. This adds a named alias of an existing type into your program. After a type alias is declared, the aliased name can be used instead of the existing type everywhere in your program. Type aliases do not create new types; they simply allow a name to refer to an existing type.\\n\",\n        \"\\n\",\n        \"Now let's see how we can use protocols and generics together.\\n\",\n        \"\\n\",\n        \"Let's imagine we are a computer store with the following requirements on any laptop we sell for determining how we organize them in the back of the store:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"oKvieIsw2YJW\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"enum Box {\\n\",\n        \"    case small\\n\",\n        \"    case medium\\n\",\n        \"    case large\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"enum Mass {\\n\",\n        \"    case light\\n\",\n        \"    case medium\\n\",\n        \"    case heavy\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Note: `CustomStringConvertible` protocol lets us pretty-print a `Laptop`.\\n\",\n        \"struct Laptop: CustomStringConvertible {\\n\",\n        \"    var name: String\\n\",\n        \"    var box: Box\\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    var description: String {\\n\",\n        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"    }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"ey519vu04FgG\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, we got a new requirement of grouping our `Laptop`s by mass since the shelves have weight restrictions.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"tVRuqx_q4jQ9\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"abee5d7a-37e5-4c7b-bcf6-d43088741bcc\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 34\n        }\n      },\n      \"source\": [\n        \"func filtering(_ laptops: [Laptop], by mass: Mass) -> [Laptop] {\\n\",\n        \"    return laptops.filter { $0.mass == mass }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let laptops: [Laptop] = [\\n\",\n        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n        \"]\\n\",\n        \"\\n\",\n        \"let filteredLaptops = filtering(laptops, by: .light)\\n\",\n        \"print(filteredLaptops)\"\n      ],\n      \"execution_count\": 15,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"[(a small light), (d large light)]\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"Lw_W5zW17UMc\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, what if we wanted to filter by something other than `Mass`? One option is to do the following.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"2qDVD9Yl8POQ\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"9d273353-1e52-4eed-8a9a-c2d3019eb992\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 51\n        }\n      },\n      \"source\": [\n        \"// Define a protocol which will act as our comparator.\\n\",\n        \"protocol DeviceFilterPredicate {\\n\",\n        \"    associatedtype Device\\n\",\n        \"    func shouldKeep(_ item: Device) -> Bool\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the structs we will use for passing into our filtering function.\\n\",\n        \"struct BoxFilter: DeviceFilterPredicate {\\n\",\n        \"    typealias Device = Laptop\\n\",\n        \"    var box: Box \\n\",\n        \"    \\n\",\n        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n        \"        return item.box == box\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct MassFilter: DeviceFilterPredicate {\\n\",\n        \"    typealias Device = Laptop  \\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n        \"        return item.mass == mass\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Make sure our filter conforms to `DeviceFilterPredicate` and that we are \\n\",\n        \"// filtering `Laptop`s.\\n\",\n        \"func filtering<F: DeviceFilterPredicate>(\\n\",\n        \"    _ laptops: [Laptop], \\n\",\n        \"    by filter: F\\n\",\n        \") -> [Laptop] where Laptop == F.Device {\\n\",\n        \"    return laptops.filter { filter.shouldKeep($0) }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Let's test the function out!\\n\",\n        \"print(filtering(laptops, by: BoxFilter(box: .large)))\\n\",\n        \"print(filtering(laptops, by: MassFilter(mass: .heavy)))\"\n      ],\n      \"execution_count\": 16,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"[(b large medium), (d large light)]\\r\\n\",\n            \"[(c medium heavy)]\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"yFx_6y0-CRHc\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Awesome! Now we are able to filter based on any laptop constraint. However, we are only able to filter `Laptop`s. What about being able to filter anything that is in a box and has mass? Maybe this warehouse of laptops will also be used for servers which have a different customer base.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"EzhE_K-eCvYt\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"89f16e54-e1ce-40e9-f84a-da58bb126620\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 85\n        }\n      },\n      \"source\": [\n        \"// Define 2 new protocols so we can filter anything in a box and which has mass.\\n\",\n        \"protocol Weighable {\\n\",\n        \"    var mass: Mass { get }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"protocol Boxed {\\n\",\n        \"    var box: Box { get }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the new Laptop and Server struct which have mass and a box.\\n\",\n        \"struct Laptop: CustomStringConvertible, Boxed, Weighable {\\n\",\n        \"    var name: String\\n\",\n        \"    var box: Box\\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    var description: String {\\n\",\n        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct Server: CustomStringConvertible, Boxed, Weighable {\\n\",\n        \"    var isWorking: Bool\\n\",\n        \"    var name: String\\n\",\n        \"    let box: Box\\n\",\n        \"    let mass: Mass\\n\",\n        \"\\n\",\n        \"    var description: String {\\n\",\n        \"        if isWorking {\\n\",\n        \"            return \\\"(working \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"        } else {\\n\",\n        \"            return \\\"(notWorking \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"        }\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the structs we will use for passing into our filtering function.\\n\",\n        \"struct BoxFilter<T: Boxed>: DeviceFilterPredicate {\\n\",\n        \"    var box: Box \\n\",\n        \"  \\n\",\n        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n        \"        return item.box == box\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct MassFilter<T: Weighable>: DeviceFilterPredicate {\\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n        \"        return item.mass == mass\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the new filter function.\\n\",\n        \"func filtering<F: DeviceFilterPredicate, T>(\\n\",\n        \"    _ elements: [T], \\n\",\n        \"    by filter: F\\n\",\n        \") -> [T] where T == F.Device {\\n\",\n        \"    return elements.filter { filter.shouldKeep($0) }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"// Let's test the function out!\\n\",\n        \"let servers = [\\n\",\n        \"    Server(isWorking: true, name: \\\"serverA\\\", box: .small, mass: .heavy),\\n\",\n        \"    Server(isWorking: false, name: \\\"serverB\\\", box: .medium, mass: .medium),\\n\",\n        \"    Server(isWorking: true, name: \\\"serverC\\\", box: .large, mass: .light),\\n\",\n        \"    Server(isWorking: false, name: \\\"serverD\\\", box: .medium, mass: .light),\\n\",\n        \"    Server(isWorking: true, name: \\\"serverE\\\", box: .small, mass: .heavy)\\n\",\n        \"]\\n\",\n        \"\\n\",\n        \"let products = [\\n\",\n        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n        \"]\\n\",\n        \"\\n\",\n        \"print(filtering(servers, by: BoxFilter(box: .small)))\\n\",\n        \"print(filtering(servers, by: MassFilter(mass: .medium)))\\n\",\n        \"\\n\",\n        \"print(filtering(products, by: BoxFilter(box: .small)))\\n\",\n        \"print(filtering(products, by: MassFilter(mass: .medium)))\"\n      ],\n      \"execution_count\": 17,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"[(working serverA small heavy), (working serverE small heavy)]\\r\\n\",\n            \"[(notWorking serverB medium medium)]\\r\\n\",\n            \"[(a small light)]\\r\\n\",\n            \"[(b large medium)]\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"-UrRDSaFNCRg\"\n      },\n      \"source\": [\n        \"We have now been able to filter an array by not only any property of a specific `struct`, but also be able to filter any struct which has that property!\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"6g3pPZIuMvPu\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"# Tips for good API design\\n\",\n        \"***This section was taken from the [WWDC 2019: Modern Swift API Design](https://developer.apple.com/videos/play/wwdc2019/415/) talk.***\\n\",\n        \"\\n\",\n        \"Now that you understand how protocols behave, it's best to now go over when you should use protocols. As powerful as protocols can be, it's not always the best idea to dive in and immediately start with protocols.\\n\",\n        \"\\n\",\n        \"* Start with concrete use cases.\\n\",\n        \"    * First explore the use case with concrete types and understand what code it is you want to share and find is being repeated. Then, factor that shared code out with generics. It might mean to create new protocols. Discover a need for generic code.\\n\",\n        \"* Consider composing new protocols from existing protocols defined in the standard library. Refer to the following [Apple documentation](https://developer.apple.com/documentation/swift/adopting_common_protocols) for a good example of this.\\n\",\n        \"* Instead of a generic protocol, consider defining a generic type instead.\\n\",\n        \"\\n\",\n        \"## Example: defining a custom vector type\\n\",\n        \"Let's say we want to define a `GeometricVector` protocol on floating-point numbers to use in some geometry app we are making which defines 3 important vector operations:\\n\",\n        \"\\n\",\n        \"```swift\\n\",\n        \"protocol GeometricVector where Scalar: FloatingPoint {\\n\",",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "310343661",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "310343661",
        "commented_code": "@@ -0,0 +1,1307 @@\n+{\n+  \"nbformat\": 4,\n+  \"nbformat_minor\": 0,\n+  \"metadata\": {\n+    \"colab\": {\n+      \"name\": \"protocol.ipynb\",\n+      \"version\": \"0.3.2\",\n+      \"provenance\": [],\n+      \"collapsed_sections\": []\n+    },\n+    \"language_info\": {\n+      \"file_extension\": \".swift\",\n+      \"mimetype\": \"text/x-swift\",\n+      \"name\": \"swift\",\n+      \"version\": \"\"\n+    },\n+    \"kernelspec\": {\n+      \"display_name\": \"Swift\",\n+      \"language\": \"swift\",\n+      \"name\": \"swift\"\n+    }\n+  },\n+  \"cells\": [\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"ZloPIuRHn97X\"\n+      },\n+      \"source\": [\n+        \"##### Copyright 2019 The TensorFlow Authors. [Licensed under the Apache License, Version 2.0](#scrollTo=Afd8bu4xJOgh).\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"colab_type\": \"code\",\n+        \"id\": \"tNgCmfUvJNoF\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"#@title Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); { display-mode: \\\"form\\\" }\\n\",\n+        \"// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\",\n+        \"// you may not use this file except in compliance with the License.\\n\",\n+        \"// You may obtain a copy of the License at\\n\",\n+        \"//\\n\",\n+        \"// https://www.apache.org/licenses/LICENSE-2.0\\n\",\n+        \"//\\n\",\n+        \"// Unless required by applicable law or agreed to in writing, software\\n\",\n+        \"// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\",\n+        \"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\",\n+        \"// See the License for the specific language governing permissions and\\n\",\n+        \"// limitations under the License.\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"AlvdCHw5JGyx\"\n+      },\n+      \"source\": [\n+        \"<table class=\\\"tfo-notebook-buttons\\\" align=\\\"left\\\">\\n\",\n+        \"  <td>\\n\",\n+        \"    <a target=\\\"_blank\\\" href=\\\"https://www.tensorflow.org/swift/tutorials/protocol_oriented_generics\\\"><img src=\\\"https://www.tensorflow.org/images/tf_logo_32px.png\\\" />View on TensorFlow.org</a>\\n\",\n+        \"  </td>\\n\",\n+        \"  <td>\\n\",\n+        \"    <a target=\\\"_blank\\\" href=\\\"https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/colab_logo_32px.png\\\" />Run in Google Colab</a>\\n\",\n+        \"  </td>\\n\",\n+        \"  <td>\\n\",\n+        \"    <a target=\\\"_blank\\\" href=\\\"https://github.com/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/GitHub-Mark-32px.png\\\" />View source on GitHub</a>\\n\",\n+        \"  </td>\\n\",\n+        \"</table>\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"c_1u7JSBMx3x\"\n+      },\n+      \"source\": [\n+        \"# Protocol-oriented programming & generics\\n\",\n+        \"\\n\",\n+        \"This tutorial will go over protocol-oriented programming, and different examples of how they can be used with generics in day to day examples.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"LP0gMw56TlvH\"\n+      },\n+      \"source\": [\n+        \"## Protocols\\n\",\n+        \"\\n\",\n+        \"Inheritence is a powerful way to organize code in programming languages that allows you to share code between multiple components of the program.\\n\",\n+        \"\\n\",\n+        \"In Swift, there are different ways to express inheritence. One of those ways you may be familiar with already - class inheritence. However, Swift has another way - protocols.\\n\",\n+        \"\\n\",\n+        \"In this tutorial, we will explore protocols - an alternative to subclassing that allows you to achieve similar goals through different tradeoffs. In Swift, protocols contain multiple abstract members. Classes, structs and enums can conform to multiple protocols and the conformance relationship can be established retroactively. All that enables some designs that aren't easily expressible in Swift using subclassing. We will walk through the idioms that support the use of protocols (extensions and protocol constraints), as well as the limitations of protocols.\\n\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"5AIIH5Q59b41\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Swift ðŸ’–'s value types!\\n\",\n+        \"\\n\",\n+        \"In addition to classes which have reference semantics, Swift supports enums and structs that are passed by value. Enums and structs support many features provided by classes. Let's take a look!\\n\",\n+        \"\\n\",\n+        \"Firstly let's look at how enums are similar to classes.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"zCN0Uc0w-gng\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"4dbad5e2-fad0-4be9-f6f2-bf9982c94893\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 51\n+        }\n+      },\n+      \"source\": [\n+        \"enum Color: String {\\n\",\n+        \"    case red = \\\"red\\\"\\n\",\n+        \"    case green = \\\"green\\\"\\n\",\n+        \"    case blue = \\\"blue\\\"\\n\",\n+        \"    // A computed property. Note that enums cannot contain stored properties.\\n\",\n+        \"    var giveHint: String {\\n\",\n+        \"        switch self {\\n\",\n+        \"            case .red:\\n\",\n+        \"                return \\\"Roses are this color.\\\"\\n\",\n+        \"            case .green:\\n\",\n+        \"                return \\\"Grass is this color.\\\"\\n\",\n+        \"            case .blue:\\n\",\n+        \"                return \\\"The ocean is this color.\\\"\\n\",\n+        \"        }\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    // An initializer like for classes.\\n\",\n+        \"    init?(color: String) {\\n\",\n+        \"        switch color {\\n\",\n+        \"        case \\\"red\\\":\\n\",\n+        \"            self = .red\\n\",\n+        \"        case \\\"green\\\":\\n\",\n+        \"            self = .green\\n\",\n+        \"        case \\\"blue\\\":\\n\",\n+        \"            self = .blue\\n\",\n+        \"        default:\\n\",\n+        \"            return nil\\n\",\n+        \"        }\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Can extend the enum as well!\\n\",\n+        \"extension Color {\\n\",\n+        \"    // A function.\\n\",\n+        \"    func giveHintFunc() -> String {\\n\",\n+        \"        return self.giveHint\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let c = Color.red\\n\",\n+        \"print(\\\"Give me a hint for c: \\\\(c.giveHintFunc())\\\")\\n\",\n+        \"\\n\",\n+        \"let invalidColor = Color(color: \\\"orange\\\")\\n\",\n+        \"print(\\\"is invalidColor nil: \\\\(invalidColor == nil)\\\")\"\n+      ],\n+      \"execution_count\": 2,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"Give me a hint for c: Roses are this color.\\r\\n\",\n+            \"is invalidColor nil: true\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"ueiGy9gCgypk\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Now let's look at structs. Notice that we cannot inherit structs, but we can use protocols instead.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"ns4qCE1pg3uJ\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"a1e4403e-abcf-4b76-c3e5-e34b0da33c7f\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 68\n+        }\n+      },\n+      \"source\": [\n+        \"struct FastCar {\\n\",\n+        \"    // Can have variables and constants as stored properties.\\n\",\n+        \"    var color: Color\\n\",\n+        \"    let horsePower: Int\\n\",\n+        \"    // Can have computed properties.\\n\",\n+        \"    var watts: Float {\\n\",\n+        \"       return Float(horsePower) * 745.7\\n\",\n+        \"    }\\n\",\n+        \"    // Can have lazy variables like in classes!\\n\",\n+        \"    lazy var titleCaseColorString: String = {\\n\",\n+        \"        let colorString = color.rawValue\\n\",\n+        \"        return colorString.prefix(1).uppercased() + \\n\",\n+        \"               colorString.lowercased().dropFirst()\\n\",\n+        \"    }()\\n\",\n+        \"    // A function.\\n\",\n+        \"    func description() -> String {\\n\",\n+        \"        return \\\"This is a \\\\(color) car with \\\\(horsePower) horse power!\\\"\\n\",\n+        \"    }\\n\",\n+        \"    // Can create a variety of initializers.\\n\",\n+        \"    init(color: Color, horsePower: Int) {\\n\",\n+        \"        self.color = color\\n\",\n+        \"        self.horsePower = horsePower\\n\",\n+        \"    }\\n\",\n+        \"    // Can define extra initializers other than the default one.\\n\",\n+        \"    init?(color: String, horsePower: Int) {\\n\",\n+        \"        guard let enumColor = Color(color: color) else {\\n\",\n+        \"            return nil\\n\",\n+        \"        }\\n\",\n+        \"        self.color = enumColor\\n\",\n+        \"        self.horsePower = horsePower\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"var car = FastCar(color: .red, horsePower: 250)\\n\",\n+        \"print(car.description())\\n\",\n+        \"print(\\\"Horse power in watts: \\\\(car.watts)\\\")\\n\",\n+        \"print(car.titleCaseColorString)\"\n+      ],\n+      \"execution_count\": 3,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"This is a red car with 250 horse power!\\r\\n\",\n+            \"Horse power in watts: 186425.0\\r\\n\",\n+            \"Red\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"1Hw8bpQIlaWT\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Finally let's see how they are pass by value types unlike classes:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"C67qzGBVlhdo\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"848838f7-0122-469f-e8c1-2f90bffe2f23\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 51\n+        }\n+      },\n+      \"source\": [\n+        \"// Notice we have no problem modifying a constant class with \\n\",\n+        \"// variable properties.\\n\",\n+        \"class A {\\n\",\n+        \"  var a = \\\"a\\\"\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo(_ a: A) {\\n\",\n+        \"  a.a = \\\"foo\\\"\\n\",\n+        \"}\\n\",\n+        \"let a = A()\\n\",\n+        \"print(a.a)\\n\",\n+        \"foo(a)\\n\",\n+        \"print(a.a)\\n\",\n+        \"\\n\",\n+        \"/* \\n\",\n+        \"Uncomment the following code to see how an error is thrown.\\n\",\n+        \"Structs are implicitly passed by value, so we cannot modify it.\\n\",\n+        \"> \\\"error: cannot assign to property: 'car' is a 'let' constant\\\"\\n\",\n+        \"*/\\n\",\n+        \"\\n\",\n+        \"// func modify(car: Car, toColor color: Color) -> Void {\\n\",\n+        \"//   car.color = color\\n\",\n+        \"// }\\n\",\n+        \"\\n\",\n+        \"// car = Car(color: .red, horsePower: 250)\\n\",\n+        \"// print(car.description())\\n\",\n+        \"// modify(car: &car, toColor: .blue)\\n\",\n+        \"// print(car.description())\\n\"\n+      ],\n+      \"execution_count\": 4,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"a\\r\\n\",\n+            \"foo\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"0BNxC5RyoKM7\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Let's use protocols\\n\",\n+        \"\\n\",\n+        \"Let's start by creating protocols for different cars.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"3ZSm1uTWoJ0h\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"protocol Car {\\n\",\n+        \"    var color: Color { get set }\\n\",\n+        \"    var price: Int { get }\\n\",\n+        \"    func turnOn()\\n\",\n+        \"    mutating func drive()\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"protocol Electric {\\n\",\n+        \"    mutating func recharge()\\n\",\n+        \"    // percentage of the battery level, 0-100%.\\n\",\n+        \"    var batteryLevel: Int { get set }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"protocol Gas {\\n\",\n+        \"    mutating func refill()\\n\",\n+        \"    // # of liters the car is holding, varies b/w models.\\n\",\n+        \"    var gasLevelLiters: Int { get set }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"aV_F6MyLps3h\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"In an object-oriented world (with no multiple inheritance), you may have made `Electric` and `Gas` abstract classes then used class inheritance to make both inherit from `Car`, and then have a specific car model be a base class. However, here both are completely separate protocols with **zero** coupling! This makes the entire system more flexible in how you design it.\\n\",\n+        \"\\n\",\n+        \"Let's define a Tesla:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"LkGRtwz3psrP\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"struct TeslaModelS: Car, Electric {\\n\",\n+        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n+        \"    let price: Int\\n\",\n+        \"    var batteryLevel: Int\\n\",\n+        \"    \\n\",\n+        \"    func turnOn() {\\n\",\n+        \"        print(\\\"Starting all systems!\\\")\\n\",\n+        \"    }\\n\",\n+        \"\\n\",\n+        \"    mutating func drive() {\\n\",\n+        \"        print(\\\"Self driving engaged!\\\")\\n\",\n+        \"        batteryLevel -= 8\\n\",\n+        \"    }\\n\",\n+        \"\\n\",\n+        \"    mutating func recharge() {\\n\",\n+        \"        print(\\\"Recharging the battery...\\\")\\n\",\n+        \"        batteryLevel = 100\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"var tesla = TeslaModelS(color: .red, price: 110000, batteryLevel: 100)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"K5KB0IGLrkcm\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"This specifies a new struct `TeslaModelS` that conforms to both protocols `Car` and `Electric`.\\n\",\n+        \"\\n\",\n+        \"Now letâ€™s define a gas powered car:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"GPLKFUAOrMp-\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"struct Mustang: Car, Gas{\\n\",\n+        \"    var color: Color\\n\",\n+        \"    let price: Int\\n\",\n+        \"    var gasLevelLiters: Int\\n\",\n+        \"    \\n\",\n+        \"    func turnOn() {\\n\",\n+        \"        print(\\\"Starting all systems!\\\")\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func drive() {\\n\",\n+        \"        print(\\\"Time to drive!\\\")\\n\",\n+        \"        gasLevelLiters -= 1\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func refill() {\\n\",\n+        \"        print(\\\"Filling the tank...\\\")\\n\",\n+        \"        gasLevelLiters = 25\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"var mustang = Mustang(color: .red, price: 30000, gasLevelLiters: 25)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"jrbCRkglsi_d\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"### Extend protocols with default behaviors\\n\",\n+        \"\\n\",\n+        \"What you can notice from the examples is that we have some redundancy. Every time we recharge an electric car, we need to set the battery percentage level to 100. Since all electric cars have a max capacity of 100%, but gas cars vary between gas tank capacity, we can default the level to 100 for electric cars.\\n\",\n+        \"\\n\",\n+        \"This is where extensions in Swift can come in handy:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"NiHUJxXMtzSg\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"extension Electric {\\n\",\n+        \"    mutating func recharge() {\\n\",\n+        \"        print(\\\"Recharging the battery...\\\")\\n\",\n+        \"        batteryLevel = 100\\n\",\n+        \"    }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"v8QbTb9NxWqI\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"So now, any new electric car we create will set the battery to 100 when we recharge it. Thus, we have just been able to decorate classes, structs, and enums with unique and default behavior.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"VIXakqxtvkp_\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"![Protocol Comic](https://koenig-media.raywenderlich.com/uploads/2015/06/protocols-extend.png)\\n\",\n+        \"\\n\",\n+        \"Thanks to [Ray Wenderlich](https://www.raywenderlich.com/814-introducing-protocol-oriented-programming-in-swift-3) for the comic!\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"MAo8n3zUR8Q9\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, one thing to watch out for is the following. In our first implementation, we define `foo()` as a default implementation on `A`, but not make it required in the protocol. So when we call `a.foo()`, we get \\\"`A default`\\\" printed.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"koP20_C9R7ps\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 34\n+        },\n+        \"outputId\": \"0e6375dd-f42c-4285-a9db-15b7a0477609\"\n+      },\n+      \"source\": [\n+        \"protocol Default {}\\n\",\n+        \"\\n\",\n+        \"extension Default {\\n\",\n+        \"    func foo() { print(\\\"A default\\\")}\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct DefaultStruct: Default {\\n\",\n+        \"    func foo() {\\n\",\n+        \"        print(\\\"Inst\\\")\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let a: Default = DefaultStruct()\\n\",\n+        \"a.foo()\"\n+      ],\n+      \"execution_count\": 9,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"A default\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"uSE5IWF_Sdet\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, if we make `foo()` required on `A`, we get \\\"`Inst`\\\".\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"DJ8jstIWSoUP\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 34\n+        },\n+        \"outputId\": \"5c586323-f630-4d08-c2a8-b32a16d94c45\"\n+      },\n+      \"source\": [\n+        \"protocol Default {\\n\",\n+        \"    func foo()\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"extension Default {\\n\",\n+        \"    func foo() { \\n\",\n+        \"        print(\\\"A default\\\")\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct DefaultStruct: Default {\\n\",\n+        \"    func foo() {\\n\",\n+        \"        print(\\\"Inst\\\")\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let a: Default = DefaultStruct()\\n\",\n+        \"a.foo()\"\n+      ],\n+      \"execution_count\": 10,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"Inst\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"XC1juXPzZV8Q\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"This occurs due to a difference between static dispatch in the first example and static dispatch in the second on protocols in Swift. For more info, refer to the following [Medium post](https://medium.com/@PavloShadov/https-medium-com-pavloshadov-swift-protocols-magic-of-dynamic-static-methods-dispatches-dfe0e0c85509).\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"HzB0XC0wwMLD\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"### Overriding default behavior\\n\",\n+        \"\\n\",\n+        \"However, if we want to, we can still override the default behavior. One important thing to note is that this [doesnâ€™t support dynamic dispatch](https://stackoverflow.com/questions/44703205/swift-protocol-extension-method-is-called-instead-of-method-implemented-in-subcl).\\n\",\n+        \"\\n\",\n+        \"Letâ€™s say we have an older version of an electric car, so the battery health has been reduced to 90%.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"CaIZhcsVyBKz\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"struct OldElectric: Car, Electric {\\n\",\n+        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n+        \"    let price: Int\\n\",\n+        \"    var batteryLevel: Int\\n\",\n+        \"    \\n\",\n+        \"    func turnOn() {\\n\",\n+        \"        print(\\\"Starting all systems!\\\")\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func drive() {\\n\",\n+        \"        print(\\\"Self driving engaged!\\\")\\n\",\n+        \"        batteryLevel -= 8\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func reCharge() {\\n\",\n+        \"        print(\\\"Recharging the battery...\\\")\\n\",\n+        \"        batteryLevel = 90\\n\",\n+        \"    }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"c_Xmw5cDy_rZ\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Standard library uses of protocols\\n\",\n+        \"\\n\",\n+        \"Now that we have an idea how protocols in Swift work, let's go through some typical examples of using the standard library protocols.\\n\",\n+        \"\\n\",\n+        \"### Extend the standard library\\n\",\n+        \"Let's see how we can add additional functionality to types that exist in Swift already. Since types in Swift aren't built in, but are part of the standard library as structs, this is easy to do.\\n\",\n+        \"\\n\",\n+        \"Let's try and do binary search on an array of elements, while also making sure to check that the array is sorted.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"-Jfn3P3P1RDt\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"8082bcd1-a13b-440e-d592-c4018ddf17f4\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 68\n+        }\n+      },\n+      \"source\": [\n+        \"extension Collection where Element: Comparable {\\n\",\n+        \"    // Verify that a `Collection` is sorted.\\n\",\n+        \"    func isSorted(_ order: (Element, Element) -> Bool) -> Bool {\\n\",\n+        \"        var i = index(startIndex, offsetBy: 1)\\n\",\n+        \"        \\n\",\n+        \"        while i < endIndex {\\n\",\n+        \"            // The longer way of calling a binary function like `<(_:_:)`, \\n\",\n+        \"            // `<=(_:_:)`, `==(_:_:)`, etc.\\n\",\n+        \"            guard order(self[index(i, offsetBy: -1)], self[i]) else {\\n\",\n+        \"                return false\\n\",\n+        \"            }\\n\",\n+        \"            i = index(after: i)\\n\",\n+        \"        }\\n\",\n+        \"        return true\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    // Perform binary search on a `Collection`, verifying it is sorted.\\n\",\n+        \"    func binarySearch(_ element: Element) -> Index? {\\n\",\n+        \"        guard self.isSorted(<=) else {\\n\",\n+        \"            return nil\\n\",\n+        \"        }\\n\",\n+        \"        \\n\",\n+        \"        var low = startIndex\\n\",\n+        \"        var high = endIndex\\n\",\n+        \"        \\n\",\n+        \"        while low <= high {\\n\",\n+        \"            let mid = index(low, offsetBy: distance(from: low, to: high)/2)\\n\",\n+        \"\\n\",\n+        \"            if self[mid] == element {\\n\",\n+        \"                return mid\\n\",\n+        \"            } else if self[mid] < element {\\n\",\n+        \"                low = index(after: mid)\\n\",\n+        \"            } else {\\n\",\n+        \"                high = index(mid, offsetBy: -1)\\n\",\n+        \"            }\\n\",\n+        \"        }\\n\",\n+        \"        \\n\",\n+        \"        return nil\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"print([2, 2, 5, 7, 11, 13, 17].binarySearch(5)!)\\n\",\n+        \"print([\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"].binarySearch(\\\"b\\\")!)\\n\",\n+        \"print([1.1, 2.2, 3.3, 4.4, 5.5].binarySearch(3.3)!)\"\n+      ],\n+      \"execution_count\": 12,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"2\\r\\n\",\n+            \"1\\r\\n\",\n+            \"2\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"CIh7qyFVqlaH\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"We do this by extending the [`Collection`](https://developer.apple.com/documentation/swift/collection) protocol which defines _\\\"a sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.\\\"_ Since arrays can be indexed using the square bracket notation, this is the protocol we want to extend.\\n\",\n+        \"\\n\",\n+        \"Similarly, we only want to add this utility function to arrays whose elements can be compared. This is the reason why we have `where Element: Comparable`. \\n\",\n+        \"\\n\",\n+        \"The `where` clause is a part of Swift's type system, which we will cover soon, but in short lets us add additional requirements to the extension we are writing, such as to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.\\n\",\n+        \"\\n\",\n+        \"[`Element`](https://developer.apple.com/documentation/swift/sequence/2908099-element) is the associated type of the elements in a `Collection`-conforming type. `Element` is defined within the [`Sequence`](https://developer.apple.com/documentation/swift/sequence) protocol, but since `Collection` inherits from `Sequence`, it inherits the `Element` associated type.\\n\",\n+        \"\\n\",\n+        \"[`Comparable`](https://developer.apple.com/documentation/swift/comparable) is a protocol that defines _\\\"a type that can be compared using the relational operators `<`, `<=`, `>=`, and `>`.\\\"_. Since we are performing binary search on a sorted `Collection`, this of course has to be true or else we don't know whether to recurse/iterate left or right in the binary search.\\n\",\n+        \"\\n\",\n+        \"As a side note about the implementation,  for more info on the `index(_:offsetBy:)` function that was used, refer to the following [documentation](https://developer.apple.com/documentation/swift/string/1786175-index).\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"TmqFx2layKs7\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Generics + protocols = ðŸ’¥\\n\",\n+        \"Generics and protocols can be a powerful tool if used correctly to avoid duplicate code.\\n\",\n+        \"\\n\",\n+        \"Firstly, look over another tutorial, [A Swift Tour](https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/a_swift_tour.ipynb), which briefly covers generics at the end of the Colab book.\\n\",\n+        \"\\n\",\n+        \"Assuming you have a general idea about generics, let's quickly take a look at some advanced uses.\\n\",\n+        \"\\n\",\n+        \"When a single type has multiple requirements such as a type conforming to several protocols, you have several options at your disposal:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"HIjkHLGtz268\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"ac91c112-777a-4c4e-dbe2-8044d1735c26\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 102\n+        }\n+      },\n+      \"source\": [\n+        \"typealias ComparableReal = Comparable & FloatingPoint\\n\",\n+        \"\\n\",\n+        \"func foo1<T: ComparableReal>(a: T, b: T) -> Bool {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo2<T: Comparable & FloatingPoint>(a: T, b: T) -> Bool {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo3<T>(a: T, b: T) -> Bool where T: ComparableReal {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo4<T>(a: T, b: T) -> Bool where T: Comparable & FloatingPoint {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo5<T: FloatingPoint>(a: T, b: T) -> Bool where T: Comparable {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"print(foo1(a: 1, b: 2))\\n\",\n+        \"print(foo2(a: 1, b: 2))\\n\",\n+        \"print(foo3(a: 1, b: 2))\\n\",\n+        \"print(foo4(a: 1, b: 2))\\n\",\n+        \"print(foo5(a: 1, b: 2))\"\n+      ],\n+      \"execution_count\": 13,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"false\\r\\n\",\n+            \"false\\r\\n\",\n+            \"false\\r\\n\",\n+            \"false\\r\\n\",\n+            \"false\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"DMCioS9Dz5Fh\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Notice the use of `typealias` at the top. This adds a named alias of an existing type into your program. After a type alias is declared, the aliased name can be used instead of the existing type everywhere in your program. Type aliases do not create new types; they simply allow a name to refer to an existing type.\\n\",\n+        \"\\n\",\n+        \"Now let's see how we can use protocols and generics together.\\n\",\n+        \"\\n\",\n+        \"Let's imagine we are a computer store with the following requirements on any laptop we sell for determining how we organize them in the back of the store:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"oKvieIsw2YJW\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"enum Box {\\n\",\n+        \"    case small\\n\",\n+        \"    case medium\\n\",\n+        \"    case large\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"enum Mass {\\n\",\n+        \"    case light\\n\",\n+        \"    case medium\\n\",\n+        \"    case heavy\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Note: `CustomStringConvertible` protocol lets us pretty-print a `Laptop`.\\n\",\n+        \"struct Laptop: CustomStringConvertible {\\n\",\n+        \"    var name: String\\n\",\n+        \"    var box: Box\\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    var description: String {\\n\",\n+        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"    }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"ey519vu04FgG\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, we got a new requirement of grouping our `Laptop`s by mass since the shelves have weight restrictions.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"tVRuqx_q4jQ9\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"abee5d7a-37e5-4c7b-bcf6-d43088741bcc\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 34\n+        }\n+      },\n+      \"source\": [\n+        \"func filtering(_ laptops: [Laptop], by mass: Mass) -> [Laptop] {\\n\",\n+        \"    return laptops.filter { $0.mass == mass }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let laptops: [Laptop] = [\\n\",\n+        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n+        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n+        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n+        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n+        \"]\\n\",\n+        \"\\n\",\n+        \"let filteredLaptops = filtering(laptops, by: .light)\\n\",\n+        \"print(filteredLaptops)\"\n+      ],\n+      \"execution_count\": 15,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"[(a small light), (d large light)]\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"Lw_W5zW17UMc\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, what if we wanted to filter by something other than `Mass`? One option is to do the following.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"2qDVD9Yl8POQ\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"9d273353-1e52-4eed-8a9a-c2d3019eb992\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 51\n+        }\n+      },\n+      \"source\": [\n+        \"// Define a protocol which will act as our comparator.\\n\",\n+        \"protocol DeviceFilterPredicate {\\n\",\n+        \"    associatedtype Device\\n\",\n+        \"    func shouldKeep(_ item: Device) -> Bool\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the structs we will use for passing into our filtering function.\\n\",\n+        \"struct BoxFilter: DeviceFilterPredicate {\\n\",\n+        \"    typealias Device = Laptop\\n\",\n+        \"    var box: Box \\n\",\n+        \"    \\n\",\n+        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n+        \"        return item.box == box\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct MassFilter: DeviceFilterPredicate {\\n\",\n+        \"    typealias Device = Laptop  \\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n+        \"        return item.mass == mass\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Make sure our filter conforms to `DeviceFilterPredicate` and that we are \\n\",\n+        \"// filtering `Laptop`s.\\n\",\n+        \"func filtering<F: DeviceFilterPredicate>(\\n\",\n+        \"    _ laptops: [Laptop], \\n\",\n+        \"    by filter: F\\n\",\n+        \") -> [Laptop] where Laptop == F.Device {\\n\",\n+        \"    return laptops.filter { filter.shouldKeep($0) }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Let's test the function out!\\n\",\n+        \"print(filtering(laptops, by: BoxFilter(box: .large)))\\n\",\n+        \"print(filtering(laptops, by: MassFilter(mass: .heavy)))\"\n+      ],\n+      \"execution_count\": 16,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"[(b large medium), (d large light)]\\r\\n\",\n+            \"[(c medium heavy)]\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"yFx_6y0-CRHc\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Awesome! Now we are able to filter based on any laptop constraint. However, we are only able to filter `Laptop`s. What about being able to filter anything that is in a box and has mass? Maybe this warehouse of laptops will also be used for servers which have a different customer base.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"EzhE_K-eCvYt\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"89f16e54-e1ce-40e9-f84a-da58bb126620\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 85\n+        }\n+      },\n+      \"source\": [\n+        \"// Define 2 new protocols so we can filter anything in a box and which has mass.\\n\",\n+        \"protocol Weighable {\\n\",\n+        \"    var mass: Mass { get }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"protocol Boxed {\\n\",\n+        \"    var box: Box { get }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the new Laptop and Server struct which have mass and a box.\\n\",\n+        \"struct Laptop: CustomStringConvertible, Boxed, Weighable {\\n\",\n+        \"    var name: String\\n\",\n+        \"    var box: Box\\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    var description: String {\\n\",\n+        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct Server: CustomStringConvertible, Boxed, Weighable {\\n\",\n+        \"    var isWorking: Bool\\n\",\n+        \"    var name: String\\n\",\n+        \"    let box: Box\\n\",\n+        \"    let mass: Mass\\n\",\n+        \"\\n\",\n+        \"    var description: String {\\n\",\n+        \"        if isWorking {\\n\",\n+        \"            return \\\"(working \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"        } else {\\n\",\n+        \"            return \\\"(notWorking \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"        }\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the structs we will use for passing into our filtering function.\\n\",\n+        \"struct BoxFilter<T: Boxed>: DeviceFilterPredicate {\\n\",\n+        \"    var box: Box \\n\",\n+        \"  \\n\",\n+        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n+        \"        return item.box == box\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct MassFilter<T: Weighable>: DeviceFilterPredicate {\\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n+        \"        return item.mass == mass\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the new filter function.\\n\",\n+        \"func filtering<F: DeviceFilterPredicate, T>(\\n\",\n+        \"    _ elements: [T], \\n\",\n+        \"    by filter: F\\n\",\n+        \") -> [T] where T == F.Device {\\n\",\n+        \"    return elements.filter { filter.shouldKeep($0) }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"\\n\",\n+        \"// Let's test the function out!\\n\",\n+        \"let servers = [\\n\",\n+        \"    Server(isWorking: true, name: \\\"serverA\\\", box: .small, mass: .heavy),\\n\",\n+        \"    Server(isWorking: false, name: \\\"serverB\\\", box: .medium, mass: .medium),\\n\",\n+        \"    Server(isWorking: true, name: \\\"serverC\\\", box: .large, mass: .light),\\n\",\n+        \"    Server(isWorking: false, name: \\\"serverD\\\", box: .medium, mass: .light),\\n\",\n+        \"    Server(isWorking: true, name: \\\"serverE\\\", box: .small, mass: .heavy)\\n\",\n+        \"]\\n\",\n+        \"\\n\",\n+        \"let products = [\\n\",\n+        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n+        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n+        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n+        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n+        \"]\\n\",\n+        \"\\n\",\n+        \"print(filtering(servers, by: BoxFilter(box: .small)))\\n\",\n+        \"print(filtering(servers, by: MassFilter(mass: .medium)))\\n\",\n+        \"\\n\",\n+        \"print(filtering(products, by: BoxFilter(box: .small)))\\n\",\n+        \"print(filtering(products, by: MassFilter(mass: .medium)))\"\n+      ],\n+      \"execution_count\": 17,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"[(working serverA small heavy), (working serverE small heavy)]\\r\\n\",\n+            \"[(notWorking serverB medium medium)]\\r\\n\",\n+            \"[(a small light)]\\r\\n\",\n+            \"[(b large medium)]\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"-UrRDSaFNCRg\"\n+      },\n+      \"source\": [\n+        \"We have now been able to filter an array by not only any property of a specific `struct`, but also be able to filter any struct which has that property!\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"6g3pPZIuMvPu\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"# Tips for good API design\\n\",\n+        \"***This section was taken from the [WWDC 2019: Modern Swift API Design](https://developer.apple.com/videos/play/wwdc2019/415/) talk.***\\n\",\n+        \"\\n\",\n+        \"Now that you understand how protocols behave, it's best to now go over when you should use protocols. As powerful as protocols can be, it's not always the best idea to dive in and immediately start with protocols.\\n\",\n+        \"\\n\",\n+        \"* Start with concrete use cases.\\n\",\n+        \"    * First explore the use case with concrete types and understand what code it is you want to share and find is being repeated. Then, factor that shared code out with generics. It might mean to create new protocols. Discover a need for generic code.\\n\",\n+        \"* Consider composing new protocols from existing protocols defined in the standard library. Refer to the following [Apple documentation](https://developer.apple.com/documentation/swift/adopting_common_protocols) for a good example of this.\\n\",\n+        \"* Instead of a generic protocol, consider defining a generic type instead.\\n\",\n+        \"\\n\",\n+        \"## Example: defining a custom vector type\\n\",\n+        \"Let's say we want to define a `GeometricVector` protocol on floating-point numbers to use in some geometry app we are making which defines 3 important vector operations:\\n\",\n+        \"\\n\",\n+        \"```swift\\n\",\n+        \"protocol GeometricVector where Scalar: FloatingPoint {\\n\",",
        "comment_created_at": "2019-08-03T08:08:29+00:00",
        "comment_author": "rxwei",
        "comment_body": "Move the constraint in the where clause to the declaration of the associated type scalar.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "310343682",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-08-03T08:09:16+00:00",
    "commented_code": "{\n  \"nbformat\": 4,\n  \"nbformat_minor\": 0,\n  \"metadata\": {\n    \"colab\": {\n      \"name\": \"protocol.ipynb\",\n      \"version\": \"0.3.2\",\n      \"provenance\": [],\n      \"collapsed_sections\": []\n    },\n    \"language_info\": {\n      \"file_extension\": \".swift\",\n      \"mimetype\": \"text/x-swift\",\n      \"name\": \"swift\",\n      \"version\": \"\"\n    },\n    \"kernelspec\": {\n      \"display_name\": \"Swift\",\n      \"language\": \"swift\",\n      \"name\": \"swift\"\n    }\n  },\n  \"cells\": [\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"ZloPIuRHn97X\"\n      },\n      \"source\": [\n        \"##### Copyright 2019 The TensorFlow Authors. [Licensed under the Apache License, Version 2.0](#scrollTo=Afd8bu4xJOgh).\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"colab_type\": \"code\",\n        \"id\": \"tNgCmfUvJNoF\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"#@title Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); { display-mode: \\\"form\\\" }\\n\",\n        \"// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\",\n        \"// you may not use this file except in compliance with the License.\\n\",\n        \"// You may obtain a copy of the License at\\n\",\n        \"//\\n\",\n        \"// https://www.apache.org/licenses/LICENSE-2.0\\n\",\n        \"//\\n\",\n        \"// Unless required by applicable law or agreed to in writing, software\\n\",\n        \"// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\",\n        \"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\",\n        \"// See the License for the specific language governing permissions and\\n\",\n        \"// limitations under the License.\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"AlvdCHw5JGyx\"\n      },\n      \"source\": [\n        \"<table class=\\\"tfo-notebook-buttons\\\" align=\\\"left\\\">\\n\",\n        \"  <td>\\n\",\n        \"    <a target=\\\"_blank\\\" href=\\\"https://www.tensorflow.org/swift/tutorials/protocol_oriented_generics\\\"><img src=\\\"https://www.tensorflow.org/images/tf_logo_32px.png\\\" />View on TensorFlow.org</a>\\n\",\n        \"  </td>\\n\",\n        \"  <td>\\n\",\n        \"    <a target=\\\"_blank\\\" href=\\\"https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/colab_logo_32px.png\\\" />Run in Google Colab</a>\\n\",\n        \"  </td>\\n\",\n        \"  <td>\\n\",\n        \"    <a target=\\\"_blank\\\" href=\\\"https://github.com/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/GitHub-Mark-32px.png\\\" />View source on GitHub</a>\\n\",\n        \"  </td>\\n\",\n        \"</table>\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"c_1u7JSBMx3x\"\n      },\n      \"source\": [\n        \"# Protocol-oriented programming & generics\\n\",\n        \"\\n\",\n        \"This tutorial will go over protocol-oriented programming, and different examples of how they can be used with generics in day to day examples.\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"LP0gMw56TlvH\"\n      },\n      \"source\": [\n        \"## Protocols\\n\",\n        \"\\n\",\n        \"Inheritence is a powerful way to organize code in programming languages that allows you to share code between multiple components of the program.\\n\",\n        \"\\n\",\n        \"In Swift, there are different ways to express inheritence. One of those ways you may be familiar with already - class inheritence. However, Swift has another way - protocols.\\n\",\n        \"\\n\",\n        \"In this tutorial, we will explore protocols - an alternative to subclassing that allows you to achieve similar goals through different tradeoffs. In Swift, protocols contain multiple abstract members. Classes, structs and enums can conform to multiple protocols and the conformance relationship can be established retroactively. All that enables some designs that aren't easily expressible in Swift using subclassing. We will walk through the idioms that support the use of protocols (extensions and protocol constraints), as well as the limitations of protocols.\\n\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"5AIIH5Q59b41\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Swift ðŸ’–'s value types!\\n\",\n        \"\\n\",\n        \"In addition to classes which have reference semantics, Swift supports enums and structs that are passed by value. Enums and structs support many features provided by classes. Let's take a look!\\n\",\n        \"\\n\",\n        \"Firstly let's look at how enums are similar to classes.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"zCN0Uc0w-gng\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"4dbad5e2-fad0-4be9-f6f2-bf9982c94893\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 51\n        }\n      },\n      \"source\": [\n        \"enum Color: String {\\n\",\n        \"    case red = \\\"red\\\"\\n\",\n        \"    case green = \\\"green\\\"\\n\",\n        \"    case blue = \\\"blue\\\"\\n\",\n        \"    // A computed property. Note that enums cannot contain stored properties.\\n\",\n        \"    var giveHint: String {\\n\",\n        \"        switch self {\\n\",\n        \"            case .red:\\n\",\n        \"                return \\\"Roses are this color.\\\"\\n\",\n        \"            case .green:\\n\",\n        \"                return \\\"Grass is this color.\\\"\\n\",\n        \"            case .blue:\\n\",\n        \"                return \\\"The ocean is this color.\\\"\\n\",\n        \"        }\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    // An initializer like for classes.\\n\",\n        \"    init?(color: String) {\\n\",\n        \"        switch color {\\n\",\n        \"        case \\\"red\\\":\\n\",\n        \"            self = .red\\n\",\n        \"        case \\\"green\\\":\\n\",\n        \"            self = .green\\n\",\n        \"        case \\\"blue\\\":\\n\",\n        \"            self = .blue\\n\",\n        \"        default:\\n\",\n        \"            return nil\\n\",\n        \"        }\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Can extend the enum as well!\\n\",\n        \"extension Color {\\n\",\n        \"    // A function.\\n\",\n        \"    func giveHintFunc() -> String {\\n\",\n        \"        return self.giveHint\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let c = Color.red\\n\",\n        \"print(\\\"Give me a hint for c: \\\\(c.giveHintFunc())\\\")\\n\",\n        \"\\n\",\n        \"let invalidColor = Color(color: \\\"orange\\\")\\n\",\n        \"print(\\\"is invalidColor nil: \\\\(invalidColor == nil)\\\")\"\n      ],\n      \"execution_count\": 2,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"Give me a hint for c: Roses are this color.\\r\\n\",\n            \"is invalidColor nil: true\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"ueiGy9gCgypk\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Now let's look at structs. Notice that we cannot inherit structs, but we can use protocols instead.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"ns4qCE1pg3uJ\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"a1e4403e-abcf-4b76-c3e5-e34b0da33c7f\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 68\n        }\n      },\n      \"source\": [\n        \"struct FastCar {\\n\",\n        \"    // Can have variables and constants as stored properties.\\n\",\n        \"    var color: Color\\n\",\n        \"    let horsePower: Int\\n\",\n        \"    // Can have computed properties.\\n\",\n        \"    var watts: Float {\\n\",\n        \"       return Float(horsePower) * 745.7\\n\",\n        \"    }\\n\",\n        \"    // Can have lazy variables like in classes!\\n\",\n        \"    lazy var titleCaseColorString: String = {\\n\",\n        \"        let colorString = color.rawValue\\n\",\n        \"        return colorString.prefix(1).uppercased() + \\n\",\n        \"               colorString.lowercased().dropFirst()\\n\",\n        \"    }()\\n\",\n        \"    // A function.\\n\",\n        \"    func description() -> String {\\n\",\n        \"        return \\\"This is a \\\\(color) car with \\\\(horsePower) horse power!\\\"\\n\",\n        \"    }\\n\",\n        \"    // Can create a variety of initializers.\\n\",\n        \"    init(color: Color, horsePower: Int) {\\n\",\n        \"        self.color = color\\n\",\n        \"        self.horsePower = horsePower\\n\",\n        \"    }\\n\",\n        \"    // Can define extra initializers other than the default one.\\n\",\n        \"    init?(color: String, horsePower: Int) {\\n\",\n        \"        guard let enumColor = Color(color: color) else {\\n\",\n        \"            return nil\\n\",\n        \"        }\\n\",\n        \"        self.color = enumColor\\n\",\n        \"        self.horsePower = horsePower\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"var car = FastCar(color: .red, horsePower: 250)\\n\",\n        \"print(car.description())\\n\",\n        \"print(\\\"Horse power in watts: \\\\(car.watts)\\\")\\n\",\n        \"print(car.titleCaseColorString)\"\n      ],\n      \"execution_count\": 3,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"This is a red car with 250 horse power!\\r\\n\",\n            \"Horse power in watts: 186425.0\\r\\n\",\n            \"Red\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"1Hw8bpQIlaWT\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Finally let's see how they are pass by value types unlike classes:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"C67qzGBVlhdo\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"848838f7-0122-469f-e8c1-2f90bffe2f23\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 51\n        }\n      },\n      \"source\": [\n        \"// Notice we have no problem modifying a constant class with \\n\",\n        \"// variable properties.\\n\",\n        \"class A {\\n\",\n        \"  var a = \\\"a\\\"\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo(_ a: A) {\\n\",\n        \"  a.a = \\\"foo\\\"\\n\",\n        \"}\\n\",\n        \"let a = A()\\n\",\n        \"print(a.a)\\n\",\n        \"foo(a)\\n\",\n        \"print(a.a)\\n\",\n        \"\\n\",\n        \"/* \\n\",\n        \"Uncomment the following code to see how an error is thrown.\\n\",\n        \"Structs are implicitly passed by value, so we cannot modify it.\\n\",\n        \"> \\\"error: cannot assign to property: 'car' is a 'let' constant\\\"\\n\",\n        \"*/\\n\",\n        \"\\n\",\n        \"// func modify(car: Car, toColor color: Color) -> Void {\\n\",\n        \"//   car.color = color\\n\",\n        \"// }\\n\",\n        \"\\n\",\n        \"// car = Car(color: .red, horsePower: 250)\\n\",\n        \"// print(car.description())\\n\",\n        \"// modify(car: &car, toColor: .blue)\\n\",\n        \"// print(car.description())\\n\"\n      ],\n      \"execution_count\": 4,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"a\\r\\n\",\n            \"foo\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"0BNxC5RyoKM7\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Let's use protocols\\n\",\n        \"\\n\",\n        \"Let's start by creating protocols for different cars.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"3ZSm1uTWoJ0h\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"protocol Car {\\n\",\n        \"    var color: Color { get set }\\n\",\n        \"    var price: Int { get }\\n\",\n        \"    func turnOn()\\n\",\n        \"    mutating func drive()\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"protocol Electric {\\n\",\n        \"    mutating func recharge()\\n\",\n        \"    // percentage of the battery level, 0-100%.\\n\",\n        \"    var batteryLevel: Int { get set }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"protocol Gas {\\n\",\n        \"    mutating func refill()\\n\",\n        \"    // # of liters the car is holding, varies b/w models.\\n\",\n        \"    var gasLevelLiters: Int { get set }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"aV_F6MyLps3h\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"In an object-oriented world (with no multiple inheritance), you may have made `Electric` and `Gas` abstract classes then used class inheritance to make both inherit from `Car`, and then have a specific car model be a base class. However, here both are completely separate protocols with **zero** coupling! This makes the entire system more flexible in how you design it.\\n\",\n        \"\\n\",\n        \"Let's define a Tesla:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"LkGRtwz3psrP\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"struct TeslaModelS: Car, Electric {\\n\",\n        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n        \"    let price: Int\\n\",\n        \"    var batteryLevel: Int\\n\",\n        \"    \\n\",\n        \"    func turnOn() {\\n\",\n        \"        print(\\\"Starting all systems!\\\")\\n\",\n        \"    }\\n\",\n        \"\\n\",\n        \"    mutating func drive() {\\n\",\n        \"        print(\\\"Self driving engaged!\\\")\\n\",\n        \"        batteryLevel -= 8\\n\",\n        \"    }\\n\",\n        \"\\n\",\n        \"    mutating func recharge() {\\n\",\n        \"        print(\\\"Recharging the battery...\\\")\\n\",\n        \"        batteryLevel = 100\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"var tesla = TeslaModelS(color: .red, price: 110000, batteryLevel: 100)\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"K5KB0IGLrkcm\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"This specifies a new struct `TeslaModelS` that conforms to both protocols `Car` and `Electric`.\\n\",\n        \"\\n\",\n        \"Now letâ€™s define a gas powered car:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"GPLKFUAOrMp-\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"struct Mustang: Car, Gas{\\n\",\n        \"    var color: Color\\n\",\n        \"    let price: Int\\n\",\n        \"    var gasLevelLiters: Int\\n\",\n        \"    \\n\",\n        \"    func turnOn() {\\n\",\n        \"        print(\\\"Starting all systems!\\\")\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func drive() {\\n\",\n        \"        print(\\\"Time to drive!\\\")\\n\",\n        \"        gasLevelLiters -= 1\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func refill() {\\n\",\n        \"        print(\\\"Filling the tank...\\\")\\n\",\n        \"        gasLevelLiters = 25\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"var mustang = Mustang(color: .red, price: 30000, gasLevelLiters: 25)\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"jrbCRkglsi_d\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"### Extend protocols with default behaviors\\n\",\n        \"\\n\",\n        \"What you can notice from the examples is that we have some redundancy. Every time we recharge an electric car, we need to set the battery percentage level to 100. Since all electric cars have a max capacity of 100%, but gas cars vary between gas tank capacity, we can default the level to 100 for electric cars.\\n\",\n        \"\\n\",\n        \"This is where extensions in Swift can come in handy:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"NiHUJxXMtzSg\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"extension Electric {\\n\",\n        \"    mutating func recharge() {\\n\",\n        \"        print(\\\"Recharging the battery...\\\")\\n\",\n        \"        batteryLevel = 100\\n\",\n        \"    }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"v8QbTb9NxWqI\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"So now, any new electric car we create will set the battery to 100 when we recharge it. Thus, we have just been able to decorate classes, structs, and enums with unique and default behavior.\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"VIXakqxtvkp_\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"![Protocol Comic](https://koenig-media.raywenderlich.com/uploads/2015/06/protocols-extend.png)\\n\",\n        \"\\n\",\n        \"Thanks to [Ray Wenderlich](https://www.raywenderlich.com/814-introducing-protocol-oriented-programming-in-swift-3) for the comic!\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"MAo8n3zUR8Q9\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, one thing to watch out for is the following. In our first implementation, we define `foo()` as a default implementation on `A`, but not make it required in the protocol. So when we call `a.foo()`, we get \\\"`A default`\\\" printed.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"koP20_C9R7ps\",\n        \"colab_type\": \"code\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 34\n        },\n        \"outputId\": \"0e6375dd-f42c-4285-a9db-15b7a0477609\"\n      },\n      \"source\": [\n        \"protocol Default {}\\n\",\n        \"\\n\",\n        \"extension Default {\\n\",\n        \"    func foo() { print(\\\"A default\\\")}\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct DefaultStruct: Default {\\n\",\n        \"    func foo() {\\n\",\n        \"        print(\\\"Inst\\\")\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let a: Default = DefaultStruct()\\n\",\n        \"a.foo()\"\n      ],\n      \"execution_count\": 9,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"A default\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"uSE5IWF_Sdet\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, if we make `foo()` required on `A`, we get \\\"`Inst`\\\".\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"DJ8jstIWSoUP\",\n        \"colab_type\": \"code\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 34\n        },\n        \"outputId\": \"5c586323-f630-4d08-c2a8-b32a16d94c45\"\n      },\n      \"source\": [\n        \"protocol Default {\\n\",\n        \"    func foo()\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"extension Default {\\n\",\n        \"    func foo() { \\n\",\n        \"        print(\\\"A default\\\")\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct DefaultStruct: Default {\\n\",\n        \"    func foo() {\\n\",\n        \"        print(\\\"Inst\\\")\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let a: Default = DefaultStruct()\\n\",\n        \"a.foo()\"\n      ],\n      \"execution_count\": 10,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"Inst\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"XC1juXPzZV8Q\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"This occurs due to a difference between static dispatch in the first example and static dispatch in the second on protocols in Swift. For more info, refer to the following [Medium post](https://medium.com/@PavloShadov/https-medium-com-pavloshadov-swift-protocols-magic-of-dynamic-static-methods-dispatches-dfe0e0c85509).\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"HzB0XC0wwMLD\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"### Overriding default behavior\\n\",\n        \"\\n\",\n        \"However, if we want to, we can still override the default behavior. One important thing to note is that this [doesnâ€™t support dynamic dispatch](https://stackoverflow.com/questions/44703205/swift-protocol-extension-method-is-called-instead-of-method-implemented-in-subcl).\\n\",\n        \"\\n\",\n        \"Letâ€™s say we have an older version of an electric car, so the battery health has been reduced to 90%.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"CaIZhcsVyBKz\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"struct OldElectric: Car, Electric {\\n\",\n        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n        \"    let price: Int\\n\",\n        \"    var batteryLevel: Int\\n\",\n        \"    \\n\",\n        \"    func turnOn() {\\n\",\n        \"        print(\\\"Starting all systems!\\\")\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func drive() {\\n\",\n        \"        print(\\\"Self driving engaged!\\\")\\n\",\n        \"        batteryLevel -= 8\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    mutating func reCharge() {\\n\",\n        \"        print(\\\"Recharging the battery...\\\")\\n\",\n        \"        batteryLevel = 90\\n\",\n        \"    }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"c_Xmw5cDy_rZ\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Standard library uses of protocols\\n\",\n        \"\\n\",\n        \"Now that we have an idea how protocols in Swift work, let's go through some typical examples of using the standard library protocols.\\n\",\n        \"\\n\",\n        \"### Extend the standard library\\n\",\n        \"Let's see how we can add additional functionality to types that exist in Swift already. Since types in Swift aren't built in, but are part of the standard library as structs, this is easy to do.\\n\",\n        \"\\n\",\n        \"Let's try and do binary search on an array of elements, while also making sure to check that the array is sorted.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"-Jfn3P3P1RDt\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"8082bcd1-a13b-440e-d592-c4018ddf17f4\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 68\n        }\n      },\n      \"source\": [\n        \"extension Collection where Element: Comparable {\\n\",\n        \"    // Verify that a `Collection` is sorted.\\n\",\n        \"    func isSorted(_ order: (Element, Element) -> Bool) -> Bool {\\n\",\n        \"        var i = index(startIndex, offsetBy: 1)\\n\",\n        \"        \\n\",\n        \"        while i < endIndex {\\n\",\n        \"            // The longer way of calling a binary function like `<(_:_:)`, \\n\",\n        \"            // `<=(_:_:)`, `==(_:_:)`, etc.\\n\",\n        \"            guard order(self[index(i, offsetBy: -1)], self[i]) else {\\n\",\n        \"                return false\\n\",\n        \"            }\\n\",\n        \"            i = index(after: i)\\n\",\n        \"        }\\n\",\n        \"        return true\\n\",\n        \"    }\\n\",\n        \"    \\n\",\n        \"    // Perform binary search on a `Collection`, verifying it is sorted.\\n\",\n        \"    func binarySearch(_ element: Element) -> Index? {\\n\",\n        \"        guard self.isSorted(<=) else {\\n\",\n        \"            return nil\\n\",\n        \"        }\\n\",\n        \"        \\n\",\n        \"        var low = startIndex\\n\",\n        \"        var high = endIndex\\n\",\n        \"        \\n\",\n        \"        while low <= high {\\n\",\n        \"            let mid = index(low, offsetBy: distance(from: low, to: high)/2)\\n\",\n        \"\\n\",\n        \"            if self[mid] == element {\\n\",\n        \"                return mid\\n\",\n        \"            } else if self[mid] < element {\\n\",\n        \"                low = index(after: mid)\\n\",\n        \"            } else {\\n\",\n        \"                high = index(mid, offsetBy: -1)\\n\",\n        \"            }\\n\",\n        \"        }\\n\",\n        \"        \\n\",\n        \"        return nil\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"print([2, 2, 5, 7, 11, 13, 17].binarySearch(5)!)\\n\",\n        \"print([\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"].binarySearch(\\\"b\\\")!)\\n\",\n        \"print([1.1, 2.2, 3.3, 4.4, 5.5].binarySearch(3.3)!)\"\n      ],\n      \"execution_count\": 12,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"2\\r\\n\",\n            \"1\\r\\n\",\n            \"2\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"CIh7qyFVqlaH\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"We do this by extending the [`Collection`](https://developer.apple.com/documentation/swift/collection) protocol which defines _\\\"a sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.\\\"_ Since arrays can be indexed using the square bracket notation, this is the protocol we want to extend.\\n\",\n        \"\\n\",\n        \"Similarly, we only want to add this utility function to arrays whose elements can be compared. This is the reason why we have `where Element: Comparable`. \\n\",\n        \"\\n\",\n        \"The `where` clause is a part of Swift's type system, which we will cover soon, but in short lets us add additional requirements to the extension we are writing, such as to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.\\n\",\n        \"\\n\",\n        \"[`Element`](https://developer.apple.com/documentation/swift/sequence/2908099-element) is the associated type of the elements in a `Collection`-conforming type. `Element` is defined within the [`Sequence`](https://developer.apple.com/documentation/swift/sequence) protocol, but since `Collection` inherits from `Sequence`, it inherits the `Element` associated type.\\n\",\n        \"\\n\",\n        \"[`Comparable`](https://developer.apple.com/documentation/swift/comparable) is a protocol that defines _\\\"a type that can be compared using the relational operators `<`, `<=`, `>=`, and `>`.\\\"_. Since we are performing binary search on a sorted `Collection`, this of course has to be true or else we don't know whether to recurse/iterate left or right in the binary search.\\n\",\n        \"\\n\",\n        \"As a side note about the implementation,  for more info on the `index(_:offsetBy:)` function that was used, refer to the following [documentation](https://developer.apple.com/documentation/swift/string/1786175-index).\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"TmqFx2layKs7\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"## Generics + protocols = ðŸ’¥\\n\",\n        \"Generics and protocols can be a powerful tool if used correctly to avoid duplicate code.\\n\",\n        \"\\n\",\n        \"Firstly, look over another tutorial, [A Swift Tour](https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/a_swift_tour.ipynb), which briefly covers generics at the end of the Colab book.\\n\",\n        \"\\n\",\n        \"Assuming you have a general idea about generics, let's quickly take a look at some advanced uses.\\n\",\n        \"\\n\",\n        \"When a single type has multiple requirements such as a type conforming to several protocols, you have several options at your disposal:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"HIjkHLGtz268\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"ac91c112-777a-4c4e-dbe2-8044d1735c26\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 102\n        }\n      },\n      \"source\": [\n        \"typealias ComparableReal = Comparable & FloatingPoint\\n\",\n        \"\\n\",\n        \"func foo1<T: ComparableReal>(a: T, b: T) -> Bool {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo2<T: Comparable & FloatingPoint>(a: T, b: T) -> Bool {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo3<T>(a: T, b: T) -> Bool where T: ComparableReal {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo4<T>(a: T, b: T) -> Bool where T: Comparable & FloatingPoint {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"func foo5<T: FloatingPoint>(a: T, b: T) -> Bool where T: Comparable {\\n\",\n        \"    return a > b\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"print(foo1(a: 1, b: 2))\\n\",\n        \"print(foo2(a: 1, b: 2))\\n\",\n        \"print(foo3(a: 1, b: 2))\\n\",\n        \"print(foo4(a: 1, b: 2))\\n\",\n        \"print(foo5(a: 1, b: 2))\"\n      ],\n      \"execution_count\": 13,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"false\\r\\n\",\n            \"false\\r\\n\",\n            \"false\\r\\n\",\n            \"false\\r\\n\",\n            \"false\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"DMCioS9Dz5Fh\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Notice the use of `typealias` at the top. This adds a named alias of an existing type into your program. After a type alias is declared, the aliased name can be used instead of the existing type everywhere in your program. Type aliases do not create new types; they simply allow a name to refer to an existing type.\\n\",\n        \"\\n\",\n        \"Now let's see how we can use protocols and generics together.\\n\",\n        \"\\n\",\n        \"Let's imagine we are a computer store with the following requirements on any laptop we sell for determining how we organize them in the back of the store:\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"oKvieIsw2YJW\",\n        \"colab_type\": \"code\",\n        \"colab\": {}\n      },\n      \"source\": [\n        \"enum Box {\\n\",\n        \"    case small\\n\",\n        \"    case medium\\n\",\n        \"    case large\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"enum Mass {\\n\",\n        \"    case light\\n\",\n        \"    case medium\\n\",\n        \"    case heavy\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Note: `CustomStringConvertible` protocol lets us pretty-print a `Laptop`.\\n\",\n        \"struct Laptop: CustomStringConvertible {\\n\",\n        \"    var name: String\\n\",\n        \"    var box: Box\\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    var description: String {\\n\",\n        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"    }\\n\",\n        \"}\"\n      ],\n      \"execution_count\": 0,\n      \"outputs\": []\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"ey519vu04FgG\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, we got a new requirement of grouping our `Laptop`s by mass since the shelves have weight restrictions.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"tVRuqx_q4jQ9\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"abee5d7a-37e5-4c7b-bcf6-d43088741bcc\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 34\n        }\n      },\n      \"source\": [\n        \"func filtering(_ laptops: [Laptop], by mass: Mass) -> [Laptop] {\\n\",\n        \"    return laptops.filter { $0.mass == mass }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"let laptops: [Laptop] = [\\n\",\n        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n        \"]\\n\",\n        \"\\n\",\n        \"let filteredLaptops = filtering(laptops, by: .light)\\n\",\n        \"print(filteredLaptops)\"\n      ],\n      \"execution_count\": 15,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"[(a small light), (d large light)]\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"Lw_W5zW17UMc\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"However, what if we wanted to filter by something other than `Mass`? One option is to do the following.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"2qDVD9Yl8POQ\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"9d273353-1e52-4eed-8a9a-c2d3019eb992\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 51\n        }\n      },\n      \"source\": [\n        \"// Define a protocol which will act as our comparator.\\n\",\n        \"protocol DeviceFilterPredicate {\\n\",\n        \"    associatedtype Device\\n\",\n        \"    func shouldKeep(_ item: Device) -> Bool\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the structs we will use for passing into our filtering function.\\n\",\n        \"struct BoxFilter: DeviceFilterPredicate {\\n\",\n        \"    typealias Device = Laptop\\n\",\n        \"    var box: Box \\n\",\n        \"    \\n\",\n        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n        \"        return item.box == box\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct MassFilter: DeviceFilterPredicate {\\n\",\n        \"    typealias Device = Laptop  \\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n        \"        return item.mass == mass\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Make sure our filter conforms to `DeviceFilterPredicate` and that we are \\n\",\n        \"// filtering `Laptop`s.\\n\",\n        \"func filtering<F: DeviceFilterPredicate>(\\n\",\n        \"    _ laptops: [Laptop], \\n\",\n        \"    by filter: F\\n\",\n        \") -> [Laptop] where Laptop == F.Device {\\n\",\n        \"    return laptops.filter { filter.shouldKeep($0) }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Let's test the function out!\\n\",\n        \"print(filtering(laptops, by: BoxFilter(box: .large)))\\n\",\n        \"print(filtering(laptops, by: MassFilter(mass: .heavy)))\"\n      ],\n      \"execution_count\": 16,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"[(b large medium), (d large light)]\\r\\n\",\n            \"[(c medium heavy)]\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"yFx_6y0-CRHc\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"Awesome! Now we are able to filter based on any laptop constraint. However, we are only able to filter `Laptop`s. What about being able to filter anything that is in a box and has mass? Maybe this warehouse of laptops will also be used for servers which have a different customer base.\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"metadata\": {\n        \"id\": \"EzhE_K-eCvYt\",\n        \"colab_type\": \"code\",\n        \"outputId\": \"89f16e54-e1ce-40e9-f84a-da58bb126620\",\n        \"colab\": {\n          \"base_uri\": \"https://localhost:8080/\",\n          \"height\": 85\n        }\n      },\n      \"source\": [\n        \"// Define 2 new protocols so we can filter anything in a box and which has mass.\\n\",\n        \"protocol Weighable {\\n\",\n        \"    var mass: Mass { get }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"protocol Boxed {\\n\",\n        \"    var box: Box { get }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the new Laptop and Server struct which have mass and a box.\\n\",\n        \"struct Laptop: CustomStringConvertible, Boxed, Weighable {\\n\",\n        \"    var name: String\\n\",\n        \"    var box: Box\\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    var description: String {\\n\",\n        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct Server: CustomStringConvertible, Boxed, Weighable {\\n\",\n        \"    var isWorking: Bool\\n\",\n        \"    var name: String\\n\",\n        \"    let box: Box\\n\",\n        \"    let mass: Mass\\n\",\n        \"\\n\",\n        \"    var description: String {\\n\",\n        \"        if isWorking {\\n\",\n        \"            return \\\"(working \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"        } else {\\n\",\n        \"            return \\\"(notWorking \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n        \"        }\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the structs we will use for passing into our filtering function.\\n\",\n        \"struct BoxFilter<T: Boxed>: DeviceFilterPredicate {\\n\",\n        \"    var box: Box \\n\",\n        \"  \\n\",\n        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n        \"        return item.box == box\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"struct MassFilter<T: Weighable>: DeviceFilterPredicate {\\n\",\n        \"    var mass: Mass\\n\",\n        \"    \\n\",\n        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n        \"        return item.mass == mass\\n\",\n        \"    }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"// Define the new filter function.\\n\",\n        \"func filtering<F: DeviceFilterPredicate, T>(\\n\",\n        \"    _ elements: [T], \\n\",\n        \"    by filter: F\\n\",\n        \") -> [T] where T == F.Device {\\n\",\n        \"    return elements.filter { filter.shouldKeep($0) }\\n\",\n        \"}\\n\",\n        \"\\n\",\n        \"\\n\",\n        \"// Let's test the function out!\\n\",\n        \"let servers = [\\n\",\n        \"    Server(isWorking: true, name: \\\"serverA\\\", box: .small, mass: .heavy),\\n\",\n        \"    Server(isWorking: false, name: \\\"serverB\\\", box: .medium, mass: .medium),\\n\",\n        \"    Server(isWorking: true, name: \\\"serverC\\\", box: .large, mass: .light),\\n\",\n        \"    Server(isWorking: false, name: \\\"serverD\\\", box: .medium, mass: .light),\\n\",\n        \"    Server(isWorking: true, name: \\\"serverE\\\", box: .small, mass: .heavy)\\n\",\n        \"]\\n\",\n        \"\\n\",\n        \"let products = [\\n\",\n        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n        \"]\\n\",\n        \"\\n\",\n        \"print(filtering(servers, by: BoxFilter(box: .small)))\\n\",\n        \"print(filtering(servers, by: MassFilter(mass: .medium)))\\n\",\n        \"\\n\",\n        \"print(filtering(products, by: BoxFilter(box: .small)))\\n\",\n        \"print(filtering(products, by: MassFilter(mass: .medium)))\"\n      ],\n      \"execution_count\": 17,\n      \"outputs\": [\n        {\n          \"output_type\": \"stream\",\n          \"text\": [\n            \"[(working serverA small heavy), (working serverE small heavy)]\\r\\n\",\n            \"[(notWorking serverB medium medium)]\\r\\n\",\n            \"[(a small light)]\\r\\n\",\n            \"[(b large medium)]\\r\\n\"\n          ],\n          \"name\": \"stdout\"\n        }\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"colab_type\": \"text\",\n        \"id\": \"-UrRDSaFNCRg\"\n      },\n      \"source\": [\n        \"We have now been able to filter an array by not only any property of a specific `struct`, but also be able to filter any struct which has that property!\"\n      ]\n    },\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"6g3pPZIuMvPu\",\n        \"colab_type\": \"text\"\n      },\n      \"source\": [\n        \"# Tips for good API design\\n\",\n        \"***This section was taken from the [WWDC 2019: Modern Swift API Design](https://developer.apple.com/videos/play/wwdc2019/415/) talk.***\\n\",\n        \"\\n\",\n        \"Now that you understand how protocols behave, it's best to now go over when you should use protocols. As powerful as protocols can be, it's not always the best idea to dive in and immediately start with protocols.\\n\",\n        \"\\n\",\n        \"* Start with concrete use cases.\\n\",\n        \"    * First explore the use case with concrete types and understand what code it is you want to share and find is being repeated. Then, factor that shared code out with generics. It might mean to create new protocols. Discover a need for generic code.\\n\",\n        \"* Consider composing new protocols from existing protocols defined in the standard library. Refer to the following [Apple documentation](https://developer.apple.com/documentation/swift/adopting_common_protocols) for a good example of this.\\n\",\n        \"* Instead of a generic protocol, consider defining a generic type instead.\\n\",\n        \"\\n\",\n        \"## Example: defining a custom vector type\\n\",\n        \"Let's say we want to define a `GeometricVector` protocol on floating-point numbers to use in some geometry app we are making which defines 3 important vector operations:\\n\",\n        \"\\n\",\n        \"```swift\\n\",\n        \"protocol GeometricVector where Scalar: FloatingPoint {\\n\",\n        \"    associatedtype Scalar\\n\",\n        \"    static func dot(_ a: Self, _ b: Self) -> Scalar\\n\",\n        \"    var length: Scalar { get }\\n\",\n        \"    func distance(to other: Self) -> Scalar\\n\",\n        \"}\\n\",\n        \"```\\n\",\n        \"\\n\",\n        \"Let's say we want to store the dimensions of the vector, which the `SIMD` protocol can help us with, so we will make our new type refine the `SIMD` protocol. `SIMD` vectors can be thought of as fixed size vectors that are very fast when you use them to perform vector operations:\\n\",\n        \"\\n\",\n        \"```swift\\n\",\n        \"protocol GeometricVector: SIMD where Scalar: FloatingPoint {\\n\",",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "310343682",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "310343682",
        "commented_code": "@@ -0,0 +1,1307 @@\n+{\n+  \"nbformat\": 4,\n+  \"nbformat_minor\": 0,\n+  \"metadata\": {\n+    \"colab\": {\n+      \"name\": \"protocol.ipynb\",\n+      \"version\": \"0.3.2\",\n+      \"provenance\": [],\n+      \"collapsed_sections\": []\n+    },\n+    \"language_info\": {\n+      \"file_extension\": \".swift\",\n+      \"mimetype\": \"text/x-swift\",\n+      \"name\": \"swift\",\n+      \"version\": \"\"\n+    },\n+    \"kernelspec\": {\n+      \"display_name\": \"Swift\",\n+      \"language\": \"swift\",\n+      \"name\": \"swift\"\n+    }\n+  },\n+  \"cells\": [\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"ZloPIuRHn97X\"\n+      },\n+      \"source\": [\n+        \"##### Copyright 2019 The TensorFlow Authors. [Licensed under the Apache License, Version 2.0](#scrollTo=Afd8bu4xJOgh).\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"colab_type\": \"code\",\n+        \"id\": \"tNgCmfUvJNoF\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"#@title Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); { display-mode: \\\"form\\\" }\\n\",\n+        \"// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\",\n+        \"// you may not use this file except in compliance with the License.\\n\",\n+        \"// You may obtain a copy of the License at\\n\",\n+        \"//\\n\",\n+        \"// https://www.apache.org/licenses/LICENSE-2.0\\n\",\n+        \"//\\n\",\n+        \"// Unless required by applicable law or agreed to in writing, software\\n\",\n+        \"// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\",\n+        \"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\",\n+        \"// See the License for the specific language governing permissions and\\n\",\n+        \"// limitations under the License.\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"AlvdCHw5JGyx\"\n+      },\n+      \"source\": [\n+        \"<table class=\\\"tfo-notebook-buttons\\\" align=\\\"left\\\">\\n\",\n+        \"  <td>\\n\",\n+        \"    <a target=\\\"_blank\\\" href=\\\"https://www.tensorflow.org/swift/tutorials/protocol_oriented_generics\\\"><img src=\\\"https://www.tensorflow.org/images/tf_logo_32px.png\\\" />View on TensorFlow.org</a>\\n\",\n+        \"  </td>\\n\",\n+        \"  <td>\\n\",\n+        \"    <a target=\\\"_blank\\\" href=\\\"https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/colab_logo_32px.png\\\" />Run in Google Colab</a>\\n\",\n+        \"  </td>\\n\",\n+        \"  <td>\\n\",\n+        \"    <a target=\\\"_blank\\\" href=\\\"https://github.com/tensorflow/swift/blob/master/docs/site/tutorials/protocol_oriented_generics.ipynb\\\"><img src=\\\"https://www.tensorflow.org/images/GitHub-Mark-32px.png\\\" />View source on GitHub</a>\\n\",\n+        \"  </td>\\n\",\n+        \"</table>\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"c_1u7JSBMx3x\"\n+      },\n+      \"source\": [\n+        \"# Protocol-oriented programming & generics\\n\",\n+        \"\\n\",\n+        \"This tutorial will go over protocol-oriented programming, and different examples of how they can be used with generics in day to day examples.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"LP0gMw56TlvH\"\n+      },\n+      \"source\": [\n+        \"## Protocols\\n\",\n+        \"\\n\",\n+        \"Inheritence is a powerful way to organize code in programming languages that allows you to share code between multiple components of the program.\\n\",\n+        \"\\n\",\n+        \"In Swift, there are different ways to express inheritence. One of those ways you may be familiar with already - class inheritence. However, Swift has another way - protocols.\\n\",\n+        \"\\n\",\n+        \"In this tutorial, we will explore protocols - an alternative to subclassing that allows you to achieve similar goals through different tradeoffs. In Swift, protocols contain multiple abstract members. Classes, structs and enums can conform to multiple protocols and the conformance relationship can be established retroactively. All that enables some designs that aren't easily expressible in Swift using subclassing. We will walk through the idioms that support the use of protocols (extensions and protocol constraints), as well as the limitations of protocols.\\n\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"5AIIH5Q59b41\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Swift ðŸ’–'s value types!\\n\",\n+        \"\\n\",\n+        \"In addition to classes which have reference semantics, Swift supports enums and structs that are passed by value. Enums and structs support many features provided by classes. Let's take a look!\\n\",\n+        \"\\n\",\n+        \"Firstly let's look at how enums are similar to classes.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"zCN0Uc0w-gng\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"4dbad5e2-fad0-4be9-f6f2-bf9982c94893\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 51\n+        }\n+      },\n+      \"source\": [\n+        \"enum Color: String {\\n\",\n+        \"    case red = \\\"red\\\"\\n\",\n+        \"    case green = \\\"green\\\"\\n\",\n+        \"    case blue = \\\"blue\\\"\\n\",\n+        \"    // A computed property. Note that enums cannot contain stored properties.\\n\",\n+        \"    var giveHint: String {\\n\",\n+        \"        switch self {\\n\",\n+        \"            case .red:\\n\",\n+        \"                return \\\"Roses are this color.\\\"\\n\",\n+        \"            case .green:\\n\",\n+        \"                return \\\"Grass is this color.\\\"\\n\",\n+        \"            case .blue:\\n\",\n+        \"                return \\\"The ocean is this color.\\\"\\n\",\n+        \"        }\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    // An initializer like for classes.\\n\",\n+        \"    init?(color: String) {\\n\",\n+        \"        switch color {\\n\",\n+        \"        case \\\"red\\\":\\n\",\n+        \"            self = .red\\n\",\n+        \"        case \\\"green\\\":\\n\",\n+        \"            self = .green\\n\",\n+        \"        case \\\"blue\\\":\\n\",\n+        \"            self = .blue\\n\",\n+        \"        default:\\n\",\n+        \"            return nil\\n\",\n+        \"        }\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Can extend the enum as well!\\n\",\n+        \"extension Color {\\n\",\n+        \"    // A function.\\n\",\n+        \"    func giveHintFunc() -> String {\\n\",\n+        \"        return self.giveHint\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let c = Color.red\\n\",\n+        \"print(\\\"Give me a hint for c: \\\\(c.giveHintFunc())\\\")\\n\",\n+        \"\\n\",\n+        \"let invalidColor = Color(color: \\\"orange\\\")\\n\",\n+        \"print(\\\"is invalidColor nil: \\\\(invalidColor == nil)\\\")\"\n+      ],\n+      \"execution_count\": 2,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"Give me a hint for c: Roses are this color.\\r\\n\",\n+            \"is invalidColor nil: true\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"ueiGy9gCgypk\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Now let's look at structs. Notice that we cannot inherit structs, but we can use protocols instead.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"ns4qCE1pg3uJ\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"a1e4403e-abcf-4b76-c3e5-e34b0da33c7f\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 68\n+        }\n+      },\n+      \"source\": [\n+        \"struct FastCar {\\n\",\n+        \"    // Can have variables and constants as stored properties.\\n\",\n+        \"    var color: Color\\n\",\n+        \"    let horsePower: Int\\n\",\n+        \"    // Can have computed properties.\\n\",\n+        \"    var watts: Float {\\n\",\n+        \"       return Float(horsePower) * 745.7\\n\",\n+        \"    }\\n\",\n+        \"    // Can have lazy variables like in classes!\\n\",\n+        \"    lazy var titleCaseColorString: String = {\\n\",\n+        \"        let colorString = color.rawValue\\n\",\n+        \"        return colorString.prefix(1).uppercased() + \\n\",\n+        \"               colorString.lowercased().dropFirst()\\n\",\n+        \"    }()\\n\",\n+        \"    // A function.\\n\",\n+        \"    func description() -> String {\\n\",\n+        \"        return \\\"This is a \\\\(color) car with \\\\(horsePower) horse power!\\\"\\n\",\n+        \"    }\\n\",\n+        \"    // Can create a variety of initializers.\\n\",\n+        \"    init(color: Color, horsePower: Int) {\\n\",\n+        \"        self.color = color\\n\",\n+        \"        self.horsePower = horsePower\\n\",\n+        \"    }\\n\",\n+        \"    // Can define extra initializers other than the default one.\\n\",\n+        \"    init?(color: String, horsePower: Int) {\\n\",\n+        \"        guard let enumColor = Color(color: color) else {\\n\",\n+        \"            return nil\\n\",\n+        \"        }\\n\",\n+        \"        self.color = enumColor\\n\",\n+        \"        self.horsePower = horsePower\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"var car = FastCar(color: .red, horsePower: 250)\\n\",\n+        \"print(car.description())\\n\",\n+        \"print(\\\"Horse power in watts: \\\\(car.watts)\\\")\\n\",\n+        \"print(car.titleCaseColorString)\"\n+      ],\n+      \"execution_count\": 3,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"This is a red car with 250 horse power!\\r\\n\",\n+            \"Horse power in watts: 186425.0\\r\\n\",\n+            \"Red\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"1Hw8bpQIlaWT\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Finally let's see how they are pass by value types unlike classes:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"C67qzGBVlhdo\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"848838f7-0122-469f-e8c1-2f90bffe2f23\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 51\n+        }\n+      },\n+      \"source\": [\n+        \"// Notice we have no problem modifying a constant class with \\n\",\n+        \"// variable properties.\\n\",\n+        \"class A {\\n\",\n+        \"  var a = \\\"a\\\"\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo(_ a: A) {\\n\",\n+        \"  a.a = \\\"foo\\\"\\n\",\n+        \"}\\n\",\n+        \"let a = A()\\n\",\n+        \"print(a.a)\\n\",\n+        \"foo(a)\\n\",\n+        \"print(a.a)\\n\",\n+        \"\\n\",\n+        \"/* \\n\",\n+        \"Uncomment the following code to see how an error is thrown.\\n\",\n+        \"Structs are implicitly passed by value, so we cannot modify it.\\n\",\n+        \"> \\\"error: cannot assign to property: 'car' is a 'let' constant\\\"\\n\",\n+        \"*/\\n\",\n+        \"\\n\",\n+        \"// func modify(car: Car, toColor color: Color) -> Void {\\n\",\n+        \"//   car.color = color\\n\",\n+        \"// }\\n\",\n+        \"\\n\",\n+        \"// car = Car(color: .red, horsePower: 250)\\n\",\n+        \"// print(car.description())\\n\",\n+        \"// modify(car: &car, toColor: .blue)\\n\",\n+        \"// print(car.description())\\n\"\n+      ],\n+      \"execution_count\": 4,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"a\\r\\n\",\n+            \"foo\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"0BNxC5RyoKM7\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Let's use protocols\\n\",\n+        \"\\n\",\n+        \"Let's start by creating protocols for different cars.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"3ZSm1uTWoJ0h\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"protocol Car {\\n\",\n+        \"    var color: Color { get set }\\n\",\n+        \"    var price: Int { get }\\n\",\n+        \"    func turnOn()\\n\",\n+        \"    mutating func drive()\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"protocol Electric {\\n\",\n+        \"    mutating func recharge()\\n\",\n+        \"    // percentage of the battery level, 0-100%.\\n\",\n+        \"    var batteryLevel: Int { get set }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"protocol Gas {\\n\",\n+        \"    mutating func refill()\\n\",\n+        \"    // # of liters the car is holding, varies b/w models.\\n\",\n+        \"    var gasLevelLiters: Int { get set }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"aV_F6MyLps3h\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"In an object-oriented world (with no multiple inheritance), you may have made `Electric` and `Gas` abstract classes then used class inheritance to make both inherit from `Car`, and then have a specific car model be a base class. However, here both are completely separate protocols with **zero** coupling! This makes the entire system more flexible in how you design it.\\n\",\n+        \"\\n\",\n+        \"Let's define a Tesla:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"LkGRtwz3psrP\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"struct TeslaModelS: Car, Electric {\\n\",\n+        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n+        \"    let price: Int\\n\",\n+        \"    var batteryLevel: Int\\n\",\n+        \"    \\n\",\n+        \"    func turnOn() {\\n\",\n+        \"        print(\\\"Starting all systems!\\\")\\n\",\n+        \"    }\\n\",\n+        \"\\n\",\n+        \"    mutating func drive() {\\n\",\n+        \"        print(\\\"Self driving engaged!\\\")\\n\",\n+        \"        batteryLevel -= 8\\n\",\n+        \"    }\\n\",\n+        \"\\n\",\n+        \"    mutating func recharge() {\\n\",\n+        \"        print(\\\"Recharging the battery...\\\")\\n\",\n+        \"        batteryLevel = 100\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"var tesla = TeslaModelS(color: .red, price: 110000, batteryLevel: 100)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"K5KB0IGLrkcm\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"This specifies a new struct `TeslaModelS` that conforms to both protocols `Car` and `Electric`.\\n\",\n+        \"\\n\",\n+        \"Now letâ€™s define a gas powered car:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"GPLKFUAOrMp-\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"struct Mustang: Car, Gas{\\n\",\n+        \"    var color: Color\\n\",\n+        \"    let price: Int\\n\",\n+        \"    var gasLevelLiters: Int\\n\",\n+        \"    \\n\",\n+        \"    func turnOn() {\\n\",\n+        \"        print(\\\"Starting all systems!\\\")\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func drive() {\\n\",\n+        \"        print(\\\"Time to drive!\\\")\\n\",\n+        \"        gasLevelLiters -= 1\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func refill() {\\n\",\n+        \"        print(\\\"Filling the tank...\\\")\\n\",\n+        \"        gasLevelLiters = 25\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"var mustang = Mustang(color: .red, price: 30000, gasLevelLiters: 25)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"jrbCRkglsi_d\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"### Extend protocols with default behaviors\\n\",\n+        \"\\n\",\n+        \"What you can notice from the examples is that we have some redundancy. Every time we recharge an electric car, we need to set the battery percentage level to 100. Since all electric cars have a max capacity of 100%, but gas cars vary between gas tank capacity, we can default the level to 100 for electric cars.\\n\",\n+        \"\\n\",\n+        \"This is where extensions in Swift can come in handy:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"NiHUJxXMtzSg\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"extension Electric {\\n\",\n+        \"    mutating func recharge() {\\n\",\n+        \"        print(\\\"Recharging the battery...\\\")\\n\",\n+        \"        batteryLevel = 100\\n\",\n+        \"    }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"v8QbTb9NxWqI\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"So now, any new electric car we create will set the battery to 100 when we recharge it. Thus, we have just been able to decorate classes, structs, and enums with unique and default behavior.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"VIXakqxtvkp_\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"![Protocol Comic](https://koenig-media.raywenderlich.com/uploads/2015/06/protocols-extend.png)\\n\",\n+        \"\\n\",\n+        \"Thanks to [Ray Wenderlich](https://www.raywenderlich.com/814-introducing-protocol-oriented-programming-in-swift-3) for the comic!\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"MAo8n3zUR8Q9\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, one thing to watch out for is the following. In our first implementation, we define `foo()` as a default implementation on `A`, but not make it required in the protocol. So when we call `a.foo()`, we get \\\"`A default`\\\" printed.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"koP20_C9R7ps\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 34\n+        },\n+        \"outputId\": \"0e6375dd-f42c-4285-a9db-15b7a0477609\"\n+      },\n+      \"source\": [\n+        \"protocol Default {}\\n\",\n+        \"\\n\",\n+        \"extension Default {\\n\",\n+        \"    func foo() { print(\\\"A default\\\")}\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct DefaultStruct: Default {\\n\",\n+        \"    func foo() {\\n\",\n+        \"        print(\\\"Inst\\\")\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let a: Default = DefaultStruct()\\n\",\n+        \"a.foo()\"\n+      ],\n+      \"execution_count\": 9,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"A default\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"uSE5IWF_Sdet\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, if we make `foo()` required on `A`, we get \\\"`Inst`\\\".\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"DJ8jstIWSoUP\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 34\n+        },\n+        \"outputId\": \"5c586323-f630-4d08-c2a8-b32a16d94c45\"\n+      },\n+      \"source\": [\n+        \"protocol Default {\\n\",\n+        \"    func foo()\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"extension Default {\\n\",\n+        \"    func foo() { \\n\",\n+        \"        print(\\\"A default\\\")\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct DefaultStruct: Default {\\n\",\n+        \"    func foo() {\\n\",\n+        \"        print(\\\"Inst\\\")\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let a: Default = DefaultStruct()\\n\",\n+        \"a.foo()\"\n+      ],\n+      \"execution_count\": 10,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"Inst\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"XC1juXPzZV8Q\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"This occurs due to a difference between static dispatch in the first example and static dispatch in the second on protocols in Swift. For more info, refer to the following [Medium post](https://medium.com/@PavloShadov/https-medium-com-pavloshadov-swift-protocols-magic-of-dynamic-static-methods-dispatches-dfe0e0c85509).\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"HzB0XC0wwMLD\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"### Overriding default behavior\\n\",\n+        \"\\n\",\n+        \"However, if we want to, we can still override the default behavior. One important thing to note is that this [doesnâ€™t support dynamic dispatch](https://stackoverflow.com/questions/44703205/swift-protocol-extension-method-is-called-instead-of-method-implemented-in-subcl).\\n\",\n+        \"\\n\",\n+        \"Letâ€™s say we have an older version of an electric car, so the battery health has been reduced to 90%.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"CaIZhcsVyBKz\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"struct OldElectric: Car, Electric {\\n\",\n+        \"    var color: Color // Needs to be a var since `Car` has a getter and setter.\\n\",\n+        \"    let price: Int\\n\",\n+        \"    var batteryLevel: Int\\n\",\n+        \"    \\n\",\n+        \"    func turnOn() {\\n\",\n+        \"        print(\\\"Starting all systems!\\\")\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func drive() {\\n\",\n+        \"        print(\\\"Self driving engaged!\\\")\\n\",\n+        \"        batteryLevel -= 8\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    mutating func reCharge() {\\n\",\n+        \"        print(\\\"Recharging the battery...\\\")\\n\",\n+        \"        batteryLevel = 90\\n\",\n+        \"    }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"c_Xmw5cDy_rZ\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Standard library uses of protocols\\n\",\n+        \"\\n\",\n+        \"Now that we have an idea how protocols in Swift work, let's go through some typical examples of using the standard library protocols.\\n\",\n+        \"\\n\",\n+        \"### Extend the standard library\\n\",\n+        \"Let's see how we can add additional functionality to types that exist in Swift already. Since types in Swift aren't built in, but are part of the standard library as structs, this is easy to do.\\n\",\n+        \"\\n\",\n+        \"Let's try and do binary search on an array of elements, while also making sure to check that the array is sorted.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"-Jfn3P3P1RDt\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"8082bcd1-a13b-440e-d592-c4018ddf17f4\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 68\n+        }\n+      },\n+      \"source\": [\n+        \"extension Collection where Element: Comparable {\\n\",\n+        \"    // Verify that a `Collection` is sorted.\\n\",\n+        \"    func isSorted(_ order: (Element, Element) -> Bool) -> Bool {\\n\",\n+        \"        var i = index(startIndex, offsetBy: 1)\\n\",\n+        \"        \\n\",\n+        \"        while i < endIndex {\\n\",\n+        \"            // The longer way of calling a binary function like `<(_:_:)`, \\n\",\n+        \"            // `<=(_:_:)`, `==(_:_:)`, etc.\\n\",\n+        \"            guard order(self[index(i, offsetBy: -1)], self[i]) else {\\n\",\n+        \"                return false\\n\",\n+        \"            }\\n\",\n+        \"            i = index(after: i)\\n\",\n+        \"        }\\n\",\n+        \"        return true\\n\",\n+        \"    }\\n\",\n+        \"    \\n\",\n+        \"    // Perform binary search on a `Collection`, verifying it is sorted.\\n\",\n+        \"    func binarySearch(_ element: Element) -> Index? {\\n\",\n+        \"        guard self.isSorted(<=) else {\\n\",\n+        \"            return nil\\n\",\n+        \"        }\\n\",\n+        \"        \\n\",\n+        \"        var low = startIndex\\n\",\n+        \"        var high = endIndex\\n\",\n+        \"        \\n\",\n+        \"        while low <= high {\\n\",\n+        \"            let mid = index(low, offsetBy: distance(from: low, to: high)/2)\\n\",\n+        \"\\n\",\n+        \"            if self[mid] == element {\\n\",\n+        \"                return mid\\n\",\n+        \"            } else if self[mid] < element {\\n\",\n+        \"                low = index(after: mid)\\n\",\n+        \"            } else {\\n\",\n+        \"                high = index(mid, offsetBy: -1)\\n\",\n+        \"            }\\n\",\n+        \"        }\\n\",\n+        \"        \\n\",\n+        \"        return nil\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"print([2, 2, 5, 7, 11, 13, 17].binarySearch(5)!)\\n\",\n+        \"print([\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"].binarySearch(\\\"b\\\")!)\\n\",\n+        \"print([1.1, 2.2, 3.3, 4.4, 5.5].binarySearch(3.3)!)\"\n+      ],\n+      \"execution_count\": 12,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"2\\r\\n\",\n+            \"1\\r\\n\",\n+            \"2\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"CIh7qyFVqlaH\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"We do this by extending the [`Collection`](https://developer.apple.com/documentation/swift/collection) protocol which defines _\\\"a sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.\\\"_ Since arrays can be indexed using the square bracket notation, this is the protocol we want to extend.\\n\",\n+        \"\\n\",\n+        \"Similarly, we only want to add this utility function to arrays whose elements can be compared. This is the reason why we have `where Element: Comparable`. \\n\",\n+        \"\\n\",\n+        \"The `where` clause is a part of Swift's type system, which we will cover soon, but in short lets us add additional requirements to the extension we are writing, such as to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.\\n\",\n+        \"\\n\",\n+        \"[`Element`](https://developer.apple.com/documentation/swift/sequence/2908099-element) is the associated type of the elements in a `Collection`-conforming type. `Element` is defined within the [`Sequence`](https://developer.apple.com/documentation/swift/sequence) protocol, but since `Collection` inherits from `Sequence`, it inherits the `Element` associated type.\\n\",\n+        \"\\n\",\n+        \"[`Comparable`](https://developer.apple.com/documentation/swift/comparable) is a protocol that defines _\\\"a type that can be compared using the relational operators `<`, `<=`, `>=`, and `>`.\\\"_. Since we are performing binary search on a sorted `Collection`, this of course has to be true or else we don't know whether to recurse/iterate left or right in the binary search.\\n\",\n+        \"\\n\",\n+        \"As a side note about the implementation,  for more info on the `index(_:offsetBy:)` function that was used, refer to the following [documentation](https://developer.apple.com/documentation/swift/string/1786175-index).\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"TmqFx2layKs7\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"## Generics + protocols = ðŸ’¥\\n\",\n+        \"Generics and protocols can be a powerful tool if used correctly to avoid duplicate code.\\n\",\n+        \"\\n\",\n+        \"Firstly, look over another tutorial, [A Swift Tour](https://colab.research.google.com/github/tensorflow/swift/blob/master/docs/site/tutorials/a_swift_tour.ipynb), which briefly covers generics at the end of the Colab book.\\n\",\n+        \"\\n\",\n+        \"Assuming you have a general idea about generics, let's quickly take a look at some advanced uses.\\n\",\n+        \"\\n\",\n+        \"When a single type has multiple requirements such as a type conforming to several protocols, you have several options at your disposal:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"HIjkHLGtz268\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"ac91c112-777a-4c4e-dbe2-8044d1735c26\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 102\n+        }\n+      },\n+      \"source\": [\n+        \"typealias ComparableReal = Comparable & FloatingPoint\\n\",\n+        \"\\n\",\n+        \"func foo1<T: ComparableReal>(a: T, b: T) -> Bool {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo2<T: Comparable & FloatingPoint>(a: T, b: T) -> Bool {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo3<T>(a: T, b: T) -> Bool where T: ComparableReal {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo4<T>(a: T, b: T) -> Bool where T: Comparable & FloatingPoint {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"func foo5<T: FloatingPoint>(a: T, b: T) -> Bool where T: Comparable {\\n\",\n+        \"    return a > b\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"print(foo1(a: 1, b: 2))\\n\",\n+        \"print(foo2(a: 1, b: 2))\\n\",\n+        \"print(foo3(a: 1, b: 2))\\n\",\n+        \"print(foo4(a: 1, b: 2))\\n\",\n+        \"print(foo5(a: 1, b: 2))\"\n+      ],\n+      \"execution_count\": 13,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"false\\r\\n\",\n+            \"false\\r\\n\",\n+            \"false\\r\\n\",\n+            \"false\\r\\n\",\n+            \"false\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"DMCioS9Dz5Fh\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Notice the use of `typealias` at the top. This adds a named alias of an existing type into your program. After a type alias is declared, the aliased name can be used instead of the existing type everywhere in your program. Type aliases do not create new types; they simply allow a name to refer to an existing type.\\n\",\n+        \"\\n\",\n+        \"Now let's see how we can use protocols and generics together.\\n\",\n+        \"\\n\",\n+        \"Let's imagine we are a computer store with the following requirements on any laptop we sell for determining how we organize them in the back of the store:\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"oKvieIsw2YJW\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {}\n+      },\n+      \"source\": [\n+        \"enum Box {\\n\",\n+        \"    case small\\n\",\n+        \"    case medium\\n\",\n+        \"    case large\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"enum Mass {\\n\",\n+        \"    case light\\n\",\n+        \"    case medium\\n\",\n+        \"    case heavy\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Note: `CustomStringConvertible` protocol lets us pretty-print a `Laptop`.\\n\",\n+        \"struct Laptop: CustomStringConvertible {\\n\",\n+        \"    var name: String\\n\",\n+        \"    var box: Box\\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    var description: String {\\n\",\n+        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"    }\\n\",\n+        \"}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"ey519vu04FgG\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, we got a new requirement of grouping our `Laptop`s by mass since the shelves have weight restrictions.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"tVRuqx_q4jQ9\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"abee5d7a-37e5-4c7b-bcf6-d43088741bcc\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 34\n+        }\n+      },\n+      \"source\": [\n+        \"func filtering(_ laptops: [Laptop], by mass: Mass) -> [Laptop] {\\n\",\n+        \"    return laptops.filter { $0.mass == mass }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"let laptops: [Laptop] = [\\n\",\n+        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n+        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n+        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n+        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n+        \"]\\n\",\n+        \"\\n\",\n+        \"let filteredLaptops = filtering(laptops, by: .light)\\n\",\n+        \"print(filteredLaptops)\"\n+      ],\n+      \"execution_count\": 15,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"[(a small light), (d large light)]\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"Lw_W5zW17UMc\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"However, what if we wanted to filter by something other than `Mass`? One option is to do the following.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"2qDVD9Yl8POQ\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"9d273353-1e52-4eed-8a9a-c2d3019eb992\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 51\n+        }\n+      },\n+      \"source\": [\n+        \"// Define a protocol which will act as our comparator.\\n\",\n+        \"protocol DeviceFilterPredicate {\\n\",\n+        \"    associatedtype Device\\n\",\n+        \"    func shouldKeep(_ item: Device) -> Bool\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the structs we will use for passing into our filtering function.\\n\",\n+        \"struct BoxFilter: DeviceFilterPredicate {\\n\",\n+        \"    typealias Device = Laptop\\n\",\n+        \"    var box: Box \\n\",\n+        \"    \\n\",\n+        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n+        \"        return item.box == box\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct MassFilter: DeviceFilterPredicate {\\n\",\n+        \"    typealias Device = Laptop  \\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    func shouldKeep(_ item: Laptop) -> Bool {\\n\",\n+        \"        return item.mass == mass\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Make sure our filter conforms to `DeviceFilterPredicate` and that we are \\n\",\n+        \"// filtering `Laptop`s.\\n\",\n+        \"func filtering<F: DeviceFilterPredicate>(\\n\",\n+        \"    _ laptops: [Laptop], \\n\",\n+        \"    by filter: F\\n\",\n+        \") -> [Laptop] where Laptop == F.Device {\\n\",\n+        \"    return laptops.filter { filter.shouldKeep($0) }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Let's test the function out!\\n\",\n+        \"print(filtering(laptops, by: BoxFilter(box: .large)))\\n\",\n+        \"print(filtering(laptops, by: MassFilter(mass: .heavy)))\"\n+      ],\n+      \"execution_count\": 16,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"[(b large medium), (d large light)]\\r\\n\",\n+            \"[(c medium heavy)]\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"yFx_6y0-CRHc\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"Awesome! Now we are able to filter based on any laptop constraint. However, we are only able to filter `Laptop`s. What about being able to filter anything that is in a box and has mass? Maybe this warehouse of laptops will also be used for servers which have a different customer base.\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"code\",\n+      \"metadata\": {\n+        \"id\": \"EzhE_K-eCvYt\",\n+        \"colab_type\": \"code\",\n+        \"outputId\": \"89f16e54-e1ce-40e9-f84a-da58bb126620\",\n+        \"colab\": {\n+          \"base_uri\": \"https://localhost:8080/\",\n+          \"height\": 85\n+        }\n+      },\n+      \"source\": [\n+        \"// Define 2 new protocols so we can filter anything in a box and which has mass.\\n\",\n+        \"protocol Weighable {\\n\",\n+        \"    var mass: Mass { get }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"protocol Boxed {\\n\",\n+        \"    var box: Box { get }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the new Laptop and Server struct which have mass and a box.\\n\",\n+        \"struct Laptop: CustomStringConvertible, Boxed, Weighable {\\n\",\n+        \"    var name: String\\n\",\n+        \"    var box: Box\\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    var description: String {\\n\",\n+        \"        return \\\"(\\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct Server: CustomStringConvertible, Boxed, Weighable {\\n\",\n+        \"    var isWorking: Bool\\n\",\n+        \"    var name: String\\n\",\n+        \"    let box: Box\\n\",\n+        \"    let mass: Mass\\n\",\n+        \"\\n\",\n+        \"    var description: String {\\n\",\n+        \"        if isWorking {\\n\",\n+        \"            return \\\"(working \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"        } else {\\n\",\n+        \"            return \\\"(notWorking \\\\(self.name) \\\\(self.box) \\\\(self.mass))\\\"\\n\",\n+        \"        }\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the structs we will use for passing into our filtering function.\\n\",\n+        \"struct BoxFilter<T: Boxed>: DeviceFilterPredicate {\\n\",\n+        \"    var box: Box \\n\",\n+        \"  \\n\",\n+        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n+        \"        return item.box == box\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"struct MassFilter<T: Weighable>: DeviceFilterPredicate {\\n\",\n+        \"    var mass: Mass\\n\",\n+        \"    \\n\",\n+        \"    func shouldKeep(_ item: T) -> Bool {\\n\",\n+        \"        return item.mass == mass\\n\",\n+        \"    }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"// Define the new filter function.\\n\",\n+        \"func filtering<F: DeviceFilterPredicate, T>(\\n\",\n+        \"    _ elements: [T], \\n\",\n+        \"    by filter: F\\n\",\n+        \") -> [T] where T == F.Device {\\n\",\n+        \"    return elements.filter { filter.shouldKeep($0) }\\n\",\n+        \"}\\n\",\n+        \"\\n\",\n+        \"\\n\",\n+        \"// Let's test the function out!\\n\",\n+        \"let servers = [\\n\",\n+        \"    Server(isWorking: true, name: \\\"serverA\\\", box: .small, mass: .heavy),\\n\",\n+        \"    Server(isWorking: false, name: \\\"serverB\\\", box: .medium, mass: .medium),\\n\",\n+        \"    Server(isWorking: true, name: \\\"serverC\\\", box: .large, mass: .light),\\n\",\n+        \"    Server(isWorking: false, name: \\\"serverD\\\", box: .medium, mass: .light),\\n\",\n+        \"    Server(isWorking: true, name: \\\"serverE\\\", box: .small, mass: .heavy)\\n\",\n+        \"]\\n\",\n+        \"\\n\",\n+        \"let products = [\\n\",\n+        \"    Laptop(name: \\\"a\\\", box: .small, mass: .light),\\n\",\n+        \"    Laptop(name: \\\"b\\\", box: .large, mass: .medium),\\n\",\n+        \"    Laptop(name: \\\"c\\\", box: .medium, mass: .heavy),\\n\",\n+        \"    Laptop(name: \\\"d\\\", box: .large, mass: .light)\\n\",\n+        \"]\\n\",\n+        \"\\n\",\n+        \"print(filtering(servers, by: BoxFilter(box: .small)))\\n\",\n+        \"print(filtering(servers, by: MassFilter(mass: .medium)))\\n\",\n+        \"\\n\",\n+        \"print(filtering(products, by: BoxFilter(box: .small)))\\n\",\n+        \"print(filtering(products, by: MassFilter(mass: .medium)))\"\n+      ],\n+      \"execution_count\": 17,\n+      \"outputs\": [\n+        {\n+          \"output_type\": \"stream\",\n+          \"text\": [\n+            \"[(working serverA small heavy), (working serverE small heavy)]\\r\\n\",\n+            \"[(notWorking serverB medium medium)]\\r\\n\",\n+            \"[(a small light)]\\r\\n\",\n+            \"[(b large medium)]\\r\\n\"\n+          ],\n+          \"name\": \"stdout\"\n+        }\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"colab_type\": \"text\",\n+        \"id\": \"-UrRDSaFNCRg\"\n+      },\n+      \"source\": [\n+        \"We have now been able to filter an array by not only any property of a specific `struct`, but also be able to filter any struct which has that property!\"\n+      ]\n+    },\n+    {\n+      \"cell_type\": \"markdown\",\n+      \"metadata\": {\n+        \"id\": \"6g3pPZIuMvPu\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"source\": [\n+        \"# Tips for good API design\\n\",\n+        \"***This section was taken from the [WWDC 2019: Modern Swift API Design](https://developer.apple.com/videos/play/wwdc2019/415/) talk.***\\n\",\n+        \"\\n\",\n+        \"Now that you understand how protocols behave, it's best to now go over when you should use protocols. As powerful as protocols can be, it's not always the best idea to dive in and immediately start with protocols.\\n\",\n+        \"\\n\",\n+        \"* Start with concrete use cases.\\n\",\n+        \"    * First explore the use case with concrete types and understand what code it is you want to share and find is being repeated. Then, factor that shared code out with generics. It might mean to create new protocols. Discover a need for generic code.\\n\",\n+        \"* Consider composing new protocols from existing protocols defined in the standard library. Refer to the following [Apple documentation](https://developer.apple.com/documentation/swift/adopting_common_protocols) for a good example of this.\\n\",\n+        \"* Instead of a generic protocol, consider defining a generic type instead.\\n\",\n+        \"\\n\",\n+        \"## Example: defining a custom vector type\\n\",\n+        \"Let's say we want to define a `GeometricVector` protocol on floating-point numbers to use in some geometry app we are making which defines 3 important vector operations:\\n\",\n+        \"\\n\",\n+        \"```swift\\n\",\n+        \"protocol GeometricVector where Scalar: FloatingPoint {\\n\",\n+        \"    associatedtype Scalar\\n\",\n+        \"    static func dot(_ a: Self, _ b: Self) -> Scalar\\n\",\n+        \"    var length: Scalar { get }\\n\",\n+        \"    func distance(to other: Self) -> Scalar\\n\",\n+        \"}\\n\",\n+        \"```\\n\",\n+        \"\\n\",\n+        \"Let's say we want to store the dimensions of the vector, which the `SIMD` protocol can help us with, so we will make our new type refine the `SIMD` protocol. `SIMD` vectors can be thought of as fixed size vectors that are very fast when you use them to perform vector operations:\\n\",\n+        \"\\n\",\n+        \"```swift\\n\",\n+        \"protocol GeometricVector: SIMD where Scalar: FloatingPoint {\\n\",",
        "comment_created_at": "2019-08-03T08:09:16+00:00",
        "comment_author": "rxwei",
        "comment_body": "Move the `Scalar` constraint to the associated type declaration as well.",
        "pr_file_module": null
      }
    ]
  }
]