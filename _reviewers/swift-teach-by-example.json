[
  {
    "discussion_id": "456451995",
    "pr_number": 502,
    "pr_file": "notebooks/value_semantics/01_value_semantics_in_swift.ipynb",
    "created_at": "2020-07-17T13:45:22+00:00",
    "commented_code": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Swift & Value Semantics\\n\",\n    \"\\n\",\n    \"This notebook walks through a few small examples to get a feel for consuming and producing value-semantic APIs (in the small).\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Unary functions\\n\",\n    \"\\n\",\n    \"We begin with two functions that are approximately equal to increment an integer by `1`.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 1,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"func foo1(_ x: Int) -> Int {\\n\",\n    \"    return x + 1\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 2,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"func foo2(_ x: inout Int) {\\n\",\n    \"    x += 1\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"Note: `inout` should be thought of as _semantically_ \\\"copy-in-copy-out\\\", but is implemented more efficiently.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"1\\r\\n\",\n      \"2\\r\\n\",\n      \"3\\r\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"var x = 1\\n\",\n    \"// We now demonstrate their usage\\n\",\n    \"print(x)\\n\",\n    \"x = foo1(x)\\n\",\n    \"print(x)\\n\",\n    \"foo2(&x)  // The & helps you see where mutations are happening!\\n\",\n    \"print(x)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 4,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"// Of course, you can make an immutable variable, which will (as expected) not be allowed to mutate.\\n\",\n    \"let y = 0\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 5,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"ename\": \"\",\n     \"evalue\": \"\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"error: <Cell 5>:1:1: error: cannot assign to value: 'y' is a 'let' constant\\ny = foo1(y)  // Compile error\\n^\\n\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"y = foo1(y)  // Compile error\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 6,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"ename\": \"\",\n     \"evalue\": \"\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"error: <Cell 6>:1:6: error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\\nfoo2(&y)  // Compile error\\n     ^~\\n\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"foo2(&y)  // Compile error\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Higher-airity functions\\n\",\n    \"\\n\",\n    \"They work exactly as you'd expect.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 7,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"1\\r\\n\",\n      \"2\\r\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"func incrementTwoInts(_ a: inout Int, _ b: inout Int) {\\n\",\n    \"    a += 1\\n\",\n    \"    b += 1\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"var a = 0\\n\",\n    \"var b = 1\\n\",\n    \"incrementTwoInts(&a, &b)\\n\",\n    \"print(a)\\n\",\n    \"print(b)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Mutating Functions\\n\",\n    \"\\n\",\n    \"Object-oriented programming taught us that we often want to group data and operations together. For example, we often like to write:\\n\",\n    \"\\n\",\n    \"```python\\n\",\n    \"myType.method()\\n\",\n    \"```\\n\",\n    \"\\n\",\n    \"instead of\\n\",\n    \"\\n\",\n    \"```python\\n\",\n    \"top_level_function(myType)\\n\",\n    \"```\\n\",\n    \"\\n\",\n    \"The extension for `inout` to \\\"methods\\\" is spelled `mutating`.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 8,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"struct Foo {\\n\",\n    \"    var x: Int = 0\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 9,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"extension Foo {\\n\",\n    \"    mutating func incrementByOne() {\\n\",\n    \"        x += 1\\n\",\n    \"    }\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 10,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"Foo(x: 0)\\r\\n\",\n      \"Foo(x: 1)\\r\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"func testFunction() {\\n\",\n    \"    var f = Foo()\\n\",\n    \"    print(f)\\n\",\n    \"    f.incrementByOne()\\n\",\n    \"    print(f)\\n\",\n    \"}\\n\",\n    \"testFunction()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"Naturally, mutating functions can't be called on immutable values.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 11,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"ename\": \"\",\n     \"evalue\": \"\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"error: <Cell 11>:4:7: error: cannot use mutating member on immutable value: 'f' is a 'let' constant\\n    f.incrementByOne()  // Compile error\\n    ~ ^\\n\\n<Cell 11>:2:5: note: change 'let' to 'var' to make it mutable\\n    let f = Foo()\\n    ^~~\\n    var\\n\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"func testFunc2() {\\n\",\n    \"    let f = Foo()\\n\",\n    \"    print(f)\\n\",\n    \"    f.incrementByOne()  // Compile error\\n\",\n    \"}\\n\",\n    \"testFunc2()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"Mutating functions are convenient in a variety of circumstances. For example, when using an iterator.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 12,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"Optional(0)\\r\\n\",\n      \"Optional(1)\\r\\n\",\n      \"Optional(4)\\r\\n\",\n      \"Optional(8)\\r\\n\",\n      \"Optional(9)\\r\\n\",\n      \"nil\\r\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"// Silly implementation to skip 2 values\\n\",\n    \"func skip2<Itr: IteratorProtocol>(_ itr: inout Itr) {\\n\",\n    \"    _ = itr.next()\\n\",\n    \"    _ = itr.next()\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"extension IteratorProtocol {\\n\",\n    \"    // Silly implementation to skip 3 values.\\n\",\n    \"    mutating func skip3() {\\n\",\n    \"        skip2(&self)\\n\",\n    \"        _ = next()\\n\",\n    \"    }\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"func doSomeIteration() {\\n\",\n    \"    let r = 0...9  // Int's from 0 to 9, inclusive.\\n\",\n    \"    var itr = r.makeIterator()\\n\",\n    \"    print(itr.next())\\n\",\n    \"    print(itr.next())\\n\",\n    \"    skip2(&itr)\\n\",\n    \"    print(itr.next())\\n\",\n    \"    itr.skip3()\\n\",\n    \"    print(itr.next())\\n\",\n    \"    print(itr.next())\\n\",\n    \"    print(itr.next())  // End of sequence\\n\",\n    \"}\\n\",\n    \"doSomeIteration()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Compositions\\n\",\n    \"\\n\",\n    \"Value semantics composes exactly as you'd expect, and continue to maintain the efficiency of in-place operations without allowing spooky-action-at-a-distance.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 13,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"// Declare another struct composed of two additional value-semantic types.\\n\",\n    \"struct Bar {\\n\",\n    \"    var f: Foo\\n\",\n    \"    var y: Int\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 14,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"extension Bar {\\n\",\n    \"    init() {\\n\",\n    \"        self.init(f: Foo(), y: 0)\\n\",\n    \"    }\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 15,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"extension Bar {\\n\",\n    \"    mutating func baz() {\\n\",\n    \"        f.incrementByOne()\\n\",\n    \"        y += 1\\n\",\n    \"    }\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 16,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"extension Bar: CustomStringConvertible {\\n\",\n    \"    public var description: String {\\n\",\n    \"        \\\"Bar(f: \\\\(f), y: \\\\(y))\\\"\\n\",\n    \"    }\\n\",\n    \"}\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 17,\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"b: Bar(f: Foo(x: 0), y: 0)\\r\\n\",\n      \"b: Bar(f: Foo(x: 1), y: 1) (post-baz())\\r\\n\",\n      \"c: Bar(f: Foo(x: 1), y: 1) (create copy)\\r\\n\",\n      \"b: Bar(f: Foo(x: 1), y: 1) (should be equivalent to above)\\r\\n\",\n      \"b: Bar(f: Foo(x: 2), y: 1) (f should be incremented)\\r\\n\",\n      \"c: Bar(f: Foo(x: 1), y: 1) (should be the same as original c value)\\r\\n\",\n      \"b: Bar(f: Foo(x: 3), y: 2) (more changes)\\r\\n\",\n      \"c: Bar(f: Foo(x: 1), y: 1) (more sames)\\r\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"func testFunc3() {\\n\",\n    \"    var b = Bar()\\n\",\n    \"    print(\\\"b: \\\\(b)\\\")\\n\",\n    \"    b.baz()\\n\",\n    \"    print(\\\"b: \\\\(b) (post-baz())\\\")\\n\",\n    \"    let c = b\\n\",\n    \"    print(\\\"c: \\\\(c) (create copy)\\\")\\n\",\n    \"    print(\\\"b: \\\\(b) (should be equivalent to above)\\\")\\n\",\n    \"    b.f.incrementByOne()\\n\",\n    \"    print(\\\"b: \\\\(b) (f should be incremented)\\\")\\n\",\n    \"    print(\\\"c: \\\\(c) (should be the same as original c value)\\\")\\n\",\n    \"    b.baz()\\n\",\n    \"    print(\\\"b: \\\\(b) (more changes)\\\")\\n\",\n    \"    print(\\\"c: \\\\(c) (more sames)\\\")\\n\",\n    \"//     c.baz() // Compile error\\n\",\n    \"//     c.f.incrementByOne()  // Also compile error\\n\",\n    \"}\\n\",\n    \"testFunc3()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Swift's non-obvious properties\\n\",\n    \"\\n\",\n    \"I've collected a few nice features of Swift that aren't apparent by reading [the language guide](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html).\\n\",\n    \"\\n\",\n    \"Said another way, these properties of Swift enable high performance execution without sacrificing value semantics.\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Early dropping of references\\n\",\n    \"\\n\",\n    \"Swift does not have a defined point of destruction for local variables, and thus the compiler is free to destroy variables early. Swift doesn't specify the memory layout of a local stack frame, which allows for a variety of optimizations, such as hoisting values to registers or tearing them apart. Below are a few code examples of this.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 18,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"/// An Int, but implemented using the same lazy copy-on-write techniques as\\n\",\n    \"/// arrays (and Tensors) for demonstration purposes (makes copies explicit).\\n\",\n    \"public struct CoWInt {\\n\",",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "456451995",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 502,
        "pr_file": "notebooks/value_semantics/01_value_semantics_in_swift.ipynb",
        "discussion_id": "456451995",
        "commented_code": "@@ -0,0 +1,949 @@\n+{\n+ \"cells\": [\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"# Swift & Value Semantics\\n\",\n+    \"\\n\",\n+    \"This notebook walks through a few small examples to get a feel for consuming and producing value-semantic APIs (in the small).\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Unary functions\\n\",\n+    \"\\n\",\n+    \"We begin with two functions that are approximately equal to increment an integer by `1`.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 1,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"func foo1(_ x: Int) -> Int {\\n\",\n+    \"    return x + 1\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 2,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"func foo2(_ x: inout Int) {\\n\",\n+    \"    x += 1\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"Note: `inout` should be thought of as _semantically_ \\\"copy-in-copy-out\\\", but is implemented more efficiently.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 3,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"1\\r\\n\",\n+      \"2\\r\\n\",\n+      \"3\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"var x = 1\\n\",\n+    \"// We now demonstrate their usage\\n\",\n+    \"print(x)\\n\",\n+    \"x = foo1(x)\\n\",\n+    \"print(x)\\n\",\n+    \"foo2(&x)  // The & helps you see where mutations are happening!\\n\",\n+    \"print(x)\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 4,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"// Of course, you can make an immutable variable, which will (as expected) not be allowed to mutate.\\n\",\n+    \"let y = 0\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 5,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"ename\": \"\",\n+     \"evalue\": \"\",\n+     \"output_type\": \"error\",\n+     \"traceback\": [\n+      \"error: <Cell 5>:1:1: error: cannot assign to value: 'y' is a 'let' constant\\ny = foo1(y)  // Compile error\\n^\\n\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"y = foo1(y)  // Compile error\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 6,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"ename\": \"\",\n+     \"evalue\": \"\",\n+     \"output_type\": \"error\",\n+     \"traceback\": [\n+      \"error: <Cell 6>:1:6: error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\\nfoo2(&y)  // Compile error\\n     ^~\\n\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"foo2(&y)  // Compile error\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Higher-airity functions\\n\",\n+    \"\\n\",\n+    \"They work exactly as you'd expect.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 7,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"1\\r\\n\",\n+      \"2\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func incrementTwoInts(_ a: inout Int, _ b: inout Int) {\\n\",\n+    \"    a += 1\\n\",\n+    \"    b += 1\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"var a = 0\\n\",\n+    \"var b = 1\\n\",\n+    \"incrementTwoInts(&a, &b)\\n\",\n+    \"print(a)\\n\",\n+    \"print(b)\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Mutating Functions\\n\",\n+    \"\\n\",\n+    \"Object-oriented programming taught us that we often want to group data and operations together. For example, we often like to write:\\n\",\n+    \"\\n\",\n+    \"```python\\n\",\n+    \"myType.method()\\n\",\n+    \"```\\n\",\n+    \"\\n\",\n+    \"instead of\\n\",\n+    \"\\n\",\n+    \"```python\\n\",\n+    \"top_level_function(myType)\\n\",\n+    \"```\\n\",\n+    \"\\n\",\n+    \"The extension for `inout` to \\\"methods\\\" is spelled `mutating`.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 8,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"struct Foo {\\n\",\n+    \"    var x: Int = 0\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 9,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Foo {\\n\",\n+    \"    mutating func incrementByOne() {\\n\",\n+    \"        x += 1\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 10,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"Foo(x: 0)\\r\\n\",\n+      \"Foo(x: 1)\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func testFunction() {\\n\",\n+    \"    var f = Foo()\\n\",\n+    \"    print(f)\\n\",\n+    \"    f.incrementByOne()\\n\",\n+    \"    print(f)\\n\",\n+    \"}\\n\",\n+    \"testFunction()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"Naturally, mutating functions can't be called on immutable values.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 11,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"ename\": \"\",\n+     \"evalue\": \"\",\n+     \"output_type\": \"error\",\n+     \"traceback\": [\n+      \"error: <Cell 11>:4:7: error: cannot use mutating member on immutable value: 'f' is a 'let' constant\\n    f.incrementByOne()  // Compile error\\n    ~ ^\\n\\n<Cell 11>:2:5: note: change 'let' to 'var' to make it mutable\\n    let f = Foo()\\n    ^~~\\n    var\\n\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func testFunc2() {\\n\",\n+    \"    let f = Foo()\\n\",\n+    \"    print(f)\\n\",\n+    \"    f.incrementByOne()  // Compile error\\n\",\n+    \"}\\n\",\n+    \"testFunc2()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"Mutating functions are convenient in a variety of circumstances. For example, when using an iterator.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 12,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"Optional(0)\\r\\n\",\n+      \"Optional(1)\\r\\n\",\n+      \"Optional(4)\\r\\n\",\n+      \"Optional(8)\\r\\n\",\n+      \"Optional(9)\\r\\n\",\n+      \"nil\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"// Silly implementation to skip 2 values\\n\",\n+    \"func skip2<Itr: IteratorProtocol>(_ itr: inout Itr) {\\n\",\n+    \"    _ = itr.next()\\n\",\n+    \"    _ = itr.next()\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"extension IteratorProtocol {\\n\",\n+    \"    // Silly implementation to skip 3 values.\\n\",\n+    \"    mutating func skip3() {\\n\",\n+    \"        skip2(&self)\\n\",\n+    \"        _ = next()\\n\",\n+    \"    }\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"func doSomeIteration() {\\n\",\n+    \"    let r = 0...9  // Int's from 0 to 9, inclusive.\\n\",\n+    \"    var itr = r.makeIterator()\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    skip2(&itr)\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    itr.skip3()\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    print(itr.next())  // End of sequence\\n\",\n+    \"}\\n\",\n+    \"doSomeIteration()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Compositions\\n\",\n+    \"\\n\",\n+    \"Value semantics composes exactly as you'd expect, and continue to maintain the efficiency of in-place operations without allowing spooky-action-at-a-distance.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 13,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"// Declare another struct composed of two additional value-semantic types.\\n\",\n+    \"struct Bar {\\n\",\n+    \"    var f: Foo\\n\",\n+    \"    var y: Int\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 14,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Bar {\\n\",\n+    \"    init() {\\n\",\n+    \"        self.init(f: Foo(), y: 0)\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 15,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Bar {\\n\",\n+    \"    mutating func baz() {\\n\",\n+    \"        f.incrementByOne()\\n\",\n+    \"        y += 1\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 16,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Bar: CustomStringConvertible {\\n\",\n+    \"    public var description: String {\\n\",\n+    \"        \\\"Bar(f: \\\\(f), y: \\\\(y))\\\"\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 17,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"b: Bar(f: Foo(x: 0), y: 0)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 1), y: 1) (post-baz())\\r\\n\",\n+      \"c: Bar(f: Foo(x: 1), y: 1) (create copy)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 1), y: 1) (should be equivalent to above)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 2), y: 1) (f should be incremented)\\r\\n\",\n+      \"c: Bar(f: Foo(x: 1), y: 1) (should be the same as original c value)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 3), y: 2) (more changes)\\r\\n\",\n+      \"c: Bar(f: Foo(x: 1), y: 1) (more sames)\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func testFunc3() {\\n\",\n+    \"    var b = Bar()\\n\",\n+    \"    print(\\\"b: \\\\(b)\\\")\\n\",\n+    \"    b.baz()\\n\",\n+    \"    print(\\\"b: \\\\(b) (post-baz())\\\")\\n\",\n+    \"    let c = b\\n\",\n+    \"    print(\\\"c: \\\\(c) (create copy)\\\")\\n\",\n+    \"    print(\\\"b: \\\\(b) (should be equivalent to above)\\\")\\n\",\n+    \"    b.f.incrementByOne()\\n\",\n+    \"    print(\\\"b: \\\\(b) (f should be incremented)\\\")\\n\",\n+    \"    print(\\\"c: \\\\(c) (should be the same as original c value)\\\")\\n\",\n+    \"    b.baz()\\n\",\n+    \"    print(\\\"b: \\\\(b) (more changes)\\\")\\n\",\n+    \"    print(\\\"c: \\\\(c) (more sames)\\\")\\n\",\n+    \"//     c.baz() // Compile error\\n\",\n+    \"//     c.f.incrementByOne()  // Also compile error\\n\",\n+    \"}\\n\",\n+    \"testFunc3()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"# Swift's non-obvious properties\\n\",\n+    \"\\n\",\n+    \"I've collected a few nice features of Swift that aren't apparent by reading [the language guide](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html).\\n\",\n+    \"\\n\",\n+    \"Said another way, these properties of Swift enable high performance execution without sacrificing value semantics.\\n\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Early dropping of references\\n\",\n+    \"\\n\",\n+    \"Swift does not have a defined point of destruction for local variables, and thus the compiler is free to destroy variables early. Swift doesn't specify the memory layout of a local stack frame, which allows for a variety of optimizations, such as hoisting values to registers or tearing them apart. Below are a few code examples of this.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 18,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"/// An Int, but implemented using the same lazy copy-on-write techniques as\\n\",\n+    \"/// arrays (and Tensors) for demonstration purposes (makes copies explicit).\\n\",\n+    \"public struct CoWInt {\\n\",",
        "comment_created_at": "2020-07-17T13:45:22+00:00",
        "comment_author": "dabrahams",
        "comment_body": "IMO this example isn't illustrating anything about exploding values/local stack frames as claimed above, and keeping the copy count in the instance makes for a complex example that's hard for users to analyze.  We should discuss how to improve this part.\r\n\r\nOne idea: maybe it would be better simply to have `CoWInt` print a message when it makes a copy",
        "pr_file_module": null
      },
      {
        "comment_id": "457511749",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 502,
        "pr_file": "notebooks/value_semantics/01_value_semantics_in_swift.ipynb",
        "discussion_id": "456451995",
        "commented_code": "@@ -0,0 +1,949 @@\n+{\n+ \"cells\": [\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"# Swift & Value Semantics\\n\",\n+    \"\\n\",\n+    \"This notebook walks through a few small examples to get a feel for consuming and producing value-semantic APIs (in the small).\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Unary functions\\n\",\n+    \"\\n\",\n+    \"We begin with two functions that are approximately equal to increment an integer by `1`.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 1,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"func foo1(_ x: Int) -> Int {\\n\",\n+    \"    return x + 1\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 2,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"func foo2(_ x: inout Int) {\\n\",\n+    \"    x += 1\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"Note: `inout` should be thought of as _semantically_ \\\"copy-in-copy-out\\\", but is implemented more efficiently.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 3,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"1\\r\\n\",\n+      \"2\\r\\n\",\n+      \"3\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"var x = 1\\n\",\n+    \"// We now demonstrate their usage\\n\",\n+    \"print(x)\\n\",\n+    \"x = foo1(x)\\n\",\n+    \"print(x)\\n\",\n+    \"foo2(&x)  // The & helps you see where mutations are happening!\\n\",\n+    \"print(x)\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 4,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"// Of course, you can make an immutable variable, which will (as expected) not be allowed to mutate.\\n\",\n+    \"let y = 0\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 5,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"ename\": \"\",\n+     \"evalue\": \"\",\n+     \"output_type\": \"error\",\n+     \"traceback\": [\n+      \"error: <Cell 5>:1:1: error: cannot assign to value: 'y' is a 'let' constant\\ny = foo1(y)  // Compile error\\n^\\n\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"y = foo1(y)  // Compile error\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 6,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"ename\": \"\",\n+     \"evalue\": \"\",\n+     \"output_type\": \"error\",\n+     \"traceback\": [\n+      \"error: <Cell 6>:1:6: error: cannot pass immutable value as inout argument: 'y' is a 'let' constant\\nfoo2(&y)  // Compile error\\n     ^~\\n\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"foo2(&y)  // Compile error\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Higher-airity functions\\n\",\n+    \"\\n\",\n+    \"They work exactly as you'd expect.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 7,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"1\\r\\n\",\n+      \"2\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func incrementTwoInts(_ a: inout Int, _ b: inout Int) {\\n\",\n+    \"    a += 1\\n\",\n+    \"    b += 1\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"var a = 0\\n\",\n+    \"var b = 1\\n\",\n+    \"incrementTwoInts(&a, &b)\\n\",\n+    \"print(a)\\n\",\n+    \"print(b)\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Mutating Functions\\n\",\n+    \"\\n\",\n+    \"Object-oriented programming taught us that we often want to group data and operations together. For example, we often like to write:\\n\",\n+    \"\\n\",\n+    \"```python\\n\",\n+    \"myType.method()\\n\",\n+    \"```\\n\",\n+    \"\\n\",\n+    \"instead of\\n\",\n+    \"\\n\",\n+    \"```python\\n\",\n+    \"top_level_function(myType)\\n\",\n+    \"```\\n\",\n+    \"\\n\",\n+    \"The extension for `inout` to \\\"methods\\\" is spelled `mutating`.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 8,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"struct Foo {\\n\",\n+    \"    var x: Int = 0\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 9,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Foo {\\n\",\n+    \"    mutating func incrementByOne() {\\n\",\n+    \"        x += 1\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 10,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"Foo(x: 0)\\r\\n\",\n+      \"Foo(x: 1)\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func testFunction() {\\n\",\n+    \"    var f = Foo()\\n\",\n+    \"    print(f)\\n\",\n+    \"    f.incrementByOne()\\n\",\n+    \"    print(f)\\n\",\n+    \"}\\n\",\n+    \"testFunction()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"Naturally, mutating functions can't be called on immutable values.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 11,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"ename\": \"\",\n+     \"evalue\": \"\",\n+     \"output_type\": \"error\",\n+     \"traceback\": [\n+      \"error: <Cell 11>:4:7: error: cannot use mutating member on immutable value: 'f' is a 'let' constant\\n    f.incrementByOne()  // Compile error\\n    ~ ^\\n\\n<Cell 11>:2:5: note: change 'let' to 'var' to make it mutable\\n    let f = Foo()\\n    ^~~\\n    var\\n\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func testFunc2() {\\n\",\n+    \"    let f = Foo()\\n\",\n+    \"    print(f)\\n\",\n+    \"    f.incrementByOne()  // Compile error\\n\",\n+    \"}\\n\",\n+    \"testFunc2()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"Mutating functions are convenient in a variety of circumstances. For example, when using an iterator.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 12,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"Optional(0)\\r\\n\",\n+      \"Optional(1)\\r\\n\",\n+      \"Optional(4)\\r\\n\",\n+      \"Optional(8)\\r\\n\",\n+      \"Optional(9)\\r\\n\",\n+      \"nil\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"// Silly implementation to skip 2 values\\n\",\n+    \"func skip2<Itr: IteratorProtocol>(_ itr: inout Itr) {\\n\",\n+    \"    _ = itr.next()\\n\",\n+    \"    _ = itr.next()\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"extension IteratorProtocol {\\n\",\n+    \"    // Silly implementation to skip 3 values.\\n\",\n+    \"    mutating func skip3() {\\n\",\n+    \"        skip2(&self)\\n\",\n+    \"        _ = next()\\n\",\n+    \"    }\\n\",\n+    \"}\\n\",\n+    \"\\n\",\n+    \"func doSomeIteration() {\\n\",\n+    \"    let r = 0...9  // Int's from 0 to 9, inclusive.\\n\",\n+    \"    var itr = r.makeIterator()\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    skip2(&itr)\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    itr.skip3()\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    print(itr.next())\\n\",\n+    \"    print(itr.next())  // End of sequence\\n\",\n+    \"}\\n\",\n+    \"doSomeIteration()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Compositions\\n\",\n+    \"\\n\",\n+    \"Value semantics composes exactly as you'd expect, and continue to maintain the efficiency of in-place operations without allowing spooky-action-at-a-distance.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 13,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"// Declare another struct composed of two additional value-semantic types.\\n\",\n+    \"struct Bar {\\n\",\n+    \"    var f: Foo\\n\",\n+    \"    var y: Int\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 14,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Bar {\\n\",\n+    \"    init() {\\n\",\n+    \"        self.init(f: Foo(), y: 0)\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 15,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Bar {\\n\",\n+    \"    mutating func baz() {\\n\",\n+    \"        f.incrementByOne()\\n\",\n+    \"        y += 1\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 16,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"extension Bar: CustomStringConvertible {\\n\",\n+    \"    public var description: String {\\n\",\n+    \"        \\\"Bar(f: \\\\(f), y: \\\\(y))\\\"\\n\",\n+    \"    }\\n\",\n+    \"}\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 17,\n+   \"metadata\": {},\n+   \"outputs\": [\n+    {\n+     \"name\": \"stdout\",\n+     \"output_type\": \"stream\",\n+     \"text\": [\n+      \"b: Bar(f: Foo(x: 0), y: 0)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 1), y: 1) (post-baz())\\r\\n\",\n+      \"c: Bar(f: Foo(x: 1), y: 1) (create copy)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 1), y: 1) (should be equivalent to above)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 2), y: 1) (f should be incremented)\\r\\n\",\n+      \"c: Bar(f: Foo(x: 1), y: 1) (should be the same as original c value)\\r\\n\",\n+      \"b: Bar(f: Foo(x: 3), y: 2) (more changes)\\r\\n\",\n+      \"c: Bar(f: Foo(x: 1), y: 1) (more sames)\\r\\n\"\n+     ]\n+    }\n+   ],\n+   \"source\": [\n+    \"func testFunc3() {\\n\",\n+    \"    var b = Bar()\\n\",\n+    \"    print(\\\"b: \\\\(b)\\\")\\n\",\n+    \"    b.baz()\\n\",\n+    \"    print(\\\"b: \\\\(b) (post-baz())\\\")\\n\",\n+    \"    let c = b\\n\",\n+    \"    print(\\\"c: \\\\(c) (create copy)\\\")\\n\",\n+    \"    print(\\\"b: \\\\(b) (should be equivalent to above)\\\")\\n\",\n+    \"    b.f.incrementByOne()\\n\",\n+    \"    print(\\\"b: \\\\(b) (f should be incremented)\\\")\\n\",\n+    \"    print(\\\"c: \\\\(c) (should be the same as original c value)\\\")\\n\",\n+    \"    b.baz()\\n\",\n+    \"    print(\\\"b: \\\\(b) (more changes)\\\")\\n\",\n+    \"    print(\\\"c: \\\\(c) (more sames)\\\")\\n\",\n+    \"//     c.baz() // Compile error\\n\",\n+    \"//     c.f.incrementByOne()  // Also compile error\\n\",\n+    \"}\\n\",\n+    \"testFunc3()\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"# Swift's non-obvious properties\\n\",\n+    \"\\n\",\n+    \"I've collected a few nice features of Swift that aren't apparent by reading [the language guide](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html).\\n\",\n+    \"\\n\",\n+    \"Said another way, these properties of Swift enable high performance execution without sacrificing value semantics.\\n\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"## Early dropping of references\\n\",\n+    \"\\n\",\n+    \"Swift does not have a defined point of destruction for local variables, and thus the compiler is free to destroy variables early. Swift doesn't specify the memory layout of a local stack frame, which allows for a variety of optimizations, such as hoisting values to registers or tearing them apart. Below are a few code examples of this.\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": 18,\n+   \"metadata\": {},\n+   \"outputs\": [],\n+   \"source\": [\n+    \"/// An Int, but implemented using the same lazy copy-on-write techniques as\\n\",\n+    \"/// arrays (and Tensors) for demonstration purposes (makes copies explicit).\\n\",\n+    \"public struct CoWInt {\\n\",",
        "comment_created_at": "2020-07-20T15:48:37+00:00",
        "comment_author": "saeta",
        "comment_body": "I think that would be a good improvement.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "281229684",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-05-06T15:14:34+00:00",
    "commented_code": "{",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "281229684",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "281229684",
        "commented_code": "@@ -0,0 +1,1141 @@\n+{",
        "comment_created_at": "2019-05-06T15:14:34+00:00",
        "comment_author": "saeta",
        "comment_body": "<p>This section is set up as a negative. (Basically, we are telling the reader that what they know and love is wrong.) Is there a way we can take the ideas you have in this section, and make them positive? Maybe a narrative arc along the lines of:</p><ul><li>Swift has value types.</li><li>What are value types?</li><li>Why are value types awesome?</li></ul><p>And then include these advantages in that section.</p><p><br></p><p>Does that make sense?</p>\n\n _Reply via <a href='https://app.reviewnb.com/tensorflow/swift/pull/187/discussion/'>ReviewNB</a>_ <div id='ReviewNBCommentContext-DoNotDelete' style='display:none' data-state='OPEN' data-cellIndex='4'/>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "281268207",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-05-06T16:55:47+00:00",
    "commented_code": "{",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "281268207",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "281268207",
        "commented_code": "@@ -0,0 +1,1141 @@\n+{",
        "comment_created_at": "2019-05-06T16:55:47+00:00",
        "comment_author": "burmako",
        "comment_body": "<p>Perhaps this tutorial can introduce protocols without starting with shortcomings in alternative approaches? Given that OOP may mean different things for different people and different languages, this may invite controversy which I think can be avoided. An alternative to the current wording would be skipping this section altogether, explaining how protocols work on compelling examples and then discussing pros and cons in comparison with designs that don't involve protocols.</p>\n\n _Reply via <a href='https://app.reviewnb.com/tensorflow/swift/pull/187/discussion/'>ReviewNB</a>_ <div id='ReviewNBCommentContext-DoNotDelete' style='display:none' data-state='OPEN' data-cellIndex='4'/>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "281268211",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-05-06T16:55:47+00:00",
    "commented_code": "{",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "281268211",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "281268211",
        "commented_code": "@@ -0,0 +1,1141 @@\n+{",
        "comment_created_at": "2019-05-06T16:55:47+00:00",
        "comment_author": "burmako",
        "comment_body": "<p>Similarly to the previous section, I think that the potential controversy of comparing Swift with everyone's favorite languages can be avoided by saying something like \"In addition to classes which have reference semantics, Swift supports enums and structs that are passed by value. Enums and structs support many features provided by classes, albeit with a few restrictions. Let's take a look\".</p><p><br></p><p>I believe that Swift's features are deep enough and useful enough to stand on their own, without necessarily referring to alternatives which are supposedly doing worse in some regards. The latter may make the message more powerful, but it also invites further questions and imposes an additional burden of proof, which both make the task of writing more complicated.</p>\n\n _Reply via <a href='https://app.reviewnb.com/tensorflow/swift/pull/187/discussion/'>ReviewNB</a>_ <div id='ReviewNBCommentContext-DoNotDelete' style='display:none' data-state='OPEN' data-cellIndex='5'/>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "287050799",
    "pr_number": 187,
    "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
    "created_at": "2019-05-23T17:21:43+00:00",
    "commented_code": "{",
    "repo_full_name": "tensorflow/swift",
    "discussion_comments": [
      {
        "comment_id": "287050799",
        "repo_full_name": "tensorflow/swift",
        "pr_number": 187,
        "pr_file": "docs/site/tutorials/protocol_oriented_generics.ipynb",
        "discussion_id": "287050799",
        "commented_code": "@@ -0,0 +1,1108 @@\n+{",
        "comment_created_at": "2019-05-23T17:21:43+00:00",
        "comment_author": "bartchr808",
        "comment_body": "<p><strong>Brennan: </strong></p><blockquote>\"Hmm, this section reads both relatively dry and potentially leaves people getting hung up on Swift limitations (e.g. that C++ doesn't have).&nbsp;</blockquote><blockquote><br></blockquote><blockquote>What do you think about this silly idea: what if you illustrated things by example such that the user themselves comes to the conclusion that subclassing / object orientation is inappropriate for certain situations? You'll definitely have to figure out a great example, but I think showing (not telling) might be more powerful here. Does that make sense?\"</blockquote><p><br></p><p><strong>Bart:</strong></p><blockquote>\"Hmm I'll definitely try figuring something out! My worry is that I may introduce some bias and throw object oriented under the bus, i.e protocol oriented is superior and object oriented sucks, which my previous version of the tutorial sometimes did and Eugene&nbsp;helped correct.\"</blockquote>\n\n _Reply via <a href='https://app.reviewnb.com/tensorflow/swift/pull/187/discussion/'>ReviewNB</a>_ <div id='ReviewNBCommentContext-DoNotDelete' style='display:none' data-state='OPEN' data-cellIndex='4'/>",
        "pr_file_module": null
      }
    ]
  }
]