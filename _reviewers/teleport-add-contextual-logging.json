[
  {
    "discussion_id": "2323773975",
    "pr_number": 58778,
    "pr_file": "lib/service/connect.go",
    "created_at": "2025-09-05T00:02:07+00:00",
    "commented_code": "// client, so it does not make sense to call reconnectToAuthService.\n \t\t\t\treturn nil, trace.BadParameter(\"reconnectToAuthService got a connector with no client, this is a logic error\")\n \t\t\t}\n-\n \t\t\treturn connector, nil\n \t\t} else {\n \t\t\tswitch {\n \t\t\tcase errors.As(connectErr, &invalidVersionErr{}):\n \t\t\t\treturn nil, trace.Wrap(connectErr)\n-\t\t\tcase role == types.RoleNode && strings.Contains(connectErr.Error(), auth.TokenExpiredOrNotFound):\n-\t\t\t\tprocess.logger.ErrorContext(process.ExitContext(), \"Can not join the cluster as node, the token expired or not found. Regenerate the token and try again.\")\n+\t\t\tcase strings.Contains(connectErr.Error(), auth.TokenExpiredOrNotFound):\n+\t\t\t\tprocess.logger.ErrorContext(process.ExitContext(), \"Can not join the cluster, the token is expired or not found. Regenerate the token and try again.\")",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2323773975",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58778,
        "pr_file": "lib/service/connect.go",
        "discussion_id": "2323773975",
        "commented_code": "@@ -91,14 +91,13 @@ func (process *TeleportProcess) reconnectToAuthService(role types.SystemRole) (*\n \t\t\t\t// client, so it does not make sense to call reconnectToAuthService.\n \t\t\t\treturn nil, trace.BadParameter(\"reconnectToAuthService got a connector with no client, this is a logic error\")\n \t\t\t}\n-\n \t\t\treturn connector, nil\n \t\t} else {\n \t\t\tswitch {\n \t\t\tcase errors.As(connectErr, &invalidVersionErr{}):\n \t\t\t\treturn nil, trace.Wrap(connectErr)\n-\t\t\tcase role == types.RoleNode && strings.Contains(connectErr.Error(), auth.TokenExpiredOrNotFound):\n-\t\t\t\tprocess.logger.ErrorContext(process.ExitContext(), \"Can not join the cluster as node, the token expired or not found. Regenerate the token and try again.\")\n+\t\t\tcase strings.Contains(connectErr.Error(), auth.TokenExpiredOrNotFound):\n+\t\t\t\tprocess.logger.ErrorContext(process.ExitContext(), \"Can not join the cluster, the token is expired or not found. Regenerate the token and try again.\")",
        "comment_created_at": "2025-09-05T00:02:07+00:00",
        "comment_author": "nklaassen",
        "comment_body": "not sure why we were only logging this for RoleNode, it should apply to any system role as long as we see the `TokenExpiredOrNotFound` error",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2318956026",
    "pr_number": 58187,
    "pr_file": "lib/srv/uacc/uacc.go",
    "created_at": "2025-09-03T13:18:12+00:00",
    "commented_code": "+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tutmp, err := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif err == nil {\n+\t\tuacc.utmp = utmp\n+\t}\n+\twtmpdb, err := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif err == nil {\n+\t\tuacc.wtmpdb = wtmpdb",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2318956026",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2318956026",
        "commented_code": "@@ -0,0 +1,180 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tutmp, err := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif err == nil {\n+\t\tuacc.utmp = utmp\n+\t}\n+\twtmpdb, err := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif err == nil {\n+\t\tuacc.wtmpdb = wtmpdb",
        "comment_created_at": "2025-09-03T13:18:12+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "What do you think about logging some informational message if both of these errors are not nil? The only indication that users get if things are not working is from the message [here](https://github.com/gravitational/teleport/pull/58187/files#diff-76045a1d6e2c8f7d42000a7065c3c58579e87c33c0efd6f813701a28d970fefdR353) but that won't contain any context on _why_ user accounting is disabled. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2320231208",
    "pr_number": 58187,
    "pr_file": "lib/srv/uacc/uacc.go",
    "created_at": "2025-09-03T21:12:57+00:00",
    "commented_code": "+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2320231208",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2320231208",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
        "comment_created_at": "2025-09-03T21:12:57+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "What do you think about rewriting this to return early on success? Same suggestion for `Close` below.\n```suggestion\n\tvar errors []error\n\tif uacc.utmp != nil {\n\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n\t\t\treturn &Session{\n\t\t\t\tuacc: uacc,\n\t\t\t\tutmpKey: ttyName,\n\t\t\t}, nil\n\t\t}\n\t\t\n\t\terrors = append(errors, err)\n\t}\n\t\n\tif uacc.wtmpdb != nil {\n\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n\t\tif err == nil {\n\t\t\treturn &Session{\n\t\t\t\tuacc: uacc,\n\t\t\t\twtmpdbKey: ttyName,\n\t\t\t}, nil\n\t\t}\n\t\terrors = append(errors, err)\n\t}\n\t\n\treturn nil, trace.NewAggregate(errors...)\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2320507511",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2320231208",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
        "comment_created_at": "2025-09-04T00:08:49+00:00",
        "comment_author": "atburke",
        "comment_body": "In the event that both backends are available, I want us to write to both.",
        "pr_file_module": null
      },
      {
        "comment_id": "2320536968",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2320231208",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
        "comment_created_at": "2025-09-04T00:41:11+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "If wtmpdb exists then shouldn't it be viewed as the source of truth?",
        "pr_file_module": null
      },
      {
        "comment_id": "2322682171",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2320231208",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
        "comment_created_at": "2025-09-04T16:04:26+00:00",
        "comment_author": "atburke",
        "comment_body": "If both exists, wtmpdb was probably installed manually, and I don't think we can guarantee that everything on the system is using it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2322699514",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2320231208",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
        "comment_created_at": "2025-09-04T16:11:12+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "The Ubuntu 24.10 VM I tested this on had all of /var/log/wtmp, /var/log/wtmpx, and wtmpdb - and I didn't install wtmpdb manually \ud83d\ude05 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2322950366",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58187,
        "pr_file": "lib/srv/uacc/uacc.go",
        "discussion_id": "2320231208",
        "commented_code": "@@ -0,0 +1,186 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2023  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+// Package uacc implements user accounting on Linux systems. There are two\n+// supported backends, utmp and wtmpdb. Operations in this package attempt to use\n+// all available backends and succeed if at least one backend succeeds.\n+//\n+// # utmp\n+//\n+// utmp is the classic Unix user accounting system. Current sessions are logged in\n+// the utmp file, session history is logged in the wtmp file, and failed logins are\n+// logged in the btmp file (or their *tmpx counterparts, the file format is\n+// identical on Linux). Teleport writes to the *tmp files via the libc API in\n+// <utmp.h>.\n+//\n+// # wtmpdb\n+//\n+// [wtmpdb] is the Y2038-safe successor to utmp. Session history is logged in the\n+// wtmp.db sqlite database. Teleport writes to wtmpdb with sqlite directly instead\n+// of using libwtmpdb.\n+//\n+// [wtmpdb]: https://github.com/thkukuk/wtmpdb\n+package uacc\n+\n+import (\n+\t\"context\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/gravitational/trace\"\n+)\n+\n+// UserAccountHandler handles user accounting across multiple backends.\n+type UserAccountHandler struct {\n+\tutmp   *UtmpBackend\n+\twtmpdb *WtmpdbBackend\n+}\n+\n+// UaccConfig configures NewUserAccounting.\n+type UaccConfig struct {\n+\t// WtmpdbFile is the path to an alternate wtmpdb database.\n+\tWtmpdbFile string\n+\t// UtmpFile is the path to an alternate utmp file.\n+\tUtmpFile string\n+\t// WtmpFile is the path to an alternate wtmp file.\n+\tWtmpFile string\n+\t// BtmpFile is the path to an alternate btmp file.\n+\tBtmpFile string\n+}\n+\n+// NewUserAccountHandler creates a new UserAccountHandler.\n+func NewUserAccountHandler(cfg UaccConfig) *UserAccountHandler {\n+\tuacc := &UserAccountHandler{}\n+\tctx := context.Background()\n+\tutmp, utmpErr := NewUtmpBackend(cfg.UtmpFile, cfg.WtmpFile, cfg.BtmpFile)\n+\tif utmpErr == nil {\n+\t\tuacc.utmp = utmp\n+\t\tslog.DebugContext(ctx, \"utmp user accounting is active\")\n+\t}\n+\twtmpdb, wtmpdbErr := NewWtmpdbBackend(cfg.WtmpdbFile)\n+\tif wtmpdbErr == nil {\n+\t\tuacc.wtmpdb = wtmpdb\n+\t\tslog.DebugContext(ctx, \"wtmpdb user accounting is active\")\n+\t}\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\tslog.DebugContext(\n+\t\t\tctx, \"no user accounting backends are available, sessions will not be logged locally\",\n+\t\t\t\"utmp_error\", utmpErr, \"wtmpdb_error\", wtmpdbErr,\n+\t\t)\n+\t}\n+\treturn uacc\n+}\n+\n+// Session represents a login session. It must be closed when the session is finished.\n+type Session struct {\n+\tuacc      *UserAccountHandler\n+\tutmpKey   string\n+\twtmpdbKey *int64\n+}\n+\n+// OpenSession opens a new login session. It will succeed if at least one backend succeeds.\n+func (uacc *UserAccountHandler) OpenSession(tty *os.File, username string, remote net.Addr) (*Session, error) {\n+\tif uacc.utmp == nil && uacc.wtmpdb == nil {\n+\t\treturn &Session{}, nil\n+\t}\n+\n+\tloginTime := time.Now()\n+\tttyFullName, err := os.Readlink(tty.Name())\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tttyName := strings.TrimPrefix(ttyFullName, \"/dev/\")\n+\n+\tvar anySucceeded bool\n+\tsession := &Session{\n+\t\tuacc: uacc,\n+\t}\n+\tvar errors []error\n+\tif uacc.utmp != nil {\n+\t\tif err := uacc.utmp.Login(ttyName, username, remote, loginTime); err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.utmpKey = ttyName\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif uacc.wtmpdb != nil {\n+\t\tkey, err := uacc.wtmpdb.Login(ttyName, username, remote, loginTime)\n+\t\tif err == nil {\n+\t\t\tanySucceeded = true\n+\t\t\tsession.wtmpdbKey = &key\n+\t\t} else {\n+\t\t\terrors = append(errors, err)\n+\t\t}\n+\t}\n+\tif !anySucceeded {\n+\t\treturn nil, trace.NewAggregate(errors...)\n+\t}\n+\treturn session, nil",
        "comment_created_at": "2025-09-04T17:41:48+00:00",
        "comment_author": "atburke",
        "comment_body": "I stand corrected! Although if they're being used side-by-side intentionally, I'd guess that there's an expectation that both are being used, so we should keep writing to both.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283431355",
    "pr_number": 57796,
    "pr_file": "lib/srv/db/mysql/handshake.go",
    "created_at": "2025-08-18T20:47:05+00:00",
    "commented_code": "+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mysql\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/go-mysql-org/go-mysql/client\"\n+\t\"github.com/go-mysql-org/go-mysql/mysql\"\n+\t\"github.com/go-mysql-org/go-mysql/server\"\n+\t\"github.com/gravitational/trace\"\n+\n+\t\"github.com/gravitational/teleport/lib/defaults\"\n+\t\"github.com/gravitational/teleport/lib/srv/db/mysql/protocol\"\n+)\n+\n+const (\n+\t// magicProxyReply is sent from proxy to the agent if, and only if, the proxy receives the agent's indication that it would like to handshake.\n+\t// to indicate that the\n+\t// proxy supports a full MySQL handshake and is waiting for the agent to\n+\t// initiate it.\n+\t// TODO(gavin): DELETE IN 22.0.0\n+\tmagicProxyReply = \"ready-for-handshake\"\n+\t// emptyPassword is used as a fake credential because auth is already handled via mTLS.\n+\temptyPassword = \"\"\n+\t// clientNameParamName defines the application name parameter name.\n+\t// This is used to set the session context's user agent.\n+\t//\n+\t// https://dev.mysql.com/doc/refman/8.0/en/performance-schema-connection-attribute-tables.html\n+\tclientNameParamName = \"_client_name\"\n+\t// handshakeModeEnvVar overrides the default MySQL handshake mode for the\n+\t// proxy and/or agent.\n+\t// Only exact string enum values are supported, see [handshakeMode].\n+\thandshakeModeEnvVar = \"TELEPORT_MYSQL_DB_HANDSHAKE_MODE\"\n+)\n+\n+// handshakeMode determines the MySQL handshake behavior of the proxy or agent.\n+type handshakeMode string\n+\n+const (\n+\t// handshakeWhenSupported makes the agent or proxy perform a MySQL handshake\n+\t// only when the other party supports a MySQL handshake. Handshake support\n+\t// is determined via a magic \"OK\" packet value sent by the agent and a\n+\t// corresponding magic proxy reply:\n+\t// +-------------------+                +----------------------+\n+\t// |  Teleport Proxy   |                |  Teleport DB Agent   |\n+\t// +-------------------+                +----------------------+\n+\t//            |                                    |\n+\t//            |--- Connect (reverse tunnel) ------>|\n+\t//            |                                    |\n+\t//            |<----------- OK packet -------------|\n+\t//            |                                    |\n+\t//            |      (If \"magic\" OK packet)        |\n+\t//         +------------------------------------------+\n+\t//         |  |                                    |  |\n+\t//         |  |--- \"magic\" reply ----------------->|  |\n+\t//         |  |                                    |  |\n+\t//         |  |<----- Init MySQL handshake --------|  |\n+\t//         |                                          |\n+\t//         +------------------------------------------+\n+\t// In v20 we can be sure that the proxy will support MySQL handshakes, so\n+\t// the agent can stop sending the OK packet to initiate a handshake and\n+\t// instead initiate a partial handshake with the proxy, dial the real\n+\t// database, and then complete the MySQL handshake with by sending OK.\n+\t// Since the agent will no longer have to send the initial OK packet, we\n+\t// will no longer have to worry about an older proxy telling the real client\n+\t// that the connection is ready without the proxy having completed a\n+\t// MySQL handshake with the agent first.\n+\t// This will allow us to forward client capabilities without mangling\n+\t// connection error propagation to the real client.\n+\thandshakeWhenSupported handshakeMode = \"when_supported\"\n+\t// handshakeAlways makes the agent or proxy unconditionally attempt a MySQL\n+\t// handshake after the proxy dials the agent, without waiting for the magic\n+\t// OK packet / proxy reply.\n+\thandshakeAlways handshakeMode = \"always\"\n+\t// handshakeDisabled disables MySQL handshake on the proxy or agent.\n+\thandshakeDisabled handshakeMode = \"disabled\"\n+)\n+\n+func getHandshakeMode() handshakeMode {\n+\tswitch handshakeMode(os.Getenv(handshakeModeEnvVar)) {\n+\tcase handshakeWhenSupported, \"\":\n+\t\t// the default setting without env var override\n+\t\treturn handshakeWhenSupported\n+\tcase handshakeAlways:\n+\t\treturn handshakeAlways\n+\tdefault:\n+\t\treturn handshakeDisabled\n+\t}\n+}\n+\n+// waitForAgent waits for the agent to indicate to the proxy that the connection\n+// is ready.\n+func waitForAgent(ctx context.Context, mode handshakeMode, serviceConn net.Conn, handshakeOpts ...client.Option) error {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2283431355",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 57796,
        "pr_file": "lib/srv/db/mysql/handshake.go",
        "discussion_id": "2283431355",
        "commented_code": "@@ -0,0 +1,285 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mysql\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/go-mysql-org/go-mysql/client\"\n+\t\"github.com/go-mysql-org/go-mysql/mysql\"\n+\t\"github.com/go-mysql-org/go-mysql/server\"\n+\t\"github.com/gravitational/trace\"\n+\n+\t\"github.com/gravitational/teleport/lib/defaults\"\n+\t\"github.com/gravitational/teleport/lib/srv/db/mysql/protocol\"\n+)\n+\n+const (\n+\t// magicProxyReply is sent from proxy to the agent if, and only if, the proxy receives the agent's indication that it would like to handshake.\n+\t// to indicate that the\n+\t// proxy supports a full MySQL handshake and is waiting for the agent to\n+\t// initiate it.\n+\t// TODO(gavin): DELETE IN 22.0.0\n+\tmagicProxyReply = \"ready-for-handshake\"\n+\t// emptyPassword is used as a fake credential because auth is already handled via mTLS.\n+\temptyPassword = \"\"\n+\t// clientNameParamName defines the application name parameter name.\n+\t// This is used to set the session context's user agent.\n+\t//\n+\t// https://dev.mysql.com/doc/refman/8.0/en/performance-schema-connection-attribute-tables.html\n+\tclientNameParamName = \"_client_name\"\n+\t// handshakeModeEnvVar overrides the default MySQL handshake mode for the\n+\t// proxy and/or agent.\n+\t// Only exact string enum values are supported, see [handshakeMode].\n+\thandshakeModeEnvVar = \"TELEPORT_MYSQL_DB_HANDSHAKE_MODE\"\n+)\n+\n+// handshakeMode determines the MySQL handshake behavior of the proxy or agent.\n+type handshakeMode string\n+\n+const (\n+\t// handshakeWhenSupported makes the agent or proxy perform a MySQL handshake\n+\t// only when the other party supports a MySQL handshake. Handshake support\n+\t// is determined via a magic \"OK\" packet value sent by the agent and a\n+\t// corresponding magic proxy reply:\n+\t// +-------------------+                +----------------------+\n+\t// |  Teleport Proxy   |                |  Teleport DB Agent   |\n+\t// +-------------------+                +----------------------+\n+\t//            |                                    |\n+\t//            |--- Connect (reverse tunnel) ------>|\n+\t//            |                                    |\n+\t//            |<----------- OK packet -------------|\n+\t//            |                                    |\n+\t//            |      (If \"magic\" OK packet)        |\n+\t//         +------------------------------------------+\n+\t//         |  |                                    |  |\n+\t//         |  |--- \"magic\" reply ----------------->|  |\n+\t//         |  |                                    |  |\n+\t//         |  |<----- Init MySQL handshake --------|  |\n+\t//         |                                          |\n+\t//         +------------------------------------------+\n+\t// In v20 we can be sure that the proxy will support MySQL handshakes, so\n+\t// the agent can stop sending the OK packet to initiate a handshake and\n+\t// instead initiate a partial handshake with the proxy, dial the real\n+\t// database, and then complete the MySQL handshake with by sending OK.\n+\t// Since the agent will no longer have to send the initial OK packet, we\n+\t// will no longer have to worry about an older proxy telling the real client\n+\t// that the connection is ready without the proxy having completed a\n+\t// MySQL handshake with the agent first.\n+\t// This will allow us to forward client capabilities without mangling\n+\t// connection error propagation to the real client.\n+\thandshakeWhenSupported handshakeMode = \"when_supported\"\n+\t// handshakeAlways makes the agent or proxy unconditionally attempt a MySQL\n+\t// handshake after the proxy dials the agent, without waiting for the magic\n+\t// OK packet / proxy reply.\n+\thandshakeAlways handshakeMode = \"always\"\n+\t// handshakeDisabled disables MySQL handshake on the proxy or agent.\n+\thandshakeDisabled handshakeMode = \"disabled\"\n+)\n+\n+func getHandshakeMode() handshakeMode {\n+\tswitch handshakeMode(os.Getenv(handshakeModeEnvVar)) {\n+\tcase handshakeWhenSupported, \"\":\n+\t\t// the default setting without env var override\n+\t\treturn handshakeWhenSupported\n+\tcase handshakeAlways:\n+\t\treturn handshakeAlways\n+\tdefault:\n+\t\treturn handshakeDisabled\n+\t}\n+}\n+\n+// waitForAgent waits for the agent to indicate to the proxy that the connection\n+// is ready.\n+func waitForAgent(ctx context.Context, mode handshakeMode, serviceConn net.Conn, handshakeOpts ...client.Option) error {",
        "comment_created_at": "2025-08-18T20:47:05+00:00",
        "comment_author": "greedy52",
        "comment_body": "nit: some debug logs on the handshake flow would be nice. same on agent side.",
        "pr_file_module": null
      },
      {
        "comment_id": "2283601133",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 57796,
        "pr_file": "lib/srv/db/mysql/handshake.go",
        "discussion_id": "2283431355",
        "commented_code": "@@ -0,0 +1,285 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mysql\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"log/slog\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/go-mysql-org/go-mysql/client\"\n+\t\"github.com/go-mysql-org/go-mysql/mysql\"\n+\t\"github.com/go-mysql-org/go-mysql/server\"\n+\t\"github.com/gravitational/trace\"\n+\n+\t\"github.com/gravitational/teleport/lib/defaults\"\n+\t\"github.com/gravitational/teleport/lib/srv/db/mysql/protocol\"\n+)\n+\n+const (\n+\t// magicProxyReply is sent from proxy to the agent if, and only if, the proxy receives the agent's indication that it would like to handshake.\n+\t// to indicate that the\n+\t// proxy supports a full MySQL handshake and is waiting for the agent to\n+\t// initiate it.\n+\t// TODO(gavin): DELETE IN 22.0.0\n+\tmagicProxyReply = \"ready-for-handshake\"\n+\t// emptyPassword is used as a fake credential because auth is already handled via mTLS.\n+\temptyPassword = \"\"\n+\t// clientNameParamName defines the application name parameter name.\n+\t// This is used to set the session context's user agent.\n+\t//\n+\t// https://dev.mysql.com/doc/refman/8.0/en/performance-schema-connection-attribute-tables.html\n+\tclientNameParamName = \"_client_name\"\n+\t// handshakeModeEnvVar overrides the default MySQL handshake mode for the\n+\t// proxy and/or agent.\n+\t// Only exact string enum values are supported, see [handshakeMode].\n+\thandshakeModeEnvVar = \"TELEPORT_MYSQL_DB_HANDSHAKE_MODE\"\n+)\n+\n+// handshakeMode determines the MySQL handshake behavior of the proxy or agent.\n+type handshakeMode string\n+\n+const (\n+\t// handshakeWhenSupported makes the agent or proxy perform a MySQL handshake\n+\t// only when the other party supports a MySQL handshake. Handshake support\n+\t// is determined via a magic \"OK\" packet value sent by the agent and a\n+\t// corresponding magic proxy reply:\n+\t// +-------------------+                +----------------------+\n+\t// |  Teleport Proxy   |                |  Teleport DB Agent   |\n+\t// +-------------------+                +----------------------+\n+\t//            |                                    |\n+\t//            |--- Connect (reverse tunnel) ------>|\n+\t//            |                                    |\n+\t//            |<----------- OK packet -------------|\n+\t//            |                                    |\n+\t//            |      (If \"magic\" OK packet)        |\n+\t//         +------------------------------------------+\n+\t//         |  |                                    |  |\n+\t//         |  |--- \"magic\" reply ----------------->|  |\n+\t//         |  |                                    |  |\n+\t//         |  |<----- Init MySQL handshake --------|  |\n+\t//         |                                          |\n+\t//         +------------------------------------------+\n+\t// In v20 we can be sure that the proxy will support MySQL handshakes, so\n+\t// the agent can stop sending the OK packet to initiate a handshake and\n+\t// instead initiate a partial handshake with the proxy, dial the real\n+\t// database, and then complete the MySQL handshake with by sending OK.\n+\t// Since the agent will no longer have to send the initial OK packet, we\n+\t// will no longer have to worry about an older proxy telling the real client\n+\t// that the connection is ready without the proxy having completed a\n+\t// MySQL handshake with the agent first.\n+\t// This will allow us to forward client capabilities without mangling\n+\t// connection error propagation to the real client.\n+\thandshakeWhenSupported handshakeMode = \"when_supported\"\n+\t// handshakeAlways makes the agent or proxy unconditionally attempt a MySQL\n+\t// handshake after the proxy dials the agent, without waiting for the magic\n+\t// OK packet / proxy reply.\n+\thandshakeAlways handshakeMode = \"always\"\n+\t// handshakeDisabled disables MySQL handshake on the proxy or agent.\n+\thandshakeDisabled handshakeMode = \"disabled\"\n+)\n+\n+func getHandshakeMode() handshakeMode {\n+\tswitch handshakeMode(os.Getenv(handshakeModeEnvVar)) {\n+\tcase handshakeWhenSupported, \"\":\n+\t\t// the default setting without env var override\n+\t\treturn handshakeWhenSupported\n+\tcase handshakeAlways:\n+\t\treturn handshakeAlways\n+\tdefault:\n+\t\treturn handshakeDisabled\n+\t}\n+}\n+\n+// waitForAgent waits for the agent to indicate to the proxy that the connection\n+// is ready.\n+func waitForAgent(ctx context.Context, mode handshakeMode, serviceConn net.Conn, handshakeOpts ...client.Option) error {",
        "comment_created_at": "2025-08-18T22:07:32+00:00",
        "comment_author": "GavinFrazar",
        "comment_body": "good idea, added: a1e3ae673153e38a49b46467e764c43accd64013",
        "pr_file_module": null
      }
    ]
  }
]