[
  {
    "discussion_id": "2308297505",
    "pr_number": 58243,
    "pr_file": "lib/services/presets.go",
    "created_at": "2025-08-28T19:04:06+00:00",
    "commented_code": "return role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2308297505",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-28T19:04:06+00:00",
        "comment_author": "smallinsky",
        "comment_body": "> Improve day zero experience so the end user doesn't have to think about RBAC too much.\r\n\r\nWhy we don't suggest to use the preset `access` role instead ?  https://github.com/gravitational/teleport/blob/master/lib/services/presets.go#L306\r\n\r\n\r\nIt there a way to scope down the AppLabels: `types.Wildcard: []string{types.Wildcard},`  to  MCP apps  based on the appLabel  key: value  ? \r\n\r\nI\u2019m raising this because using AppLabels: types.Wildcard can lead to unintended side effects. For example, the SAML IdP app  is hidden behind the app_label=RBAC, also  the Okta app\u2019s upstream Assignment provisioning.  \r\n\r\nSo the role says `mcp-user` but it unintentionally  grants  like admin permission in Okta (if Okta integration is enabled) and SAML IdP application and other teleport applications. \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2308428861",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-28T20:08:27+00:00",
        "comment_author": "greedy52",
        "comment_body": "the `access` uses traits for many things including the `allow.mcp.tools`, which is the extra that ppl usually miss when setting it up.\r\n\r\nagree that the side effects on non-mcp apps but there is no current way to scope it down based on `app_labels`.\r\n\r\none way i can implement this is to have inject some internal labels for all MCP apps, to be used for `app_labels`. i will have to experiment with them tho. WDYT? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2308444557",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-28T20:17:07+00:00",
        "comment_author": "smallinsky",
        "comment_body": ">  i can implement this is to have inject some internal labels for all MCP apps, to be used for app_labels\r\n\r\nAgree - If we can take this route, it would give clients a much safer and more predictable expectation what `mpc-user` can do within teleport  cluster.  ",
        "pr_file_module": null
      },
      {
        "comment_id": "2310408126",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-29T14:59:19+00:00",
        "comment_author": "greedy52",
        "comment_body": "how about something like this:\r\n[2a54fe5](https://github.com/gravitational/teleport/pull/58243/commits/2a54fe57509852d83d44e9325efd542c76f366b7)",
        "pr_file_module": null
      },
      {
        "comment_id": "2310511224",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-29T15:46:27+00:00",
        "comment_author": "smallinsky",
        "comment_body": "Yes, that looks perfect. I\u2019m just wondering whether we want to apply this to all apps with subKind != \"\", or limit this logic to the MCP app for now.",
        "pr_file_module": null
      },
      {
        "comment_id": "2310537090",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-29T15:58:54+00:00",
        "comment_author": "greedy52",
        "comment_body": "i added the logic for all apps but i only know MCP apps using the subkind field. do you know any other apps that sets subkind?",
        "pr_file_module": null
      },
      {
        "comment_id": "2310875639",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "lib/services/presets.go",
        "discussion_id": "2308297505",
        "commented_code": "@@ -825,6 +825,34 @@ func NewPresetTerraformProviderRole() types.Role {\n \treturn role\n }\n \n+// NewPresetMCPUserRole returns a new pre-defined role for accessing MCP\n+// servers.\n+func NewPresetMCPUserRole() types.Role {\n+\trole := &types.RoleV6{\n+\t\tKind:    types.KindRole,\n+\t\tVersion: types.V8,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName:        teleport.PresetMCPUserRoleName,\n+\t\t\tNamespace:   apidefaults.Namespace,\n+\t\t\tDescription: \"Access to MCP servers\",\n+\t\t\tLabels: map[string]string{\n+\t\t\t\ttypes.TeleportInternalResourceType: types.PresetResource,\n+\t\t\t},\n+\t\t},\n+\t\tSpec: types.RoleSpecV6{\n+\t\t\tAllow: types.RoleConditions{\n+\t\t\t\tAppLabels: map[string]apiutils.Strings{\n+\t\t\t\t\ttypes.Wildcard: []string{types.Wildcard},",
        "comment_created_at": "2025-08-29T18:52:44+00:00",
        "comment_author": "smallinsky",
        "comment_body": "For instance `aws-ic-account`  but this is app created dynamically from  KindAppServer: \r\n<img width=\"1344\" height=\"641\" alt=\"Screenshot 2025-08-29 at 20 50 41\" src=\"https://github.com/user-attachments/assets/7a125780-e8d2-483f-b5c1-4aacd654c8ec\" />\r\n\r\nBut yea, At first glance setting labels based on subkind should not affect anything. \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293136603",
    "pr_number": 58114,
    "pr_file": "lib/auth/auth_with_roles.go",
    "created_at": "2025-08-22T08:56:51+00:00",
    "commented_code": "func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293136603",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-22T08:56:51+00:00",
        "comment_author": "Tener",
        "comment_body": "This looks like a very important piece of code. I think it should be tested on its own (for basic sanity checks), but also validated against the other parts of the RBAC. We should try to answer these questions:\n- is the reconstructed resource a faithful reconstruction? \n- are there any cases in which original resource is not accessible, but reconstructed one is? (or the opposite)\n- can _future_ changes to RBAC invalidate this property? is there any way to make it more resilient?\n\nAll in all, I wonder if a better approach (from consistency perspective, and also future-proof) would be to store the _entire_ resource definition (or the part that impact RBAC; testing would shift here) directly in the event. That would make the reconstruction function much simpler; just pick up the applicable field from the event.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293392504",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-22T10:47:10+00:00",
        "comment_author": "tigrato",
        "comment_body": "> is the reconstructed resource a faithful copy of the original?\r\n\r\nFor RBAC purposes, yes. We take both the dynamic and static labels from the original resource and preserve them as static labels in the reconstructed resource.\r\n\r\n> are there any cases in which original resource is not accessible, but reconstructed one is? (or the opposite)\r\nYes. There are no guarantees that the resource still exists in Teleport. A node may have been decommissioned, renamed, stopped, or gone offline.\r\n\r\nBecause we can\u2019t control what happens in the Teleport cluster, the only reliable option is to reconstruct the resource from the event itself. There\u2019s no alternative. These reconstructed resources are static: they won\u2019t reflect later changes in session creator traits or in the resource\u2019s labels.\r\n\r\n> can future changes to RBAC invalidate this property? is there any way to make it more resilient?\r\n\r\nI don\u2019t think so. For RBAC, only labels matter; most other fields are irrelevant. Duplicating entire resource definitions would add unnecessary overhead and complexity.\r\n\r\nMoreover, keeping full definitions creates long-term compatibility issues. Future resource versions (e.g., `databasev4`, `kubernetesv4`) could make old events impossible to unmarshal cleanly. Labels, however, are stable and sufficient for RBAC, so sticking with them avoids breaking changes.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2293696856",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-22T13:11:11+00:00",
        "comment_author": "Tener",
        "comment_body": ">  Labels, however, are stable and sufficient for RBAC\r\n\r\nI'm not quite sure about this. Should the user that can only login as `bob` to a node have access to session recordings made by `root`? That would be at least somewhat surprising.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293732017",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-22T13:23:22+00:00",
        "comment_author": "tigrato",
        "comment_body": "My idea with this was to give auditors ability to see the nodes but unable to login into them.\r\nRoles would have the matching labels or label expressions but they are unable to login because they have no principals associated with them.\r\n\r\nChecking the roles will inherently give them access permissions ",
        "pr_file_module": null
      },
      {
        "comment_id": "2293796044",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-22T13:50:31+00:00",
        "comment_author": "Tener",
        "comment_body": "In the original PR description you say:\r\n\r\n> The resource is used to evaluate the function has_access result - this function evaluates if the user requesting the session recording has access to the underlying resource.\r\n\r\nI think the problem is the overloaded meaning of \"access to resource\". If I have no logins allowed but labels are matching, do I have the access or not?\r\n\r\nYou cannot actually login to the node in question, so it would be logical to say \"I cannot access this node\". \r\n\r\nBut you would still see the node in `tsh ls`:\r\n\r\n```\r\n> tsh ls\r\nNode Name Address             Labels\r\n--------- ------------------- -------\r\nnode      11.22.33.44:3022 env=dev\r\n```\r\n\r\nSimilarly for databases there is this discrepancy, which we account for in `tsh db ls` by letting user know there are no usernames they can actually use to login.\r\n\r\n```\r\n> tsh db ls\r\nName   Description Users                              Labels     Connect\r\n------ ----------- ---------------------------------- ---------- ----------------------------\r\ndb-foo             (no matching users found)          env=dev\r\n```\r\n\r\nAll in all perhaps the correct way to resolve it is to always pair `has_access` with some additional role membership, for example `auditor`. Not through hardcoded behaviour though, but rather through proper documentation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2296598087",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-24T10:05:05+00:00",
        "comment_author": "tigrato",
        "comment_body": "I think teleport already overloads the term access with the matching labels instead of matching + principals.\r\n\r\nI wish I could implement the has_access properly but database access logic is too complex. depends on too many random parameters that must be carried.\r\n\r\nI renamed the function to can_view just to clarify the behavior",
        "pr_file_module": null
      },
      {
        "comment_id": "2297374746",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/auth/auth_with_roles.go",
        "discussion_id": "2293136603",
        "commented_code": "@@ -218,13 +218,89 @@ func (a *ServerWithRoles) actionWithExtendedContext(ctx context.Context, kind, v\n func (a *ServerWithRoles) actionForKindSession(ctx context.Context, sid session.ID) error {\n \textendContext := func(servicesCtx *services.Context) error {\n \t\tsessionEnd, err := a.findSessionEndEvent(ctx, sid)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n \t\tservicesCtx.Session = sessionEnd\n+\t\tservicesCtx.Resource = rebuildResourceFromSessionEndEvent(sessionEnd)\n \t\treturn trace.Wrap(err)\n \t}\n \n \treturn trace.Wrap(a.actionWithExtendedContext(ctx, types.KindSession, types.VerbRead, extendContext))\n }\n \n+// rebuildResourceFromSessionEndEvent rebuilds a resource from a session end event.",
        "comment_created_at": "2025-08-25T07:48:32+00:00",
        "comment_author": "Tener",
        "comment_body": "Love it, I think it conveys the intended read-only aspect pretty well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293183628",
    "pr_number": 58114,
    "pr_file": "lib/services/parser.go",
    "created_at": "2025-08-22T09:17:56+00:00",
    "commented_code": "},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}\n+\n+// NewWhereParser returns standard parser for `where` section in access rules.\n+func NewWhereParser(ctx RuleContext, opts ...WhereParserOpts) (predicate.Parser, error) {\n+\tdef := newDefaultWhereParserDef(ctx)\n+\tfor _, opt := range opts {\n+\t\topt(ctx, &def)\n+\t}\n+\treturn predicate.NewParser(def)\n+}\n+\n+func hasAccessFunc(ctx RuleContext) func() predicate.BoolPredicate {\n+\treturn func() predicate.BoolPredicate {\n+\t\treturn func() bool {\n+\t\t\tresource, err := ctx.GetResource()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\taccessCheckableResource, ok := resource.(AccessCheckable)\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\trole, err := ctx.GetRole()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tchecker := NewAccessCheckerWithRoleSet(&AccessInfo{\n+\t\t\t\tRoles:    []string{role.GetName()},\n+\t\t\t\tTraits:   nil,\n+\t\t\t\tUsername: \"\",\n+\t\t\t},\n+\t\t\t\t\"\",\n+\t\t\t\tRoleSet{role},\n+\t\t\t)\n+\t\t\t// We do not enforce MFA or Device Trust for this check because\n+\t\t\t// we don't have a way of checking it from the context.\n+\t\t\treturn checker.CheckAccess(accessCheckableResource, AccessState{\n+\t\t\t\tMFARequired: MFARequiredNever,\n+\t\t\t\tMFAVerified: true,\n+\t\t\t}) == nil",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293183628",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293183628",
        "commented_code": "@@ -192,7 +207,68 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}\n+\n+// NewWhereParser returns standard parser for `where` section in access rules.\n+func NewWhereParser(ctx RuleContext, opts ...WhereParserOpts) (predicate.Parser, error) {\n+\tdef := newDefaultWhereParserDef(ctx)\n+\tfor _, opt := range opts {\n+\t\topt(ctx, &def)\n+\t}\n+\treturn predicate.NewParser(def)\n+}\n+\n+func hasAccessFunc(ctx RuleContext) func() predicate.BoolPredicate {\n+\treturn func() predicate.BoolPredicate {\n+\t\treturn func() bool {\n+\t\t\tresource, err := ctx.GetResource()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\taccessCheckableResource, ok := resource.(AccessCheckable)\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\trole, err := ctx.GetRole()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tchecker := NewAccessCheckerWithRoleSet(&AccessInfo{\n+\t\t\t\tRoles:    []string{role.GetName()},\n+\t\t\t\tTraits:   nil,\n+\t\t\t\tUsername: \"\",\n+\t\t\t},\n+\t\t\t\t\"\",\n+\t\t\t\tRoleSet{role},\n+\t\t\t)\n+\t\t\t// We do not enforce MFA or Device Trust for this check because\n+\t\t\t// we don't have a way of checking it from the context.\n+\t\t\treturn checker.CheckAccess(accessCheckableResource, AccessState{\n+\t\t\t\tMFARequired: MFARequiredNever,\n+\t\t\t\tMFAVerified: true,\n+\t\t\t}) == nil",
        "comment_created_at": "2025-08-22T09:17:56+00:00",
        "comment_author": "Tener",
        "comment_body": "So accessing the session recording to a MFA-protected device will not require MFA in turn? If yes, we should document this gap to avoid confusion.\r\n\r\nIt might be a sensible limitation in the context of session recordings, but I wonder if we can make it harder to misuse. I can imagine someone adding the `has_access` function as written to other parts of RBAC without being aware of its limitations.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293538117",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293183628",
        "commented_code": "@@ -192,7 +207,68 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}\n+\n+// NewWhereParser returns standard parser for `where` section in access rules.\n+func NewWhereParser(ctx RuleContext, opts ...WhereParserOpts) (predicate.Parser, error) {\n+\tdef := newDefaultWhereParserDef(ctx)\n+\tfor _, opt := range opts {\n+\t\topt(ctx, &def)\n+\t}\n+\treturn predicate.NewParser(def)\n+}\n+\n+func hasAccessFunc(ctx RuleContext) func() predicate.BoolPredicate {\n+\treturn func() predicate.BoolPredicate {\n+\t\treturn func() bool {\n+\t\t\tresource, err := ctx.GetResource()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\taccessCheckableResource, ok := resource.(AccessCheckable)\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\trole, err := ctx.GetRole()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tchecker := NewAccessCheckerWithRoleSet(&AccessInfo{\n+\t\t\t\tRoles:    []string{role.GetName()},\n+\t\t\t\tTraits:   nil,\n+\t\t\t\tUsername: \"\",\n+\t\t\t},\n+\t\t\t\t\"\",\n+\t\t\t\tRoleSet{role},\n+\t\t\t)\n+\t\t\t// We do not enforce MFA or Device Trust for this check because\n+\t\t\t// we don't have a way of checking it from the context.\n+\t\t\treturn checker.CheckAccess(accessCheckableResource, AccessState{\n+\t\t\t\tMFARequired: MFARequiredNever,\n+\t\t\t\tMFAVerified: true,\n+\t\t\t}) == nil",
        "comment_created_at": "2025-08-22T12:01:59+00:00",
        "comment_author": "tigrato",
        "comment_body": "has_access is only available to sessions. We can't validate if MFA exists because it depends on teleport setup. In our case, it only depends on labels/label expression matches and not device trust or MFA verified ",
        "pr_file_module": null
      },
      {
        "comment_id": "2293674255",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293183628",
        "commented_code": "@@ -192,7 +207,68 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}\n+\n+// NewWhereParser returns standard parser for `where` section in access rules.\n+func NewWhereParser(ctx RuleContext, opts ...WhereParserOpts) (predicate.Parser, error) {\n+\tdef := newDefaultWhereParserDef(ctx)\n+\tfor _, opt := range opts {\n+\t\topt(ctx, &def)\n+\t}\n+\treturn predicate.NewParser(def)\n+}\n+\n+func hasAccessFunc(ctx RuleContext) func() predicate.BoolPredicate {\n+\treturn func() predicate.BoolPredicate {\n+\t\treturn func() bool {\n+\t\t\tresource, err := ctx.GetResource()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\taccessCheckableResource, ok := resource.(AccessCheckable)\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\trole, err := ctx.GetRole()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tchecker := NewAccessCheckerWithRoleSet(&AccessInfo{\n+\t\t\t\tRoles:    []string{role.GetName()},\n+\t\t\t\tTraits:   nil,\n+\t\t\t\tUsername: \"\",\n+\t\t\t},\n+\t\t\t\t\"\",\n+\t\t\t\tRoleSet{role},\n+\t\t\t)\n+\t\t\t// We do not enforce MFA or Device Trust for this check because\n+\t\t\t// we don't have a way of checking it from the context.\n+\t\t\treturn checker.CheckAccess(accessCheckableResource, AccessState{\n+\t\t\t\tMFARequired: MFARequiredNever,\n+\t\t\t\tMFAVerified: true,\n+\t\t\t}) == nil",
        "comment_created_at": "2025-08-22T13:01:39+00:00",
        "comment_author": "Tener",
        "comment_body": "> has_access is only available to sessions.\r\n\r\nRight now, yes, but I'm worried about future misuse. Perhaps we can rename it to `hasAccessUncheckedMFAFunc` or something similar, just to highlight this property?",
        "pr_file_module": null
      },
      {
        "comment_id": "2293678572",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293183628",
        "commented_code": "@@ -192,7 +207,68 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}\n+\n+// NewWhereParser returns standard parser for `where` section in access rules.\n+func NewWhereParser(ctx RuleContext, opts ...WhereParserOpts) (predicate.Parser, error) {\n+\tdef := newDefaultWhereParserDef(ctx)\n+\tfor _, opt := range opts {\n+\t\topt(ctx, &def)\n+\t}\n+\treturn predicate.NewParser(def)\n+}\n+\n+func hasAccessFunc(ctx RuleContext) func() predicate.BoolPredicate {\n+\treturn func() predicate.BoolPredicate {\n+\t\treturn func() bool {\n+\t\t\tresource, err := ctx.GetResource()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\taccessCheckableResource, ok := resource.(AccessCheckable)\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\trole, err := ctx.GetRole()\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tchecker := NewAccessCheckerWithRoleSet(&AccessInfo{\n+\t\t\t\tRoles:    []string{role.GetName()},\n+\t\t\t\tTraits:   nil,\n+\t\t\t\tUsername: \"\",\n+\t\t\t},\n+\t\t\t\t\"\",\n+\t\t\t\tRoleSet{role},\n+\t\t\t)\n+\t\t\t// We do not enforce MFA or Device Trust for this check because\n+\t\t\t// we don't have a way of checking it from the context.\n+\t\t\treturn checker.CheckAccess(accessCheckableResource, AccessState{\n+\t\t\t\tMFARequired: MFARequiredNever,\n+\t\t\t\tMFAVerified: true,\n+\t\t\t}) == nil",
        "comment_created_at": "2025-08-22T13:03:18+00:00",
        "comment_author": "tigrato",
        "comment_body": "But the named function is still has_access ",
        "pr_file_module": null
      }
    ]
  }
]