[
  {
    "discussion_id": "2325956058",
    "pr_number": 58754,
    "pr_file": "lib/relaytunnel/tunnel_common.go",
    "created_at": "2025-09-05T20:12:57+00:00",
    "commented_code": "+// Teleport\n+// Copyright (C) 2025 Gravitational, Inc.\n+//\n+// This program is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU Affero General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+//\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU Affero General Public License for more details.\n+//\n+// You should have received a copy of the GNU Affero General Public License\n+// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+package relaytunnel\n+\n+const yamuxTunnelALPN = \"teleport-relaytunnel\"",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2325956058",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58754,
        "pr_file": "lib/relaytunnel/tunnel_common.go",
        "discussion_id": "2325956058",
        "commented_code": "@@ -0,0 +1,19 @@\n+// Teleport\n+// Copyright (C) 2025 Gravitational, Inc.\n+//\n+// This program is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU Affero General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+//\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU Affero General Public License for more details.\n+//\n+// You should have received a copy of the GNU Affero General Public License\n+// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+package relaytunnel\n+\n+const yamuxTunnelALPN = \"teleport-relaytunnel\"",
        "comment_created_at": "2025-09-05T20:12:57+00:00",
        "comment_author": "GavinFrazar",
        "comment_body": "not exported but a comment explaining this would be good to have since I don't know what \"yamux\" means.",
        "pr_file_module": null
      },
      {
        "comment_id": "2329373621",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58754,
        "pr_file": "lib/relaytunnel/tunnel_common.go",
        "discussion_id": "2325956058",
        "commented_code": "@@ -0,0 +1,19 @@\n+// Teleport\n+// Copyright (C) 2025 Gravitational, Inc.\n+//\n+// This program is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU Affero General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+//\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU Affero General Public License for more details.\n+//\n+// You should have received a copy of the GNU Affero General Public License\n+// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+package relaytunnel\n+\n+const yamuxTunnelALPN = \"teleport-relaytunnel\"",
        "comment_created_at": "2025-09-08T07:25:35+00:00",
        "comment_author": "espadolini",
        "comment_body": "Added a godoc in dae8b89a88c5c03bf053a83de3521050d78f3f64",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2322162494",
    "pr_number": 58568,
    "pr_file": "lib/accesslists/hierarchy_legacy.go",
    "created_at": "2025-09-04T13:27:57+00:00",
    "commented_code": "+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package accesslists\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/jonboulle/clockwork\"\n+\n+\taccesslistv1 \"github.com/gravitational/teleport/api/gen/proto/go/teleport/accesslist/v1\"\n+\t\"github.com/gravitational/teleport/api/types\"\n+\t\"github.com/gravitational/teleport/api/types/accesslist\"\n+\t\"github.com/gravitational/teleport/lib/services\"\n+)\n+\n+// GetMembersFor returns a flattened list of Members for an Access List, including inherited Members.\n+//\n+// Returned Members are not validated for expiration or other requirements \u2013 use IsAccessListMember\n+// to validate a Member's membership status.\n+// DEPRECATED: use Hierarchy.GetMembersFor instead.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2322162494",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58568,
        "pr_file": "lib/accesslists/hierarchy_legacy.go",
        "discussion_id": "2322162494",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package accesslists\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/jonboulle/clockwork\"\n+\n+\taccesslistv1 \"github.com/gravitational/teleport/api/gen/proto/go/teleport/accesslist/v1\"\n+\t\"github.com/gravitational/teleport/api/types\"\n+\t\"github.com/gravitational/teleport/api/types/accesslist\"\n+\t\"github.com/gravitational/teleport/lib/services\"\n+)\n+\n+// GetMembersFor returns a flattened list of Members for an Access List, including inherited Members.\n+//\n+// Returned Members are not validated for expiration or other requirements \u2013 use IsAccessListMember\n+// to validate a Member's membership status.\n+// DEPRECATED: use Hierarchy.GetMembersFor instead.",
        "comment_created_at": "2025-09-04T13:27:57+00:00",
        "comment_author": "flyinghermit",
        "comment_body": "Should we retire this function in the next major version release? If yes, add `DELETE IN x.x.x` comment too. \r\n(same comment for deprecated functions below)",
        "pr_file_module": null
      },
      {
        "comment_id": "2323720474",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58568,
        "pr_file": "lib/accesslists/hierarchy_legacy.go",
        "discussion_id": "2322162494",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package accesslists\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/jonboulle/clockwork\"\n+\n+\taccesslistv1 \"github.com/gravitational/teleport/api/gen/proto/go/teleport/accesslist/v1\"\n+\t\"github.com/gravitational/teleport/api/types\"\n+\t\"github.com/gravitational/teleport/api/types/accesslist\"\n+\t\"github.com/gravitational/teleport/lib/services\"\n+)\n+\n+// GetMembersFor returns a flattened list of Members for an Access List, including inherited Members.\n+//\n+// Returned Members are not validated for expiration or other requirements \u2013 use IsAccessListMember\n+// to validate a Member's membership status.\n+// DEPRECATED: use Hierarchy.GetMembersFor instead.",
        "comment_created_at": "2025-09-04T23:04:15+00:00",
        "comment_author": "r0mant",
        "comment_body": "Is this really legacy/deprecated though? This seems like just some convenient wrapper functions.\r\n\r\n@smallinsky I think we should do one of the 2:\r\n\r\n- If you do consider this legacy, then we should make a specific plan/commitment to refactor the rest of the code to use the new hierarchy object and get rid of this or we'll be stuck with \"legacy\" forever, OR\r\n- Consider this just wrapped methods, and remove `_legacy` suffix (maybe call it `hierarchy_wrappers.go` or something) from the filename and \"deprecated\" notices from functions.\r\n\r\nWhich one would you lean towards?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2322181354",
    "pr_number": 58568,
    "pr_file": "lib/accesslists/hierarchy_legacy.go",
    "created_at": "2025-09-04T13:32:36+00:00",
    "commented_code": "+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package accesslists\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/jonboulle/clockwork\"\n+\n+\taccesslistv1 \"github.com/gravitational/teleport/api/gen/proto/go/teleport/accesslist/v1\"\n+\t\"github.com/gravitational/teleport/api/types\"\n+\t\"github.com/gravitational/teleport/api/types/accesslist\"\n+\t\"github.com/gravitational/teleport/lib/services\"\n+)\n+\n+// GetMembersFor returns a flattened list of Members for an Access List, including inherited Members.\n+//\n+// Returned Members are not validated for expiration or other requirements \u2013 use IsAccessListMember\n+// to validate a Member's membership status.\n+// DEPRECATED: use Hierarchy.GetMembersFor instead.\n+func GetMembersFor(ctx context.Context, accessListName string, g AccessListAndMembersGetter) ([]*accesslist.AccessListMember, error) {\n+\th, err := NewHierarchy(HierarchyConfig{\n+\t\tAccessListsService: g,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tmembers, err := h.GetMembersFor(ctx, accessListName)\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\treturn members, nil\n+}\n+\n+// GetOwnersFor returns a flattened list of Owners for an Access List, including inherited Owners.\n+//\n+// Returned Owners are not validated for expiration or other requirements \u2013 use IsAccessListOwner\n+// to validate an Owner's ownership status.\n+// DEPRECATED: use Hierarchy.GetOwnersFor instead.\n+func GetOwnersFor(ctx context.Context, accessList *accesslist.AccessList, g AccessListAndMembersGetter) ([]*accesslist.Owner, error) {\n+\th, err := NewHierarchy(HierarchyConfig{\n+\t\tAccessListsService: g,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\towners, err := h.GetOwnersFor(ctx, accessList)\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\treturn owners, nil\n+}\n+\n+// IsAccessListOwner checks if the given user is the Access List owner. It returns an error matched\n+// by [IsUserLocked] if the user is locked.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2322181354",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58568,
        "pr_file": "lib/accesslists/hierarchy_legacy.go",
        "discussion_id": "2322181354",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package accesslists\n+\n+import (\n+\t\"context\"\n+\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/jonboulle/clockwork\"\n+\n+\taccesslistv1 \"github.com/gravitational/teleport/api/gen/proto/go/teleport/accesslist/v1\"\n+\t\"github.com/gravitational/teleport/api/types\"\n+\t\"github.com/gravitational/teleport/api/types/accesslist\"\n+\t\"github.com/gravitational/teleport/lib/services\"\n+)\n+\n+// GetMembersFor returns a flattened list of Members for an Access List, including inherited Members.\n+//\n+// Returned Members are not validated for expiration or other requirements \u2013 use IsAccessListMember\n+// to validate a Member's membership status.\n+// DEPRECATED: use Hierarchy.GetMembersFor instead.\n+func GetMembersFor(ctx context.Context, accessListName string, g AccessListAndMembersGetter) ([]*accesslist.AccessListMember, error) {\n+\th, err := NewHierarchy(HierarchyConfig{\n+\t\tAccessListsService: g,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\tmembers, err := h.GetMembersFor(ctx, accessListName)\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\treturn members, nil\n+}\n+\n+// GetOwnersFor returns a flattened list of Owners for an Access List, including inherited Owners.\n+//\n+// Returned Owners are not validated for expiration or other requirements \u2013 use IsAccessListOwner\n+// to validate an Owner's ownership status.\n+// DEPRECATED: use Hierarchy.GetOwnersFor instead.\n+func GetOwnersFor(ctx context.Context, accessList *accesslist.AccessList, g AccessListAndMembersGetter) ([]*accesslist.Owner, error) {\n+\th, err := NewHierarchy(HierarchyConfig{\n+\t\tAccessListsService: g,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\towners, err := h.GetOwnersFor(ctx, accessList)\n+\tif err != nil {\n+\t\treturn nil, trace.Wrap(err)\n+\t}\n+\treturn owners, nil\n+}\n+\n+// IsAccessListOwner checks if the given user is the Access List owner. It returns an error matched\n+// by [IsUserLocked] if the user is locked.",
        "comment_created_at": "2025-09-04T13:32:36+00:00",
        "comment_author": "flyinghermit",
        "comment_body": "> It returns an error matched by [IsUserLocked] if the user is locked.\r\n```suggestion\r\n// IsAccessListOwner checks if the given user is the Access List owner. It may return an error matched\r\n// by [IsUserLocked] if the user is locked.\r\n```\r\n\r\nOtherwise, I found it a bit misleading cause an error is returned for `NewHierarchy` too, which may not have the `IsUserLocked`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2298980080",
    "pr_number": 58323,
    "pr_file": "lib/cache/access_list.go",
    "created_at": "2025-08-25T19:49:17+00:00",
    "commented_code": "types.KindAccessList,\n \t\t\t(*accesslist.AccessList).Clone,\n \t\t\tmap[accessListIndex]func(*accesslist.AccessList) string{\n-\t\t\t\taccessListNameIndex: func(al *accesslist.AccessList) string {\n-\t\t\t\t\treturn al.GetMetadata().Name\n-\t\t\t\t},\n+\t\t\t\taccessListNameIndex:          accessListNameIndexFn,\n+\t\t\t\taccessListAuditNextDateIndex: accessListAuditNextDateIndexFn,",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2298980080",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58323,
        "pr_file": "lib/cache/access_list.go",
        "discussion_id": "2298980080",
        "commented_code": "@@ -46,9 +59,8 @@ func newAccessListCollection(upstream services.AccessLists, w types.WatchKind) (\n \t\t\ttypes.KindAccessList,\n \t\t\t(*accesslist.AccessList).Clone,\n \t\t\tmap[accessListIndex]func(*accesslist.AccessList) string{\n-\t\t\t\taccessListNameIndex: func(al *accesslist.AccessList) string {\n-\t\t\t\t\treturn al.GetMetadata().Name\n-\t\t\t\t},\n+\t\t\t\taccessListNameIndex:          accessListNameIndexFn,\n+\t\t\t\taccessListAuditNextDateIndex: accessListAuditNextDateIndexFn,",
        "comment_created_at": "2025-08-25T19:49:17+00:00",
        "comment_author": "smallinsky",
        "comment_body": "Could you add a comment  like: \r\n\r\n// Second index is used in FE ...\r\n\r\nGiven a 50k access list, the access-list object will use roughly 2\u00d7 more memory. But I that it should be fine as the primary bottleneck is the access-list member entries, which in our case may exceed 2\u202fmillion",
        "pr_file_module": null
      },
      {
        "comment_id": "2300787431",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58323,
        "pr_file": "lib/cache/access_list.go",
        "discussion_id": "2298980080",
        "commented_code": "@@ -46,9 +59,8 @@ func newAccessListCollection(upstream services.AccessLists, w types.WatchKind) (\n \t\t\ttypes.KindAccessList,\n \t\t\t(*accesslist.AccessList).Clone,\n \t\t\tmap[accessListIndex]func(*accesslist.AccessList) string{\n-\t\t\t\taccessListNameIndex: func(al *accesslist.AccessList) string {\n-\t\t\t\t\treturn al.GetMetadata().Name\n-\t\t\t\t},\n+\t\t\t\taccessListNameIndex:          accessListNameIndexFn,\n+\t\t\t\taccessListAuditNextDateIndex: accessListAuditNextDateIndexFn,",
        "comment_created_at": "2025-08-26T12:07:18+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "I don't know that we should be annotating indexes with their current use cases. The comments may become completely irrelevant over time. I think it'd be more valuable to add comments that explain what the index does, i.e. allows for efficient sorting by the next audit date.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2313788992",
    "pr_number": 58409,
    "pr_file": "lib/events/dynamoevents/dynamoevents.go",
    "created_at": "2025-09-01T12:14:05+00:00",
    "commented_code": "func fromWhereExpr(cond *types.WhereExpr, params *condFilterParams) (string, error) {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2313788992",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58409,
        "pr_file": "lib/events/dynamoevents/dynamoevents.go",
        "discussion_id": "2313788992",
        "commented_code": "@@ -1091,7 +1096,7 @@ type condFilterParams struct {\n \n func fromWhereExpr(cond *types.WhereExpr, params *condFilterParams) (string, error) {",
        "comment_created_at": "2025-09-01T12:14:05+00:00",
        "comment_author": "bl-nero",
        "comment_body": "While we're at it, can you please add a documentation comment to this function? It took me quite a while to wrap my head around what it's supposed to do. (We can also do it separately if this is urgent.) Things I wish to have known upfront:\r\n- that this translates a `WhereExpr` to a DB filter expression\r\n- that `condFilterParams` is actually an input/output parameter\r\n- perhaps also add something about what `attrValues` and `attrNames` are, as they are both maps, and it goes against the intuition of \"a name to value mapping is a single map\". This may belong to the `attrValues` and `attrNames` fields.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293147254",
    "pr_number": 58114,
    "pr_file": "lib/services/parser.go",
    "created_at": "2025-08-22T09:01:16+00:00",
    "commented_code": "Functions: map[string]any{\n \t\t\t\"equals\":       predicate.Equals,\n \t\t\t\"contains\":     predicate.Contains,\n+\t\t\t\"contains_all\": predicateContainsAll,\n+\t\t\t\"contains_any\": predicateContainsAny,",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293147254",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293147254",
        "commented_code": "@@ -156,6 +160,17 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\tFunctions: map[string]any{\n \t\t\t\"equals\":       predicate.Equals,\n \t\t\t\"contains\":     predicate.Contains,\n+\t\t\t\"contains_all\": predicateContainsAll,\n+\t\t\t\"contains_any\": predicateContainsAny,",
        "comment_created_at": "2025-08-22T09:01:16+00:00",
        "comment_author": "Tener",
        "comment_body": "Having all of  `contains`, `contains_any` and `contains_all` will be somewhat confusing. Can you document how `contains` is related to the others? This would be both useful here as well in the user-facing docs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293399632",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293147254",
        "commented_code": "@@ -156,6 +160,17 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\tFunctions: map[string]any{\n \t\t\t\"equals\":       predicate.Equals,\n \t\t\t\"contains\":     predicate.Contains,\n+\t\t\t\"contains_all\": predicateContainsAll,\n+\t\t\t\"contains_any\": predicateContainsAny,",
        "comment_created_at": "2025-08-22T10:50:36+00:00",
        "comment_author": "tigrato",
        "comment_body": "contains signature is as follows: `contains([]string, string)`. It searches for the string in the slice.\r\nContains any and all both receive slices and one ensures at least one entry from the second slice exists and the other ensures all entries from the second slices exist in the first slice - order doesn't matter.\r\n\r\nI will write proper documentation ",
        "pr_file_module": null
      }
    ]
  }
]