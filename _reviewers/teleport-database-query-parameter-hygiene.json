[
  {
    "discussion_id": "2323235100",
    "pr_number": 58677,
    "pr_file": "lib/services/local/access_list.go",
    "created_at": "2025-09-04T19:16:02+00:00",
    "commented_code": "// update references for new owners\n \t\tfor ownerName := range currentOwnersMap {\n-\t\t\tif _, exists := originalOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n-\t\t\t\t}\n+\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n \t\t\t}\n \t\t}\n \n \t\t// update references for old owners\n-\t\tfor ownerName := range originalOwnersMap {\n-\t\t\tif _, exists := currentOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, false); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n+\t\tif existingAccessList != nil {\n+\t\t\tfor _, owner := range existingAccessList.Spec.Owners {\n+\t\t\t\tif _, exists := currentOwnersMap[owner.Name]; !exists {\n+\t\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), owner.Name, false); err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2323235100",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58677,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2323235100",
        "commented_code": "@@ -282,18 +272,18 @@ func (a *AccessListService) runOpWithLock(ctx context.Context, accessList *acces\n \n \t\t// update references for new owners\n \t\tfor ownerName := range currentOwnersMap {\n-\t\t\tif _, exists := originalOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n-\t\t\t\t}\n+\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n \t\t\t}\n \t\t}\n \n \t\t// update references for old owners\n-\t\tfor ownerName := range originalOwnersMap {\n-\t\t\tif _, exists := currentOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, false); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n+\t\tif existingAccessList != nil {\n+\t\t\tfor _, owner := range existingAccessList.Spec.Owners {\n+\t\t\t\tif _, exists := currentOwnersMap[owner.Name]; !exists {\n+\t\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), owner.Name, false); err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}",
        "comment_created_at": "2025-09-04T19:16:02+00:00",
        "comment_author": "GavinFrazar",
        "comment_body": "we don't want to check if the owner's membership kind is `accesslist.MembershipKindList` anymore?",
        "pr_file_module": null
      },
      {
        "comment_id": "2323611150",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58677,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2323235100",
        "commented_code": "@@ -282,18 +272,18 @@ func (a *AccessListService) runOpWithLock(ctx context.Context, accessList *acces\n \n \t\t// update references for new owners\n \t\tfor ownerName := range currentOwnersMap {\n-\t\t\tif _, exists := originalOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n-\t\t\t\t}\n+\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n \t\t\t}\n \t\t}\n \n \t\t// update references for old owners\n-\t\tfor ownerName := range originalOwnersMap {\n-\t\t\tif _, exists := currentOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, false); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n+\t\tif existingAccessList != nil {\n+\t\t\tfor _, owner := range existingAccessList.Spec.Owners {\n+\t\t\t\tif _, exists := currentOwnersMap[owner.Name]; !exists {\n+\t\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), owner.Name, false); err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}",
        "comment_created_at": "2025-09-04T21:41:29+00:00",
        "comment_author": "kopiczko",
        "comment_body": "We definitely do. Thanks for catching this. Weird any test didn't cover for that. I'll have to add one.",
        "pr_file_module": null
      },
      {
        "comment_id": "2324741816",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58677,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2323235100",
        "commented_code": "@@ -282,18 +272,18 @@ func (a *AccessListService) runOpWithLock(ctx context.Context, accessList *acces\n \n \t\t// update references for new owners\n \t\tfor ownerName := range currentOwnersMap {\n-\t\t\tif _, exists := originalOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n-\t\t\t\t}\n+\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n \t\t\t}\n \t\t}\n \n \t\t// update references for old owners\n-\t\tfor ownerName := range originalOwnersMap {\n-\t\t\tif _, exists := currentOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, false); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n+\t\tif existingAccessList != nil {\n+\t\t\tfor _, owner := range existingAccessList.Spec.Owners {\n+\t\t\t\tif _, exists := currentOwnersMap[owner.Name]; !exists {\n+\t\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), owner.Name, false); err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}",
        "comment_created_at": "2025-09-05T10:40:43+00:00",
        "comment_author": "kopiczko",
        "comment_body": "I've just figured it works ok because of this code https://github.com/gravitational/teleport/blob/4b450debfa3ff74c66db9071fe90a68fb09a9399/lib/services/local/access_list.go#L484-L487, but the efficiency suffers a tiny bit.",
        "pr_file_module": null
      },
      {
        "comment_id": "2324774422",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58677,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2323235100",
        "commented_code": "@@ -282,18 +272,18 @@ func (a *AccessListService) runOpWithLock(ctx context.Context, accessList *acces\n \n \t\t// update references for new owners\n \t\tfor ownerName := range currentOwnersMap {\n-\t\t\tif _, exists := originalOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n-\t\t\t\t}\n+\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, true); err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n \t\t\t}\n \t\t}\n \n \t\t// update references for old owners\n-\t\tfor ownerName := range originalOwnersMap {\n-\t\t\tif _, exists := currentOwnersMap[ownerName]; !exists {\n-\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), ownerName, false); err != nil {\n-\t\t\t\t\treturn trace.Wrap(err)\n+\t\tif existingAccessList != nil {\n+\t\t\tfor _, owner := range existingAccessList.Spec.Owners {\n+\t\t\t\tif _, exists := currentOwnersMap[owner.Name]; !exists {\n+\t\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, accessList.GetName(), owner.Name, false); err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}",
        "comment_created_at": "2025-09-05T10:58:44+00:00",
        "comment_author": "kopiczko",
        "comment_body": "I added the filter and also some coverage for status cleanup for deleted owner lists. Just to cover for `!=` -> `==` typo.\r\nhttps://github.com/gravitational/teleport/compare/4b450debfa3ff74c66db9071fe90a68fb09a9399..841870ebf2abb12793277f338f8f2455994984e9",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2325178025",
    "pr_number": 58716,
    "pr_file": "lib/cache/access_list.go",
    "created_at": "2025-09-05T13:56:47+00:00",
    "commented_code": "return out, nil\n }\n \n+// RangeAccessLists returns access list resources within the range [start, end).\n+func (c *Cache) RangeAccessLists(ctx context.Context, start string, end string, filter *accesslistv1.AccessListsFilter, sort *types.SortBy) iter.Seq2[*accesslist.AccessList, error] {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2325178025",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58716,
        "pr_file": "lib/cache/access_list.go",
        "discussion_id": "2325178025",
        "commented_code": "@@ -112,13 +113,64 @@ func (c *Cache) GetAccessLists(ctx context.Context) ([]*accesslist.AccessList, e\n \treturn out, nil\n }\n \n+// RangeAccessLists returns access list resources within the range [start, end).\n+func (c *Cache) RangeAccessLists(ctx context.Context, start string, end string, filter *accesslistv1.AccessListsFilter, sort *types.SortBy) iter.Seq2[*accesslist.AccessList, error] {",
        "comment_created_at": "2025-09-05T13:56:47+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "Why do we need the filter here if it isn't being consumed?",
        "pr_file_module": null
      },
      {
        "comment_id": "2325196955",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58716,
        "pr_file": "lib/cache/access_list.go",
        "discussion_id": "2325178025",
        "commented_code": "@@ -112,13 +113,64 @@ func (c *Cache) GetAccessLists(ctx context.Context) ([]*accesslist.AccessList, e\n \treturn out, nil\n }\n \n+// RangeAccessLists returns access list resources within the range [start, end).\n+func (c *Cache) RangeAccessLists(ctx context.Context, start string, end string, filter *accesslistv1.AccessListsFilter, sort *types.SortBy) iter.Seq2[*accesslist.AccessList, error] {",
        "comment_created_at": "2025-09-05T14:04:05+00:00",
        "comment_author": "avatus",
        "comment_body": "i think it might have been a vestigial thing from an old iteration and then i kept it due to interface issues. good call out tho, removed it. the filter is only used in the grpc service `ListAccessListsV2`",
        "pr_file_module": null
      },
      {
        "comment_id": "2325272791",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58716,
        "pr_file": "lib/cache/access_list.go",
        "discussion_id": "2325178025",
        "commented_code": "@@ -112,13 +113,64 @@ func (c *Cache) GetAccessLists(ctx context.Context) ([]*accesslist.AccessList, e\n \treturn out, nil\n }\n \n+// RangeAccessLists returns access list resources within the range [start, end).\n+func (c *Cache) RangeAccessLists(ctx context.Context, start string, end string, filter *accesslistv1.AccessListsFilter, sort *types.SortBy) iter.Seq2[*accesslist.AccessList, error] {",
        "comment_created_at": "2025-09-05T14:33:40+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "I guess this poses the question of should the filter be applied in the cache/backend or the RPC layer. cc @okraport @espadolini ",
        "pr_file_module": null
      }
    ]
  }
]