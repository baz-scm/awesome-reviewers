[
  {
    "discussion_id": "2316335200",
    "pr_number": 58518,
    "pr_file": "rfd/XXXX-scopes.md",
    "created_at": "2025-09-02T14:50:31+00:00",
    "commented_code": "+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2316335200",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316335200",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:",
        "comment_created_at": "2025-09-02T14:50:31+00:00",
        "comment_author": "zmb3",
        "comment_body": "We should also consider the UX of web UI (and Teleport Connect) login. Is there a scope selector on the login form? After login? Do you just log in to a different URL? Is a web session cookie also pinned to a scope?\n\nMaybe this is all coming later and would be best left to a separate RFD. That's okay too.",
        "pr_file_module": null
      },
      {
        "comment_id": "2316468866",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316335200",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:",
        "comment_created_at": "2025-09-02T15:38:30+00:00",
        "comment_author": "michxsung",
        "comment_body": "I've been working on the web UI UX and am documenting my UX planning/discovery here (Figma Slides): https://www.figma.com/slides/OIWxra2hWqRupGIaWBraBt/SLIDES-Scoped-RBAC--Product-Design-Notes?node-id=19-810&t=PSQjWXGxtLFnbEmV-1\r\n\r\nTo answer your question, we would want a scope selector view but after the login view. The latest analogy is AWS's access portal view where you'd see a list of accounts and then select an account to \"switch into\".\r\n\r\n*Edit to add: this is based on the latest discussions - if there's support to have the selector on the login screen, versus post-login, we could consider but that has not come up yet.",
        "pr_file_module": null
      },
      {
        "comment_id": "2316977794",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316335200",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:",
        "comment_created_at": "2025-09-02T19:30:33+00:00",
        "comment_author": "zmb3",
        "comment_body": "> To answer your question, we would want a scope selector view but after the login view.\r\n\r\nThanks for clarifying. It's kind of the opposite of tsh, where you don't get issued certificates until you specify a scope. Seems doable as long as we can avoid prompting the user for credentials a second time in order to pin them to a scope.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2316350149",
    "pr_number": 58518,
    "pr_file": "rfd/XXXX-scopes.md",
    "created_at": "2025-09-02T14:55:03+00:00",
    "commented_code": "+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2316350149",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316350149",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east",
        "comment_created_at": "2025-09-02T14:55:03+00:00",
        "comment_author": "zmb3",
        "comment_body": "And this will work even if the current user certs are pinned to a child scope like `/staging/west`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2316607449",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316350149",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east",
        "comment_created_at": "2025-09-02T16:29:42+00:00",
        "comment_author": "fspmarshall",
        "comment_body": "Yes, we're planning to add an exception in the same vein of how we let users read their own user resource even if they don't have `user:read`.  Users clients will be permitted to list all their scoped privilege assignments even when pinned to a child scope.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2316357112",
    "pr_number": 58518,
    "pr_file": "rfd/XXXX-scopes.md",
    "created_at": "2025-09-02T14:57:13+00:00",
    "commented_code": "+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.\n+\n+\n+### A Scoped Access Check\n+\n+In order to conform to our core isolation and heirarchy goals, the form of scoped access checking will need to diverge\n+somewhat from classic teleport access checks.  Ordinarily, in teleport code, an access check is a one-off decision, the\n+pseudocode of which would look something like this:\n+\n+```go\n+roles := LoadRolesForUser(cert)\n+\n+if CanAccessResource(roles, resource) {\n+    parameters := GetAccessConstraints(roles, resource)\n+    return Permit(parameters)\n+} else {\n+    return Denial\n+}\n+```\n+\n+Note that allow decisions are not binary. There are often parameters that affect the nature of allowed access (e.g. allowed\n+ssh access may come with or without X11 forwarding enabled).\n+\n+Per our scoping design goals, one of our key criteria is that administrative permissions assigned at a child scope cannot\n+be used to affect the nature of resources/permissions at a parent scope.  This means that we cannot allow permissions in\n+a child scope to modify the parameters of access that is permitted at a parent scope. We therefore end up with an access\n+check flow that looks something like this:\n+\n+```go\n+if !PinScopeAllowsAccessToResourceScope(cert.ScopePin, resource.GetScope()) {\n+    return Denial\n+}\n+\n+var roles []Role\n+for scope := range DescendScopeHeirarchy(resource.GetScope()) { // \"/staging/west\" -> [\"/\", \"/staging\", \"/staging/west\"]\n+    roles = append(roles, LoadRolesForUserAtScope(cert, scope)...)\n+    if CanAccessResource(roles, resource) {\n+        parameters := GetAccessConstraints(roles, resource)\n+        return Permit(parameters)\n+    }\n+}\n+\n+return Denial\n+```\n+\n+Note that we start from the uppermost parent scope, and iteratively descend. At the first scope where access is allowed,\n+we determine the full parameters of access *at that scope*. Assignment of additional roles/permissions at child scopes\n+have no effect per scope isolation rules.\n+\n+\n+### Scoped Roles and Assignments\n+\n+A new `scoped_role` type will be introduced for the purpose of defining scoped permissions. This type will implement\n+a subset of the features of the existing `role` type, with features being ported over iteratively over time.\n+\n+Classical teleport roles are assigned to users by directly editing the user resource's `roles` field. This centralized\n+approach is not inkeeping with the goal of delegated/limited administration.  Instead, scoped roles will be assigned\n+via a separate scoped assignment resource.  Admins of a given scope will be able to create scoped role assignments\n+for users independently, without the need to modify global state.\n+\n+Inkeeping with the heirarchical isolation principle, scoped roles will only be assignable at the scope of the role\n+resource itself or a descendant scope.  For example, a `scoped_role` defined at `/staging` could be assigned to users\n+at `/staging` or `/staging/west`, but not at `/prod` or `/prod/west`. This ensures that role editing privileges in\n+one scope cannot be used to affect permissions in another scope.\n+\n+As an additional layer of control, it will be possible to constrain the assignable scopes of a scoped role to\n+an explicitly defined subset. For example, a scoped role defined at `/staging` could be\n+configured be assignable at `/staging/west` and `/staging/east`, but not at `/staging` or `/staging/central`\n+by specifying `assignable_scopes: [\"/staging/west\", \"/staging/east\"]` in the role spec. This has a few important\n+benefits. First, by allowing this extra layer of control, we allows scoped roles to be used in a manner similar\n+to a \"role template\". If two different scopes need similar roles, a parent scope can provide a common definition.\n+Second, separating the concerns of scoping role definition and assignment ensures that admins can accurately express\n+intent and prevent misuse.\n+\n+A `scoped_role` resource for scoped admins might look like something like this:\n+\n+```yaml\n+kind: scoped_role\n+metadata:\n+  name: staging-admin\n+  description: Basic administrative privileges for staging env admins\n+scope: /staging\n+spec:\n+  assignable_scopes:\n+    - /staging/west\n+    - /staging/east\n+  allow:\n+    rules:\n+    - kind: scoped_token\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role_assignment\n+      verbs: [create, read, update, delete]\n+version: v1\n+```\n+\n+Note that other than the `scope` and `spec.assignable_scopes` fields, this is identical to a standard teleport role\n+definition.  Keeping this parity ensures ease of transition and reduces cognitive load for users familiar with\n+existing teleport concepts. It also saves us considerable effort since most of the existing role evaluation logic\n+can be reused.\n+\n+\n+### Scoped Tokens and Joining\n+\n+The scope of an agent will be determined by their join tokens. Scoped administrators will be able to create join tokens\n+assigned to scopes where they have `token:create` permissions. When an agent joins the teleport cluster using a scoped\n+join token, the agent will be automatically assigned that scope.\n+\n+Creation of scoped join tokens will mirror the existing token creation API where possible. Ex:\n+\n+```shell\n+$ tctl scoped token add --type=node --scope=/staging/west",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2316357112",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316357112",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.\n+\n+\n+### A Scoped Access Check\n+\n+In order to conform to our core isolation and heirarchy goals, the form of scoped access checking will need to diverge\n+somewhat from classic teleport access checks.  Ordinarily, in teleport code, an access check is a one-off decision, the\n+pseudocode of which would look something like this:\n+\n+```go\n+roles := LoadRolesForUser(cert)\n+\n+if CanAccessResource(roles, resource) {\n+    parameters := GetAccessConstraints(roles, resource)\n+    return Permit(parameters)\n+} else {\n+    return Denial\n+}\n+```\n+\n+Note that allow decisions are not binary. There are often parameters that affect the nature of allowed access (e.g. allowed\n+ssh access may come with or without X11 forwarding enabled).\n+\n+Per our scoping design goals, one of our key criteria is that administrative permissions assigned at a child scope cannot\n+be used to affect the nature of resources/permissions at a parent scope.  This means that we cannot allow permissions in\n+a child scope to modify the parameters of access that is permitted at a parent scope. We therefore end up with an access\n+check flow that looks something like this:\n+\n+```go\n+if !PinScopeAllowsAccessToResourceScope(cert.ScopePin, resource.GetScope()) {\n+    return Denial\n+}\n+\n+var roles []Role\n+for scope := range DescendScopeHeirarchy(resource.GetScope()) { // \"/staging/west\" -> [\"/\", \"/staging\", \"/staging/west\"]\n+    roles = append(roles, LoadRolesForUserAtScope(cert, scope)...)\n+    if CanAccessResource(roles, resource) {\n+        parameters := GetAccessConstraints(roles, resource)\n+        return Permit(parameters)\n+    }\n+}\n+\n+return Denial\n+```\n+\n+Note that we start from the uppermost parent scope, and iteratively descend. At the first scope where access is allowed,\n+we determine the full parameters of access *at that scope*. Assignment of additional roles/permissions at child scopes\n+have no effect per scope isolation rules.\n+\n+\n+### Scoped Roles and Assignments\n+\n+A new `scoped_role` type will be introduced for the purpose of defining scoped permissions. This type will implement\n+a subset of the features of the existing `role` type, with features being ported over iteratively over time.\n+\n+Classical teleport roles are assigned to users by directly editing the user resource's `roles` field. This centralized\n+approach is not inkeeping with the goal of delegated/limited administration.  Instead, scoped roles will be assigned\n+via a separate scoped assignment resource.  Admins of a given scope will be able to create scoped role assignments\n+for users independently, without the need to modify global state.\n+\n+Inkeeping with the heirarchical isolation principle, scoped roles will only be assignable at the scope of the role\n+resource itself or a descendant scope.  For example, a `scoped_role` defined at `/staging` could be assigned to users\n+at `/staging` or `/staging/west`, but not at `/prod` or `/prod/west`. This ensures that role editing privileges in\n+one scope cannot be used to affect permissions in another scope.\n+\n+As an additional layer of control, it will be possible to constrain the assignable scopes of a scoped role to\n+an explicitly defined subset. For example, a scoped role defined at `/staging` could be\n+configured be assignable at `/staging/west` and `/staging/east`, but not at `/staging` or `/staging/central`\n+by specifying `assignable_scopes: [\"/staging/west\", \"/staging/east\"]` in the role spec. This has a few important\n+benefits. First, by allowing this extra layer of control, we allows scoped roles to be used in a manner similar\n+to a \"role template\". If two different scopes need similar roles, a parent scope can provide a common definition.\n+Second, separating the concerns of scoping role definition and assignment ensures that admins can accurately express\n+intent and prevent misuse.\n+\n+A `scoped_role` resource for scoped admins might look like something like this:\n+\n+```yaml\n+kind: scoped_role\n+metadata:\n+  name: staging-admin\n+  description: Basic administrative privileges for staging env admins\n+scope: /staging\n+spec:\n+  assignable_scopes:\n+    - /staging/west\n+    - /staging/east\n+  allow:\n+    rules:\n+    - kind: scoped_token\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role_assignment\n+      verbs: [create, read, update, delete]\n+version: v1\n+```\n+\n+Note that other than the `scope` and `spec.assignable_scopes` fields, this is identical to a standard teleport role\n+definition.  Keeping this parity ensures ease of transition and reduces cognitive load for users familiar with\n+existing teleport concepts. It also saves us considerable effort since most of the existing role evaluation logic\n+can be reused.\n+\n+\n+### Scoped Tokens and Joining\n+\n+The scope of an agent will be determined by their join tokens. Scoped administrators will be able to create join tokens\n+assigned to scopes where they have `token:create` permissions. When an agent joins the teleport cluster using a scoped\n+join token, the agent will be automatically assigned that scope.\n+\n+Creation of scoped join tokens will mirror the existing token creation API where possible. Ex:\n+\n+```shell\n+$ tctl scoped token add --type=node --scope=/staging/west",
        "comment_created_at": "2025-09-02T14:57:13+00:00",
        "comment_author": "zmb3",
        "comment_body": "Why not just?\n```suggestion\n$ tctl token add --type=node --scope=/staging/west\n```\n\nWhich would add to the specified scope, or fall back to:\n- the pinned scope in the user's cert (for remote tctl)\n- the root scope (for `RoleAdmin`)",
        "pr_file_module": null
      },
      {
        "comment_id": "2316681294",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316357112",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.\n+\n+\n+### A Scoped Access Check\n+\n+In order to conform to our core isolation and heirarchy goals, the form of scoped access checking will need to diverge\n+somewhat from classic teleport access checks.  Ordinarily, in teleport code, an access check is a one-off decision, the\n+pseudocode of which would look something like this:\n+\n+```go\n+roles := LoadRolesForUser(cert)\n+\n+if CanAccessResource(roles, resource) {\n+    parameters := GetAccessConstraints(roles, resource)\n+    return Permit(parameters)\n+} else {\n+    return Denial\n+}\n+```\n+\n+Note that allow decisions are not binary. There are often parameters that affect the nature of allowed access (e.g. allowed\n+ssh access may come with or without X11 forwarding enabled).\n+\n+Per our scoping design goals, one of our key criteria is that administrative permissions assigned at a child scope cannot\n+be used to affect the nature of resources/permissions at a parent scope.  This means that we cannot allow permissions in\n+a child scope to modify the parameters of access that is permitted at a parent scope. We therefore end up with an access\n+check flow that looks something like this:\n+\n+```go\n+if !PinScopeAllowsAccessToResourceScope(cert.ScopePin, resource.GetScope()) {\n+    return Denial\n+}\n+\n+var roles []Role\n+for scope := range DescendScopeHeirarchy(resource.GetScope()) { // \"/staging/west\" -> [\"/\", \"/staging\", \"/staging/west\"]\n+    roles = append(roles, LoadRolesForUserAtScope(cert, scope)...)\n+    if CanAccessResource(roles, resource) {\n+        parameters := GetAccessConstraints(roles, resource)\n+        return Permit(parameters)\n+    }\n+}\n+\n+return Denial\n+```\n+\n+Note that we start from the uppermost parent scope, and iteratively descend. At the first scope where access is allowed,\n+we determine the full parameters of access *at that scope*. Assignment of additional roles/permissions at child scopes\n+have no effect per scope isolation rules.\n+\n+\n+### Scoped Roles and Assignments\n+\n+A new `scoped_role` type will be introduced for the purpose of defining scoped permissions. This type will implement\n+a subset of the features of the existing `role` type, with features being ported over iteratively over time.\n+\n+Classical teleport roles are assigned to users by directly editing the user resource's `roles` field. This centralized\n+approach is not inkeeping with the goal of delegated/limited administration.  Instead, scoped roles will be assigned\n+via a separate scoped assignment resource.  Admins of a given scope will be able to create scoped role assignments\n+for users independently, without the need to modify global state.\n+\n+Inkeeping with the heirarchical isolation principle, scoped roles will only be assignable at the scope of the role\n+resource itself or a descendant scope.  For example, a `scoped_role` defined at `/staging` could be assigned to users\n+at `/staging` or `/staging/west`, but not at `/prod` or `/prod/west`. This ensures that role editing privileges in\n+one scope cannot be used to affect permissions in another scope.\n+\n+As an additional layer of control, it will be possible to constrain the assignable scopes of a scoped role to\n+an explicitly defined subset. For example, a scoped role defined at `/staging` could be\n+configured be assignable at `/staging/west` and `/staging/east`, but not at `/staging` or `/staging/central`\n+by specifying `assignable_scopes: [\"/staging/west\", \"/staging/east\"]` in the role spec. This has a few important\n+benefits. First, by allowing this extra layer of control, we allows scoped roles to be used in a manner similar\n+to a \"role template\". If two different scopes need similar roles, a parent scope can provide a common definition.\n+Second, separating the concerns of scoping role definition and assignment ensures that admins can accurately express\n+intent and prevent misuse.\n+\n+A `scoped_role` resource for scoped admins might look like something like this:\n+\n+```yaml\n+kind: scoped_role\n+metadata:\n+  name: staging-admin\n+  description: Basic administrative privileges for staging env admins\n+scope: /staging\n+spec:\n+  assignable_scopes:\n+    - /staging/west\n+    - /staging/east\n+  allow:\n+    rules:\n+    - kind: scoped_token\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role_assignment\n+      verbs: [create, read, update, delete]\n+version: v1\n+```\n+\n+Note that other than the `scope` and `spec.assignable_scopes` fields, this is identical to a standard teleport role\n+definition.  Keeping this parity ensures ease of transition and reduces cognitive load for users familiar with\n+existing teleport concepts. It also saves us considerable effort since most of the existing role evaluation logic\n+can be reused.\n+\n+\n+### Scoped Tokens and Joining\n+\n+The scope of an agent will be determined by their join tokens. Scoped administrators will be able to create join tokens\n+assigned to scopes where they have `token:create` permissions. When an agent joins the teleport cluster using a scoped\n+join token, the agent will be automatically assigned that scope.\n+\n+Creation of scoped join tokens will mirror the existing token creation API where possible. Ex:\n+\n+```shell\n+$ tctl scoped token add --type=node --scope=/staging/west",
        "comment_created_at": "2025-09-02T17:04:04+00:00",
        "comment_author": "fspmarshall",
        "comment_body": "A few reasons, in no particular order:\r\n\r\nA lot of the options on `tctl token add` just won't work initially with scoped tokens, which is confusing (and annoying maintenance-wise).\r\n\r\nI am leery of ever silently making an existing operation that is directly or indirectly privilege-granting scoped.  Joining an unscoped/root agent will allow fewer people to access that agent if it is an ssh server, but will also grant the agent increased privileges (especially for some of the other protocols), so there is a complex shift in access surface.  Silently changing the nature of an existing command s.t. access surface is significantly changed under previously unrelated conditions seems like a bad idea.  By creating a new `tctl scoped token add` command, we make it explicit that the meaning of the command you are running now is dependent on the scoping you did earlier and not silently changing the meaning of existing administrative workflows.\r\n\r\nScoped tokens will likely be single-use by default, as opposed to standard tokens which are infinite-use by default, so scoped tokens won't be a simple identical subset of standard token functionality.",
        "pr_file_module": null
      },
      {
        "comment_id": "2316973476",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316357112",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.\n+\n+\n+### A Scoped Access Check\n+\n+In order to conform to our core isolation and heirarchy goals, the form of scoped access checking will need to diverge\n+somewhat from classic teleport access checks.  Ordinarily, in teleport code, an access check is a one-off decision, the\n+pseudocode of which would look something like this:\n+\n+```go\n+roles := LoadRolesForUser(cert)\n+\n+if CanAccessResource(roles, resource) {\n+    parameters := GetAccessConstraints(roles, resource)\n+    return Permit(parameters)\n+} else {\n+    return Denial\n+}\n+```\n+\n+Note that allow decisions are not binary. There are often parameters that affect the nature of allowed access (e.g. allowed\n+ssh access may come with or without X11 forwarding enabled).\n+\n+Per our scoping design goals, one of our key criteria is that administrative permissions assigned at a child scope cannot\n+be used to affect the nature of resources/permissions at a parent scope.  This means that we cannot allow permissions in\n+a child scope to modify the parameters of access that is permitted at a parent scope. We therefore end up with an access\n+check flow that looks something like this:\n+\n+```go\n+if !PinScopeAllowsAccessToResourceScope(cert.ScopePin, resource.GetScope()) {\n+    return Denial\n+}\n+\n+var roles []Role\n+for scope := range DescendScopeHeirarchy(resource.GetScope()) { // \"/staging/west\" -> [\"/\", \"/staging\", \"/staging/west\"]\n+    roles = append(roles, LoadRolesForUserAtScope(cert, scope)...)\n+    if CanAccessResource(roles, resource) {\n+        parameters := GetAccessConstraints(roles, resource)\n+        return Permit(parameters)\n+    }\n+}\n+\n+return Denial\n+```\n+\n+Note that we start from the uppermost parent scope, and iteratively descend. At the first scope where access is allowed,\n+we determine the full parameters of access *at that scope*. Assignment of additional roles/permissions at child scopes\n+have no effect per scope isolation rules.\n+\n+\n+### Scoped Roles and Assignments\n+\n+A new `scoped_role` type will be introduced for the purpose of defining scoped permissions. This type will implement\n+a subset of the features of the existing `role` type, with features being ported over iteratively over time.\n+\n+Classical teleport roles are assigned to users by directly editing the user resource's `roles` field. This centralized\n+approach is not inkeeping with the goal of delegated/limited administration.  Instead, scoped roles will be assigned\n+via a separate scoped assignment resource.  Admins of a given scope will be able to create scoped role assignments\n+for users independently, without the need to modify global state.\n+\n+Inkeeping with the heirarchical isolation principle, scoped roles will only be assignable at the scope of the role\n+resource itself or a descendant scope.  For example, a `scoped_role` defined at `/staging` could be assigned to users\n+at `/staging` or `/staging/west`, but not at `/prod` or `/prod/west`. This ensures that role editing privileges in\n+one scope cannot be used to affect permissions in another scope.\n+\n+As an additional layer of control, it will be possible to constrain the assignable scopes of a scoped role to\n+an explicitly defined subset. For example, a scoped role defined at `/staging` could be\n+configured be assignable at `/staging/west` and `/staging/east`, but not at `/staging` or `/staging/central`\n+by specifying `assignable_scopes: [\"/staging/west\", \"/staging/east\"]` in the role spec. This has a few important\n+benefits. First, by allowing this extra layer of control, we allows scoped roles to be used in a manner similar\n+to a \"role template\". If two different scopes need similar roles, a parent scope can provide a common definition.\n+Second, separating the concerns of scoping role definition and assignment ensures that admins can accurately express\n+intent and prevent misuse.\n+\n+A `scoped_role` resource for scoped admins might look like something like this:\n+\n+```yaml\n+kind: scoped_role\n+metadata:\n+  name: staging-admin\n+  description: Basic administrative privileges for staging env admins\n+scope: /staging\n+spec:\n+  assignable_scopes:\n+    - /staging/west\n+    - /staging/east\n+  allow:\n+    rules:\n+    - kind: scoped_token\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role_assignment\n+      verbs: [create, read, update, delete]\n+version: v1\n+```\n+\n+Note that other than the `scope` and `spec.assignable_scopes` fields, this is identical to a standard teleport role\n+definition.  Keeping this parity ensures ease of transition and reduces cognitive load for users familiar with\n+existing teleport concepts. It also saves us considerable effort since most of the existing role evaluation logic\n+can be reused.\n+\n+\n+### Scoped Tokens and Joining\n+\n+The scope of an agent will be determined by their join tokens. Scoped administrators will be able to create join tokens\n+assigned to scopes where they have `token:create` permissions. When an agent joins the teleport cluster using a scoped\n+join token, the agent will be automatically assigned that scope.\n+\n+Creation of scoped join tokens will mirror the existing token creation API where possible. Ex:\n+\n+```shell\n+$ tctl scoped token add --type=node --scope=/staging/west",
        "comment_created_at": "2025-09-02T19:28:16+00:00",
        "comment_author": "zmb3",
        "comment_body": "Seems reasonable, and makes a lot of sense on the second read, now that I see:\r\n\r\n> Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\r\nof scoping once they have logged in to the appropriate scope.\r\n\r\nSo the design goal is to both:\r\n- make it obvious and explicit for **admins** when they're working with scopes\r\n- make the concept of scopes largely disappear for **ordinary users**",
        "pr_file_module": null
      },
      {
        "comment_id": "2316991799",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2316357112",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.\n+\n+\n+### A Scoped Access Check\n+\n+In order to conform to our core isolation and heirarchy goals, the form of scoped access checking will need to diverge\n+somewhat from classic teleport access checks.  Ordinarily, in teleport code, an access check is a one-off decision, the\n+pseudocode of which would look something like this:\n+\n+```go\n+roles := LoadRolesForUser(cert)\n+\n+if CanAccessResource(roles, resource) {\n+    parameters := GetAccessConstraints(roles, resource)\n+    return Permit(parameters)\n+} else {\n+    return Denial\n+}\n+```\n+\n+Note that allow decisions are not binary. There are often parameters that affect the nature of allowed access (e.g. allowed\n+ssh access may come with or without X11 forwarding enabled).\n+\n+Per our scoping design goals, one of our key criteria is that administrative permissions assigned at a child scope cannot\n+be used to affect the nature of resources/permissions at a parent scope.  This means that we cannot allow permissions in\n+a child scope to modify the parameters of access that is permitted at a parent scope. We therefore end up with an access\n+check flow that looks something like this:\n+\n+```go\n+if !PinScopeAllowsAccessToResourceScope(cert.ScopePin, resource.GetScope()) {\n+    return Denial\n+}\n+\n+var roles []Role\n+for scope := range DescendScopeHeirarchy(resource.GetScope()) { // \"/staging/west\" -> [\"/\", \"/staging\", \"/staging/west\"]\n+    roles = append(roles, LoadRolesForUserAtScope(cert, scope)...)\n+    if CanAccessResource(roles, resource) {\n+        parameters := GetAccessConstraints(roles, resource)\n+        return Permit(parameters)\n+    }\n+}\n+\n+return Denial\n+```\n+\n+Note that we start from the uppermost parent scope, and iteratively descend. At the first scope where access is allowed,\n+we determine the full parameters of access *at that scope*. Assignment of additional roles/permissions at child scopes\n+have no effect per scope isolation rules.\n+\n+\n+### Scoped Roles and Assignments\n+\n+A new `scoped_role` type will be introduced for the purpose of defining scoped permissions. This type will implement\n+a subset of the features of the existing `role` type, with features being ported over iteratively over time.\n+\n+Classical teleport roles are assigned to users by directly editing the user resource's `roles` field. This centralized\n+approach is not inkeeping with the goal of delegated/limited administration.  Instead, scoped roles will be assigned\n+via a separate scoped assignment resource.  Admins of a given scope will be able to create scoped role assignments\n+for users independently, without the need to modify global state.\n+\n+Inkeeping with the heirarchical isolation principle, scoped roles will only be assignable at the scope of the role\n+resource itself or a descendant scope.  For example, a `scoped_role` defined at `/staging` could be assigned to users\n+at `/staging` or `/staging/west`, but not at `/prod` or `/prod/west`. This ensures that role editing privileges in\n+one scope cannot be used to affect permissions in another scope.\n+\n+As an additional layer of control, it will be possible to constrain the assignable scopes of a scoped role to\n+an explicitly defined subset. For example, a scoped role defined at `/staging` could be\n+configured be assignable at `/staging/west` and `/staging/east`, but not at `/staging` or `/staging/central`\n+by specifying `assignable_scopes: [\"/staging/west\", \"/staging/east\"]` in the role spec. This has a few important\n+benefits. First, by allowing this extra layer of control, we allows scoped roles to be used in a manner similar\n+to a \"role template\". If two different scopes need similar roles, a parent scope can provide a common definition.\n+Second, separating the concerns of scoping role definition and assignment ensures that admins can accurately express\n+intent and prevent misuse.\n+\n+A `scoped_role` resource for scoped admins might look like something like this:\n+\n+```yaml\n+kind: scoped_role\n+metadata:\n+  name: staging-admin\n+  description: Basic administrative privileges for staging env admins\n+scope: /staging\n+spec:\n+  assignable_scopes:\n+    - /staging/west\n+    - /staging/east\n+  allow:\n+    rules:\n+    - kind: scoped_token\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role\n+      verbs: [create, read, update, delete]\n+    - kind: scoped_role_assignment\n+      verbs: [create, read, update, delete]\n+version: v1\n+```\n+\n+Note that other than the `scope` and `spec.assignable_scopes` fields, this is identical to a standard teleport role\n+definition.  Keeping this parity ensures ease of transition and reduces cognitive load for users familiar with\n+existing teleport concepts. It also saves us considerable effort since most of the existing role evaluation logic\n+can be reused.\n+\n+\n+### Scoped Tokens and Joining\n+\n+The scope of an agent will be determined by their join tokens. Scoped administrators will be able to create join tokens\n+assigned to scopes where they have `token:create` permissions. When an agent joins the teleport cluster using a scoped\n+join token, the agent will be automatically assigned that scope.\n+\n+Creation of scoped join tokens will mirror the existing token creation API where possible. Ex:\n+\n+```shell\n+$ tctl scoped token add --type=node --scope=/staging/west",
        "comment_created_at": "2025-09-02T19:38:00+00:00",
        "comment_author": "fspmarshall",
        "comment_body": "Exactly, yes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2320541742",
    "pr_number": 58518,
    "pr_file": "rfd/XXXX-scopes.md",
    "created_at": "2025-09-04T00:45:40+00:00",
    "commented_code": "+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2320541742",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2320541742",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.",
        "comment_created_at": "2025-09-04T00:45:40+00:00",
        "comment_author": "Joerger",
        "comment_body": "This seems useful, but also likely to cause friction. Depending on the nature of an admin's work, they may lose track of what scope they are currently logged into and accidentally add or edit a resource in the wrong scope.\r\n\r\nI'm guessing users can check their pinned scope with `tsh status`? Would we consider adding a `y/n` prompt to confirm the scope when creating resources, with a CLI flag to skip the prompt? Perhaps it could even just be added to the MFA for Admin Actions prompt.",
        "pr_file_module": null
      },
      {
        "comment_id": "2323754176",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58518,
        "pr_file": "rfd/XXXX-scopes.md",
        "discussion_id": "2320541742",
        "commented_code": "@@ -0,0 +1,438 @@\n+---\n+authors: Forrest Marshall (forrest@goteleport.com)\n+state: draft\n+---\n+\n+# RFD XXXX - Scopes\n+\n+## What\n+\n+A system for heirarchical organization and isolation for resources and permissions.\n+\n+\n+## Why\n+\n+Historically, teleport's resource and permission organization systems have been very \"flat\". In particular,\n+administrative and resource-provisioning permissions tend to be \"all or nothing\". Resource labels and selectors\n+allow organization of resources/permissions, but said organization can only be performed by what are effectively\n+global admins. Any user with the ability to create node join tokens can join any node to the cluster\n+with any labels they like. Similarly, a user with role creation permissions can create a role that grants access\n+to anything. This poses a significant challenge when trying to delegate any meaningful responsibility and/or to\n+apply the prinicial of least privilege to users that need to administer resources/permissions in an meaningful way.\n+\n+Similarly, teleport user credentials tend to be all or nothing. There isn't a good way to get credentials that\n+are only useable for the specific task at hand. Instead, if a user is logged into a teleport cluster they always\n+have all their available permissions applied. This increases blast radius, both in terms of compromise and accidental\n+misuse.\n+\n+We would like to provide a mechanism for organizing resources and permissions in a manner that allows for both\n+isolation and heirarchy. This system should support admins that have powerful control over provisioning of, and\n+access to, resources within their domain of influence. Said admin privileges must not be able to affect resources\n+and permissions outside the scope of their domain(s). We would also like to provide means of limiting the blast\n+radius of compromise/misuse as part of this organizational system. Finally, we require that this organizational\n+system be backwards compatible with existing teleport resources, permissions, and usage patterns to the greatest\n+extent possible.\n+\n+\n+## Intro\n+\n+### Overview\n+\n+We will introduce the concept of a \"scope\" as a new means of organizing resources and permissions. The scope of\n+a resource or permission will be a simple attribute formatted as a path-like string (e.g. `/staging/west`, `/prod/east`,\n+etc).\n+\n+Permissions that are scoped will apply only to resources of the same scope, or a descendant scope. For example, having\n+permission to ssh into nodes assigned at scope `/staging` will permit ssh access for nodes that have a scope of `/staging`\n+or `/staging/west`, but not `/prod` or `/prod/west`.\n+\n+Scoping will apply to administrative privileges as well. A user with the the permission to join teleport nodes assigned\n+at `/staging` will *only* be able to join nodes with that scope or a descendant scope. Same goes for role creation/assignment,\n+with users effectively being able to be granted admin-like powers \"within\" a scope but not outside of it.\n+\n+In order to improve useability and reduce blast radius of compromise/misuse, we will also introduce the concept of scope\n+\"pinning\". Rather than logging into the teleport cluster as a whole, users will be able to login to a specific scope. This\n+will result in the credentials granted to the user *only* being usable for the target scope and its descendants. For example,\n+if a user has permissions at `/prod` and `/staging`, and logs in to `/staging`, they will only be able to see and interact\n+with `/staging` scoped resources.\n+\n+We will be targeting a basic user experience that looks something like this:\n+\n+```shell\n+$ tsh login --scope=/staging/east\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-east ...     ...\n+\n+$ tsh ssh some-node-east\n+# success\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+\n+$ tsh ls\n+Node Name      Address Labels\n+-------------- ------- ------\n+some-node-west ...     ...\n+\n+$ tsh ssh some-node-east\n+ERROR: access denied\n+\n+$ tsh ssh some-node-west\n+# success\n+```\n+\n+Note that the nature of commands after login are unchanged. Ordinary (non-admin) users should be able to ignore the concept\n+of scoping once they have logged in to the appropriate scope. Scripts that work today with an already logged-in `tsh` should\n+continue to function as expected with scoped credentials, with the only change being that the resources affected by the opeartions\n+are now limited to the subset assigned to the pinned scope.\n+\n+Scoping will be a large and complex feature to implement, as it will meaningfully change most access-control\n+checks and APIs in teleport. In order to make this transition more manageable, we will be gradually implementing scoped\n+features over time, with the initial scopes MVP only providing very basic scoped joining, role management, and ssh access.\n+The intent will be that users will be able to start adopting a mixed use style as scope features become sufficiently robust\n+to start addressing their specific usecases.\n+\n+\n+### Scoping Semantics\n+\n+A scope is a simple path-like string (e.g. `/staging/west`). A resource will be said to be \"scoped\" if it has a `scope` attribute\n+that obeys this format. Likewise, a permission will be scoped if it is granted by a configuration resource with a\n+`scope` attribute.\n+\n+Scopes are heirarchical. The scope `/staging` is a \"parent\" of `/staging/west`, and `/staging/west` is a \"child\" of `/staging`.\n+Permissions granted at a parent scope apply to all child scopes.\n+\n+Scope heirarchy is segment based, not prefix based. I.e. `/staging` is a parent of `/staging/west`, but not of `/stagingwest`.\n+\n+Scopes are attributes, not objects. There is no need to create a scope object before creating a resource with a given\n+scope attribute. I.e. if no resource exists with scope `/staging/west`, a node can still be created with that scope without\n+first performing any kind of scope setup/creation/configuration ceremony.\n+\n+\n+### Core Design Goals\n+\n+**Heirarchical Isolation**: Permissions within a given scope cannot be used to \"reach up\" and affect resources/access defined\n+in parent scopes or \"reach across\" and affect resources/access defined in orthogonal scopes.\n+\n+**Blast Radius Reduction**: Scoping will be a robust tool for further reducing the blast radius of compromised or misused\n+credentials.\n+\n+**Delegated/Limited Administration**: Scoping will unlock the ability to create \"scoped admins\" with powerful control over\n+resources and permissions within their scopes, without being able to affect resources/permissions outside of their scope.\n+\n+**Minimal Effect on User Experience**: After selecting the scope to login to, the user experience for normal (non-administrative)\n+tasks will be unchanged.\n+\n+**Backwards Compatibility**: Scoping will not change the function or meaning of existing teleport resources/permissions.\n+\n+**Gradual Rollout and Adoption**: Scoping features will be rolled out gradually and mixed use of scoped and unscoped\n+resources/permissions will be supported.\n+\n+\n+### Comparison to Other Systems\n+\n+Scoping has a lot in common with systems like the AWS organization/account model, GCP's folder/project model, and Azure's\n+own RBAC scopes. Scopes differ in a few key ways:\n+\n+- Scopes are arbitrarily heirarchical. Resources can be assigned at any level of the heirarchy. Other similar systems tend\n+  to have a heirarchy where all resources live in the leaf nodes, and often the depth of the heirarchy is fixed.\n+\n+- Scopes are an attribute, not an object. There is no additional creation step like there would be with a system that organizes\n+  resources into accounts/projects/etc. Other systems tend to require the heirarchy be defined separately as a standalone entity\n+  prior to resources being created.\n+\n+- Credentials can be pinned to arbitrarily narrow scopes. A user can opt to access a resource in `/staging/west` by logging\n+  into `/staging` *or* logging into `/staging/west`. This gives granular control over the blast radius of credentials, and\n+  ensures that heirarchies and practices can evolve and refine over time without needing to be fully rebuilt. By virtue of\n+  the fixed leaf nodes of other systems, options for constraint of credentials via the organizing heirarchy tend to be more\n+  limited.\n+\n+\n+## Details\n+\n+### Scoping of Resources\n+\n+Within teleport's existing resource format, `scope` will be a new top-level field of type `string`.  Ex:\n+\n+```yaml\n+kind: example_resource\n+metadata:\n+  name: example\n+scope: /staging/west # this resource is \"scoped\" to /staging/west\n+spec:\n+  # ...\n+version: v1\n+```\n+\n+For inventory/presence resources like ssh servers, kubernetes clusters, etc, we can add the `scope` field to the existing\n+resource type without much fear of compatibility issues.  Existing resources that do not have a `scope` field can be thought\n+of as being assigned to the \"root\" of the scope heirarchy (this is mostly a philosophical point, as we do not plan to support\n+permission assignment at root for the time being), and will not be accessible via scoped permissions.\n+\n+For resources that grant permissions (e.g. roles), the story is more complicated. Assignment of scoped permissions doesn't mesh\n+well with existing permission-granting resources.  For these types, we will need to have new special scoped variants with\n+separate APIs. For example, we will be introducing a new `scoped_role` type which will implement a compatible subset of the\n+functionality of the `role` type and serve the same purpose when using scoping to organize permissions.\n+\n+This bimodal approach to resource scoping is inkeeping with our user-facing design goal. The resources/apis that ordinary\n+(non-admin) users interact with will remain unchanged except for the addition of the scope field (which said users can safely\n+ignore). Administrative APIs/types will receive scope-specific variants that will be tailored to the needs of scoped\n+administration.\n+\n+\n+### Scope Pinning\n+\n+Scope \"pinning\" is the term we will use for the process of logging into and being granted credentials for a specific scope.\n+A user certificate issued in this way will contain a `ScopePin` field which will constrain all subsequent actions by the\n+user to the pinned scope and its descendants.  A certificate of this kind will be said to be \"pinned\" to the given scope.\n+\n+Users will be able to pin to a scope by passing the `--scope` flag to `tsh login`.  If no scope is specified, the user will be\n+logged in normally, with whatever unscoped privileges they have.\n+\n+In order to ensure that users are able to make effective use of their scoped privileges, users will be able to list the scopes\n+for which they have assigned permissions:\n+\n+```shell\n+$ tsh scopes ls\n+/staging/west\n+/staging/east\n+/prod/west\n+/prod/east\n+\n+$ tsh scopes ls --verbose\n+Scope                 Roles\n+--------------------- -----------------------\n+/staging/west         access, auditor, editor\n+/staging/east         access, auditor, editor\n+/prod/west            access\n+/prod/east            access\n+\n+$ tsh login --scope=/staging/west\n+# authentication flow\n+```\n+\n+For ease of use, we will also provide a shortcut for reauthenticating to a different scope while keeping all other `tsh login`\n+parameters unchanged:\n+\n+```shell\n+$ tsh scopes login /staging/west\n+# authentication flow\n+```\n+\n+Within teleport's internals, the scope pin will serve as an additional constraint on all access-control checks. We will require\n+that any attempted resource access first be against a resource that is scoped to the pinned scope or a descendant scope. If this\n+check does not pass, access is denied without the need to load or evaluate any other permissions.\n+\n+Pinned scope will also provide a default value for APIs that accept scope parameters.  For example, a scoped admin creating\n+a join token will automatically have the token created at their pinned scope unless they explicitly specify something else.\n+In this way, scope pinning will provide a means of reducing the friction associated with scoped administration since most admins\n+will simply log directly into the scope they wish to administer.",
        "comment_created_at": "2025-09-04T23:39:49+00:00",
        "comment_author": "fspmarshall",
        "comment_body": "This is a good point.  We're concerned that requiring too much explicit scope specification may be cumbersome, but accidental misuse is a potential issue too.  Will need to give it more thought vis-a-vis where we draw the line.\r\n\r\n> I'm guessing users can check their pinned scope with tsh status? \r\n\r\nYes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1487078522",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-02-13T02:37:28+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1487078522",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1487078522",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. ",
        "comment_created_at": "2024-02-13T02:37:28+00:00",
        "comment_author": "nklaassen",
        "comment_body": "I think the reason for this is so resource_group admins have more control then anyone who can edit the inline spec, and that makes sense to me, but I think it is counter-intuitive because the inline definition is more specific, and people will try to use it the opposite way, and if we silently override it users will be confused",
        "pr_file_module": null
      },
      {
        "comment_id": "1493087883",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1487078522",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. ",
        "comment_created_at": "2024-02-17T00:04:32+00:00",
        "comment_author": "klizhentas",
        "comment_body": "Removed this part as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1489419897",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-02-14T12:51:55+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1489419897",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1489419897",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. ",
        "comment_created_at": "2024-02-14T12:51:55+00:00",
        "comment_author": "tigrato",
        "comment_body": "Should we prefer the opposite?\r\n\r\nIf you have root access to node A and you edit its labels, you can only affect resource A. If by any chance, you gain some sort of credentials that you can edit/affect the centralized assignment, you end up in situations of lateral movement. \r\nA user holding compromised credentials that grant RW permissions to those assignments (I am thinking about Teleport infra structure creds) can easily manipulate them and trick nodes to move from resource group A to resource group B for which he has full access.",
        "pr_file_module": null
      },
      {
        "comment_id": "1493088952",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1489419897",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. ",
        "comment_created_at": "2024-02-17T00:07:27+00:00",
        "comment_author": "klizhentas",
        "comment_body": "We should prefer centralized assignment over decentralized. I've seen more customers concerned over the latter - e.g. the node that is compromised can update it's labels. This PR allows the usual decentralized flow - but in the new design case admin can choose to ignore the labels when it comes to assignment of nodes to resource groups.",
        "pr_file_module": null
      },
      {
        "comment_id": "1493089445",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1489419897",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. ",
        "comment_created_at": "2024-02-17T00:08:41+00:00",
        "comment_author": "klizhentas",
        "comment_body": "A user who can create/delete resource groups is de-facto teleport cluster admin, I agree with that, but I think it's OK risk to take. I will add a note that resource group assignment is administrative action that should be protected by MFA.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1489439036",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-02-14T13:08:52+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1489439036",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1489439036",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users. ",
        "comment_created_at": "2024-02-14T13:08:52+00:00",
        "comment_author": "tigrato",
        "comment_body": "should we separate these global resources out of the role and we keep the roles for scoped resources.\r\n\r\nCluster-wide configurations for most resources should be tracked using a different resource type to prevent any incorrect concealment of permissions like the one described in https://github.com/gravitational/teleport.e/issues/3111\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1493491201",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1489439036",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users. ",
        "comment_created_at": "2024-02-18T00:16:07+00:00",
        "comment_author": "klizhentas",
        "comment_body": "Interesting idea, let me think about it. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1511968158",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1489439036",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users. ",
        "comment_created_at": "2024-03-05T00:17:48+00:00",
        "comment_author": "klizhentas",
        "comment_body": "I've introduced an `admin:` scope to address this issue instead of creating a separate resource, take a look.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1490855143",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-02-15T11:20:25+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users. \n+\n+That\u2019s why we will prohibit creating those resources by roles granted by any scope other than the root. \n+\n+Here is a list of resources that can\u2019t be created at scopes:\n+\n+* SSO connectors\n+* Users\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+### Features we will depreciate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined  in the start of this RFD and review how the new system will  help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scope: '/dev/lab`\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+K8s access to specific clusters\n+\n+Teleport can autodiscover clusters echo and bravo with namespaces default and prod, creating the following resource group hierarchy:\n+\n+```\n+/k8s/namespaces/prod/bravo\n+/k8s/namespaces/prod/echo\n+\n+/k8s/namespaces/default/bravo\n+/k8s/namespaces/default/echo\n+```\n+\n+Note that here we have set namespaces, and not cluster names as the root of the resource hierarchy,\n+so we can group different cluster names by namespace.\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scope:  '/k8s/namespaces/default`\n+  members:\n+    - bob@example.com\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/dev`\n+  members:\n+    - bob@example.com\n+ - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/dev`\n+  member_lists:\n+    - dev-team\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-stage\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/prod`\n+  member_lists:\n+    - dev-team\n+```\n+\n+**Note:** We have to make sure that the child access list is a strict subset of the roles, traits and scopes of it's parent or has no scopes or grants at all.\n+\n+### Scoped Impersonation",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1490855143",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1490855143",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users. \n+\n+That\u2019s why we will prohibit creating those resources by roles granted by any scope other than the root. \n+\n+Here is a list of resources that can\u2019t be created at scopes:\n+\n+* SSO connectors\n+* Users\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+### Features we will depreciate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined  in the start of this RFD and review how the new system will  help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scope: '/dev/lab`\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+K8s access to specific clusters\n+\n+Teleport can autodiscover clusters echo and bravo with namespaces default and prod, creating the following resource group hierarchy:\n+\n+```\n+/k8s/namespaces/prod/bravo\n+/k8s/namespaces/prod/echo\n+\n+/k8s/namespaces/default/bravo\n+/k8s/namespaces/default/echo\n+```\n+\n+Note that here we have set namespaces, and not cluster names as the root of the resource hierarchy,\n+so we can group different cluster names by namespace.\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scope:  '/k8s/namespaces/default`\n+  members:\n+    - bob@example.com\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/dev`\n+  members:\n+    - bob@example.com\n+ - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/dev`\n+  member_lists:\n+    - dev-team\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-stage\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/prod`\n+  member_lists:\n+    - dev-team\n+```\n+\n+**Note:** We have to make sure that the child access list is a strict subset of the roles, traits and scopes of it's parent or has no scopes or grants at all.\n+\n+### Scoped Impersonation",
        "comment_created_at": "2024-02-15T11:20:25+00:00",
        "comment_author": "strideynet",
        "comment_body": "Perhaps my thoughts here are a little tangential to this RFD, but part of me has been wondering whether impersonation is something we need to support externally long-term. Historically, it has been a useful tool in producing long-lived credentials for a Teleport user to act as a service account from machine to machine environments like CI/CD, but Machine ID is now the golden path for this. Recent changes (e.g requiring MFA for Admin RPCs) has made impersonation even less useful with tools like our Terraform provider or `tctl`.\r\n\r\nPerhaps the only usecase I can see into the future is for those trying to debug their RBAC - and assuming a user is the best way of exploring their access. However, we could potentially build out other tools that make this easier (e.g a CLI or UI tool that allows the RBAC configuration to be tested for a given user/roleset)",
        "pr_file_module": null
      },
      {
        "comment_id": "1506810777",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1490855143",
        "commented_code": "@@ -0,0 +1,956 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+     - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a cluster resource group.\n+\n+We will also restrict a resource to be a member of only one resource group at a time.  \n+It\u2019s tempting to have a resource to be assigned to multiple resource groups, but we push this out of the scope of this RFD for simplicity.\n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+Such centralized assignment will also ensure that one resource can be only assigned to one resource group at a time.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+Centralized assignment should take precedence over any resource based one, in case of a conflict. \n+By default all resources are assigned to the root - a cluster.\n+\n+Resource groups are hierarchical, and we can refer to the lab resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scope: \u2018/env/prod/lab`\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scope: '/env/prod`\n+```\n+\n+Grantable scope specifies maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scope` is missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  grants_scope: /env/prod/lab\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with a `parent_resource_group` will bind any resource using this join method to the resource group specified in `parent_resource_group` or a more specific one. \n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-cluster scopes\n+\n+Some resources don't have a clear cut behavior at certain scopes, like SSO connectors, or are difficult to define, like users. \n+\n+That\u2019s why we will prohibit creating those resources by roles granted by any scope other than the root. \n+\n+Here is a list of resources that can\u2019t be created at scopes:\n+\n+* SSO connectors\n+* Users\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+### Features we will depreciate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined  in the start of this RFD and review how the new system will  help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scope: '/dev/lab`\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+K8s access to specific clusters\n+\n+Teleport can autodiscover clusters echo and bravo with namespaces default and prod, creating the following resource group hierarchy:\n+\n+```\n+/k8s/namespaces/prod/bravo\n+/k8s/namespaces/prod/echo\n+\n+/k8s/namespaces/default/bravo\n+/k8s/namespaces/default/echo\n+```\n+\n+Note that here we have set namespaces, and not cluster names as the root of the resource hierarchy,\n+so we can group different cluster names by namespace.\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scope:  '/k8s/namespaces/default`\n+  members:\n+    - bob@example.com\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/dev`\n+  members:\n+    - bob@example.com\n+ - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/dev`\n+  member_lists:\n+    - dev-team\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-stage\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scope:  '/prod`\n+  member_lists:\n+    - dev-team\n+```\n+\n+**Note:** We have to make sure that the child access list is a strict subset of the roles, traits and scopes of it's parent or has no scopes or grants at all.\n+\n+### Scoped Impersonation",
        "comment_created_at": "2024-02-28T23:52:26+00:00",
        "comment_author": "klizhentas",
        "comment_body": "I'd keep this out of scope of this RFD. We likely have a lot of customers leveraging impersonation. I think it would work as is with the new design, and you can plan transition to a better model when convenient for Machine ID.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1502676866",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-02-26T14:11:19+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significanly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]\n+```\n+\n+When granted at scope, the role above will deny access to any apps in this scope.\n+\n+We will use `access` verb during migration. The following V7 and V8 roles are equivalent:\n+\n+```yaml\n+kind: role\n+version: V7\n+metadata:\n+   name: all-apps\n+spec:\n+  app_labels:\n+    '*': '*'\n+```\n+\n+```yaml\n+kind: role\n+version: V8\n+metadata:\n+   name: all-apps\n+spec:\n+  allow:\n+    rules:\n+    - resources: [app]\n+      verbs: [access]\n+```\n+\n+We will use the verb `access` for any supported resource, `node`, `k8s`, `db`, `app`, `desktop`, etc.\n+\n+Most of Teleport's preset roles have labels `*`: `*`, so migration will be straightforward.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with `scopes` present will limit the resource groups the resources can join to.\n+\n+For example, Teleport service using the scoped token below will only be able to join the resource group `dev`\n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  scopes: ['/dev']\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens with a `parent_resource_group` set can only have scope equal to this resource group.\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` and `scopes` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`. \n+\n+**Note:** To implement this, the token can be exchanged for the host certificate with `parent_resource_id` encoded in it. This way nodes can't set the nodes to any resource groups other than the parent.\n+By default, all existing join tokens will use `/` as a default resource group.\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-admin scope\n+\n+Some resources don't have a clear cut behavior at nested scopes, like SSO connectors, or are difficult to define, like for users. To address this issue, we will define a new `admin:` scope hierarchy that is parallel\n+to the `/` hierarchy and will require roles that grant access to this set of resources to use this and only this hierarchy.\n+\n+Here is a list of resources that can\u2019t be created at any scopes other than `admin:`\n+\n+* SSO connectors\n+* Users\n+* Bots\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+In the `V7` role version, we will let users to mix `admin:` scope that includes resources other than `admin:`, however in role `V8` we will require the role to **only** include the admin scope resources:\n+\n+```yaml\n+kind: role\n+version: v8\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  grantable_scopes: 'admin:'\n+  allow:\n+    # only admin scope is allowed in V8, \n+    rules:\n+      - resources: [user, bot]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+Access lists that grant roles in `admin:` scope also have to have scopes to be explicitly set to only `admin:` scope and nothing else.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  # only root and `admin:` scope is allowed if grants include roles that contain resources requiring `admin:` scope.\n+  scopes: ['admin:']\n+  members:\n+    - bob@example.com\n+```\n+\n+This will help to separate non-admin and admin resources more clearly and in the UI we should mark roles and access list in `admin:` scopes with label `admin`.\n+\n+### Trusted Clusters\n+\n+With new scoped RBAC approach, leaf clusters will sync users from the root cluster, similarly to how we sync users from Okta via SCIM. \n+Leaf clusters will also sync root cluster's Access Lists similarly to how Teleport syncs access lists from Okta, see RFD 0019e - Okta Access Lists Sync.\n+Combined together, Users and Access Lists sync will let leaf clusters mirror permissions from the root cluster, while remaining independent, as leafs can have their own access lists and users.\n+\n+To let users access resources in specific clusters, we will use `/=leafs/[cluster-name]` scope. Leafs hierarchy is a part of a root `/` cluster hierarchy. This will allow transparent migration of resources. To avoid name collisions we will reserve paths that contain `=` and will prohibit users from creating resource groups that have character `=` in them.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Leaf clusters syncing access lists and users from the root clusters should avoid name collisions - if a local or SSO leaf cluster, role or access list exists, the sync should avoid overwriting the local leaf cluster data, emitting audit event that mentions that the system did not sync the list.\n+\n+This architecture lets leafs to have their own indpendent grants, while mirroring users, access lists from the root, which represents majority of today's use cases.\n+\n+### Features we will deprecate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined  in the start of this RFD and review how the new system will  help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+K8s access to specific clusters\n+\n+Teleport can autodiscover clusters echo and bravo with namespaces default and prod, creating the following resource group hierarchy:\n+\n+```\n+/k8s/namespaces/prod/bravo\n+/k8s/namespaces/prod/echo\n+\n+/k8s/namespaces/default/bravo\n+/k8s/namespaces/default/echo\n+```\n+\n+Note that here we have set namespaces, and not cluster names as the root of the resource hierarchy,\n+so we can group different cluster names by namespace.\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes:  ['/k8s/namespaces/default']\n+  members:\n+    - bob@example.com\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  member_lists:\n+    - dev-team\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-stage\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/prod']\n+  member_lists:\n+    - dev-team\n+```\n+\n+**Note:** We have to make sure that the child access list is a strict subset of the roles, traits and scopes of it's parent or has no scopes or grants at all.\n+\n+### Scoped Impersonation\n+\n+To make sure Alice and Ketanji can impersonate Jenkins, but only when accessing dev infrastructure, we will grant impersonator role via access list with scope `/dev`\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-dev\n+spec:\n+  grants: \n+    roles: [impersonator]\n+  scopes:  ['/dev']\n+  members:\n+    - alice@example.com\n+    - ketanji@example.com\n+```\n+\n+### Scoped admins\n+\n+Large organizations would like to grant some users admin rights scoped for part of the infrastructure. \n+Scoped admins can manage access to users and resources within the scopes of their access lists and resource groups.\n+\n+Let\u2019s review how we can create a scoped admin structure and even let delegated admins create new roles in the scopes of their environments.\n+Scoped admins can create new roles, and access lists, however only if those roles have `grantable_scopes` and access lists have `scope` equal or more specific \n+than the scope of the granted roles of admins.\n+\n+Let\u2019s say Alice would like to delegate admin rights for the lab environment to Ketanji and Bob:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: scoped-dev-admin-dev\n+spec:\n+  scopes: ['/dev/lab']\n+  grants: \n+  roles: [editor, auditor]\n+  members:\n+    - bob@example.com\n+    - ketanji@example.com\n+```\n+\n+Ketanji can now create roles, access lists and join tokens, but they all will have scopes set to /dev/lab\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  grantable_scope: '/dev/lab'\n+  parent_resource_group: '/dev/lab' \n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+---\n+kind: access_list\n+metadata:\n+  name: scoped-dev-admin-dev-access\n+spec:\n+  parent_resource_group: '/dev/lab'\n+  scopes: ['/dev/lab']\n+  grants: \n+  roles: [access]\n+  members:\n+    - bob@example.com\n+    - ketanji@example.com\n+---\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev/lab'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+By propagating scope for any resource created by a user leveraging the roles the granted scope, \n+we  make sure that our security invariant remains - Ketanji and Bob can\u2019t expand the scope of their cluster access beyond /dev/lab.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1502676866",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1502676866",
        "commented_code": "@@ -0,0 +1,1122 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significanly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]\n+```\n+\n+When granted at scope, the role above will deny access to any apps in this scope.\n+\n+We will use `access` verb during migration. The following V7 and V8 roles are equivalent:\n+\n+```yaml\n+kind: role\n+version: V7\n+metadata:\n+   name: all-apps\n+spec:\n+  app_labels:\n+    '*': '*'\n+```\n+\n+```yaml\n+kind: role\n+version: V8\n+metadata:\n+   name: all-apps\n+spec:\n+  allow:\n+    rules:\n+    - resources: [app]\n+      verbs: [access]\n+```\n+\n+We will use the verb `access` for any supported resource, `node`, `k8s`, `db`, `app`, `desktop`, etc.\n+\n+Most of Teleport's preset roles have labels `*`: `*`, so migration will be straightforward.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with `scopes` present will limit the resource groups the resources can join to.\n+\n+For example, Teleport service using the scoped token below will only be able to join the resource group `dev`\n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  scopes: ['/dev']\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens with a `parent_resource_group` set can only have scope equal to this resource group.\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` and `scopes` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`. \n+\n+**Note:** To implement this, the token can be exchanged for the host certificate with `parent_resource_id` encoded in it. This way nodes can't set the nodes to any resource groups other than the parent.\n+By default, all existing join tokens will use `/` as a default resource group.\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-admin scope\n+\n+Some resources don't have a clear cut behavior at nested scopes, like SSO connectors, or are difficult to define, like for users. To address this issue, we will define a new `admin:` scope hierarchy that is parallel\n+to the `/` hierarchy and will require roles that grant access to this set of resources to use this and only this hierarchy.\n+\n+Here is a list of resources that can\u2019t be created at any scopes other than `admin:`\n+\n+* SSO connectors\n+* Users\n+* Bots\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+In the `V7` role version, we will let users to mix `admin:` scope that includes resources other than `admin:`, however in role `V8` we will require the role to **only** include the admin scope resources:\n+\n+```yaml\n+kind: role\n+version: v8\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  grantable_scopes: 'admin:'\n+  allow:\n+    # only admin scope is allowed in V8, \n+    rules:\n+      - resources: [user, bot]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+Access lists that grant roles in `admin:` scope also have to have scopes to be explicitly set to only `admin:` scope and nothing else.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  # only root and `admin:` scope is allowed if grants include roles that contain resources requiring `admin:` scope.\n+  scopes: ['admin:']\n+  members:\n+    - bob@example.com\n+```\n+\n+This will help to separate non-admin and admin resources more clearly and in the UI we should mark roles and access list in `admin:` scopes with label `admin`.\n+\n+### Trusted Clusters\n+\n+With new scoped RBAC approach, leaf clusters will sync users from the root cluster, similarly to how we sync users from Okta via SCIM. \n+Leaf clusters will also sync root cluster's Access Lists similarly to how Teleport syncs access lists from Okta, see RFD 0019e - Okta Access Lists Sync.\n+Combined together, Users and Access Lists sync will let leaf clusters mirror permissions from the root cluster, while remaining independent, as leafs can have their own access lists and users.\n+\n+To let users access resources in specific clusters, we will use `/=leafs/[cluster-name]` scope. Leafs hierarchy is a part of a root `/` cluster hierarchy. This will allow transparent migration of resources. To avoid name collisions we will reserve paths that contain `=` and will prohibit users from creating resource groups that have character `=` in them.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Leaf clusters syncing access lists and users from the root clusters should avoid name collisions - if a local or SSO leaf cluster, role or access list exists, the sync should avoid overwriting the local leaf cluster data, emitting audit event that mentions that the system did not sync the list.\n+\n+This architecture lets leafs to have their own indpendent grants, while mirroring users, access lists from the root, which represents majority of today's use cases.\n+\n+### Features we will deprecate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined  in the start of this RFD and review how the new system will  help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+K8s access to specific clusters\n+\n+Teleport can autodiscover clusters echo and bravo with namespaces default and prod, creating the following resource group hierarchy:\n+\n+```\n+/k8s/namespaces/prod/bravo\n+/k8s/namespaces/prod/echo\n+\n+/k8s/namespaces/default/bravo\n+/k8s/namespaces/default/echo\n+```\n+\n+Note that here we have set namespaces, and not cluster names as the root of the resource hierarchy,\n+so we can group different cluster names by namespace.\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes:  ['/k8s/namespaces/default']\n+  members:\n+    - bob@example.com\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  member_lists:\n+    - dev-team\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-stage\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/prod']\n+  member_lists:\n+    - dev-team\n+```\n+\n+**Note:** We have to make sure that the child access list is a strict subset of the roles, traits and scopes of it's parent or has no scopes or grants at all.\n+\n+### Scoped Impersonation\n+\n+To make sure Alice and Ketanji can impersonate Jenkins, but only when accessing dev infrastructure, we will grant impersonator role via access list with scope `/dev`\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-dev\n+spec:\n+  grants: \n+    roles: [impersonator]\n+  scopes:  ['/dev']\n+  members:\n+    - alice@example.com\n+    - ketanji@example.com\n+```\n+\n+### Scoped admins\n+\n+Large organizations would like to grant some users admin rights scoped for part of the infrastructure. \n+Scoped admins can manage access to users and resources within the scopes of their access lists and resource groups.\n+\n+Let\u2019s review how we can create a scoped admin structure and even let delegated admins create new roles in the scopes of their environments.\n+Scoped admins can create new roles, and access lists, however only if those roles have `grantable_scopes` and access lists have `scope` equal or more specific \n+than the scope of the granted roles of admins.\n+\n+Let\u2019s say Alice would like to delegate admin rights for the lab environment to Ketanji and Bob:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: scoped-dev-admin-dev\n+spec:\n+  scopes: ['/dev/lab']\n+  grants: \n+  roles: [editor, auditor]\n+  members:\n+    - bob@example.com\n+    - ketanji@example.com\n+```\n+\n+Ketanji can now create roles, access lists and join tokens, but they all will have scopes set to /dev/lab\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  grantable_scope: '/dev/lab'\n+  parent_resource_group: '/dev/lab' \n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+---\n+kind: access_list\n+metadata:\n+  name: scoped-dev-admin-dev-access\n+spec:\n+  parent_resource_group: '/dev/lab'\n+  scopes: ['/dev/lab']\n+  grants: \n+  roles: [access]\n+  members:\n+    - bob@example.com\n+    - ketanji@example.com\n+---\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  parent_resource_group: '/dev/lab'\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+By propagating scope for any resource created by a user leveraging the roles the granted scope, \n+we  make sure that our security invariant remains - Ketanji and Bob can\u2019t expand the scope of their cluster access beyond /dev/lab.",
        "comment_created_at": "2024-02-26T14:11:19+00:00",
        "comment_author": "webvictim",
        "comment_body": "```suggestion\r\nwe make sure that our security invariant remains - Ketanji and Bob can\u2019t expand the scope of their cluster access beyond /dev/lab.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1573040729",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-04-19T22:52:50+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1573040729",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1573040729",
        "commented_code": "@@ -0,0 +1,1144 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]",
        "comment_created_at": "2024-04-19T22:52:50+00:00",
        "comment_author": "fspmarshall",
        "comment_body": "This is just an observation, but the intuition-breaking power of deny rules strikes again here.  At a glance, moving a role to a more specific/lower scope should equate to a privilege reduction, but if the role contains deny rules the effect may be to increase privilege.  Even in the world of scoping (whose biggest strength IMO is reigning in deny rules), they still break intuition.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075066937",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1573040729",
        "commented_code": "@@ -0,0 +1,1144 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]",
        "comment_created_at": "2025-05-06T09:17:20+00:00",
        "comment_author": "FireDrunk",
        "comment_body": "Maybe `scope` should be an immutable field to prevent this?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1573056237",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-04-19T23:44:19+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]\n+```\n+\n+When granted at scope, the role above will deny access to any apps in this scope.\n+\n+We will use `access` verb during migration. The following V7 and V8 roles are equivalent:\n+\n+```yaml\n+kind: role\n+version: V7\n+metadata:\n+   name: all-apps\n+spec:\n+  app_labels:\n+    '*': '*'\n+```\n+\n+```yaml\n+kind: role\n+version: V8\n+metadata:\n+   name: all-apps\n+spec:\n+  allow:\n+    rules:\n+    - resources: [app]\n+      verbs: [access]\n+```\n+\n+We will use the verb `access` for any supported resource, `node`, `k8s`, `db`, `app`, `desktop`, etc.\n+\n+Most of Teleport's preset roles have labels `*`: `*`, so migration will be straightforward.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with `scopes` present will limit the resource groups the resources can join to.\n+\n+For example, Teleport service using the scoped token below will only be able to join the resource group `dev`\n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  scopes: ['/dev']\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens with a `parent_resource_group` set can only have scope equal to this resource group.\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` and `scopes` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`. \n+\n+**Note:** To implement this, the token can be exchanged for the host certificate with `parent_resource_id` encoded in it. This way nodes can't set the nodes to any resource groups other than the parent.\n+By default, all existing join tokens will use `/` as a default resource group.\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-admin scope\n+\n+Some resources don't have a clear cut behavior at nested scopes, like SSO connectors, or are difficult to define, like for users. To address this issue, we will define a new `admin:` scope hierarchy that is parallel\n+to the `/` hierarchy and will require roles that grant access to this set of resources to use this and only this hierarchy.\n+\n+Here is a list of resources that can\u2019t be created at any scopes other than `admin:`\n+\n+* SSO connectors\n+* Users\n+* Bots\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+In the `V7` role version, we will let users to mix `admin:` scope that includes resources other than `admin:`, however in role `V8` we will require the role to **only** include the admin scope resources:\n+\n+```yaml\n+kind: role\n+version: v8\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  grantable_scopes: 'admin:'\n+  allow:\n+    # only admin scope is allowed in V8, \n+    rules:\n+      - resources: [user, bot]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+Access lists that grant roles in `admin:` scope also have to have scopes to be explicitly set to only `admin:` scope and nothing else.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  # only root and `admin:` scope is allowed if grants include roles that contain resources requiring `admin:` scope.\n+  scopes: ['admin:']\n+  members:\n+    - bob@example.com\n+```\n+\n+This will help to separate non-admin and admin resources more clearly and in the UI we should mark roles and access list in `admin:` scopes with label `admin`.\n+\n+### Trusted Clusters\n+\n+With new scoped RBAC approach, leaf clusters will sync users from the root cluster, similarly to how we sync users from Okta via SCIM. \n+Leaf clusters will also sync root cluster's Access Lists similarly to how Teleport syncs access lists from Okta, see RFD 0019e - Okta Access Lists Sync.\n+Combined together, Users and Access Lists sync will let leaf clusters mirror permissions from the root cluster, while remaining independent, as leafs can have their own access lists and users.\n+\n+To let users access resources in specific clusters, we will use `/=leafs/[cluster-name]` scope. Leafs hierarchy is a part of a root `/` cluster hierarchy. This will allow transparent migration of resources. To avoid name collisions we will reserve paths that contain `=` and will prohibit users from creating resource groups that have character `=` in them.\n+",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1573056237",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1573056237",
        "commented_code": "@@ -0,0 +1,1144 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]\n+```\n+\n+When granted at scope, the role above will deny access to any apps in this scope.\n+\n+We will use `access` verb during migration. The following V7 and V8 roles are equivalent:\n+\n+```yaml\n+kind: role\n+version: V7\n+metadata:\n+   name: all-apps\n+spec:\n+  app_labels:\n+    '*': '*'\n+```\n+\n+```yaml\n+kind: role\n+version: V8\n+metadata:\n+   name: all-apps\n+spec:\n+  allow:\n+    rules:\n+    - resources: [app]\n+      verbs: [access]\n+```\n+\n+We will use the verb `access` for any supported resource, `node`, `k8s`, `db`, `app`, `desktop`, etc.\n+\n+Most of Teleport's preset roles have labels `*`: `*`, so migration will be straightforward.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with `scopes` present will limit the resource groups the resources can join to.\n+\n+For example, Teleport service using the scoped token below will only be able to join the resource group `dev`\n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  scopes: ['/dev']\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens with a `parent_resource_group` set can only have scope equal to this resource group.\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` and `scopes` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`. \n+\n+**Note:** To implement this, the token can be exchanged for the host certificate with `parent_resource_id` encoded in it. This way nodes can't set the nodes to any resource groups other than the parent.\n+By default, all existing join tokens will use `/` as a default resource group.\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-admin scope\n+\n+Some resources don't have a clear cut behavior at nested scopes, like SSO connectors, or are difficult to define, like for users. To address this issue, we will define a new `admin:` scope hierarchy that is parallel\n+to the `/` hierarchy and will require roles that grant access to this set of resources to use this and only this hierarchy.\n+\n+Here is a list of resources that can\u2019t be created at any scopes other than `admin:`\n+\n+* SSO connectors\n+* Users\n+* Bots\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+In the `V7` role version, we will let users to mix `admin:` scope that includes resources other than `admin:`, however in role `V8` we will require the role to **only** include the admin scope resources:\n+\n+```yaml\n+kind: role\n+version: v8\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  grantable_scopes: 'admin:'\n+  allow:\n+    # only admin scope is allowed in V8, \n+    rules:\n+      - resources: [user, bot]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+Access lists that grant roles in `admin:` scope also have to have scopes to be explicitly set to only `admin:` scope and nothing else.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  # only root and `admin:` scope is allowed if grants include roles that contain resources requiring `admin:` scope.\n+  scopes: ['admin:']\n+  members:\n+    - bob@example.com\n+```\n+\n+This will help to separate non-admin and admin resources more clearly and in the UI we should mark roles and access list in `admin:` scopes with label `admin`.\n+\n+### Trusted Clusters\n+\n+With new scoped RBAC approach, leaf clusters will sync users from the root cluster, similarly to how we sync users from Okta via SCIM. \n+Leaf clusters will also sync root cluster's Access Lists similarly to how Teleport syncs access lists from Okta, see RFD 0019e - Okta Access Lists Sync.\n+Combined together, Users and Access Lists sync will let leaf clusters mirror permissions from the root cluster, while remaining independent, as leafs can have their own access lists and users.\n+\n+To let users access resources in specific clusters, we will use `/=leafs/[cluster-name]` scope. Leafs hierarchy is a part of a root `/` cluster hierarchy. This will allow transparent migration of resources. To avoid name collisions we will reserve paths that contain `=` and will prohibit users from creating resource groups that have character `=` in them.\n+",
        "comment_created_at": "2024-04-19T23:44:19+00:00",
        "comment_author": "fspmarshall",
        "comment_body": "I'm not sure I follow what this is proposing.  This reads to me like saying that a role in the root cluster that is scoped to `/=leafs/[cluster-name]` would be able to grant direct permissions into the leaf cluster?  I assume I'm misunderstanding, since the below comments reference continuing to maintain the current principal of isolation, but I think this could use some clarification.\r\n\r\n(actually, the whole trusted cluster section could probably use some more specifics... this seems like a big shift in how trusted clusters work and I think it could use additional exposition/examples)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1573240814",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-04-20T10:36:40+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1573240814",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1573240814",
        "commented_code": "@@ -0,0 +1,1144 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+",
        "comment_created_at": "2024-04-20T10:36:40+00:00",
        "comment_author": "francesco-doyensec",
        "comment_body": " parent_resource_group could reintroduce the labels issue (or a variation of it) \r\n```\r\nIt is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\r\n```\r\nAllowing resources to self-declare their parent may introduce self-assignment patterns depending on the resource type and the implementation of the validation. I see multiple checks instances within the RFD:\r\n- Scoped Join tokens\r\n- Scoped admins\r\n\r\nIn my opinion, the risk of self-declaration should be assessed for each *Kind* allowing it, then validations checks should be linked to the attribute. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1573248624",
    "pr_number": 38078,
    "pr_file": "rfd/0164-scoped-rbac.md",
    "created_at": "2024-04-20T11:07:42+00:00",
    "commented_code": "+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]\n+```\n+\n+When granted at scope, the role above will deny access to any apps in this scope.\n+\n+We will use `access` verb during migration. The following V7 and V8 roles are equivalent:\n+\n+```yaml\n+kind: role\n+version: V7\n+metadata:\n+   name: all-apps\n+spec:\n+  app_labels:\n+    '*': '*'\n+```\n+\n+```yaml\n+kind: role\n+version: V8\n+metadata:\n+   name: all-apps\n+spec:\n+  allow:\n+    rules:\n+    - resources: [app]\n+      verbs: [access]\n+```\n+\n+We will use the verb `access` for any supported resource, `node`, `k8s`, `db`, `app`, `desktop`, etc.\n+\n+Most of Teleport's preset roles have labels `*`: `*`, so migration will be straightforward.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with `scopes` present will limit the resource groups the resources can join to.\n+\n+For example, Teleport service using the scoped token below will only be able to join the resource group `dev`\n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  scopes: ['/dev']\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens with a `parent_resource_group` set can only have scope equal to this resource group.\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` and `scopes` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`. \n+\n+**Note:** To implement this, the token can be exchanged for the host certificate with `parent_resource_id` encoded in it. This way nodes can't set the nodes to any resource groups other than the parent.\n+By default, all existing join tokens will use `/` as a default resource group.\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-admin scope\n+\n+Some resources don't have a clear cut behavior at nested scopes, like SSO connectors, or are difficult to define, like for users. To address this issue, we will define a new `admin:` scope hierarchy that is parallel\n+to the `/` hierarchy and will require roles that grant access to this set of resources to use this and only this hierarchy.\n+\n+Here is a list of resources that can\u2019t be created at any scopes other than `admin:`\n+\n+* SSO connectors\n+* Users\n+* Bots\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+In the `V7` role version, we will let users to mix `admin:` scope that includes resources other than `admin:`, however in role `V8` we will require the role to **only** include the admin scope resources:\n+\n+```yaml\n+kind: role\n+version: v8\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  grantable_scopes: 'admin:'\n+  allow:\n+    # only admin scope is allowed in V8, \n+    rules:\n+      - resources: [user, bot]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+Access lists that grant roles in `admin:` scope also have to have scopes to be explicitly set to only `admin:` scope and nothing else.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  # only root and `admin:` scope is allowed if grants include roles that contain resources requiring `admin:` scope.\n+  scopes: ['admin:']\n+  members:\n+    - bob@example.com\n+```\n+\n+This will help to separate non-admin and admin resources more clearly and in the UI we should mark roles and access list in `admin:` scopes with label `admin`.\n+\n+### Trusted Clusters\n+\n+With new scoped RBAC approach, leaf clusters will sync users from the root cluster, similarly to how we sync users from Okta via SCIM. \n+Leaf clusters will also sync root cluster's Access Lists similarly to how Teleport syncs access lists from Okta, see RFD 0019e - Okta Access Lists Sync.\n+Combined together, Users and Access Lists sync will let leaf clusters mirror permissions from the root cluster, while remaining independent, as leafs can have their own access lists and users.\n+\n+To let users access resources in specific clusters, we will use `/=leafs/[cluster-name]` scope. Leafs hierarchy is a part of a root `/` cluster hierarchy. This will allow transparent migration of resources. To avoid name collisions we will reserve paths that contain `=` and will prohibit users from creating resource groups that have character `=` in them.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Leaf clusters syncing access lists and users from the root clusters should avoid name collisions - if a local or SSO leaf cluster, role or access list exists, the sync should avoid overwriting the local leaf cluster data, emitting audit event that mentions that the system did not sync the list.\n+\n+This architecture lets leafs to have their own indpendent grants, while mirroring users, access lists from the root, which represents majority of today's use cases.\n+\n+### Features we will deprecate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined in the start of this RFD and review how the new system will help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+### K8s access to specific clusters\n+\n+Teleport can autodiscover clusters `echo` and `bravo` with namespaces `default` and `prod`, creating the following resource group hierarchy:\n+\n+```\n+/k8s/bravo\n+/k8s/echo\n+```\n+\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [k8s-access]\n+    traits:\n+      'internal.logins' : 'root'\n+      'namespaces': ['default', 'prod']\n+      'groups': ['view', 'edit']\n+  scopes:  ['/k8s/bravo']\n+  members:\n+    - bob@example.com\n+```\n+\n+The role `kube-access` can keep leveraging templates to bind traits \n+\n+```yaml\n+kind: role\n+metadata:\n+  name: kube-access\n+version: v7\n+spec:\n+  allow:\n+    kubernetes_resources:\n+      - kind: pod\n+        namespace: \"{{external.namespaces}}\"\n+        name: \"*\"\n+    kubernetes_groups: {{external.groups}}\n+  deny: {}\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  member_lists:",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1573248624",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 38078,
        "pr_file": "rfd/0164-scoped-rbac.md",
        "discussion_id": "1573248624",
        "commented_code": "@@ -0,0 +1,1144 @@\n+\n+---\n+authors: @klizhentas (sasha@goteleport.com)\n+state: draft\n+---\n+\n+# RFD 0163 - Scoped RBAC\n+\n+## Required Approvers\n+\n+* Engineering @r0mant && (@tigrato || @marcoandredinis)\n+* Security: (@reedloden || @jentfoo)\n+* Product: (@xinding33 || @klizhentas )\n+\n+## What\n+\n+This RFD introduces resource hierarchies and scopes to existing RBAC. \n+Our goal is simplify and evolve access control in Teleport without drastic changes or new policy languages. \n+Make it easier to integrate Teleport RBAC with cloud IAMs of AWS, GCP and Azure.\n+This RFD is closely modeled and inspired by Azure RBAC model, the most advanced out of 3 clouds. \n+\n+Read about it here https://learn.microsoft.com/en-us/azure/role-based-access-control/overview before diving into this RFD.\n+\n+## Why\n+\n+There are several structural issues with the current RBAC model in Teleport.\n+\n+### Scalability issues \n+\n+Every role has to be distributed to every node or proxy that has to perform authorization. \n+Current roles are brittle - to evaluate access, every single role has to be fetched and processed, \n+because each role can have a deny rule that can block access to any allowed rule.\n+\n+### Scoping issues\n+\n+It is not possible to describe \u201cdelegated admins\u201d in RBAC, when one user has administrative access over part of the cluster.\n+It is also not possible to specify that certain role options only apply in certain use-cases. \n+\n+For example, the setting `permit-agent-forward: false` will deny agent-forward to any matching resource with no exceptions, even if other roles allow it.\n+\n+It is not possible to allow admins to grant roles to other users but with certain restrictions, as in the example of issue https://github.com/gravitational/teleport/issues/16914. \n+\n+### Complexity \n+\n+Roles today have both labels and label expressions, login rules to inject traits and claims and templates. \n+This creates a complicated system that is hard to understand and reason about.\n+Role mapping is brittle and requires updating OIDC/SAML connector resources, which can break access.\n+\n+### Security issues\n+\n+Every role assignment and trait is encoded in certificate, and each time a user gets their roles updated, they have to get a new certificate. \n+Old certificates can be re-used to get privileges that have been removed, \n+creating \u201ca new enemy problem\u201d described in [Zanzibar Paper](https://research.google/pubs/zanzibar-googles-consistent-global-authorization-system/).\n+\n+Many roles allow \u201crole escapes\u201d, as any person who gets assigned a role that can create other roles, \n+would become an admin, see for example issue https://github.com/gravitational/teleport.e/issues/3111\n+\n+### Goals\n+\n+Our key goal is to evolve Teleport\u2019s roles without asking users to rewrite their existing RBAC.\n+We also would like to better integrate Teleport RBAC with cloud provider\u2019s IAM systems out of the box.\n+We would like to give Teleport\u2019s users \u201cbatteries included\u201d approach, when they can get 90% of the use-cases done without c\n+reating any new roles, or modifying existing ones.\n+\n+### Non-Goals\n+\n+We are not going to implement backwards-incompatible changes that require our customers rewrite their RBAC stack or adopt a completely new policy language. \n+\n+## Details\n+To understand the required changes, let\u2019s first take a look at Teleport RBAC structure. \n+\n+### RBAC Primer\n+\n+Let\u2019s start with fundamental Teleport RBAC concepts and highlight some issues as we review them.\n+\n+#### Roles\n+\n+Each user or bot in Teleport is assigned one or several roles. \n+For the full reference, take a look at the documentation at https://goteleport.com/docs/reference/resources/#role.\n+\n+Here is a role structure:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  # options are a set of knobs that apply across the entire role set.\n+  # the most restrictive options wins\n+  options:\n+    # max_session_ttl defines the TTL (time to live) of certificates\n+    # issued to the users with this role.\n+    max_session_ttl: 8h\n+    # forward_agent controls whether SSH agent forwarding is allowed\n+    forward_agent: true\n+  # The allow section declares a list of resource/verb combinations that are\n+  # allowed for the users of this role. By default, nothing is allowed.\n+  #\n+  # Allow rules specify both actions that are allowed and match the resources\n+  # they are applying to.\n+  allow:\n+    # Some Allow fields specify target protocol\n+    #  login principals, like in this example, SSH logins\n+    logins: [root, '{{internal.logins}}']\n+\n+    # In this example, the fields specify a set of windows desktop logins\n+    windows_desktop_logins: [Administrator, '{{internal.logins}}']\n+\n+    # There are multiple types of labels and label expressions that \n+    # match different computing resources.\n+    node_labels:\n+      # literal strings:\n+      'env': 'test'\n+    # regexp expressions\n+      'reg': '^us-west-1|eu-central-1$'\n+\n+    # node_labels_expression has the same purpose as node_labels but\n+    # supports predicate expressions to configure custom logic.\n+    # A user with this role will be allowed to access nodes if they are in the\n+    # staging environment *or* if they belong to one of the user's own teams.\n+    node_labels_expression: |\n+      labels[\"env\"] == \"staging\" ||\n+      contains(user.spec.traits[\"teams\"] , labels[\"team\"])\n+ \n+    # rules allow a user holding this role to modify other resources\n+    # matching the expressions below.\n+    # rules match both resources and specify what actions are allowed\n+    rules:\n+      - resources: [role]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+We can spot several issues with this role design:\n+\n+* There is no way to specify the scope that role applies to, all roles apply globally to all resources they match and all users they assign to all the time.\n+* There is no way to specify resource hierarchies, like computing environments (env vs prod), which makes it hard to partition the infrastructure and forces customers to specify labels.\n+\n+\n+#### Labels\n+\n+Teleport RBAC\u2019s advice to engineers to partition their resource is to first, label their computing resource or use AWS labels, and second, match the labels in RBAC.\n+\n+Admins can set the tags on the resource configuration file statically, or, for some resources, use `server_info` to set the tags for each resource:\n+\n+```yaml\n+# server_info.yaml\n+kind: server_info\n+metadata:\n+   name: si-<node-name>\n+spec:\n+   new_labels:\n+      \"foo\": \"bar\"\n+```\n+\n+This creates several issues:\n+\n+* It is not always secure to delegate labeling to owners of computing resources, as anyone with root access to the node config file can update its labels impacting everyone else.\n+* It is not scalable, as it\u2019s not always useful to set and updates tags for each individual resource\n+* It\u2019s hard or impossible to partition infrastructure with two-dimensional labels, although users can use `env: prod` to mark all resources in the production environment, there is no way to say that `env: lab` is a subset of `env: prod`.\n+\n+#### Current Roles mapping\n+\n+In Teleport there are multiple ways to map roles to users: static roles mapping to local users and bots, \n+dynamic mapping to SSO via connectors and on-demand assignment via access lists and access requests.\n+\n+Most users start with local static mapping and SSO mapping, later graduating to access requests and access lists.\n+\n+https://goteleport.com/docs/access-controls/sso/#creating-an-authentication-connector\n+\n+For SSO users, on login, Teleport checks SSO connector, and maps attributes of a user to a list of roles:\n+\n+```yaml\n+# connector.yaml\n+kind: saml\n+version: v2\n+metadata:\n+  name: corporate\n+spec:\n+  attributes_to_roles:\n+    - {name: \"groups\", value: \"okta-admin\", roles: [\"access\"]}\n+     # regular expressions with capture are also supported. \n+     # the next line instructs Teleport\n+     # to assign users to roles `admin-1` if his SAML \"group\" \n+     # attribute equals 'ssh_admin_1':\n+   - { name: \"group\", value: \"^ssh_admin_(.*)$\", roles: [\"admin-$1\"] }\n+```\n+\n+This creates several security and scalability issues:\n+\n+* Every time administrators need to change roles assignment, they have to update the resource.\n+* Every time the Identity Provider changes user\u2019s attributes, the users would have to relogin to get new roles. \n+\n+For local users, administrators have to specify roles and traits in the local resource:\n+\n+```yaml\n+kind: user\n+version: v2\n+metadata:\n+  name: joe\n+spec:\n+  # roles is a list of roles assigned to this user\n+  roles:\n+  - admin\n+  # traits are key, list of values pairs assigned to a user resource.\n+  # Traits can be used in role templates as variables.\n+  traits:\n+    logins:\n+    - joe\n+    - root\n+```\n+\n+This also creates some challenges, as administrators are forced to update local resources each time they have to assign a user new permission.\n+\n+### Modifications\n+\n+Let\u2019s now introduce the missing pieces of the puzzle and review how new roles will simplify or deprecate legacy concepts.\n+\n+#### Hierarchical Resource Groups\n+\n+Resource groups are one such missing piece - in most cloud environments, resources are split into hierarchy, \n+for example, host `luna` is a member of a resource group `lab`, in turn a member of environment `prod`, which is in turn a member of a Teleport cluster.\n+\n+In Teleport, we will make cluster a default root of this hierarchy. Every computing resource by default will be a direct member of a root `cluster` resource group.\n+\n+One resource can be assigned to multiple resource groups at a time, or none. \n+\n+In our example, the cluster administrator would define lab resource group in the following way:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent: prod_env\n+```\n+\n+Administrators can assign resources to resource groups:\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+   parent: prod_env\n+ match_kinds:\n+   - node\n+   - database\n+   - role\n+   - access_list\n+   - '.*'\n+ match_labels:  \n+   env: prod\n+```\n+\n+In this case, any resource that matches `env:prod` label will be assigned to this resource group. We will use the same label matching algorithm as in today's `discovery_service`. \n+\n+This will let administrators to gradually migrate their existing flat infrastructure to resource groups one.\n+\n+In some cases it makes sense to specify parent resource group inline:\n+\n+```yaml\n+kind: role\n+spec:\n+  parent_resource_group: /env/prod\n+```\n+\n+By default, if unspecified, a resource is a member of a root-level - `/` cluster resource group. If specified by the resource, it won't be a member of a root `/` resource group.\n+\n+Resource groups are hierarchical, and we can refer to the `lab` resource group by its full path as `/env/prod/lab`. \n+\n+Most Teleport resources, with some exceptions, like users, SSO connectors can be a member of a resource group. \n+\n+We will list those resources separately below.\n+\n+##### Default Resource groups via auto-discovery\n+\n+Teleport can create resource groups if admins turn on auto discovery. This will significantly simplify configuration. \n+\n+Here are some of the resource groups that Teleport Discovery service will create:\n+\n+* For AWS, Teleport discovery service will place each computing resource in `/aws/[account-id]/[region]/[resource-type]/[resource-id]`.\n+  + When EKS auto-discovery is on, this hierarchy will include discovered apps - `/aws/account-id/[region]/k8s/[cluster-name]/namespaces/[namespace]/[app-id]`\n+* For Azure, Teleport will use Azure's hierarchy - `/azure/[management-group]/[subscription]/[resource-group]/[resource-type]/[resource-id]`\n+* For GCP, we will use GCP hierarchy of `/gcp/[organization]/[folder]/[project]/[resource-type]/[resource-id]`\n+\n+Discovery service will create and remove these hierarchies based on the cloud state, and will create resources with `parent_resource_group` field to place them in those resource groups.\n+\n+If users are not happy with a default hierarchy, they can create a different one.\n+\n+#### Access Lists\n+\n+Teleport has a concept of access lists, that lists an owner, members, and optionally a parent access list.\n+Access List in Teleport represents a group of users with a hierarchy. \n+\n+We will further assume that the root of this hierarchy is a cluster. \n+\n+Unlike in resource groups, a user can be an owner and a member of none, one or several access lists at once.\n+\n+In addition to that, access list grants a role to a set of members, like in this example:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+We will return to access lists later, but let\u2019s now recall that access lists contain a list of members, who are, in turn, granted one or several roles.\n+\n+#### Scopes\n+\n+By default, in Teleport a role is granted it applies to all resources in the Teleport cluster.\n+\n+However, with this change, will be able to grant a set of roles that apply only to resources that belong to a specific resource group. \n+\n+In this case, we will say that the roles apply at the scope of the resource group.\n+\n+Scopes define a set of resources roles apply to. \n+\n+We will introduce scopes in a couple of places, first, for access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: \"lab-engineers\"\n+spec:\n+  desc: \"Access list for lab engineers\"\n+  # this grant applies only at the scope of the resource group `/env/prod/lab`\n+  scopes: [\u2018/env/prod/lab']\n+  grants:\n+    roles: [access]\n+  members:\n+    - name: bob@example.com\n+```\n+\n+By default, all existing access lists will grant roles at the cluster scope, cascading to all resources, just like before the migration. \n+\n+However, going forward, admins will be able to set scopes to more granular levels.\n+\n+The second place where we introduce scopes is in the roles:\n+\n+```yaml\n+kind: role\n+metadata:\n+ name: access\n+spec:\n+  grantable_scopes: ['/env/prod']\n+```\n+\n+Grantable scopes specifiy maximum scope this role can be granted on. \n+\n+**Important:** By default, if the `grantable_scopes` are missing, we assume empty scope - that will prevent the role from being granted on any scopes. When migrating existing roles, we would set `/` - root scope to avoid breaking the cluster. \n+\n+To sum it up, any role is granted to a set of users present in the access list, to a set of resources specified in the resource group.\n+\n+Grants are cascading, if a role is granted to a parent access list, it is also granted to members of any child access lists.\n+\n+If a role is granted at a scope of an access list, and this role can in turn give ability to request roles or impersonate, the roles and resources \n+and impersonation must be bound to the same scope or the scope smaller than the original one.\n+\n+For example, let\u2019s assume that the access list granted Alice the requester role described below at the scope of `/env/prod/lab`.  \n+\n+In this case, Alice would get the ability to search and request resources with an access role, but only in the scope of `/env/prod/lab`.\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+The same applies to impersonation, if access list granted Alice the role `impersonator` below at scope `/env/prod/lab`, \n+Alice would be able to impersonate role `jenkins`, but only at the scope `/env/prod/lab` or a more specific one, e.g. `/env/prod/lab/cabinet-west`.\n+\n+```yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: impersonator\n+spec:\n+  allow:\n+    impersonate:\n+      users: ['jenkins']\n+      roles: ['jenkins']\n+```\n+\n+**Note:** While it\u2019s tempting to support scope templates, we will push this out of the scope of this RFD.\n+\n+Each scope is a valid URI, either starting with a path `/leafs/path/etc` or with scheme prefix: `admin:/path`. URI syntax will let us expand definition of the scope going forward.\n+\n+#### The Access verb\n+\n+Alice would like to create a role that denies access to all apps in some scope. To achieve this without labels, we introduce a new verb `access`:\n+\n+```yaml\n+kind: role\n+metadata:\n+   name: no-apps\n+spec:\n+  deny:\n+      rules:\n+      - resources: [app]\n+        verbs: [access]\n+```\n+\n+When granted at scope, the role above will deny access to any apps in this scope.\n+\n+We will use `access` verb during migration. The following V7 and V8 roles are equivalent:\n+\n+```yaml\n+kind: role\n+version: V7\n+metadata:\n+   name: all-apps\n+spec:\n+  app_labels:\n+    '*': '*'\n+```\n+\n+```yaml\n+kind: role\n+version: V8\n+metadata:\n+   name: all-apps\n+spec:\n+  allow:\n+    rules:\n+    - resources: [app]\n+      verbs: [access]\n+```\n+\n+We will use the verb `access` for any supported resource, `node`, `k8s`, `db`, `app`, `desktop`, etc.\n+\n+Most of Teleport's preset roles have labels `*`: `*`, so migration will be straightforward.\n+\n+#### Roles and Access Lists in resource groups\n+\n+A special case is when a role or an access list is assigned to a certain resource group.  \n+\n+Only roles that have `grantable_scope` matching the resource group can be assigned to the resource group.\n+\n+The same applies to access lists, the scope of the access list grants should always match the scope of the roles it grants access to and \n+should not exceed the scope of the access list itself.\n+\n+In both of those cases, parent resource group must be specified both for access lists and roles and should equal or be more specific than the scope it was created in:\n+\n+```yaml\n+kind: role\n+metadata:\n+  name: lab-admin\n+spec:\n+  grantable_scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: lab-personnel\n+spec:\n+  scopes: ['/env/prod/lab']\n+  parent_resource_group: /env/prod/lab\n+```\n+\n+Roles created within a scope will have `grantable_scope` and `parent_resource_group` to be equal to scope, or more specific. \n+\n+For example, any role created within a scope `/env/prod/lab` must have the same `grantable_scope` and `parent_resource_group`  - `/env/prod/lab` or more specific one, \n+for example `/env/prod/lab/west-wing`.\n+\n+The roles and access lists created in the scope must grant access to scopes equal, or more specific than the scope they were created in to prevent lateral expansion or permissions.\n+\n+These invariants will let us make sure that any role created within a scope, will only grant permissions in the same, or more specific scope. \n+\n+We will apply the same invariants to any other resources created within a scope. \n+\n+#### Scoped Join Tokens\n+\n+Join tokens with `scopes` present will limit the resource groups the resources can join to.\n+\n+For example, Teleport service using the scoped token below will only be able to join the resource group `dev`\n+\n+```yaml\n+# token.yaml\n+kind: token\n+version: v2\n+metadata:\n+  name: my-token-name\n+spec:\n+  scopes: ['/dev']\n+  roles: \n+    - Node\n+    - App\n+```\n+\n+Join tokens with a `parent_resource_group` set can only have scope equal to this resource group.\n+\n+Join tokens created by roles granted within a scope must have `parent_resource_group` and `scopes` equal to this scope `/dev` or a more specific scope, e.g. `/dev/lab`. \n+\n+**Note:** To implement this, the token can be exchanged for the host certificate with `parent_resource_id` encoded in it. This way nodes can't set the nodes to any resource groups other than the parent.\n+By default, all existing join tokens will use `/` as a default resource group.\n+\n+#### Access Requests\n+\n+Access requests are bound to the scope they are created within, when Alice requests access to environment `/dev/lab` with role access, \n+the access request will capture the scope `/dev/lab` and create grant at this scope for Alice when approved.\n+\n+#### Scoped Audit Log Events and Session Recordings\n+\n+The audit events and session recordings generated by activity in some scope, will have a property that binds them to the same scope. \n+\n+This will let us filter and grant access to a subset of events and session recordings within a scope.\n+\n+#### Resources that can\u2019t be created at non-admin scope\n+\n+Some resources don't have a clear cut behavior at nested scopes, like SSO connectors, or are difficult to define, like for users. To address this issue, we will define a new `admin:` scope hierarchy that is parallel\n+to the `/` hierarchy and will require roles that grant access to this set of resources to use this and only this hierarchy.\n+\n+Here is a list of resources that can\u2019t be created at any scopes other than `admin:`\n+\n+* SSO connectors\n+* Users\n+* Bots\n+* Clusters\n+* Login rules\n+* Devices\n+* UI Configs\n+* Cluster auth preference\n+* Join tokens for roles Proxy, Auth\n+\n+In the `V7` role version, we will let users to mix `admin:` scope that includes resources other than `admin:`, however in role `V8` we will require the role to **only** include the admin scope resources:\n+\n+```yaml\n+kind: role\n+version: v8\n+metadata:\n+  # role name is unique across the entire cluster\n+  name: example\n+spec:\n+  grantable_scopes: 'admin:'\n+  allow:\n+    # only admin scope is allowed in V8, \n+    rules:\n+      - resources: [user, bot]\n+        verbs: [list, create, read, update, delete]\n+\n+  # The deny section uses the identical format as the 'allow' section.\n+  # The deny rules always override allow rules.\n+  deny: {}\n+```\n+\n+Access lists that grant roles in `admin:` scope also have to have scopes to be explicitly set to only `admin:` scope and nothing else.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  # only root and `admin:` scope is allowed if grants include roles that contain resources requiring `admin:` scope.\n+  scopes: ['admin:']\n+  members:\n+    - bob@example.com\n+```\n+\n+This will help to separate non-admin and admin resources more clearly and in the UI we should mark roles and access list in `admin:` scopes with label `admin`.\n+\n+### Trusted Clusters\n+\n+With new scoped RBAC approach, leaf clusters will sync users from the root cluster, similarly to how we sync users from Okta via SCIM. \n+Leaf clusters will also sync root cluster's Access Lists similarly to how Teleport syncs access lists from Okta, see RFD 0019e - Okta Access Lists Sync.\n+Combined together, Users and Access Lists sync will let leaf clusters mirror permissions from the root cluster, while remaining independent, as leafs can have their own access lists and users.\n+\n+To let users access resources in specific clusters, we will use `/=leafs/[cluster-name]` scope. Leafs hierarchy is a part of a root `/` cluster hierarchy. This will allow transparent migration of resources. To avoid name collisions we will reserve paths that contain `=` and will prohibit users from creating resource groups that have character `=` in them.\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Leaf clusters syncing access lists and users from the root clusters should avoid name collisions - if a local or SSO leaf cluster, role or access list exists, the sync should avoid overwriting the local leaf cluster data, emitting audit event that mentions that the system did not sync the list.\n+\n+This architecture lets leafs to have their own indpendent grants, while mirroring users, access lists from the root, which represents majority of today's use cases.\n+\n+### Features we will deprecate over time\n+\n+All existing Teleport features will keep working with no changes, however, with this design we plan to deprecate:\n+\n+* The mappings in connectors `attributes_to_roles` in favor of Access Lists integrated with SCIM and identity providers. Any grants of roles will be governed by access lists.\n+* Certificate extensions with roles and traits. A new access control system will no longer rely on certificate metadata to identify what roles have been assigned to users. The only data that new access control requires is information about user identity - username. Teleport will propagate grants via backend. This will lower Teleport\u2019s resiliency to auth server failures, but this will be compensated with modern database backends like CockroachDB that provide multi-region resiliency and failover. \n+* Label matchers and resource matchers in roles. We will have to support those for a long time, but those labels will always apply at the granted scope to resources in a resource group, and will become redundant, with later versions of Teleport relying on auto-discovery and assignment of resources to resource groups.\n+* Login rules. We will recommend replacing login rules with access lists that provide similar functionality.\n+\n+## User stories\n+\n+Let\u2019s get back to the issues we outlined in the start of this RFD and review how the new system will help to resolve them.\n+\n+### Gradual scoping\n+\n+Most Teleport customers will start with all resources and roles in the cluster scope. \n+\n+We will let them introduce resource groups gradually. Let\u2019s create two resource groups, `prod` and `dev` with resource groups `west` and `lab`.\n+\n+Here is the resource groups hierarchy, where we will assume that mars and luna servers matched the assignments:\n+\n+```mermaid\n+graph TD;\n+    luna(Server luna)-->west;\n+    west-->prod;\n+    prod-->cluster;\n+    lab-->dev;\n+    mars(Server mars)-->lab;\n+    dev-->cluster;\n+```\n+\n+```yaml\n+kind: resource_group\n+metadata:\n+  name: prod\n+---\n+kind: resource_group\n+metadata:\n+  name: west\n+  parent_resource_group: prod\n+  # would be nice if we could match on AWS specific right away with match_aws\n+  match_aws:\n+    account_id: aws-account-id\n+    region: west\n+---\n+kind: resource_group\n+metadata:\n+  name: dev\n+---\n+kind: resource_group\n+metadata:\n+  name: lab\n+spec:\n+  parent_resource_group: dev\n+  # here we will just match on labels\n+  match_labels:\n+    kinds: [node]\n+    env: lab\n+```\n+\n+This will let administrators create a resource hierarchy by  mapping computing resources using AWS metadata or labels.\n+\n+We will use this setup in the following examples.\n+\n+### SSH access to specific hosts\n+\n+The most prominent use-case is our over-engineered access role. We can keep this role as is. Today, it grants blanket access to any computing resource of Teleport.\n+\n+Alice, who is an administrator, would like to restrict access for a user bob@example.com to any server in the lab as root\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-lab\n+spec:\n+  grants: \n+    roles: [access]\n+    traits:\n+      'internal.logins' : 'root'\n+  scopes: ['/dev/lab']\n+  members:\n+    - bob@example.com\n+```\n+\n+Teleport will grant role access  and traits internal.logins: root to `bob@example.com`, but only when Bob would access servers in the resource group `/dev/lab`. \n+\n+This grant will not be valid out of the scope of `/dev/lab`, so Bob won\u2019t be able to SSH as root to any other servers.\n+\n+### K8s access to specific clusters\n+\n+Teleport can autodiscover clusters `echo` and `bravo` with namespaces `default` and `prod`, creating the following resource group hierarchy:\n+\n+```\n+/k8s/bravo\n+/k8s/echo\n+```\n+\n+\n+We can then use this hierarchy to create access lists specifying access to default namespace in any cluster:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [k8s-access]\n+    traits:\n+      'internal.logins' : 'root'\n+      'namespaces': ['default', 'prod']\n+      'groups': ['view', 'edit']\n+  scopes:  ['/k8s/bravo']\n+  members:\n+    - bob@example.com\n+```\n+\n+The role `kube-access` can keep leveraging templates to bind traits \n+\n+```yaml\n+kind: role\n+metadata:\n+  name: kube-access\n+version: v7\n+spec:\n+  allow:\n+    kubernetes_resources:\n+      - kind: pod\n+        namespace: \"{{external.namespaces}}\"\n+        name: \"*\"\n+    kubernetes_groups: {{external.groups}}\n+  deny: {}\n+```\n+\n+### Scoped search-based access requests\n+\n+Search-based access requests let users to search and request access to individual resources. Here is a standard requester role:\n+\n+```yaml\n+# requester.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: requester\n+spec:\n+  allow:\n+    request:\n+      search_as_roles:\n+        - access\n+```\n+\n+Here is a standard reviewer role:\n+\n+```yaml\n+# reviewer.yaml\n+kind: role\n+version: v5\n+metadata:\n+  name: reviewer\n+spec:\n+  allow:\n+    review_requests:\n+      roles:\n+        - access\n+      preview_as_roles:\n+        - access\n+```\n+\n+Without changing those roles, we can assign both requester and reviewer roles in a specific scope with access list:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: access-to-default\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+```\n+\n+In this case, `bob@example.com` and `alice@example.com` will get an ability to search, request and review requests, but only in the scope of any resource in `/dev` resource group.\n+\n+Customers frequently ask a question of how to scale this with multiple teams, \n+with this approach, we\u2019d have to create an access list for each individual team. \n+\n+Previously we\u2019ve been recommending to use role templates. \n+However, new access lists integration mirrors any group hierarchy in identity providers, \n+so there is no need to use templates - Teleport will create access lists and keep members up to date.\n+\n+The only thing we are missing is to let customers specify the scope when importing Okta groups or apps as access lists. \n+For example, access list for Okta group `devs` can automatically have scope `/dev`\n+\n+Additionally, one access list can be a member of another access list. Let\u2019s review a case when we have a group devs that needs access to both staging and production.\n+\n+Let\u2019s create access list for Alice and Bob, this special access list does no grants and scopes, we are going to use it to keep list of our developers:\n+\n+```yaml\n+kind: access_list\n+metadata:\n+  name: dev-team\n+spec:\n+  members:\n+    - bob@example.com\n+    - alice@example.com\n+---\n+kind: access_list\n+metadata:\n+  name: access-to-prod\n+spec:\n+  grants: \n+    roles: [requester, reviewer]\n+  scopes:  ['/dev']\n+  member_lists:",
        "comment_created_at": "2024-04-20T11:07:42+00:00",
        "comment_author": "francesco-doyensec",
        "comment_body": "*member_lists*  attribute should avoid the introduction of dangling entries in the hierarchy (See [TEL-Q124a-4: Privilege Escalation via Dangling Access List Members Claim](https://github.com/gravitational/teleport-private/issues/1463)). As far as I can see, AL will be a central part of the new design. \r\n\r\nAs an  example, scoped admin A (/env/dev) should not be able to create an AL named X if the name is a dangling member list in an AL within a different scope. ",
        "pr_file_module": null
      }
    ]
  }
]