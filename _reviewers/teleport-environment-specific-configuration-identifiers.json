[
  {
    "discussion_id": "2316506040",
    "pr_number": 58575,
    "pr_file": "web/packages/teleterm/src/mainProcess/windowsManager.ts",
    "created_at": "2025-09-02T15:49:33+00:00",
    "commented_code": "reject: (error: Error) => void;\n   };\n   private readonly windowUrl: string;\n+  private isHidden: boolean;",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2316506040",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/mainProcess/windowsManager.ts",
        "discussion_id": "2316506040",
        "commented_code": "@@ -57,10 +63,12 @@ export class WindowsManager {\n     reject: (error: Error) => void;\n   };\n   private readonly windowUrl: string;\n+  private isHidden: boolean;",
        "comment_created_at": "2025-09-02T15:49:33+00:00",
        "comment_author": "ravicious",
        "comment_body": "What if I hide the window myself with `Cmd + H`? It looks like this piece of state tracks the visibility state only when a change is caused by the app itself, but it doesn't react to changes made outside of the app.",
        "pr_file_module": null
      },
      {
        "comment_id": "2316513853",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/mainProcess/windowsManager.ts",
        "discussion_id": "2316506040",
        "commented_code": "@@ -57,10 +63,12 @@ export class WindowsManager {\n     reject: (error: Error) => void;\n   };\n   private readonly windowUrl: string;\n+  private isHidden: boolean;",
        "comment_created_at": "2025-09-02T15:52:33+00:00",
        "comment_author": "ravicious",
        "comment_body": "Do we need to track it in the first place? Would it be possible to use `win.isVisible`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2319307087",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/mainProcess/windowsManager.ts",
        "discussion_id": "2316506040",
        "commented_code": "@@ -57,10 +63,12 @@ export class WindowsManager {\n     reject: (error: Error) => void;\n   };\n   private readonly windowUrl: string;\n+  private isHidden: boolean;",
        "comment_created_at": "2025-09-03T15:14:39+00:00",
        "comment_author": "gzdunek",
        "comment_body": "Honestly, I completely forgot that you can hide a window in that way :p\r\n\r\nWhile using `win.isVisible()` to track whether the window is visible or not is definitely a good idea, I believe we still need a piece of state.  Hiding the window through Command+H is more like minimizing it, while closing it via `hideWindow()` is a different action, which terminates the sessions and hides the dock icon.\r\n\r\nThe problem is that we use the same `showWindow()` function to restore the window from both states. This function sends a \"window show\" event to the renderer and calls `dock.show()`. However, when restoring from the \"OS hide,\" doing that feels wrong,  we didn't emit a \"hide\" event or hide the icon in the first place.",
        "pr_file_module": null
      },
      {
        "comment_id": "2319502742",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/mainProcess/windowsManager.ts",
        "discussion_id": "2316506040",
        "commented_code": "@@ -57,10 +63,12 @@ export class WindowsManager {\n     reject: (error: Error) => void;\n   };\n   private readonly windowUrl: string;\n+  private isHidden: boolean;",
        "comment_created_at": "2025-09-03T16:29:05+00:00",
        "comment_author": "ravicious",
        "comment_body": "> (\u2026) I believe we still need a piece of state. Hiding the window through Command+H is more like minimizing it, while closing it via `hideWindow()` is a different action, which terminates the sessions and hides the dock icon.\r\n\r\nAh, I see. I think it's a valuable distinction, though I don't like that we're using the existing terminology (hidden/visible window) to mean something slightly different (\"minimizing\" the app into the tray). I'd worry that if we ever had to actually take window visibility into account (no matter whether it was hidden by us or by `Cmd+H`), then the implementation would become much harder to read.\r\n\r\nWhat if we internally called it \"background mode\"? Then the piece of state would become `isInBackgroundMode`, similarly the hook would be `useIsInBackgroundMode`.\r\n\r\n`hideWindow` in `WindowsManager` could then become `enterBackgroundMode`, while `showWindow` would continue to have the same name, because it must handle both things like a click in the menu bar as well as the `activate` event.",
        "pr_file_module": null
      },
      {
        "comment_id": "2324470742",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/mainProcess/windowsManager.ts",
        "discussion_id": "2316506040",
        "commented_code": "@@ -57,10 +63,12 @@ export class WindowsManager {\n     reject: (error: Error) => void;\n   };\n   private readonly windowUrl: string;\n+  private isHidden: boolean;",
        "comment_created_at": "2025-09-05T08:37:10+00:00",
        "comment_author": "gzdunek",
        "comment_body": "Agree, changing the terminology makes it much clearer, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2322118041",
    "pr_number": 58575,
    "pr_file": "web/packages/teleterm/src/tray.ts",
    "created_at": "2025-09-04T13:16:31+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import { Menu, nativeImage, NativeImage, Tray } from 'electron';\n+\n+import { getAssetPath } from 'teleterm/mainProcess/runtimeSettings';\n+import { RuntimeSettings } from 'teleterm/mainProcess/types';\n+\n+export function setTray(\n+  runtimeSettings: RuntimeSettings,\n+  window: { show(): void }\n+): void {\n+  const tray = new Tray(\n+    getIcon(runtimeSettings),\n+    // A random GUID that allows the icon to retain its position between relaunches.\n+    'acf0cb59-0f9e-412a-8973-9ee803bc39f6'",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2322118041",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/tray.ts",
        "discussion_id": "2322118041",
        "commented_code": "@@ -0,0 +1,64 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import { Menu, nativeImage, NativeImage, Tray } from 'electron';\n+\n+import { getAssetPath } from 'teleterm/mainProcess/runtimeSettings';\n+import { RuntimeSettings } from 'teleterm/mainProcess/types';\n+\n+export function setTray(\n+  runtimeSettings: RuntimeSettings,\n+  window: { show(): void }\n+): void {\n+  const tray = new Tray(\n+    getIcon(runtimeSettings),\n+    // A random GUID that allows the icon to retain its position between relaunches.\n+    'acf0cb59-0f9e-412a-8973-9ee803bc39f6'",
        "comment_created_at": "2025-09-04T13:16:31+00:00",
        "comment_author": "ravicious",
        "comment_body": "What happens if I run both the packaged app and the dev version at the same time? Should we use different IDs for these two versions?",
        "pr_file_module": null
      },
      {
        "comment_id": "2324475470",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58575,
        "pr_file": "web/packages/teleterm/src/tray.ts",
        "discussion_id": "2322118041",
        "commented_code": "@@ -0,0 +1,64 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import { Menu, nativeImage, NativeImage, Tray } from 'electron';\n+\n+import { getAssetPath } from 'teleterm/mainProcess/runtimeSettings';\n+import { RuntimeSettings } from 'teleterm/mainProcess/types';\n+\n+export function setTray(\n+  runtimeSettings: RuntimeSettings,\n+  window: { show(): void }\n+): void {\n+  const tray = new Tray(\n+    getIcon(runtimeSettings),\n+    // A random GUID that allows the icon to retain its position between relaunches.\n+    'acf0cb59-0f9e-412a-8973-9ee803bc39f6'",
        "comment_created_at": "2025-09-05T08:39:16+00:00",
        "comment_author": "gzdunek",
        "comment_body": "On Windows \"changing the path to the executable will break the creation of the tray icon and a new GUID must be used\", so it's probably safer to have separate guids. ",
        "pr_file_module": null
      }
    ]
  }
]