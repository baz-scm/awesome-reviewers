[
  {
    "discussion_id": "2261115442",
    "pr_number": 57659,
    "pr_file": "tool/teleport-update/main.go",
    "created_at": "2025-08-07T18:24:30+00:00",
    "commented_code": "Envar(autoupdate.SetupVersionEnvVar).StringVar(&ccfg.ForceVersion)\n \tsetupCmd.Flag(\"flag\", \"Use the provided flags to generate configuration files.\").\n \t\tEnvar(autoupdate.SetupFlagsEnvVar).StringsVar(&ccfg.ForceFlags)\n-\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").Hidden().BoolVar(&ccfg.SELinuxSSH)\n+\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").\n+\t\tHidden().Envar(autoupdate.SetupSELinuxSSHEnvVar).BoolVar(&ccfg.SELinuxSSH)",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2261115442",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 57659,
        "pr_file": "tool/teleport-update/main.go",
        "discussion_id": "2261115442",
        "commented_code": "@@ -187,7 +187,8 @@ func Run(args []string) int {\n \t\tEnvar(autoupdate.SetupVersionEnvVar).StringVar(&ccfg.ForceVersion)\n \tsetupCmd.Flag(\"flag\", \"Use the provided flags to generate configuration files.\").\n \t\tEnvar(autoupdate.SetupFlagsEnvVar).StringsVar(&ccfg.ForceFlags)\n-\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").Hidden().BoolVar(&ccfg.SELinuxSSH)\n+\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").\n+\t\tHidden().Envar(autoupdate.SetupSELinuxSSHEnvVar).BoolVar(&ccfg.SELinuxSSH)",
        "comment_created_at": "2025-08-07T18:24:30+00:00",
        "comment_author": "sclevine",
        "comment_body": "There may be a subtle issue here: if the teleport-update process invoking `teleport-update setup` has the env var set, it will be set for the subprocess even if `ReexecSetup` is invoked with `false`. Does this matter?",
        "pr_file_module": null
      },
      {
        "comment_id": "2261132287",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 57659,
        "pr_file": "tool/teleport-update/main.go",
        "discussion_id": "2261115442",
        "commented_code": "@@ -187,7 +187,8 @@ func Run(args []string) int {\n \t\tEnvar(autoupdate.SetupVersionEnvVar).StringVar(&ccfg.ForceVersion)\n \tsetupCmd.Flag(\"flag\", \"Use the provided flags to generate configuration files.\").\n \t\tEnvar(autoupdate.SetupFlagsEnvVar).StringsVar(&ccfg.ForceFlags)\n-\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").Hidden().BoolVar(&ccfg.SELinuxSSH)\n+\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").\n+\t\tHidden().Envar(autoupdate.SetupSELinuxSSHEnvVar).BoolVar(&ccfg.SELinuxSSH)",
        "comment_created_at": "2025-08-07T18:33:34+00:00",
        "comment_author": "capnspacehook",
        "comment_body": "I don't think so, if the SELinux env var is set in the original parent process we want to enable SELinux support so that should be fine",
        "pr_file_module": null
      },
      {
        "comment_id": "2261331716",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 57659,
        "pr_file": "tool/teleport-update/main.go",
        "discussion_id": "2261115442",
        "commented_code": "@@ -187,7 +187,8 @@ func Run(args []string) int {\n \t\tEnvar(autoupdate.SetupVersionEnvVar).StringVar(&ccfg.ForceVersion)\n \tsetupCmd.Flag(\"flag\", \"Use the provided flags to generate configuration files.\").\n \t\tEnvar(autoupdate.SetupFlagsEnvVar).StringsVar(&ccfg.ForceFlags)\n-\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").Hidden().BoolVar(&ccfg.SELinuxSSH)\n+\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").\n+\t\tHidden().Envar(autoupdate.SetupSELinuxSSHEnvVar).BoolVar(&ccfg.SELinuxSSH)",
        "comment_created_at": "2025-08-07T20:27:54+00:00",
        "comment_author": "sclevine",
        "comment_body": "What if I invoke `teleport-update enable --no-selinux-ssh` with the env var set to true? Seems like the outer `teleport-update` would think the value is false, but the subprocess would think it's true?",
        "pr_file_module": null
      },
      {
        "comment_id": "2262999941",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 57659,
        "pr_file": "tool/teleport-update/main.go",
        "discussion_id": "2261115442",
        "commented_code": "@@ -187,7 +187,8 @@ func Run(args []string) int {\n \t\tEnvar(autoupdate.SetupVersionEnvVar).StringVar(&ccfg.ForceVersion)\n \tsetupCmd.Flag(\"flag\", \"Use the provided flags to generate configuration files.\").\n \t\tEnvar(autoupdate.SetupFlagsEnvVar).StringsVar(&ccfg.ForceFlags)\n-\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").Hidden().BoolVar(&ccfg.SELinuxSSH)\n+\tsetupCmd.Flag(\"selinux-ssh\", \"Install the SELinux module for Teleport SSH.\").\n+\t\tHidden().Envar(autoupdate.SetupSELinuxSSHEnvVar).BoolVar(&ccfg.SELinuxSSH)",
        "comment_created_at": "2025-08-08T13:35:38+00:00",
        "comment_author": "capnspacehook",
        "comment_body": "Good catch, always setting the env var when reexec'ing seems to fix it, as the flag should take precedence anyways",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2310653833",
    "pr_number": 58416,
    "pr_file": "tool/teleport/common/backend.go",
    "created_at": "2025-08-29T16:51:00+00:00",
    "commented_code": "}\n \treturn nil\n }\n+\n+func onBackendGet(ctx context.Context, config backend.Config, key, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\treturn trace.Wrap(printBackendItems(format, stream.Once(*item)))\n+}\n+\n+func onBackendList(ctx context.Context, config backend.Config, prefix, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tvar startKey, endKey backend.Key\n+\tif prefix != \"\" {\n+\t\tstartKey = backend.KeyFromString(prefix)\n+\t\tendKey = backend.RangeEnd(startKey.ExactKey())\n+\t} else {\n+\t\tstartKey = backend.NewKey(\"\")\n+\t\tendKey = backend.RangeEnd(startKey)\n+\t}\n+\n+\titems := bk.Items(ctx, backend.ItemsParams{StartKey: startKey, EndKey: endKey})\n+\n+\treturn trace.Wrap(printBackendItems(format, items))\n+}\n+\n+func printBackendItems(format string, items iter.Seq2[backend.Item, error]) error {\n+\t// displayItem exists to better represent a\n+\t// [backend.Item] to users. The Key is converted to\n+\t// it's textual representation, and the Value is\n+\t// converted to a string so that it is not base64 encoded\n+\t// during marshaling.\n+\ttype displayItem struct {\n+\t\tKey      string\n+\t\tValue    string\n+\t\tRevision string\n+\t\tExpires  time.Time\n+\t}\n+\n+\tbackendItems := stream.FilterMap(items, func(i backend.Item) (displayItem, bool) {\n+\t\treturn displayItem{\n+\t\t\tKey:      i.Key.String(),\n+\t\t\tExpires:  i.Expires,\n+\t\t\tRevision: i.Revision,\n+\t\t\tValue:    string(i.Value),\n+\t\t}, true\n+\t})\n+\n+\tswitch strings.ToLower(format) {\n+\tcase teleport.Text, \"\":\n+\t\ttable := asciitable.MakeTable([]string{\"Key\", \"Expires\", \"Revision\"})\n+\t\tfor row, err := range stream.FilterMap(backendItems, func(i displayItem) ([]string, bool) {\n+\t\t\texpiry := \"Never\"\n+\t\t\tif !i.Expires.IsZero() {\n+\t\t\t\texpiry = i.Expires.Format(time.RFC3339)\n+\t\t\t}\n+\t\t\treturn []string{i.Key, expiry, i.Revision}, true\n+\t\t}) {\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err, \"retrieving items\")\n+\t\t\t}\n+\n+\t\t\ttable.AddRow(row)\n+\t\t}\n+\n+\t\tif err := table.WriteTo(os.Stdout); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.JSON:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := utils.FastMarshalIndent(allItems, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.YAML:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := yaml.Marshal(allItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tdefault:\n+\t\treturn trace.BadParameter(\"unsupported format %q\", format)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func onBackendDelete(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from stomping on the prompt.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tok, err := prompt.Confirmation(ctx, os.Stdout, prompt.Stdin(), fmt.Sprintf(\"Are you sure you want to delete %s\", key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t} else if !ok {\n+\t\treturn trace.Errorf(\"Operation canceled by user request.\")\n+\t}\n+\n+\tif err := bk.Delete(ctx, backend.KeyFromString(key)); err != nil {\n+\t\treturn trace.Wrap(err, \"deleting item\")\n+\t}\n+\n+\tfmt.Printf(\"item %q has been deleted\n\", key)\n+\treturn nil\n+}\n+\n+func checksum(filename string) (string, error) {\n+\tf, err := utils.OpenFileAllowingUnsafeLinks(filename)\n+\tif err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\tdefer f.Close()\n+\n+\th := sha256.New()\n+\tif _, err := io.Copy(h, f); err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\n+\treturn hex.EncodeToString(h.Sum(nil)), nil\n+}\n+\n+func onBackendEdit(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from being written over the editor.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\teditor := \"vi\"\n+\tfor _, v := range []string{\"TELEPORT_EDITOR\", \"VISUAL\", \"EDITOR\"} {\n+\t\tif value := os.Getenv(v); value != \"\" {\n+\t\t\teditor = value\n+\t\t\tbreak\n+\t\t}\n+\t}",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2310653833",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58416,
        "pr_file": "tool/teleport/common/backend.go",
        "discussion_id": "2310653833",
        "commented_code": "@@ -53,3 +78,273 @@ func onClone(ctx context.Context, configPath string) error {\n \t}\n \treturn nil\n }\n+\n+func onBackendGet(ctx context.Context, config backend.Config, key, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\treturn trace.Wrap(printBackendItems(format, stream.Once(*item)))\n+}\n+\n+func onBackendList(ctx context.Context, config backend.Config, prefix, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tvar startKey, endKey backend.Key\n+\tif prefix != \"\" {\n+\t\tstartKey = backend.KeyFromString(prefix)\n+\t\tendKey = backend.RangeEnd(startKey.ExactKey())\n+\t} else {\n+\t\tstartKey = backend.NewKey(\"\")\n+\t\tendKey = backend.RangeEnd(startKey)\n+\t}\n+\n+\titems := bk.Items(ctx, backend.ItemsParams{StartKey: startKey, EndKey: endKey})\n+\n+\treturn trace.Wrap(printBackendItems(format, items))\n+}\n+\n+func printBackendItems(format string, items iter.Seq2[backend.Item, error]) error {\n+\t// displayItem exists to better represent a\n+\t// [backend.Item] to users. The Key is converted to\n+\t// it's textual representation, and the Value is\n+\t// converted to a string so that it is not base64 encoded\n+\t// during marshaling.\n+\ttype displayItem struct {\n+\t\tKey      string\n+\t\tValue    string\n+\t\tRevision string\n+\t\tExpires  time.Time\n+\t}\n+\n+\tbackendItems := stream.FilterMap(items, func(i backend.Item) (displayItem, bool) {\n+\t\treturn displayItem{\n+\t\t\tKey:      i.Key.String(),\n+\t\t\tExpires:  i.Expires,\n+\t\t\tRevision: i.Revision,\n+\t\t\tValue:    string(i.Value),\n+\t\t}, true\n+\t})\n+\n+\tswitch strings.ToLower(format) {\n+\tcase teleport.Text, \"\":\n+\t\ttable := asciitable.MakeTable([]string{\"Key\", \"Expires\", \"Revision\"})\n+\t\tfor row, err := range stream.FilterMap(backendItems, func(i displayItem) ([]string, bool) {\n+\t\t\texpiry := \"Never\"\n+\t\t\tif !i.Expires.IsZero() {\n+\t\t\t\texpiry = i.Expires.Format(time.RFC3339)\n+\t\t\t}\n+\t\t\treturn []string{i.Key, expiry, i.Revision}, true\n+\t\t}) {\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err, \"retrieving items\")\n+\t\t\t}\n+\n+\t\t\ttable.AddRow(row)\n+\t\t}\n+\n+\t\tif err := table.WriteTo(os.Stdout); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.JSON:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := utils.FastMarshalIndent(allItems, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.YAML:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := yaml.Marshal(allItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tdefault:\n+\t\treturn trace.BadParameter(\"unsupported format %q\", format)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func onBackendDelete(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from stomping on the prompt.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tok, err := prompt.Confirmation(ctx, os.Stdout, prompt.Stdin(), fmt.Sprintf(\"Are you sure you want to delete %s\", key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t} else if !ok {\n+\t\treturn trace.Errorf(\"Operation canceled by user request.\")\n+\t}\n+\n+\tif err := bk.Delete(ctx, backend.KeyFromString(key)); err != nil {\n+\t\treturn trace.Wrap(err, \"deleting item\")\n+\t}\n+\n+\tfmt.Printf(\"item %q has been deleted\\n\", key)\n+\treturn nil\n+}\n+\n+func checksum(filename string) (string, error) {\n+\tf, err := utils.OpenFileAllowingUnsafeLinks(filename)\n+\tif err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\tdefer f.Close()\n+\n+\th := sha256.New()\n+\tif _, err := io.Copy(h, f); err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\n+\treturn hex.EncodeToString(h.Sum(nil)), nil\n+}\n+\n+func onBackendEdit(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from being written over the editor.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\teditor := \"vi\"\n+\tfor _, v := range []string{\"TELEPORT_EDITOR\", \"VISUAL\", \"EDITOR\"} {\n+\t\tif value := os.Getenv(v); value != \"\" {\n+\t\t\teditor = value\n+\t\t\tbreak\n+\t\t}\n+\t}",
        "comment_created_at": "2025-08-29T16:51:00+00:00",
        "comment_author": "zmb3",
        "comment_body": "```suggestion\n\teditor := cmp.Or(os.Getenv(\"TELEPORT_EDITOR\"), os.Getenv(\"VISUAL\"), os.Getenv(\"EDITOR\"), \"vi\")\n```",
        "pr_file_module": null
      }
    ]
  }
]