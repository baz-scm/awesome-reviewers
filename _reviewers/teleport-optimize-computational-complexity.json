[
  {
    "discussion_id": "2321144782",
    "pr_number": 58685,
    "pr_file": "lib/autoupdate/tools/utils.go",
    "created_at": "2025-09-04T07:41:37+00:00",
    "commented_code": "flags |= autoupdate.FlagEnterprise\n \t}\n \n-\tteleportURL, err := autoupdate.MakeURL(uriTmpl, baseURL, autoupdate.DefaultPackage, version, flags)\n+\t// TODO(vapopov): DELETE in v22.0.0 version check - the separate `teleport-tools` package\n+\t// will be included in all supported versions.\n+\tpkg := autoupdate.DefaultPackage\n+\tif runtime.GOOS == constants.DarwinOS &&\n+\t\t(semVersion.Major == 17 && semVersion.Compare(*semver.New(\"17.7.2\")) >= 0 ||\n+\t\t\tsemVersion.Major == 18 && semVersion.Compare(*semver.New(\"18.1.5\")) >= 0 ||\n+\t\t\tsemVersion.Major > 18) {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2321144782",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58685,
        "pr_file": "lib/autoupdate/tools/utils.go",
        "discussion_id": "2321144782",
        "commented_code": "@@ -209,11 +214,22 @@ func teleportPackageURLs(ctx context.Context, uriTmpl string, baseURL, version s\n \t\tflags |= autoupdate.FlagEnterprise\n \t}\n \n-\tteleportURL, err := autoupdate.MakeURL(uriTmpl, baseURL, autoupdate.DefaultPackage, version, flags)\n+\t// TODO(vapopov): DELETE in v22.0.0 version check - the separate `teleport-tools` package\n+\t// will be included in all supported versions.\n+\tpkg := autoupdate.DefaultPackage\n+\tif runtime.GOOS == constants.DarwinOS &&\n+\t\t(semVersion.Major == 17 && semVersion.Compare(*semver.New(\"17.7.2\")) >= 0 ||\n+\t\t\tsemVersion.Major == 18 && semVersion.Compare(*semver.New(\"18.1.5\")) >= 0 ||\n+\t\t\tsemVersion.Major > 18) {",
        "comment_created_at": "2025-09-04T07:41:37+00:00",
        "comment_author": "espadolini",
        "comment_body": "Unless some linter complains about the unkeyed fields (also, eventually the wanted semVersion is always going to be higher than 18 so checking that first is very slightly better):\n\n```suggestion\n\t\t(semVersion.Major > 18 ||\n\t\t\tsemVersion.Major == 18 && semVersion.Compare(semver.Version{18, 1, 5}) >= 0 ||\n\t\t\tsemVersion.Major == 17 && semVersion.Compare(semver.Version{17, 7, 2}) >= 0) {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2318528019",
    "pr_number": 58588,
    "pr_file": "build.assets/tooling/cmd/goderive/plugin/deepcopy/deepcopy.go",
    "created_at": "2025-09-03T10:25:18+00:00",
    "commented_code": "+//  Copyright 2017 Walter Schulze\n+//\n+//  Licensed under the Apache License, Version 2.0 (the \"License\");\n+//  you may not use this file except in compliance with the License.\n+//  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//  Unless required by applicable law or agreed to in writing, software\n+//  distributed under the License is distributed on an \"AS IS\" BASIS,\n+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//  See the License for the specific language governing permissions and\n+//  limitations under the License.\n+\n+// Package deepcopy contains the implementation of the deepcopy plugin, which generates the deriveDeepCopy function.\n+//\n+// The deriveDeepCopy function is a maintainable and fast way to implement fast copy functions.\n+//\n+// When goderive walks over your code it is looking for a function that:\n+//   - was not implemented (or was previously derived) and\n+//   - has a predefined prefix.\n+//\n+// In the following code the deriveDeepCopy function will be found, because\n+// it was not implemented and it has a prefix deriveDeepCopy.\n+// This prefix is configurable.\n+//\n+//\tpackage main\n+//\n+//\timport \"sort\"\n+//\n+//\ttype MyStruct struct {\n+//\t\tInt64     int64\n+//\t\tStringPtr *string\n+//\t}\n+//\n+//\tfunc (m *MyStruct) Clone() *MyStruct {\n+//\t\tif m == nil {\n+//\t\t\treturn nil\n+//\t\t}\n+//\t\tn := &MyStruct{}\n+//\t\tderiveDeepCopy(n, m)\n+//\t\treturn n\n+//\t}\n+//\n+// The initial type that is passed into deriveDeepCopy needs to have a reference type:\n+//   - pointer\n+//   - slice\n+//   - map\n+//\n+// , otherwise we are not able to modify the input parameter and then what are you really copying,\n+// but as we go deeper we support most types.\n+//\n+// Supported types:\n+//   - basic types\n+//   - named structs\n+//   - slices\n+//   - maps\n+//   - pointers to these types\n+//   - private fields of structs in external packages (using reflect and unsafe)\n+//   - and many more\n+//\n+// Unsupported types:\n+//   - chan\n+//   - interface\n+//   - function\n+//   - unnamed structs, which are not comparable with the == operator\n+//\n+// Example output can be found here:\n+// https://github.com/awalterschulze/goderive/tree/master/example/plugin/deepcopy\n+//\n+// This plugin has been tested thoroughly.\n+package deepcopy\n+\n+import (\n+\t\"fmt\"\n+\t\"go/types\"\n+\t\"strings\"\n+\n+\t\"github.com/awalterschulze/goderive/derive\"\n+)\n+\n+// NewPlugin creates a new deepcopy plugin.\n+// This function returns the plugin name, default prefix and a constructor for the deepcopy code generator.\n+func NewPlugin() derive.Plugin {\n+\treturn derive.NewPlugin(\"deepcopy\", \"deriveDeepCopy\", New)\n+}\n+\n+// New is a constructor for the deepcopy code generator.\n+// This generator should be reconstructed for each package.\n+func New(typesMap derive.TypesMap, p derive.Printer, deps map[string]derive.Dependency) derive.Generator {\n+\treturn &gen{\n+\t\tTypesMap:   typesMap,\n+\t\tprinter:    p,\n+\t\tbytesPkg:   p.NewImport(\"bytes\", \"bytes\"),\n+\t\treflectPkg: p.NewImport(\"reflect\", \"reflect\"),\n+\t\tunsafePkg:  p.NewImport(\"unsafe\", \"unsafe\"),\n+\t}\n+}\n+\n+type gen struct {\n+\tderive.TypesMap\n+\tprinter    derive.Printer\n+\tbytesPkg   derive.Import\n+\treflectPkg derive.Import\n+\tunsafePkg  derive.Import\n+}\n+\n+func (g *gen) Add(name string, typs []types.Type) (string, error) {\n+\tif len(typs) != 2 {\n+\t\treturn \"\", fmt.Errorf(\"%s does not have two arguments\", name)\n+\t}\n+\tif !types.Identical(typs[0], typs[1]) {\n+\t\treturn \"\", fmt.Errorf(\"%s has two arguments, but they are of different types %s != %s\",\n+\t\t\tname, g.TypeString(typs[0]), g.TypeString(typs[1]))\n+\t}\n+\treturn g.SetFuncName(name, typs[0])\n+}\n+\n+func (g *gen) Generate(typs []types.Type) error {\n+\treturn g.genFunc(typs[0])\n+}\n+\n+func (g *gen) genFunc(typ types.Type) error {\n+\tp := g.printer\n+\tg.Generating(typ)\n+\ttypeStr := g.TypeString(typ)\n+\tp.P(\"\")\n+\tp.P(\"// %s recursively copies the contents of src into dst.\", g.GetFuncName(typ))\n+\tp.P(\"func %s(dst, src %s) {\", g.GetFuncName(typ), typeStr)\n+\tp.In()\n+\tif err := g.genStatement(typ, \"src\", \"dst\"); err != nil {\n+\t\treturn err\n+\t}\n+\tp.Out()\n+\tp.P(\"}\")\n+\treturn nil\n+}\n+\n+func (g *gen) genStatement(typ types.Type, this, that string) error {\n+\tp := g.printer\n+\tif canCopy(typ) {\n+\t\tp.P(\"%s = %s\", that, this)\n+\t\treturn nil\n+\t}\n+\n+\tif typ.String() == \"*time.Time\" {\n+\t\tp.P(\"if src.IsZero() {\")\n+\t\tp.In()\n+\t\tp.P(\"return\")\n+\t\tp.Out()\n+\t\tp.P(\"}\")\n+\t\tp.P(fmt.Sprintf(\"*%s = time.Unix(0, %s.UnixNano()).In(%[2]s.Location())\", that, this))",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2318528019",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58588,
        "pr_file": "build.assets/tooling/cmd/goderive/plugin/deepcopy/deepcopy.go",
        "discussion_id": "2318528019",
        "commented_code": "@@ -0,0 +1,423 @@\n+//  Copyright 2017 Walter Schulze\n+//\n+//  Licensed under the Apache License, Version 2.0 (the \"License\");\n+//  you may not use this file except in compliance with the License.\n+//  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//  Unless required by applicable law or agreed to in writing, software\n+//  distributed under the License is distributed on an \"AS IS\" BASIS,\n+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//  See the License for the specific language governing permissions and\n+//  limitations under the License.\n+\n+// Package deepcopy contains the implementation of the deepcopy plugin, which generates the deriveDeepCopy function.\n+//\n+// The deriveDeepCopy function is a maintainable and fast way to implement fast copy functions.\n+//\n+// When goderive walks over your code it is looking for a function that:\n+//   - was not implemented (or was previously derived) and\n+//   - has a predefined prefix.\n+//\n+// In the following code the deriveDeepCopy function will be found, because\n+// it was not implemented and it has a prefix deriveDeepCopy.\n+// This prefix is configurable.\n+//\n+//\tpackage main\n+//\n+//\timport \"sort\"\n+//\n+//\ttype MyStruct struct {\n+//\t\tInt64     int64\n+//\t\tStringPtr *string\n+//\t}\n+//\n+//\tfunc (m *MyStruct) Clone() *MyStruct {\n+//\t\tif m == nil {\n+//\t\t\treturn nil\n+//\t\t}\n+//\t\tn := &MyStruct{}\n+//\t\tderiveDeepCopy(n, m)\n+//\t\treturn n\n+//\t}\n+//\n+// The initial type that is passed into deriveDeepCopy needs to have a reference type:\n+//   - pointer\n+//   - slice\n+//   - map\n+//\n+// , otherwise we are not able to modify the input parameter and then what are you really copying,\n+// but as we go deeper we support most types.\n+//\n+// Supported types:\n+//   - basic types\n+//   - named structs\n+//   - slices\n+//   - maps\n+//   - pointers to these types\n+//   - private fields of structs in external packages (using reflect and unsafe)\n+//   - and many more\n+//\n+// Unsupported types:\n+//   - chan\n+//   - interface\n+//   - function\n+//   - unnamed structs, which are not comparable with the == operator\n+//\n+// Example output can be found here:\n+// https://github.com/awalterschulze/goderive/tree/master/example/plugin/deepcopy\n+//\n+// This plugin has been tested thoroughly.\n+package deepcopy\n+\n+import (\n+\t\"fmt\"\n+\t\"go/types\"\n+\t\"strings\"\n+\n+\t\"github.com/awalterschulze/goderive/derive\"\n+)\n+\n+// NewPlugin creates a new deepcopy plugin.\n+// This function returns the plugin name, default prefix and a constructor for the deepcopy code generator.\n+func NewPlugin() derive.Plugin {\n+\treturn derive.NewPlugin(\"deepcopy\", \"deriveDeepCopy\", New)\n+}\n+\n+// New is a constructor for the deepcopy code generator.\n+// This generator should be reconstructed for each package.\n+func New(typesMap derive.TypesMap, p derive.Printer, deps map[string]derive.Dependency) derive.Generator {\n+\treturn &gen{\n+\t\tTypesMap:   typesMap,\n+\t\tprinter:    p,\n+\t\tbytesPkg:   p.NewImport(\"bytes\", \"bytes\"),\n+\t\treflectPkg: p.NewImport(\"reflect\", \"reflect\"),\n+\t\tunsafePkg:  p.NewImport(\"unsafe\", \"unsafe\"),\n+\t}\n+}\n+\n+type gen struct {\n+\tderive.TypesMap\n+\tprinter    derive.Printer\n+\tbytesPkg   derive.Import\n+\treflectPkg derive.Import\n+\tunsafePkg  derive.Import\n+}\n+\n+func (g *gen) Add(name string, typs []types.Type) (string, error) {\n+\tif len(typs) != 2 {\n+\t\treturn \"\", fmt.Errorf(\"%s does not have two arguments\", name)\n+\t}\n+\tif !types.Identical(typs[0], typs[1]) {\n+\t\treturn \"\", fmt.Errorf(\"%s has two arguments, but they are of different types %s != %s\",\n+\t\t\tname, g.TypeString(typs[0]), g.TypeString(typs[1]))\n+\t}\n+\treturn g.SetFuncName(name, typs[0])\n+}\n+\n+func (g *gen) Generate(typs []types.Type) error {\n+\treturn g.genFunc(typs[0])\n+}\n+\n+func (g *gen) genFunc(typ types.Type) error {\n+\tp := g.printer\n+\tg.Generating(typ)\n+\ttypeStr := g.TypeString(typ)\n+\tp.P(\"\")\n+\tp.P(\"// %s recursively copies the contents of src into dst.\", g.GetFuncName(typ))\n+\tp.P(\"func %s(dst, src %s) {\", g.GetFuncName(typ), typeStr)\n+\tp.In()\n+\tif err := g.genStatement(typ, \"src\", \"dst\"); err != nil {\n+\t\treturn err\n+\t}\n+\tp.Out()\n+\tp.P(\"}\")\n+\treturn nil\n+}\n+\n+func (g *gen) genStatement(typ types.Type, this, that string) error {\n+\tp := g.printer\n+\tif canCopy(typ) {\n+\t\tp.P(\"%s = %s\", that, this)\n+\t\treturn nil\n+\t}\n+\n+\tif typ.String() == \"*time.Time\" {\n+\t\tp.P(\"if src.IsZero() {\")\n+\t\tp.In()\n+\t\tp.P(\"return\")\n+\t\tp.Out()\n+\t\tp.P(\"}\")\n+\t\tp.P(fmt.Sprintf(\"*%s = time.Unix(0, %s.UnixNano()).In(%[2]s.Location())\", that, this))",
        "comment_created_at": "2025-09-03T10:25:18+00:00",
        "comment_author": "espadolini",
        "comment_body": "Why this roundtrip through UnixNano (which narrows the time range)? Can't we just do `*%s = %s` or, better yet, add the type check to `canCopy`\u00a0instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2318563232",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58588,
        "pr_file": "build.assets/tooling/cmd/goderive/plugin/deepcopy/deepcopy.go",
        "discussion_id": "2318528019",
        "commented_code": "@@ -0,0 +1,423 @@\n+//  Copyright 2017 Walter Schulze\n+//\n+//  Licensed under the Apache License, Version 2.0 (the \"License\");\n+//  you may not use this file except in compliance with the License.\n+//  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//  Unless required by applicable law or agreed to in writing, software\n+//  distributed under the License is distributed on an \"AS IS\" BASIS,\n+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//  See the License for the specific language governing permissions and\n+//  limitations under the License.\n+\n+// Package deepcopy contains the implementation of the deepcopy plugin, which generates the deriveDeepCopy function.\n+//\n+// The deriveDeepCopy function is a maintainable and fast way to implement fast copy functions.\n+//\n+// When goderive walks over your code it is looking for a function that:\n+//   - was not implemented (or was previously derived) and\n+//   - has a predefined prefix.\n+//\n+// In the following code the deriveDeepCopy function will be found, because\n+// it was not implemented and it has a prefix deriveDeepCopy.\n+// This prefix is configurable.\n+//\n+//\tpackage main\n+//\n+//\timport \"sort\"\n+//\n+//\ttype MyStruct struct {\n+//\t\tInt64     int64\n+//\t\tStringPtr *string\n+//\t}\n+//\n+//\tfunc (m *MyStruct) Clone() *MyStruct {\n+//\t\tif m == nil {\n+//\t\t\treturn nil\n+//\t\t}\n+//\t\tn := &MyStruct{}\n+//\t\tderiveDeepCopy(n, m)\n+//\t\treturn n\n+//\t}\n+//\n+// The initial type that is passed into deriveDeepCopy needs to have a reference type:\n+//   - pointer\n+//   - slice\n+//   - map\n+//\n+// , otherwise we are not able to modify the input parameter and then what are you really copying,\n+// but as we go deeper we support most types.\n+//\n+// Supported types:\n+//   - basic types\n+//   - named structs\n+//   - slices\n+//   - maps\n+//   - pointers to these types\n+//   - private fields of structs in external packages (using reflect and unsafe)\n+//   - and many more\n+//\n+// Unsupported types:\n+//   - chan\n+//   - interface\n+//   - function\n+//   - unnamed structs, which are not comparable with the == operator\n+//\n+// Example output can be found here:\n+// https://github.com/awalterschulze/goderive/tree/master/example/plugin/deepcopy\n+//\n+// This plugin has been tested thoroughly.\n+package deepcopy\n+\n+import (\n+\t\"fmt\"\n+\t\"go/types\"\n+\t\"strings\"\n+\n+\t\"github.com/awalterschulze/goderive/derive\"\n+)\n+\n+// NewPlugin creates a new deepcopy plugin.\n+// This function returns the plugin name, default prefix and a constructor for the deepcopy code generator.\n+func NewPlugin() derive.Plugin {\n+\treturn derive.NewPlugin(\"deepcopy\", \"deriveDeepCopy\", New)\n+}\n+\n+// New is a constructor for the deepcopy code generator.\n+// This generator should be reconstructed for each package.\n+func New(typesMap derive.TypesMap, p derive.Printer, deps map[string]derive.Dependency) derive.Generator {\n+\treturn &gen{\n+\t\tTypesMap:   typesMap,\n+\t\tprinter:    p,\n+\t\tbytesPkg:   p.NewImport(\"bytes\", \"bytes\"),\n+\t\treflectPkg: p.NewImport(\"reflect\", \"reflect\"),\n+\t\tunsafePkg:  p.NewImport(\"unsafe\", \"unsafe\"),\n+\t}\n+}\n+\n+type gen struct {\n+\tderive.TypesMap\n+\tprinter    derive.Printer\n+\tbytesPkg   derive.Import\n+\treflectPkg derive.Import\n+\tunsafePkg  derive.Import\n+}\n+\n+func (g *gen) Add(name string, typs []types.Type) (string, error) {\n+\tif len(typs) != 2 {\n+\t\treturn \"\", fmt.Errorf(\"%s does not have two arguments\", name)\n+\t}\n+\tif !types.Identical(typs[0], typs[1]) {\n+\t\treturn \"\", fmt.Errorf(\"%s has two arguments, but they are of different types %s != %s\",\n+\t\t\tname, g.TypeString(typs[0]), g.TypeString(typs[1]))\n+\t}\n+\treturn g.SetFuncName(name, typs[0])\n+}\n+\n+func (g *gen) Generate(typs []types.Type) error {\n+\treturn g.genFunc(typs[0])\n+}\n+\n+func (g *gen) genFunc(typ types.Type) error {\n+\tp := g.printer\n+\tg.Generating(typ)\n+\ttypeStr := g.TypeString(typ)\n+\tp.P(\"\")\n+\tp.P(\"// %s recursively copies the contents of src into dst.\", g.GetFuncName(typ))\n+\tp.P(\"func %s(dst, src %s) {\", g.GetFuncName(typ), typeStr)\n+\tp.In()\n+\tif err := g.genStatement(typ, \"src\", \"dst\"); err != nil {\n+\t\treturn err\n+\t}\n+\tp.Out()\n+\tp.P(\"}\")\n+\treturn nil\n+}\n+\n+func (g *gen) genStatement(typ types.Type, this, that string) error {\n+\tp := g.printer\n+\tif canCopy(typ) {\n+\t\tp.P(\"%s = %s\", that, this)\n+\t\treturn nil\n+\t}\n+\n+\tif typ.String() == \"*time.Time\" {\n+\t\tp.P(\"if src.IsZero() {\")\n+\t\tp.In()\n+\t\tp.P(\"return\")\n+\t\tp.Out()\n+\t\tp.P(\"}\")\n+\t\tp.P(fmt.Sprintf(\"*%s = time.Unix(0, %s.UnixNano()).In(%[2]s.Location())\", that, this))",
        "comment_created_at": "2025-09-03T10:40:22+00:00",
        "comment_author": "smallinsky",
        "comment_body": "yes, The `  p.P(\"*%s = *%s\", that, this)` should be enough aligned cc @tigrato \r\n\r\nAligned in https://github.com/gravitational/teleport/pull/58588/files#diff-8dc91e43c563fced07a198413c94221ec11d4c66f64bd97ff09ecc2284787d65R70",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293096285",
    "pr_number": 58114,
    "pr_file": "api/types/wrappers/wrappers.go",
    "created_at": "2025-08-22T08:38:43+00:00",
    "commented_code": "return nil\n }\n \n+// Clone returns a copy of the Traits map.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293096285",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "api/types/wrappers/wrappers.go",
        "discussion_id": "2293096285",
        "commented_code": "@@ -58,6 +59,18 @@ func UnmarshalTraits(data []byte, traits *Traits) error {\n \treturn nil\n }\n \n+// Clone returns a copy of the Traits map.",
        "comment_created_at": "2025-08-22T08:38:43+00:00",
        "comment_author": "Tener",
        "comment_body": "Might also be reimplemented through a `Marshal`/`Unmarshal` pair, but I think I like the current implementation better.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293373039",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "api/types/wrappers/wrappers.go",
        "discussion_id": "2293096285",
        "commented_code": "@@ -58,6 +59,18 @@ func UnmarshalTraits(data []byte, traits *Traits) error {\n \treturn nil\n }\n \n+// Clone returns a copy of the Traits map.",
        "comment_created_at": "2025-08-22T10:37:15+00:00",
        "comment_author": "tigrato",
        "comment_body": "Marshal/Unmarshal takes more cpu cycles. Proto clone won't work here because we use custom types",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293213655",
    "pr_number": 58114,
    "pr_file": "lib/services/parser.go",
    "created_at": "2025-08-22T09:30:54+00:00",
    "commented_code": "})\n }\n \n+// predicateContainsAll is a custom function to test if all entries in a []string\n+// are contained in another []string. Order does not matter, but all entries\n+// in the second slice must be present in the first slice.\n+func predicateContainsAll(a, b any) predicate.BoolPredicate {\n+\treturn func() bool {\n+\t\taval, ok := a.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tbval, ok := b.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tfor _, v := range bval {\n+\t\t\tif !slices.Contains(aval, v) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293213655",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293213655",
        "commented_code": "@@ -730,6 +821,48 @@ func newParserForIdentifierSubcondition(ctx RuleContext, identifier string) (pre\n \t})\n }\n \n+// predicateContainsAll is a custom function to test if all entries in a []string\n+// are contained in another []string. Order does not matter, but all entries\n+// in the second slice must be present in the first slice.\n+func predicateContainsAll(a, b any) predicate.BoolPredicate {\n+\treturn func() bool {\n+\t\taval, ok := a.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tbval, ok := b.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tfor _, v := range bval {\n+\t\t\tif !slices.Contains(aval, v) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}",
        "comment_created_at": "2025-08-22T09:30:54+00:00",
        "comment_author": "Tener",
        "comment_body": "This is `O(N^2)` and thus carries DoS risk. We can rewrite this to work on `map[string]` to mitigate this risk.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293485485",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293213655",
        "commented_code": "@@ -730,6 +821,48 @@ func newParserForIdentifierSubcondition(ctx RuleContext, identifier string) (pre\n \t})\n }\n \n+// predicateContainsAll is a custom function to test if all entries in a []string\n+// are contained in another []string. Order does not matter, but all entries\n+// in the second slice must be present in the first slice.\n+func predicateContainsAll(a, b any) predicate.BoolPredicate {\n+\treturn func() bool {\n+\t\taval, ok := a.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tbval, ok := b.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tfor _, v := range bval {\n+\t\t\tif !slices.Contains(aval, v) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}",
        "comment_created_at": "2025-08-22T11:35:51+00:00",
        "comment_author": "tigrato",
        "comment_body": "the number of permutations is low and my guess is O(n2) will be better than creating a map but changed it anw",
        "pr_file_module": null
      },
      {
        "comment_id": "2293685712",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293213655",
        "commented_code": "@@ -730,6 +821,48 @@ func newParserForIdentifierSubcondition(ctx RuleContext, identifier string) (pre\n \t})\n }\n \n+// predicateContainsAll is a custom function to test if all entries in a []string\n+// are contained in another []string. Order does not matter, but all entries\n+// in the second slice must be present in the first slice.\n+func predicateContainsAll(a, b any) predicate.BoolPredicate {\n+\treturn func() bool {\n+\t\taval, ok := a.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tbval, ok := b.([]string)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\tfor _, v := range bval {\n+\t\t\tif !slices.Contains(aval, v) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}",
        "comment_created_at": "2025-08-22T13:06:26+00:00",
        "comment_author": "Tener",
        "comment_body": "That would have been fine if we asserted the upper bound of elements anywhere, or as a specialised way to handle just a handful of elements (how many? benchmarks, I suppose).\r\n\r\nI doubt we need this level of optimisation here, a plain map should be fast enough.",
        "pr_file_module": null
      }
    ]
  }
]