[
  {
    "discussion_id": "2319550265",
    "pr_number": 58520,
    "pr_file": "lib/join/diagnostic/diagnostic.go",
    "created_at": "2025-09-03T16:49:15+00:00",
    "commented_code": null,
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2319550265",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58520,
        "pr_file": "lib/join/diagnostic/diagnostic.go",
        "discussion_id": "2319550265",
        "commented_code": null,
        "comment_created_at": "2025-09-03T16:49:15+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "Is this package intended to ever be consumed outside of lib/join? Should we consider moving it into `join/internal/diagnostic`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2294029356",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-22T15:19:26+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.cancelActiveTask != nil {\n+\t\ts.cancelActiveTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.cancelActiveTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\t// start the stream over if we need to go back in time\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.cancelActiveTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\t// process an event, returning a boolean indicating if the events should continue being\n+\t// processed (i.e. returns false once we have reached the end of the requested time window)\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2294029356",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2294029356",
        "commented_code": "@@ -0,0 +1,640 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.cancelActiveTask != nil {\n+\t\ts.cancelActiveTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.cancelActiveTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\t// start the stream over if we need to go back in time\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.cancelActiveTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\t// process an event, returning a boolean indicating if the events should continue being\n+\t// processed (i.e. returns false once we have reached the end of the requested time window)\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)",
        "comment_created_at": "2025-08-22T15:19:26+00:00",
        "comment_author": "bl-nero",
        "comment_body": "Perhaps we should also investigate the buffered events upfront and pause reading from the stream until we clear the buffered events? Otherwise, this code will add an event every time a print outside the requested range is encountered.\r\n\r\nEdit: I see that you're actually doing it below, it's just the way this code is structured (one big function with another big function inside) made it unclear about the order of things. Would it be a lot of work to pull the `processEvent` function outside for better readability?",
        "pr_file_module": null
      },
      {
        "comment_id": "2300530905",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2294029356",
        "commented_code": "@@ -0,0 +1,640 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.cancelActiveTask != nil {\n+\t\ts.cancelActiveTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.cancelActiveTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\t// start the stream over if we need to go back in time\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.cancelActiveTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\t// process an event, returning a boolean indicating if the events should continue being\n+\t// processed (i.e. returns false once we have reached the end of the requested time window)\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)",
        "comment_created_at": "2025-08-26T10:22:14+00:00",
        "comment_author": "ryanclark",
        "comment_body": "Yeah, it accesses `streamStartTime`, `addToBatch` which accesses `eventBatch`, etc, I didn't want to put them all on the `recordingPlayback` struct just to have everything in separate functions when they're only related to the one streamEvents call",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2303854850",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-27T12:57:12+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2303854850",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2303854850",
        "commented_code": "@@ -0,0 +1,767 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}",
        "comment_created_at": "2025-08-27T12:57:12+00:00",
        "comment_author": "smallinsky",
        "comment_body": "I would suggest to move the wire messages and encoding/decoding related function to separate `.go`  file that will allow to decouple the message handling layer from data/packet creation\r\n\r\nAs example I can point to databases lib: \r\nhttps://github.com/gravitational/teleport/blob/master/lib/srv/db/sqlserver/protocol/login7.go#L119",
        "pr_file_module": null
      },
      {
        "comment_id": "2304241364",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2303854850",
        "commented_code": "@@ -0,0 +1,767 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}",
        "comment_created_at": "2025-08-27T14:59:51+00:00",
        "comment_author": "ryanclark",
        "comment_body": "Moved it and the tests into their own file",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2305119814",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-27T19:31:40+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// maxRequestRange is the maximum allowed time range for a request\n+const maxRequestRange = 10 * time.Minute\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+type recordingTerminal struct {\n+\tsync.Mutex\n+\tvt vt10x.Terminal\n+}\n+\n+type recordingStream struct {\n+\tsync.Mutex\n+\teventsChan    <-chan apievents.AuditEvent\n+\terrorsChan    <-chan error\n+\tlastEndTime   time.Duration\n+\tbufferedEvent apievents.AuditEvent\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\tstream           recordingStream\n+\tterminal         recordingTerminal\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWS(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2305119814",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2305119814",
        "commented_code": "@@ -0,0 +1,654 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// maxRequestRange is the maximum allowed time range for a request\n+const maxRequestRange = 10 * time.Minute\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+type recordingTerminal struct {\n+\tsync.Mutex\n+\tvt vt10x.Terminal\n+}\n+\n+type recordingStream struct {\n+\tsync.Mutex\n+\teventsChan    <-chan apievents.AuditEvent\n+\terrorsChan    <-chan error\n+\tlastEndTime   time.Duration\n+\tbufferedEvent apievents.AuditEvent\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\tstream           recordingStream\n+\tterminal         recordingTerminal\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWS(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {",
        "comment_created_at": "2025-08-27T19:31:40+00:00",
        "comment_author": "smallinsky",
        "comment_body": "I think that  this is not  generic web socket close flow but vt playback specific behavior. \r\n\r\nnit: What would you say about decoupling the newRecordingPlayback object and closeWebsocketWithError flow into a dedicated object  or package. \r\n\r\nOtherwise we are implement business protocol logic in that `lib/web` package wher ``lib/web` should contains basic HTTP handlers.   \r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2307350685",
    "pr_number": 58398,
    "pr_file": "lib/msgraph/paginated.go",
    "created_at": "2025-08-28T13:02:18+00:00",
    "commented_code": "return iterateSimple(c, ctx, \"servicePrincipals\", f)\n }\n \n+func (c *Client) IterateManagedDevicePages(ctx context.Context, f func(mds []*ManagedDevice) bool, queryOpts ...IterateOpt) error {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2307350685",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58398,
        "pr_file": "lib/msgraph/paginated.go",
        "discussion_id": "2307350685",
        "commented_code": "@@ -116,13 +208,18 @@ func (c *Client) IterateServicePrincipals(ctx context.Context, f func(principal\n \treturn iterateSimple(c, ctx, \"servicePrincipals\", f)\n }\n \n+func (c *Client) IterateManagedDevicePages(ctx context.Context, f func(mds []*ManagedDevice) bool, queryOpts ...IterateOpt) error {",
        "comment_created_at": "2025-08-28T13:02:18+00:00",
        "comment_author": "ravicious",
        "comment_body": "I'm thinking that instead of putting this in a generic `lib/msgraph/paginated.go`, I should actually put it in `lib/msgraph/managed_device.go`. I'll have two API calls related to devices (paginate through all and get device by ID) and it feels better to have the code organized by what it does rather than how it's implemented.",
        "pr_file_module": null
      },
      {
        "comment_id": "2307378680",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58398,
        "pr_file": "lib/msgraph/paginated.go",
        "discussion_id": "2307350685",
        "commented_code": "@@ -116,13 +208,18 @@ func (c *Client) IterateServicePrincipals(ctx context.Context, f func(principal\n \treturn iterateSimple(c, ctx, \"servicePrincipals\", f)\n }\n \n+func (c *Client) IterateManagedDevicePages(ctx context.Context, f func(mds []*ManagedDevice) bool, queryOpts ...IterateOpt) error {",
        "comment_created_at": "2025-08-28T13:12:31+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "It might also be worthwhile to convert these iterators over to iter.Seq at some point as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216590024",
    "pr_number": 56691,
    "pr_file": "lib/services/local/access_list.go",
    "created_at": "2025-07-18T17:44:06+00:00",
    "commented_code": "return accessList, membersIn, nil\n }\n \n+// UpsertAccessListWithMembersV2 creates or updates an access list resource and its members.\n+// Replica of UpsertAccessListWithMembers.\n+// TODO(kimlisa): delete once UpsertAccessListWithMembers signature gets updated.\n+func (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2216590024",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56691,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2216590024",
        "commented_code": "@@ -827,6 +827,169 @@ func (a *AccessListService) UpsertAccessListWithMembers(ctx context.Context, acc\n \treturn accessList, membersIn, nil\n }\n \n+// UpsertAccessListWithMembersV2 creates or updates an access list resource and its members.\n+// Replica of UpsertAccessListWithMembers.\n+// TODO(kimlisa): delete once UpsertAccessListWithMembers signature gets updated.\n+func (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {",
        "comment_created_at": "2025-07-18T17:44:06+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "Let's consolidate the implementations of UpsertAccessListWithMembers and UpsertAccessListWithMembersV2 by having one call the other.  \r\n\r\n```suggestion\r\nfunc (a *AccessListService) UpsertAccessListWithMembers(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {\r\nreturn a.UpsertAccessListWithMembersV2(ctx, accesslist.UpsertAccessListWithMembersRequest{...})\r\n}\r\n\r\nfunc (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {\r\n....\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2246069933",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56691,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2216590024",
        "commented_code": "@@ -827,6 +827,169 @@ func (a *AccessListService) UpsertAccessListWithMembers(ctx context.Context, acc\n \treturn accessList, membersIn, nil\n }\n \n+// UpsertAccessListWithMembersV2 creates or updates an access list resource and its members.\n+// Replica of UpsertAccessListWithMembers.\n+// TODO(kimlisa): delete once UpsertAccessListWithMembers signature gets updated.\n+func (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {",
        "comment_created_at": "2025-07-31T18:13:46+00:00",
        "comment_author": "kimlisa",
        "comment_body": "oh right... \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f \ud83e\udd26\u200d\u2640\ufe0f , i did the opposite of what you suggested but i think it should be the same outcome",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216612810",
    "pr_number": 56691,
    "pr_file": "lib/services/local/access_list.go",
    "created_at": "2025-07-18T17:58:29+00:00",
    "commented_code": "return accessList, membersIn, nil\n }\n \n+// UpsertAccessListWithMembersV2 creates or updates an access list resource and its members.\n+// Replica of UpsertAccessListWithMembers.\n+// TODO(kimlisa): delete once UpsertAccessListWithMembers signature gets updated.\n+func (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {\n+\tif err := req.AccessList.CheckAndSetDefaults(); err != nil {\n+\t\treturn nil, nil, trace.Wrap(err)\n+\t}\n+\n+\tfor _, m := range req.Members {\n+\t\tif err := m.CheckAndSetDefaults(); err != nil {\n+\t\t\treturn nil, nil, trace.Wrap(err)\n+\t\t}\n+\t}\n+\n+\tvalidateAccessList := func() error {\n+\t\texistingList, err := a.service.GetResource(ctx, req.AccessList.GetName())\n+\t\tif err != nil && !trace.IsNotFound(err) {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\t\tif existingList != nil {\n+\t\t\treq.AccessList.Status.MemberOf = existingList.Status.MemberOf\n+\t\t\treq.AccessList.Status.OwnerOf = existingList.Status.OwnerOf\n+\t\t} else {\n+\t\t\t// In case the MemberOf/OwnerOf fields were manually changed, set to empty.\n+\t\t\treq.AccessList.Status.MemberOf = []string{}\n+\t\t\treq.AccessList.Status.OwnerOf = []string{}\n+\t\t}\n+\n+\t\tif err := accesslists.ValidateAccessListWithMembers(ctx, req.AccessList, req.Members, &accessListAndMembersGetter{a.service, a.memberService}); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+\n+\treconcileMembers := func() error {\n+\t\t// Convert the members slice to a map for easier lookup.\n+\t\tmembersMap := utils.FromSlice(req.Members, types.GetName)\n+\n+\t\tvar (\n+\t\t\tmembers      []*accesslist.AccessListMember\n+\t\t\tmembersToken string\n+\t\t)\n+\n+\t\tfor {\n+\t\t\t// List all members for the access list.\n+\t\t\tvar err error\n+\t\t\tmembers, membersToken, err = a.memberService.WithPrefix(req.AccessList.GetName()).ListResources(ctx, 0 /* default size */, membersToken)\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n+\t\t\t}\n+\n+\t\t\tfor _, existingMember := range members {\n+\t\t\t\t// If the member is not in the new members map (request), delete it.\n+\t\t\t\tif newMember, ok := membersMap[existingMember.GetName()]; !ok {\n+\t\t\t\t\terr = a.memberService.WithPrefix(req.AccessList.GetName()).DeleteResource(ctx, existingMember.GetName())\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}\n+\t\t\t\t\t// Update memberOf field if nested list.\n+\t\t\t\t\tif existingMember.Spec.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\t\t\tif err := a.updateAccessListMemberOf(ctx, req.AccessList.GetName(), existingMember.GetName(), false); err != nil {\n+\t\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// Preserve the membership metadata for any existing members\n+\t\t\t\t\t// to suppress member records flipping back and forth due\n+\t\t\t\t\t// due SCIM pushes or Sync Service updates.\n+\t\t\t\t\tif !existingMember.Spec.Expires.IsZero() {\n+\t\t\t\t\t\tnewMember.Spec.Expires = existingMember.Spec.Expires\n+\t\t\t\t\t}\n+\t\t\t\t\tif existingMember.Spec.Reason != \"\" {\n+\t\t\t\t\t\tnewMember.Spec.Reason = existingMember.Spec.Reason\n+\t\t\t\t\t}\n+\t\t\t\t\tkeepAWSIdentityCenterLabels(existingMember, newMember)\n+\t\t\t\t\tnewMember.Spec.AddedBy = existingMember.Spec.AddedBy\n+\n+\t\t\t\t\t// Compare members and update if necessary.\n+\t\t\t\t\tif !cmp.Equal(newMember, existingMember) {\n+\t\t\t\t\t\t// Update the member.\n+\t\t\t\t\t\tupserted, err := a.memberService.WithPrefix(req.AccessList.GetName()).UpsertResource(ctx, newMember)\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\texistingMember.SetRevision(upserted.GetRevision())\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Remove the member from the map.\n+\t\t\t\tdelete(membersMap, existingMember.GetName())\n+\t\t\t}\n+\n+\t\t\tif membersToken == \"\" {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Add any remaining members to the access list.\n+\t\tfor _, member := range membersMap {\n+\t\t\tupserted, err := a.memberService.WithPrefix(req.AccessList.GetName()).UpsertResource(ctx, member)\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n+\t\t\t}\n+\t\t\t// Update memberOf field if nested list.\n+\t\t\tif member.Spec.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\tif err := a.updateAccessListMemberOf(ctx, req.AccessList.GetName(), member.Spec.Name, true); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmember.SetRevision(upserted.GetRevision())\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+\n+\treconcileOwners := func() error {\n+\t\t// update references for new owners\n+\t\tfor _, owner := range req.AccessList.Spec.Owners {\n+\t\t\tif owner.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, req.AccessList.GetName(), owner.Name, true); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tupdateAccessList := func() error {\n+\t\tvar err error\n+\t\treq.AccessList, err = a.service.UpsertResource(ctx, req.AccessList)\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\tvar actions []func() error\n+\n+\t// If IGS is not enabled for this cluster we need to wrap the whole update and\n+\t// member reconciliation in *another* lock so that we can accurately count the\n+\t// access lists in the cluster in order to  prevent un-authorized use of the\n+\t// AccessList feature\n+\tif !modules.GetModules().Features().GetEntitlement(entitlements.Identity).Enabled {\n+\t\tactions = append(actions, func() error { return a.VerifyAccessListCreateLimit(ctx, req.AccessList.GetName()) })\n+\t}\n+\n+\tactions = append(actions, validateAccessList, reconcileMembers, updateAccessList, reconcileOwners)\n+\n+\tif err := a.service.RunWhileLocked(ctx, []string{accessListResourceLockName}, 2*accessListLockTTL, func(ctx context.Context, _ backend.Backend) error {\n+\t\treturn a.service.RunWhileLocked(ctx, lockName(req.AccessList.GetName()), 2*accessListLockTTL, func(ctx context.Context, _ backend.Backend) error {\n+\t\t\tfor _, action := range actions {\n+\t\t\t\tif err := action(); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}); err != nil {\n+\t\treturn nil, nil, trace.Wrap(err)\n+\t}\n+\n+\treturn req.AccessList, req.Members, nil",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2216612810",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56691,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2216612810",
        "commented_code": "@@ -827,6 +827,169 @@ func (a *AccessListService) UpsertAccessListWithMembers(ctx context.Context, acc\n \treturn accessList, membersIn, nil\n }\n \n+// UpsertAccessListWithMembersV2 creates or updates an access list resource and its members.\n+// Replica of UpsertAccessListWithMembers.\n+// TODO(kimlisa): delete once UpsertAccessListWithMembers signature gets updated.\n+func (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {\n+\tif err := req.AccessList.CheckAndSetDefaults(); err != nil {\n+\t\treturn nil, nil, trace.Wrap(err)\n+\t}\n+\n+\tfor _, m := range req.Members {\n+\t\tif err := m.CheckAndSetDefaults(); err != nil {\n+\t\t\treturn nil, nil, trace.Wrap(err)\n+\t\t}\n+\t}\n+\n+\tvalidateAccessList := func() error {\n+\t\texistingList, err := a.service.GetResource(ctx, req.AccessList.GetName())\n+\t\tif err != nil && !trace.IsNotFound(err) {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\t\tif existingList != nil {\n+\t\t\treq.AccessList.Status.MemberOf = existingList.Status.MemberOf\n+\t\t\treq.AccessList.Status.OwnerOf = existingList.Status.OwnerOf\n+\t\t} else {\n+\t\t\t// In case the MemberOf/OwnerOf fields were manually changed, set to empty.\n+\t\t\treq.AccessList.Status.MemberOf = []string{}\n+\t\t\treq.AccessList.Status.OwnerOf = []string{}\n+\t\t}\n+\n+\t\tif err := accesslists.ValidateAccessListWithMembers(ctx, req.AccessList, req.Members, &accessListAndMembersGetter{a.service, a.memberService}); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+\n+\treconcileMembers := func() error {\n+\t\t// Convert the members slice to a map for easier lookup.\n+\t\tmembersMap := utils.FromSlice(req.Members, types.GetName)\n+\n+\t\tvar (\n+\t\t\tmembers      []*accesslist.AccessListMember\n+\t\t\tmembersToken string\n+\t\t)\n+\n+\t\tfor {\n+\t\t\t// List all members for the access list.\n+\t\t\tvar err error\n+\t\t\tmembers, membersToken, err = a.memberService.WithPrefix(req.AccessList.GetName()).ListResources(ctx, 0 /* default size */, membersToken)\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n+\t\t\t}\n+\n+\t\t\tfor _, existingMember := range members {\n+\t\t\t\t// If the member is not in the new members map (request), delete it.\n+\t\t\t\tif newMember, ok := membersMap[existingMember.GetName()]; !ok {\n+\t\t\t\t\terr = a.memberService.WithPrefix(req.AccessList.GetName()).DeleteResource(ctx, existingMember.GetName())\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}\n+\t\t\t\t\t// Update memberOf field if nested list.\n+\t\t\t\t\tif existingMember.Spec.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\t\t\tif err := a.updateAccessListMemberOf(ctx, req.AccessList.GetName(), existingMember.GetName(), false); err != nil {\n+\t\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// Preserve the membership metadata for any existing members\n+\t\t\t\t\t// to suppress member records flipping back and forth due\n+\t\t\t\t\t// due SCIM pushes or Sync Service updates.\n+\t\t\t\t\tif !existingMember.Spec.Expires.IsZero() {\n+\t\t\t\t\t\tnewMember.Spec.Expires = existingMember.Spec.Expires\n+\t\t\t\t\t}\n+\t\t\t\t\tif existingMember.Spec.Reason != \"\" {\n+\t\t\t\t\t\tnewMember.Spec.Reason = existingMember.Spec.Reason\n+\t\t\t\t\t}\n+\t\t\t\t\tkeepAWSIdentityCenterLabels(existingMember, newMember)\n+\t\t\t\t\tnewMember.Spec.AddedBy = existingMember.Spec.AddedBy\n+\n+\t\t\t\t\t// Compare members and update if necessary.\n+\t\t\t\t\tif !cmp.Equal(newMember, existingMember) {\n+\t\t\t\t\t\t// Update the member.\n+\t\t\t\t\t\tupserted, err := a.memberService.WithPrefix(req.AccessList.GetName()).UpsertResource(ctx, newMember)\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\texistingMember.SetRevision(upserted.GetRevision())\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Remove the member from the map.\n+\t\t\t\tdelete(membersMap, existingMember.GetName())\n+\t\t\t}\n+\n+\t\t\tif membersToken == \"\" {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Add any remaining members to the access list.\n+\t\tfor _, member := range membersMap {\n+\t\t\tupserted, err := a.memberService.WithPrefix(req.AccessList.GetName()).UpsertResource(ctx, member)\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n+\t\t\t}\n+\t\t\t// Update memberOf field if nested list.\n+\t\t\tif member.Spec.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\tif err := a.updateAccessListMemberOf(ctx, req.AccessList.GetName(), member.Spec.Name, true); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmember.SetRevision(upserted.GetRevision())\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+\n+\treconcileOwners := func() error {\n+\t\t// update references for new owners\n+\t\tfor _, owner := range req.AccessList.Spec.Owners {\n+\t\t\tif owner.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, req.AccessList.GetName(), owner.Name, true); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tupdateAccessList := func() error {\n+\t\tvar err error\n+\t\treq.AccessList, err = a.service.UpsertResource(ctx, req.AccessList)\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\tvar actions []func() error\n+\n+\t// If IGS is not enabled for this cluster we need to wrap the whole update and\n+\t// member reconciliation in *another* lock so that we can accurately count the\n+\t// access lists in the cluster in order to  prevent un-authorized use of the\n+\t// AccessList feature\n+\tif !modules.GetModules().Features().GetEntitlement(entitlements.Identity).Enabled {\n+\t\tactions = append(actions, func() error { return a.VerifyAccessListCreateLimit(ctx, req.AccessList.GetName()) })\n+\t}\n+\n+\tactions = append(actions, validateAccessList, reconcileMembers, updateAccessList, reconcileOwners)\n+\n+\tif err := a.service.RunWhileLocked(ctx, []string{accessListResourceLockName}, 2*accessListLockTTL, func(ctx context.Context, _ backend.Backend) error {\n+\t\treturn a.service.RunWhileLocked(ctx, lockName(req.AccessList.GetName()), 2*accessListLockTTL, func(ctx context.Context, _ backend.Backend) error {\n+\t\t\tfor _, action := range actions {\n+\t\t\t\tif err := action(); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}); err != nil {\n+\t\treturn nil, nil, trace.Wrap(err)\n+\t}\n+\n+\treturn req.AccessList, req.Members, nil",
        "comment_created_at": "2025-07-18T17:58:29+00:00",
        "comment_author": "smallinsky",
        "comment_body": "Please don't introduce logic duplication. This is quite complex logic we that can't be just copied an pasted because it make the code very hard to maintain. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2246085181",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56691,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2216612810",
        "commented_code": "@@ -827,6 +827,169 @@ func (a *AccessListService) UpsertAccessListWithMembers(ctx context.Context, acc\n \treturn accessList, membersIn, nil\n }\n \n+// UpsertAccessListWithMembersV2 creates or updates an access list resource and its members.\n+// Replica of UpsertAccessListWithMembers.\n+// TODO(kimlisa): delete once UpsertAccessListWithMembers signature gets updated.\n+func (a *AccessListService) UpsertAccessListWithMembersV2(ctx context.Context, req accesslist.UpsertAccessListWithMembersRequest) (*accesslist.AccessList, []*accesslist.AccessListMember, error) {\n+\tif err := req.AccessList.CheckAndSetDefaults(); err != nil {\n+\t\treturn nil, nil, trace.Wrap(err)\n+\t}\n+\n+\tfor _, m := range req.Members {\n+\t\tif err := m.CheckAndSetDefaults(); err != nil {\n+\t\t\treturn nil, nil, trace.Wrap(err)\n+\t\t}\n+\t}\n+\n+\tvalidateAccessList := func() error {\n+\t\texistingList, err := a.service.GetResource(ctx, req.AccessList.GetName())\n+\t\tif err != nil && !trace.IsNotFound(err) {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\t\tif existingList != nil {\n+\t\t\treq.AccessList.Status.MemberOf = existingList.Status.MemberOf\n+\t\t\treq.AccessList.Status.OwnerOf = existingList.Status.OwnerOf\n+\t\t} else {\n+\t\t\t// In case the MemberOf/OwnerOf fields were manually changed, set to empty.\n+\t\t\treq.AccessList.Status.MemberOf = []string{}\n+\t\t\treq.AccessList.Status.OwnerOf = []string{}\n+\t\t}\n+\n+\t\tif err := accesslists.ValidateAccessListWithMembers(ctx, req.AccessList, req.Members, &accessListAndMembersGetter{a.service, a.memberService}); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+\n+\treconcileMembers := func() error {\n+\t\t// Convert the members slice to a map for easier lookup.\n+\t\tmembersMap := utils.FromSlice(req.Members, types.GetName)\n+\n+\t\tvar (\n+\t\t\tmembers      []*accesslist.AccessListMember\n+\t\t\tmembersToken string\n+\t\t)\n+\n+\t\tfor {\n+\t\t\t// List all members for the access list.\n+\t\t\tvar err error\n+\t\t\tmembers, membersToken, err = a.memberService.WithPrefix(req.AccessList.GetName()).ListResources(ctx, 0 /* default size */, membersToken)\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n+\t\t\t}\n+\n+\t\t\tfor _, existingMember := range members {\n+\t\t\t\t// If the member is not in the new members map (request), delete it.\n+\t\t\t\tif newMember, ok := membersMap[existingMember.GetName()]; !ok {\n+\t\t\t\t\terr = a.memberService.WithPrefix(req.AccessList.GetName()).DeleteResource(ctx, existingMember.GetName())\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t}\n+\t\t\t\t\t// Update memberOf field if nested list.\n+\t\t\t\t\tif existingMember.Spec.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\t\t\tif err := a.updateAccessListMemberOf(ctx, req.AccessList.GetName(), existingMember.GetName(), false); err != nil {\n+\t\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// Preserve the membership metadata for any existing members\n+\t\t\t\t\t// to suppress member records flipping back and forth due\n+\t\t\t\t\t// due SCIM pushes or Sync Service updates.\n+\t\t\t\t\tif !existingMember.Spec.Expires.IsZero() {\n+\t\t\t\t\t\tnewMember.Spec.Expires = existingMember.Spec.Expires\n+\t\t\t\t\t}\n+\t\t\t\t\tif existingMember.Spec.Reason != \"\" {\n+\t\t\t\t\t\tnewMember.Spec.Reason = existingMember.Spec.Reason\n+\t\t\t\t\t}\n+\t\t\t\t\tkeepAWSIdentityCenterLabels(existingMember, newMember)\n+\t\t\t\t\tnewMember.Spec.AddedBy = existingMember.Spec.AddedBy\n+\n+\t\t\t\t\t// Compare members and update if necessary.\n+\t\t\t\t\tif !cmp.Equal(newMember, existingMember) {\n+\t\t\t\t\t\t// Update the member.\n+\t\t\t\t\t\tupserted, err := a.memberService.WithPrefix(req.AccessList.GetName()).UpsertResource(ctx, newMember)\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\texistingMember.SetRevision(upserted.GetRevision())\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Remove the member from the map.\n+\t\t\t\tdelete(membersMap, existingMember.GetName())\n+\t\t\t}\n+\n+\t\t\tif membersToken == \"\" {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Add any remaining members to the access list.\n+\t\tfor _, member := range membersMap {\n+\t\t\tupserted, err := a.memberService.WithPrefix(req.AccessList.GetName()).UpsertResource(ctx, member)\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err)\n+\t\t\t}\n+\t\t\t// Update memberOf field if nested list.\n+\t\t\tif member.Spec.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\tif err := a.updateAccessListMemberOf(ctx, req.AccessList.GetName(), member.Spec.Name, true); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tmember.SetRevision(upserted.GetRevision())\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+\n+\treconcileOwners := func() error {\n+\t\t// update references for new owners\n+\t\tfor _, owner := range req.AccessList.Spec.Owners {\n+\t\t\tif owner.MembershipKind == accesslist.MembershipKindList {\n+\t\t\t\tif err := a.updateAccessListOwnerOf(ctx, req.AccessList.GetName(), owner.Name, true); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tupdateAccessList := func() error {\n+\t\tvar err error\n+\t\treq.AccessList, err = a.service.UpsertResource(ctx, req.AccessList)\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\tvar actions []func() error\n+\n+\t// If IGS is not enabled for this cluster we need to wrap the whole update and\n+\t// member reconciliation in *another* lock so that we can accurately count the\n+\t// access lists in the cluster in order to  prevent un-authorized use of the\n+\t// AccessList feature\n+\tif !modules.GetModules().Features().GetEntitlement(entitlements.Identity).Enabled {\n+\t\tactions = append(actions, func() error { return a.VerifyAccessListCreateLimit(ctx, req.AccessList.GetName()) })\n+\t}\n+\n+\tactions = append(actions, validateAccessList, reconcileMembers, updateAccessList, reconcileOwners)\n+\n+\tif err := a.service.RunWhileLocked(ctx, []string{accessListResourceLockName}, 2*accessListLockTTL, func(ctx context.Context, _ backend.Backend) error {\n+\t\treturn a.service.RunWhileLocked(ctx, lockName(req.AccessList.GetName()), 2*accessListLockTTL, func(ctx context.Context, _ backend.Backend) error {\n+\t\t\tfor _, action := range actions {\n+\t\t\t\tif err := action(); err != nil {\n+\t\t\t\t\treturn trace.Wrap(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t})\n+\t}); err != nil {\n+\t\treturn nil, nil, trace.Wrap(err)\n+\t}\n+\n+\treturn req.AccessList, req.Members, nil",
        "comment_created_at": "2025-07-31T18:22:08+00:00",
        "comment_author": "kimlisa",
        "comment_body": "sorry, i didn't realize i could just call the old api while i'm name changing. https://github.com/gravitational/teleport/pull/56691#discussion_r2246069933",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2316391790",
    "pr_number": 58580,
    "pr_file": "lib/cache/access_list.go",
    "created_at": "2025-09-02T15:10:14+00:00",
    "commented_code": "defaultPageSize: 200,\n \t\tupstreamList:    c.Config.AccessLists.ListAllAccessListMembers,\n \t\tnextToken: func(t *accesslist.AccessListMember) string {\n-\t\t\treturn t.GetMetadata().Name\n+\t\t\treturn t.Spec.AccessList + \"/\" + t.GetMetadata().Name",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2316391790",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58580,
        "pr_file": "lib/cache/access_list.go",
        "discussion_id": "2316391790",
        "commented_code": "@@ -260,10 +260,10 @@ func (c *Cache) ListAllAccessListMembers(ctx context.Context, pageSize int, page\n \t\tdefaultPageSize: 200,\n \t\tupstreamList:    c.Config.AccessLists.ListAllAccessListMembers,\n \t\tnextToken: func(t *accesslist.AccessListMember) string {\n-\t\t\treturn t.GetMetadata().Name\n+\t\t\treturn t.Spec.AccessList + \"/\" + t.GetMetadata().Name",
        "comment_created_at": "2025-09-02T15:10:14+00:00",
        "comment_author": "r0mant",
        "comment_body": "The member key `<list-name>/<member-name>` is used in multiple places in the cache, and looks like part of the issue it was originally missed, can this be factored out into a helper method?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205155926",
    "pr_number": 56760,
    "pr_file": "lib/services/local/access_list.go",
    "created_at": "2025-07-14T14:58:09+00:00",
    "commented_code": "validateAccessList := func() error {\n \t\tvar err error\n \n-\t\tif op == opTypeUpdate {\n-\t\t\texistingList, err = a.service.GetResource(ctx, accessList.GetName())\n-\t\t\tif err != nil {\n-\t\t\t\treturn trace.Wrap(err)\n-\t\t\t}\n+\t\texistingAccessList, err = a.service.GetResource(ctx, accessList.GetName())\n+\t\tif op == opTypeUpsert && trace.IsNotFound(err) {\n+\t\t\t// ok, will be created\n+\t\t} else if err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif existingAccessList != nil {\n \t\t\t// Set memberOf / ownerOf to the existing values to prevent them from being updated.\n-\t\t\taccessList.Status.MemberOf = existingList.Status.MemberOf\n-\t\t\taccessList.Status.OwnerOf = existingList.Status.OwnerOf\n+\t\t\taccessList.Status.MemberOf = existingAccessList.Status.MemberOf",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2205155926",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56760,
        "pr_file": "lib/services/local/access_list.go",
        "discussion_id": "2205155926",
        "commented_code": "@@ -214,14 +214,17 @@ func (a *AccessListService) runOpWithLock(ctx context.Context, accessList *acces\n \tvalidateAccessList := func() error {\n \t\tvar err error\n \n-\t\tif op == opTypeUpdate {\n-\t\t\texistingList, err = a.service.GetResource(ctx, accessList.GetName())\n-\t\t\tif err != nil {\n-\t\t\t\treturn trace.Wrap(err)\n-\t\t\t}\n+\t\texistingAccessList, err = a.service.GetResource(ctx, accessList.GetName())\n+\t\tif op == opTypeUpsert && trace.IsNotFound(err) {\n+\t\t\t// ok, will be created\n+\t\t} else if err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif existingAccessList != nil {\n \t\t\t// Set memberOf / ownerOf to the existing values to prevent them from being updated.\n-\t\t\taccessList.Status.MemberOf = existingList.Status.MemberOf\n-\t\t\taccessList.Status.OwnerOf = existingList.Status.OwnerOf\n+\t\t\taccessList.Status.MemberOf = existingAccessList.Status.MemberOf",
        "comment_created_at": "2025-07-14T14:58:09+00:00",
        "comment_author": "smallinsky",
        "comment_body": "Can we extract this logic to a separate function and reuse instead of creating duplication like: \r\n\r\nhttps://github.com/gravitational/teleport/pull/56760/files#diff-163b30f0186e4cbccf93708c28c159fa46e5832b9316ddc1761f4c2d52da97e2R693",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2310175430",
    "pr_number": 58496,
    "pr_file": "lib/services/local/bot_instance.go",
    "created_at": "2025-08-29T13:32:10+00:00",
    "commented_code": "return nil, trace.CompareFailed(\"failed to update bot instance within %v iterations\", iterLimit)\n }\n+\n+func MatchBotInstance(b *machineidv1.BotInstance, botName string, search string, exp typical.Expression[*Environment, bool]) bool {\n+\tif botName != \"\" && b.Spec.BotName != botName {\n+\t\treturn false\n+\t}\n+\n+\tlatestHeartbeats := b.GetStatus().GetLatestHeartbeats()\n+\theartbeat := b.Status.InitialHeartbeat // Use initial heartbeat as a fallback\n+\tif len(latestHeartbeats) > 0 {\n+\t\theartbeat = latestHeartbeats[len(latestHeartbeats)-1]\n+\t}\n+\n+\tif exp != nil {\n+\t\tif match, err := exp.Evaluate(&Environment{\n+\t\t\tInstance:        b,\n+\t\t\tLatestHeartbeat: heartbeat,\n+\t\t}); err != nil || !match {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tif search == \"\" {\n+\t\treturn true\n+\t}\n+\n+\tvalues := []string{\n+\t\tb.Spec.BotName,\n+\t\tb.Spec.InstanceId,\n+\t}\n+\n+\tif heartbeat != nil {\n+\t\tvalues = append(values, heartbeat.Hostname, heartbeat.JoinMethod, heartbeat.Version, \"v\"+heartbeat.Version)\n+\t}\n+\n+\treturn slices.ContainsFunc(values, func(val string) bool {\n+\t\treturn strings.Contains(strings.ToLower(val), strings.ToLower(search))\n+\t})\n+}\n+\n+// Environment in which expressions will be evaluated.\n+type Environment struct {\n+\tInstance        *machineidv1.BotInstance\n+\tLatestHeartbeat *machineidv1.BotInstanceStatusHeartbeat\n+}\n+\n+// message satisfies messageEnv[T].\n+// func (env *Environment) message() *pb.BotInstance { return env.instance }\n+\n+// TODO Docs for NewBotInstanceExpressionParser\n+func NewBotInstanceExpressionParser() (*typical.Parser[*Environment, bool], error) {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2310175430",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58496,
        "pr_file": "lib/services/local/bot_instance.go",
        "discussion_id": "2310175430",
        "commented_code": "@@ -213,3 +196,95 @@ func (b *BotInstanceService) PatchBotInstance(\n \n \treturn nil, trace.CompareFailed(\"failed to update bot instance within %v iterations\", iterLimit)\n }\n+\n+func MatchBotInstance(b *machineidv1.BotInstance, botName string, search string, exp typical.Expression[*Environment, bool]) bool {\n+\tif botName != \"\" && b.Spec.BotName != botName {\n+\t\treturn false\n+\t}\n+\n+\tlatestHeartbeats := b.GetStatus().GetLatestHeartbeats()\n+\theartbeat := b.Status.InitialHeartbeat // Use initial heartbeat as a fallback\n+\tif len(latestHeartbeats) > 0 {\n+\t\theartbeat = latestHeartbeats[len(latestHeartbeats)-1]\n+\t}\n+\n+\tif exp != nil {\n+\t\tif match, err := exp.Evaluate(&Environment{\n+\t\t\tInstance:        b,\n+\t\t\tLatestHeartbeat: heartbeat,\n+\t\t}); err != nil || !match {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tif search == \"\" {\n+\t\treturn true\n+\t}\n+\n+\tvalues := []string{\n+\t\tb.Spec.BotName,\n+\t\tb.Spec.InstanceId,\n+\t}\n+\n+\tif heartbeat != nil {\n+\t\tvalues = append(values, heartbeat.Hostname, heartbeat.JoinMethod, heartbeat.Version, \"v\"+heartbeat.Version)\n+\t}\n+\n+\treturn slices.ContainsFunc(values, func(val string) bool {\n+\t\treturn strings.Contains(strings.ToLower(val), strings.ToLower(search))\n+\t})\n+}\n+\n+// Environment in which expressions will be evaluated.\n+type Environment struct {\n+\tInstance        *machineidv1.BotInstance\n+\tLatestHeartbeat *machineidv1.BotInstanceStatusHeartbeat\n+}\n+\n+// message satisfies messageEnv[T].\n+// func (env *Environment) message() *pb.BotInstance { return env.instance }\n+\n+// TODO Docs for NewBotInstanceExpressionParser\n+func NewBotInstanceExpressionParser() (*typical.Parser[*Environment, bool], error) {",
        "comment_created_at": "2025-08-29T13:32:10+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "I don't know that lib/services/local is the right home for this either. The local package is meant to house the storage layer for resources and I don't think there is anything particularly tied to the storage layer about this expression parser.",
        "pr_file_module": null
      }
    ]
  }
]