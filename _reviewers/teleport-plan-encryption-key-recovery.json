[
  {
    "discussion_id": "2309824946",
    "pr_number": 56325,
    "pr_file": "docs/pages/enroll-resources/server-access/guides/encrypted-session-recordings/encrypted-session-recordings.mdx",
    "created_at": "2025-08-29T10:39:47+00:00",
    "commented_code": "+---\n+title: Encrypted Session Recordings\n+description: How to enable encrypted session recordings using your CA key backend.\n+labels:\n+  - how-to\n+  - zero-trust\n+---\n+\n+Encrypted session recordings allow Teleport users to enable at-rest encryption\n+of their session recording data. This guide explains how to setup encrypted\n+session recordings.\n+\n+## How it works\n+\n+When encrypted recordings are enabled, Teleport will encrypt session recording\n+data before saving it to disk or long term storage. Encryption keys are\n+provisioned using the same key storage backend configured for CAs defined by\n+the `ca_key_params` section of the Teleport Auth Service configuration file. In\n+`node-sync` and `proxy-sync` session recording modes, session recording events\n+are sent directly to the Teleport Auth Service where they are encrypted prior\n+to being written to long term storage. In `node` and `proxy` session recording\n+modes, session recording events are encrypted locally at the Teleport-protected\n+server or Proxy Service instance before being written to disk for future upload\n+to the Auth Service.\n+\n+Decryption of session recordings for replay is always facilitated by the\n+Teleport Auth Service regardless of the session recording mode. This means\n+replays can be viewed using the Teleport Web UI, or by using `tsh play`\n+with a valid session ID. Replaying session recording files directly using\n+`tsh play` is not possible for encrypted files.\n+\n+## Step 1/2. Configure Teleport\n+\n+In this section, you will configure Teleport to encrypt session recordings\n+using the configured key storage backend.\n+\n+### Enable recording encryption\n+\n+Encrypted session recordings can be enabled through the Teleport Auth\n+Service configuration file.\n+\n+You can edit the Auth Service configuration file as follows:\n+\n+```yaml\n+# snippet from teleport.yaml\n+auth_service:\n+  session_recording_config:\n+    encryption:\n+      enabled: yes\n+```\n+\n+### Optional step: Configure key storage backend\n+\n+Session recording encryption keys are provisioned using the same key storage\n+backend configured for CAs. Software keys stored in Teleport's backend storage\n+are the default, but other backends can also be configured:\n+\n+- [AWS KMS](../../../../zero-trust-access/deploy-a-cluster/aws-kms.mdx)\n+- [Google Cloud KMS](../../../../zero-trust-access/deploy-a-cluster/gcp-kms.mdx)\n+- [HSM](../../../../zero-trust-access/deploy-a-cluster/hsm.mdx)\n+\n+It is important that all Teleport Auth Service instances have access to the",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2309824946",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56325,
        "pr_file": "docs/pages/enroll-resources/server-access/guides/encrypted-session-recordings/encrypted-session-recordings.mdx",
        "discussion_id": "2309824946",
        "commented_code": "@@ -0,0 +1,149 @@\n+---\n+title: Encrypted Session Recordings\n+description: How to enable encrypted session recordings using your CA key backend.\n+labels:\n+  - how-to\n+  - zero-trust\n+---\n+\n+Encrypted session recordings allow Teleport users to enable at-rest encryption\n+of their session recording data. This guide explains how to setup encrypted\n+session recordings.\n+\n+## How it works\n+\n+When encrypted recordings are enabled, Teleport will encrypt session recording\n+data before saving it to disk or long term storage. Encryption keys are\n+provisioned using the same key storage backend configured for CAs defined by\n+the `ca_key_params` section of the Teleport Auth Service configuration file. In\n+`node-sync` and `proxy-sync` session recording modes, session recording events\n+are sent directly to the Teleport Auth Service where they are encrypted prior\n+to being written to long term storage. In `node` and `proxy` session recording\n+modes, session recording events are encrypted locally at the Teleport-protected\n+server or Proxy Service instance before being written to disk for future upload\n+to the Auth Service.\n+\n+Decryption of session recordings for replay is always facilitated by the\n+Teleport Auth Service regardless of the session recording mode. This means\n+replays can be viewed using the Teleport Web UI, or by using `tsh play`\n+with a valid session ID. Replaying session recording files directly using\n+`tsh play` is not possible for encrypted files.\n+\n+## Step 1/2. Configure Teleport\n+\n+In this section, you will configure Teleport to encrypt session recordings\n+using the configured key storage backend.\n+\n+### Enable recording encryption\n+\n+Encrypted session recordings can be enabled through the Teleport Auth\n+Service configuration file.\n+\n+You can edit the Auth Service configuration file as follows:\n+\n+```yaml\n+# snippet from teleport.yaml\n+auth_service:\n+  session_recording_config:\n+    encryption:\n+      enabled: yes\n+```\n+\n+### Optional step: Configure key storage backend\n+\n+Session recording encryption keys are provisioned using the same key storage\n+backend configured for CAs. Software keys stored in Teleport's backend storage\n+are the default, but other backends can also be configured:\n+\n+- [AWS KMS](../../../../zero-trust-access/deploy-a-cluster/aws-kms.mdx)\n+- [Google Cloud KMS](../../../../zero-trust-access/deploy-a-cluster/gcp-kms.mdx)\n+- [HSM](../../../../zero-trust-access/deploy-a-cluster/hsm.mdx)\n+\n+It is important that all Teleport Auth Service instances have access to the",
        "comment_created_at": "2025-08-29T10:39:47+00:00",
        "comment_author": "tigrato",
        "comment_body": "IIRC, our recommendation for HSM is to use one per auth server so you don't have a single point of failure.\n\nWhile reading this I discussed with Erik a few improvements:\n- use a recovery key  - can be HSM or software key - that will allow us to recover access to all recordings in case of major failure of the HSM or incorrect destruction of the keys.\n- support multiple encryption keys. Generate a software key per session, encrypt the session with it and encrypt the software private key with the HSM key and store them into separate files - `session.encrypt.<fingerprint>`. This will allow clients to easily remove encryption keys if they are compromised or lost before re-encrypting all sessions - this will take ages. A quick shortcut of deleting the encrypted pk will be helpful.\n\n\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2310773488",
    "pr_number": 56325,
    "pr_file": "docs/pages/enroll-resources/server-access/guides/encrypted-session-recordings/encrypted-session-recordings.mdx",
    "created_at": "2025-08-29T17:58:34+00:00",
    "commented_code": "+---\n+title: Encrypted Session Recordings\n+description: How to enable encrypted session recordings using your CA key backend.\n+labels:\n+  - how-to\n+  - zero-trust\n+---\n+\n+Encrypted session recordings allow Teleport users to enable at-rest encryption\n+of their session recording data. This guide explains how to setup encrypted\n+session recordings.\n+\n+## How it works\n+\n+When encrypted recordings are enabled, Teleport will encrypt session recording\n+data before saving it to disk or long term storage. Encryption keys are\n+provisioned using the same key storage backend configured for CAs defined by\n+the `ca_key_params` section of the Teleport Auth Service configuration file. In\n+`node-sync` and `proxy-sync` session recording modes, session recording events\n+are sent directly to the Teleport Auth Service where they are encrypted prior\n+to being written to long term storage. In `node` and `proxy` session recording\n+modes, session recording events are encrypted locally at the Teleport-protected\n+server or Proxy Service instance before being written to disk for future upload\n+to the Auth Service.\n+\n+Decryption of session recordings for replay is always facilitated by the\n+Teleport Auth Service regardless of the session recording mode. This means\n+replays can be viewed using the Teleport Web UI, or by using `tsh play`\n+with a valid session ID. Replaying session recording files directly using\n+`tsh play` is not possible for encrypted files.\n+\n+## Step 1/2. Configure Teleport\n+\n+In this section, you will configure Teleport to encrypt session recordings\n+using the configured key storage backend.\n+\n+### Enable recording encryption\n+\n+Encrypted session recordings can be enabled through the Teleport Auth\n+Service configuration file.\n+\n+You can edit the Auth Service configuration file as follows:\n+\n+```yaml\n+# snippet from teleport.yaml\n+auth_service:\n+  session_recording_config:\n+    encryption:\n+      enabled: yes\n+```\n+\n+### Optional step: Configure key storage backend\n+\n+Session recording encryption keys are provisioned using the same key storage\n+backend configured for CAs. Software keys stored in Teleport's backend storage\n+are the default, but other backends can also be configured:\n+\n+- [AWS KMS](../../../../zero-trust-access/deploy-a-cluster/aws-kms.mdx)\n+- [Google Cloud KMS](../../../../zero-trust-access/deploy-a-cluster/gcp-kms.mdx)\n+- [HSM](../../../../zero-trust-access/deploy-a-cluster/hsm.mdx)\n+\n+It is important that all Teleport Auth Service instances have access to the\n+same keys and key storage backend to ensure all recorded sessions are always",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2310773488",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 56325,
        "pr_file": "docs/pages/enroll-resources/server-access/guides/encrypted-session-recordings/encrypted-session-recordings.mdx",
        "discussion_id": "2310773488",
        "commented_code": "@@ -0,0 +1,149 @@\n+---\n+title: Encrypted Session Recordings\n+description: How to enable encrypted session recordings using your CA key backend.\n+labels:\n+  - how-to\n+  - zero-trust\n+---\n+\n+Encrypted session recordings allow Teleport users to enable at-rest encryption\n+of their session recording data. This guide explains how to setup encrypted\n+session recordings.\n+\n+## How it works\n+\n+When encrypted recordings are enabled, Teleport will encrypt session recording\n+data before saving it to disk or long term storage. Encryption keys are\n+provisioned using the same key storage backend configured for CAs defined by\n+the `ca_key_params` section of the Teleport Auth Service configuration file. In\n+`node-sync` and `proxy-sync` session recording modes, session recording events\n+are sent directly to the Teleport Auth Service where they are encrypted prior\n+to being written to long term storage. In `node` and `proxy` session recording\n+modes, session recording events are encrypted locally at the Teleport-protected\n+server or Proxy Service instance before being written to disk for future upload\n+to the Auth Service.\n+\n+Decryption of session recordings for replay is always facilitated by the\n+Teleport Auth Service regardless of the session recording mode. This means\n+replays can be viewed using the Teleport Web UI, or by using `tsh play`\n+with a valid session ID. Replaying session recording files directly using\n+`tsh play` is not possible for encrypted files.\n+\n+## Step 1/2. Configure Teleport\n+\n+In this section, you will configure Teleport to encrypt session recordings\n+using the configured key storage backend.\n+\n+### Enable recording encryption\n+\n+Encrypted session recordings can be enabled through the Teleport Auth\n+Service configuration file.\n+\n+You can edit the Auth Service configuration file as follows:\n+\n+```yaml\n+# snippet from teleport.yaml\n+auth_service:\n+  session_recording_config:\n+    encryption:\n+      enabled: yes\n+```\n+\n+### Optional step: Configure key storage backend\n+\n+Session recording encryption keys are provisioned using the same key storage\n+backend configured for CAs. Software keys stored in Teleport's backend storage\n+are the default, but other backends can also be configured:\n+\n+- [AWS KMS](../../../../zero-trust-access/deploy-a-cluster/aws-kms.mdx)\n+- [Google Cloud KMS](../../../../zero-trust-access/deploy-a-cluster/gcp-kms.mdx)\n+- [HSM](../../../../zero-trust-access/deploy-a-cluster/hsm.mdx)\n+\n+It is important that all Teleport Auth Service instances have access to the\n+same keys and key storage backend to ensure all recorded sessions are always",
        "comment_created_at": "2025-08-29T17:58:34+00:00",
        "comment_author": "tigrato",
        "comment_body": "Can we re-write this to make it 100% clear that every auth server replica MUST access the same exact encryption key? This means sync HSM PK material or make a network HSM",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2299479547",
    "pr_number": 58229,
    "pr_file": "docs/pages/machine-workload-identity/machine-id/access-guides/argocd.mdx",
    "created_at": "2025-08-26T01:13:30+00:00",
    "commented_code": "+---\n+title: Machine ID with Argo CD\n+description: How to use Machine ID to enable Argo CD to connect to external Kubernetes clusters\n+labels:\n+ - how-to\n+ - mwi\n+---\n+\n+Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. It\n+runs in Kubernetes and can deploy applications to the same cluster or to other\n+\"external\" clusters.\n+\n+In this guide, you will configure the Machine ID agent, `tbot`, to provide Argo\n+CD with the connection details and short-lived credentials it needs to manage\n+clusters using Teleport's Kubernetes Access.\n+\n+## Prerequisite\n+\n+(!docs/pages/includes/edition-prereqs-tabs.mdx!)\n+\n+- Argo CD [installed](https://argo-cd.readthedocs.io/en/latest/#quick-start)\n+  in a Kubernetes cluster. This cluster does not need to be enrolled into\n+  Teleport.\n+- The Kubernetes cluster to which you'd like Argo CD to deploy applications.\n+  This cluster must be enrolled into Teleport, if you have not already done this,\n+  follow the [Enroll a Kubernetes Cluster](../../../enroll-resources/kubernetes-access/getting-started.mdx)\n+  guide.\n+- (!docs/pages/includes/tctl.mdx!)\n+- To configure Kubernetes and deploy `tbot` you will need\n+  [`kubectl`](https://kubernetes.io/docs/tasks/tools/) and\n+  [`helm`](https://helm.sh/docs/intro/install/) installed.\n+- To check clusters have been registered with Argo CD, you will need the\n+  [`argocd` CLI](https://argo-cd.readthedocs.io/en/stable/cli_installation/)\n+  installed.\n+\n+## Step 1/4. Configure Teleport and Kubernetes RBAC\n+\n+First, we need to configure the RBAC for both Teleport and Kubernetes in order\n+to grant the Machine ID agent the correct level of access.\n+\n+When forwarding requests to the Kubernetes API on behalf of a bot, the Teleport\n+Proxy attaches the groups configured (using `kubernetes_groups`) in the bot's\n+Teleport roles to the request. These groups are then used to configure a\n+RoleBinding or ClusterRoleBinding in Kubernetes to grant specific permissions\n+within the Kubernetes cluster to the bot.\n+\n+For the purpose of this guide, we will bind the `editor` group to the default\n+`edit` ClusterRole that is preconfigured in most Kubernetes clusters to give the\n+bot read and write access to resources in all the cluster namespaces.\n+\n+When configuring this in a production environment, you should consider:\n+\n+- If RoleBinding should be used instead of ClusterRoleBinding to limit the bot's\n+  access to a specific namespace.\n+- If a Role should be created that grants the bot the least privileges necessary\n+  rather than using a pre-existing general Role such as `edit`.\n+\n+To bind the `editor` group to the `edit` Cluster Role, run:\n+\n+```code\n+$ kubectl create clusterrolebinding teleport-editor-edit \\\n+  --clusterrole=edit \\\n+  --group=editor\n+```\n+\n+With the appropriate RoleBinding configured in Kubernetes to grant access to a\n+specific group, you now need to add this group to the role that the bot will\n+impersonate when producing credentials. You also need to grant the bot access\n+through Teleport to the cluster itself. This is done by creating a role that\n+grants the necessary permissions and then assigning this role to the bot.\n+\n+Create a file called `role.yaml` with the following content:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  name: example-role\n+spec:\n+  allow:\n+    kubernetes_labels:\n+      '*': '*'\n+    kubernetes_groups:\n+    - editor\n+    kubernetes_resources:\n+    - kind: \"*\"\n+      namespace: \"*\"\n+      name: \"*\"\n+      verbs: [\"*\"]\n+```\n+\n+Replace `example-role` with a descriptive name related to your use case.\n+\n+Adjust the `allow` field for your environment:\n+\n+- `kubernetes_labels` should be adjusted to grant access to only the clusters\n+  that the bot will need to access. The value shown, `'*': '*'` will grant\n+  access to all Kubernetes clusters.\n+- `editor` must match the name of the group you specified in the RoleBinding or\n+  ClusterRoleBinding.\n+- `kubernetes_resources` can be used to apply additional restrictions to what\n+  the bot can access within the Kubernetes cluster. These restrictions are\n+  layered upon the RBAC configured within the Kubernetes role itself.\n+\n+Use `tctl create -f ./role.yaml` to create the role.\n+\n+(!docs/pages/includes/create-role-using-web.mdx!)\n+\n+## Step 2/4. Create a bot\n+\n+Next, we need to create the bot. A bot is a Teleport identity for a machine or\n+group of machines.\n+\n+Create a file called `bot.yaml` with the following content:\n+\n+```yaml\n+kind: bot\n+version: v1\n+metadata:\n+  # name uniquely identifies the bot within Teleport\n+  name: example-bot\n+spec:\n+  # roles that will be granted to the bot.\n+  roles: [example-role]\n+```\n+\n+Make sure you replace `example-bot` with a unique, descriptive name for your Bot,\n+and replace `example-role` with the name of the role you created in the previous\n+step.\n+\n+Use `tctl create -f ./bot.yaml` to create the bot.\n+\n+## Step 3/4. Create a join token\n+\n+In order for `tbot` to be able to authenticate and join the Teleport cluster,\n+we need to configure a join token. There are a number of different available\n+[methods](../../../reference/join-methods.mdx), but for this guide we will use\n+the `kubernetes` method with a static JWKS.\n+\n+Please refer to the [Deploying tbot on Kubernetes](../deployment/kubernetes.mdx)\n+and [Deploying tbot on Kubernetes with OIDC](../deployment/kubernetes-oidc.mdx)\n+guides for more in-depth information.",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2299479547",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58229,
        "pr_file": "docs/pages/machine-workload-identity/machine-id/access-guides/argocd.mdx",
        "discussion_id": "2299479547",
        "commented_code": "@@ -0,0 +1,251 @@\n+---\n+title: Machine ID with Argo CD\n+description: How to use Machine ID to enable Argo CD to connect to external Kubernetes clusters\n+labels:\n+ - how-to\n+ - mwi\n+---\n+\n+Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. It\n+runs in Kubernetes and can deploy applications to the same cluster or to other\n+\"external\" clusters.\n+\n+In this guide, you will configure the Machine ID agent, `tbot`, to provide Argo\n+CD with the connection details and short-lived credentials it needs to manage\n+clusters using Teleport's Kubernetes Access.\n+\n+## Prerequisite\n+\n+(!docs/pages/includes/edition-prereqs-tabs.mdx!)\n+\n+- Argo CD [installed](https://argo-cd.readthedocs.io/en/latest/#quick-start)\n+  in a Kubernetes cluster. This cluster does not need to be enrolled into\n+  Teleport.\n+- The Kubernetes cluster to which you'd like Argo CD to deploy applications.\n+  This cluster must be enrolled into Teleport, if you have not already done this,\n+  follow the [Enroll a Kubernetes Cluster](../../../enroll-resources/kubernetes-access/getting-started.mdx)\n+  guide.\n+- (!docs/pages/includes/tctl.mdx!)\n+- To configure Kubernetes and deploy `tbot` you will need\n+  [`kubectl`](https://kubernetes.io/docs/tasks/tools/) and\n+  [`helm`](https://helm.sh/docs/intro/install/) installed.\n+- To check clusters have been registered with Argo CD, you will need the\n+  [`argocd` CLI](https://argo-cd.readthedocs.io/en/stable/cli_installation/)\n+  installed.\n+\n+## Step 1/4. Configure Teleport and Kubernetes RBAC\n+\n+First, we need to configure the RBAC for both Teleport and Kubernetes in order\n+to grant the Machine ID agent the correct level of access.\n+\n+When forwarding requests to the Kubernetes API on behalf of a bot, the Teleport\n+Proxy attaches the groups configured (using `kubernetes_groups`) in the bot's\n+Teleport roles to the request. These groups are then used to configure a\n+RoleBinding or ClusterRoleBinding in Kubernetes to grant specific permissions\n+within the Kubernetes cluster to the bot.\n+\n+For the purpose of this guide, we will bind the `editor` group to the default\n+`edit` ClusterRole that is preconfigured in most Kubernetes clusters to give the\n+bot read and write access to resources in all the cluster namespaces.\n+\n+When configuring this in a production environment, you should consider:\n+\n+- If RoleBinding should be used instead of ClusterRoleBinding to limit the bot's\n+  access to a specific namespace.\n+- If a Role should be created that grants the bot the least privileges necessary\n+  rather than using a pre-existing general Role such as `edit`.\n+\n+To bind the `editor` group to the `edit` Cluster Role, run:\n+\n+```code\n+$ kubectl create clusterrolebinding teleport-editor-edit \\\n+  --clusterrole=edit \\\n+  --group=editor\n+```\n+\n+With the appropriate RoleBinding configured in Kubernetes to grant access to a\n+specific group, you now need to add this group to the role that the bot will\n+impersonate when producing credentials. You also need to grant the bot access\n+through Teleport to the cluster itself. This is done by creating a role that\n+grants the necessary permissions and then assigning this role to the bot.\n+\n+Create a file called `role.yaml` with the following content:\n+\n+```yaml\n+kind: role\n+version: v7\n+metadata:\n+  name: example-role\n+spec:\n+  allow:\n+    kubernetes_labels:\n+      '*': '*'\n+    kubernetes_groups:\n+    - editor\n+    kubernetes_resources:\n+    - kind: \"*\"\n+      namespace: \"*\"\n+      name: \"*\"\n+      verbs: [\"*\"]\n+```\n+\n+Replace `example-role` with a descriptive name related to your use case.\n+\n+Adjust the `allow` field for your environment:\n+\n+- `kubernetes_labels` should be adjusted to grant access to only the clusters\n+  that the bot will need to access. The value shown, `'*': '*'` will grant\n+  access to all Kubernetes clusters.\n+- `editor` must match the name of the group you specified in the RoleBinding or\n+  ClusterRoleBinding.\n+- `kubernetes_resources` can be used to apply additional restrictions to what\n+  the bot can access within the Kubernetes cluster. These restrictions are\n+  layered upon the RBAC configured within the Kubernetes role itself.\n+\n+Use `tctl create -f ./role.yaml` to create the role.\n+\n+(!docs/pages/includes/create-role-using-web.mdx!)\n+\n+## Step 2/4. Create a bot\n+\n+Next, we need to create the bot. A bot is a Teleport identity for a machine or\n+group of machines.\n+\n+Create a file called `bot.yaml` with the following content:\n+\n+```yaml\n+kind: bot\n+version: v1\n+metadata:\n+  # name uniquely identifies the bot within Teleport\n+  name: example-bot\n+spec:\n+  # roles that will be granted to the bot.\n+  roles: [example-role]\n+```\n+\n+Make sure you replace `example-bot` with a unique, descriptive name for your Bot,\n+and replace `example-role` with the name of the role you created in the previous\n+step.\n+\n+Use `tctl create -f ./bot.yaml` to create the bot.\n+\n+## Step 3/4. Create a join token\n+\n+In order for `tbot` to be able to authenticate and join the Teleport cluster,\n+we need to configure a join token. There are a number of different available\n+[methods](../../../reference/join-methods.mdx), but for this guide we will use\n+the `kubernetes` method with a static JWKS.\n+\n+Please refer to the [Deploying tbot on Kubernetes](../deployment/kubernetes.mdx)\n+and [Deploying tbot on Kubernetes with OIDC](../deployment/kubernetes-oidc.mdx)\n+guides for more in-depth information.",
        "comment_created_at": "2025-08-26T01:13:30+00:00",
        "comment_author": "timothyb89",
        "comment_body": "I wonder if we should specifically caution against using `static_jwks` for OIDC-enabled providers (especially EKS) since this will appear to work initially and break once the keys get rotated.\r\n\r\n(I wish it was easy to configure and we could just put the two different variants in a tab view or something, but unfortunately OIDC is kind of annoying to configure and has a bunch of caveats... but then I suppose `static_jwks` does too, sigh.)",
        "pr_file_module": null
      }
    ]
  }
]