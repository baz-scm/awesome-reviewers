[
  {
    "discussion_id": "2301360782",
    "pr_number": 58046,
    "pr_file": "tool/tctl/common/plugin/awsic.go",
    "created_at": "2025-08-26T15:23:56+00:00",
    "commented_code": "return nil\n }\n+\n+type awsICEditArgs struct {\n+\tcmd           *kingpin.CmdClause\n+\tpluginName    string\n+\trolesSyncMode string\n+}\n+\n+func (p *PluginsCommand) initEditAWSIC(parent *kingpin.CmdClause) {\n+\tp.edit.awsIC.cmd = parent.Command(\"awsic\", \"Edit an AWS IAM Identity Center integration's settings.\")\n+\tcmd := p.edit.awsIC.cmd\n+\n+\tcmd.Flag(awsicPluginNameFlag, awsicPluginNameHelp).\n+\t\tDefault(defaultAWSICPluginName).\n+\t\tStringVar(&p.edit.awsIC.pluginName)\n+\n+\tcmd.Flag(awsicRolesSyncModeFlag, awsicRolesSyncModeHelp).\n+\t\tEnumVar(&p.edit.awsIC.rolesSyncMode, types.AWSICRolesSyncModeAll, types.AWSICRolesSyncModeNone)\n+}\n+\n+func (p *PluginsCommand) EditAWSIC(ctx context.Context, args installPluginArgs) error {\n+\tplugin, err := args.plugins.GetPlugin(ctx, &pluginsv1.GetPluginRequest{\n+\t\tName:        p.edit.awsIC.pluginName,\n+\t\tWithSecrets: true,\n+\t})\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\ticSettings := plugin.Spec.GetAwsIc()\n+\tif icSettings == nil {\n+\t\treturn trace.BadParameter(\"target is not an IC plugin\")",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2301360782",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58046,
        "pr_file": "tool/tctl/common/plugin/awsic.go",
        "discussion_id": "2301360782",
        "commented_code": "@@ -316,3 +339,49 @@ func (p *PluginsCommand) InstallAWSIC(ctx context.Context, args installPluginArg\n \n \treturn nil\n }\n+\n+type awsICEditArgs struct {\n+\tcmd           *kingpin.CmdClause\n+\tpluginName    string\n+\trolesSyncMode string\n+}\n+\n+func (p *PluginsCommand) initEditAWSIC(parent *kingpin.CmdClause) {\n+\tp.edit.awsIC.cmd = parent.Command(\"awsic\", \"Edit an AWS IAM Identity Center integration's settings.\")\n+\tcmd := p.edit.awsIC.cmd\n+\n+\tcmd.Flag(awsicPluginNameFlag, awsicPluginNameHelp).\n+\t\tDefault(defaultAWSICPluginName).\n+\t\tStringVar(&p.edit.awsIC.pluginName)\n+\n+\tcmd.Flag(awsicRolesSyncModeFlag, awsicRolesSyncModeHelp).\n+\t\tEnumVar(&p.edit.awsIC.rolesSyncMode, types.AWSICRolesSyncModeAll, types.AWSICRolesSyncModeNone)\n+}\n+\n+func (p *PluginsCommand) EditAWSIC(ctx context.Context, args installPluginArgs) error {\n+\tplugin, err := args.plugins.GetPlugin(ctx, &pluginsv1.GetPluginRequest{\n+\t\tName:        p.edit.awsIC.pluginName,\n+\t\tWithSecrets: true,\n+\t})\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\ticSettings := plugin.Spec.GetAwsIc()\n+\tif icSettings == nil {\n+\t\treturn trace.BadParameter(\"target is not an IC plugin\")",
        "comment_created_at": "2025-08-26T15:23:56+00:00",
        "comment_author": "r0mant",
        "comment_body": "```suggestion\r\n\t\treturn trace.BadParameter(\"%q is not an AWS Identity Center integration\", p.edit.awsIC.pluginName)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288778956",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-20T16:56:30+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx        context.Context\n+\tcancel     context.CancelFunc\n+\tclt        events.SessionStreamer\n+\tsessionID  string\n+\tlogger     *slog.Logger\n+\tmu         sync.Mutex\n+\tactiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.activeTask != nil {\n+\t\ts.activeTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.activeTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.activeTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)\n+\t\t\t\ts.stream.Unlock()\n+\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\ts.terminal.Lock()\n+\t\t\t_, _ = s.terminal.vt.Write(evt.Data)\n+\t\t\ts.terminal.Unlock()\n+\n+\t\t\tif evt.DelayMilliseconds >= req.startOffset {\n+\t\t\t\taddToBatch(eventTypeSessionPrint, evt.DelayMilliseconds, evt.Data)\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionEnd:\n+\t\t\tendTime := int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\n+\t\t\tif endTime >= req.startOffset && endTime <= req.endOffset {\n+\t\t\t\taddToBatch(eventTypeSessionEnd, endTime, []byte(evt.EndTime.Format(time.RFC3339)))\n+\t\t\t}\n+\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn false\n+\n+\t\tcase *apievents.Resize:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeResize, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\ts.stream.Lock()\n+\n+\tbuffered := make([]apievents.AuditEvent, len(s.stream.bufferedEvents))\n+\tcopy(buffered, s.stream.bufferedEvents)\n+\ts.stream.bufferedEvents = nil\n+\n+\ts.stream.Unlock()\n+\n+\tfor _, evt := range buffered {\n+\t\tif !processEvent(evt) {\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase err := <-errorsChan:\n+\t\t\tflushBatch()\n+\t\t\tif err != nil {\n+\t\t\t\ts.sendError(err, req.requestID)\n+\t\t\t}\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase evt, ok := <-eventsChan:\n+\t\t\tif !ok {\n+\t\t\t\tflushBatch()\n+\t\t\t\tif req.requestCurrentScreen && !screenSent && inTimeRange {\n+\t\t\t\t\ts.sendCurrentScreen(req.requestID, req.startOffset)\n+\t\t\t\t}\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif !processEvent(evt) {\n+\t\t\t\tflushBatch()\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// resizeTerminal resizes the terminal based on the provided size string.\n+func (s *recordingPlayback) resizeTerminal(size string) {\n+\tparts := strings.Split(size, \":\")\n+\tif len(parts) != 2 {\n+\t\treturn\n+\t}\n+\n+\tcols, cErr := strconv.Atoi(parts[0])\n+\trows, rErr := strconv.Atoi(parts[1])\n+\n+\tif cmp.Or(cErr, rErr) != nil {\n+\t\treturn\n+\t}\n+\n+\ts.terminal.Lock()\n+\tdefer s.terminal.Unlock()\n+\n+\ts.terminal.vt.Resize(cols, rows)\n+}\n+\n+// writeMessage writes a message to the websocket connection with a timeout.\n+func (s *recordingPlayback) writeMessage(msgType int, data []byte) error {\n+\ts.websocket.Lock()\n+\tdefer s.websocket.Unlock()\n+\n+\tif err := s.websocket.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn s.websocket.WriteMessage(msgType, data)\n+}\n+\n+// sendEvent sends a single event to the client.\n+func (s *recordingPlayback) sendEvent(eventType byte, timestamp int64, data []byte, requestID int) {\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventType, timestamp, data, requestID)\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event\", \"session_id\", s.sessionID, \"error\", err)\n+\t}\n+}\n+\n+// sendEventBatch sends a batch of events to the client.\n+func (s *recordingPlayback) sendEventBatch(batch []sessionEvent, requestID int) {\n+\ttotalSize := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\ttotalSize += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tbuf := make([]byte, totalSize)\n+\n+\tbuf[0] = eventTypeBatch\n+\tbinary.BigEndian.PutUint32(buf[1:5], uint32(len(batch)))\n+\tbinary.BigEndian.PutUint32(buf[5:9], uint32(requestID))\n+\n+\toffset := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\tencodeEvent(buf, offset, evt.eventType, evt.timestamp, evt.data, requestID)\n+\n+\t\toffset += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event batch\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"error\", err,\n+\t\t\t\"batch_size\", len(batch),\n+\t\t\t\"buffer_size\", totalSize)\n+\t}\n+}\n+\n+// sendError sends an error event to the client.\n+func (s *recordingPlayback) sendError(err error, requestID int) {\n+\ts.sendEvent(eventTypeError, 0, []byte(err.Error()), requestID)\n+}\n+\n+// sendCurrentScreen sends the current terminal screen state to the client.\n+func (s *recordingPlayback) sendCurrentScreen(requestID int, timestamp int64) {\n+\ts.terminal.RLock()\n+\tstate := s.terminal.vt.DumpState()\n+\tcols, rows := s.terminal.vt.Size()\n+\tcursor := s.terminal.vt.Cursor()\n+\ts.terminal.RUnlock()\n+\n+\tdata := encodeScreenEvent(state, cols, rows, cursor)\n+\n+\ts.sendEvent(eventTypeScreen, timestamp, data, requestID)\n+}\n+\n+// encodeScreenEvent encodes the current terminal screen state into a byte slice.\n+func encodeScreenEvent(state vt10x.TerminalState, cols, rows int, cursor vt10x.Cursor) []byte {\n+\tdata := terminal.VtStateToANSI(state)\n+\n+\teventData := make([]byte, requestHeaderSize+len(data))\n+\teventData[0] = eventTypeScreen\n+\n+\tbinary.BigEndian.PutUint32(eventData[1:5], uint32(cols))\n+\tbinary.BigEndian.PutUint32(eventData[5:9], uint32(rows))\n+\tbinary.BigEndian.PutUint32(eventData[9:13], uint32(cursor.X))\n+\tbinary.BigEndian.PutUint32(eventData[13:17], uint32(cursor.Y))\n+\tbinary.BigEndian.PutUint32(eventData[17:21], uint32(len(data)))\n+\n+\tcopy(eventData[requestHeaderSize:], data)\n+\n+\treturn eventData\n+}\n+\n+// encodeEvent encodes a session event into a byte slice.\n+func encodeEvent(buf []byte, offset int, eventType byte, timestamp int64, data []byte, requestID int) {\n+\tbuf[offset] = eventType\n+\n+\tbinary.BigEndian.PutUint64(buf[offset+1:offset+9], uint64(timestamp))\n+\tbinary.BigEndian.PutUint32(buf[offset+9:offset+13], uint32(len(data)))\n+\tbinary.BigEndian.PutUint32(buf[offset+13:offset+17], uint32(requestID))\n+\n+\tcopy(buf[offset+responseHeaderSize:], data)\n+}\n+\n+// encodeTime encodes the start and end times into a byte slice.\n+func encodeTime(startTime, endTime int64) []byte {\n+\tbuf := make([]byte, 16)\n+\n+\tbinary.BigEndian.PutUint64(buf, uint64(startTime))\n+\tbinary.BigEndian.PutUint64(buf[8:], uint64(endTime))\n+\n+\treturn buf\n+}\n+\n+// decodeBinaryRequest decodes a binary request from the client.\n+func decodeBinaryRequest(data []byte) (*fetchRequest, error) {\n+\tif len(data) != requestHeaderSize {\n+\t\treturn nil, trace.BadParameter(\"invalid request size: expected %d bytes, got %d bytes\", requestHeaderSize, len(data))\n+\t}\n+\n+\treq := &fetchRequest{\n+\t\trequestType:          data[0],\n+\t\tstartOffset:          int64(binary.BigEndian.Uint64(data[1:9])),\n+\t\tendOffset:            int64(binary.BigEndian.Uint64(data[9:17])),\n+\t\trequestID:            int(binary.BigEndian.Uint32(data[17:21])),\n+\t\trequestCurrentScreen: data[21] == 1,\n+\t}\n+\n+\treturn req, nil\n+}\n+\n+// getEventTime extracts the event time from an AuditEvent.\n+func getEventTime(evt apievents.AuditEvent) int64 {\n+\tswitch evt := evt.(type) {\n+\tcase *apievents.SessionPrint:\n+\t\treturn evt.DelayMilliseconds\n+\tcase *apievents.SessionEnd:\n+\t\treturn int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\tdefault:\n+\t\treturn 0\n+\t}\n+}\n+\n+// validateRequest validates the fetch request parameters.\n+func validateRequest(req *fetchRequest) error {\n+\tif req.startOffset < 0 || req.endOffset < 0 {\n+\t\treturn fmt.Errorf(\"invalid time range\")\n+\t}\n+\n+\tif req.endOffset < req.startOffset {\n+\t\treturn fmt.Errorf(\"end time before start time\")",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2288778956",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2288778956",
        "commented_code": "@@ -0,0 +1,637 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx        context.Context\n+\tcancel     context.CancelFunc\n+\tclt        events.SessionStreamer\n+\tsessionID  string\n+\tlogger     *slog.Logger\n+\tmu         sync.Mutex\n+\tactiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.activeTask != nil {\n+\t\ts.activeTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.activeTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.activeTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)\n+\t\t\t\ts.stream.Unlock()\n+\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\ts.terminal.Lock()\n+\t\t\t_, _ = s.terminal.vt.Write(evt.Data)\n+\t\t\ts.terminal.Unlock()\n+\n+\t\t\tif evt.DelayMilliseconds >= req.startOffset {\n+\t\t\t\taddToBatch(eventTypeSessionPrint, evt.DelayMilliseconds, evt.Data)\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionEnd:\n+\t\t\tendTime := int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\n+\t\t\tif endTime >= req.startOffset && endTime <= req.endOffset {\n+\t\t\t\taddToBatch(eventTypeSessionEnd, endTime, []byte(evt.EndTime.Format(time.RFC3339)))\n+\t\t\t}\n+\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn false\n+\n+\t\tcase *apievents.Resize:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeResize, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\ts.stream.Lock()\n+\n+\tbuffered := make([]apievents.AuditEvent, len(s.stream.bufferedEvents))\n+\tcopy(buffered, s.stream.bufferedEvents)\n+\ts.stream.bufferedEvents = nil\n+\n+\ts.stream.Unlock()\n+\n+\tfor _, evt := range buffered {\n+\t\tif !processEvent(evt) {\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase err := <-errorsChan:\n+\t\t\tflushBatch()\n+\t\t\tif err != nil {\n+\t\t\t\ts.sendError(err, req.requestID)\n+\t\t\t}\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase evt, ok := <-eventsChan:\n+\t\t\tif !ok {\n+\t\t\t\tflushBatch()\n+\t\t\t\tif req.requestCurrentScreen && !screenSent && inTimeRange {\n+\t\t\t\t\ts.sendCurrentScreen(req.requestID, req.startOffset)\n+\t\t\t\t}\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif !processEvent(evt) {\n+\t\t\t\tflushBatch()\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// resizeTerminal resizes the terminal based on the provided size string.\n+func (s *recordingPlayback) resizeTerminal(size string) {\n+\tparts := strings.Split(size, \":\")\n+\tif len(parts) != 2 {\n+\t\treturn\n+\t}\n+\n+\tcols, cErr := strconv.Atoi(parts[0])\n+\trows, rErr := strconv.Atoi(parts[1])\n+\n+\tif cmp.Or(cErr, rErr) != nil {\n+\t\treturn\n+\t}\n+\n+\ts.terminal.Lock()\n+\tdefer s.terminal.Unlock()\n+\n+\ts.terminal.vt.Resize(cols, rows)\n+}\n+\n+// writeMessage writes a message to the websocket connection with a timeout.\n+func (s *recordingPlayback) writeMessage(msgType int, data []byte) error {\n+\ts.websocket.Lock()\n+\tdefer s.websocket.Unlock()\n+\n+\tif err := s.websocket.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn s.websocket.WriteMessage(msgType, data)\n+}\n+\n+// sendEvent sends a single event to the client.\n+func (s *recordingPlayback) sendEvent(eventType byte, timestamp int64, data []byte, requestID int) {\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventType, timestamp, data, requestID)\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event\", \"session_id\", s.sessionID, \"error\", err)\n+\t}\n+}\n+\n+// sendEventBatch sends a batch of events to the client.\n+func (s *recordingPlayback) sendEventBatch(batch []sessionEvent, requestID int) {\n+\ttotalSize := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\ttotalSize += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tbuf := make([]byte, totalSize)\n+\n+\tbuf[0] = eventTypeBatch\n+\tbinary.BigEndian.PutUint32(buf[1:5], uint32(len(batch)))\n+\tbinary.BigEndian.PutUint32(buf[5:9], uint32(requestID))\n+\n+\toffset := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\tencodeEvent(buf, offset, evt.eventType, evt.timestamp, evt.data, requestID)\n+\n+\t\toffset += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event batch\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"error\", err,\n+\t\t\t\"batch_size\", len(batch),\n+\t\t\t\"buffer_size\", totalSize)\n+\t}\n+}\n+\n+// sendError sends an error event to the client.\n+func (s *recordingPlayback) sendError(err error, requestID int) {\n+\ts.sendEvent(eventTypeError, 0, []byte(err.Error()), requestID)\n+}\n+\n+// sendCurrentScreen sends the current terminal screen state to the client.\n+func (s *recordingPlayback) sendCurrentScreen(requestID int, timestamp int64) {\n+\ts.terminal.RLock()\n+\tstate := s.terminal.vt.DumpState()\n+\tcols, rows := s.terminal.vt.Size()\n+\tcursor := s.terminal.vt.Cursor()\n+\ts.terminal.RUnlock()\n+\n+\tdata := encodeScreenEvent(state, cols, rows, cursor)\n+\n+\ts.sendEvent(eventTypeScreen, timestamp, data, requestID)\n+}\n+\n+// encodeScreenEvent encodes the current terminal screen state into a byte slice.\n+func encodeScreenEvent(state vt10x.TerminalState, cols, rows int, cursor vt10x.Cursor) []byte {\n+\tdata := terminal.VtStateToANSI(state)\n+\n+\teventData := make([]byte, requestHeaderSize+len(data))\n+\teventData[0] = eventTypeScreen\n+\n+\tbinary.BigEndian.PutUint32(eventData[1:5], uint32(cols))\n+\tbinary.BigEndian.PutUint32(eventData[5:9], uint32(rows))\n+\tbinary.BigEndian.PutUint32(eventData[9:13], uint32(cursor.X))\n+\tbinary.BigEndian.PutUint32(eventData[13:17], uint32(cursor.Y))\n+\tbinary.BigEndian.PutUint32(eventData[17:21], uint32(len(data)))\n+\n+\tcopy(eventData[requestHeaderSize:], data)\n+\n+\treturn eventData\n+}\n+\n+// encodeEvent encodes a session event into a byte slice.\n+func encodeEvent(buf []byte, offset int, eventType byte, timestamp int64, data []byte, requestID int) {\n+\tbuf[offset] = eventType\n+\n+\tbinary.BigEndian.PutUint64(buf[offset+1:offset+9], uint64(timestamp))\n+\tbinary.BigEndian.PutUint32(buf[offset+9:offset+13], uint32(len(data)))\n+\tbinary.BigEndian.PutUint32(buf[offset+13:offset+17], uint32(requestID))\n+\n+\tcopy(buf[offset+responseHeaderSize:], data)\n+}\n+\n+// encodeTime encodes the start and end times into a byte slice.\n+func encodeTime(startTime, endTime int64) []byte {\n+\tbuf := make([]byte, 16)\n+\n+\tbinary.BigEndian.PutUint64(buf, uint64(startTime))\n+\tbinary.BigEndian.PutUint64(buf[8:], uint64(endTime))\n+\n+\treturn buf\n+}\n+\n+// decodeBinaryRequest decodes a binary request from the client.\n+func decodeBinaryRequest(data []byte) (*fetchRequest, error) {\n+\tif len(data) != requestHeaderSize {\n+\t\treturn nil, trace.BadParameter(\"invalid request size: expected %d bytes, got %d bytes\", requestHeaderSize, len(data))\n+\t}\n+\n+\treq := &fetchRequest{\n+\t\trequestType:          data[0],\n+\t\tstartOffset:          int64(binary.BigEndian.Uint64(data[1:9])),\n+\t\tendOffset:            int64(binary.BigEndian.Uint64(data[9:17])),\n+\t\trequestID:            int(binary.BigEndian.Uint32(data[17:21])),\n+\t\trequestCurrentScreen: data[21] == 1,\n+\t}\n+\n+\treturn req, nil\n+}\n+\n+// getEventTime extracts the event time from an AuditEvent.\n+func getEventTime(evt apievents.AuditEvent) int64 {\n+\tswitch evt := evt.(type) {\n+\tcase *apievents.SessionPrint:\n+\t\treturn evt.DelayMilliseconds\n+\tcase *apievents.SessionEnd:\n+\t\treturn int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\tdefault:\n+\t\treturn 0\n+\t}\n+}\n+\n+// validateRequest validates the fetch request parameters.\n+func validateRequest(req *fetchRequest) error {\n+\tif req.startOffset < 0 || req.endOffset < 0 {\n+\t\treturn fmt.Errorf(\"invalid time range\")\n+\t}\n+\n+\tif req.endOffset < req.startOffset {\n+\t\treturn fmt.Errorf(\"end time before start time\")",
        "comment_created_at": "2025-08-20T16:56:30+00:00",
        "comment_author": "zmb3",
        "comment_body": "```suggestion\n\t\treturn errors.New(\"end time before start time\")\n```\n\nThough I'd consider just adding this as a condition to the previous if statement. The same error message works in both cases.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288780358",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-20T16:57:15+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx        context.Context\n+\tcancel     context.CancelFunc\n+\tclt        events.SessionStreamer\n+\tsessionID  string\n+\tlogger     *slog.Logger\n+\tmu         sync.Mutex\n+\tactiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.activeTask != nil {\n+\t\ts.activeTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.activeTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.activeTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)\n+\t\t\t\ts.stream.Unlock()\n+\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\ts.terminal.Lock()\n+\t\t\t_, _ = s.terminal.vt.Write(evt.Data)\n+\t\t\ts.terminal.Unlock()\n+\n+\t\t\tif evt.DelayMilliseconds >= req.startOffset {\n+\t\t\t\taddToBatch(eventTypeSessionPrint, evt.DelayMilliseconds, evt.Data)\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionEnd:\n+\t\t\tendTime := int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\n+\t\t\tif endTime >= req.startOffset && endTime <= req.endOffset {\n+\t\t\t\taddToBatch(eventTypeSessionEnd, endTime, []byte(evt.EndTime.Format(time.RFC3339)))\n+\t\t\t}\n+\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn false\n+\n+\t\tcase *apievents.Resize:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeResize, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\ts.stream.Lock()\n+\n+\tbuffered := make([]apievents.AuditEvent, len(s.stream.bufferedEvents))\n+\tcopy(buffered, s.stream.bufferedEvents)\n+\ts.stream.bufferedEvents = nil\n+\n+\ts.stream.Unlock()\n+\n+\tfor _, evt := range buffered {\n+\t\tif !processEvent(evt) {\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase err := <-errorsChan:\n+\t\t\tflushBatch()\n+\t\t\tif err != nil {\n+\t\t\t\ts.sendError(err, req.requestID)\n+\t\t\t}\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase evt, ok := <-eventsChan:\n+\t\t\tif !ok {\n+\t\t\t\tflushBatch()\n+\t\t\t\tif req.requestCurrentScreen && !screenSent && inTimeRange {\n+\t\t\t\t\ts.sendCurrentScreen(req.requestID, req.startOffset)\n+\t\t\t\t}\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif !processEvent(evt) {\n+\t\t\t\tflushBatch()\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// resizeTerminal resizes the terminal based on the provided size string.\n+func (s *recordingPlayback) resizeTerminal(size string) {\n+\tparts := strings.Split(size, \":\")\n+\tif len(parts) != 2 {\n+\t\treturn\n+\t}\n+\n+\tcols, cErr := strconv.Atoi(parts[0])\n+\trows, rErr := strconv.Atoi(parts[1])\n+\n+\tif cmp.Or(cErr, rErr) != nil {\n+\t\treturn\n+\t}\n+\n+\ts.terminal.Lock()\n+\tdefer s.terminal.Unlock()\n+\n+\ts.terminal.vt.Resize(cols, rows)\n+}\n+\n+// writeMessage writes a message to the websocket connection with a timeout.\n+func (s *recordingPlayback) writeMessage(msgType int, data []byte) error {\n+\ts.websocket.Lock()\n+\tdefer s.websocket.Unlock()\n+\n+\tif err := s.websocket.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn s.websocket.WriteMessage(msgType, data)\n+}\n+\n+// sendEvent sends a single event to the client.\n+func (s *recordingPlayback) sendEvent(eventType byte, timestamp int64, data []byte, requestID int) {\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventType, timestamp, data, requestID)\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event\", \"session_id\", s.sessionID, \"error\", err)\n+\t}\n+}\n+\n+// sendEventBatch sends a batch of events to the client.\n+func (s *recordingPlayback) sendEventBatch(batch []sessionEvent, requestID int) {\n+\ttotalSize := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\ttotalSize += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tbuf := make([]byte, totalSize)\n+\n+\tbuf[0] = eventTypeBatch\n+\tbinary.BigEndian.PutUint32(buf[1:5], uint32(len(batch)))\n+\tbinary.BigEndian.PutUint32(buf[5:9], uint32(requestID))\n+\n+\toffset := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\tencodeEvent(buf, offset, evt.eventType, evt.timestamp, evt.data, requestID)\n+\n+\t\toffset += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event batch\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"error\", err,\n+\t\t\t\"batch_size\", len(batch),\n+\t\t\t\"buffer_size\", totalSize)\n+\t}\n+}\n+\n+// sendError sends an error event to the client.\n+func (s *recordingPlayback) sendError(err error, requestID int) {\n+\ts.sendEvent(eventTypeError, 0, []byte(err.Error()), requestID)\n+}\n+\n+// sendCurrentScreen sends the current terminal screen state to the client.\n+func (s *recordingPlayback) sendCurrentScreen(requestID int, timestamp int64) {\n+\ts.terminal.RLock()\n+\tstate := s.terminal.vt.DumpState()\n+\tcols, rows := s.terminal.vt.Size()\n+\tcursor := s.terminal.vt.Cursor()\n+\ts.terminal.RUnlock()\n+\n+\tdata := encodeScreenEvent(state, cols, rows, cursor)\n+\n+\ts.sendEvent(eventTypeScreen, timestamp, data, requestID)\n+}\n+\n+// encodeScreenEvent encodes the current terminal screen state into a byte slice.\n+func encodeScreenEvent(state vt10x.TerminalState, cols, rows int, cursor vt10x.Cursor) []byte {\n+\tdata := terminal.VtStateToANSI(state)\n+\n+\teventData := make([]byte, requestHeaderSize+len(data))\n+\teventData[0] = eventTypeScreen\n+\n+\tbinary.BigEndian.PutUint32(eventData[1:5], uint32(cols))\n+\tbinary.BigEndian.PutUint32(eventData[5:9], uint32(rows))\n+\tbinary.BigEndian.PutUint32(eventData[9:13], uint32(cursor.X))\n+\tbinary.BigEndian.PutUint32(eventData[13:17], uint32(cursor.Y))\n+\tbinary.BigEndian.PutUint32(eventData[17:21], uint32(len(data)))\n+\n+\tcopy(eventData[requestHeaderSize:], data)\n+\n+\treturn eventData\n+}\n+\n+// encodeEvent encodes a session event into a byte slice.\n+func encodeEvent(buf []byte, offset int, eventType byte, timestamp int64, data []byte, requestID int) {\n+\tbuf[offset] = eventType\n+\n+\tbinary.BigEndian.PutUint64(buf[offset+1:offset+9], uint64(timestamp))\n+\tbinary.BigEndian.PutUint32(buf[offset+9:offset+13], uint32(len(data)))\n+\tbinary.BigEndian.PutUint32(buf[offset+13:offset+17], uint32(requestID))\n+\n+\tcopy(buf[offset+responseHeaderSize:], data)\n+}\n+\n+// encodeTime encodes the start and end times into a byte slice.\n+func encodeTime(startTime, endTime int64) []byte {\n+\tbuf := make([]byte, 16)\n+\n+\tbinary.BigEndian.PutUint64(buf, uint64(startTime))\n+\tbinary.BigEndian.PutUint64(buf[8:], uint64(endTime))\n+\n+\treturn buf\n+}\n+\n+// decodeBinaryRequest decodes a binary request from the client.\n+func decodeBinaryRequest(data []byte) (*fetchRequest, error) {\n+\tif len(data) != requestHeaderSize {\n+\t\treturn nil, trace.BadParameter(\"invalid request size: expected %d bytes, got %d bytes\", requestHeaderSize, len(data))\n+\t}\n+\n+\treq := &fetchRequest{\n+\t\trequestType:          data[0],\n+\t\tstartOffset:          int64(binary.BigEndian.Uint64(data[1:9])),\n+\t\tendOffset:            int64(binary.BigEndian.Uint64(data[9:17])),\n+\t\trequestID:            int(binary.BigEndian.Uint32(data[17:21])),\n+\t\trequestCurrentScreen: data[21] == 1,\n+\t}\n+\n+\treturn req, nil\n+}\n+\n+// getEventTime extracts the event time from an AuditEvent.\n+func getEventTime(evt apievents.AuditEvent) int64 {\n+\tswitch evt := evt.(type) {\n+\tcase *apievents.SessionPrint:\n+\t\treturn evt.DelayMilliseconds\n+\tcase *apievents.SessionEnd:\n+\t\treturn int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\tdefault:\n+\t\treturn 0\n+\t}\n+}\n+\n+// validateRequest validates the fetch request parameters.\n+func validateRequest(req *fetchRequest) error {\n+\tif req.startOffset < 0 || req.endOffset < 0 {\n+\t\treturn fmt.Errorf(\"invalid time range\")\n+\t}\n+\n+\tif req.endOffset < req.startOffset {\n+\t\treturn fmt.Errorf(\"end time before start time\")\n+\t}\n+\n+\trangeMillis := req.endOffset - req.startOffset\n+\tmaxRangeMillis := int64(maxRequestRange / time.Millisecond)\n+\n+\tif rangeMillis > maxRangeMillis {\n+\t\treturn fmt.Errorf(\"time range too large\")",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2288780358",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2288780358",
        "commented_code": "@@ -0,0 +1,637 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx        context.Context\n+\tcancel     context.CancelFunc\n+\tclt        events.SessionStreamer\n+\tsessionID  string\n+\tlogger     *slog.Logger\n+\tmu         sync.Mutex\n+\tactiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          byte\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType byte\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.websocket.ReadMessage()\n+\t\tif err != nil {\n+\t\t\tif !utils.IsOKNetworkError(err) {\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"websocket read error\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tcase requestTypeClose:\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tif s.activeTask != nil {\n+\t\ts.activeTask()\n+\t}\n+\n+\tctx, taskCancel := context.WithCancel(s.ctx)\n+\ts.activeTask = taskCancel\n+\n+\treturn ctx\n+}\n+\n+// handleFetchRequest processes a fetch request for session events.\n+func (s *recordingPlayback) handleFetchRequest(req *fetchRequest) {\n+\tif err := validateRequest(req); err != nil {\n+\t\ts.sendError(err, req.requestID)\n+\n+\t\treturn\n+\t}\n+\n+\tctx := s.createTaskContext()\n+\n+\ts.stream.Lock()\n+\tneedNewStream := false\n+\n+\tif s.stream.eventsChan == nil {\n+\t\tneedNewStream = true\n+\t} else if req.startOffset < s.stream.lastEndTime {\n+\t\tneedNewStream = true\n+\t}\n+\n+\tif needNewStream {\n+\t\tevents, errors := s.clt.StreamSessionEvents(\n+\t\t\tmetadata.WithSessionRecordingFormatContext(ctx, teleport.PTY),\n+\t\t\tsession.ID(s.sessionID),\n+\t\t\t0,\n+\t\t)\n+\n+\t\tif events == nil || errors == nil {\n+\t\t\ts.sendError(fmt.Errorf(\"failed to start session event stream\"), req.requestID)\n+\t\t\ts.stream.Unlock()\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.stream.eventsChan = events\n+\t\ts.stream.errorsChan = errors\n+\t\ts.stream.lastEndTime = 0\n+\n+\t\ts.terminal.Lock()\n+\t\ts.terminal.vt = vt10x.New()\n+\t\ts.terminal.Unlock()\n+\t}\n+\n+\ts.stream.lastEndTime = req.endOffset\n+\n+\teventsChan := s.stream.eventsChan\n+\terrorsChan := s.stream.errorsChan\n+\n+\ts.stream.Unlock()\n+\n+\tgo s.streamEvents(ctx, req, eventsChan, errorsChan)\n+}\n+\n+// streamEvents streams session events to the client.\n+func (s *recordingPlayback) streamEvents(ctx context.Context, req *fetchRequest, eventsChan <-chan apievents.AuditEvent, errorsChan <-chan error) {\n+\tdefer func() {\n+\t\ts.mu.Lock()\n+\t\ts.activeTask = nil\n+\t\ts.mu.Unlock()\n+\t}()\n+\n+\ts.sendEvent(eventTypeStart, req.startOffset, nil, req.requestID)\n+\n+\tscreenSent := false\n+\tinTimeRange := false\n+\tvar streamStartTime time.Time\n+\n+\tconst maxBatchSize = 200\n+\teventBatch := make([]sessionEvent, 0, maxBatchSize)\n+\n+\tflushBatch := func() {\n+\t\tif len(eventBatch) == 0 {\n+\t\t\treturn\n+\t\t}\n+\n+\t\ts.sendEventBatch(eventBatch, req.requestID)\n+\t\teventBatch = eventBatch[:0]\n+\t}\n+\n+\taddToBatch := func(eventType byte, timestamp int64, data []byte) {\n+\t\teventBatch = append(eventBatch, sessionEvent{eventType, timestamp, data})\n+\n+\t\tif len(eventBatch) >= maxBatchSize {\n+\t\t\tflushBatch()\n+\t\t}\n+\t}\n+\n+\tsendStop := func() {\n+\t\ts.sendEvent(eventTypeStop, 0, encodeTime(req.startOffset, req.endOffset), req.requestID)\n+\t}\n+\n+\tprocessEvent := func(evt apievents.AuditEvent) bool {\n+\t\tif _, ok := evt.(*apievents.SessionStart); ok && streamStartTime.IsZero() {\n+\t\t\tstreamStartTime = evt.GetTime()\n+\t\t}\n+\n+\t\teventTime := getEventTime(evt)\n+\n+\t\tif !inTimeRange && eventTime >= req.startOffset {\n+\t\t\tinTimeRange = true\n+\n+\t\t\tif req.requestCurrentScreen && !screenSent {\n+\t\t\t\tflushBatch()\n+\t\t\t\ts.sendCurrentScreen(req.requestID, eventTime)\n+\n+\t\t\t\tscreenSent = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch evt := evt.(type) {\n+\t\tcase *apievents.SessionStart:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeSessionStart, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionPrint:\n+\t\t\tif evt.DelayMilliseconds > req.endOffset {\n+\t\t\t\ts.stream.Lock()\n+\t\t\t\ts.stream.bufferedEvents = append(s.stream.bufferedEvents, evt)\n+\t\t\t\ts.stream.Unlock()\n+\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\ts.terminal.Lock()\n+\t\t\t_, _ = s.terminal.vt.Write(evt.Data)\n+\t\t\ts.terminal.Unlock()\n+\n+\t\t\tif evt.DelayMilliseconds >= req.startOffset {\n+\t\t\t\taddToBatch(eventTypeSessionPrint, evt.DelayMilliseconds, evt.Data)\n+\t\t\t}\n+\n+\t\tcase *apievents.SessionEnd:\n+\t\t\tendTime := int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\n+\t\t\tif endTime >= req.startOffset && endTime <= req.endOffset {\n+\t\t\t\taddToBatch(eventTypeSessionEnd, endTime, []byte(evt.EndTime.Format(time.RFC3339)))\n+\t\t\t}\n+\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn false\n+\n+\t\tcase *apievents.Resize:\n+\t\t\ts.resizeTerminal(evt.TerminalSize)\n+\n+\t\t\tif inTimeRange {\n+\t\t\t\taddToBatch(eventTypeResize, 0, []byte(evt.TerminalSize))\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true\n+\t}\n+\n+\ts.stream.Lock()\n+\n+\tbuffered := make([]apievents.AuditEvent, len(s.stream.bufferedEvents))\n+\tcopy(buffered, s.stream.bufferedEvents)\n+\ts.stream.bufferedEvents = nil\n+\n+\ts.stream.Unlock()\n+\n+\tfor _, evt := range buffered {\n+\t\tif !processEvent(evt) {\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\tflushBatch()\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase err := <-errorsChan:\n+\t\t\tflushBatch()\n+\t\t\tif err != nil {\n+\t\t\t\ts.sendError(err, req.requestID)\n+\t\t\t}\n+\t\t\tsendStop()\n+\n+\t\t\treturn\n+\n+\t\tcase evt, ok := <-eventsChan:\n+\t\t\tif !ok {\n+\t\t\t\tflushBatch()\n+\t\t\t\tif req.requestCurrentScreen && !screenSent && inTimeRange {\n+\t\t\t\t\ts.sendCurrentScreen(req.requestID, req.startOffset)\n+\t\t\t\t}\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif !processEvent(evt) {\n+\t\t\t\tflushBatch()\n+\t\t\t\tsendStop()\n+\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// resizeTerminal resizes the terminal based on the provided size string.\n+func (s *recordingPlayback) resizeTerminal(size string) {\n+\tparts := strings.Split(size, \":\")\n+\tif len(parts) != 2 {\n+\t\treturn\n+\t}\n+\n+\tcols, cErr := strconv.Atoi(parts[0])\n+\trows, rErr := strconv.Atoi(parts[1])\n+\n+\tif cmp.Or(cErr, rErr) != nil {\n+\t\treturn\n+\t}\n+\n+\ts.terminal.Lock()\n+\tdefer s.terminal.Unlock()\n+\n+\ts.terminal.vt.Resize(cols, rows)\n+}\n+\n+// writeMessage writes a message to the websocket connection with a timeout.\n+func (s *recordingPlayback) writeMessage(msgType int, data []byte) error {\n+\ts.websocket.Lock()\n+\tdefer s.websocket.Unlock()\n+\n+\tif err := s.websocket.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn s.websocket.WriteMessage(msgType, data)\n+}\n+\n+// sendEvent sends a single event to the client.\n+func (s *recordingPlayback) sendEvent(eventType byte, timestamp int64, data []byte, requestID int) {\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventType, timestamp, data, requestID)\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event\", \"session_id\", s.sessionID, \"error\", err)\n+\t}\n+}\n+\n+// sendEventBatch sends a batch of events to the client.\n+func (s *recordingPlayback) sendEventBatch(batch []sessionEvent, requestID int) {\n+\ttotalSize := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\ttotalSize += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tbuf := make([]byte, totalSize)\n+\n+\tbuf[0] = eventTypeBatch\n+\tbinary.BigEndian.PutUint32(buf[1:5], uint32(len(batch)))\n+\tbinary.BigEndian.PutUint32(buf[5:9], uint32(requestID))\n+\n+\toffset := responseHeaderSize\n+\tfor _, evt := range batch {\n+\t\tencodeEvent(buf, offset, evt.eventType, evt.timestamp, evt.data, requestID)\n+\n+\t\toffset += responseHeaderSize + len(evt.data)\n+\t}\n+\n+\tif err := s.writeMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\ts.logger.ErrorContext(s.ctx, \"failed to send event batch\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"error\", err,\n+\t\t\t\"batch_size\", len(batch),\n+\t\t\t\"buffer_size\", totalSize)\n+\t}\n+}\n+\n+// sendError sends an error event to the client.\n+func (s *recordingPlayback) sendError(err error, requestID int) {\n+\ts.sendEvent(eventTypeError, 0, []byte(err.Error()), requestID)\n+}\n+\n+// sendCurrentScreen sends the current terminal screen state to the client.\n+func (s *recordingPlayback) sendCurrentScreen(requestID int, timestamp int64) {\n+\ts.terminal.RLock()\n+\tstate := s.terminal.vt.DumpState()\n+\tcols, rows := s.terminal.vt.Size()\n+\tcursor := s.terminal.vt.Cursor()\n+\ts.terminal.RUnlock()\n+\n+\tdata := encodeScreenEvent(state, cols, rows, cursor)\n+\n+\ts.sendEvent(eventTypeScreen, timestamp, data, requestID)\n+}\n+\n+// encodeScreenEvent encodes the current terminal screen state into a byte slice.\n+func encodeScreenEvent(state vt10x.TerminalState, cols, rows int, cursor vt10x.Cursor) []byte {\n+\tdata := terminal.VtStateToANSI(state)\n+\n+\teventData := make([]byte, requestHeaderSize+len(data))\n+\teventData[0] = eventTypeScreen\n+\n+\tbinary.BigEndian.PutUint32(eventData[1:5], uint32(cols))\n+\tbinary.BigEndian.PutUint32(eventData[5:9], uint32(rows))\n+\tbinary.BigEndian.PutUint32(eventData[9:13], uint32(cursor.X))\n+\tbinary.BigEndian.PutUint32(eventData[13:17], uint32(cursor.Y))\n+\tbinary.BigEndian.PutUint32(eventData[17:21], uint32(len(data)))\n+\n+\tcopy(eventData[requestHeaderSize:], data)\n+\n+\treturn eventData\n+}\n+\n+// encodeEvent encodes a session event into a byte slice.\n+func encodeEvent(buf []byte, offset int, eventType byte, timestamp int64, data []byte, requestID int) {\n+\tbuf[offset] = eventType\n+\n+\tbinary.BigEndian.PutUint64(buf[offset+1:offset+9], uint64(timestamp))\n+\tbinary.BigEndian.PutUint32(buf[offset+9:offset+13], uint32(len(data)))\n+\tbinary.BigEndian.PutUint32(buf[offset+13:offset+17], uint32(requestID))\n+\n+\tcopy(buf[offset+responseHeaderSize:], data)\n+}\n+\n+// encodeTime encodes the start and end times into a byte slice.\n+func encodeTime(startTime, endTime int64) []byte {\n+\tbuf := make([]byte, 16)\n+\n+\tbinary.BigEndian.PutUint64(buf, uint64(startTime))\n+\tbinary.BigEndian.PutUint64(buf[8:], uint64(endTime))\n+\n+\treturn buf\n+}\n+\n+// decodeBinaryRequest decodes a binary request from the client.\n+func decodeBinaryRequest(data []byte) (*fetchRequest, error) {\n+\tif len(data) != requestHeaderSize {\n+\t\treturn nil, trace.BadParameter(\"invalid request size: expected %d bytes, got %d bytes\", requestHeaderSize, len(data))\n+\t}\n+\n+\treq := &fetchRequest{\n+\t\trequestType:          data[0],\n+\t\tstartOffset:          int64(binary.BigEndian.Uint64(data[1:9])),\n+\t\tendOffset:            int64(binary.BigEndian.Uint64(data[9:17])),\n+\t\trequestID:            int(binary.BigEndian.Uint32(data[17:21])),\n+\t\trequestCurrentScreen: data[21] == 1,\n+\t}\n+\n+\treturn req, nil\n+}\n+\n+// getEventTime extracts the event time from an AuditEvent.\n+func getEventTime(evt apievents.AuditEvent) int64 {\n+\tswitch evt := evt.(type) {\n+\tcase *apievents.SessionPrint:\n+\t\treturn evt.DelayMilliseconds\n+\tcase *apievents.SessionEnd:\n+\t\treturn int64(evt.EndTime.Sub(evt.StartTime) / time.Millisecond)\n+\tdefault:\n+\t\treturn 0\n+\t}\n+}\n+\n+// validateRequest validates the fetch request parameters.\n+func validateRequest(req *fetchRequest) error {\n+\tif req.startOffset < 0 || req.endOffset < 0 {\n+\t\treturn fmt.Errorf(\"invalid time range\")\n+\t}\n+\n+\tif req.endOffset < req.startOffset {\n+\t\treturn fmt.Errorf(\"end time before start time\")\n+\t}\n+\n+\trangeMillis := req.endOffset - req.startOffset\n+\tmaxRangeMillis := int64(maxRequestRange / time.Millisecond)\n+\n+\tif rangeMillis > maxRangeMillis {\n+\t\treturn fmt.Errorf(\"time range too large\")",
        "comment_created_at": "2025-08-20T16:57:15+00:00",
        "comment_author": "zmb3",
        "comment_body": "```suggestion\n\t\treturn errors.New(\"time range too large\")\n```\n\nOr even consider a trace.LimitExceeded error.",
        "pr_file_module": null
      }
    ]
  }
]