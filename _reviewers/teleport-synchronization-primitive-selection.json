[
  {
    "discussion_id": "2293452742",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-22T11:18:45+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293452742",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2293452742",
        "commented_code": "@@ -0,0 +1,640 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex",
        "comment_created_at": "2025-08-22T11:18:45+00:00",
        "comment_author": "bl-nero",
        "comment_body": "Tim recently showed me that `sync.RWMutex` is a trap and it's usually not an improvement to performance: https://zephyrtronium.github.io/articles/rwmutex.html. So if it's performance you're after here, I'd rethink it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2300472447",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2293452742",
        "commented_code": "@@ -0,0 +1,640 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex",
        "comment_created_at": "2025-08-26T09:56:57+00:00",
        "comment_author": "ryanclark",
        "comment_body": "Wasn't really performance, I just default to `RWMutex` if I'm reading and writing",
        "pr_file_module": null
      },
      {
        "comment_id": "2300539214",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2293452742",
        "commented_code": "@@ -0,0 +1,640 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"cmp\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch byte = 1\n+\t// requestTypeClose closes the connection\n+\trequestTypeClose byte = 2\n+)\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates stream start\n+\teventTypeStart byte = 1\n+\t// eventTypeStop indicates stream stop\n+\teventTypeStop byte = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError byte = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart byte = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint byte = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd byte = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize byte = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen byte = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch byte = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan     <-chan apievents.AuditEvent\n+\t\terrorsChan     <-chan error\n+\t\tlastEndTime    int64\n+\t\tbufferedEvents []apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.RWMutex",
        "comment_created_at": "2025-08-26T10:25:51+00:00",
        "comment_author": "ryanclark",
        "comment_body": "Changed it to a mutex",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2300611526",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-26T10:57:26+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   int64\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType responseType\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\ts.websocket.Lock()",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2300611526",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2300611526",
        "commented_code": "@@ -0,0 +1,653 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   int64\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\twebsocket struct {\n+\t\tsync.Mutex\n+\t\t*websocket.Conn\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType responseType\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t}\n+\n+\ts.websocket.Conn = ws\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\ts.websocket.Lock()\n+\t_ = s.writeMessage(websocket.CloseMessage, nil)\n+\t_ = s.websocket.Close()\n+\ts.websocket.Unlock()\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\ts.websocket.Lock()",
        "comment_created_at": "2025-08-26T10:57:26+00:00",
        "comment_author": "tigrato",
        "comment_body": "locking before read will make any write action impossible. \ntransform the write loops into a single write on a goroutine and share a channel with all possible writers. no need for a mutex afterwards ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301805793",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-26T18:32:14+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\ttaskWg           *sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {\n+\tdata := []byte(err.Error())\n+\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\n+\t// Send close frame to initiate graceful shutdown\n+\t_ = ws.SetWriteDeadline(deadline)\n+\t_ = ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\t_ = ws.SetReadDeadline(deadline)\n+\tmsgType, _, _ := ws.ReadMessage()\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif msgType != -1 {\n+\t\th.logger.DebugContext(ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", sessionID,\n+\t\t\t\"message_type\", msgType)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\tws.Close()\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan websocketMessage),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t// Wait for any active task to complete\n+\ts.mu.Lock()\n+\twg := s.taskWg\n+\talreadySent := s.closeSent\n+\ts.mu.Unlock()\n+\n+\tif wg != nil {\n+\t\twg.Wait()\n+\t}\n+\n+\t// Only send close message if we haven't already sent one\n+\tif !alreadySent {\n+\t\tselect {\n+\t\tcase s.writeChan <- websocketMessage{\n+\t\t\tmessageType: websocket.CloseMessage,\n+\t\t\tdata:        websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"),\n+\t\t}:\n+\t\tcase <-time.After(websocketCloseTimeout):\n+\t\t}\n+\t}\n+\n+\tclose(s.writeChan)\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\t_ = s.ws.SetReadDeadline(deadline)\n+\tmsgType, _, _ := s.ws.ReadMessage()\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif msgType != -1 {\n+\t\ts.logger.DebugContext(s.ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"message_type\", msgType)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\ts.ws.Close()\n+}\n+\n+// writeLoop handles all websocket writes from a dedicated goroutine.\n+func (s *recordingPlayback) writeLoop() {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-s.ctx.Done():\n+\t\t\treturn\n+\t\tcase msg, ok := <-s.writeChan:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\t\t\ts.logWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.WriteMessage(msg.messageType, msg.data); err != nil {\n+\t\t\t\ts.logWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// If we just sent a close message, exit the loop\n+\t\t\tif msg.messageType == websocket.CloseMessage {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// logWebsocketError handles errors that occur during websocket writes.\n+func (s *recordingPlayback) logWebsocketError(err error) {\n+\tif !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) &&\n+\t\t!utils.IsOKNetworkError(err) {\n+\t\ts.logger.ErrorContext(s.ctx, \"websocket write error\", \"error\", err)\n+\t}\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.ws.ReadMessage()\n+\t\tif err != nil {\n+\t\t\ts.logWebsocketError(err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"ignoring non-binary websocket message\", \"session_id\", s.sessionID, \"type\", msgType)\n+\n+\t\t\t// Mark that we're sending a close message\n+\t\t\ts.mu.Lock()\n+\t\t\ts.closeSent = true\n+\t\t\ts.mu.Unlock()\n+\n+\t\t\t// Send close message through the write channel\n+\t\t\tselect {\n+\t\t\tcase s.writeChan <- websocketMessage{\n+\t\t\t\tmessageType: websocket.CloseMessage,\n+\t\t\t\tdata:        websocket.FormatCloseMessage(websocket.CloseUnsupportedData, \"only binary messages are supported\"),\n+\t\t\t}:\n+\t\t\tcase <-time.After(1 * time.Second):\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"timeout sending close message\", \"session_id\", s.sessionID)\n+\t\t\t}\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.WarnContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tdefault:\n+\t\t\ts.sendError(trace.BadParameter(\"unknown request type: %d\", req.requestType), req.requestID)\n+\n+\t\t\ts.logger.ErrorContext(s.ctx, \"received unknown request type\", \"session_id\", s.sessionID, \"type\", req.requestType)\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+// A task context is used to manage the lifecycle of a fetch request, ensuring that only one fetch request is active at a time.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\n+\tif s.cancelActiveTask != nil {\n+\t\t// Cancel the active task first\n+\t\ts.cancelActiveTask()\n+\t\toldWg := s.taskWg\n+\t\ts.mu.Unlock()\n+\n+\t\t// Wait for streamEvents to terminate before continuing\n+\t\t// We unlock the mutex while waiting to avoid deadlock\n+\t\tif oldWg != nil {\n+\t\t\toldWg.Wait()\n+\t\t}\n+\n+\t\ts.mu.Lock()\n+\t}\n+\n+\t// Create a new WaitGroup for the new task\n+\ts.taskWg = &sync.WaitGroup{}",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2301805793",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2301805793",
        "commented_code": "@@ -0,0 +1,779 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\ttaskWg           *sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {\n+\tdata := []byte(err.Error())\n+\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\n+\t// Send close frame to initiate graceful shutdown\n+\t_ = ws.SetWriteDeadline(deadline)\n+\t_ = ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\t_ = ws.SetReadDeadline(deadline)\n+\tmsgType, _, _ := ws.ReadMessage()\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif msgType != -1 {\n+\t\th.logger.DebugContext(ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", sessionID,\n+\t\t\t\"message_type\", msgType)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\tws.Close()\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan websocketMessage),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t// Wait for any active task to complete\n+\ts.mu.Lock()\n+\twg := s.taskWg\n+\talreadySent := s.closeSent\n+\ts.mu.Unlock()\n+\n+\tif wg != nil {\n+\t\twg.Wait()\n+\t}\n+\n+\t// Only send close message if we haven't already sent one\n+\tif !alreadySent {\n+\t\tselect {\n+\t\tcase s.writeChan <- websocketMessage{\n+\t\t\tmessageType: websocket.CloseMessage,\n+\t\t\tdata:        websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"),\n+\t\t}:\n+\t\tcase <-time.After(websocketCloseTimeout):\n+\t\t}\n+\t}\n+\n+\tclose(s.writeChan)\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\t_ = s.ws.SetReadDeadline(deadline)\n+\tmsgType, _, _ := s.ws.ReadMessage()\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif msgType != -1 {\n+\t\ts.logger.DebugContext(s.ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"message_type\", msgType)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\ts.ws.Close()\n+}\n+\n+// writeLoop handles all websocket writes from a dedicated goroutine.\n+func (s *recordingPlayback) writeLoop() {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-s.ctx.Done():\n+\t\t\treturn\n+\t\tcase msg, ok := <-s.writeChan:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\t\t\ts.logWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.WriteMessage(msg.messageType, msg.data); err != nil {\n+\t\t\t\ts.logWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// If we just sent a close message, exit the loop\n+\t\t\tif msg.messageType == websocket.CloseMessage {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// logWebsocketError handles errors that occur during websocket writes.\n+func (s *recordingPlayback) logWebsocketError(err error) {\n+\tif !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) &&\n+\t\t!utils.IsOKNetworkError(err) {\n+\t\ts.logger.ErrorContext(s.ctx, \"websocket write error\", \"error\", err)\n+\t}\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.ws.ReadMessage()\n+\t\tif err != nil {\n+\t\t\ts.logWebsocketError(err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"ignoring non-binary websocket message\", \"session_id\", s.sessionID, \"type\", msgType)\n+\n+\t\t\t// Mark that we're sending a close message\n+\t\t\ts.mu.Lock()\n+\t\t\ts.closeSent = true\n+\t\t\ts.mu.Unlock()\n+\n+\t\t\t// Send close message through the write channel\n+\t\t\tselect {\n+\t\t\tcase s.writeChan <- websocketMessage{\n+\t\t\t\tmessageType: websocket.CloseMessage,\n+\t\t\t\tdata:        websocket.FormatCloseMessage(websocket.CloseUnsupportedData, \"only binary messages are supported\"),\n+\t\t\t}:\n+\t\t\tcase <-time.After(1 * time.Second):\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"timeout sending close message\", \"session_id\", s.sessionID)\n+\t\t\t}\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.WarnContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tdefault:\n+\t\t\ts.sendError(trace.BadParameter(\"unknown request type: %d\", req.requestType), req.requestID)\n+\n+\t\t\ts.logger.ErrorContext(s.ctx, \"received unknown request type\", \"session_id\", s.sessionID, \"type\", req.requestType)\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+// A task context is used to manage the lifecycle of a fetch request, ensuring that only one fetch request is active at a time.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\n+\tif s.cancelActiveTask != nil {\n+\t\t// Cancel the active task first\n+\t\ts.cancelActiveTask()\n+\t\toldWg := s.taskWg\n+\t\ts.mu.Unlock()\n+\n+\t\t// Wait for streamEvents to terminate before continuing\n+\t\t// We unlock the mutex while waiting to avoid deadlock\n+\t\tif oldWg != nil {\n+\t\t\toldWg.Wait()\n+\t\t}\n+\n+\t\ts.mu.Lock()\n+\t}\n+\n+\t// Create a new WaitGroup for the new task\n+\ts.taskWg = &sync.WaitGroup{}",
        "comment_created_at": "2025-08-26T18:32:14+00:00",
        "comment_author": "tigrato",
        "comment_body": "you can reuse the same waitgroup given that the task is managed by the same goroutine.\n\nno need to create one per task. Just init it when you init recordingPlayback and use add, wait and done",
        "pr_file_module": null
      },
      {
        "comment_id": "2301812682",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2301805793",
        "commented_code": "@@ -0,0 +1,779 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\ttaskWg           *sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {\n+\tdata := []byte(err.Error())\n+\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\n+\t// Send close frame to initiate graceful shutdown\n+\t_ = ws.SetWriteDeadline(deadline)\n+\t_ = ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"))\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\t_ = ws.SetReadDeadline(deadline)\n+\tmsgType, _, _ := ws.ReadMessage()\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif msgType != -1 {\n+\t\th.logger.DebugContext(ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", sessionID,\n+\t\t\t\"message_type\", msgType)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\tws.Close()\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan websocketMessage),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t// Wait for any active task to complete\n+\ts.mu.Lock()\n+\twg := s.taskWg\n+\talreadySent := s.closeSent\n+\ts.mu.Unlock()\n+\n+\tif wg != nil {\n+\t\twg.Wait()\n+\t}\n+\n+\t// Only send close message if we haven't already sent one\n+\tif !alreadySent {\n+\t\tselect {\n+\t\tcase s.writeChan <- websocketMessage{\n+\t\t\tmessageType: websocket.CloseMessage,\n+\t\t\tdata:        websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\"),\n+\t\t}:\n+\t\tcase <-time.After(websocketCloseTimeout):\n+\t\t}\n+\t}\n+\n+\tclose(s.writeChan)\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\t_ = s.ws.SetReadDeadline(deadline)\n+\tmsgType, _, _ := s.ws.ReadMessage()\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif msgType != -1 {\n+\t\ts.logger.DebugContext(s.ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", s.sessionID,\n+\t\t\t\"message_type\", msgType)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\ts.ws.Close()\n+}\n+\n+// writeLoop handles all websocket writes from a dedicated goroutine.\n+func (s *recordingPlayback) writeLoop() {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-s.ctx.Done():\n+\t\t\treturn\n+\t\tcase msg, ok := <-s.writeChan:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\t\t\ts.logWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.WriteMessage(msg.messageType, msg.data); err != nil {\n+\t\t\t\ts.logWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\t// If we just sent a close message, exit the loop\n+\t\t\tif msg.messageType == websocket.CloseMessage {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// logWebsocketError handles errors that occur during websocket writes.\n+func (s *recordingPlayback) logWebsocketError(err error) {\n+\tif !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) &&\n+\t\t!utils.IsOKNetworkError(err) {\n+\t\ts.logger.ErrorContext(s.ctx, \"websocket write error\", \"error\", err)\n+\t}\n+}\n+\n+// readLoop reads messages from the websocket connection and processes them.\n+func (s *recordingPlayback) readLoop() {\n+\tfor {\n+\t\tmsgType, data, err := s.ws.ReadMessage()\n+\t\tif err != nil {\n+\t\t\ts.logWebsocketError(err)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif msgType != websocket.BinaryMessage {\n+\t\t\ts.logger.ErrorContext(s.ctx, \"ignoring non-binary websocket message\", \"session_id\", s.sessionID, \"type\", msgType)\n+\n+\t\t\t// Mark that we're sending a close message\n+\t\t\ts.mu.Lock()\n+\t\t\ts.closeSent = true\n+\t\t\ts.mu.Unlock()\n+\n+\t\t\t// Send close message through the write channel\n+\t\t\tselect {\n+\t\t\tcase s.writeChan <- websocketMessage{\n+\t\t\t\tmessageType: websocket.CloseMessage,\n+\t\t\t\tdata:        websocket.FormatCloseMessage(websocket.CloseUnsupportedData, \"only binary messages are supported\"),\n+\t\t\t}:\n+\t\t\tcase <-time.After(1 * time.Second):\n+\t\t\t\ts.logger.ErrorContext(s.ctx, \"timeout sending close message\", \"session_id\", s.sessionID)\n+\t\t\t}\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\treq, err := decodeBinaryRequest(data)\n+\t\tif err != nil {\n+\t\t\ts.logger.WarnContext(s.ctx, \"failed to decode request\", \"session_id\", s.sessionID, \"error\", err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch req.requestType {\n+\t\tcase requestTypeFetch:\n+\t\t\ts.handleFetchRequest(req)\n+\t\tdefault:\n+\t\t\ts.sendError(trace.BadParameter(\"unknown request type: %d\", req.requestType), req.requestID)\n+\n+\t\t\ts.logger.ErrorContext(s.ctx, \"received unknown request type\", \"session_id\", s.sessionID, \"type\", req.requestType)\n+\t\t}\n+\t}\n+}\n+\n+// createTaskContext creates a new context for a task and cancels any previous task.\n+// A task context is used to manage the lifecycle of a fetch request, ensuring that only one fetch request is active at a time.\n+func (s *recordingPlayback) createTaskContext() context.Context {\n+\ts.mu.Lock()\n+\n+\tif s.cancelActiveTask != nil {\n+\t\t// Cancel the active task first\n+\t\ts.cancelActiveTask()\n+\t\toldWg := s.taskWg\n+\t\ts.mu.Unlock()\n+\n+\t\t// Wait for streamEvents to terminate before continuing\n+\t\t// We unlock the mutex while waiting to avoid deadlock\n+\t\tif oldWg != nil {\n+\t\t\toldWg.Wait()\n+\t\t}\n+\n+\t\ts.mu.Lock()\n+\t}\n+\n+\t// Create a new WaitGroup for the new task\n+\ts.taskWg = &sync.WaitGroup{}",
        "comment_created_at": "2025-08-26T18:35:42+00:00",
        "comment_author": "ryanclark",
        "comment_body": "I was getting sync wait group reuse errors during race tests when I was using just one, what was I doing wrong?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2303918912",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-27T13:22:36+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {\n+\tdata := []byte(err.Error())\n+\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\n+\t// Send close frame to initiate graceful shutdown\n+\tif err := ws.SetWriteDeadline(deadline); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to set write deadline\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\tif err := ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to send close message\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\tif err := ws.SetReadDeadline(deadline); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to set read deadline\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif _, _, err := ws.ReadMessage(); err != nil && !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {\n+\t\th.logger.DebugContext(ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\tws.Close()\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan websocketMessage),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t// Wait for any active task to complete\n+\ts.mu.Lock()\n+\talreadySent := s.closeSent\n+\ts.mu.Unlock()\n+\n+\ts.wg.Wait()\n+\n+\t// Only send close message if we haven't already sent one\n+\tif !alreadySent {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2303918912",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2303918912",
        "commented_code": "@@ -0,0 +1,767 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {\n+\tdata := []byte(err.Error())\n+\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\n+\t// Send close frame to initiate graceful shutdown\n+\tif err := ws.SetWriteDeadline(deadline); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to set write deadline\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\tif err := ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to send close message\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\tif err := ws.SetReadDeadline(deadline); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to set read deadline\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif _, _, err := ws.ReadMessage(); err != nil && !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {\n+\t\th.logger.DebugContext(ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\tws.Close()\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan websocketMessage),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t// Wait for any active task to complete\n+\ts.mu.Lock()\n+\talreadySent := s.closeSent\n+\ts.mu.Unlock()\n+\n+\ts.wg.Wait()\n+\n+\t// Only send close message if we haven't already sent one\n+\tif !alreadySent {",
        "comment_created_at": "2025-08-27T13:22:36+00:00",
        "comment_author": "smallinsky",
        "comment_body": "Does this is safe to assume that  alreadySent have up to data here ? It can be false if the `closeSent` was updated after the: \r\n\r\n```\r\n\ts.mu.Lock()\r\n\talreadySent := s.closeSent\r\n\ts.mu.Unlock()\r\n```\r\ncall. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2304242239",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2303918912",
        "commented_code": "@@ -0,0 +1,767 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types sent back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+const websocketCloseTimeout = 5 * time.Second\n+\n+// websocketMessage represents a message to be written to the websocket\n+type websocketMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+}\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\twg               sync.WaitGroup\n+\tws               *websocket.Conn\n+\twriteChan        chan websocketMessage\n+\tcloseSent        bool // tracks if a close message has been sent\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   time.Duration\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          time.Duration\n+\tendOffset            time.Duration\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType  responseType\n+\ttimeOffset time.Duration\n+\tdata       []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\th.closeWebsocketWithError(r.Context(), ws, sessionID, trace.BadParameter(\"missing session ID in request URL\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\th.closeWebsocketWithError(ctx, ws, sessionID, trace.Wrap(err, \"failed to get user client\"))\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+func (h *Handler) closeWebsocketWithError(ctx context.Context, ws *websocket.Conn, sessionID string, err error) {\n+\tdata := []byte(err.Error())\n+\n+\ttotalSize := responseHeaderSize + len(data)\n+\tbuf := make([]byte, totalSize)\n+\n+\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\tdeadline := time.Now().Add(websocketCloseTimeout)\n+\n+\t// Send close frame to initiate graceful shutdown\n+\tif err := ws.SetWriteDeadline(deadline); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to set write deadline\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\tif err := ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to send close message\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Wait for peer's close frame response (or timeout)\n+\tif err := ws.SetReadDeadline(deadline); err != nil {\n+\t\th.logger.DebugContext(ctx, \"failed to set read deadline\", \"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Log if we got something other than a close acknowledgement\n+\tif _, _, err := ws.ReadMessage(); err != nil && !websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) {\n+\t\th.logger.DebugContext(ctx, \"received non-close message while waiting for close acknowledgement\",\n+\t\t\t\"session_id\", sessionID, \"error\", err)\n+\t}\n+\n+\t// Finally close the underlying connection\n+\tws.Close()\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan websocketMessage),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t// Wait for any active task to complete\n+\ts.mu.Lock()\n+\talreadySent := s.closeSent\n+\ts.mu.Unlock()\n+\n+\ts.wg.Wait()\n+\n+\t// Only send close message if we haven't already sent one\n+\tif !alreadySent {",
        "comment_created_at": "2025-08-27T15:00:08+00:00",
        "comment_author": "ryanclark",
        "comment_body": "Moved it to inside the lock",
        "pr_file_module": null
      }
    ]
  }
]