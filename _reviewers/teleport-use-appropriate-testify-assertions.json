[
  {
    "discussion_id": "2325409941",
    "pr_number": 58707,
    "pr_file": "integration/integration_test.go",
    "created_at": "2025-09-05T15:29:54+00:00",
    "commented_code": "}\n }\n \n+func testRecordingModesSessionTrackers(t *testing.T, suite *integrationTestSuite) {\n+\tctx := context.Background()\n+\n+\tcfg := suite.defaultServiceConfig()\n+\tcfg.Auth.Enabled = true\n+\tcfg.Proxy.DisableWebService = true\n+\tcfg.Proxy.DisableWebInterface = true\n+\tcfg.Proxy.Enabled = true\n+\tcfg.SSH.Enabled = true\n+\n+\tteleport := suite.NewTeleportWithConfig(t, nil, nil, cfg)\n+\tdefer teleport.StopAll()\n+\n+\t// startSession starts an interactive session, users must terminate the\n+\t// session by typing \"exit\" in the terminal.\n+\tstartSession := func(username string) (*Terminal, chan error) {\n+\t\tterm := NewTerminal(250)\n+\t\terrCh := make(chan error)\n+\n+\t\tgo func() {\n+\t\t\tcl, err := teleport.NewClient(helpers.ClientConfig{\n+\t\t\t\tLogin:   username,\n+\t\t\t\tCluster: helpers.Site,\n+\t\t\t\tHost:    Host,\n+\t\t\t})\n+\t\t\tif err != nil {\n+\t\t\t\terrCh <- trace.Wrap(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcl.Stdout = term\n+\t\t\tcl.Stdin = term\n+\n+\t\t\tctx, cancel := context.WithTimeout(ctx, 30*time.Second)\n+\t\t\tdefer cancel()\n+\t\t\terrCh <- cl.SSH(ctx, nil)\n+\t\t}()\n+\n+\t\treturn term, errCh\n+\t}\n+\n+\tauth := teleport.Process.GetAuthServer()\n+\tfor _, mode := range []string{types.RecordAtNode, types.RecordAtProxy} {\n+\t\tt.Run(mode, func(t *testing.T) {\n+\t\t\trc := types.DefaultSessionRecordingConfig()\n+\t\t\trc.SetMode(mode)\n+\n+\t\t\t_, err := auth.UpsertSessionRecordingConfig(ctx, rc)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\t// Start session.\n+\t\t\tterm, errCh := startSession(suite.Me.Username)\n+\n+\t\t\t// Validate that the session tracker exists and contains\n+\t\t\t// the correct target address.\n+\t\t\tvar sessionID string\n+\t\t\trequire.EventuallyWithT(t, func(t *assert.CollectT) {\n+\t\t\t\ttrackers, err := auth.GetActiveSessionTrackers(ctx)\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t\tif !assert.Len(t, trackers, 1) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tassert.Equal(t, helpers.HostID, trackers[0].GetAddress())",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2325409941",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58707,
        "pr_file": "integration/integration_test.go",
        "discussion_id": "2325409941",
        "commented_code": "@@ -1038,6 +1040,82 @@ func testSessionRecordingModes(t *testing.T, suite *integrationTestSuite) {\n \t}\n }\n \n+func testRecordingModesSessionTrackers(t *testing.T, suite *integrationTestSuite) {\n+\tctx := context.Background()\n+\n+\tcfg := suite.defaultServiceConfig()\n+\tcfg.Auth.Enabled = true\n+\tcfg.Proxy.DisableWebService = true\n+\tcfg.Proxy.DisableWebInterface = true\n+\tcfg.Proxy.Enabled = true\n+\tcfg.SSH.Enabled = true\n+\n+\tteleport := suite.NewTeleportWithConfig(t, nil, nil, cfg)\n+\tdefer teleport.StopAll()\n+\n+\t// startSession starts an interactive session, users must terminate the\n+\t// session by typing \"exit\" in the terminal.\n+\tstartSession := func(username string) (*Terminal, chan error) {\n+\t\tterm := NewTerminal(250)\n+\t\terrCh := make(chan error)\n+\n+\t\tgo func() {\n+\t\t\tcl, err := teleport.NewClient(helpers.ClientConfig{\n+\t\t\t\tLogin:   username,\n+\t\t\t\tCluster: helpers.Site,\n+\t\t\t\tHost:    Host,\n+\t\t\t})\n+\t\t\tif err != nil {\n+\t\t\t\terrCh <- trace.Wrap(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcl.Stdout = term\n+\t\t\tcl.Stdin = term\n+\n+\t\t\tctx, cancel := context.WithTimeout(ctx, 30*time.Second)\n+\t\t\tdefer cancel()\n+\t\t\terrCh <- cl.SSH(ctx, nil)\n+\t\t}()\n+\n+\t\treturn term, errCh\n+\t}\n+\n+\tauth := teleport.Process.GetAuthServer()\n+\tfor _, mode := range []string{types.RecordAtNode, types.RecordAtProxy} {\n+\t\tt.Run(mode, func(t *testing.T) {\n+\t\t\trc := types.DefaultSessionRecordingConfig()\n+\t\t\trc.SetMode(mode)\n+\n+\t\t\t_, err := auth.UpsertSessionRecordingConfig(ctx, rc)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\t// Start session.\n+\t\t\tterm, errCh := startSession(suite.Me.Username)\n+\n+\t\t\t// Validate that the session tracker exists and contains\n+\t\t\t// the correct target address.\n+\t\t\tvar sessionID string\n+\t\t\trequire.EventuallyWithT(t, func(t *assert.CollectT) {\n+\t\t\t\ttrackers, err := auth.GetActiveSessionTrackers(ctx)\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t\tif !assert.Len(t, trackers, 1) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tassert.Equal(t, helpers.HostID, trackers[0].GetAddress())",
        "comment_created_at": "2025-09-05T15:29:54+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "As of testify v1.10.0, require is now able to be used within a EventuallyWith assertion function. \n```suggestion\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.Len(t, trackers, 1)\n\t\t\t\trequire.Equal(t, helpers.HostID, trackers[0].GetAddress())\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288782029",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback_test.go",
    "created_at": "2025-08-20T16:58:02+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+)\n+\n+func TestValidateRequest(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\treq     *fetchRequest\n+\t\twantErr bool\n+\t\terrMsg  string\n+\t}{\n+\t\t{\n+\t\t\tname: \"valid request\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   1000,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"negative start offset\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: -1,\n+\t\t\t\tendOffset:   1000,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"invalid time range\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"negative end offset\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   -1,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"invalid time range\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"end before start\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 1000,\n+\t\t\t\tendOffset:   500,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"end time before start time\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"range too large\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   11 * 60 * 1000, // 11 minutes\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"time range too large\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"max valid range\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   10 * 60 * 1000, // 10 minutes\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := validateRequest(tt.req)\n+\t\t\tif tt.wantErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\trequire.Contains(t, err.Error(), tt.errMsg)",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2288782029",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback_test.go",
        "discussion_id": "2288782029",
        "commented_code": "@@ -0,0 +1,723 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2024  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+)\n+\n+func TestValidateRequest(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\treq     *fetchRequest\n+\t\twantErr bool\n+\t\terrMsg  string\n+\t}{\n+\t\t{\n+\t\t\tname: \"valid request\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   1000,\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"negative start offset\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: -1,\n+\t\t\t\tendOffset:   1000,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"invalid time range\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"negative end offset\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   -1,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"invalid time range\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"end before start\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 1000,\n+\t\t\t\tendOffset:   500,\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"end time before start time\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"range too large\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   11 * 60 * 1000, // 11 minutes\n+\t\t\t},\n+\t\t\twantErr: true,\n+\t\t\terrMsg:  \"time range too large\",\n+\t\t},\n+\t\t{\n+\t\t\tname: \"max valid range\",\n+\t\t\treq: &fetchRequest{\n+\t\t\t\tstartOffset: 0,\n+\t\t\t\tendOffset:   10 * 60 * 1000, // 10 minutes\n+\t\t\t},\n+\t\t\twantErr: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\terr := validateRequest(tt.req)\n+\t\t\tif tt.wantErr {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t\trequire.Contains(t, err.Error(), tt.errMsg)",
        "comment_created_at": "2025-08-20T16:58:02+00:00",
        "comment_author": "zmb3",
        "comment_body": "nit: use `require.ErrorContains` here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2322932471",
    "pr_number": 58739,
    "pr_file": "integration/hostuser_test.go",
    "created_at": "2025-09-04T17:36:14+00:00",
    "commented_code": "require.EventuallyWithT(t, func(collect *assert.CollectT) {\n \t\t// Check that the user was created.\n \t\texistingUser, err := user.Lookup(goodLogin)\n-\t\tassert.NoError(collect, err)\n+\t\trequire.NoError(collect, err)",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2322932471",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58739,
        "pr_file": "integration/hostuser_test.go",
        "discussion_id": "2322932471",
        "commented_code": "@@ -875,23 +875,23 @@ func testStaticHostUsers(t *testing.T, nodeUUID, goodLogin, goodLoginWithShell,\n \trequire.EventuallyWithT(t, func(collect *assert.CollectT) {\n \t\t// Check that the user was created.\n \t\texistingUser, err := user.Lookup(goodLogin)\n-\t\tassert.NoError(collect, err)\n+\t\trequire.NoError(collect, err)",
        "comment_created_at": "2025-09-04T17:36:14+00:00",
        "comment_author": "cthach",
        "comment_body": "Just for my info, if `err` is non-nil, will it trigger `require.EventuallyWithT` to loop to continue polling until the func passes?",
        "pr_file_module": null
      },
      {
        "comment_id": "2323002094",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58739,
        "pr_file": "integration/hostuser_test.go",
        "discussion_id": "2322932471",
        "commented_code": "@@ -875,23 +875,23 @@ func testStaticHostUsers(t *testing.T, nodeUUID, goodLogin, goodLoginWithShell,\n \trequire.EventuallyWithT(t, func(collect *assert.CollectT) {\n \t\t// Check that the user was created.\n \t\texistingUser, err := user.Lookup(goodLogin)\n-\t\tassert.NoError(collect, err)\n+\t\trequire.NoError(collect, err)",
        "comment_created_at": "2025-09-04T18:00:59+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "Yeah, require will cause the function to return early if err is non-nil. At which point it will try again on the next tick.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1980435204",
    "pr_number": 49072,
    "pr_file": "tool/tsh/common/access_request_test.go",
    "created_at": "2025-03-04T23:43:58+00:00",
    "commented_code": "return table.AsBuffer().String()\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname: \"list kube clusters in leaf cluster and expect json output\",\n+\t\t\targs: args{\n+\t\t\t\tteleportCluster: leafClusterName,\n+\t\t\t\tkind:            types.KindKubernetesCluster,\n+\t\t\t\tformat:          \"json\",\n+\t\t\t},\n+\t\t\twantOutput: func() string {\n+\t\t\t\tsearchOutput := accessRequestSearchOutput{\n+\t\t\t\t\tResources: []map[string]string{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\"hostname\":    \"\",\n+\t\t\t\t\t\t\t\"labels\":      \"\",\n+\t\t\t\t\t\t\t\"name\":        leafKubeCluster,\n+\t\t\t\t\t\t\t\"resource_id\": fmt.Sprintf(\"/%s/kube_cluster/%s\", leafClusterName, leafKubeCluster),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tRequestCommand: fmt.Sprintf(\"tsh request create --resource /%s/kube_cluster/%s --reason <request reason>\", leafClusterName, leafKubeCluster),\n+\t\t\t\t}\n+\t\t\t\tbytes, _ := utils.FastMarshalIndent(searchOutput, \"\", \"  \")\n+\t\t\t\treturn string(bytes)\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"list kube clusters in leaf cluster and expect yaml output\",\n+\t\t\targs: args{\n+\t\t\t\tteleportCluster: leafClusterName,\n+\t\t\t\tkind:            types.KindKubernetesCluster,\n+\t\t\t\tformat:          \"yaml\",\n+\t\t\t},\n+\t\t\twantOutput: func() string {\n+\t\t\t\tsearchOutput := accessRequestSearchOutput{\n+\t\t\t\t\tResources: []map[string]string{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\"hostname\":    \"\",\n+\t\t\t\t\t\t\t\"labels\":      \"\",\n+\t\t\t\t\t\t\t\"name\":        leafKubeCluster,\n+\t\t\t\t\t\t\t\"resource_id\": fmt.Sprintf(\"/%s/kube_cluster/%s\", leafClusterName, leafKubeCluster),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tRequestCommand: fmt.Sprintf(\"tsh request create --resource /%s/kube_cluster/%s --reason <request reason>\", leafClusterName, leafKubeCluster),\n+\t\t\t\t}\n+\t\t\t\tbytes, _ := yaml.Marshal(searchOutput)\n+\t\t\t\treturn string(bytes)",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1980435204",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 49072,
        "pr_file": "tool/tsh/common/access_request_test.go",
        "discussion_id": "1980435204",
        "commented_code": "@@ -194,6 +196,52 @@ func TestAccessRequestSearch(t *testing.T) {\n \t\t\t\treturn table.AsBuffer().String()\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\tname: \"list kube clusters in leaf cluster and expect json output\",\n+\t\t\targs: args{\n+\t\t\t\tteleportCluster: leafClusterName,\n+\t\t\t\tkind:            types.KindKubernetesCluster,\n+\t\t\t\tformat:          \"json\",\n+\t\t\t},\n+\t\t\twantOutput: func() string {\n+\t\t\t\tsearchOutput := accessRequestSearchOutput{\n+\t\t\t\t\tResources: []map[string]string{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\"hostname\":    \"\",\n+\t\t\t\t\t\t\t\"labels\":      \"\",\n+\t\t\t\t\t\t\t\"name\":        leafKubeCluster,\n+\t\t\t\t\t\t\t\"resource_id\": fmt.Sprintf(\"/%s/kube_cluster/%s\", leafClusterName, leafKubeCluster),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tRequestCommand: fmt.Sprintf(\"tsh request create --resource /%s/kube_cluster/%s --reason <request reason>\", leafClusterName, leafKubeCluster),\n+\t\t\t\t}\n+\t\t\t\tbytes, _ := utils.FastMarshalIndent(searchOutput, \"\", \"  \")\n+\t\t\t\treturn string(bytes)\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"list kube clusters in leaf cluster and expect yaml output\",\n+\t\t\targs: args{\n+\t\t\t\tteleportCluster: leafClusterName,\n+\t\t\t\tkind:            types.KindKubernetesCluster,\n+\t\t\t\tformat:          \"yaml\",\n+\t\t\t},\n+\t\t\twantOutput: func() string {\n+\t\t\t\tsearchOutput := accessRequestSearchOutput{\n+\t\t\t\t\tResources: []map[string]string{\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\"hostname\":    \"\",\n+\t\t\t\t\t\t\t\"labels\":      \"\",\n+\t\t\t\t\t\t\t\"name\":        leafKubeCluster,\n+\t\t\t\t\t\t\t\"resource_id\": fmt.Sprintf(\"/%s/kube_cluster/%s\", leafClusterName, leafKubeCluster),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tRequestCommand: fmt.Sprintf(\"tsh request create --resource /%s/kube_cluster/%s --reason <request reason>\", leafClusterName, leafKubeCluster),\n+\t\t\t\t}\n+\t\t\t\tbytes, _ := yaml.Marshal(searchOutput)\n+\t\t\t\treturn string(bytes)",
        "comment_created_at": "2025-03-04T23:43:58+00:00",
        "comment_author": "zmb3",
        "comment_body": "Use `require.YAMLEq` instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1980435965",
    "pr_number": 49072,
    "pr_file": "tool/tsh/common/access_request_test.go",
    "created_at": "2025-03-04T23:44:44+00:00",
    "commented_code": "t.Parallel()\n \t\t\thomePath, _ := mustLoginLegacy(t, s, tc.args.teleportCluster)\n \t\t\tcaptureStdout := new(bytes.Buffer)\n+\t\t\targs := append([]string{\n+\t\t\t\t\"--insecure\",\n+\t\t\t\t\"request\",\n+\t\t\t\t\"search\",\n+\t\t\t\tfmt.Sprintf(\"--kind=%s\", tc.args.kind),\n+\t\t\t},\n+\t\t\t\ttc.args.extraArgs...,\n+\t\t\t)\n+\t\t\tif tc.args.format != \"\" {\n+\t\t\t\targs = append(args, fmt.Sprintf(\"--format=%s\", tc.args.format))\n+\t\t\t}\n \t\t\terr := Run(\n \t\t\t\tcontext.Background(),\n-\t\t\t\tappend([]string{\n-\t\t\t\t\t\"--insecure\",\n-\t\t\t\t\t\"request\",\n-\t\t\t\t\t\"search\",\n-\t\t\t\t\tfmt.Sprintf(\"--kind=%s\", tc.args.kind),\n-\t\t\t\t},\n-\t\t\t\t\ttc.args.extraArgs...,\n-\t\t\t\t),\n+\t\t\t\targs,\n \t\t\t\tsetCopyStdout(captureStdout),\n \t\t\t\tsetHomePath(homePath),\n \t\t\t)\n \t\t\trequire.NoError(t, err)\n-\t\t\t// We append a newline to the expected output to esnure that the table\n-\t\t\t// does not contain any more rows than expected.\n-\t\t\trequire.Contains(t, captureStdout.String(), tc.wantTable()+\"\n\")\n+\t\t\tif tc.args.format == \"json\" || tc.args.format == \"yaml\" {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "1980435965",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 49072,
        "pr_file": "tool/tsh/common/access_request_test.go",
        "discussion_id": "1980435965",
        "commented_code": "@@ -202,23 +250,31 @@ func TestAccessRequestSearch(t *testing.T) {\n \t\t\tt.Parallel()\n \t\t\thomePath, _ := mustLoginLegacy(t, s, tc.args.teleportCluster)\n \t\t\tcaptureStdout := new(bytes.Buffer)\n+\t\t\targs := append([]string{\n+\t\t\t\t\"--insecure\",\n+\t\t\t\t\"request\",\n+\t\t\t\t\"search\",\n+\t\t\t\tfmt.Sprintf(\"--kind=%s\", tc.args.kind),\n+\t\t\t},\n+\t\t\t\ttc.args.extraArgs...,\n+\t\t\t)\n+\t\t\tif tc.args.format != \"\" {\n+\t\t\t\targs = append(args, fmt.Sprintf(\"--format=%s\", tc.args.format))\n+\t\t\t}\n \t\t\terr := Run(\n \t\t\t\tcontext.Background(),\n-\t\t\t\tappend([]string{\n-\t\t\t\t\t\"--insecure\",\n-\t\t\t\t\t\"request\",\n-\t\t\t\t\t\"search\",\n-\t\t\t\t\tfmt.Sprintf(\"--kind=%s\", tc.args.kind),\n-\t\t\t\t},\n-\t\t\t\t\ttc.args.extraArgs...,\n-\t\t\t\t),\n+\t\t\t\targs,\n \t\t\t\tsetCopyStdout(captureStdout),\n \t\t\t\tsetHomePath(homePath),\n \t\t\t)\n \t\t\trequire.NoError(t, err)\n-\t\t\t// We append a newline to the expected output to esnure that the table\n-\t\t\t// does not contain any more rows than expected.\n-\t\t\trequire.Contains(t, captureStdout.String(), tc.wantTable()+\"\\n\")\n+\t\t\tif tc.args.format == \"json\" || tc.args.format == \"yaml\" {",
        "comment_created_at": "2025-03-04T23:44:44+00:00",
        "comment_author": "zmb3",
        "comment_body": "Same thing here. Instead of asserting on the exact output, use `require.JSONEq` or `require.YAMLEq` to assert that the result is equivalent to the expected value.",
        "pr_file_module": null
      }
    ]
  }
]