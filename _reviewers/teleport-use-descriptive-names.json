[
  {
    "discussion_id": "2319541224",
    "pr_number": 58520,
    "pr_file": "lib/join/diagnostic/diagnostic.go",
    "created_at": "2025-09-03T16:47:01+00:00",
    "commented_code": "+// Teleport\n+// Copyright (C) 2025 Gravitational, Inc.\n+//\n+// This program is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU Affero General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+//\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU Affero General Public License for more details.\n+//\n+// You should have received a copy of the GNU Affero General Public License\n+// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+package diagnostic\n+\n+import (\n+\t\"log/slog\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+// Diagnostic collects diagnostic information about a join attempt so that it\n+// can be displayed in log messages and audit events. Because the join process\n+// is highly concurrent, it provides safe methods for editing and retrieving\n+// an [Info] struct.\n+type Diagnostic struct {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2319541224",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58520,
        "pr_file": "lib/join/diagnostic/diagnostic.go",
        "discussion_id": "2319541224",
        "commented_code": "@@ -0,0 +1,121 @@\n+// Teleport\n+// Copyright (C) 2025 Gravitational, Inc.\n+//\n+// This program is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU Affero General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+//\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU Affero General Public License for more details.\n+//\n+// You should have received a copy of the GNU Affero General Public License\n+// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+package diagnostic\n+\n+import (\n+\t\"log/slog\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+// Diagnostic collects diagnostic information about a join attempt so that it\n+// can be displayed in log messages and audit events. Because the join process\n+// is highly concurrent, it provides safe methods for editing and retrieving\n+// an [Info] struct.\n+type Diagnostic struct {",
        "comment_created_at": "2025-09-03T16:47:01+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "Minor naming nit: `diagnostic.Diagnostic` is repetitive ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301348681",
    "pr_number": 58046,
    "pr_file": "tool/tctl/common/plugin/awsic.go",
    "created_at": "2025-08-26T15:19:41+00:00",
    "commented_code": "awsregion \"github.com/gravitational/teleport/lib/utils/aws/region\"\n )\n \n-type awsICArgs struct {\n-\tcmd                  *kingpin.CmdClause\n-\tdefaultOwners        []string\n-\tscimToken            string\n-\tscimURL              *url.URL\n-\tforceSCIMURL         bool\n-\tregion               string\n-\tarn                  string\n-\tuseSystemCredentials bool\n-\tassumeRoleARN        string\n-\tuserOrigins          []string\n-\tuserLabels           []string\n-\tgroupNameFilters     []string\n-\taccountNameFilters   []string\n-\taccountIDFilters     []string\n+const (\n+\tdefaultAWSICPluginName = apicommon.OriginAWSIdentityCenter\n+\tawsicPluginNameFlag    = \"plugin-name\"\n+\tawsicPluginNameHelp    = \"Name of the AWSIC plugin instance to update. Defaults to \" + apicommon.OriginAWSIdentityCenter + \".\"",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2301348681",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58046,
        "pr_file": "tool/tctl/common/plugin/awsic.go",
        "discussion_id": "2301348681",
        "commented_code": "@@ -36,22 +37,30 @@ import (\n \tawsregion \"github.com/gravitational/teleport/lib/utils/aws/region\"\n )\n \n-type awsICArgs struct {\n-\tcmd                  *kingpin.CmdClause\n-\tdefaultOwners        []string\n-\tscimToken            string\n-\tscimURL              *url.URL\n-\tforceSCIMURL         bool\n-\tregion               string\n-\tarn                  string\n-\tuseSystemCredentials bool\n-\tassumeRoleARN        string\n-\tuserOrigins          []string\n-\tuserLabels           []string\n-\tgroupNameFilters     []string\n-\taccountNameFilters   []string\n-\taccountIDFilters     []string\n+const (\n+\tdefaultAWSICPluginName = apicommon.OriginAWSIdentityCenter\n+\tawsicPluginNameFlag    = \"plugin-name\"\n+\tawsicPluginNameHelp    = \"Name of the AWSIC plugin instance to update. Defaults to \" + apicommon.OriginAWSIdentityCenter + \".\"",
        "comment_created_at": "2025-08-26T15:19:41+00:00",
        "comment_author": "r0mant",
        "comment_body": "Nit: Let's not use our internal abbreviations for user-facing content.\r\n```suggestion\r\n\tawsicPluginNameHelp    = \"Name of the AWS Identity Center integration instance to update. Defaults to \" + apicommon.OriginAWSIdentityCenter + \".\"\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2301011980",
    "pr_number": 58116,
    "pr_file": "lib/web/recordingplayback.go",
    "created_at": "2025-08-26T13:31:48+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\tws               *websocket.Conn\n+\twriteChan        chan []byte\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   int64\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType responseType\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan []byte),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t_ = s.ws.Close()\n+}\n+\n+// writeLoop handles all websocket writes from a dedicated goroutine.\n+func (s *recordingPlayback) writeLoop() {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-s.ctx.Done():\n+\t\t\treturn\n+\t\tcase msg, ok := <-s.writeChan:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\t\t\ts.handleWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.WriteMessage(websocket.BinaryMessage, msg); err != nil {\n+\t\t\t\ts.handleWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// handleWebsocketError handles errors that occur during websocket writes.\n+func (s *recordingPlayback) handleWebsocketError(err error) {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2301011980",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58116,
        "pr_file": "lib/web/recordingplayback.go",
        "discussion_id": "2301011980",
        "commented_code": "@@ -0,0 +1,677 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025  Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package web\n+\n+import (\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"log/slog\"\n+\t\"net/http\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/gravitational/trace\"\n+\t\"github.com/hinshun/vt10x\"\n+\t\"github.com/julienschmidt/httprouter\"\n+\n+\t\"github.com/gravitational/teleport\"\n+\t\"github.com/gravitational/teleport/api/metadata\"\n+\tapievents \"github.com/gravitational/teleport/api/types/events\"\n+\t\"github.com/gravitational/teleport/lib/events\"\n+\t\"github.com/gravitational/teleport/lib/reversetunnelclient\"\n+\t\"github.com/gravitational/teleport/lib/session\"\n+\t\"github.com/gravitational/teleport/lib/terminal\"\n+\t\"github.com/gravitational/teleport/lib/utils\"\n+)\n+\n+type requestType byte\n+\n+// Identifies requests coming from the client (web UI)\n+const (\n+\t// requestTypeFetch requests event data\n+\trequestTypeFetch requestType = 1\n+)\n+\n+type responseType byte\n+\n+// Response types send back to the client\n+const (\n+\t// eventTypeStart indicates the start of a response of events\n+\teventTypeStart responseType = 1\n+\t// eventTypeStop indicates the stop of a response of events\n+\teventTypeStop responseType = 2\n+\t// eventTypeError indicates an error\n+\teventTypeError responseType = 3\n+\t// eventTypeSessionStart indicates session started\n+\teventTypeSessionStart responseType = 4\n+\t// eventTypeSessionPrint contains terminal output\n+\teventTypeSessionPrint responseType = 5\n+\t// eventTypeSessionEnd indicates session ended\n+\teventTypeSessionEnd responseType = 6\n+\t// eventTypeResize indicates terminal resize\n+\teventTypeResize responseType = 7\n+\t// eventTypeScreen contains terminal screen state\n+\teventTypeScreen responseType = 8\n+\t// eventTypeBatch indicates a batch of events\n+\teventTypeBatch responseType = 9\n+)\n+\n+const (\n+\t// maxRequestRange is the maximum allowed time range for a request\n+\tmaxRequestRange = 10 * time.Minute\n+\t// requestHeaderSize is the size of the request header (event type, start time, end time, request ID, and current screen flag)\n+\trequestHeaderSize = 22\n+\t// responseHeaderSize is the size of the response header (event type, timestamp, data size, and request ID)\n+\tresponseHeaderSize = 17\n+)\n+\n+// recordingPlayback manages session event streaming\n+type recordingPlayback struct {\n+\tctx              context.Context\n+\tcancel           context.CancelFunc\n+\tclt              events.SessionStreamer\n+\tsessionID        string\n+\tlogger           *slog.Logger\n+\tmu               sync.Mutex\n+\tcancelActiveTask context.CancelFunc\n+\tws               *websocket.Conn\n+\twriteChan        chan []byte\n+\n+\tstream struct {\n+\t\tsync.Mutex\n+\t\teventsChan    <-chan apievents.AuditEvent\n+\t\terrorsChan    <-chan error\n+\t\tlastEndTime   int64\n+\t\tbufferedEvent apievents.AuditEvent\n+\t}\n+\n+\tterminal struct {\n+\t\tsync.Mutex\n+\t\tvt          vt10x.Terminal\n+\t\tcurrentTime int64\n+\t}\n+}\n+\n+// fetchRequest represents a request for session events.\n+type fetchRequest struct {\n+\trequestType          requestType\n+\tstartOffset          int64\n+\tendOffset            int64\n+\trequestID            int\n+\trequestCurrentScreen bool\n+}\n+\n+// sessionEvent represents a single session event with its type, timestamp, and data.\n+type sessionEvent struct {\n+\teventType responseType\n+\ttimestamp int64\n+\tdata      []byte\n+}\n+\n+func (h *Handler) recordingPlaybackWs(\n+\tw http.ResponseWriter,\n+\tr *http.Request,\n+\tp httprouter.Params,\n+\tsctx *SessionContext,\n+\tcluster reversetunnelclient.Cluster,\n+\tws *websocket.Conn,\n+) (interface{}, error) {\n+\tsessionID := p.ByName(\"session_id\")\n+\tif sessionID == \"\" {\n+\t\treturn nil, trace.BadParameter(\"missing session ID in request URL\")\n+\t}\n+\n+\tdefer ws.Close()\n+\n+\tctx := r.Context()\n+\tclt, err := sctx.GetUserClient(ctx, cluster)\n+\tif err != nil {\n+\t\tdata := []byte(err.Error())\n+\n+\t\ttotalSize := responseHeaderSize + len(data)\n+\t\tbuf := make([]byte, totalSize)\n+\n+\t\tencodeEvent(buf, 0, eventTypeError, 0, data, 0)\n+\n+\t\tif err := ws.WriteMessage(websocket.BinaryMessage, buf); err != nil {\n+\t\t\th.logger.ErrorContext(ctx, \"failed to send event\", \"session_id\", sessionID, \"error\", err)\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tplayback := newRecordingPlayback(ctx, ws, clt, sessionID, h.logger)\n+\n+\tplayback.run()\n+\n+\treturn nil, nil\n+}\n+\n+// newRecordingPlayback creates a new session recording playback handler.\n+// This provides a way for the client to request session events within a specific time range, as well as the current\n+// terminal screen state at a given time (when seeking).\n+// This allows for faster seeking without having to send the client extra events to reconstruct the terminal state.\n+func newRecordingPlayback(ctx context.Context, ws *websocket.Conn, clt events.SessionStreamer, sessionID string, logger *slog.Logger) *recordingPlayback {\n+\tctx, cancel := context.WithCancel(ctx)\n+\n+\ts := &recordingPlayback{\n+\t\tctx:       ctx,\n+\t\tcancel:    cancel,\n+\t\tclt:       clt,\n+\t\tsessionID: sessionID,\n+\t\tlogger:    logger,\n+\t\tws:        ws,\n+\t\twriteChan: make(chan []byte),\n+\t}\n+\n+\treturn s\n+}\n+\n+// run starts the recording playback handler.\n+func (s *recordingPlayback) run() {\n+\tdefer s.cleanup()\n+\n+\tgo s.writeLoop()\n+\n+\ts.readLoop()\n+}\n+\n+// cleanup cleans up the recording playback resources.\n+func (s *recordingPlayback) cleanup() {\n+\ts.cancel()\n+\n+\t_ = s.ws.Close()\n+}\n+\n+// writeLoop handles all websocket writes from a dedicated goroutine.\n+func (s *recordingPlayback) writeLoop() {\n+\tfor {\n+\t\tselect {\n+\t\tcase <-s.ctx.Done():\n+\t\t\treturn\n+\t\tcase msg, ok := <-s.writeChan:\n+\t\t\tif !ok {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\t\t\ts.handleWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif err := s.ws.WriteMessage(websocket.BinaryMessage, msg); err != nil {\n+\t\t\t\ts.handleWebsocketError(err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// handleWebsocketError handles errors that occur during websocket writes.\n+func (s *recordingPlayback) handleWebsocketError(err error) {",
        "comment_created_at": "2025-08-26T13:31:48+00:00",
        "comment_author": "tigrato",
        "comment_body": "maybe rename it to logWebsocketError or similar. It's clearly not handling the error",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2305494742",
    "pr_number": 58209,
    "pr_file": "lib/srv/desktop/windows_server.go",
    "created_at": "2025-08-27T22:55:35+00:00",
    "commented_code": "return len(s), nil\n }\n+\n+// startUpdateRetryProcess starts a background process that periodically attempts\n+// to establish an LDAP connection for the certificate authority.\n+func (s *WindowsService) startUpdateRetryProcess(ctx context.Context, tlsConfig *tls.Config) error {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2305494742",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58209,
        "pr_file": "lib/srv/desktop/windows_server.go",
        "discussion_id": "2305494742",
        "commented_code": "@@ -1277,3 +1288,25 @@ func (m *monitorErrorSender) WriteString(s string) (n int, err error) {\n \n \treturn len(s), nil\n }\n+\n+// startUpdateRetryProcess starts a background process that periodically attempts\n+// to establish an LDAP connection for the certificate authority.\n+func (s *WindowsService) startUpdateRetryProcess(ctx context.Context, tlsConfig *tls.Config) error {",
        "comment_created_at": "2025-08-27T22:55:35+00:00",
        "comment_author": "zmb3",
        "comment_body": "I would use a slightly more descriptive name here to make it more clear what operation we're retrying.\n\n```suggestion\nfunc (s *WindowsService) retryPublishCRL(ctx context.Context, tlsConfig *tls.Config) error {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293066071",
    "pr_number": 58243,
    "pr_file": "constants.go",
    "created_at": "2025-08-22T08:23:57+00:00",
    "commented_code": "// PresetListAccessRequestResourcesRoleName is a name of a preset role that\n \t// includes permissions to read access request resources.\n \tPresetListAccessRequestResourcesRoleName = \"list-access-request-resources\"\n+\n+\t// PresetMCPAccessRoleName is a name of a preset role that allows\n+\t// accessing MCP servers.\n+\tPresetMCPAccessRoleName = \"mcp-access\"",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293066071",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "constants.go",
        "discussion_id": "2293066071",
        "commented_code": "@@ -759,6 +759,10 @@ const (\n \t// PresetListAccessRequestResourcesRoleName is a name of a preset role that\n \t// includes permissions to read access request resources.\n \tPresetListAccessRequestResourcesRoleName = \"list-access-request-resources\"\n+\n+\t// PresetMCPAccessRoleName is a name of a preset role that allows\n+\t// accessing MCP servers.\n+\tPresetMCPAccessRoleName = \"mcp-access\"",
        "comment_created_at": "2025-08-22T08:23:57+00:00",
        "comment_author": "Tener",
        "comment_body": "It isn't clear if this role is meant for admins or users. I much prefer the roles which give a name to the \"actor\", such as \"reviewer\" or \"okta-requester\". In that spirit I'd suggest the name \"mcp-user\". ",
        "pr_file_module": null
      },
      {
        "comment_id": "2294042249",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58243,
        "pr_file": "constants.go",
        "discussion_id": "2293066071",
        "commented_code": "@@ -759,6 +759,10 @@ const (\n \t// PresetListAccessRequestResourcesRoleName is a name of a preset role that\n \t// includes permissions to read access request resources.\n \tPresetListAccessRequestResourcesRoleName = \"list-access-request-resources\"\n+\n+\t// PresetMCPAccessRoleName is a name of a preset role that allows\n+\t// accessing MCP servers.\n+\tPresetMCPAccessRoleName = \"mcp-access\"",
        "comment_created_at": "2025-08-22T15:24:45+00:00",
        "comment_author": "greedy52",
        "comment_body": "i love `mcp-user` a lot more than `mcp-access`. i wanted to do something like that initially but we have a few `xxx-access` roles already. i will switch to `mcp-user` unless someone feels strong against it. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2305218157",
    "pr_number": 58356,
    "pr_file": "lib/web/scripts/oneoff/oneoff.go",
    "created_at": "2025-08-27T20:21:53+00:00",
    "commented_code": "// Possible values:\n \t// - teleport\n \t// - teleport-ent\n+\t// - teleport-update\n \tTeleportFlavor string\n \n+\t// TeleportPackage is the teleport package name.\n+\t// Possible values:\n+\t// - teleport\n+\t// - teleport-ent\n+\tTeleportPackage string\n+",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2305218157",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58356,
        "pr_file": "lib/web/scripts/oneoff/oneoff.go",
        "discussion_id": "2305218157",
        "commented_code": "@@ -90,8 +91,15 @@ type OneOffScriptParams struct {\n \t// Possible values:\n \t// - teleport\n \t// - teleport-ent\n+\t// - teleport-update\n \tTeleportFlavor string\n \n+\t// TeleportPackage is the teleport package name.\n+\t// Possible values:\n+\t// - teleport\n+\t// - teleport-ent\n+\tTeleportPackage string\n+",
        "comment_created_at": "2025-08-27T20:21:53+00:00",
        "comment_author": "hugoShaka",
        "comment_body": "Can you rename teleportFlavor and Teleport Package to TeleportArtifact and TeleportDirectory or something similar, as the distinction is confusing",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293168412",
    "pr_number": 58114,
    "pr_file": "lib/services/parser.go",
    "created_at": "2025-08-22T09:10:48+00:00",
    "commented_code": "},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2293168412",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2293168412",
        "commented_code": "@@ -192,7 +207,68 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpts is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpts func(RuleContext, *predicate.Def)\n+\n+// WithHasAccessFunction adds a has_access function to the parser definition.\n+// This function will be used to check if the user has access to the resource\n+// specified in the context. If value is false, the function will not be added.\n+func WithHasAccessFunction(value bool) WhereParserOpts {\n+\treturn func(ctx RuleContext, def *predicate.Def) {\n+\t\tif !value {\n+\t\t\treturn\n+\t\t}\n+\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n+\t}\n+}",
        "comment_created_at": "2025-08-22T09:10:48+00:00",
        "comment_author": "Tener",
        "comment_body": "This reads a bit weird. I'd rename `value` to `condition` or something like it; `value` is too generic to me.\n\nSuch conditional option might also be better expressed with a helper function. For example:\n\n```suggestion\n// WithHasAccessFunction adds a has_access function to the parser definition.\n// This function will be used to check if the user has access to the resource\n// specified in the context.\nfunc WithHasAccessFunction() WhereParserOpts {\n\treturn func(ctx RuleContext, def *predicate.Def) {\n\t\tdef.Functions[\"has_access\"] = hasAccessFunc(ctx)\n\t}\n}\n\n// ConditionalOption applies the specified option if the condition is true. \n// Otherwise, the returned option is a no-op.\nfunc ConditionalOption(condition bool, option WhereParserOpts) WhereParserOpts {\n\treturn func(ctx RuleContext, def *predicate.Def) {\n\t\tif condition {\n\t\t\toption(ctx, def)\n\t\t}\n\t}\n}\n```\n\nThe result is bit more verbose, but possibly cleaner. Instead of:\n\n```go\nWithHasAccessFunction(resource == types.KindSession)\n```\n\nwe would now have:\n\n```go\nConditionalOption(resource == types.KindSession, WithHasAccessFunction())\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2302426343",
    "pr_number": 58114,
    "pr_file": "lib/services/parser.go",
    "created_at": "2025-08-26T23:57:26+00:00",
    "commented_code": "},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpt is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpt func(RuleContext, *predicate.Def)\n+\n+// WithCanViewFunction adds a can_view function to the parser definition.\n+// This function will be used to check if the user has access to the resource",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2302426343",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2302426343",
        "commented_code": "@@ -192,7 +206,82 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpt is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpt func(RuleContext, *predicate.Def)\n+\n+// WithCanViewFunction adds a can_view function to the parser definition.\n+// This function will be used to check if the user has access to the resource",
        "comment_created_at": "2025-08-26T23:57:26+00:00",
        "comment_author": "zmb3",
        "comment_body": "I'm not sure I understand what `can_view` means. Is that separate from \"can access\" ??",
        "pr_file_module": null
      },
      {
        "comment_id": "2303399954",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58114,
        "pr_file": "lib/services/parser.go",
        "discussion_id": "2302426343",
        "commented_code": "@@ -192,7 +206,82 @@ func NewWhereParser(ctx RuleContext) (predicate.Parser, error) {\n \t\t},\n \t\tGetIdentifier: ctx.GetIdentifier,\n \t\tGetProperty:   GetStringMapValue,\n-\t})\n+\t}\n+\treturn def\n+}\n+\n+// WhereParserOpt is a function that modifies the default\n+// predicate.Def used to create a parser for the `where` section in access rules.\n+type WhereParserOpt func(RuleContext, *predicate.Def)\n+\n+// WithCanViewFunction adds a can_view function to the parser definition.\n+// This function will be used to check if the user has access to the resource",
        "comment_created_at": "2025-08-27T09:31:45+00:00",
        "comment_author": "tigrato",
        "comment_body": "I initially named it as `can_access` but @Tener seemed confused by the terminology given that it doesn't really grant access to the resource - it only matched the resource labels. If a user doesn't have principals, he still doesn't have access to the resource so `can_access` seemed a bit incorrect.\r\n\r\nIIRC, this is the terminology we use for label matching - can access the resource - but given that it caused some confusion, I renamed it to `can_view`. Properly implementing a `can_access` is quite difficult, specially for database access.\r\n\r\nTL;DR `can_view` checks if the user role's match the server labels",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2307379670",
    "pr_number": 58416,
    "pr_file": "tool/teleport/common/backend.go",
    "created_at": "2025-08-28T13:12:53+00:00",
    "commented_code": "}\n \treturn nil\n }\n+\n+func onBackendGet(ctx context.Context, config backend.Config, key, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\treturn trace.Wrap(printBackendItems(format, stream.Once(*item)))\n+}\n+\n+func onBackendList(ctx context.Context, config backend.Config, prefix, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tvar startKey, endKey backend.Key\n+\tif prefix != \"\" {\n+\t\tstartKey = backend.KeyFromString(prefix)\n+\t\tendKey = backend.RangeEnd(startKey.ExactKey())\n+\t} else {\n+\t\tstartKey = backend.NewKey(\"\")\n+\t\tendKey = backend.RangeEnd(startKey)\n+\t}\n+\n+\titems := bk.Items(ctx, backend.ItemsParams{StartKey: startKey, EndKey: endKey})\n+\n+\treturn trace.Wrap(printBackendItems(format, items))\n+}\n+\n+func printBackendItems(format string, items iter.Seq2[backend.Item, error]) error {\n+\t// backendItem exists to better represent a\n+\t// [backend.Item] to users. The Key is converted to\n+\t// it's textual representation, and the Value is\n+\t// converted to a string so that it is not base64 encoded\n+\t// during marshaling.\n+\ttype backendItem struct {\n+\t\tKey      string\n+\t\tValue    string\n+\t\tRevision string\n+\t\tExpires  time.Time\n+\t}\n+\n+\tbackendItems := stream.FilterMap(items, func(i backend.Item) (backendItem, bool) {\n+\t\treturn backendItem{\n+\t\t\tKey:      i.Key.String(),\n+\t\t\tExpires:  i.Expires,\n+\t\t\tRevision: i.Revision,\n+\t\t\tValue:    string(i.Value),\n+\t\t}, true\n+\t})\n+\n+\tswitch strings.ToLower(format) {\n+\tcase teleport.Text, \"\":\n+\t\ttable := asciitable.MakeTable([]string{\"Key\", \"Expires\", \"Revision\"})\n+\t\tfor row, err := range stream.FilterMap(backendItems, func(i backendItem) ([]string, bool) {\n+\t\t\texpiry := \"Never\"\n+\t\t\tif !i.Expires.IsZero() {\n+\t\t\t\texpiry = i.Expires.Format(time.RFC3339)\n+\t\t\t}\n+\t\t\treturn []string{i.Key, expiry, i.Revision}, true\n+\t\t}) {\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err, \"retrieving items\")\n+\t\t\t}\n+\n+\t\t\ttable.AddRow(row)\n+\t\t}\n+\n+\t\tif err := table.WriteTo(os.Stdout); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.JSON:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := utils.FastMarshalIndent(allItems, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.YAML:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := yaml.Marshal(allItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tdefault:\n+\t\treturn trace.BadParameter(\"unsupported format %q\", format)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func onBackendDelete(ctx context.Context, config backend.Config, key string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tif err := bk.Delete(ctx, backend.KeyFromString(key)); err != nil {\n+\t\treturn trace.Wrap(err, \"deleting item\")\n+\t}\n+\n+\tfmt.Printf(\"item %q has been deleted\n\", key)\n+\treturn nil\n+}\n+\n+func checksum(filename string) (string, error) {\n+\tf, err := utils.OpenFileAllowingUnsafeLinks(filename)\n+\tif err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\tdefer f.Close()\n+\n+\th := sha256.New()\n+\tif _, err := io.Copy(h, f); err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\n+\treturn hex.EncodeToString(h.Sum(nil)), nil\n+}\n+\n+func onBackendEdit(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from being written over the editor.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\teditor := \"vi\"\n+\tfor _, v := range []string{\"TELEPORT_EDITOR\", \"VISUAL\", \"EDITOR\"} {\n+\t\tif value := os.Getenv(v); value != \"\" {\n+\t\t\teditor = value\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tf, err := os.CreateTemp(\"\", \"teleport-item*.yaml\")\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := os.Remove(f.Name()); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"ERROR: could not remove temporary file %v\n\", f.Name())\n+\t\t}\n+\t}()\n+\n+\t// backendItem exists to better represent a\n+\t// [backend.Item] to users when editing. The\n+\t// Key is omitted as that isn't allowed to be modified,\n+\t// and the Value is converted to a string so that it\n+\t// is not base64 encoded during marshaling.\n+\ttype backendItem struct {",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2307379670",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58416,
        "pr_file": "tool/teleport/common/backend.go",
        "discussion_id": "2307379670",
        "commented_code": "@@ -53,3 +69,262 @@ func onClone(ctx context.Context, configPath string) error {\n \t}\n \treturn nil\n }\n+\n+func onBackendGet(ctx context.Context, config backend.Config, key, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\treturn trace.Wrap(printBackendItems(format, stream.Once(*item)))\n+}\n+\n+func onBackendList(ctx context.Context, config backend.Config, prefix, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tvar startKey, endKey backend.Key\n+\tif prefix != \"\" {\n+\t\tstartKey = backend.KeyFromString(prefix)\n+\t\tendKey = backend.RangeEnd(startKey.ExactKey())\n+\t} else {\n+\t\tstartKey = backend.NewKey(\"\")\n+\t\tendKey = backend.RangeEnd(startKey)\n+\t}\n+\n+\titems := bk.Items(ctx, backend.ItemsParams{StartKey: startKey, EndKey: endKey})\n+\n+\treturn trace.Wrap(printBackendItems(format, items))\n+}\n+\n+func printBackendItems(format string, items iter.Seq2[backend.Item, error]) error {\n+\t// backendItem exists to better represent a\n+\t// [backend.Item] to users. The Key is converted to\n+\t// it's textual representation, and the Value is\n+\t// converted to a string so that it is not base64 encoded\n+\t// during marshaling.\n+\ttype backendItem struct {\n+\t\tKey      string\n+\t\tValue    string\n+\t\tRevision string\n+\t\tExpires  time.Time\n+\t}\n+\n+\tbackendItems := stream.FilterMap(items, func(i backend.Item) (backendItem, bool) {\n+\t\treturn backendItem{\n+\t\t\tKey:      i.Key.String(),\n+\t\t\tExpires:  i.Expires,\n+\t\t\tRevision: i.Revision,\n+\t\t\tValue:    string(i.Value),\n+\t\t}, true\n+\t})\n+\n+\tswitch strings.ToLower(format) {\n+\tcase teleport.Text, \"\":\n+\t\ttable := asciitable.MakeTable([]string{\"Key\", \"Expires\", \"Revision\"})\n+\t\tfor row, err := range stream.FilterMap(backendItems, func(i backendItem) ([]string, bool) {\n+\t\t\texpiry := \"Never\"\n+\t\t\tif !i.Expires.IsZero() {\n+\t\t\t\texpiry = i.Expires.Format(time.RFC3339)\n+\t\t\t}\n+\t\t\treturn []string{i.Key, expiry, i.Revision}, true\n+\t\t}) {\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err, \"retrieving items\")\n+\t\t\t}\n+\n+\t\t\ttable.AddRow(row)\n+\t\t}\n+\n+\t\tif err := table.WriteTo(os.Stdout); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.JSON:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := utils.FastMarshalIndent(allItems, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.YAML:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := yaml.Marshal(allItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tdefault:\n+\t\treturn trace.BadParameter(\"unsupported format %q\", format)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func onBackendDelete(ctx context.Context, config backend.Config, key string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tif err := bk.Delete(ctx, backend.KeyFromString(key)); err != nil {\n+\t\treturn trace.Wrap(err, \"deleting item\")\n+\t}\n+\n+\tfmt.Printf(\"item %q has been deleted\\n\", key)\n+\treturn nil\n+}\n+\n+func checksum(filename string) (string, error) {\n+\tf, err := utils.OpenFileAllowingUnsafeLinks(filename)\n+\tif err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\tdefer f.Close()\n+\n+\th := sha256.New()\n+\tif _, err := io.Copy(h, f); err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\n+\treturn hex.EncodeToString(h.Sum(nil)), nil\n+}\n+\n+func onBackendEdit(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from being written over the editor.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\teditor := \"vi\"\n+\tfor _, v := range []string{\"TELEPORT_EDITOR\", \"VISUAL\", \"EDITOR\"} {\n+\t\tif value := os.Getenv(v); value != \"\" {\n+\t\t\teditor = value\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tf, err := os.CreateTemp(\"\", \"teleport-item*.yaml\")\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := os.Remove(f.Name()); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"ERROR: could not remove temporary file %v\\n\", f.Name())\n+\t\t}\n+\t}()\n+\n+\t// backendItem exists to better represent a\n+\t// [backend.Item] to users when editing. The\n+\t// Key is omitted as that isn't allowed to be modified,\n+\t// and the Value is converted to a string so that it\n+\t// is not base64 encoded during marshaling.\n+\ttype backendItem struct {",
        "comment_created_at": "2025-08-28T13:12:53+00:00",
        "comment_author": "okraport",
        "comment_body": "nit: I would consider naming this something to hint why it exists to avoid confusion when reading the code:\n\n```suggestion\n\ttype displayItem struct {\n```\n\nBut that's a nitpick/style, feel free to ignore. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2307959991",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58416,
        "pr_file": "tool/teleport/common/backend.go",
        "discussion_id": "2307379670",
        "commented_code": "@@ -53,3 +69,262 @@ func onClone(ctx context.Context, configPath string) error {\n \t}\n \treturn nil\n }\n+\n+func onBackendGet(ctx context.Context, config backend.Config, key, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\treturn trace.Wrap(printBackendItems(format, stream.Once(*item)))\n+}\n+\n+func onBackendList(ctx context.Context, config backend.Config, prefix, format string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tvar startKey, endKey backend.Key\n+\tif prefix != \"\" {\n+\t\tstartKey = backend.KeyFromString(prefix)\n+\t\tendKey = backend.RangeEnd(startKey.ExactKey())\n+\t} else {\n+\t\tstartKey = backend.NewKey(\"\")\n+\t\tendKey = backend.RangeEnd(startKey)\n+\t}\n+\n+\titems := bk.Items(ctx, backend.ItemsParams{StartKey: startKey, EndKey: endKey})\n+\n+\treturn trace.Wrap(printBackendItems(format, items))\n+}\n+\n+func printBackendItems(format string, items iter.Seq2[backend.Item, error]) error {\n+\t// backendItem exists to better represent a\n+\t// [backend.Item] to users. The Key is converted to\n+\t// it's textual representation, and the Value is\n+\t// converted to a string so that it is not base64 encoded\n+\t// during marshaling.\n+\ttype backendItem struct {\n+\t\tKey      string\n+\t\tValue    string\n+\t\tRevision string\n+\t\tExpires  time.Time\n+\t}\n+\n+\tbackendItems := stream.FilterMap(items, func(i backend.Item) (backendItem, bool) {\n+\t\treturn backendItem{\n+\t\t\tKey:      i.Key.String(),\n+\t\t\tExpires:  i.Expires,\n+\t\t\tRevision: i.Revision,\n+\t\t\tValue:    string(i.Value),\n+\t\t}, true\n+\t})\n+\n+\tswitch strings.ToLower(format) {\n+\tcase teleport.Text, \"\":\n+\t\ttable := asciitable.MakeTable([]string{\"Key\", \"Expires\", \"Revision\"})\n+\t\tfor row, err := range stream.FilterMap(backendItems, func(i backendItem) ([]string, bool) {\n+\t\t\texpiry := \"Never\"\n+\t\t\tif !i.Expires.IsZero() {\n+\t\t\t\texpiry = i.Expires.Format(time.RFC3339)\n+\t\t\t}\n+\t\t\treturn []string{i.Key, expiry, i.Revision}, true\n+\t\t}) {\n+\t\t\tif err != nil {\n+\t\t\t\treturn trace.Wrap(err, \"retrieving items\")\n+\t\t\t}\n+\n+\t\t\ttable.AddRow(row)\n+\t\t}\n+\n+\t\tif err := table.WriteTo(os.Stdout); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.JSON:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := utils.FastMarshalIndent(allItems, \"\", \"  \")\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tcase teleport.YAML:\n+\t\tallItems, err := stream.Collect(backendItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err, \"collecting items\")\n+\t\t}\n+\n+\t\tout, err := yaml.Marshal(allItems)\n+\t\tif err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\n+\t\tif _, err := fmt.Fprintln(os.Stdout, string(out)); err != nil {\n+\t\t\treturn trace.Wrap(err)\n+\t\t}\n+\tdefault:\n+\t\treturn trace.BadParameter(\"unsupported format %q\", format)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func onBackendDelete(ctx context.Context, config backend.Config, key string) error {\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\tif err := bk.Delete(ctx, backend.KeyFromString(key)); err != nil {\n+\t\treturn trace.Wrap(err, \"deleting item\")\n+\t}\n+\n+\tfmt.Printf(\"item %q has been deleted\\n\", key)\n+\treturn nil\n+}\n+\n+func checksum(filename string) (string, error) {\n+\tf, err := utils.OpenFileAllowingUnsafeLinks(filename)\n+\tif err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\tdefer f.Close()\n+\n+\th := sha256.New()\n+\tif _, err := io.Copy(h, f); err != nil {\n+\t\treturn \"\", trace.Wrap(err)\n+\t}\n+\n+\treturn hex.EncodeToString(h.Sum(nil)), nil\n+}\n+\n+func onBackendEdit(ctx context.Context, config backend.Config, key string) error {\n+\t// logs are discarded to prevent any logging output\n+\t// from being written over the editor.\n+\tslog.SetDefault(slog.New(slog.DiscardHandler))\n+\n+\tbk, err := backend.New(ctx, config.Type, config.Params)\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"creating backend\")\n+\t}\n+\n+\titem, err := bk.Get(ctx, backend.KeyFromString(key))\n+\tif err != nil {\n+\t\treturn trace.Wrap(err, \"getting item\")\n+\t}\n+\n+\teditor := \"vi\"\n+\tfor _, v := range []string{\"TELEPORT_EDITOR\", \"VISUAL\", \"EDITOR\"} {\n+\t\tif value := os.Getenv(v); value != \"\" {\n+\t\t\teditor = value\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tf, err := os.CreateTemp(\"\", \"teleport-item*.yaml\")\n+\tif err != nil {\n+\t\treturn trace.Wrap(err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := os.Remove(f.Name()); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"ERROR: could not remove temporary file %v\\n\", f.Name())\n+\t\t}\n+\t}()\n+\n+\t// backendItem exists to better represent a\n+\t// [backend.Item] to users when editing. The\n+\t// Key is omitted as that isn't allowed to be modified,\n+\t// and the Value is converted to a string so that it\n+\t// is not base64 encoded during marshaling.\n+\ttype backendItem struct {",
        "comment_created_at": "2025-08-28T16:37:31+00:00",
        "comment_author": "rosstimothy",
        "comment_body": "Renamed in [17b5b1b](https://github.com/gravitational/teleport/pull/58416/commits/17b5b1be3bc724e0a9f89b63d2c0354a389d1677).",
        "pr_file_module": null
      }
    ]
  }
]