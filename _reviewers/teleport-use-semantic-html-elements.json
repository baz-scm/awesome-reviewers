[
  {
    "discussion_id": "2316600032",
    "pr_number": 58586,
    "pr_file": "web/packages/teleport/src/SessionRecordings/view/player/RecordingPlayer.tsx",
    "created_at": "2025-09-02T16:26:21+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import {\n+  useCallback,\n+  useEffect,\n+  useImperativeHandle,\n+  useMemo,\n+  useRef,\n+  useState,\n+  type RefObject,\n+} from 'react';\n+import styled, { keyframes } from 'styled-components';\n+import { useEventListener } from 'usehooks-ts';\n+import Box from 'web/packages/design/src/Box';\n+import Flex from 'web/packages/design/src/Flex';\n+import { Pause, Play } from 'web/packages/design/src/Icon';\n+\n+import type { Player } from 'teleport/SessionRecordings/view/player/Player';\n+import {\n+  PlayerControls,\n+  type PlayerControlsHandle,\n+} from 'teleport/SessionRecordings/view/player/PlayerControls';\n+import type { PlayerHandle } from 'teleport/SessionRecordings/view/SshPlayer';\n+import {\n+  PlayerState,\n+  SessionStream,\n+} from 'teleport/SessionRecordings/view/stream/SessionStream';\n+import type { BaseEvent } from 'teleport/SessionRecordings/view/stream/types';\n+\n+export interface RecordingPlayerProps<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+  TEndEventType extends TEventType = TEventType,\n+> {\n+  duration: number;\n+  onTimeChange: (time: number) => void;\n+  onToggleSidebar?: () => void;\n+  onToggleTimeline?: () => void;\n+  onToggleFullscreen?: () => void;\n+  fullscreen?: boolean;\n+  player: Player<TEvent>;\n+  endEventType: TEndEventType;\n+  decodeEvent: (buffer: ArrayBuffer) => TEvent;\n+  ref: RefObject<PlayerHandle>;\n+  ws: WebSocket;\n+}\n+\n+export function RecordingPlayer<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+>({\n+  duration,\n+  onTimeChange,\n+  player,\n+  endEventType,\n+  fullscreen,\n+  decodeEvent,\n+  onToggleFullscreen,\n+  onToggleSidebar,\n+  onToggleTimeline,\n+  ref,\n+  ws,\n+}: RecordingPlayerProps<TEvent>) {\n+  const [state, setState] = useState(PlayerState.Loading);\n+\n+  const [showPlayButton, setShowPlayButton] = useState(true);\n+\n+  const controlsRef = useRef<PlayerControlsHandle>(null);\n+  const playerRef = useRef<HTMLDivElement>(null);\n+\n+  const stream = useMemo(\n+    () => new SessionStream(ws, player, decodeEvent, endEventType, duration),\n+    [ws, player, decodeEvent, endEventType, duration]\n+  );\n+\n+  useEffect(() => {\n+    stream.on('state', next => {\n+      setState(next);\n+    });\n+\n+    stream.on('time', time => {\n+      if (!controlsRef.current) {\n+        return;\n+      }\n+\n+      controlsRef.current.setTime(time);\n+      onTimeChange(time);\n+    });\n+\n+    stream.loadInitial();\n+\n+    return () => {\n+      stream.destroy();\n+    };\n+  }, [stream, onTimeChange]);\n+\n+  useEffect(() => {\n+    if (!playerRef.current) {\n+      return;\n+    }\n+\n+    player.init(playerRef.current);\n+\n+    const observer = new ResizeObserver(() => {\n+      player.fit();\n+    });\n+\n+    observer.observe(playerRef.current);\n+\n+    return () => {\n+      observer.disconnect();\n+    };\n+  }, [player]);\n+\n+  const handlePlay = useCallback(() => {\n+    if (showPlayButton) {\n+      setShowPlayButton(false);\n+    }\n+\n+    stream.play();\n+  }, [stream, showPlayButton]);\n+\n+  const handlePause = useCallback(() => {\n+    stream.pause();\n+  }, [stream]);\n+\n+  const handleSeek = useCallback(\n+    (time: number) => {\n+      if (showPlayButton) {\n+        setShowPlayButton(false);\n+      }\n+\n+      stream.seek(time);\n+    },\n+    [stream, showPlayButton]\n+  );\n+\n+  useImperativeHandle(ref, () => ({\n+    moveToTime: handleSeek,\n+  }));\n+\n+  return (\n+    <Box height=\"100%\" flex={1} p={3}>\n+      <Flex\n+        alignItems=\"stretch\"\n+        flexDirection=\"column\"\n+        border=\"1px solid\"\n+        height=\"100%\"\n+        borderColor=\"spotBackground.1\"\n+        borderRadius={4}\n+        overflow=\"hidden\"\n+      >\n+        {showPlayButton && (\n+          <PlayButton>\n+            <AdjustedPlay size=\"extra-large\" onClick={handlePlay} />\n+          </PlayButton>",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2316600032",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58586,
        "pr_file": "web/packages/teleport/src/SessionRecordings/view/player/RecordingPlayer.tsx",
        "discussion_id": "2316600032",
        "commented_code": "@@ -0,0 +1,324 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import {\n+  useCallback,\n+  useEffect,\n+  useImperativeHandle,\n+  useMemo,\n+  useRef,\n+  useState,\n+  type RefObject,\n+} from 'react';\n+import styled, { keyframes } from 'styled-components';\n+import { useEventListener } from 'usehooks-ts';\n+import Box from 'web/packages/design/src/Box';\n+import Flex from 'web/packages/design/src/Flex';\n+import { Pause, Play } from 'web/packages/design/src/Icon';\n+\n+import type { Player } from 'teleport/SessionRecordings/view/player/Player';\n+import {\n+  PlayerControls,\n+  type PlayerControlsHandle,\n+} from 'teleport/SessionRecordings/view/player/PlayerControls';\n+import type { PlayerHandle } from 'teleport/SessionRecordings/view/SshPlayer';\n+import {\n+  PlayerState,\n+  SessionStream,\n+} from 'teleport/SessionRecordings/view/stream/SessionStream';\n+import type { BaseEvent } from 'teleport/SessionRecordings/view/stream/types';\n+\n+export interface RecordingPlayerProps<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+  TEndEventType extends TEventType = TEventType,\n+> {\n+  duration: number;\n+  onTimeChange: (time: number) => void;\n+  onToggleSidebar?: () => void;\n+  onToggleTimeline?: () => void;\n+  onToggleFullscreen?: () => void;\n+  fullscreen?: boolean;\n+  player: Player<TEvent>;\n+  endEventType: TEndEventType;\n+  decodeEvent: (buffer: ArrayBuffer) => TEvent;\n+  ref: RefObject<PlayerHandle>;\n+  ws: WebSocket;\n+}\n+\n+export function RecordingPlayer<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+>({\n+  duration,\n+  onTimeChange,\n+  player,\n+  endEventType,\n+  fullscreen,\n+  decodeEvent,\n+  onToggleFullscreen,\n+  onToggleSidebar,\n+  onToggleTimeline,\n+  ref,\n+  ws,\n+}: RecordingPlayerProps<TEvent>) {\n+  const [state, setState] = useState(PlayerState.Loading);\n+\n+  const [showPlayButton, setShowPlayButton] = useState(true);\n+\n+  const controlsRef = useRef<PlayerControlsHandle>(null);\n+  const playerRef = useRef<HTMLDivElement>(null);\n+\n+  const stream = useMemo(\n+    () => new SessionStream(ws, player, decodeEvent, endEventType, duration),\n+    [ws, player, decodeEvent, endEventType, duration]\n+  );\n+\n+  useEffect(() => {\n+    stream.on('state', next => {\n+      setState(next);\n+    });\n+\n+    stream.on('time', time => {\n+      if (!controlsRef.current) {\n+        return;\n+      }\n+\n+      controlsRef.current.setTime(time);\n+      onTimeChange(time);\n+    });\n+\n+    stream.loadInitial();\n+\n+    return () => {\n+      stream.destroy();\n+    };\n+  }, [stream, onTimeChange]);\n+\n+  useEffect(() => {\n+    if (!playerRef.current) {\n+      return;\n+    }\n+\n+    player.init(playerRef.current);\n+\n+    const observer = new ResizeObserver(() => {\n+      player.fit();\n+    });\n+\n+    observer.observe(playerRef.current);\n+\n+    return () => {\n+      observer.disconnect();\n+    };\n+  }, [player]);\n+\n+  const handlePlay = useCallback(() => {\n+    if (showPlayButton) {\n+      setShowPlayButton(false);\n+    }\n+\n+    stream.play();\n+  }, [stream, showPlayButton]);\n+\n+  const handlePause = useCallback(() => {\n+    stream.pause();\n+  }, [stream]);\n+\n+  const handleSeek = useCallback(\n+    (time: number) => {\n+      if (showPlayButton) {\n+        setShowPlayButton(false);\n+      }\n+\n+      stream.seek(time);\n+    },\n+    [stream, showPlayButton]\n+  );\n+\n+  useImperativeHandle(ref, () => ({\n+    moveToTime: handleSeek,\n+  }));\n+\n+  return (\n+    <Box height=\"100%\" flex={1} p={3}>\n+      <Flex\n+        alignItems=\"stretch\"\n+        flexDirection=\"column\"\n+        border=\"1px solid\"\n+        height=\"100%\"\n+        borderColor=\"spotBackground.1\"\n+        borderRadius={4}\n+        overflow=\"hidden\"\n+      >\n+        {showPlayButton && (\n+          <PlayButton>\n+            <AdjustedPlay size=\"extra-large\" onClick={handlePlay} />\n+          </PlayButton>",
        "comment_created_at": "2025-09-02T16:26:21+00:00",
        "comment_author": "gzdunek",
        "comment_body": "None of these elements is a button. Could we make `PlayButton` an actual button and attach an `onClick` handler to it?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2324567347",
    "pr_number": 58586,
    "pr_file": "web/packages/teleport/src/SessionRecordings/view/player/RecordingPlayer.tsx",
    "created_at": "2025-09-05T09:20:43+00:00",
    "commented_code": "+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import {\n+  useCallback,\n+  useEffect,\n+  useImperativeHandle,\n+  useMemo,\n+  useRef,\n+  useState,\n+  type RefObject,\n+} from 'react';\n+import styled, { keyframes } from 'styled-components';\n+import { useEventListener } from 'usehooks-ts';\n+import Box from 'web/packages/design/src/Box';\n+import Flex from 'web/packages/design/src/Flex';\n+import { Pause, Play } from 'web/packages/design/src/Icon';\n+\n+import type { Player } from 'teleport/SessionRecordings/view/player/Player';\n+import {\n+  PlayerControls,\n+  type PlayerControlsHandle,\n+} from 'teleport/SessionRecordings/view/player/PlayerControls';\n+import type { PlayerHandle } from 'teleport/SessionRecordings/view/SshPlayer';\n+import {\n+  PlayerState,\n+  SessionStream,\n+} from 'teleport/SessionRecordings/view/stream/SessionStream';\n+import type { BaseEvent } from 'teleport/SessionRecordings/view/stream/types';\n+\n+export interface RecordingPlayerProps<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+  TEndEventType extends TEventType = TEventType,\n+> {\n+  duration: number;\n+  onTimeChange: (time: number) => void;\n+  onToggleSidebar?: () => void;\n+  onToggleTimeline?: () => void;\n+  onToggleFullscreen?: () => void;\n+  fullscreen?: boolean;\n+  player: Player<TEvent>;\n+  endEventType: TEndEventType;\n+  decodeEvent: (buffer: ArrayBuffer) => TEvent;\n+  ref: RefObject<PlayerHandle>;\n+  ws: WebSocket;\n+}\n+\n+export function RecordingPlayer<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+>({\n+  duration,\n+  onTimeChange,\n+  player,\n+  endEventType,\n+  fullscreen,\n+  decodeEvent,\n+  onToggleFullscreen,\n+  onToggleSidebar,\n+  onToggleTimeline,\n+  ref,\n+  ws,\n+}: RecordingPlayerProps<TEvent>) {\n+  const [playerState, setPlayerState] = useState(PlayerState.Loading);\n+\n+  const [showPlayButton, setShowPlayButton] = useState(true);\n+\n+  const controlsRef = useRef<PlayerControlsHandle>(null);\n+  const playerRef = useRef<HTMLDivElement>(null);\n+\n+  const stream = useMemo(\n+    () => new SessionStream(ws, player, decodeEvent, endEventType, duration),\n+    [ws, player, decodeEvent, endEventType, duration]\n+  );\n+\n+  useEffect(() => {\n+    stream.on('state', next => {\n+      setPlayerState(next);\n+    });\n+\n+    stream.on('time', time => {\n+      if (!controlsRef.current) {\n+        return;\n+      }\n+\n+      controlsRef.current.setTime(time);\n+      onTimeChange(time);\n+    });\n+\n+    stream.loadInitial();\n+\n+    return () => {\n+      stream.destroy();\n+    };\n+  }, [stream, onTimeChange]);\n+\n+  useEffect(() => {\n+    if (!playerRef.current) {\n+      return;\n+    }\n+\n+    player.init(playerRef.current);\n+\n+    const observer = new ResizeObserver(() => {\n+      player.fit();\n+    });\n+\n+    observer.observe(playerRef.current);\n+\n+    return () => {\n+      observer.disconnect();\n+    };\n+  }, [player]);\n+\n+  const handlePlay = useCallback(() => {\n+    if (showPlayButton) {\n+      setShowPlayButton(false);\n+    }\n+\n+    stream.play();\n+  }, [stream, showPlayButton]);\n+\n+  const handlePause = useCallback(() => {\n+    stream.pause();\n+  }, [stream]);\n+\n+  const handleSeek = useCallback(\n+    (time: number) => {\n+      if (showPlayButton) {\n+        setShowPlayButton(false);\n+      }\n+\n+      stream.seek(time);\n+    },\n+    [stream, showPlayButton]\n+  );\n+\n+  useImperativeHandle(ref, () => ({\n+    moveToTime: handleSeek,\n+  }));\n+\n+  return (\n+    <Box height=\"100%\" flex={1} p={3}>\n+      <Flex\n+        alignItems=\"stretch\"\n+        flexDirection=\"column\"\n+        border=\"1px solid\"\n+        height=\"100%\"\n+        borderColor=\"spotBackground.1\"\n+        borderRadius={4}\n+        overflow=\"hidden\"\n+      >\n+        {showPlayButton && (\n+          <PlayButton onClick={handlePlay}>\n+            <AdjustedPlay size=\"extra-large\" />\n+          </PlayButton>\n+        )}\n+\n+        <PlayPauseKeyboardShortcuts\n+          onPlay={handlePlay}\n+          onPause={handlePause}\n+          state={playerState}\n+        />\n+\n+        <PlayerBox ref={playerRef} />\n+\n+        <PlayerControls\n+          fullscreen={fullscreen}\n+          onToggleFullscreen={onToggleFullscreen}\n+          onToggleSidebar={onToggleSidebar}\n+          onToggleTimeline={onToggleTimeline}\n+          duration={duration}\n+          onPlay={handlePlay}\n+          onPause={handlePause}\n+          onSeek={handleSeek}\n+          state={playerState}\n+          ref={controlsRef}\n+        />\n+      </Flex>\n+    </Box>\n+  );\n+}\n+\n+const PlayButton = styled.button`\n+  border: none;\n+  background: none;\n+  color: white;\n+  display: flex;\n+  align-items: center;\n+  justify-content: center;\n+  position: absolute;\n+  top: 50%;\n+  left: 50%;\n+  transform: translate(-50%, -50%);\n+  background: rgba(0, 0, 0, 0.6);\n+  border-radius: 50%;\n+  padding: ${p => p.theme.space[3]}px;\n+  z-index: 1;\n+  cursor: pointer;\n+\n+  &:hover {\n+    background: rgba(0, 0, 0, 0.4);\n+  }\n+`;\n+\n+interface PlayPauseKeyboardShortcutsProps {\n+  onPlay: () => void;\n+  onPause: () => void;\n+  state: PlayerState;\n+}\n+\n+function PlayPauseKeyboardShortcuts({\n+  onPlay,\n+  onPause,\n+  state,\n+}: PlayPauseKeyboardShortcutsProps) {\n+  const [visibleState, setVisibleState] = useState<\n+    PlayerState.Paused | PlayerState.Playing | null\n+  >(null);\n+\n+  const timeoutRef = useRef<number | null>(null);\n+\n+  useEffect(() => {\n+    if (visibleState) {\n+      if (timeoutRef.current) {\n+        window.clearTimeout(timeoutRef.current);\n+      }\n+\n+      timeoutRef.current = window.setTimeout(() => {\n+        setVisibleState(null);\n+      }, 1000);\n+    }\n+\n+    return () => {\n+      if (timeoutRef.current) {\n+        window.clearTimeout(timeoutRef.current);\n+      }\n+    };\n+  }, [visibleState]);",
    "repo_full_name": "gravitational/teleport",
    "discussion_comments": [
      {
        "comment_id": "2324567347",
        "repo_full_name": "gravitational/teleport",
        "pr_number": 58586,
        "pr_file": "web/packages/teleport/src/SessionRecordings/view/player/RecordingPlayer.tsx",
        "discussion_id": "2324567347",
        "commented_code": "@@ -0,0 +1,330 @@\n+/**\n+ * Teleport\n+ * Copyright (C) 2025 Gravitational, Inc.\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+import {\n+  useCallback,\n+  useEffect,\n+  useImperativeHandle,\n+  useMemo,\n+  useRef,\n+  useState,\n+  type RefObject,\n+} from 'react';\n+import styled, { keyframes } from 'styled-components';\n+import { useEventListener } from 'usehooks-ts';\n+import Box from 'web/packages/design/src/Box';\n+import Flex from 'web/packages/design/src/Flex';\n+import { Pause, Play } from 'web/packages/design/src/Icon';\n+\n+import type { Player } from 'teleport/SessionRecordings/view/player/Player';\n+import {\n+  PlayerControls,\n+  type PlayerControlsHandle,\n+} from 'teleport/SessionRecordings/view/player/PlayerControls';\n+import type { PlayerHandle } from 'teleport/SessionRecordings/view/SshPlayer';\n+import {\n+  PlayerState,\n+  SessionStream,\n+} from 'teleport/SessionRecordings/view/stream/SessionStream';\n+import type { BaseEvent } from 'teleport/SessionRecordings/view/stream/types';\n+\n+export interface RecordingPlayerProps<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+  TEndEventType extends TEventType = TEventType,\n+> {\n+  duration: number;\n+  onTimeChange: (time: number) => void;\n+  onToggleSidebar?: () => void;\n+  onToggleTimeline?: () => void;\n+  onToggleFullscreen?: () => void;\n+  fullscreen?: boolean;\n+  player: Player<TEvent>;\n+  endEventType: TEndEventType;\n+  decodeEvent: (buffer: ArrayBuffer) => TEvent;\n+  ref: RefObject<PlayerHandle>;\n+  ws: WebSocket;\n+}\n+\n+export function RecordingPlayer<\n+  TEvent extends BaseEvent<TEventType>,\n+  TEventType extends number = number,\n+>({\n+  duration,\n+  onTimeChange,\n+  player,\n+  endEventType,\n+  fullscreen,\n+  decodeEvent,\n+  onToggleFullscreen,\n+  onToggleSidebar,\n+  onToggleTimeline,\n+  ref,\n+  ws,\n+}: RecordingPlayerProps<TEvent>) {\n+  const [playerState, setPlayerState] = useState(PlayerState.Loading);\n+\n+  const [showPlayButton, setShowPlayButton] = useState(true);\n+\n+  const controlsRef = useRef<PlayerControlsHandle>(null);\n+  const playerRef = useRef<HTMLDivElement>(null);\n+\n+  const stream = useMemo(\n+    () => new SessionStream(ws, player, decodeEvent, endEventType, duration),\n+    [ws, player, decodeEvent, endEventType, duration]\n+  );\n+\n+  useEffect(() => {\n+    stream.on('state', next => {\n+      setPlayerState(next);\n+    });\n+\n+    stream.on('time', time => {\n+      if (!controlsRef.current) {\n+        return;\n+      }\n+\n+      controlsRef.current.setTime(time);\n+      onTimeChange(time);\n+    });\n+\n+    stream.loadInitial();\n+\n+    return () => {\n+      stream.destroy();\n+    };\n+  }, [stream, onTimeChange]);\n+\n+  useEffect(() => {\n+    if (!playerRef.current) {\n+      return;\n+    }\n+\n+    player.init(playerRef.current);\n+\n+    const observer = new ResizeObserver(() => {\n+      player.fit();\n+    });\n+\n+    observer.observe(playerRef.current);\n+\n+    return () => {\n+      observer.disconnect();\n+    };\n+  }, [player]);\n+\n+  const handlePlay = useCallback(() => {\n+    if (showPlayButton) {\n+      setShowPlayButton(false);\n+    }\n+\n+    stream.play();\n+  }, [stream, showPlayButton]);\n+\n+  const handlePause = useCallback(() => {\n+    stream.pause();\n+  }, [stream]);\n+\n+  const handleSeek = useCallback(\n+    (time: number) => {\n+      if (showPlayButton) {\n+        setShowPlayButton(false);\n+      }\n+\n+      stream.seek(time);\n+    },\n+    [stream, showPlayButton]\n+  );\n+\n+  useImperativeHandle(ref, () => ({\n+    moveToTime: handleSeek,\n+  }));\n+\n+  return (\n+    <Box height=\"100%\" flex={1} p={3}>\n+      <Flex\n+        alignItems=\"stretch\"\n+        flexDirection=\"column\"\n+        border=\"1px solid\"\n+        height=\"100%\"\n+        borderColor=\"spotBackground.1\"\n+        borderRadius={4}\n+        overflow=\"hidden\"\n+      >\n+        {showPlayButton && (\n+          <PlayButton onClick={handlePlay}>\n+            <AdjustedPlay size=\"extra-large\" />\n+          </PlayButton>\n+        )}\n+\n+        <PlayPauseKeyboardShortcuts\n+          onPlay={handlePlay}\n+          onPause={handlePause}\n+          state={playerState}\n+        />\n+\n+        <PlayerBox ref={playerRef} />\n+\n+        <PlayerControls\n+          fullscreen={fullscreen}\n+          onToggleFullscreen={onToggleFullscreen}\n+          onToggleSidebar={onToggleSidebar}\n+          onToggleTimeline={onToggleTimeline}\n+          duration={duration}\n+          onPlay={handlePlay}\n+          onPause={handlePause}\n+          onSeek={handleSeek}\n+          state={playerState}\n+          ref={controlsRef}\n+        />\n+      </Flex>\n+    </Box>\n+  );\n+}\n+\n+const PlayButton = styled.button`\n+  border: none;\n+  background: none;\n+  color: white;\n+  display: flex;\n+  align-items: center;\n+  justify-content: center;\n+  position: absolute;\n+  top: 50%;\n+  left: 50%;\n+  transform: translate(-50%, -50%);\n+  background: rgba(0, 0, 0, 0.6);\n+  border-radius: 50%;\n+  padding: ${p => p.theme.space[3]}px;\n+  z-index: 1;\n+  cursor: pointer;\n+\n+  &:hover {\n+    background: rgba(0, 0, 0, 0.4);\n+  }\n+`;\n+\n+interface PlayPauseKeyboardShortcutsProps {\n+  onPlay: () => void;\n+  onPause: () => void;\n+  state: PlayerState;\n+}\n+\n+function PlayPauseKeyboardShortcuts({\n+  onPlay,\n+  onPause,\n+  state,\n+}: PlayPauseKeyboardShortcutsProps) {\n+  const [visibleState, setVisibleState] = useState<\n+    PlayerState.Paused | PlayerState.Playing | null\n+  >(null);\n+\n+  const timeoutRef = useRef<number | null>(null);\n+\n+  useEffect(() => {\n+    if (visibleState) {\n+      if (timeoutRef.current) {\n+        window.clearTimeout(timeoutRef.current);\n+      }\n+\n+      timeoutRef.current = window.setTimeout(() => {\n+        setVisibleState(null);\n+      }, 1000);\n+    }\n+\n+    return () => {\n+      if (timeoutRef.current) {\n+        window.clearTimeout(timeoutRef.current);\n+      }\n+    };\n+  }, [visibleState]);",
        "comment_created_at": "2025-09-05T09:20:43+00:00",
        "comment_author": "gzdunek",
        "comment_body": "We can simplify the logic to:\n```suggestion\n  useEffect(() => {\n    if (visibleState) {\n      return;\n    }\n\n    if (timeoutRef.current) {\n      window.clearTimeout(timeoutRef.current);\n    }\n\n    timeoutRef.current = window.setTimeout(() => {\n      setVisibleState(null);\n    }, 1000);\n\n    return () => {\n      window.clearTimeout(timeoutRef.current);\n    };\n  }, [visibleState]);\n```",
        "pr_file_module": null
      }
    ]
  }
]