[
  {
    "discussion_id": "2214457319",
    "pr_number": 8061,
    "pr_file": "service/worker/batcher/workflow.go",
    "created_at": "2025-07-17T23:01:35+00:00",
    "commented_code": "Jitter         time.Duration\n \t}\n \n+\tUpdateOptionsActivitiesParams struct {\n+\t\tIdentity        string\n+\t\tActivityType    string\n+\t\tMatchAll        bool\n+\t\tActivityOptions *activitypb.ActivityOptions\n+\t\tUpdateMask      *fieldmaskpb.FieldMask",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2214457319",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8061,
        "pr_file": "service/worker/batcher/workflow.go",
        "discussion_id": "2214457319",
        "commented_code": "@@ -103,6 +109,26 @@ type (\n \t\tJitter         time.Duration\n \t}\n \n+\tUpdateOptionsActivitiesParams struct {\n+\t\tIdentity        string\n+\t\tActivityType    string\n+\t\tMatchAll        bool\n+\t\tActivityOptions *activitypb.ActivityOptions\n+\t\tUpdateMask      *fieldmaskpb.FieldMask",
        "comment_created_at": "2025-07-17T23:01:35+00:00",
        "comment_author": "bergundy",
        "comment_body": "I _think_ this is fine but you should know that using a nested proto struct in workflow input doesn't use proto JSON serialization, instead it uses plain JSON serialization which may yield unexpected results.\r\n\r\nIf we were writing this from scratch, the right thing to do here is to define a proto struct for the workflow input and reuse the request structs for each of these actions.\r\nYou may want to serialize these proto messages yourself and bypass the SDK's serialization.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216478482",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8061,
        "pr_file": "service/worker/batcher/workflow.go",
        "discussion_id": "2214457319",
        "commented_code": "@@ -103,6 +109,26 @@ type (\n \t\tJitter         time.Duration\n \t}\n \n+\tUpdateOptionsActivitiesParams struct {\n+\t\tIdentity        string\n+\t\tActivityType    string\n+\t\tMatchAll        bool\n+\t\tActivityOptions *activitypb.ActivityOptions\n+\t\tUpdateMask      *fieldmaskpb.FieldMask",
        "comment_created_at": "2025-07-18T16:47:55+00:00",
        "comment_author": "spkane31",
        "comment_body": "Chatted w/ Yuri on this. We already use the proto struct for `FieldMask` without custom serialization in other batch commands so we should be fine here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216598203",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8061,
        "pr_file": "service/worker/batcher/workflow.go",
        "discussion_id": "2214457319",
        "commented_code": "@@ -103,6 +109,26 @@ type (\n \t\tJitter         time.Duration\n \t}\n \n+\tUpdateOptionsActivitiesParams struct {\n+\t\tIdentity        string\n+\t\tActivityType    string\n+\t\tMatchAll        bool\n+\t\tActivityOptions *activitypb.ActivityOptions\n+\t\tUpdateMask      *fieldmaskpb.FieldMask",
        "comment_created_at": "2025-07-18T17:49:46+00:00",
        "comment_author": "bergundy",
        "comment_body": "I would test that every field in these message are properly serialized.\r\nGenerally, what we've done here is bad practice and should be avoided in our codebase. It's not just `FieldMask`, it's also `ActivityOptions`. Even if we know that all fields are properly serialized today (which I'm not convinced of), there's no guarantee that future fields will.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216666690",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8061,
        "pr_file": "service/worker/batcher/workflow.go",
        "discussion_id": "2214457319",
        "commented_code": "@@ -103,6 +109,26 @@ type (\n \t\tJitter         time.Duration\n \t}\n \n+\tUpdateOptionsActivitiesParams struct {\n+\t\tIdentity        string\n+\t\tActivityType    string\n+\t\tMatchAll        bool\n+\t\tActivityOptions *activitypb.ActivityOptions\n+\t\tUpdateMask      *fieldmaskpb.FieldMask",
        "comment_created_at": "2025-07-18T18:34:04+00:00",
        "comment_author": "gow",
        "comment_body": "fyi: There are known issues with the default protobuf json converter when the message contains `oneoff` fields - https://protobuf.dev/programming-guides/json/. It's recommended to use protojson to explicitly serialize/deserialize in such cases.\r\nIn this case you're fine since UpdateActivitiesOptionsParams doesn't contain any protobufs with `oneoff` fields. But that may change in the future if someone adds additional fields to this input.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2074224910",
    "pr_number": 7678,
    "pr_file": "chasm/component.go",
    "created_at": "2025-05-05T21:27:07+00:00",
    "commented_code": "import (\n \t\"context\"\n \t\"reflect\"\n+\t\"strconv\"\n+\n+\tcommonpb \"go.temporal.io/api/common/v1\"\n )\n \n type Component interface {\n-\tLifecycleState() LifecycleState\n+\tLifecycleState(Context) LifecycleState\n \n-\t// TBD: the framework can just put the component in terminated state\n-\t// component lifecycle state can still be running when getting terminated\n-\t// but framework will use some rule to block incoming operations\n-\t// Terminate()\n+\tTerminate(MutableContext, TerminateComponentRequest) (TerminateComponentResponse, error)",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2074224910",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7678,
        "pr_file": "chasm/component.go",
        "discussion_id": "2074224910",
        "commented_code": "@@ -5,28 +5,38 @@ package chasm\n import (\n \t\"context\"\n \t\"reflect\"\n+\t\"strconv\"\n+\n+\tcommonpb \"go.temporal.io/api/common/v1\"\n )\n \n type Component interface {\n-\tLifecycleState() LifecycleState\n+\tLifecycleState(Context) LifecycleState\n \n-\t// TBD: the framework can just put the component in terminated state\n-\t// component lifecycle state can still be running when getting terminated\n-\t// but framework will use some rule to block incoming operations\n-\t// Terminate()\n+\tTerminate(MutableContext, TerminateComponentRequest) (TerminateComponentResponse, error)",
        "comment_created_at": "2025-05-05T21:27:07+00:00",
        "comment_author": "lina-temporal",
        "comment_body": "(nitpick) The way this is structured makes me think we're future-proofing the request/response in anticipation of them changing; is there something about `Terminate` in particular that warrants this, versus just `Terminate(ctx MutableContext, identity, reason string, details *commonpb.Payloads) error`? I'm not opposed to the pattern, I'm just not sure what the criteria is for methods in the framework to warrant the pattern.",
        "pr_file_module": null
      },
      {
        "comment_id": "2074371170",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7678,
        "pr_file": "chasm/component.go",
        "discussion_id": "2074224910",
        "commented_code": "@@ -5,28 +5,38 @@ package chasm\n import (\n \t\"context\"\n \t\"reflect\"\n+\t\"strconv\"\n+\n+\tcommonpb \"go.temporal.io/api/common/v1\"\n )\n \n type Component interface {\n-\tLifecycleState() LifecycleState\n+\tLifecycleState(Context) LifecycleState\n \n-\t// TBD: the framework can just put the component in terminated state\n-\t// component lifecycle state can still be running when getting terminated\n-\t// but framework will use some rule to block incoming operations\n-\t// Terminate()\n+\tTerminate(MutableContext, TerminateComponentRequest) (TerminateComponentResponse, error)",
        "comment_created_at": "2025-05-05T23:33:53+00:00",
        "comment_author": "yycptt",
        "comment_body": "yeah I think we want to make them as stable as possible. A lot of (most?) exported method/functions are variadic functions. Interfaces definitions also have corresponding embedUnimplmented implementation to avoid breaking changes.\r\n\r\nWe eventually need this when more chasm components are develop, and since it's straight forward to do it for this Terminate method, so think I can just do it from the beginning. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198494720",
    "pr_number": 8027,
    "pr_file": "service/matching/db.go",
    "created_at": "2025-07-10T19:05:53+00:00",
    "commented_code": "db.subqueues[subqueue].oldestTime = oldestTime\n }\n \n-func (db *taskQueueDB) getApproximateBacklogCount(subqueue int) int64 {\n-\tdb.Lock()\n-\tdefer db.Unlock()\n-\treturn db.subqueues[subqueue].ApproximateBacklogCount\n-}\n-\n-func (db *taskQueueDB) getTotalApproximateBacklogCount() (total int64) {\n+func (db *taskQueueDB) getApproximateBacklogCounts() map[int32]int64 {\n \tdb.Lock()\n \tdefer db.Unlock()\n+\tcounts := make(map[int32]int64)\n \tfor _, s := range db.subqueues {\n-\t\ttotal += s.ApproximateBacklogCount\n+\t\tcounts[s.Key.Priority] = s.ApproximateBacklogCount",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2198494720",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8027,
        "pr_file": "service/matching/db.go",
        "discussion_id": "2198494720",
        "commented_code": "@@ -308,19 +308,14 @@ func (db *taskQueueDB) updateBacklogStatsLocked(subqueue int, countDelta int64,\n \tdb.subqueues[subqueue].oldestTime = oldestTime\n }\n \n-func (db *taskQueueDB) getApproximateBacklogCount(subqueue int) int64 {\n-\tdb.Lock()\n-\tdefer db.Unlock()\n-\treturn db.subqueues[subqueue].ApproximateBacklogCount\n-}\n-\n-func (db *taskQueueDB) getTotalApproximateBacklogCount() (total int64) {\n+func (db *taskQueueDB) getApproximateBacklogCounts() map[int32]int64 {\n \tdb.Lock()\n \tdefer db.Unlock()\n+\tcounts := make(map[int32]int64)\n \tfor _, s := range db.subqueues {\n-\t\ttotal += s.ApproximateBacklogCount\n+\t\tcounts[s.Key.Priority] = s.ApproximateBacklogCount",
        "comment_created_at": "2025-07-10T19:05:53+00:00",
        "comment_author": "dnr",
        "comment_body": "actually nevermind.. after reading more I think this should return a slice of counts, one per subqueue. taskQueueDB should work in terms of subqueues only, it shouldn't know anything about their semantics, like priority",
        "pr_file_module": null
      },
      {
        "comment_id": "2201066190",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8027,
        "pr_file": "service/matching/db.go",
        "discussion_id": "2198494720",
        "commented_code": "@@ -308,19 +308,14 @@ func (db *taskQueueDB) updateBacklogStatsLocked(subqueue int, countDelta int64,\n \tdb.subqueues[subqueue].oldestTime = oldestTime\n }\n \n-func (db *taskQueueDB) getApproximateBacklogCount(subqueue int) int64 {\n-\tdb.Lock()\n-\tdefer db.Unlock()\n-\treturn db.subqueues[subqueue].ApproximateBacklogCount\n-}\n-\n-func (db *taskQueueDB) getTotalApproximateBacklogCount() (total int64) {\n+func (db *taskQueueDB) getApproximateBacklogCounts() map[int32]int64 {\n \tdb.Lock()\n \tdefer db.Unlock()\n+\tcounts := make(map[int32]int64)\n \tfor _, s := range db.subqueues {\n-\t\ttotal += s.ApproximateBacklogCount\n+\t\tcounts[s.Key.Priority] = s.ApproximateBacklogCount",
        "comment_created_at": "2025-07-11T15:40:37+00:00",
        "comment_author": "stephanos",
        "comment_body": "Hm, I don't know. I've implemented it, but unless I misunderstood the intention it feels worse now.\r\n\r\nThe index-based lookups have potential for off-by-one errors (had one already) since priorities are 1-based, the code is more complicated (now you need two loops), and the fact that db knows about priorities is still there and required to encode the priorities into the slice index (otherwise, how would the caller know which count belong to which priority).\r\n\r\nCouldn't we just call the method `ApproximateBacklogCountByPriority` and return a map of priorities?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2191477754",
    "pr_number": 7914,
    "pr_file": "service/matching/handler.go",
    "created_at": "2025-07-08T04:58:35+00:00",
    "commented_code": "// RecordWorkerHeartbeat receive heartbeat request from the worker.\n func (h *Handler) RecordWorkerHeartbeat(\n-\tcontext.Context, *matchingservice.RecordWorkerHeartbeatRequest,\n+\t_ context.Context, request *matchingservice.RecordWorkerHeartbeatRequest,\n ) (*matchingservice.RecordWorkerHeartbeatResponse, error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"RecordWorkerHeartbeat is not implemented\")\n+\tnsID := namespace.ID(request.GetNamespaceId())\n+\th.workersRegistry.RecordWorkerHeartbeat(nsID, request.GetHeartbeartRequest().GetWorkerHeartbeat())",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2191477754",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7914,
        "pr_file": "service/matching/handler.go",
        "discussion_id": "2191477754",
        "commented_code": "@@ -535,16 +539,32 @@ func (h *Handler) ListNexusEndpoints(ctx context.Context, request *matchingservi\n \n // RecordWorkerHeartbeat receive heartbeat request from the worker.\n func (h *Handler) RecordWorkerHeartbeat(\n-\tcontext.Context, *matchingservice.RecordWorkerHeartbeatRequest,\n+\t_ context.Context, request *matchingservice.RecordWorkerHeartbeatRequest,\n ) (*matchingservice.RecordWorkerHeartbeatResponse, error) {\n-\treturn nil, serviceerror.NewUnimplemented(\"RecordWorkerHeartbeat is not implemented\")\n+\tnsID := namespace.ID(request.GetNamespaceId())\n+\th.workersRegistry.RecordWorkerHeartbeat(nsID, request.GetHeartbeartRequest().GetWorkerHeartbeat())",
        "comment_created_at": "2025-07-08T04:58:35+00:00",
        "comment_author": "sivagirish81",
        "comment_body": "@ychebotarev : The worker_heartbeat in RecordWorkerHeartbeatRequest is a repeated field. So the getter is expected to return a slice []*v110.WorkerHeartbeat but the workersRegistry.RecordWorkerHeartbeat expects a pointer to *workerpb.WorkerHeartbeat. I think the workersRegistry.RecordWorkerHeartbeat needs to be changed.\r\n\r\nI am facing build issues on my local. There is a type mismatch due to which I am not able to bring up my server. I am not sure if I am missing something here?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118387507",
    "pr_number": 7774,
    "pr_file": "chasm/context.go",
    "created_at": "2025-05-31T23:28:16+00:00",
    "commented_code": "// NOTE: component created in the current transaction won't have a ref\n \t// this is a Ref to the component state at the start of the transition\n-\tRef(Component) (ComponentRef, bool)\n+\tRefC(Component) (ComponentRef, bool)\n+\tRefD(proto.Message) (ComponentRef, bool)",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2118387507",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7774,
        "pr_file": "chasm/context.go",
        "discussion_id": "2118387507",
        "commented_code": "@@ -11,7 +13,8 @@ type Context interface {\n \n \t// NOTE: component created in the current transaction won't have a ref\n \t// this is a Ref to the component state at the start of the transition\n-\tRef(Component) (ComponentRef, bool)\n+\tRefC(Component) (ComponentRef, bool)\n+\tRefD(proto.Message) (ComponentRef, bool)",
        "comment_created_at": "2025-05-31T23:28:16+00:00",
        "comment_author": "yycptt",
        "comment_body": "I don't think we want to expose the Ref to a Data, for now at least. Component is the most basic unit someone outside the CHASM framework can interact with. \r\nWe probably need a different type of Ref (instead of ComponentRef) if we want to make Data node directly addressable from outside in the future. \r\n\r\nNo concern on making this a private method and use it for DataPointer implementation and only expose Ref(Component)",
        "pr_file_module": null
      }
    ]
  }
]