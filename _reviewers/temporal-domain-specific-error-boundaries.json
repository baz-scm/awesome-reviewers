[
  {
    "discussion_id": "2089500557",
    "pr_number": 7761,
    "pr_file": "chasm/tree.go",
    "created_at": "2025-05-14T18:20:40+00:00",
    "commented_code": "case fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2089500557",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-14T18:20:40+00:00",
        "comment_author": "bergundy",
        "comment_body": "nit: I find this more readable:\r\n\r\n```suggestion\r\n\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"CHASM collection only supports map[string]Field[T]: value of %s is not of a map type\", n.nodeName))\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2089751694",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-14T21:04:34+00:00",
        "comment_author": "bergundy",
        "comment_body": "I also don't think we should be using gRPC errors in our application code. We should have specific errors for these internal errors and not assume what context these methods will be called from.",
        "pr_file_module": null
      },
      {
        "comment_id": "2089768055",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-14T21:16:12+00:00",
        "comment_author": "bergundy",
        "comment_body": "I don't even think that internal is the right error here since it is retryable and this should not be a retryable error.",
        "pr_file_module": null
      },
      {
        "comment_id": "2089887876",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-14T23:10:45+00:00",
        "comment_author": "alexshtin",
        "comment_body": "it needs to be \"very scary error\" :-). I agree about errors. It is not in the scope of this PR though.",
        "pr_file_module": null
      },
      {
        "comment_id": "2090115314",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-15T03:07:22+00:00",
        "comment_author": "bergundy",
        "comment_body": "Not sure I understood what you want to address and what to defer. Whatever you defer, please track.",
        "pr_file_module": null
      },
      {
        "comment_id": "2090165396",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-15T03:30:01+00:00",
        "comment_author": "alexshtin",
        "comment_body": "I agree we shouldn't use `serviceerror`s in CHASM. But define generic CHASM error and wrap it with more details every time. And then some sort of conversion will be needed in case if the error needs to cross single service boundaries. But we need to do it holistically in entire package. I would like to defer (and track) it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2090241500",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7761,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2089500557",
        "commented_code": "@@ -529,46 +543,117 @@ func (n *Node) syncSubComponentsInternal(\n \t\tcase fieldKindData:\n \t\t\t// Nothing to sync.\n \t\tcase fieldKindSubField:\n-\t\t\tinternalV := field.val.FieldByName(internalFieldName)\n-\t\t\t//nolint:revive // Internal field is guaranteed to be of type fieldInternal.\n-\t\t\tinternal := internalV.Interface().(fieldInternal)\n-\t\t\tif internal.isEmpty() {\n+\t\t\tkeepChild, updatedFieldV, err := n.syncSubField(field.val, field.name, nodePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif updatedFieldV.IsValid() {\n+\t\t\t\tfield.val.Set(updatedFieldV)\n+\t\t\t}\n+\t\t\tif keepChild {\n+\t\t\t\tchildrenToKeep[field.name] = struct{}{}\n+\t\t\t}\n+\t\tcase fieldKindSubCollection:\n+\t\t\tif field.val.IsNil() {\n+\t\t\t\t// If Collection field is nil then delete all collection items nodes and collection node itself.\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif internal.node == nil && internal.value() != nil {\n-\t\t\t\t// Field is not empty but tree node is not set. It means this is a new field, and a node must be created.\n-\t\t\t\tchildNode := newNode(n.nodeBase, n, field.name)\n \n-\t\t\t\tif err := assertStructPointer(reflect.TypeOf(internal.value())); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tchildNode.value = internal.value()\n-\t\t\t\tchildNode.initSerializedNode(internal.fieldType())\n-\t\t\t\tchildNode.valueState = valueStateNeedSerialize\n-\n-\t\t\t\tn.children[field.name] = childNode\n-\t\t\t\tinternal.node = childNode\n-\t\t\t\t// TODO: this line can be remove if Internal becomes a *fieldInternal.\n-\t\t\t\tinternalV.Set(reflect.ValueOf(internal))\n+\t\t\tcollectionNode := n.children[field.name]\n+\t\t\tif collectionNode == nil {\n+\t\t\t\tcollectionNode = newNode(n.nodeBase, n, field.name)\n+\t\t\t\tcollectionNode.initSerializedCollectionNode()\n+\t\t\t\tcollectionNode.valueState = valueStateNeedSerialize\n+\t\t\t\tn.children[field.name] = collectionNode\n \t\t\t}\n-\t\t\tif internal.fieldType() == fieldTypeComponent {\n-\t\t\t\tif err := internal.node.syncSubComponentsInternal(append(nodePath, field.name)); err != nil {\n+\n+\t\t\t// Validate collection type\n+\t\t\tif field.val.Kind() != reflect.Map {\n+\t\t\t\treturn serviceerror.NewInternal(fmt.Sprintf(\"only support map[string]Field[T] as CHASM collection: value of %s is not of a map type\", n.nodeName))",
        "comment_created_at": "2025-05-15T04:51:17+00:00",
        "comment_author": "yycptt",
        "comment_body": "+1. I was debating with myself when using serviceerrors in the implementation as well. But still went ahead with that to minimize the risk of error handling issues in the codebase and initial chasm component implementation can pretty much just forward errors to upper layer. But yeah agree, as a framework, chasm should not return serviceerrors. \r\n\r\nWe'll need different chasm error types defined and returned for cases like notFound, non-retryable, transient, etc. We may also need to defined some error types for component logic to return.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070925889",
    "pr_number": 7697,
    "pr_file": "service/history/api/describeworkflow/api.go",
    "created_at": "2025-05-01T23:30:24+00:00",
    "commented_code": "callback callbacks.Callback,\n \toutboundQueueCBPool *circuitbreakerpool.OutboundQueueCircuitBreakerPool,\n ) (*workflowpb.CallbackInfo, error) {\n-\tdestination := \"\"\n-\tcbSpec := &commonpb.Callback{}\n-\tswitch variant := callback.Callback.Variant.(type) {\n-\tcase *persistencespb.Callback_Nexus_:\n-\t\tcbSpec.Variant = &commonpb.Callback_Nexus_{\n-\t\t\tNexus: &commonpb.Callback_Nexus{\n-\t\t\t\tUrl:    variant.Nexus.GetUrl(),\n-\t\t\t\tHeader: variant.Nexus.GetHeader(),\n-\t\t\t},\n-\t\t}\n-\t\tdestination = variant.Nexus.GetUrl()\n-\tdefault:\n+\tcbSpec, err := workflow.PersistenceCallbackToAPICallback(callback.Callback)\n+\tif err != nil || cbSpec.GetNexus() == nil {\n+\t\t// Errors only happen for non-nexus callbacks.",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2070925889",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7697,
        "pr_file": "service/history/api/describeworkflow/api.go",
        "discussion_id": "2070925889",
        "commented_code": "@@ -333,18 +333,9 @@ func buildCallbackInfo(\n \tcallback callbacks.Callback,\n \toutboundQueueCBPool *circuitbreakerpool.OutboundQueueCircuitBreakerPool,\n ) (*workflowpb.CallbackInfo, error) {\n-\tdestination := \"\"\n-\tcbSpec := &commonpb.Callback{}\n-\tswitch variant := callback.Callback.Variant.(type) {\n-\tcase *persistencespb.Callback_Nexus_:\n-\t\tcbSpec.Variant = &commonpb.Callback_Nexus_{\n-\t\t\tNexus: &commonpb.Callback_Nexus{\n-\t\t\t\tUrl:    variant.Nexus.GetUrl(),\n-\t\t\t\tHeader: variant.Nexus.GetHeader(),\n-\t\t\t},\n-\t\t}\n-\t\tdestination = variant.Nexus.GetUrl()\n-\tdefault:\n+\tcbSpec, err := workflow.PersistenceCallbackToAPICallback(callback.Callback)\n+\tif err != nil || cbSpec.GetNexus() == nil {\n+\t\t// Errors only happen for non-nexus callbacks.",
        "comment_created_at": "2025-05-01T23:30:24+00:00",
        "comment_author": "bergundy",
        "comment_body": "Hesitant to make such assumptions in the code. If the function intends to mark something as an ignorable error it should probably just return nil or have a specific error type that you can filter out.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112567123",
    "pr_number": 7815,
    "pr_file": "service/worker/workerdeployment/client.go",
    "created_at": "2025-05-28T19:04:21+00:00",
    "commented_code": "Meta:  &updatepb.Meta{UpdateId: requestID, Identity: identity},\n \t})\n \tif err != nil {\n+\t\tif isResourceExhausted(err) {\n+\t\t\treturn nil, serviceerror.NewInternal(fmt.Sprintf(ErrTooManyRequests, \"UpdateVersionMetadata\"))",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2112567123",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7815,
        "pr_file": "service/worker/workerdeployment/client.go",
        "discussion_id": "2112567123",
        "commented_code": "@@ -345,6 +345,9 @@ func (d *ClientImpl) UpdateVersionMetadata(\n \t\tMeta:  &updatepb.Meta{UpdateId: requestID, Identity: identity},\n \t})\n \tif err != nil {\n+\t\tif isResourceExhausted(err) {\n+\t\t\treturn nil, serviceerror.NewInternal(fmt.Sprintf(ErrTooManyRequests, \"UpdateVersionMetadata\"))",
        "comment_created_at": "2025-05-28T19:04:21+00:00",
        "comment_author": "ShahabT",
        "comment_body": "hmm... not sure why we are changing the error code to Internal, if user is making rapid request we should send them ResourceExhausted error code, right?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1148027552",
    "pr_number": 4099,
    "pr_file": "service/history/api/queryworkflow/api.go",
    "created_at": "2023-03-24T20:33:33+00:00",
    "commented_code": "return nil, consts.ErrWorkflowTaskNotScheduled\n \t}\n \n+\tif mutableState.GetExecutionInfo().WorkflowTaskAttempt > 1 {\n+\t\t// while workflow task is failing, the query to that workflow will also fail. Failing fast here to prevent wasting\n+\t\t// resources to load history for a query that will fail.\n+\t\treturn nil, serviceerror.NewFailedPrecondition(\"Query has failed due to a failing workflow task\")",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "1148027552",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 4099,
        "pr_file": "service/history/api/queryworkflow/api.go",
        "discussion_id": "1148027552",
        "commented_code": "@@ -115,6 +115,12 @@ func Invoke(\n \t\treturn nil, consts.ErrWorkflowTaskNotScheduled\n \t}\n \n+\tif mutableState.GetExecutionInfo().WorkflowTaskAttempt > 1 {\n+\t\t// while workflow task is failing, the query to that workflow will also fail. Failing fast here to prevent wasting\n+\t\t// resources to load history for a query that will fail.\n+\t\treturn nil, serviceerror.NewFailedPrecondition(\"Query has failed due to a failing workflow task\")",
        "comment_created_at": "2023-03-24T20:33:33+00:00",
        "comment_author": "yiminc",
        "comment_body": "Cannot query workflow due to Workflow Task in failed state.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2124580723",
    "pr_number": 7729,
    "pr_file": "service/history/timer_queue_active_task_executor.go",
    "created_at": "2025-06-03T18:14:30+00:00",
    "commented_code": "return nil\n }\n \n+func (t *timerQueueActiveTaskExecutor) executeChasmSideEffectTimerTask(\n+\tctx context.Context,\n+\ttask *tasks.ChasmTask,\n+) error {\n+\tctx, cancel := context.WithTimeout(ctx, taskTimeout)\n+\tdefer cancel()\n+\n+\tif !queues.IsTimeExpired(task, t.Now(), task.GetVisibilityTime()) {\n+\t\treturn nil\n+\t}",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2124580723",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7729,
        "pr_file": "service/history/timer_queue_active_task_executor.go",
        "discussion_id": "2124580723",
        "commented_code": "@@ -925,6 +929,62 @@ func (t *timerQueueActiveTaskExecutor) processActivityWorkflowRules(\n \treturn nil\n }\n \n+func (t *timerQueueActiveTaskExecutor) executeChasmSideEffectTimerTask(\n+\tctx context.Context,\n+\ttask *tasks.ChasmTask,\n+) error {\n+\tctx, cancel := context.WithTimeout(ctx, taskTimeout)\n+\tdefer cancel()\n+\n+\tif !queues.IsTimeExpired(task, t.Now(), task.GetVisibilityTime()) {\n+\t\treturn nil\n+\t}",
        "comment_created_at": "2025-06-03T18:14:30+00:00",
        "comment_author": "yycptt",
        "comment_body": "This is not expected to happen and we can't drop the task in the case.\r\nProbably add an assertion and return an retryable (unavailable for example) error. ",
        "pr_file_module": null
      }
    ]
  }
]