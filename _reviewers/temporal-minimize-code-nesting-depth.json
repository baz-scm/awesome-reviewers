[
  {
    "discussion_id": "2164641846",
    "pr_number": 7949,
    "pr_file": "service/history/api/multioperation/api.go",
    "created_at": "2025-06-24T18:24:51+00:00",
    "commented_code": "ns := namespaceEntry.Name().String()\n \t// TODO(stephan): remove dynamic config again\n \tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n+\t\tif uws.noStartButUpdateWasAbortedByClosingWorkflow(err) {",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2164641846",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7949,
        "pr_file": "service/history/api/multioperation/api.go",
        "discussion_id": "2164641846",
        "commented_code": "@@ -121,18 +121,37 @@ func Invoke(\n \tns := namespaceEntry.Name().String()\n \t// TODO(stephan): remove dynamic config again\n \tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n+\t\tif uws.noStartButUpdateWasAbortedByClosingWorkflow(err) {",
        "comment_created_at": "2025-06-24T18:24:51+00:00",
        "comment_author": "ychebotarev",
        "comment_body": "highly recommend to reduce those nestings. It will be much easier to read. \r\nI opened in the separate window to just read it.\r\n```\r\nif !shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) ||\r\n ! uws.noStartButUpdateWasAbortedByClosingWorkflow(err) {\r\n   return res, err\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2164780487",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7949,
        "pr_file": "service/history/api/multioperation/api.go",
        "discussion_id": "2164641846",
        "commented_code": "@@ -121,18 +121,37 @@ func Invoke(\n \tns := namespaceEntry.Name().String()\n \t// TODO(stephan): remove dynamic config again\n \tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n+\t\tif uws.noStartButUpdateWasAbortedByClosingWorkflow(err) {",
        "comment_created_at": "2025-06-24T19:53:21+00:00",
        "comment_author": "stephanos",
        "comment_body": "I thought you were on an ultra wide screen :D",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165222523",
    "pr_number": 7949,
    "pr_file": "service/history/api/multioperation/api.go",
    "created_at": "2025-06-25T00:56:16+00:00",
    "commented_code": "}\n \n \tres, err := uws.Invoke(ctx)\n-\t// When an Update is admitted but not yet accepted, it can be aborted by a closing workflow.\n-\t// Since - compared to an Update - Update-with-Start has the ability to start a new workflow, the\n-\t// server will retry the Update-with-Start operation (but only once to keep latency and resource usage low).\n-\tns := namespaceEntry.Name().String()\n-\t// TODO(stephan): remove dynamic config again\n-\tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n-\t\t\tuws2, err2 := newUpdateWithStart()\n-\t\t\tif err2 != nil {\n-\t\t\t\treturn nil, err2\n+\tif err != nil {",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2165222523",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7949,
        "pr_file": "service/history/api/multioperation/api.go",
        "discussion_id": "2165222523",
        "commented_code": "@@ -115,24 +116,50 @@ func Invoke(\n \t}\n \n \tres, err := uws.Invoke(ctx)\n-\t// When an Update is admitted but not yet accepted, it can be aborted by a closing workflow.\n-\t// Since - compared to an Update - Update-with-Start has the ability to start a new workflow, the\n-\t// server will retry the Update-with-Start operation (but only once to keep latency and resource usage low).\n-\tns := namespaceEntry.Name().String()\n-\t// TODO(stephan): remove dynamic config again\n-\tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n-\t\t\tuws2, err2 := newUpdateWithStart()\n-\t\t\tif err2 != nil {\n-\t\t\t\treturn nil, err2\n+\tif err != nil {",
        "comment_created_at": "2025-06-25T00:56:16+00:00",
        "comment_author": "ychebotarev",
        "comment_body": "well... :)\r\n\r\nnot blocking on this, but in general any extra nestings adds unnecessary cognitive load.\r\nflattening (is this a term?) improves readability.\r\n```\r\nif err == nil {\r\n   return res, err\r\n}\r\n\r\n...\r\n```\r\n(and you have one more below)\r\n\r\ncompare:\r\n```\r\n\r\nfunc foo() {\r\n    result, err = tryA()\r\n    if err == nil { return result, nil} \r\n    \r\n    result, err = tryB()\r\n    if err == nil { return result, nil} \r\n\r\n    result, err = tryB()\r\n    if err == nil { return result, nil} \r\n\r\n    return nil, custom_error\r\n}\r\n```\r\n\r\nversus\r\n\r\n```\r\nfunc foo() {\r\n    result, err = tryA()\r\n    if err != nil { \r\n          result, err = tryB()\r\n          if err != nil { \r\n               result, err = tryC() \r\n               if err != nil {\r\n                     return nil, custom_error\r\n               }\r\n          }\r\n     } \r\n     return result, err\r\n}\r\n```\r\n\r\n\r\n```\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2167121300",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7949,
        "pr_file": "service/history/api/multioperation/api.go",
        "discussion_id": "2165222523",
        "commented_code": "@@ -115,24 +116,50 @@ func Invoke(\n \t}\n \n \tres, err := uws.Invoke(ctx)\n-\t// When an Update is admitted but not yet accepted, it can be aborted by a closing workflow.\n-\t// Since - compared to an Update - Update-with-Start has the ability to start a new workflow, the\n-\t// server will retry the Update-with-Start operation (but only once to keep latency and resource usage low).\n-\tns := namespaceEntry.Name().String()\n-\t// TODO(stephan): remove dynamic config again\n-\tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n-\t\t\tuws2, err2 := newUpdateWithStart()\n-\t\t\tif err2 != nil {\n-\t\t\t\treturn nil, err2\n+\tif err != nil {",
        "comment_created_at": "2025-06-25T16:19:28+00:00",
        "comment_author": "stephanos",
        "comment_body": "I've considered this and what I don't like is the `if err == nil` part. It's surprising and easy to miss/mix up since 99.999% of all checks are `if err != nil`. I'd prefer a little bit of nesting over the surprise there.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167124478",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7949,
        "pr_file": "service/history/api/multioperation/api.go",
        "discussion_id": "2165222523",
        "commented_code": "@@ -115,24 +116,50 @@ func Invoke(\n \t}\n \n \tres, err := uws.Invoke(ctx)\n-\t// When an Update is admitted but not yet accepted, it can be aborted by a closing workflow.\n-\t// Since - compared to an Update - Update-with-Start has the ability to start a new workflow, the\n-\t// server will retry the Update-with-Start operation (but only once to keep latency and resource usage low).\n-\tns := namespaceEntry.Name().String()\n-\t// TODO(stephan): remove dynamic config again\n-\tif shardContext.GetConfig().EnableUpdateWithStartRetryOnClosedWorkflowAbort(ns) {\n-\t\tif !uws.workflowWasStarted && uws.updateWasAbortedByClosingWorkflow(err) {\n-\t\t\tuws2, err2 := newUpdateWithStart()\n-\t\t\tif err2 != nil {\n-\t\t\t\treturn nil, err2\n+\tif err != nil {",
        "comment_created_at": "2025-06-25T16:20:29+00:00",
        "comment_author": "stephanos",
        "comment_body": "I also actually like that you can clearly see, from the code structure, that these are special error handling cases that are sequential. The structure tells a story. I say that as someone who also deeply believes in making code as non-nested as possible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2208931821",
    "pr_number": 8038,
    "pr_file": "service/matching/matcher_data.go",
    "created_at": "2025-07-16T00:07:13+00:00",
    "commented_code": "//\n \t// Alternatively, if now is > ready by more than burst, then we end up subtracting the full\n \t// burst from now and adding one interval.\n-\ts.ready = max(now, s.ready+s.burst.Nanoseconds()) - s.burst.Nanoseconds() + tokens*s.interval.Nanoseconds()\n+\tif p.never() {\n+\t\treturn simpleLimiterNever\n+\t}\n+\tclippedReady := max(now, int64(ready)+p.burst.Nanoseconds()) - p.burst.Nanoseconds()\n+\treturn simpleLimiter(clippedReady + tokens*p.interval.Nanoseconds())\n+}\n+\n+// clip sets ready to an allowable range based on the given parameters.\n+func (ready simpleLimiter) clip(p simpleLimiterParams, now int64, maxTokens int64) simpleLimiter {\n+\tif p.interval < 0 {\n+\t\treturn simpleLimiterNever\n+\t}\n+\t// if ready was set very far in the future (e.g. because the rate was zero), then we can\n+\t// clip it back to now + maxTokens*interval + burst.\n+\treturn min(ready, simpleLimiter(now+maxTokens*p.interval.Nanoseconds()+p.burst.Nanoseconds()))",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2208931821",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8038,
        "pr_file": "service/matching/matcher_data.go",
        "discussion_id": "2208931821",
        "commented_code": "@@ -629,5 +718,19 @@ func (s *simpleLimiter) consume(now int64, tokens int64) {\n \t//\n \t// Alternatively, if now is > ready by more than burst, then we end up subtracting the full\n \t// burst from now and adding one interval.\n-\ts.ready = max(now, s.ready+s.burst.Nanoseconds()) - s.burst.Nanoseconds() + tokens*s.interval.Nanoseconds()\n+\tif p.never() {\n+\t\treturn simpleLimiterNever\n+\t}\n+\tclippedReady := max(now, int64(ready)+p.burst.Nanoseconds()) - p.burst.Nanoseconds()\n+\treturn simpleLimiter(clippedReady + tokens*p.interval.Nanoseconds())\n+}\n+\n+// clip sets ready to an allowable range based on the given parameters.\n+func (ready simpleLimiter) clip(p simpleLimiterParams, now int64, maxTokens int64) simpleLimiter {\n+\tif p.interval < 0 {\n+\t\treturn simpleLimiterNever\n+\t}\n+\t// if ready was set very far in the future (e.g. because the rate was zero), then we can\n+\t// clip it back to now + maxTokens*interval + burst.\n+\treturn min(ready, simpleLimiter(now+maxTokens*p.interval.Nanoseconds()+p.burst.Nanoseconds()))",
        "comment_created_at": "2025-07-16T00:07:13+00:00",
        "comment_author": "stephanos",
        "comment_body": "Would it be helpful to extract a variable from `now+maxTokens*p.interval.Nanoseconds()+p.burst.Nanoseconds()` to give it a name?",
        "pr_file_module": null
      },
      {
        "comment_id": "2210831988",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8038,
        "pr_file": "service/matching/matcher_data.go",
        "discussion_id": "2208931821",
        "commented_code": "@@ -629,5 +718,19 @@ func (s *simpleLimiter) consume(now int64, tokens int64) {\n \t//\n \t// Alternatively, if now is > ready by more than burst, then we end up subtracting the full\n \t// burst from now and adding one interval.\n-\ts.ready = max(now, s.ready+s.burst.Nanoseconds()) - s.burst.Nanoseconds() + tokens*s.interval.Nanoseconds()\n+\tif p.never() {\n+\t\treturn simpleLimiterNever\n+\t}\n+\tclippedReady := max(now, int64(ready)+p.burst.Nanoseconds()) - p.burst.Nanoseconds()\n+\treturn simpleLimiter(clippedReady + tokens*p.interval.Nanoseconds())\n+}\n+\n+// clip sets ready to an allowable range based on the given parameters.\n+func (ready simpleLimiter) clip(p simpleLimiterParams, now int64, maxTokens int64) simpleLimiter {\n+\tif p.interval < 0 {\n+\t\treturn simpleLimiterNever\n+\t}\n+\t// if ready was set very far in the future (e.g. because the rate was zero), then we can\n+\t// clip it back to now + maxTokens*interval + burst.\n+\treturn min(ready, simpleLimiter(now+maxTokens*p.interval.Nanoseconds()+p.burst.Nanoseconds()))",
        "comment_created_at": "2025-07-16T15:52:45+00:00",
        "comment_author": "dnr",
        "comment_body": "sure",
        "pr_file_module": null
      }
    ]
  }
]