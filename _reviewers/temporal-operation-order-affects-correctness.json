[
  {
    "discussion_id": "2208482733",
    "pr_number": 8052,
    "pr_file": "service/matching/fair_task_reader.go",
    "created_at": "2025-07-15T19:31:44+00:00",
    "commented_code": "it := merged.Iterator()\n \tvar highestLevel fairLevel\n \ttasks = tasks[:0] // reuse incoming slice to avoid an allocation\n-\tfor b := 0; it.Next() && b < batchSize; b++ {\n+\tfor b := 0; b < batchSize && it.Next(); b++ {",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2208482733",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8052,
        "pr_file": "service/matching/fair_task_reader.go",
        "discussion_id": "2208482733",
        "commented_code": "@@ -348,7 +348,7 @@ func (tr *fairTaskReader) mergeTasks(tasks []*persistencespb.AllocatedTaskInfo,\n \tit := merged.Iterator()\n \tvar highestLevel fairLevel\n \ttasks = tasks[:0] // reuse incoming slice to avoid an allocation\n-\tfor b := 0; it.Next() && b < batchSize; b++ {\n+\tfor b := 0; b < batchSize && it.Next(); b++ {",
        "comment_created_at": "2025-07-15T19:31:44+00:00",
        "comment_author": "stephanos",
        "comment_body": "Before, it was possible that a task was consumed from the iterator and then dropped if it happened at the batch size boundary.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071968444",
    "pr_number": 7701,
    "pr_file": "chasm/tree.go",
    "created_at": "2025-05-02T18:01:40+00:00",
    "commented_code": "return false\n }\n \n+// GetPureTasks returns all valid, expired/runnable pure tasks within the CHASM\n+// tree. The CHASM tree is left untouched, even if invalid tasks are\n+// detected (these are cleaned up as part of transaction close).\n+func (n *Node) GetPureTasks(deadline time.Time) ([]any, error) {\n+\tvar componentTasks []*persistencespb.ChasmComponentAttributes_Task\n+\n+\t// Walk the tree to find runnable, valid tasks.\n+\terr := n.walk(func(node *Node) error {\n+\t\t// Skip nodes that aren't serialized yet.\n+\t\tif node.serializedNode == nil || node.serializedNode.Metadata == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tcomponentAttr := node.serializedNode.Metadata.GetComponentAttributes()\n+\t\t// Skip nodes that aren't components.\n+\t\tif componentAttr == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvalidateContext := NewContext(context.Background(), n)\n+\t\tfor _, task := range componentAttr.GetPureTasks() {\n+\t\t\tif task.ScheduledTime.AsTime().After(deadline) {\n+\t\t\t\t// Pure tasks are stored in-order, so we can skip scanning the rest once we hit\n+\t\t\t\t// an unexpired task deadline.\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif task.PhysicalTaskStatus != physicalTaskStatusCreated {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Component value must be prepared for validation to work.\n+\t\t\tif err := node.prepareComponentValue(validateContext); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\t// Validate the task. If the task is invalid, skip it for processing (it'll be\n+\t\t\t// removed when the transaction closes).\n+\t\t\tok, err := node.validateComponentTask(validateContext, task)",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2071968444",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7701,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2071968444",
        "commented_code": "@@ -1241,6 +1241,83 @@ func (n *Node) isValueNeedSerialize() bool {\n \treturn false\n }\n \n+// GetPureTasks returns all valid, expired/runnable pure tasks within the CHASM\n+// tree. The CHASM tree is left untouched, even if invalid tasks are\n+// detected (these are cleaned up as part of transaction close).\n+func (n *Node) GetPureTasks(deadline time.Time) ([]any, error) {\n+\tvar componentTasks []*persistencespb.ChasmComponentAttributes_Task\n+\n+\t// Walk the tree to find runnable, valid tasks.\n+\terr := n.walk(func(node *Node) error {\n+\t\t// Skip nodes that aren't serialized yet.\n+\t\tif node.serializedNode == nil || node.serializedNode.Metadata == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tcomponentAttr := node.serializedNode.Metadata.GetComponentAttributes()\n+\t\t// Skip nodes that aren't components.\n+\t\tif componentAttr == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvalidateContext := NewContext(context.Background(), n)\n+\t\tfor _, task := range componentAttr.GetPureTasks() {\n+\t\t\tif task.ScheduledTime.AsTime().After(deadline) {\n+\t\t\t\t// Pure tasks are stored in-order, so we can skip scanning the rest once we hit\n+\t\t\t\t// an unexpired task deadline.\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif task.PhysicalTaskStatus != physicalTaskStatusCreated {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Component value must be prepared for validation to work.\n+\t\t\tif err := node.prepareComponentValue(validateContext); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\t// Validate the task. If the task is invalid, skip it for processing (it'll be\n+\t\t\t// removed when the transaction closes).\n+\t\t\tok, err := node.validateComponentTask(validateContext, task)",
        "comment_created_at": "2025-05-02T18:01:40+00:00",
        "comment_author": "yycptt",
        "comment_body": "hmm I don't think we can do validation of tasks first and then run all validated them. The execution of one task may invalidates another task. so we have to validate t1 -> execute  t1 -> validate t2 -> execute t2.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072019018",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7701,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2071968444",
        "commented_code": "@@ -1241,6 +1241,83 @@ func (n *Node) isValueNeedSerialize() bool {\n \treturn false\n }\n \n+// GetPureTasks returns all valid, expired/runnable pure tasks within the CHASM\n+// tree. The CHASM tree is left untouched, even if invalid tasks are\n+// detected (these are cleaned up as part of transaction close).\n+func (n *Node) GetPureTasks(deadline time.Time) ([]any, error) {\n+\tvar componentTasks []*persistencespb.ChasmComponentAttributes_Task\n+\n+\t// Walk the tree to find runnable, valid tasks.\n+\terr := n.walk(func(node *Node) error {\n+\t\t// Skip nodes that aren't serialized yet.\n+\t\tif node.serializedNode == nil || node.serializedNode.Metadata == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tcomponentAttr := node.serializedNode.Metadata.GetComponentAttributes()\n+\t\t// Skip nodes that aren't components.\n+\t\tif componentAttr == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvalidateContext := NewContext(context.Background(), n)\n+\t\tfor _, task := range componentAttr.GetPureTasks() {\n+\t\t\tif task.ScheduledTime.AsTime().After(deadline) {\n+\t\t\t\t// Pure tasks are stored in-order, so we can skip scanning the rest once we hit\n+\t\t\t\t// an unexpired task deadline.\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif task.PhysicalTaskStatus != physicalTaskStatusCreated {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Component value must be prepared for validation to work.\n+\t\t\tif err := node.prepareComponentValue(validateContext); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\t// Validate the task. If the task is invalid, skip it for processing (it'll be\n+\t\t\t// removed when the transaction closes).\n+\t\t\tok, err := node.validateComponentTask(validateContext, task)",
        "comment_created_at": "2025-05-02T18:49:12+00:00",
        "comment_author": "lina-temporal",
        "comment_body": "Sure, will fix that. I think moving the validate check into `ExecutePureTask` probably makes more sense. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071971930",
    "pr_number": 7701,
    "pr_file": "chasm/tree.go",
    "created_at": "2025-05-02T18:04:51+00:00",
    "commented_code": "return false\n }\n \n+// GetPureTasks returns all valid, expired/runnable pure tasks within the CHASM\n+// tree. The CHASM tree is left untouched, even if invalid tasks are\n+// detected (these are cleaned up as part of transaction close).\n+func (n *Node) GetPureTasks(deadline time.Time) ([]any, error) {\n+\tvar componentTasks []*persistencespb.ChasmComponentAttributes_Task\n+\n+\t// Walk the tree to find runnable, valid tasks.\n+\terr := n.walk(func(node *Node) error {\n+\t\t// Skip nodes that aren't serialized yet.\n+\t\tif node.serializedNode == nil || node.serializedNode.Metadata == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tcomponentAttr := node.serializedNode.Metadata.GetComponentAttributes()\n+\t\t// Skip nodes that aren't components.\n+\t\tif componentAttr == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvalidateContext := NewContext(context.Background(), n)\n+\t\tfor _, task := range componentAttr.GetPureTasks() {\n+\t\t\tif task.ScheduledTime.AsTime().After(deadline) {\n+\t\t\t\t// Pure tasks are stored in-order, so we can skip scanning the rest once we hit\n+\t\t\t\t// an unexpired task deadline.\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif task.PhysicalTaskStatus != physicalTaskStatusCreated {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Component value must be prepared for validation to work.\n+\t\t\tif err := node.prepareComponentValue(validateContext); err != nil {",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2071971930",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7701,
        "pr_file": "chasm/tree.go",
        "discussion_id": "2071971930",
        "commented_code": "@@ -1241,6 +1241,83 @@ func (n *Node) isValueNeedSerialize() bool {\n \treturn false\n }\n \n+// GetPureTasks returns all valid, expired/runnable pure tasks within the CHASM\n+// tree. The CHASM tree is left untouched, even if invalid tasks are\n+// detected (these are cleaned up as part of transaction close).\n+func (n *Node) GetPureTasks(deadline time.Time) ([]any, error) {\n+\tvar componentTasks []*persistencespb.ChasmComponentAttributes_Task\n+\n+\t// Walk the tree to find runnable, valid tasks.\n+\terr := n.walk(func(node *Node) error {\n+\t\t// Skip nodes that aren't serialized yet.\n+\t\tif node.serializedNode == nil || node.serializedNode.Metadata == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tcomponentAttr := node.serializedNode.Metadata.GetComponentAttributes()\n+\t\t// Skip nodes that aren't components.\n+\t\tif componentAttr == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tvalidateContext := NewContext(context.Background(), n)\n+\t\tfor _, task := range componentAttr.GetPureTasks() {\n+\t\t\tif task.ScheduledTime.AsTime().After(deadline) {\n+\t\t\t\t// Pure tasks are stored in-order, so we can skip scanning the rest once we hit\n+\t\t\t\t// an unexpired task deadline.\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif task.PhysicalTaskStatus != physicalTaskStatusCreated {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Component value must be prepared for validation to work.\n+\t\t\tif err := node.prepareComponentValue(validateContext); err != nil {",
        "comment_created_at": "2025-05-02T18:04:51+00:00",
        "comment_author": "yycptt",
        "comment_body": "minor: we can probably reuse node.Component() with an empty ComponentRef(). Then we only need to implement access rule in that method and task processing side can benefit from it as well.",
        "pr_file_module": null
      }
    ]
  }
]