[
  {
    "discussion_id": "2190656109",
    "pr_number": 8004,
    "pr_file": "service/matching/matching_engine.go",
    "created_at": "2025-07-07T17:08:31+00:00",
    "commented_code": "}\n \t}\n \n+\tif req.GetReportConfig() {\n+\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif userData == nil || userData.GetData() == nil {",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2190656109",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8004,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2190656109",
        "commented_code": "@@ -1352,6 +1352,18 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \t\t}\n \t}\n \n+\tif req.GetReportConfig() {\n+\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif userData == nil || userData.GetData() == nil {",
        "comment_created_at": "2025-07-07T17:08:31+00:00",
        "comment_author": "dnr",
        "comment_body": "The GetX() wrappers check for nil receivers, so you can just write `if userData.GetData() == nil`",
        "pr_file_module": null
      },
      {
        "comment_id": "2190809242",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 8004,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2190656109",
        "commented_code": "@@ -1352,6 +1352,18 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \t\t}\n \t}\n \n+\tif req.GetReportConfig() {\n+\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif userData == nil || userData.GetData() == nil {",
        "comment_created_at": "2025-07-07T18:45:45+00:00",
        "comment_author": "sivagirish81",
        "comment_body": "Noted.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159563690",
    "pr_number": 7943,
    "pr_file": "service/matching/matching_engine.go",
    "created_at": "2025-06-20T19:33:27+00:00",
    "commented_code": "}\n \t}\n \n+\tif req.ShowTaskQueueConfig {\n+\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttaskQueueType := req.GetTaskQueueType()\n+\t\ttaskQueueUserData := userData.GetData().GetPerType()[int32(taskQueueType)]\n+\t\tdescrResp.DescResponse.Configs = taskQueueUserData.TaskQueueConfig",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2159563690",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7943,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2159563690",
        "commented_code": "@@ -1351,6 +1364,16 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \t\t}\n \t}\n \n+\tif req.ShowTaskQueueConfig {\n+\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttaskQueueType := req.GetTaskQueueType()\n+\t\ttaskQueueUserData := userData.GetData().GetPerType()[int32(taskQueueType)]\n+\t\tdescrResp.DescResponse.Configs = taskQueueUserData.TaskQueueConfig",
        "comment_created_at": "2025-06-20T19:33:27+00:00",
        "comment_author": "dnr",
        "comment_body": "this may be nil so you have to be careful:\r\n```suggestion\r\n\t\ttaskQueueType := req.GetTaskQueueType()\r\n\t\ttaskQueueUserData := userData.GetData().GetPerType()[int32(taskQueueType)]\r\n\t\tdescrResp.DescResponse.Configs = taskQueueUserData.GetTaskQueueConfig()\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070545075",
    "pr_number": 7052,
    "pr_file": "common/dynamicconfig/deepcopy.go",
    "created_at": "2025-05-01T17:18:10+00:00",
    "commented_code": "+// The MIT License\n+//\n+// Copyright (c) 2025 Temporal Technologies Inc.  All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package dynamicconfig\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+)\n+\n+// deepCopyForMapstructure does a simple deep copy of T. Fancy cases (anything other than plain\n+// old data) is not handled and will panic.\n+func deepCopyForMapstructure[T any](t T) T {\n+\treturn deepCopyValue(reflect.ValueOf(t)).Interface().(T)\n+}\n+\n+func deepCopyValue(v reflect.Value) reflect.Value {\n+\tswitch v.Kind() {\n+\tcase reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n+\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n+\t\treflect.Uintptr, reflect.Float32, reflect.Float64, reflect.String:\n+\t\tnv := reflect.New(v.Type()).Elem()\n+\t\tnv.Set(v)\n+\t\treturn nv\n+\tcase reflect.Array:\n+\t\tnv := reflect.New(v.Type()).Elem()\n+\t\tfor i := range v.Len() {\n+\t\t\tnv.Index(i).Set(deepCopyValue(v.Index(i)))\n+\t\t}\n+\t\treturn nv\n+\tcase reflect.Map:\n+\t\tif v.IsNil() {\n+\t\t\treturn v\n+\t\t}\n+\t\tnv := reflect.MakeMapWithSize(v.Type(), v.Len())\n+\t\tfor i := v.MapRange(); i.Next(); {\n+\t\t\tnv.SetMapIndex(i.Key(), deepCopyValue(i.Value()))\n+\t\t}\n+\t\treturn nv",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2070545075",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7052,
        "pr_file": "common/dynamicconfig/deepcopy.go",
        "discussion_id": "2070545075",
        "commented_code": "@@ -0,0 +1,82 @@\n+// The MIT License\n+//\n+// Copyright (c) 2025 Temporal Technologies Inc.  All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package dynamicconfig\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+)\n+\n+// deepCopyForMapstructure does a simple deep copy of T. Fancy cases (anything other than plain\n+// old data) is not handled and will panic.\n+func deepCopyForMapstructure[T any](t T) T {\n+\treturn deepCopyValue(reflect.ValueOf(t)).Interface().(T)\n+}\n+\n+func deepCopyValue(v reflect.Value) reflect.Value {\n+\tswitch v.Kind() {\n+\tcase reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n+\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n+\t\treflect.Uintptr, reflect.Float32, reflect.Float64, reflect.String:\n+\t\tnv := reflect.New(v.Type()).Elem()\n+\t\tnv.Set(v)\n+\t\treturn nv\n+\tcase reflect.Array:\n+\t\tnv := reflect.New(v.Type()).Elem()\n+\t\tfor i := range v.Len() {\n+\t\t\tnv.Index(i).Set(deepCopyValue(v.Index(i)))\n+\t\t}\n+\t\treturn nv\n+\tcase reflect.Map:\n+\t\tif v.IsNil() {\n+\t\t\treturn v\n+\t\t}\n+\t\tnv := reflect.MakeMapWithSize(v.Type(), v.Len())\n+\t\tfor i := v.MapRange(); i.Next(); {\n+\t\t\tnv.SetMapIndex(i.Key(), deepCopyValue(i.Value()))\n+\t\t}\n+\t\treturn nv",
        "comment_created_at": "2025-05-01T17:18:10+00:00",
        "comment_author": "bergundy",
        "comment_body": "nit: This case isn't tested, not blocking since the code looks good but wouldn't hurt to add a test.\r\n\r\nAlso, is there ever a need to deepcopy the key?",
        "pr_file_module": null
      },
      {
        "comment_id": "2080626021",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7052,
        "pr_file": "common/dynamicconfig/deepcopy.go",
        "discussion_id": "2070545075",
        "commented_code": "@@ -0,0 +1,82 @@\n+// The MIT License\n+//\n+// Copyright (c) 2025 Temporal Technologies Inc.  All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package dynamicconfig\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+)\n+\n+// deepCopyForMapstructure does a simple deep copy of T. Fancy cases (anything other than plain\n+// old data) is not handled and will panic.\n+func deepCopyForMapstructure[T any](t T) T {\n+\treturn deepCopyValue(reflect.ValueOf(t)).Interface().(T)\n+}\n+\n+func deepCopyValue(v reflect.Value) reflect.Value {\n+\tswitch v.Kind() {\n+\tcase reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n+\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n+\t\treflect.Uintptr, reflect.Float32, reflect.Float64, reflect.String:\n+\t\tnv := reflect.New(v.Type()).Elem()\n+\t\tnv.Set(v)\n+\t\treturn nv\n+\tcase reflect.Array:\n+\t\tnv := reflect.New(v.Type()).Elem()\n+\t\tfor i := range v.Len() {\n+\t\t\tnv.Index(i).Set(deepCopyValue(v.Index(i)))\n+\t\t}\n+\t\treturn nv\n+\tcase reflect.Map:\n+\t\tif v.IsNil() {\n+\t\t\treturn v\n+\t\t}\n+\t\tnv := reflect.MakeMapWithSize(v.Type(), v.Len())\n+\t\tfor i := v.MapRange(); i.Next(); {\n+\t\t\tnv.SetMapIndex(i.Key(), deepCopyValue(i.Value()))\n+\t\t}\n+\t\treturn nv",
        "comment_created_at": "2025-05-08T23:27:55+00:00",
        "comment_author": "dnr",
        "comment_body": "I don't think we need to deepcopy the key, you can't use reference types as keys, and for things like structs or arrays, you can't mutate a field in the key.\r\n\r\nI'll add a test.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2114864370",
    "pr_number": 7816,
    "pr_file": "service/matching/matching_engine.go",
    "created_at": "2025-05-29T22:56:44+00:00",
    "commented_code": "if err != nil {\n \t\treturn nil, err\n \t}\n-\treturn pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\t//nolint:staticcheck // SA1019 deprecated\n+\tdescrResp, err := pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req.ReportStats {\n+\t\ttotalStats := &taskqueuepb.TaskQueueStats{}\n+\t\tif ts := pm.GetCache(\"totalStats\"); ts != nil {\n+\t\t\t//revive:disable-next-line:unchecked-type-assertion\n+\t\t\ttotalStats = ts.(*taskqueuepb.TaskQueueStats)\n+\t\t} else {\n+\t\t\t// find number of partitions\n+\t\t\trootPartition, err := tqid.PartitionFromProto(req.GetTaskQueue(), request.GetNamespaceId(), req.GetTaskQueueType())\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttqConfig := newTaskQueueConfig(rootPartition.TaskQueue(), e.config, namespace.Name(req.Namespace))\n+\t\t\tnumPartitions := max(tqConfig.NumWritePartitions(), tqConfig.NumReadPartitions())\n+\n+\t\t\t// find all buildIds\n+\t\t\tvar buildIds []string\n+\t\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif userData != nil {\n+\t\t\t\tif typedUserData := userData.GetData().GetPerType()[int32(pm.Partition().TaskType())]; typedUserData != nil {\n+\t\t\t\t\tfor _, v := range typedUserData.GetDeploymentData().GetVersions() {",
    "repo_full_name": "temporalio/temporal",
    "discussion_comments": [
      {
        "comment_id": "2114864370",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7816,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2114864370",
        "commented_code": "@@ -1258,7 +1259,76 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\t//nolint:staticcheck // SA1019 deprecated\n+\tdescrResp, err := pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req.ReportStats {\n+\t\ttotalStats := &taskqueuepb.TaskQueueStats{}\n+\t\tif ts := pm.GetCache(\"totalStats\"); ts != nil {\n+\t\t\t//revive:disable-next-line:unchecked-type-assertion\n+\t\t\ttotalStats = ts.(*taskqueuepb.TaskQueueStats)\n+\t\t} else {\n+\t\t\t// find number of partitions\n+\t\t\trootPartition, err := tqid.PartitionFromProto(req.GetTaskQueue(), request.GetNamespaceId(), req.GetTaskQueueType())\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttqConfig := newTaskQueueConfig(rootPartition.TaskQueue(), e.config, namespace.Name(req.Namespace))\n+\t\t\tnumPartitions := max(tqConfig.NumWritePartitions(), tqConfig.NumReadPartitions())\n+\n+\t\t\t// find all buildIds\n+\t\t\tvar buildIds []string\n+\t\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif userData != nil {\n+\t\t\t\tif typedUserData := userData.GetData().GetPerType()[int32(pm.Partition().TaskType())]; typedUserData != nil {\n+\t\t\t\t\tfor _, v := range typedUserData.GetDeploymentData().GetVersions() {",
        "comment_created_at": "2025-05-29T22:56:44+00:00",
        "comment_author": "dnr",
        "comment_body": "You don't actually need these two if statements, nils are handled correctly everywhere, you can just do\r\n```suggestion\r\n\t\t\ttypedUserData := userData.GetData().GetPerType()[int32(pm.Partition().TaskType())]\r\n\t\t\tfor _, v := range typedUserData.GetDeploymentData().GetVersions() {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2114884739",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7816,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2114864370",
        "commented_code": "@@ -1258,7 +1259,76 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\t//nolint:staticcheck // SA1019 deprecated\n+\tdescrResp, err := pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req.ReportStats {\n+\t\ttotalStats := &taskqueuepb.TaskQueueStats{}\n+\t\tif ts := pm.GetCache(\"totalStats\"); ts != nil {\n+\t\t\t//revive:disable-next-line:unchecked-type-assertion\n+\t\t\ttotalStats = ts.(*taskqueuepb.TaskQueueStats)\n+\t\t} else {\n+\t\t\t// find number of partitions\n+\t\t\trootPartition, err := tqid.PartitionFromProto(req.GetTaskQueue(), request.GetNamespaceId(), req.GetTaskQueueType())\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttqConfig := newTaskQueueConfig(rootPartition.TaskQueue(), e.config, namespace.Name(req.Namespace))\n+\t\t\tnumPartitions := max(tqConfig.NumWritePartitions(), tqConfig.NumReadPartitions())\n+\n+\t\t\t// find all buildIds\n+\t\t\tvar buildIds []string\n+\t\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif userData != nil {\n+\t\t\t\tif typedUserData := userData.GetData().GetPerType()[int32(pm.Partition().TaskType())]; typedUserData != nil {\n+\t\t\t\t\tfor _, v := range typedUserData.GetDeploymentData().GetVersions() {",
        "comment_created_at": "2025-05-29T23:21:50+00:00",
        "comment_author": "stephanos",
        "comment_body": "I swear I saw a NPE there the other day because the type wasn't in the map. But I can't say for sure. I'll remove it and expect the tests to catch any issue.",
        "pr_file_module": null
      },
      {
        "comment_id": "2114894410",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7816,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2114864370",
        "commented_code": "@@ -1258,7 +1259,76 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\t//nolint:staticcheck // SA1019 deprecated\n+\tdescrResp, err := pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req.ReportStats {\n+\t\ttotalStats := &taskqueuepb.TaskQueueStats{}\n+\t\tif ts := pm.GetCache(\"totalStats\"); ts != nil {\n+\t\t\t//revive:disable-next-line:unchecked-type-assertion\n+\t\t\ttotalStats = ts.(*taskqueuepb.TaskQueueStats)\n+\t\t} else {\n+\t\t\t// find number of partitions\n+\t\t\trootPartition, err := tqid.PartitionFromProto(req.GetTaskQueue(), request.GetNamespaceId(), req.GetTaskQueueType())\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttqConfig := newTaskQueueConfig(rootPartition.TaskQueue(), e.config, namespace.Name(req.Namespace))\n+\t\t\tnumPartitions := max(tqConfig.NumWritePartitions(), tqConfig.NumReadPartitions())\n+\n+\t\t\t// find all buildIds\n+\t\t\tvar buildIds []string\n+\t\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif userData != nil {\n+\t\t\t\tif typedUserData := userData.GetData().GetPerType()[int32(pm.Partition().TaskType())]; typedUserData != nil {\n+\t\t\t\t\tfor _, v := range typedUserData.GetDeploymentData().GetVersions() {",
        "comment_created_at": "2025-05-29T23:35:28+00:00",
        "comment_author": "stephanos",
        "comment_body": "\ud83d\udc4d done",
        "pr_file_module": null
      },
      {
        "comment_id": "2114895336",
        "repo_full_name": "temporalio/temporal",
        "pr_number": 7816,
        "pr_file": "service/matching/matching_engine.go",
        "discussion_id": "2114864370",
        "commented_code": "@@ -1258,7 +1259,76 @@ func (e *matchingEngineImpl) DescribeTaskQueue(\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\t//nolint:staticcheck // SA1019 deprecated\n+\tdescrResp, err := pm.LegacyDescribeTaskQueue(req.GetIncludeTaskQueueStatus())\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req.ReportStats {\n+\t\ttotalStats := &taskqueuepb.TaskQueueStats{}\n+\t\tif ts := pm.GetCache(\"totalStats\"); ts != nil {\n+\t\t\t//revive:disable-next-line:unchecked-type-assertion\n+\t\t\ttotalStats = ts.(*taskqueuepb.TaskQueueStats)\n+\t\t} else {\n+\t\t\t// find number of partitions\n+\t\t\trootPartition, err := tqid.PartitionFromProto(req.GetTaskQueue(), request.GetNamespaceId(), req.GetTaskQueueType())\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttqConfig := newTaskQueueConfig(rootPartition.TaskQueue(), e.config, namespace.Name(req.Namespace))\n+\t\t\tnumPartitions := max(tqConfig.NumWritePartitions(), tqConfig.NumReadPartitions())\n+\n+\t\t\t// find all buildIds\n+\t\t\tvar buildIds []string\n+\t\t\tuserData, _, err := pm.GetUserDataManager().GetUserData()\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif userData != nil {\n+\t\t\t\tif typedUserData := userData.GetData().GetPerType()[int32(pm.Partition().TaskType())]; typedUserData != nil {\n+\t\t\t\t\tfor _, v := range typedUserData.GetDeploymentData().GetVersions() {",
        "comment_created_at": "2025-05-29T23:36:55+00:00",
        "comment_author": "dnr",
        "comment_body": "The map lookup would return nil.. `nil.GetDeploymentData().GetVersions()` is fine, it just returns a nil map and the range over it does nothing. If you did something like assign to a field that would npe though.",
        "pr_file_module": null
      }
    ]
  }
]