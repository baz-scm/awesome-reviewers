[
  {
    "discussion_id": "1237338947",
    "pr_number": 60727,
    "pr_file": "tensorflow/python/ops/numpy_ops/np_array_ops.py",
    "created_at": "2023-06-21T17:16:39+00:00",
    "commented_code": "arrays = asarray(arrays)\n     if axis == 0:\n       return arrays\n+    elif axis < -array_ops.rank(arrays) or axis >= array_ops.rank(arrays):",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1237338947",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 60727,
        "pr_file": "tensorflow/python/ops/numpy_ops/np_array_ops.py",
        "discussion_id": "1237338947",
        "commented_code": "@@ -1066,6 +1066,10 @@ def stack(arrays, axis=0):  # pylint: disable=missing-function-docstring\n     arrays = asarray(arrays)\n     if axis == 0:\n       return arrays\n+    elif axis < -array_ops.rank(arrays) or axis >= array_ops.rank(arrays):",
        "comment_created_at": "2023-06-21T17:16:39+00:00",
        "comment_author": "cantonios",
        "comment_body": "The issue is actually in `swapaxes`, which doesn't properly check that the axis is in the valid range.",
        "pr_file_module": null
      },
      {
        "comment_id": "1263394072",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 60727,
        "pr_file": "tensorflow/python/ops/numpy_ops/np_array_ops.py",
        "discussion_id": "1237338947",
        "commented_code": "@@ -1066,6 +1066,10 @@ def stack(arrays, axis=0):  # pylint: disable=missing-function-docstring\n     arrays = asarray(arrays)\n     if axis == 0:\n       return arrays\n+    elif axis < -array_ops.rank(arrays) or axis >= array_ops.rank(arrays):",
        "comment_created_at": "2023-07-14T07:23:10+00:00",
        "comment_author": "SuryanarayanaY",
        "comment_body": "@cantonios \r\n\r\nI have tested implementing range validation in swapaxes and it seems working fine. Attached [gist](https://colab.research.google.com/gist/SuryanarayanaY/81f511dd5eb0ecb4adf82e3dfd1260e1/60727_pr-r1.ipynb) for reference.\r\n\r\nValidation Code and location can be found below.\r\n\r\n```\r\ndef swapaxes(a, axis1, axis2):  # pylint: disable=missing-docstring\r\n  a = asarray(a) #\r\n  def adjust_axes(axes, rank):\r\n    def f(x):\r\n      if isinstance(x, int):\r\n        if x < 0:\r\n          x = x + rank\r\n      else:\r\n        x = array_ops.where_v2(x < 0, np_utils.add(x, a_rank), x)\r\n      return x\r\n    return nest.map_structure(f, axes)\r\n\r\n  if axis2 < -array_ops.rank(a) or axis2 >= array_ops.rank(a):\r\n    raise ValueError(\r\n        f\"Argument `axis` = {axis2} not in range \"\r\n                      f\"[{-array_ops.rank(a)}, {array_ops.rank(a)})\")  \r\n```\r\n\r\nIs it good to go implementing the validation code in `swapaxes` instead of `stack` ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1263950470",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 60727,
        "pr_file": "tensorflow/python/ops/numpy_ops/np_array_ops.py",
        "discussion_id": "1237338947",
        "commented_code": "@@ -1066,6 +1066,10 @@ def stack(arrays, axis=0):  # pylint: disable=missing-function-docstring\n     arrays = asarray(arrays)\n     if axis == 0:\n       return arrays\n+    elif axis < -array_ops.rank(arrays) or axis >= array_ops.rank(arrays):",
        "comment_created_at": "2023-07-14T17:02:13+00:00",
        "comment_author": "cantonios",
        "comment_body": "The check should be in `swapaxes`, which has the same issue.  It currently assumes that `axis` is always in the range `[-rank, rank)`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1283375269",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 60727,
        "pr_file": "tensorflow/python/ops/numpy_ops/np_array_ops.py",
        "discussion_id": "1237338947",
        "commented_code": "@@ -1066,6 +1066,10 @@ def stack(arrays, axis=0):  # pylint: disable=missing-function-docstring\n     arrays = asarray(arrays)\n     if axis == 0:\n       return arrays\n+    elif axis < -array_ops.rank(arrays) or axis >= array_ops.rank(arrays):",
        "comment_created_at": "2023-08-03T15:30:43+00:00",
        "comment_author": "cantonios",
        "comment_body": "Still waiting for the check to be made in `swapaxes`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "450989630",
    "pr_number": 40817,
    "pr_file": "tensorflow/python/eager/def_function.py",
    "created_at": "2020-07-07T16:23:54+00:00",
    "commented_code": "concrete._garbage_collector.release()  # pylint: disable=protected-access\n     return concrete\n \n+  def validate_annotations(self):\n+    \"\"\"Ensures type annotations and input_signature match.\n+\n+    Raises:\n+      ValueError when type annotations do not match input_signature.\n+    \"\"\"\n+    if self.input_signature is None:\n+      return\n+    for tensor in self.input_signature:\n+      if tensor.__class__ != tensor_spec.TensorSpec:\n+        return\n+    input_signature_dtypes = tuple(tensor.dtype for tensor\n+                                   in self.input_signature)\n+    if len(self.function_spec.arg_names) != len(input_signature_dtypes):\n+      return\n+\n+    arg_dtype_list = zip(self.function_spec.arg_names,\n+                         input_signature_dtypes)\n+    # A dict mapping from arg name to input signature dtype\n+    arg_to_dtype = dict(arg_dtype_list)\n+    type_annotations = self.function_spec.fullargspec.annotations\n+    for arg, annot in type_annotations.items():\n+      if (not hasattr(typing, \"_GenericAlias\") or\n+          not isinstance(annot, typing._GenericAlias)):\n+        return\n+      annotation_dtype = annot.__args__[0]\n+      input_signature_dtype = arg_to_dtype.get(arg)\n+      # Type annotation is not a Tensor\n+      if annot.__origin__ != ops.Tensor:\n+        return\n+      if annotation_dtype != input_signature_dtype.__class__:\n+        raise ValueError(\"Type annotation does not match input_signature\")",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "450989630",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 40817,
        "pr_file": "tensorflow/python/eager/def_function.py",
        "discussion_id": "450989630",
        "commented_code": "@@ -1168,6 +1170,39 @@ def f_sig(y):\n     concrete._garbage_collector.release()  # pylint: disable=protected-access\n     return concrete\n \n+  def validate_annotations(self):\n+    \"\"\"Ensures type annotations and input_signature match.\n+\n+    Raises:\n+      ValueError when type annotations do not match input_signature.\n+    \"\"\"\n+    if self.input_signature is None:\n+      return\n+    for tensor in self.input_signature:\n+      if tensor.__class__ != tensor_spec.TensorSpec:\n+        return\n+    input_signature_dtypes = tuple(tensor.dtype for tensor\n+                                   in self.input_signature)\n+    if len(self.function_spec.arg_names) != len(input_signature_dtypes):\n+      return\n+\n+    arg_dtype_list = zip(self.function_spec.arg_names,\n+                         input_signature_dtypes)\n+    # A dict mapping from arg name to input signature dtype\n+    arg_to_dtype = dict(arg_dtype_list)\n+    type_annotations = self.function_spec.fullargspec.annotations\n+    for arg, annot in type_annotations.items():\n+      if (not hasattr(typing, \"_GenericAlias\") or\n+          not isinstance(annot, typing._GenericAlias)):\n+        return\n+      annotation_dtype = annot.__args__[0]\n+      input_signature_dtype = arg_to_dtype.get(arg)\n+      # Type annotation is not a Tensor\n+      if annot.__origin__ != ops.Tensor:\n+        return\n+      if annotation_dtype != input_signature_dtype.__class__:\n+        raise ValueError(\"Type annotation does not match input_signature\")",
        "comment_created_at": "2020-07-07T16:23:54+00:00",
        "comment_author": "mdanatg",
        "comment_body": "Let's make sure the error message is informative and actionable:\r\n* include the name of the argument\r\n* what was the annotated dtype\r\n* what is the expected (signature) dtype",
        "pr_file_module": null
      },
      {
        "comment_id": "451074357",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 40817,
        "pr_file": "tensorflow/python/eager/def_function.py",
        "discussion_id": "450989630",
        "commented_code": "@@ -1168,6 +1170,39 @@ def f_sig(y):\n     concrete._garbage_collector.release()  # pylint: disable=protected-access\n     return concrete\n \n+  def validate_annotations(self):\n+    \"\"\"Ensures type annotations and input_signature match.\n+\n+    Raises:\n+      ValueError when type annotations do not match input_signature.\n+    \"\"\"\n+    if self.input_signature is None:\n+      return\n+    for tensor in self.input_signature:\n+      if tensor.__class__ != tensor_spec.TensorSpec:\n+        return\n+    input_signature_dtypes = tuple(tensor.dtype for tensor\n+                                   in self.input_signature)\n+    if len(self.function_spec.arg_names) != len(input_signature_dtypes):\n+      return\n+\n+    arg_dtype_list = zip(self.function_spec.arg_names,\n+                         input_signature_dtypes)\n+    # A dict mapping from arg name to input signature dtype\n+    arg_to_dtype = dict(arg_dtype_list)\n+    type_annotations = self.function_spec.fullargspec.annotations\n+    for arg, annot in type_annotations.items():\n+      if (not hasattr(typing, \"_GenericAlias\") or\n+          not isinstance(annot, typing._GenericAlias)):\n+        return\n+      annotation_dtype = annot.__args__[0]\n+      input_signature_dtype = arg_to_dtype.get(arg)\n+      # Type annotation is not a Tensor\n+      if annot.__origin__ != ops.Tensor:\n+        return\n+      if annotation_dtype != input_signature_dtype.__class__:\n+        raise ValueError(\"Type annotation does not match input_signature\")",
        "comment_created_at": "2020-07-07T18:52:08+00:00",
        "comment_author": "rahul-kamat",
        "comment_body": "Sounds good!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1414036198",
    "pr_number": 62542,
    "pr_file": "configure.py",
    "created_at": "2023-12-04T15:05:44+00:00",
    "commented_code": "default_python_bin_path = sys.executable\n   ask_python_bin_path = ('Please specify the location of python. [Default is '\n                          '{}]: ').format(default_python_bin_path)\n-  while True:\n-    python_bin_path = get_from_env_or_user_or_default(environ_cp,\n-                                                      'PYTHON_BIN_PATH',\n-                                                      ask_python_bin_path,\n-                                                      default_python_bin_path)\n-    # Check if the path is valid\n-    if os.path.isfile(python_bin_path) and os.access(python_bin_path, os.X_OK):\n-      break\n-    elif not os.path.exists(python_bin_path):\n-      print('Invalid python path: {} cannot be found.'.format(python_bin_path))\n-    else:\n-      print('{} is not executable.  Is it the python binary?'.format(\n-          python_bin_path))\n-    environ_cp['PYTHON_BIN_PATH'] = ''\n-\n+  python_bin_path = os.environ.get('PYTHON_BIN_PATH') or default_python_bin_path\n+  python_bin_path = shutil.which(python_bin_path) # Looking for the path in the system\n+  try:\n+    if not os.path.isfile(python_bin_path):\n+      if os.access(python_bin_path, os.X_OK):\n+        raise FileNotFoundError('The python path {} is not valid.'.format(python_bin_path))",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1414036198",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 62542,
        "pr_file": "configure.py",
        "discussion_id": "1414036198",
        "commented_code": "@@ -189,21 +190,19 @@ def setup_python(environ_cp):\n   default_python_bin_path = sys.executable\n   ask_python_bin_path = ('Please specify the location of python. [Default is '\n                          '{}]: ').format(default_python_bin_path)\n-  while True:\n-    python_bin_path = get_from_env_or_user_or_default(environ_cp,\n-                                                      'PYTHON_BIN_PATH',\n-                                                      ask_python_bin_path,\n-                                                      default_python_bin_path)\n-    # Check if the path is valid\n-    if os.path.isfile(python_bin_path) and os.access(python_bin_path, os.X_OK):\n-      break\n-    elif not os.path.exists(python_bin_path):\n-      print('Invalid python path: {} cannot be found.'.format(python_bin_path))\n-    else:\n-      print('{} is not executable.  Is it the python binary?'.format(\n-          python_bin_path))\n-    environ_cp['PYTHON_BIN_PATH'] = ''\n-\n+  python_bin_path = os.environ.get('PYTHON_BIN_PATH') or default_python_bin_path\n+  python_bin_path = shutil.which(python_bin_path) # Looking for the path in the system\n+  try:\n+    if not os.path.isfile(python_bin_path):\n+      if os.access(python_bin_path, os.X_OK):\n+        raise FileNotFoundError('The python path {} is not valid.'.format(python_bin_path))",
        "comment_created_at": "2023-12-04T15:05:44+00:00",
        "comment_author": "mihaimaruseac",
        "comment_body": "```suggestion\r\n        raise FileNotFoundError(f'The python path {python_bin_path} is not valid.')\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1414048388",
    "pr_number": 62542,
    "pr_file": "configure.py",
    "created_at": "2023-12-04T15:14:43+00:00",
    "commented_code": "default_python_bin_path = sys.executable\n   ask_python_bin_path = ('Please specify the location of python. [Default is '\n                          '{}]: ').format(default_python_bin_path)\n-  while True:\n-    python_bin_path = get_from_env_or_user_or_default(environ_cp,\n-                                                      'PYTHON_BIN_PATH',\n-                                                      ask_python_bin_path,\n-                                                      default_python_bin_path)\n-    # Check if the path is valid\n-    if os.path.isfile(python_bin_path) and os.access(python_bin_path, os.X_OK):\n-      break\n-    elif not os.path.exists(python_bin_path):\n-      print('Invalid python path: {} cannot be found.'.format(python_bin_path))\n-    else:\n-      print('{} is not executable.  Is it the python binary?'.format(\n-          python_bin_path))\n-    environ_cp['PYTHON_BIN_PATH'] = ''\n-\n+  python_bin_path = os.environ.get('PYTHON_BIN_PATH') or default_python_bin_path\n+  python_bin_path = shutil.which(python_bin_path) # Looking for the path in the system\n+  try:\n+    if not os.path.isfile(python_bin_path):\n+      if os.access(python_bin_path, os.X_OK):\n+        raise FileNotFoundError(f'The python path {python_bin_path} is not valid.')",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1414048388",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 62542,
        "pr_file": "configure.py",
        "discussion_id": "1414048388",
        "commented_code": "@@ -189,21 +190,19 @@ def setup_python(environ_cp):\n   default_python_bin_path = sys.executable\n   ask_python_bin_path = ('Please specify the location of python. [Default is '\n                          '{}]: ').format(default_python_bin_path)\n-  while True:\n-    python_bin_path = get_from_env_or_user_or_default(environ_cp,\n-                                                      'PYTHON_BIN_PATH',\n-                                                      ask_python_bin_path,\n-                                                      default_python_bin_path)\n-    # Check if the path is valid\n-    if os.path.isfile(python_bin_path) and os.access(python_bin_path, os.X_OK):\n-      break\n-    elif not os.path.exists(python_bin_path):\n-      print('Invalid python path: {} cannot be found.'.format(python_bin_path))\n-    else:\n-      print('{} is not executable.  Is it the python binary?'.format(\n-          python_bin_path))\n-    environ_cp['PYTHON_BIN_PATH'] = ''\n-\n+  python_bin_path = os.environ.get('PYTHON_BIN_PATH') or default_python_bin_path\n+  python_bin_path = shutil.which(python_bin_path) # Looking for the path in the system\n+  try:\n+    if not os.path.isfile(python_bin_path):\n+      if os.access(python_bin_path, os.X_OK):\n+        raise FileNotFoundError(f'The python path {python_bin_path} is not valid.')",
        "comment_created_at": "2023-12-04T15:14:43+00:00",
        "comment_author": "mihaimaruseac",
        "comment_body": "```suggestion\r\n        raise FileNotFoundError(f'Python path {python_bin_path} is invalid.')\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1414048725",
    "pr_number": 62542,
    "pr_file": "configure.py",
    "created_at": "2023-12-04T15:14:59+00:00",
    "commented_code": "default_python_bin_path = sys.executable\n   ask_python_bin_path = ('Please specify the location of python. [Default is '\n                          '{}]: ').format(default_python_bin_path)\n-  while True:\n-    python_bin_path = get_from_env_or_user_or_default(environ_cp,\n-                                                      'PYTHON_BIN_PATH',\n-                                                      ask_python_bin_path,\n-                                                      default_python_bin_path)\n-    # Check if the path is valid\n-    if os.path.isfile(python_bin_path) and os.access(python_bin_path, os.X_OK):\n-      break\n-    elif not os.path.exists(python_bin_path):\n-      print('Invalid python path: {} cannot be found.'.format(python_bin_path))\n-    else:\n-      print('{} is not executable.  Is it the python binary?'.format(\n-          python_bin_path))\n-    environ_cp['PYTHON_BIN_PATH'] = ''\n-\n+  python_bin_path = os.environ.get('PYTHON_BIN_PATH') or default_python_bin_path\n+  python_bin_path = shutil.which(python_bin_path) # Looking for the path in the system\n+  try:\n+    if not os.path.isfile(python_bin_path):\n+      if os.access(python_bin_path, os.X_OK):\n+        raise FileNotFoundError(f'The python path {python_bin_path} is not valid.')\n+    python_version = get_python_major_version(python_bin_path)\n+    if python_version != '3':\n+      raise ValueError(f'Python found at {python_bin_path} is not version 3. Please update.')",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1414048725",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 62542,
        "pr_file": "configure.py",
        "discussion_id": "1414048725",
        "commented_code": "@@ -189,21 +190,19 @@ def setup_python(environ_cp):\n   default_python_bin_path = sys.executable\n   ask_python_bin_path = ('Please specify the location of python. [Default is '\n                          '{}]: ').format(default_python_bin_path)\n-  while True:\n-    python_bin_path = get_from_env_or_user_or_default(environ_cp,\n-                                                      'PYTHON_BIN_PATH',\n-                                                      ask_python_bin_path,\n-                                                      default_python_bin_path)\n-    # Check if the path is valid\n-    if os.path.isfile(python_bin_path) and os.access(python_bin_path, os.X_OK):\n-      break\n-    elif not os.path.exists(python_bin_path):\n-      print('Invalid python path: {} cannot be found.'.format(python_bin_path))\n-    else:\n-      print('{} is not executable.  Is it the python binary?'.format(\n-          python_bin_path))\n-    environ_cp['PYTHON_BIN_PATH'] = ''\n-\n+  python_bin_path = os.environ.get('PYTHON_BIN_PATH') or default_python_bin_path\n+  python_bin_path = shutil.which(python_bin_path) # Looking for the path in the system\n+  try:\n+    if not os.path.isfile(python_bin_path):\n+      if os.access(python_bin_path, os.X_OK):\n+        raise FileNotFoundError(f'The python path {python_bin_path} is not valid.')\n+    python_version = get_python_major_version(python_bin_path)\n+    if python_version != '3':\n+      raise ValueError(f'Python found at {python_bin_path} is not version 3. Please update.')",
        "comment_created_at": "2023-12-04T15:14:59+00:00",
        "comment_author": "mihaimaruseac",
        "comment_body": "```suggestion\r\n      raise ValueError(f'Python from {python_bin_path} is not version 3.')\r\n```",
        "pr_file_module": null
      }
    ]
  }
]