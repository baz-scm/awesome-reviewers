[
  {
    "discussion_id": "1107398696",
    "pr_number": 59313,
    "pr_file": "tensorflow/python/ops/image_ops_impl.py",
    "created_at": "2023-02-15T16:58:09+00:00",
    "commented_code": "\"\"\"\n   image = ops.convert_to_tensor(image, name='image')\n   dtype = dtypes.as_dtype(dtype)\n-  if not dtype.is_floating and not dtype.is_integer:\n-    raise AttributeError('dtype must be either floating point or integer')\n+  if dtype.is_complex or image.dtype.is_complex:",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1107398696",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 59313,
        "pr_file": "tensorflow/python/ops/image_ops_impl.py",
        "discussion_id": "1107398696",
        "commented_code": "@@ -2488,8 +2488,8 @@ def convert_image_dtype(image, dtype, saturate=False, name=None):\n   \"\"\"\n   image = ops.convert_to_tensor(image, name='image')\n   dtype = dtypes.as_dtype(dtype)\n-  if not dtype.is_floating and not dtype.is_integer:\n-    raise AttributeError('dtype must be either floating point or integer')\n+  if dtype.is_complex or image.dtype.is_complex:",
        "comment_created_at": "2023-02-15T16:58:09+00:00",
        "comment_author": "cantonios",
        "comment_body": "This doesn't capture the previous conditions.\r\nPreviously, this would fail for:\r\n```\r\n[tf.bool, tf.complex128, tf.complex64, tf.qint16, tf.qint32, tf.qint8, tf.quint16, tf.quint8, tf.resource, tf.string, tf.variant]\r\n```\r\nNote that in particular, `tf.complex64/128` are not `.is_floating`, so is already included.  The only thing missing is checking the same conditions for `image.dtype`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1114722794",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 59313,
        "pr_file": "tensorflow/python/ops/image_ops_impl.py",
        "discussion_id": "1107398696",
        "commented_code": "@@ -2488,8 +2488,8 @@ def convert_image_dtype(image, dtype, saturate=False, name=None):\n   \"\"\"\n   image = ops.convert_to_tensor(image, name='image')\n   dtype = dtypes.as_dtype(dtype)\n-  if not dtype.is_floating and not dtype.is_integer:\n-    raise AttributeError('dtype must be either floating point or integer')\n+  if dtype.is_complex or image.dtype.is_complex:",
        "comment_created_at": "2023-02-22T17:54:28+00:00",
        "comment_author": "SuryanarayanaY",
        "comment_body": "In this case adding the below code to the original code shall validate the image dtype.\r\n```\r\nif not image.dtype.is_floating and not image.dtype.is_integer:\r\n    raise AttributeError('Image dtype must be either floating point or integer')\r\n```\r\n(Or)\r\n \r\nTo validate both image dtype and output dtype we can use single block as like below by deleting lines 2491 & 2492 from original code.\r\n\r\n```\r\nif (not dtype.is_floating and not dtype.is_integer) or (not image_dtype.is_floating and not image_dtype.is_integer):\r\n        raise AttributeError('data type must be either floating point or integer')\r\n```\r\n\r\nPlease refer to attached [gist](https://colab.research.google.com/gist/SuryanarayanaY/1eed84e157e6b1a29753b654f23fb21b/tf-image-convert_image_dtype-testcase-58699-_r2.ipynb).",
        "pr_file_module": null
      },
      {
        "comment_id": "1114828460",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 59313,
        "pr_file": "tensorflow/python/ops/image_ops_impl.py",
        "discussion_id": "1107398696",
        "commented_code": "@@ -2488,8 +2488,8 @@ def convert_image_dtype(image, dtype, saturate=False, name=None):\n   \"\"\"\n   image = ops.convert_to_tensor(image, name='image')\n   dtype = dtypes.as_dtype(dtype)\n-  if not dtype.is_floating and not dtype.is_integer:\n-    raise AttributeError('dtype must be either floating point or integer')\n+  if dtype.is_complex or image.dtype.is_complex:",
        "comment_created_at": "2023-02-22T18:58:01+00:00",
        "comment_author": "cantonios",
        "comment_body": "Correct",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1260006456",
    "pr_number": 61242,
    "pr_file": "tensorflow/python/ops/clip_ops.py",
    "created_at": "2023-07-11T16:51:24+00:00",
    "commented_code": "values = ops.convert_to_tensor(\n         t.values if isinstance(t, indexed_slices.IndexedSlices) else t,\n         name=\"t\")\n+    if clip_norm < 0:",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1260006456",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 61242,
        "pr_file": "tensorflow/python/ops/clip_ops.py",
        "discussion_id": "1260006456",
        "commented_code": "@@ -212,6 +212,8 @@ def clip_by_norm(t, clip_norm, axes=None, name=None):\n     values = ops.convert_to_tensor(\n         t.values if isinstance(t, indexed_slices.IndexedSlices) else t,\n         name=\"t\")\n+    if clip_norm < 0:",
        "comment_created_at": "2023-07-11T16:51:24+00:00",
        "comment_author": "cantonios",
        "comment_body": "This won't work if `clip_norm` is a tensor.\r\n\r\nI think your best option is to set\r\n```\r\nclip_norm = math_ops.maximum(clip_norm, 0)\r\n```\r\nto force it to be positive.",
        "pr_file_module": null
      },
      {
        "comment_id": "1261143376",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 61242,
        "pr_file": "tensorflow/python/ops/clip_ops.py",
        "discussion_id": "1260006456",
        "commented_code": "@@ -212,6 +212,8 @@ def clip_by_norm(t, clip_norm, axes=None, name=None):\n     values = ops.convert_to_tensor(\n         t.values if isinstance(t, indexed_slices.IndexedSlices) else t,\n         name=\"t\")\n+    if clip_norm < 0:",
        "comment_created_at": "2023-07-12T12:58:19+00:00",
        "comment_author": "SuryanarayanaY",
        "comment_body": "@cantonios \r\nThanks for the inputs. Actually I have tested with a Tensor also by passing `clip_norm=tf.constant(-10.0)` and the proposed solution still working and same can be referred in the gist attached in above [comment](https://github.com/tensorflow/tensorflow/pull/61242#issue-1798546174).\r\n\r\nI have also tested with `tf.function` and the proposed solution still working and raising intended error.Please refer [gist2](https://colab.research.google.com/gist/SuryanarayanaY/40fd4154a5835c65c5493407cd2f9ef8/61158_errors-for-code-fix-2.ipynb).\r\n\r\nfor example below code outputs bool Tensor and hence it seems working for this case:\r\n\r\n```\r\nclip_norm=tf.constant(-10.0)\r\nprint(clip_norm <0)\r\n\r\n#output:tf.Tensor(True, shape=(), dtype=bool)\r\n```\r\nI am not sure though which cases it may fail.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1261375127",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 61242,
        "pr_file": "tensorflow/python/ops/clip_ops.py",
        "discussion_id": "1260006456",
        "commented_code": "@@ -212,6 +212,8 @@ def clip_by_norm(t, clip_norm, axes=None, name=None):\n     values = ops.convert_to_tensor(\n         t.values if isinstance(t, indexed_slices.IndexedSlices) else t,\n         name=\"t\")\n+    if clip_norm < 0:",
        "comment_created_at": "2023-07-12T15:44:37+00:00",
        "comment_author": "cantonios",
        "comment_body": "That's because you're giving it constant tensors, so in the `tf.function` can extract the constant value during tracing.  If it was a variable tensor, it would fail.\r\n\r\nFor example, the following works fine with the original `tf.clip_by_norm`:\r\n```python\r\n@tf.function\r\ndef tf_clip_by_norm(t, clip_norm, axes=[1]):\r\n  return tf.clip_by_norm(t, clip_norm=clip_norm, axes=[1])\r\n\r\n# Current tf.clip_by_norm:\r\nclip = tf_clip_by_norm.get_concrete_function(tf.TensorSpec(shape=[3, 3], dtype=tf.float32), tf.TensorSpec(shape=[], dtype=tf.float32), tf.TensorSpec(shape=[], dtype=tf.int32))\r\nprint(clip(tf.ones([3, 3]), tf.constant(0.5), tf.constant(1)))\r\n```\r\n\r\nBut with your modification, it incorrectly throws the `ValueError` immediately when trying to get the concrete function:\r\n```python\r\nclip = clip_by_norm.get_concrete_function(tf.TensorSpec(shape=[3, 3], dtype=tf.float32), tf.TensorSpec(shape=[], dtype=tf.float32), tf.TensorSpec(shape=[], dtype=tf.int32))\r\n```\r\n```python\r\nValueError: in user code:\r\n\r\n    File \"<ipython-input-9-abfa95055a32>\", line 22, in clip_by_norm  *\r\n        raise ValueError('clip_norm should be a 0-D (scalar) Tensor > 0')\r\n\r\n    ValueError: clip_norm should be a 0-D (scalar) Tensor > 0\r\n```\r\neven though we haven't actually passed in any values.",
        "pr_file_module": null
      },
      {
        "comment_id": "1265370816",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 61242,
        "pr_file": "tensorflow/python/ops/clip_ops.py",
        "discussion_id": "1260006456",
        "commented_code": "@@ -212,6 +212,8 @@ def clip_by_norm(t, clip_norm, axes=None, name=None):\n     values = ops.convert_to_tensor(\n         t.values if isinstance(t, indexed_slices.IndexedSlices) else t,\n         name=\"t\")\n+    if clip_norm < 0:",
        "comment_created_at": "2023-07-17T13:38:30+00:00",
        "comment_author": "SuryanarayanaY",
        "comment_body": "@cantonios ,\r\n\r\nThanks for clarification. Then I will go with converting -ve values to 0 as suggested using:\r\n\r\n`clip_norm = math_ops.maximum(clip_norm, 0)\r\n`\r\n\r\nAlso I would like to add a note of same in the Documentation to make the users aware of this.\r\n\r\nThanks",
        "pr_file_module": null
      },
      {
        "comment_id": "1265639373",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 61242,
        "pr_file": "tensorflow/python/ops/clip_ops.py",
        "discussion_id": "1260006456",
        "commented_code": "@@ -212,6 +212,8 @@ def clip_by_norm(t, clip_norm, axes=None, name=None):\n     values = ops.convert_to_tensor(\n         t.values if isinstance(t, indexed_slices.IndexedSlices) else t,\n         name=\"t\")\n+    if clip_norm < 0:",
        "comment_created_at": "2023-07-17T16:46:41+00:00",
        "comment_author": "cantonios",
        "comment_body": "Yes, please update the documentation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1265643255",
    "pr_number": 61242,
    "pr_file": "tensorflow/python/ops/clip_ops.py",
    "created_at": "2023-07-17T16:50:13+00:00",
    "commented_code": "Args:\n     t: A `Tensor` or `IndexedSlices`.  This must be a floating point type.\n     clip_norm: A 0-D (scalar) `Tensor` > 0. A maximum clipping value, also\n-      floating point\n+      floating point.\n+      Note: If clip_norm given as a negative value then it will be converted",
    "repo_full_name": "tensorflow/tensorflow",
    "discussion_comments": [
      {
        "comment_id": "1265643255",
        "repo_full_name": "tensorflow/tensorflow",
        "pr_number": 61242,
        "pr_file": "tensorflow/python/ops/clip_ops.py",
        "discussion_id": "1265643255",
        "commented_code": "@@ -194,7 +194,9 @@ def clip_by_norm(t, clip_norm, axes=None, name=None):\n   Args:\n     t: A `Tensor` or `IndexedSlices`.  This must be a floating point type.\n     clip_norm: A 0-D (scalar) `Tensor` > 0. A maximum clipping value, also\n-      floating point\n+      floating point.\n+      Note: If clip_norm given as a negative value then it will be converted",
        "comment_created_at": "2023-07-17T16:50:13+00:00",
        "comment_author": "cantonios",
        "comment_body": "- clip_norm given -> clip_norm is given\r\n- Zero -> zero\r\n- internally and exception will not be raised here -> without raising an exception\r\n\r\nAlternatively, just say:\r\n> If a negative clip_norm is provided, it will be treated as zero.\r\n",
        "pr_file_module": null
      }
    ]
  }
]