[
  {
    "discussion_id": "2205622194",
    "pr_number": 19130,
    "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
    "created_at": "2025-07-14T19:09:45+00:00",
    "commented_code": "// Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2205622194",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205622194",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();",
        "comment_created_at": "2025-07-14T19:09:45+00:00",
        "comment_author": "lhecker",
        "comment_body": "BTW I wonder if we should avoid this Clear/Append code. Is `Inlines` observable? If so, then every call raises an event after all. Wasn't there some kind of ReplaceAll in WinRT?",
        "pr_file_module": null
      },
      {
        "comment_id": "2205622836",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205622194",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();",
        "comment_created_at": "2025-07-14T19:10:08+00:00",
        "comment_author": "DHowett",
        "comment_body": "oh, actually, this is to handle the case where the text is itself emptied",
        "pr_file_module": null
      },
      {
        "comment_id": "2205626628",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205622194",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();",
        "comment_created_at": "2025-07-14T19:12:30+00:00",
        "comment_author": "lhecker",
        "comment_body": "No, I mean would it make sense to create a `std::vector` locally from the runs first and then do a single call to `ReplaceAll`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2205626668",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205622194",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();",
        "comment_created_at": "2025-07-14T19:12:32+00:00",
        "comment_author": "DHowett",
        "comment_body": "and, yes, `InlineCollection` supports a `ReplaceAll`. I can use it if you'd like.",
        "pr_file_module": null
      },
      {
        "comment_id": "2205648425",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205622194",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();",
        "comment_created_at": "2025-07-14T19:27:00+00:00",
        "comment_author": "lhecker",
        "comment_body": "At least in WinUI 1.4 there seems to be some internal lazy logic, so this may be unnecessary: https://github.com/microsoft/microsoft-ui-xaml/blob/winui3/release/1.4-stable/dxaml/xcp/core/text/TextBlock/InlineCollection.cpp#L38",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1314923398",
    "pr_number": 15924,
    "pr_file": "src/cascadia/TerminalApp/TabManagement.cpp",
    "created_at": "2023-09-04T13:02:21+00:00",
    "commented_code": "// Arguments:\r\n     // - sender: the control that originated this event (TabViewItem)\r\n     // - eventArgs: the event's constituent arguments\r\n-    void TerminalPage::_OnTabClick(const IInspectable& sender, const Windows::UI::Xaml::Input::PointerRoutedEventArgs& eventArgs)\r\n+    void TerminalPage::_OnPointerPressed(const IInspectable& sender, const Windows::UI::Xaml::Input::PointerRoutedEventArgs& eventArgs)\r\n     {\r\n         if (eventArgs.GetCurrentPoint(*this).Properties().IsMiddleButtonPressed())",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1314923398",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 15924,
        "pr_file": "src/cascadia/TerminalApp/TabManagement.cpp",
        "discussion_id": "1314923398",
        "commented_code": "@@ -891,19 +894,72 @@ namespace winrt::TerminalApp::implementation\n     // Arguments:\r\n     // - sender: the control that originated this event (TabViewItem)\r\n     // - eventArgs: the event's constituent arguments\r\n-    void TerminalPage::_OnTabClick(const IInspectable& sender, const Windows::UI::Xaml::Input::PointerRoutedEventArgs& eventArgs)\r\n+    void TerminalPage::_OnPointerPressed(const IInspectable& sender, const Windows::UI::Xaml::Input::PointerRoutedEventArgs& eventArgs)\r\n     {\r\n         if (eventArgs.GetCurrentPoint(*this).Properties().IsMiddleButtonPressed())\r",
        "comment_created_at": "2023-09-04T13:02:21+00:00",
        "comment_author": "lhecker",
        "comment_body": "BTW shouldn't we pass `sender` instead of `*this` if anything? The documentation makes it sound like we can also just pass `nullptr` btw: https://learn.microsoft.com/en-us/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.input.pointerroutedeventargs.getcurrentpoint",
        "pr_file_module": null
      },
      {
        "comment_id": "1349574555",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 15924,
        "pr_file": "src/cascadia/TerminalApp/TabManagement.cpp",
        "discussion_id": "1314923398",
        "commented_code": "@@ -891,19 +894,72 @@ namespace winrt::TerminalApp::implementation\n     // Arguments:\r\n     // - sender: the control that originated this event (TabViewItem)\r\n     // - eventArgs: the event's constituent arguments\r\n-    void TerminalPage::_OnTabClick(const IInspectable& sender, const Windows::UI::Xaml::Input::PointerRoutedEventArgs& eventArgs)\r\n+    void TerminalPage::_OnPointerPressed(const IInspectable& sender, const Windows::UI::Xaml::Input::PointerRoutedEventArgs& eventArgs)\r\n     {\r\n         if (eventArgs.GetCurrentPoint(*this).Properties().IsMiddleButtonPressed())\r",
        "comment_created_at": "2023-10-07T21:08:23+00:00",
        "comment_author": "kasper93",
        "comment_body": "This was preexisting code, so I didn't think about it, but you are right `nullptr` seems to be correct in our case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1976447628",
    "pr_number": 18639,
    "pr_file": "src/cascadia/TerminalSettingsModel/PowershellInstallationProfileGenerator.cpp",
    "created_at": "2025-03-01T16:27:14+00:00",
    "commented_code": "+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+\r\n+#include \"PowershellInstallationProfileGenerator.h\"\r\n+#include \"DynamicProfileUtils.h\"\r\n+\r\n+#include <LibraryResources.h>\r\n+\r\n+static constexpr std::wstring_view POWERSHELL_ICON{ L\"ms-appx:///ProfileIcons/pwsh.png\" };\r\n+static constexpr std::wstring_view POWERSHELL_ICON_64{ L\"ms-appx:///ProfileIcons/Powershell_black_64.png\" };\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Model\r\n+{\r\n+    std::wstring_view PowershellInstallationProfileGenerator::Namespace{ L\"Windows.Terminal.InstallPowerShell\" };\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetNamespace() const noexcept\r\n+    {\r\n+        return Namespace;\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetDisplayName() const noexcept\r\n+    {\r\n+        return RS_(L\"PowerShellInstallationProfileGeneratorDisplayName\");\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetIcon() const noexcept\r\n+    {\r\n+        return POWERSHELL_ICON_64;\r\n+    }\r\n+\r\n+    void PowershellInstallationProfileGenerator::GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles)\r\n+    {\r\n+        auto profile{ CreateDynamicProfile(RS_(L\"PowerShellInstallationProfileName\")) };\r\n+        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1976447628",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18639,
        "pr_file": "src/cascadia/TerminalSettingsModel/PowershellInstallationProfileGenerator.cpp",
        "discussion_id": "1976447628",
        "commented_code": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+\r\n+#include \"PowershellInstallationProfileGenerator.h\"\r\n+#include \"DynamicProfileUtils.h\"\r\n+\r\n+#include <LibraryResources.h>\r\n+\r\n+static constexpr std::wstring_view POWERSHELL_ICON{ L\"ms-appx:///ProfileIcons/pwsh.png\" };\r\n+static constexpr std::wstring_view POWERSHELL_ICON_64{ L\"ms-appx:///ProfileIcons/Powershell_black_64.png\" };\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Model\r\n+{\r\n+    std::wstring_view PowershellInstallationProfileGenerator::Namespace{ L\"Windows.Terminal.InstallPowerShell\" };\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetNamespace() const noexcept\r\n+    {\r\n+        return Namespace;\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetDisplayName() const noexcept\r\n+    {\r\n+        return RS_(L\"PowerShellInstallationProfileGeneratorDisplayName\");\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetIcon() const noexcept\r\n+    {\r\n+        return POWERSHELL_ICON_64;\r\n+    }\r\n+\r\n+    void PowershellInstallationProfileGenerator::GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles)\r\n+    {\r\n+        auto profile{ CreateDynamicProfile(RS_(L\"PowerShellInstallationProfileName\")) };\r\n+        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });\r",
        "comment_created_at": "2025-03-01T16:27:14+00:00",
        "comment_author": "mdanish-kh",
        "comment_body": "```suggestion\r\n        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell --source winget & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });\r\n```\r\n\r\nnit: If this is done on a machine where WinGet hasn't been invoked before, the user will be prompted to accept `msstore` agreements first which don't seem relevant for this use case. Suggest to add explicit source argument so that user isn't prompted",
        "pr_file_module": null
      },
      {
        "comment_id": "1976449535",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18639,
        "pr_file": "src/cascadia/TerminalSettingsModel/PowershellInstallationProfileGenerator.cpp",
        "discussion_id": "1976447628",
        "commented_code": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+\r\n+#include \"PowershellInstallationProfileGenerator.h\"\r\n+#include \"DynamicProfileUtils.h\"\r\n+\r\n+#include <LibraryResources.h>\r\n+\r\n+static constexpr std::wstring_view POWERSHELL_ICON{ L\"ms-appx:///ProfileIcons/pwsh.png\" };\r\n+static constexpr std::wstring_view POWERSHELL_ICON_64{ L\"ms-appx:///ProfileIcons/Powershell_black_64.png\" };\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Model\r\n+{\r\n+    std::wstring_view PowershellInstallationProfileGenerator::Namespace{ L\"Windows.Terminal.InstallPowerShell\" };\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetNamespace() const noexcept\r\n+    {\r\n+        return Namespace;\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetDisplayName() const noexcept\r\n+    {\r\n+        return RS_(L\"PowerShellInstallationProfileGeneratorDisplayName\");\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetIcon() const noexcept\r\n+    {\r\n+        return POWERSHELL_ICON_64;\r\n+    }\r\n+\r\n+    void PowershellInstallationProfileGenerator::GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles)\r\n+    {\r\n+        auto profile{ CreateDynamicProfile(RS_(L\"PowerShellInstallationProfileName\")) };\r\n+        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });\r",
        "comment_created_at": "2025-03-01T16:35:20+00:00",
        "comment_author": "mdanish-kh",
        "comment_body": "![image](https://github.com/user-attachments/assets/daefbcf4-5f27-453b-80f0-4d9af2473046)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1976489479",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18639,
        "pr_file": "src/cascadia/TerminalSettingsModel/PowershellInstallationProfileGenerator.cpp",
        "discussion_id": "1976447628",
        "commented_code": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+\r\n+#include \"PowershellInstallationProfileGenerator.h\"\r\n+#include \"DynamicProfileUtils.h\"\r\n+\r\n+#include <LibraryResources.h>\r\n+\r\n+static constexpr std::wstring_view POWERSHELL_ICON{ L\"ms-appx:///ProfileIcons/pwsh.png\" };\r\n+static constexpr std::wstring_view POWERSHELL_ICON_64{ L\"ms-appx:///ProfileIcons/Powershell_black_64.png\" };\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Model\r\n+{\r\n+    std::wstring_view PowershellInstallationProfileGenerator::Namespace{ L\"Windows.Terminal.InstallPowerShell\" };\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetNamespace() const noexcept\r\n+    {\r\n+        return Namespace;\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetDisplayName() const noexcept\r\n+    {\r\n+        return RS_(L\"PowerShellInstallationProfileGeneratorDisplayName\");\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetIcon() const noexcept\r\n+    {\r\n+        return POWERSHELL_ICON_64;\r\n+    }\r\n+\r\n+    void PowershellInstallationProfileGenerator::GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles)\r\n+    {\r\n+        auto profile{ CreateDynamicProfile(RS_(L\"PowerShellInstallationProfileName\")) };\r\n+        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });\r",
        "comment_created_at": "2025-03-01T20:49:13+00:00",
        "comment_author": "denelon",
        "comment_body": "The Terminal shouldn't pass explicit agreements for the msstore source. That's something an IT administrator can do for their enterprise users, or an individual can do on their own, but applications shouldn't pass that on behalf of an end user. Just an FYI :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1976494198",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18639,
        "pr_file": "src/cascadia/TerminalSettingsModel/PowershellInstallationProfileGenerator.cpp",
        "discussion_id": "1976447628",
        "commented_code": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+\r\n+#include \"PowershellInstallationProfileGenerator.h\"\r\n+#include \"DynamicProfileUtils.h\"\r\n+\r\n+#include <LibraryResources.h>\r\n+\r\n+static constexpr std::wstring_view POWERSHELL_ICON{ L\"ms-appx:///ProfileIcons/pwsh.png\" };\r\n+static constexpr std::wstring_view POWERSHELL_ICON_64{ L\"ms-appx:///ProfileIcons/Powershell_black_64.png\" };\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Model\r\n+{\r\n+    std::wstring_view PowershellInstallationProfileGenerator::Namespace{ L\"Windows.Terminal.InstallPowerShell\" };\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetNamespace() const noexcept\r\n+    {\r\n+        return Namespace;\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetDisplayName() const noexcept\r\n+    {\r\n+        return RS_(L\"PowerShellInstallationProfileGeneratorDisplayName\");\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetIcon() const noexcept\r\n+    {\r\n+        return POWERSHELL_ICON_64;\r\n+    }\r\n+\r\n+    void PowershellInstallationProfileGenerator::GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles)\r\n+    {\r\n+        auto profile{ CreateDynamicProfile(RS_(L\"PowerShellInstallationProfileName\")) };\r\n+        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });\r",
        "comment_created_at": "2025-03-01T21:26:38+00:00",
        "comment_author": "mdanish-kh",
        "comment_body": "Yeah that's why I didn't suggest the `--accept-source-agreements` since we require agreements to be interactive",
        "pr_file_module": null
      },
      {
        "comment_id": "1978119714",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18639,
        "pr_file": "src/cascadia/TerminalSettingsModel/PowershellInstallationProfileGenerator.cpp",
        "discussion_id": "1976447628",
        "commented_code": "@@ -0,0 +1,42 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+\r\n+#include \"PowershellInstallationProfileGenerator.h\"\r\n+#include \"DynamicProfileUtils.h\"\r\n+\r\n+#include <LibraryResources.h>\r\n+\r\n+static constexpr std::wstring_view POWERSHELL_ICON{ L\"ms-appx:///ProfileIcons/pwsh.png\" };\r\n+static constexpr std::wstring_view POWERSHELL_ICON_64{ L\"ms-appx:///ProfileIcons/Powershell_black_64.png\" };\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Model\r\n+{\r\n+    std::wstring_view PowershellInstallationProfileGenerator::Namespace{ L\"Windows.Terminal.InstallPowerShell\" };\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetNamespace() const noexcept\r\n+    {\r\n+        return Namespace;\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetDisplayName() const noexcept\r\n+    {\r\n+        return RS_(L\"PowerShellInstallationProfileGeneratorDisplayName\");\r\n+    }\r\n+\r\n+    std::wstring_view PowershellInstallationProfileGenerator::GetIcon() const noexcept\r\n+    {\r\n+        return POWERSHELL_ICON_64;\r\n+    }\r\n+\r\n+    void PowershellInstallationProfileGenerator::GenerateProfiles(std::vector<winrt::com_ptr<implementation::Profile>>& profiles)\r\n+    {\r\n+        auto profile{ CreateDynamicProfile(RS_(L\"PowerShellInstallationProfileName\")) };\r\n+        profile->Commandline(winrt::hstring{ fmt::format(FMT_COMPILE(L\"cmd /k winget install --interactive --id Microsoft.PowerShell & echo. & echo {} & exit\"), RS_(L\"PowerShellInstallationInstallerGuidance\")) });\r",
        "comment_created_at": "2025-03-03T20:02:25+00:00",
        "comment_author": "JohnMcPMS",
        "comment_body": "When doing *any* programmatic winget operations, the source should *always* be provided, as well as explicitly specifying the Identifier, not just the identifier as a query string.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945544664",
    "pr_number": 18347,
    "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
    "created_at": "2025-02-06T22:09:23+00:00",
    "commented_code": "searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r\n+    auto iter = buffer.GetCellDataAt(dir == SearchDirection::Forward ? searchStart : searchEnd);\r\n+    while (dir == SearchDirection::Forward ? iter.Pos() < searchEnd : iter.Pos() > searchStart)\r\n+    {\r\n+        // Don't let us select the same hyperlink again\r\n+        if (iter.Pos() < _selection->start || iter.Pos() > _selection->end)\r\n         {\r\n-            return;\r\n+            if (auto attr = iter->TextAttr(); attr.IsHyperlink())\r\n+            {\r\n+                // Found an embedded hyperlink!\r\n+                const auto hyperlinkId = attr.GetHyperlinkId();\r\n+\r\n+                // Expand the start to include the entire hyperlink\r\n+                TextBufferCellIterator hyperlinkStartIter{ buffer, iter.Pos() };\r\n+                while (attr.IsHyperlink() && attr.GetHyperlinkId() == hyperlinkId)\r\n+                {\r\n+                    hyperlinkStartIter--;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1945544664",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18347,
        "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
        "discussion_id": "1945544664",
        "commented_code": "@@ -547,27 +548,69 @@ void Terminal::SelectHyperlink(const SearchDirection dir)\n                 searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r\n+    auto iter = buffer.GetCellDataAt(dir == SearchDirection::Forward ? searchStart : searchEnd);\r\n+    while (dir == SearchDirection::Forward ? iter.Pos() < searchEnd : iter.Pos() > searchStart)\r\n+    {\r\n+        // Don't let us select the same hyperlink again\r\n+        if (iter.Pos() < _selection->start || iter.Pos() > _selection->end)\r\n         {\r\n-            return;\r\n+            if (auto attr = iter->TextAttr(); attr.IsHyperlink())\r\n+            {\r\n+                // Found an embedded hyperlink!\r\n+                const auto hyperlinkId = attr.GetHyperlinkId();\r\n+\r\n+                // Expand the start to include the entire hyperlink\r\n+                TextBufferCellIterator hyperlinkStartIter{ buffer, iter.Pos() };\r\n+                while (attr.IsHyperlink() && attr.GetHyperlinkId() == hyperlinkId)\r\n+                {\r\n+                    hyperlinkStartIter--;\r",
        "comment_created_at": "2025-02-06T22:09:23+00:00",
        "comment_author": "lhecker",
        "comment_body": "Always write `--hyperlinkStartIter` if you don't want the previous result.",
        "pr_file_module": null
      }
    ]
  }
]