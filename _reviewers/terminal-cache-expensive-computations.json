[
  {
    "discussion_id": "2101032431",
    "pr_number": 18917,
    "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.cpp",
    "created_at": "2025-05-21T19:38:44+00:00",
    "commented_code": "using namespace winrt::Windows::UI::Xaml::Navigation;\r\n using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n \r\n+// todo:\r\n+//      multiple actions\r\n+//      selection color\r\n+// the above arg types aren't implemented yet - they all have multiple values within them\r\n+// and require a different approach to binding/displaying. Selection color has color and IsIndex16,\r\n+// multiple actions is... multiple actions\r\n+// for now, do not support these shortcut actions in the new action editor\r\n+inline const std::set<winrt::Microsoft::Terminal::Settings::Model::ShortcutAction> UnimplementedShortcutActions = {\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::MultipleActions,\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::ColorSelection\r\n+};\r\n+\r\n+#define INITIALIZE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_NULLABLE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                       \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr);          \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    else                                                                                                                                                    \\\r\n+    {                                                                                                                                                       \\\r\n+        _EnumValue = nullEntry;                                                                                                                             \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    enumList.emplace_back(nullEntry);                                                                                                                       \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                           \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                                  \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                   \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    auto unboxed = unbox_value<enumType>(_Value);                                                                                                      \\\r\n+                    flagWrapper.IsSet() ? WI_SetAllFlags(unboxed, flagValue) : WI_ClearAllFlags(unboxed, flagValue);                                                   \\\r\n+                    Value(box_value(unboxed));                                                                                                                         \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n+#define INITIALIZE_NULLABLE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                  \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr, true);               \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (const auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value))                                                                    \\\r\n+        {                                                                                                                                                              \\\r\n+            unboxedValue = unboxedRef.Value();                                                                                                                         \\\r\n+            nullEntry.IsSet(false);                                                                                                                                    \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue, nullEntry](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                        \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    enumType unboxedValue{ 0 };                                                                                                                        \\\r\n+                    auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value);                                                                  \\\r\n+                    if (unboxedRef)                                                                                                                                    \\\r\n+                    {                                                                                                                                                  \\\r\n+                        unboxedValue = unboxedRef.Value();                                                                                                             \\\r\n+                    }                                                                                                                                                  \\\r\n+                    if (flagWrapper.IsSet())                                                                                                                           \\\r\n+                    {                                                                                                                                                  \\\r\n+                        nullEntry.IsSet(false);                                                                                                                        \\\r\n+                        WI_SetAllFlags(unboxedValue, flagValue);                                                                                                       \\\r\n+                    }                                                                                                                                                  \\\r\n+                    else                                                                                                                                               \\\r\n+                    {                                                                                                                                                  \\\r\n+                        WI_ClearAllFlags(unboxedValue, flagValue);                                                                                                     \\\r\n+                    }                                                                                                                                                  \\\r\n+                    Value(box_value(unboxedValue));                                                                                                                    \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    nullEntry.PropertyChanged([&](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                                  \\\r\n+        const auto itemProperty{ args.PropertyName() };                                                                                                                \\\r\n+        if (itemProperty == L\"IsSet\")                                                                                                                                  \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                                    \\\r\n+            if (flagWrapper.IsSet())                                                                                                                                   \\\r\n+            {                                                                                                                                                          \\\r\n+                for (const auto flagEntry : _FlagList)                                                                                                                 \\\r\n+                {                                                                                                                                                      \\\r\n+                    if (flagEntry.FlagName() != RS_(L\"Actions_NullEnumValue\"))                                                                                         \\\r\n+                    {                                                                                                                                                  \\\r\n+                        flagEntry.IsSet(false);                                                                                                                        \\\r\n+                    }                                                                                                                                                  \\\r\n+                }                                                                                                                                                      \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(nullptr)));                                                                                  \\\r\n+            }                                                                                                                                                          \\\r\n+            else                                                                                                                                                       \\\r\n+            {                                                                                                                                                          \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(enumType{ 0 })));                                                                            \\\r\n+            }                                                                                                                                                          \\\r\n+        }                                                                                                                                                              \\\r\n+    });                                                                                                                                                                \\\r\n+    flagList.emplace_back(nullEntry);                                                                                                                                  \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    KeyBindingViewModel::KeyBindingViewModel(const IObservableVector<hstring>& availableActions) :\r\n-        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}\r\n+    CommandViewModel::CommandViewModel(Command cmd, std::vector<Control::KeyChord> keyChordList, const Editor::ActionsViewModel actionsPageVM, const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames) :\r\n+        _command{ cmd },\r\n+        _keyChordList{ keyChordList },\r\n+        _actionsPageVM{ actionsPageVM },\r\n+        _AvailableActionsAndNamesMap{ availableShortcutActionsAndNames }\r\n+    {\r\n+    }\r\n \r\n-    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :\r\n-        _CurrentKeys{ keys },\r\n-        _KeyChordText{ KeyChordSerialization::ToString(keys) },\r\n-        _CurrentAction{ actionName },\r\n-        _ProposedAction{ box_value(actionName) },\r\n-        _AvailableActions{ availableActions }\r\n+    void CommandViewModel::Initialize()\r\n     {\r\n+        std::vector<Editor::KeyChordViewModel> keyChordVMs;\r\n+        for (const auto keys : _keyChordList)\r\n+        {\r\n+            auto kcVM{ make<KeyChordViewModel>(keys) };\r\n+            _RegisterKeyChordVMEvents(kcVM);\r\n+            keyChordVMs.push_back(kcVM);\r\n+        }\r\n+        _KeyChordViewModelList = single_threaded_observable_vector(std::move(keyChordVMs));\r\n+\r\n+        std::vector<hstring> shortcutActions;\r\n+        for (const auto [action, name] : _AvailableActionsAndNamesMap)\r\n+        {\r\n+            shortcutActions.emplace_back(name);\r\n+            _NameToActionMap.emplace(name, action);\r\n+        }\r\n+        std::sort(shortcutActions.begin(), shortcutActions.end());\r\n+        _AvailableShortcutActions = single_threaded_observable_vector(std::move(shortcutActions));",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2101032431",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18917,
        "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.cpp",
        "discussion_id": "2101032431",
        "commented_code": "@@ -18,383 +24,1194 @@ using namespace winrt::Windows::UI::Xaml::Data;\n using namespace winrt::Windows::UI::Xaml::Navigation;\r\n using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n \r\n+// todo:\r\n+//      multiple actions\r\n+//      selection color\r\n+// the above arg types aren't implemented yet - they all have multiple values within them\r\n+// and require a different approach to binding/displaying. Selection color has color and IsIndex16,\r\n+// multiple actions is... multiple actions\r\n+// for now, do not support these shortcut actions in the new action editor\r\n+inline const std::set<winrt::Microsoft::Terminal::Settings::Model::ShortcutAction> UnimplementedShortcutActions = {\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::MultipleActions,\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::ColorSelection\r\n+};\r\n+\r\n+#define INITIALIZE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_NULLABLE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                       \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr);          \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    else                                                                                                                                                    \\\r\n+    {                                                                                                                                                       \\\r\n+        _EnumValue = nullEntry;                                                                                                                             \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    enumList.emplace_back(nullEntry);                                                                                                                       \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                           \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                                  \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                   \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    auto unboxed = unbox_value<enumType>(_Value);                                                                                                      \\\r\n+                    flagWrapper.IsSet() ? WI_SetAllFlags(unboxed, flagValue) : WI_ClearAllFlags(unboxed, flagValue);                                                   \\\r\n+                    Value(box_value(unboxed));                                                                                                                         \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n+#define INITIALIZE_NULLABLE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                  \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr, true);               \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (const auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value))                                                                    \\\r\n+        {                                                                                                                                                              \\\r\n+            unboxedValue = unboxedRef.Value();                                                                                                                         \\\r\n+            nullEntry.IsSet(false);                                                                                                                                    \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue, nullEntry](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                        \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    enumType unboxedValue{ 0 };                                                                                                                        \\\r\n+                    auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value);                                                                  \\\r\n+                    if (unboxedRef)                                                                                                                                    \\\r\n+                    {                                                                                                                                                  \\\r\n+                        unboxedValue = unboxedRef.Value();                                                                                                             \\\r\n+                    }                                                                                                                                                  \\\r\n+                    if (flagWrapper.IsSet())                                                                                                                           \\\r\n+                    {                                                                                                                                                  \\\r\n+                        nullEntry.IsSet(false);                                                                                                                        \\\r\n+                        WI_SetAllFlags(unboxedValue, flagValue);                                                                                                       \\\r\n+                    }                                                                                                                                                  \\\r\n+                    else                                                                                                                                               \\\r\n+                    {                                                                                                                                                  \\\r\n+                        WI_ClearAllFlags(unboxedValue, flagValue);                                                                                                     \\\r\n+                    }                                                                                                                                                  \\\r\n+                    Value(box_value(unboxedValue));                                                                                                                    \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    nullEntry.PropertyChanged([&](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                                  \\\r\n+        const auto itemProperty{ args.PropertyName() };                                                                                                                \\\r\n+        if (itemProperty == L\"IsSet\")                                                                                                                                  \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                                    \\\r\n+            if (flagWrapper.IsSet())                                                                                                                                   \\\r\n+            {                                                                                                                                                          \\\r\n+                for (const auto flagEntry : _FlagList)                                                                                                                 \\\r\n+                {                                                                                                                                                      \\\r\n+                    if (flagEntry.FlagName() != RS_(L\"Actions_NullEnumValue\"))                                                                                         \\\r\n+                    {                                                                                                                                                  \\\r\n+                        flagEntry.IsSet(false);                                                                                                                        \\\r\n+                    }                                                                                                                                                  \\\r\n+                }                                                                                                                                                      \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(nullptr)));                                                                                  \\\r\n+            }                                                                                                                                                          \\\r\n+            else                                                                                                                                                       \\\r\n+            {                                                                                                                                                          \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(enumType{ 0 })));                                                                            \\\r\n+            }                                                                                                                                                          \\\r\n+        }                                                                                                                                                              \\\r\n+    });                                                                                                                                                                \\\r\n+    flagList.emplace_back(nullEntry);                                                                                                                                  \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    KeyBindingViewModel::KeyBindingViewModel(const IObservableVector<hstring>& availableActions) :\r\n-        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}\r\n+    CommandViewModel::CommandViewModel(Command cmd, std::vector<Control::KeyChord> keyChordList, const Editor::ActionsViewModel actionsPageVM, const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames) :\r\n+        _command{ cmd },\r\n+        _keyChordList{ keyChordList },\r\n+        _actionsPageVM{ actionsPageVM },\r\n+        _AvailableActionsAndNamesMap{ availableShortcutActionsAndNames }\r\n+    {\r\n+    }\r\n \r\n-    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :\r\n-        _CurrentKeys{ keys },\r\n-        _KeyChordText{ KeyChordSerialization::ToString(keys) },\r\n-        _CurrentAction{ actionName },\r\n-        _ProposedAction{ box_value(actionName) },\r\n-        _AvailableActions{ availableActions }\r\n+    void CommandViewModel::Initialize()\r\n     {\r\n+        std::vector<Editor::KeyChordViewModel> keyChordVMs;\r\n+        for (const auto keys : _keyChordList)\r\n+        {\r\n+            auto kcVM{ make<KeyChordViewModel>(keys) };\r\n+            _RegisterKeyChordVMEvents(kcVM);\r\n+            keyChordVMs.push_back(kcVM);\r\n+        }\r\n+        _KeyChordViewModelList = single_threaded_observable_vector(std::move(keyChordVMs));\r\n+\r\n+        std::vector<hstring> shortcutActions;\r\n+        for (const auto [action, name] : _AvailableActionsAndNamesMap)\r\n+        {\r\n+            shortcutActions.emplace_back(name);\r\n+            _NameToActionMap.emplace(name, action);\r\n+        }\r\n+        std::sort(shortcutActions.begin(), shortcutActions.end());\r\n+        _AvailableShortcutActions = single_threaded_observable_vector(std::move(shortcutActions));\r",
        "comment_created_at": "2025-05-21T19:38:44+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "Wait, so _each_ `CommandViewModel` has a copy of `_AvailableShortcutActions` and `_NameToActionMap`, but it's the same thing across each `CommandViewModel`? Is there a way we can deduplicate this? Maybe make them static in `CommandViewModel` and just load them once?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2101132701",
    "pr_number": 18917,
    "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.cpp",
    "created_at": "2025-05-21T20:43:53+00:00",
    "commented_code": "using namespace winrt::Windows::UI::Xaml::Navigation;\r\n using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n \r\n+// todo:\r\n+//      multiple actions\r\n+//      selection color\r\n+// the above arg types aren't implemented yet - they all have multiple values within them\r\n+// and require a different approach to binding/displaying. Selection color has color and IsIndex16,\r\n+// multiple actions is... multiple actions\r\n+// for now, do not support these shortcut actions in the new action editor\r\n+inline const std::set<winrt::Microsoft::Terminal::Settings::Model::ShortcutAction> UnimplementedShortcutActions = {\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::MultipleActions,\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::ColorSelection\r\n+};\r\n+\r\n+#define INITIALIZE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_NULLABLE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                       \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr);          \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    else                                                                                                                                                    \\\r\n+    {                                                                                                                                                       \\\r\n+        _EnumValue = nullEntry;                                                                                                                             \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    enumList.emplace_back(nullEntry);                                                                                                                       \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                           \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                                  \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                   \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    auto unboxed = unbox_value<enumType>(_Value);                                                                                                      \\\r\n+                    flagWrapper.IsSet() ? WI_SetAllFlags(unboxed, flagValue) : WI_ClearAllFlags(unboxed, flagValue);                                                   \\\r\n+                    Value(box_value(unboxed));                                                                                                                         \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n+#define INITIALIZE_NULLABLE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                  \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr, true);               \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (const auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value))                                                                    \\\r\n+        {                                                                                                                                                              \\\r\n+            unboxedValue = unboxedRef.Value();                                                                                                                         \\\r\n+            nullEntry.IsSet(false);                                                                                                                                    \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue, nullEntry](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                        \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    enumType unboxedValue{ 0 };                                                                                                                        \\\r\n+                    auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value);                                                                  \\\r\n+                    if (unboxedRef)                                                                                                                                    \\\r\n+                    {                                                                                                                                                  \\\r\n+                        unboxedValue = unboxedRef.Value();                                                                                                             \\\r\n+                    }                                                                                                                                                  \\\r\n+                    if (flagWrapper.IsSet())                                                                                                                           \\\r\n+                    {                                                                                                                                                  \\\r\n+                        nullEntry.IsSet(false);                                                                                                                        \\\r\n+                        WI_SetAllFlags(unboxedValue, flagValue);                                                                                                       \\\r\n+                    }                                                                                                                                                  \\\r\n+                    else                                                                                                                                               \\\r\n+                    {                                                                                                                                                  \\\r\n+                        WI_ClearAllFlags(unboxedValue, flagValue);                                                                                                     \\\r\n+                    }                                                                                                                                                  \\\r\n+                    Value(box_value(unboxedValue));                                                                                                                    \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    nullEntry.PropertyChanged([&](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                                  \\\r\n+        const auto itemProperty{ args.PropertyName() };                                                                                                                \\\r\n+        if (itemProperty == L\"IsSet\")                                                                                                                                  \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                                    \\\r\n+            if (flagWrapper.IsSet())                                                                                                                                   \\\r\n+            {                                                                                                                                                          \\\r\n+                for (const auto flagEntry : _FlagList)                                                                                                                 \\\r\n+                {                                                                                                                                                      \\\r\n+                    if (flagEntry.FlagName() != RS_(L\"Actions_NullEnumValue\"))                                                                                         \\\r\n+                    {                                                                                                                                                  \\\r\n+                        flagEntry.IsSet(false);                                                                                                                        \\\r\n+                    }                                                                                                                                                  \\\r\n+                }                                                                                                                                                      \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(nullptr)));                                                                                  \\\r\n+            }                                                                                                                                                          \\\r\n+            else                                                                                                                                                       \\\r\n+            {                                                                                                                                                          \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(enumType{ 0 })));                                                                            \\\r\n+            }                                                                                                                                                          \\\r\n+        }                                                                                                                                                              \\\r\n+    });                                                                                                                                                                \\\r\n+    flagList.emplace_back(nullEntry);                                                                                                                                  \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    KeyBindingViewModel::KeyBindingViewModel(const IObservableVector<hstring>& availableActions) :\r\n-        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}\r\n+    CommandViewModel::CommandViewModel(Command cmd, std::vector<Control::KeyChord> keyChordList, const Editor::ActionsViewModel actionsPageVM, const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames) :\r\n+        _command{ cmd },\r\n+        _keyChordList{ keyChordList },\r\n+        _actionsPageVM{ actionsPageVM },\r\n+        _AvailableActionsAndNamesMap{ availableShortcutActionsAndNames }\r\n+    {\r\n+    }\r\n \r\n-    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :\r\n-        _CurrentKeys{ keys },\r\n-        _KeyChordText{ KeyChordSerialization::ToString(keys) },\r\n-        _CurrentAction{ actionName },\r\n-        _ProposedAction{ box_value(actionName) },\r\n-        _AvailableActions{ availableActions }\r\n+    void CommandViewModel::Initialize()\r\n     {\r\n+        std::vector<Editor::KeyChordViewModel> keyChordVMs;\r\n+        for (const auto keys : _keyChordList)\r\n+        {\r\n+            auto kcVM{ make<KeyChordViewModel>(keys) };\r\n+            _RegisterKeyChordVMEvents(kcVM);\r\n+            keyChordVMs.push_back(kcVM);\r\n+        }\r\n+        _KeyChordViewModelList = single_threaded_observable_vector(std::move(keyChordVMs));\r\n+\r\n+        std::vector<hstring> shortcutActions;\r\n+        for (const auto [action, name] : _AvailableActionsAndNamesMap)\r\n+        {\r\n+            shortcutActions.emplace_back(name);\r\n+            _NameToActionMap.emplace(name, action);\r\n+        }\r\n+        std::sort(shortcutActions.begin(), shortcutActions.end());\r\n+        _AvailableShortcutActions = single_threaded_observable_vector(std::move(shortcutActions));\r\n+\r\n+        const auto shortcutActionString = _AvailableActionsAndNamesMap.Lookup(_command.ActionAndArgs().Action());\r\n+        ProposedShortcutAction(winrt::box_value(shortcutActionString));\r\n+        _CreateAndInitializeActionArgsVMHelper();\r\n+\r\n         // Add a property changed handler to our own property changed event.\r\n-        // This propagates changes from the settings model to anybody listening to our\r\n-        //  unique view model members.\r\n+        // This allows us to create a new ActionArgsVM when the shortcut action changes\r\n         PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {\r\n             const auto viewModelProperty{ args.PropertyName() };\r\n-            if (viewModelProperty == L\"CurrentKeys\")\r\n+            if (viewModelProperty == L\"ProposedShortcutAction\")\r\n             {\r\n-                _KeyChordText = KeyChordSerialization::ToString(_CurrentKeys);\r\n-                _NotifyChanges(L\"KeyChordText\");\r\n+                const auto actionString = unbox_value<hstring>(ProposedShortcutAction());\r\n+                const auto actionEnum = _NameToActionMap.at(actionString);\r\n+                const auto emptyArgs = CascadiaSettings::GetEmptyArgsForAction(actionEnum);\r\n+                // todo: probably need some better default values for empty args\r\n+                // eg. for sendInput, where \"input\" is a required argument, \"input\" gets set to an empty string which does not satisfy the requirement\r\n+                // i.e. if the user hits \"save\" immediately after switching to sendInput as the action (without adding something to the input field), they'll get an error\r\n+                // there are some other cases as well\r\n+                Model::ActionAndArgs newActionAndArgs{ actionEnum, emptyArgs };\r\n+                _command.ActionAndArgs(newActionAndArgs);\r\n+                if (_IsNewCommand)\r\n+                {\r\n+                    _command.GenerateID();\r\n+                }\r\n+                else if (!IsUserAction())\r\n+                {\r\n+                    _ReplaceCommandWithUserCopy(true);\r\n+                    return;\r\n+                }\r\n+                _CreateAndInitializeActionArgsVMHelper();\r\n             }\r\n-            else if (viewModelProperty == L\"IsContainerFocused\" ||\r\n-                     viewModelProperty == L\"IsEditButtonFocused\" ||\r\n-                     viewModelProperty == L\"IsHovered\" ||\r\n-                     viewModelProperty == L\"IsAutomationPeerAttached\" ||\r\n-                     viewModelProperty == L\"IsInEditMode\")\r\n+        });\r\n+    }\r\n+\r\n+    winrt::hstring CommandViewModel::DisplayName()\r\n+    {\r\n+        return _command.Name();\r\n+    }\r\n+\r\n+    winrt::hstring CommandViewModel::Name()\r\n+    {\r\n+        if (_command.HasName())\r\n+        {\r\n+            return _command.Name();\r\n+        }\r\n+        return L\"\";\r\n+    }\r\n+\r\n+    void CommandViewModel::Name(const winrt::hstring& newName)\r\n+    {\r\n+        if (!newName.empty())\r\n+        {\r\n+            _command.Name(newName);\r\n+        }\r\n+    }\r\n+\r\n+    winrt::hstring CommandViewModel::ID()\r\n+    {\r\n+        return _command.ID();\r\n+    }\r\n+\r\n+    void CommandViewModel::ID(const winrt::hstring& ID)\r\n+    {\r\n+        _command.ID(ID);\r\n+    }\r\n+\r\n+    bool CommandViewModel::IsUserAction()\r\n+    {\r\n+        return _command.Origin() == OriginTag::User;\r\n+    }\r\n+\r\n+    void CommandViewModel::Edit_Click()\r\n+    {\r\n+        EditRequested.raise(*this, *this);\r\n+    }\r\n+\r\n+    void CommandViewModel::Delete_Click()\r\n+    {\r\n+        DeleteRequested.raise(*this, *this);\r\n+    }\r\n+\r\n+    void CommandViewModel::AddKeybinding_Click()\r\n+    {\r\n+        auto kbdVM{ make_self<KeyChordViewModel>(nullptr) };\r\n+        kbdVM->IsInEditMode(true);\r\n+        _RegisterKeyChordVMEvents(*kbdVM);\r\n+        KeyChordViewModelList().Append(*kbdVM);\r\n+    }\r\n+\r\n+    void CommandViewModel::_RegisterKeyChordVMEvents(Editor::KeyChordViewModel kcVM)\r\n+    {\r\n+        if (const auto actionsPageVM{ _actionsPageVM.get() })\r\n+        {\r\n+            const auto id = ID();\r\n+            kcVM.AddKeyChordRequested([actionsPageVM, id](const Editor::KeyChordViewModel& sender, const Control::KeyChord& keys) {\r\n+                actionsPageVM.AttemptAddOrModifyKeyChord(sender, id, keys, nullptr);\r\n+            });\r\n+            kcVM.ModifyKeyChordRequested([actionsPageVM, id](const Editor::KeyChordViewModel& sender, const Editor::ModifyKeyChordEventArgs& args) {\r\n+                actionsPageVM.AttemptAddOrModifyKeyChord(sender, id, args.NewKeys(), args.OldKeys());\r\n+            });\r\n+            kcVM.DeleteKeyChordRequested([&, actionsPageVM](const Editor::KeyChordViewModel& sender, const Control::KeyChord& args) {\r\n+                _keyChordList.erase(\r\n+                    std::remove_if(\r\n+                        _keyChordList.begin(),\r\n+                        _keyChordList.end(),\r\n+                        [&](const Control::KeyChord& kc) { return kc == args; }),\r\n+                    _keyChordList.end());\r\n+                for (uint32_t i = 0; i < _KeyChordViewModelList.Size(); i++)\r\n+                {\r\n+                    if (_KeyChordViewModelList.GetAt(i) == sender)\r\n+                    {\r\n+                        KeyChordViewModelList().RemoveAt(i);\r\n+                        break;\r\n+                    }\r\n+                }\r\n+                actionsPageVM.AttemptDeleteKeyChord(args);\r\n+            });\r\n+        }\r\n+    }\r\n+\r\n+    void CommandViewModel::_RegisterActionArgsVMEvents(Editor::ActionArgsViewModel actionArgsVM)\r\n+    {\r\n+        actionArgsVM.PropagateColorSchemeRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+            if (auto weak = weakThis.get())\r\n             {\r\n-                _NotifyChanges(L\"ShowEditButton\");\r\n+                if (wrapper)\r\n+                {\r\n+                    weak->PropagateColorSchemeRequested.raise(*weak, wrapper);\r\n+                }\r\n+            }\r\n+        });\r\n+        actionArgsVM.PropagateColorSchemeNamesRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+            if (auto weak = weakThis.get())\r\n+            {\r\n+                if (wrapper)\r\n+                {\r\n+                    weak->PropagateColorSchemeNamesRequested.raise(*weak, wrapper);\r\n+                }\r\n             }\r\n-            else if (viewModelProperty == L\"CurrentAction\")\r\n+        });\r\n+        actionArgsVM.PropagateWindowRootRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+            if (auto weak = weakThis.get())\r\n             {\r\n-                _NotifyChanges(L\"Name\");\r\n+                if (wrapper)\r\n+                {\r\n+                    weak->PropagateWindowRootRequested.raise(*weak, wrapper);\r\n+                }\r\n             }\r\n         });\r\n+        if (_IsNewCommand)\r\n+        {\r\n+            // for new commands, make sure we generate a new ID everytime any arg value changes\r\n+            actionArgsVM.WrapperValueChanged([weakThis = get_weak()](const IInspectable& /*sender*/, const IInspectable& /*args*/) {\r\n+                if (auto weak = weakThis.get())\r\n+                {\r\n+                    weak->_command.GenerateID();\r\n+                }\r\n+            });\r\n+        }\r\n+        else if (!IsUserAction())\r\n+        {\r\n+            actionArgsVM.WrapperValueChanged([weakThis = get_weak()](const IInspectable& /*sender*/, const IInspectable& /*args*/) {\r\n+                if (auto weak = weakThis.get())\r\n+                {\r\n+                    weak->_ReplaceCommandWithUserCopy(false);\r\n+                }\r\n+            });\r\n+        }\r\n+    }\r\n+\r\n+    void CommandViewModel::_ReplaceCommandWithUserCopy(bool reinitialize)\r\n+    {\r\n+        // the user is attempting to edit an in-box action\r\n+        // to handle this, we create a new command with the new values that has the same ID as the in-box action\r\n+        // swap out our underlying command with the copy, tell the ActionsVM that the copy needs to be added to the action map\r\n+        if (const auto actionsPageVM{ _actionsPageVM.get() })\r\n+        {\r\n+            const auto newCmd = Model::Command::CopyAsUserCommand(_command);\r\n+            _command = newCmd;\r\n+            actionsPageVM.AttemptAddCopiedCommand(_command);\r\n+            if (reinitialize)\r\n+            {\r\n+                // full reinitialize needed, recreate the action args VM\r\n+                // (this happens when the shortcut action is being changed on an in-box action)\r\n+                _CreateAndInitializeActionArgsVMHelper();\r\n+            }\r\n+            else\r\n+            {\r\n+                // no need to reinitialize, just swap out the underlying data model\r\n+                // (this happens when an additional argument is being changed on an in-box action)\r\n+                auto actionArgsVMImpl{ get_self<ActionArgsViewModel>(_ActionArgsVM) };\r\n+                actionArgsVMImpl->ReplaceActionAndArgs(_command.ActionAndArgs());\r\n+            }\r\n+        }\r\n     }\r\n \r\n-    hstring KeyBindingViewModel::EditButtonName() const noexcept { return RS_(L\"Actions_EditButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n-    hstring KeyBindingViewModel::CancelButtonName() const noexcept { return RS_(L\"Actions_CancelButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n-    hstring KeyBindingViewModel::AcceptButtonName() const noexcept { return RS_(L\"Actions_AcceptButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n-    hstring KeyBindingViewModel::DeleteButtonName() const noexcept { return RS_(L\"Actions_DeleteButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n+    void CommandViewModel::_CreateAndInitializeActionArgsVMHelper()\r\n+    {\r\n+        const auto actionArgsVM = make_self<ActionArgsViewModel>(_command.ActionAndArgs());\r\n+        _RegisterActionArgsVMEvents(*actionArgsVM);\r\n+        actionArgsVM->Initialize();\r\n+        ActionArgsVM(*actionArgsVM);\r\n+        _NotifyChanges(L\"DisplayName\");\r\n+    }\r\n \r\n-    bool KeyBindingViewModel::ShowEditButton() const noexcept\r\n+    ArgWrapper::ArgWrapper(const winrt::hstring& name, const winrt::hstring& type, const bool required, const Model::ArgTag tag, const Windows::Foundation::IInspectable& value) :\r\n+        _name{ name },\r\n+        _type{ type },\r\n+        _tag{ tag },\r\n+        _required{ required }\r\n     {\r\n-        return (IsContainerFocused() || IsEditButtonFocused() || IsHovered() || IsAutomationPeerAttached()) && !IsInEditMode();\r\n+        Value(value);\r\n     }\r\n \r\n-    void KeyBindingViewModel::ToggleEditMode()\r\n+    void ArgWrapper::Initialize()\r\n     {\r\n-        // toggle edit mode\r\n-        IsInEditMode(!_IsInEditMode);\r\n-        if (_IsInEditMode)\r\n+        if (_type == L\"Model::ResizeDirection\")\r\n         {\r\n-            // if we're in edit mode,\r\n-            // - prepopulate the text box with the current keys\r\n-            // - reset the combo box with the current action\r\n-            ProposedKeys(_CurrentKeys);\r\n-            ProposedAction(box_value(_CurrentAction));\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(ResizeDirection, Model::ResizeDirection, L\"Actions_ResizeDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::FocusDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(FocusDirection, Model::FocusDirection, L\"Actions_FocusDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SettingsTarget\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SettingsTarget, Model::SettingsTarget, L\"Actions_SettingsTarget\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"MoveTabDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(MoveTabDirection, Model::MoveTabDirection, L\"Actions_MoveTabDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Microsoft::Terminal::Control::ScrollToMarkDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(ScrollToMarkDirection, Control::ScrollToMarkDirection, L\"Actions_ScrollToMarkDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"CommandPaletteLaunchMode\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(CommandPaletteLaunchMode, Model::CommandPaletteLaunchMode, L\"Actions_CommandPaletteLaunchMode\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SuggestionsSource\")\r\n+        {\r\n+            INITIALIZE_FLAG_LIST_AND_VALUE(SuggestionsSource, Model::SuggestionsSource, L\"Actions_SuggestionsSource\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"FindMatchDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(FindMatchDirection, Model::FindMatchDirection, L\"Actions_FindMatchDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::DesktopBehavior\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(DesktopBehavior, Model::DesktopBehavior, L\"Actions_DesktopBehavior\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::MonitorBehavior\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(MonitorBehavior, Model::MonitorBehavior, L\"Actions_MonitorBehavior\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"winrt::Microsoft::Terminal::Control::ClearBufferType\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(ClearBufferType, Control::ClearBufferType, L\"Actions_ClearBufferType\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SelectOutputDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SelectOutputDirection, Model::SelectOutputDirection, L\"Actions_SelectOutputDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::SplitDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SplitDirection, Model::SplitDirection, L\"Actions_SplitDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SplitType\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SplitType, Model::SplitType, L\"Actions_SplitType\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Windows::Foundation::IReference<TabSwitcherMode>\")\r\n+        {\r\n+            INITIALIZE_NULLABLE_ENUM_LIST_AND_VALUE(TabSwitcherMode, Model::TabSwitcherMode, L\"Actions_TabSwitcherMode\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Windows::Foundation::IReference<Control::CopyFormat>\")\r\n+        {\r\n+            INITIALIZE_NULLABLE_FLAG_LIST_AND_VALUE(CopyFormat, Control::CopyFormat, L\"Actions_CopyFormat\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>\" ||\r\n+                 _type == L\"Windows::Foundation::IReference<Windows::UI::Color>\")\r\n+        {\r\n+            ColorSchemeRequested.raise(*this, *this);\r\n+        }\r\n+        else if (_tag == Model::ArgTag::ColorScheme)\r\n+        {\r\n+            // special case of string, emit an event letting the actionsVM know we need the list of color scheme names\r\n+            ColorSchemeNamesRequested.raise(*this, *this);\r\n+\r\n+            // even though the arg type is technically a string, we want an enum list for color schemes specifically\r\n+            std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> namesList;\r\n+            const auto currentSchemeName = unbox_value<winrt::hstring>(_Value);\r\n+            auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr);\r\n+            if (currentSchemeName.empty())\r\n+            {\r\n+                _EnumValue = nullEntry;\r\n+            }\r\n+            for (const auto colorSchemeName : _ColorSchemeNamesList)\r\n+            {\r\n+                // eventually we will want to use localized names for the enum entries, for now just use what the settings model gives us\r\n+                auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(colorSchemeName, winrt::box_value(colorSchemeName));\r\n+                namesList.emplace_back(entry);\r\n+                if (currentSchemeName == colorSchemeName)\r\n+                {\r\n+                    _EnumValue = entry;\r\n+                }\r\n+            }\r\n+            std::sort(namesList.begin(), namesList.end(), EnumEntryReverseComparator<winrt::hstring>());\r\n+            namesList.emplace_back(nullEntry);\r\n+            _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(namesList));\r\n+            _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n         }\r\n     }\r\n \r\n-    void KeyBindingViewModel::AttemptAcceptChanges()\r\n+    safe_void_coroutine ArgWrapper::Browse_Click(const IInspectable&, const RoutedEventArgs&)\r\n     {\r\n-        AttemptAcceptChanges(_ProposedKeys);\r\n+        WindowRootRequested.raise(*this, *this);\r\n+        auto lifetime = get_strong();\r\n+\r\n+        static constexpr winrt::guid clientGuidFiles{ 0xbd00ae34, 0x839b, 0x43f6, { 0x8b, 0x94, 0x12, 0x37, 0x1a, 0xfe, 0xea, 0xb5 } };\r\n+        const auto parentHwnd{ reinterpret_cast<HWND>(_WindowRoot.GetHostingWindow()) };\r\n+        auto path = co_await OpenFilePicker(parentHwnd, [](auto&& dialog) {\r\n+            THROW_IF_FAILED(dialog->SetClientGuid(clientGuidFiles));\r\n+            try\r\n+            {\r\n+                auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, nullptr) };\r\n+                dialog->SetDefaultFolder(folderShellItem.get());\r\n+            }\r\n+            CATCH_LOG(); // non-fatal\r\n+        });\r\n+\r\n+        if (!path.empty())\r\n+        {\r\n+            StringBindBack(path);\r\n+        }\r\n     }\r\n \r\n-    void KeyBindingViewModel::AttemptAcceptChanges(const Control::KeyChord newKeys)\r\n+    void ArgWrapper::EnumValue(const Windows::Foundation::IInspectable& enumValue)\r\n     {\r\n-        const auto args{ make_self<ModifyKeyBindingEventArgs>(_CurrentKeys, // OldKeys\r\n-                                                              newKeys, // NewKeys\r\n-                                                              _IsNewlyAdded ? hstring{} : _CurrentAction, // OldAction\r\n-                                                              unbox_value<hstring>(_ProposedAction)) }; // NewAction\r\n-        ModifyKeyBindingRequested.raise(*this, *args);\r\n+        if (_EnumValue != enumValue)\r\n+        {\r\n+            _EnumValue = enumValue;\r\n+            Value(_EnumValue.as<Editor::EnumEntry>().EnumValue());\r\n+        }\r\n     }\r\n \r\n-    void KeyBindingViewModel::CancelChanges()\r\n+    winrt::hstring ArgWrapper::UnboxString(const Windows::Foundation::IInspectable& value)\r\n     {\r\n-        if (_IsNewlyAdded)\r\n+        return winrt::unbox_value<winrt::hstring>(value);\r\n+    }\r\n+\r\n+    winrt::hstring ArgWrapper::UnboxGuid(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::to_hstring(winrt::unbox_value<winrt::guid>(value));\r\n+    }\r\n+\r\n+    int32_t ArgWrapper::UnboxInt32(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<int32_t>(value);\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxInt32Optional(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        const auto unboxed = winrt::unbox_value<winrt::Windows::Foundation::IReference<int32_t>>(value);\r\n+        if (unboxed)\r\n         {\r\n-            DeleteNewlyAddedKeyBinding.raise(*this, nullptr);\r\n+            return static_cast<float>(unboxed.Value());\r\n         }\r\n         else\r\n         {\r\n-            ToggleEditMode();\r\n+            return NAN;\r\n         }\r\n     }\r\n \r\n-    ActionsViewModel::ActionsViewModel(Model::CascadiaSettings settings) :\r\n-        _Settings{ settings }\r\n+    uint32_t ArgWrapper::UnboxUInt32(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<uint32_t>(value);\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxUInt32Optional(const Windows::Foundation::IInspectable& value)\r\n     {\r\n-        // Populate AvailableActionAndArgs\r\n-        _AvailableActionMap = single_threaded_map<hstring, Model::ActionAndArgs>();\r\n-        std::vector<hstring> availableActionAndArgs;\r\n-        for (const auto& [name, actionAndArgs] : _Settings.ActionMap().AvailableActions())\r\n+        const auto unboxed = winrt::unbox_value<winrt::Windows::Foundation::IReference<uint32_t>>(value);\r\n+        if (unboxed)\r\n         {\r\n-            availableActionAndArgs.push_back(name);\r\n-            _AvailableActionMap.Insert(name, actionAndArgs);\r\n+            return static_cast<float>(unboxed.Value());\r\n         }\r\n-        std::sort(begin(availableActionAndArgs), end(availableActionAndArgs));\r\n-        _AvailableActionAndArgs = single_threaded_observable_vector(std::move(availableActionAndArgs));\r\n+        else\r\n+        {\r\n+            return NAN;\r\n+        }\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxUInt64(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return static_cast<float>(winrt::unbox_value<uint64_t>(value));\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxFloat(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<float>(value);\r\n+    }\r\n \r\n-        // Convert the key bindings from our settings into a view model representation\r\n-        const auto& keyBindingMap{ _Settings.ActionMap().KeyBindings() };\r\n-        std::vector<Editor::KeyBindingViewModel> keyBindingList;\r\n-        keyBindingList.reserve(keyBindingMap.Size());\r\n-        for (const auto& [keys, cmd] : keyBindingMap)\r\n+    bool ArgWrapper::UnboxBool(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<bool>(value);\r\n+    }\r\n+\r\n+    winrt::Windows::Foundation::IReference<bool> ArgWrapper::UnboxBoolOptional(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        if (!value)\r\n         {\r\n-            // convert the cmd into a KeyBindingViewModel\r\n-            auto container{ make_self<KeyBindingViewModel>(keys, cmd.Name(), _AvailableActionAndArgs) };\r\n-            _RegisterEvents(container);\r\n-            keyBindingList.push_back(*container);\r\n+            return nullptr;\r\n         }\r\n+        return winrt::unbox_value<winrt::Windows::Foundation::IReference<bool>>(value);\r\n+    }\r\n \r\n-        std::sort(begin(keyBindingList), end(keyBindingList), KeyBindingViewModelComparator{});\r\n-        _KeyBindingList = single_threaded_observable_vector(std::move(keyBindingList));\r\n+    winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> ArgWrapper::UnboxTerminalCoreColorOptional(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        if (value)\r\n+        {\r\n+            return unbox_value<Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>>(value);\r\n+        }\r\n+        else\r\n+        {\r\n+            return nullptr;\r\n+        }\r\n     }\r\n \r\n-    void ActionsViewModel::OnAutomationPeerAttached()\r\n+    winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> ArgWrapper::UnboxWindowsUIColorOptional(const Windows::Foundation::IInspectable& value)\r\n     {\r\n-        _AutomationPeerAttached = true;\r\n-        for (const auto& kbdVM : _KeyBindingList)\r\n+        if (value)\r\n+        {\r\n+            const auto winUIColor = unbox_value<Windows::Foundation::IReference<Windows::UI::Color>>(value).Value();\r\n+            const Microsoft::Terminal::Core::Color terminalColor{ winUIColor.R, winUIColor.G, winUIColor.B, winUIColor.A };\r\n+            return Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>{ terminalColor };\r\n+        }\r\n+        else\r\n         {\r\n-            // To create a more accessible experience, we want the \"edit\" buttons to _always_\r\n-            // appear when a screen reader is attached. This ensures that the edit buttons are\r\n-            // accessible via the UIA tree.\r\n-            get_self<KeyBindingViewModel>(kbdVM)->IsAutomationPeerAttached(_AutomationPeerAttached);\r\n+            return nullptr;\r\n         }\r\n     }\r\n \r\n-    void ActionsViewModel::AddNewKeybinding()\r\n+    void ArgWrapper::StringBindBack(const winrt::hstring& newValue)\r\n     {\r\n-        // Create the new key binding and register all of the event handlers.\r\n-        auto kbdVM{ make_self<KeyBindingViewModel>(_AvailableActionAndArgs) };\r\n-        _RegisterEvents(kbdVM);\r\n-        kbdVM->DeleteNewlyAddedKeyBinding({ this, &ActionsViewModel::_KeyBindingViewModelDeleteNewlyAddedKeyBindingHandler });\r\n+        if (UnboxString(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(newValue));\r\n+        }\r\n+    }\r\n \r\n-        // Manually add the editing background. This needs to be done in Actions not the view model.\r\n-        // We also have to do this manually because it hasn't been added to the list yet.\r\n-        kbdVM->IsInEditMode(true);\r\n-        // Emit an event to let the page know to update the background of this key binding VM\r\n-        UpdateBackground.raise(*this, *kbdVM);\r\n+    void ArgWrapper::GuidBindBack(const winrt::hstring& newValue)\r\n+    {\r\n+        if (UnboxGuid(_Value) != newValue)\r\n+        {\r\n+            // todo: probably need some validation?\r\n+            Value(box_value(winrt::guid{ newValue }));\r\n+        }\r\n+    }\r\n \r\n-        // IMPORTANT: do this _after_ setting IsInEditMode. Otherwise, it'll get deleted immediately\r\n-        //              by the PropertyChangedHandler below (where we delete any IsNewlyAdded items)\r\n-        kbdVM->IsNewlyAdded(true);\r\n-        _KeyBindingList.InsertAt(0, *kbdVM);\r\n-        FocusContainer.raise(*this, *kbdVM);\r\n+    void ArgWrapper::Int32BindBack(const double newValue)\r\n+    {\r\n+        if (UnboxInt32(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<int32_t>(newValue)));\r\n+        }\r\n     }\r\n \r\n-    void ActionsViewModel::_KeyBindingViewModelPropertyChangedHandler(const IInspectable& sender, const Windows::UI::Xaml::Data::PropertyChangedEventArgs& args)\r\n+    void ArgWrapper::Int32OptionalBindBack(const double newValue)\r\n     {\r\n-        const auto senderVM{ sender.as<Editor::KeyBindingViewModel>() };\r\n-        const auto propertyName{ args.PropertyName() };\r\n-        if (propertyName == L\"IsInEditMode\")\r\n+        if (!isnan(newValue))\r\n         {\r\n-            if (senderVM.IsInEditMode())\r\n+            const auto currentValue = UnboxInt32Optional(_Value);\r\n+            if (isnan(currentValue) || static_cast<int32_t>(currentValue) != static_cast<int32_t>(newValue))\r\n             {\r\n-                // Ensure that...\r\n-                // 1. we move focus to the edit mode controls\r\n-                // 2. any actions that were newly added are removed\r\n-                // 3. this is the only entry that is in edit mode\r\n-                for (int32_t i = _KeyBindingList.Size() - 1; i >= 0; --i)\r\n+                Value(box_value(static_cast<int32_t>(newValue)));\r\n+            }\r\n+        }\r\n+        else if (!_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::UInt32BindBack(const double newValue)\r\n+    {\r\n+        if (UnboxUInt32(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<uint32_t>(newValue)));\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::UInt32OptionalBindBack(const double newValue)\r\n+    {\r\n+        if (!isnan(newValue))\r\n+        {\r\n+            const auto currentValue = UnboxUInt32Optional(_Value);\r\n+            if (isnan(currentValue) || static_cast<uint32_t>(currentValue) != static_cast<uint32_t>(newValue))\r\n+            {\r\n+                Value(box_value(static_cast<uint32_t>(newValue)));\r\n+            }\r\n+        }\r\n+        else if (!_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::UInt64BindBack(const double newValue)\r\n+    {\r\n+        if (UnboxUInt64(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<uint64_t>(newValue)));\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::FloatBindBack(const double newValue)\r\n+    {\r\n+        if (UnboxFloat(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<float>(newValue)));\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::BoolOptionalBindBack(const Windows::Foundation::IReference<bool> newValue)\r\n+    {\r\n+        if (newValue)\r\n+        {\r\n+            const auto currentValue = UnboxBoolOptional(_Value);\r\n+            if (!currentValue || currentValue.Value() != newValue.Value())\r\n+            {\r\n+                Value(box_value(newValue));\r\n+            }\r\n+        }\r\n+        else if (_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::TerminalCoreColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue)\r\n+    {\r\n+        if (newValue)\r\n+        {\r\n+            const auto currentValue = UnboxTerminalCoreColorOptional(_Value);\r\n+            if (!currentValue || currentValue.Value() != newValue.Value())\r\n+            {\r\n+                Value(box_value(newValue));\r\n+            }\r\n+        }\r\n+        else if (_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::WindowsUIColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue)\r\n+    {\r\n+        if (newValue)\r\n+        {\r\n+            const auto terminalCoreColor = unbox_value<Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>>(newValue).Value();\r\n+            const Windows::UI::Color winuiColor{\r\n+                .A = terminalCoreColor.A,\r\n+                .R = terminalCoreColor.R,\r\n+                .G = terminalCoreColor.G,\r\n+                .B = terminalCoreColor.B\r\n+            };\r\n+            // only set to the new value if our current value is not the same\r\n+            // unfortunately the Value setter does not do this check properly since\r\n+            // we create a whole new IReference even for the same underlying color\r\n+            if (_Value)\r\n+            {\r\n+                const auto currentValue = unbox_value<Windows::Foundation::IReference<Windows::UI::Color>>(_Value).Value();\r\n+                if (currentValue == winuiColor)\r\n                 {\r\n-                    const auto& kbdVM{ _KeyBindingList.GetAt(i) };\r\n-                    if (senderVM == kbdVM)\r\n+                    return;\r\n+                }\r\n+            }\r\n+            Value(box_value(Windows::Foundation::IReference<Windows::UI::Color>{ winuiColor }));\r\n+        }\r\n+        else if (_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    ActionArgsViewModel::ActionArgsViewModel(const Model::ActionAndArgs actionAndArgs) :\r\n+        _actionAndArgs{ actionAndArgs }\r\n+    {\r\n+    }\r\n+\r\n+    void ActionArgsViewModel::Initialize()\r\n+    {\r\n+        const auto shortcutArgs = _actionAndArgs.Args();\r\n+        if (shortcutArgs)\r\n+        {\r\n+            const auto shortcutArgsNumItems = shortcutArgs.GetArgCount();\r\n+            std::vector<Editor::ArgWrapper> argValues;\r\n+            for (uint32_t i = 0; i < shortcutArgsNumItems; i++)\r\n+            {\r\n+                const auto argAtIndex = shortcutArgs.GetArgAt(i);\r\n+                const auto argDescription = shortcutArgs.GetArgDescriptionAt(i);\r\n+                const auto argName = argDescription.Name;\r\n+                const auto argType = argDescription.Type;\r\n+                const auto argTag = argDescription.Tag;\r\n+                const auto argRequired = argDescription.Required;\r\n+                const auto item = make_self<ArgWrapper>(argName, argType, argRequired, argTag, argAtIndex);\r\n+                item->PropertyChanged([weakThis = get_weak(), i](const IInspectable& sender, const PropertyChangedEventArgs& args) {\r\n+                    if (auto weak = weakThis.get())\r\n                     {\r\n-                        // This is the view model entry that went into edit mode.\r\n-                        // Emit an event to let the page know to move focus to\r\n-                        // this VM's container.\r\n-                        FocusContainer.raise(*this, senderVM);\r\n+                        const auto itemProperty{ args.PropertyName() };\r\n+                        if (itemProperty == L\"Value\")\r\n+                        {\r\n+                            const auto argWrapper = sender.as<Microsoft::Terminal::Settings::Editor::ArgWrapper>();\r\n+                            const auto newValue = argWrapper.Value();\r\n+                            weak->_actionAndArgs.Args().SetArgAt(i, newValue);\r\n+                            weak->WrapperValueChanged.raise(*weak, nullptr);\r\n+                        }\r\n                     }\r\n-                    else if (kbdVM.IsNewlyAdded())\r\n+                });\r\n+                item->ColorSchemeRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+                    if (auto weak = weakThis.get())\r\n                     {\r\n-                        // Remove any actions that were newly added\r\n-                        _KeyBindingList.RemoveAt(i);\r\n+                        if (wrapper)\r\n+                        {\r\n+                            weak->PropagateColorSchemeRequested.raise(*weak, wrapper);\r\n+                        }\r\n                     }\r\n-                    else\r\n+                });\r\n+                item->ColorSchemeNamesRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+                    if (auto weak = weakThis.get())\r\n                     {\r\n-                        // Exit edit mode for all other containers\r\n-                        get_self<KeyBindingViewModel>(kbdVM)->DisableEditMode();\r\n+                        if (wrapper)\r\n+                        {\r\n+                            weak->PropagateColorSchemeNamesRequested.raise(*weak, wrapper);\r\n+                        }\r\n                     }\r\n-                }\r\n-            }\r\n-            else\r\n-            {\r\n-                // Emit an event to let the page know to move focus to\r\n-                // this VM's container.\r\n-                FocusContainer.raise(*this, senderVM);\r\n+                });\r\n+                item->WindowRootRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+                    if (auto weak = weakThis.get())\r\n+                    {\r\n+                        if (wrapper)\r\n+                        {\r\n+                            weak->PropagateWindowRootRequested.raise(*weak, wrapper);\r\n+                        }\r\n+                    }\r\n+                });\r\n+                item->Initialize();\r\n+                argValues.push_back(*item);\r\n             }\r\n \r\n-            // Emit an event to let the page know to update the background of this key binding VM\r\n-            UpdateBackground.raise(*this, senderVM);\r\n+            _ArgValues = single_threaded_observable_vector(std::move(argValues));\r\n         }\r\n     }\r\n \r\n-    void ActionsViewModel::_KeyBindingViewModelDeleteKeyBindingHandler(const Editor::KeyBindingViewModel& senderVM, const Control::KeyChord& keys)\r\n+    bool ActionArgsViewModel::HasArgs() const noexcept\r\n     {\r\n-        // Update the settings model\r\n-        _Settings.ActionMap().DeleteKeyBinding(keys);\r\n+        return _actionAndArgs.Args() != nullptr;\r\n+    }\r\n+\r\n+    void ActionArgsViewModel::ReplaceActionAndArgs(Model::ActionAndArgs newActionAndArgs)\r\n+    {\r\n+        _actionAndArgs = newActionAndArgs;\r\n+    }\r\n+\r\n+    KeyChordViewModel::KeyChordViewModel(Control::KeyChord currentKeys)\r\n+    {\r\n+        CurrentKeys(currentKeys);\r\n+    }\r\n+\r\n+    void KeyChordViewModel::CurrentKeys(const Control::KeyChord& newKeys)\r\n+    {\r\n+        _currentKeys = newKeys;\r\n+        KeyChordText(Model::KeyChordSerialization::ToString(_currentKeys));\r\n+    }\r\n+\r\n+    Control::KeyChord KeyChordViewModel::CurrentKeys() const noexcept\r\n+    {\r\n+        return _currentKeys;\r\n+    }\r\n \r\n-        // Find the current container in our list and remove it.\r\n-        // This is much faster than rebuilding the entire ActionMap.\r\n-        uint32_t index;\r\n-        if (_KeyBindingList.IndexOf(senderVM, index))\r\n+    void KeyChordViewModel::ToggleEditMode()\r\n+    {\r\n+        // toggle edit mode\r\n+        IsInEditMode(!_IsInEditMode);\r\n+        if (_IsInEditMode)\r\n         {\r\n-            _KeyBindingList.RemoveAt(index);\r\n+            // if we're in edit mode,\r\n+            // - pre-populate the text box with the current keys\r\n+            ProposedKeys(_currentKeys);\r\n+        }\r\n+    }\r\n \r\n-            // Focus the new item at this index\r\n-            if (_KeyBindingList.Size() != 0)\r\n+    void KeyChordViewModel::AttemptAcceptChanges()\r\n+    {\r\n+        if (!_currentKeys)\r\n+        {\r\n+            AddKeyChordRequested.raise(*this, _ProposedKeys);\r\n+        }\r\n+        else if (_currentKeys.Modifiers() != _ProposedKeys.Modifiers() || _currentKeys.Vkey() != _ProposedKeys.Vkey())\r\n+        {\r\n+            const auto args{ make_self<ModifyKeyChordEventArgs>(_currentKeys, // OldKeys\r\n+                                                                _ProposedKeys) }; // NewKeys\r\n+            ModifyKeyChordRequested.raise(*this, *args);\r\n+        }\r\n+        else\r\n+        {\r\n+            // no changes being requested, toggle edit mode\r\n+            ToggleEditMode();\r\n+        }\r\n+    }\r\n+\r\n+    void KeyChordViewModel::CancelChanges()\r\n+    {\r\n+        ToggleEditMode();\r\n+    }\r\n+\r\n+    void KeyChordViewModel::DeleteKeyChord()\r\n+    {\r\n+        DeleteKeyChordRequested.raise(*this, _currentKeys);\r\n+    }\r\n+\r\n+    ActionsViewModel::ActionsViewModel(Model::CascadiaSettings settings) :\r\n+        _Settings{ settings }\r\n+    {\r\n+        _MakeCommandVMsHelper();\r\n+    }\r\n+\r\n+    void ActionsViewModel::UpdateSettings(const Model::CascadiaSettings& settings)\r\n+    {\r\n+        _Settings = settings;\r\n+\r\n+        // We want to re-initialize our CommandList, but we want to make sure\r\n+        // we still have the same CurrentCommand as before (if that command still exists)\r\n+\r\n+        // Store the ID of the current command\r\n+        const auto currentCommandID = CurrentCommand() ? CurrentCommand().ID() : hstring{};\r\n+\r\n+        // Re-initialize the command vm list\r\n+        _MakeCommandVMsHelper();\r\n+\r\n+        // Re-select the previously selected command if it exists\r\n+        if (!currentCommandID.empty())\r\n+        {\r\n+            const auto it = _CommandList.First();\r\n+            while (it.HasCurrent())\r\n             {\r\n-                const auto newFocusedIndex{ std::clamp(index, 0u, _KeyBindingList.Size() - 1) };\r\n-                // Emit an event to let the page know to move focus to\r\n-                // this VM's container.\r\n-                FocusContainer.raise(*this, winrt::box_value(newFocusedIndex));\r\n+                auto cmd = *it;\r\n+                if (cmd.ID() == currentCommandID)\r\n+                {\r\n+                    CurrentCommand(cmd);\r\n+                    break;\r\n+                }\r\n+                it.MoveNext();\r\n+            }\r\n+            if (!it.HasCurrent())\r\n+            {\r\n+                // we didn't find the previously selected command\r\n+                CurrentCommand(nullptr);\r\n+                CurrentPage(ActionsSubPage::Base);\r\n             }\r\n         }\r\n+        else\r\n+        {\r\n+            // didn't have a command,\r\n+            // so skip over looking through the command\r\n+            CurrentCommand(nullptr);\r\n+            CurrentPage(ActionsSubPage::Base);\r\n+        }\r\n     }\r\n \r\n-    void ActionsViewModel::_KeyBindingViewModelModifyKeyBindingHandler(const Editor::KeyBindingViewModel& senderVM, const Editor::ModifyKeyBindingEventArgs& args)\r\n+    void ActionsViewModel::_MakeCommandVMsHelper()\r\n     {\r\n-        const auto isNewAction{ !args.OldKeys() && args.OldActionName().empty() };\r\n+        // Populate AvailableActionsAndNames\r\n+        _AvailableActionsAndNamesMap = Model::CascadiaSettings::AvailableShortcutActionsAndNames();\r\n+        for (const auto unimplemented : UnimplementedShortcutActions)\r\n+        {\r\n+            _AvailableActionsAndNamesMap.Remove(unimplemented);\r\n+        }",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2101132701",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18917,
        "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.cpp",
        "discussion_id": "2101132701",
        "commented_code": "@@ -18,383 +24,1194 @@ using namespace winrt::Windows::UI::Xaml::Data;\n using namespace winrt::Windows::UI::Xaml::Navigation;\r\n using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n \r\n+// todo:\r\n+//      multiple actions\r\n+//      selection color\r\n+// the above arg types aren't implemented yet - they all have multiple values within them\r\n+// and require a different approach to binding/displaying. Selection color has color and IsIndex16,\r\n+// multiple actions is... multiple actions\r\n+// for now, do not support these shortcut actions in the new action editor\r\n+inline const std::set<winrt::Microsoft::Terminal::Settings::Model::ShortcutAction> UnimplementedShortcutActions = {\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::MultipleActions,\r\n+    winrt::Microsoft::Terminal::Settings::Model::ShortcutAction::ColorSelection\r\n+};\r\n+\r\n+#define INITIALIZE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_NULLABLE_ENUM_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                       \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> enumList;                                                                          \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                    \\\r\n+    enumType unboxedValue;                                                                                                                                  \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr);          \\\r\n+    if (_Value)                                                                                                                                             \\\r\n+    {                                                                                                                                                       \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                       \\\r\n+    }                                                                                                                                                       \\\r\n+    else                                                                                                                                                    \\\r\n+    {                                                                                                                                                       \\\r\n+        _EnumValue = nullEntry;                                                                                                                             \\\r\n+    }                                                                                                                                                       \\\r\n+    for (const auto [enumKey, enumValue] : mappings)                                                                                                        \\\r\n+    {                                                                                                                                                       \\\r\n+        const auto enumName = LocalizedNameForEnumName(resourceSectionAndType, enumKey, resourceProperty);                                                  \\\r\n+        auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(enumName, winrt::box_value<enumType>(enumValue)); \\\r\n+        enumList.emplace_back(entry);                                                                                                                       \\\r\n+        if (_Value && unboxedValue == enumValue)                                                                                                            \\\r\n+        {                                                                                                                                                   \\\r\n+            _EnumValue = entry;                                                                                                                             \\\r\n+        }                                                                                                                                                   \\\r\n+    }                                                                                                                                                       \\\r\n+    std::sort(enumList.begin(), enumList.end(), EnumEntryReverseComparator<enumType>());                                                                    \\\r\n+    enumList.emplace_back(nullEntry);                                                                                                                       \\\r\n+    _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(enumList));                     \\\r\n+    _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n+\r\n+#define INITIALIZE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                           \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        unboxedValue = unbox_value<enumType>(_Value);                                                                                                                  \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                   \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    auto unboxed = unbox_value<enumType>(_Value);                                                                                                      \\\r\n+                    flagWrapper.IsSet() ? WI_SetAllFlags(unboxed, flagValue) : WI_ClearAllFlags(unboxed, flagValue);                                                   \\\r\n+                    Value(box_value(unboxed));                                                                                                                         \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n+#define INITIALIZE_NULLABLE_FLAG_LIST_AND_VALUE(enumMappingsName, enumType, resourceSectionAndType, resourceProperty)                                                  \\\r\n+    std::vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry> flagList;                                                                                     \\\r\n+    const auto mappings = winrt::Microsoft::Terminal::Settings::Model::EnumMappings::enumMappingsName();                                                               \\\r\n+    enumType unboxedValue{ 0 };                                                                                                                                        \\\r\n+    auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr, true);               \\\r\n+    if (_Value)                                                                                                                                                        \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (const auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value))                                                                    \\\r\n+        {                                                                                                                                                              \\\r\n+            unboxedValue = unboxedRef.Value();                                                                                                                         \\\r\n+            nullEntry.IsSet(false);                                                                                                                                    \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    for (const auto [flagKey, flagValue] : mappings)                                                                                                                   \\\r\n+    {                                                                                                                                                                  \\\r\n+        if (flagKey != L\"all\" && flagKey != L\"none\")                                                                                                                   \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagName = LocalizedNameForEnumName(resourceSectionAndType, flagKey, resourceProperty);                                                         \\\r\n+            bool isSet = WI_IsAnyFlagSet(unboxedValue, flagValue);                                                                                                     \\\r\n+            auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::FlagEntry>(flagName, winrt::box_value<enumType>(flagValue), isSet); \\\r\n+            entry.PropertyChanged([&, flagValue, nullEntry](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                        \\\r\n+                const auto itemProperty{ args.PropertyName() };                                                                                                        \\\r\n+                if (itemProperty == L\"IsSet\")                                                                                                                          \\\r\n+                {                                                                                                                                                      \\\r\n+                    const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                            \\\r\n+                    enumType unboxedValue{ 0 };                                                                                                                        \\\r\n+                    auto unboxedRef = unbox_value<Windows::Foundation::IReference<enumType>>(_Value);                                                                  \\\r\n+                    if (unboxedRef)                                                                                                                                    \\\r\n+                    {                                                                                                                                                  \\\r\n+                        unboxedValue = unboxedRef.Value();                                                                                                             \\\r\n+                    }                                                                                                                                                  \\\r\n+                    if (flagWrapper.IsSet())                                                                                                                           \\\r\n+                    {                                                                                                                                                  \\\r\n+                        nullEntry.IsSet(false);                                                                                                                        \\\r\n+                        WI_SetAllFlags(unboxedValue, flagValue);                                                                                                       \\\r\n+                    }                                                                                                                                                  \\\r\n+                    else                                                                                                                                               \\\r\n+                    {                                                                                                                                                  \\\r\n+                        WI_ClearAllFlags(unboxedValue, flagValue);                                                                                                     \\\r\n+                    }                                                                                                                                                  \\\r\n+                    Value(box_value(unboxedValue));                                                                                                                    \\\r\n+                }                                                                                                                                                      \\\r\n+            });                                                                                                                                                        \\\r\n+            flagList.emplace_back(entry);                                                                                                                              \\\r\n+        }                                                                                                                                                              \\\r\n+    }                                                                                                                                                                  \\\r\n+    std::sort(flagList.begin(), flagList.end(), FlagEntryReverseComparator<enumType>());                                                                               \\\r\n+    nullEntry.PropertyChanged([&](const IInspectable& sender, const PropertyChangedEventArgs& args) {                                                                  \\\r\n+        const auto itemProperty{ args.PropertyName() };                                                                                                                \\\r\n+        if (itemProperty == L\"IsSet\")                                                                                                                                  \\\r\n+        {                                                                                                                                                              \\\r\n+            const auto flagWrapper = sender.as<Microsoft::Terminal::Settings::Editor::FlagEntry>();                                                                    \\\r\n+            if (flagWrapper.IsSet())                                                                                                                                   \\\r\n+            {                                                                                                                                                          \\\r\n+                for (const auto flagEntry : _FlagList)                                                                                                                 \\\r\n+                {                                                                                                                                                      \\\r\n+                    if (flagEntry.FlagName() != RS_(L\"Actions_NullEnumValue\"))                                                                                         \\\r\n+                    {                                                                                                                                                  \\\r\n+                        flagEntry.IsSet(false);                                                                                                                        \\\r\n+                    }                                                                                                                                                  \\\r\n+                }                                                                                                                                                      \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(nullptr)));                                                                                  \\\r\n+            }                                                                                                                                                          \\\r\n+            else                                                                                                                                                       \\\r\n+            {                                                                                                                                                          \\\r\n+                Value(box_value(Windows::Foundation::IReference<enumType>(enumType{ 0 })));                                                                            \\\r\n+            }                                                                                                                                                          \\\r\n+        }                                                                                                                                                              \\\r\n+    });                                                                                                                                                                \\\r\n+    flagList.emplace_back(nullEntry);                                                                                                                                  \\\r\n+    _FlagList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::FlagEntry>(std::move(flagList));                                \\\r\n+    _NotifyChanges(L\"FlagList\");\r\n+\r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    KeyBindingViewModel::KeyBindingViewModel(const IObservableVector<hstring>& availableActions) :\r\n-        KeyBindingViewModel(nullptr, availableActions.First().Current(), availableActions) {}\r\n+    CommandViewModel::CommandViewModel(Command cmd, std::vector<Control::KeyChord> keyChordList, const Editor::ActionsViewModel actionsPageVM, const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames) :\r\n+        _command{ cmd },\r\n+        _keyChordList{ keyChordList },\r\n+        _actionsPageVM{ actionsPageVM },\r\n+        _AvailableActionsAndNamesMap{ availableShortcutActionsAndNames }\r\n+    {\r\n+    }\r\n \r\n-    KeyBindingViewModel::KeyBindingViewModel(const Control::KeyChord& keys, const hstring& actionName, const IObservableVector<hstring>& availableActions) :\r\n-        _CurrentKeys{ keys },\r\n-        _KeyChordText{ KeyChordSerialization::ToString(keys) },\r\n-        _CurrentAction{ actionName },\r\n-        _ProposedAction{ box_value(actionName) },\r\n-        _AvailableActions{ availableActions }\r\n+    void CommandViewModel::Initialize()\r\n     {\r\n+        std::vector<Editor::KeyChordViewModel> keyChordVMs;\r\n+        for (const auto keys : _keyChordList)\r\n+        {\r\n+            auto kcVM{ make<KeyChordViewModel>(keys) };\r\n+            _RegisterKeyChordVMEvents(kcVM);\r\n+            keyChordVMs.push_back(kcVM);\r\n+        }\r\n+        _KeyChordViewModelList = single_threaded_observable_vector(std::move(keyChordVMs));\r\n+\r\n+        std::vector<hstring> shortcutActions;\r\n+        for (const auto [action, name] : _AvailableActionsAndNamesMap)\r\n+        {\r\n+            shortcutActions.emplace_back(name);\r\n+            _NameToActionMap.emplace(name, action);\r\n+        }\r\n+        std::sort(shortcutActions.begin(), shortcutActions.end());\r\n+        _AvailableShortcutActions = single_threaded_observable_vector(std::move(shortcutActions));\r\n+\r\n+        const auto shortcutActionString = _AvailableActionsAndNamesMap.Lookup(_command.ActionAndArgs().Action());\r\n+        ProposedShortcutAction(winrt::box_value(shortcutActionString));\r\n+        _CreateAndInitializeActionArgsVMHelper();\r\n+\r\n         // Add a property changed handler to our own property changed event.\r\n-        // This propagates changes from the settings model to anybody listening to our\r\n-        //  unique view model members.\r\n+        // This allows us to create a new ActionArgsVM when the shortcut action changes\r\n         PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {\r\n             const auto viewModelProperty{ args.PropertyName() };\r\n-            if (viewModelProperty == L\"CurrentKeys\")\r\n+            if (viewModelProperty == L\"ProposedShortcutAction\")\r\n             {\r\n-                _KeyChordText = KeyChordSerialization::ToString(_CurrentKeys);\r\n-                _NotifyChanges(L\"KeyChordText\");\r\n+                const auto actionString = unbox_value<hstring>(ProposedShortcutAction());\r\n+                const auto actionEnum = _NameToActionMap.at(actionString);\r\n+                const auto emptyArgs = CascadiaSettings::GetEmptyArgsForAction(actionEnum);\r\n+                // todo: probably need some better default values for empty args\r\n+                // eg. for sendInput, where \"input\" is a required argument, \"input\" gets set to an empty string which does not satisfy the requirement\r\n+                // i.e. if the user hits \"save\" immediately after switching to sendInput as the action (without adding something to the input field), they'll get an error\r\n+                // there are some other cases as well\r\n+                Model::ActionAndArgs newActionAndArgs{ actionEnum, emptyArgs };\r\n+                _command.ActionAndArgs(newActionAndArgs);\r\n+                if (_IsNewCommand)\r\n+                {\r\n+                    _command.GenerateID();\r\n+                }\r\n+                else if (!IsUserAction())\r\n+                {\r\n+                    _ReplaceCommandWithUserCopy(true);\r\n+                    return;\r\n+                }\r\n+                _CreateAndInitializeActionArgsVMHelper();\r\n             }\r\n-            else if (viewModelProperty == L\"IsContainerFocused\" ||\r\n-                     viewModelProperty == L\"IsEditButtonFocused\" ||\r\n-                     viewModelProperty == L\"IsHovered\" ||\r\n-                     viewModelProperty == L\"IsAutomationPeerAttached\" ||\r\n-                     viewModelProperty == L\"IsInEditMode\")\r\n+        });\r\n+    }\r\n+\r\n+    winrt::hstring CommandViewModel::DisplayName()\r\n+    {\r\n+        return _command.Name();\r\n+    }\r\n+\r\n+    winrt::hstring CommandViewModel::Name()\r\n+    {\r\n+        if (_command.HasName())\r\n+        {\r\n+            return _command.Name();\r\n+        }\r\n+        return L\"\";\r\n+    }\r\n+\r\n+    void CommandViewModel::Name(const winrt::hstring& newName)\r\n+    {\r\n+        if (!newName.empty())\r\n+        {\r\n+            _command.Name(newName);\r\n+        }\r\n+    }\r\n+\r\n+    winrt::hstring CommandViewModel::ID()\r\n+    {\r\n+        return _command.ID();\r\n+    }\r\n+\r\n+    void CommandViewModel::ID(const winrt::hstring& ID)\r\n+    {\r\n+        _command.ID(ID);\r\n+    }\r\n+\r\n+    bool CommandViewModel::IsUserAction()\r\n+    {\r\n+        return _command.Origin() == OriginTag::User;\r\n+    }\r\n+\r\n+    void CommandViewModel::Edit_Click()\r\n+    {\r\n+        EditRequested.raise(*this, *this);\r\n+    }\r\n+\r\n+    void CommandViewModel::Delete_Click()\r\n+    {\r\n+        DeleteRequested.raise(*this, *this);\r\n+    }\r\n+\r\n+    void CommandViewModel::AddKeybinding_Click()\r\n+    {\r\n+        auto kbdVM{ make_self<KeyChordViewModel>(nullptr) };\r\n+        kbdVM->IsInEditMode(true);\r\n+        _RegisterKeyChordVMEvents(*kbdVM);\r\n+        KeyChordViewModelList().Append(*kbdVM);\r\n+    }\r\n+\r\n+    void CommandViewModel::_RegisterKeyChordVMEvents(Editor::KeyChordViewModel kcVM)\r\n+    {\r\n+        if (const auto actionsPageVM{ _actionsPageVM.get() })\r\n+        {\r\n+            const auto id = ID();\r\n+            kcVM.AddKeyChordRequested([actionsPageVM, id](const Editor::KeyChordViewModel& sender, const Control::KeyChord& keys) {\r\n+                actionsPageVM.AttemptAddOrModifyKeyChord(sender, id, keys, nullptr);\r\n+            });\r\n+            kcVM.ModifyKeyChordRequested([actionsPageVM, id](const Editor::KeyChordViewModel& sender, const Editor::ModifyKeyChordEventArgs& args) {\r\n+                actionsPageVM.AttemptAddOrModifyKeyChord(sender, id, args.NewKeys(), args.OldKeys());\r\n+            });\r\n+            kcVM.DeleteKeyChordRequested([&, actionsPageVM](const Editor::KeyChordViewModel& sender, const Control::KeyChord& args) {\r\n+                _keyChordList.erase(\r\n+                    std::remove_if(\r\n+                        _keyChordList.begin(),\r\n+                        _keyChordList.end(),\r\n+                        [&](const Control::KeyChord& kc) { return kc == args; }),\r\n+                    _keyChordList.end());\r\n+                for (uint32_t i = 0; i < _KeyChordViewModelList.Size(); i++)\r\n+                {\r\n+                    if (_KeyChordViewModelList.GetAt(i) == sender)\r\n+                    {\r\n+                        KeyChordViewModelList().RemoveAt(i);\r\n+                        break;\r\n+                    }\r\n+                }\r\n+                actionsPageVM.AttemptDeleteKeyChord(args);\r\n+            });\r\n+        }\r\n+    }\r\n+\r\n+    void CommandViewModel::_RegisterActionArgsVMEvents(Editor::ActionArgsViewModel actionArgsVM)\r\n+    {\r\n+        actionArgsVM.PropagateColorSchemeRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+            if (auto weak = weakThis.get())\r\n             {\r\n-                _NotifyChanges(L\"ShowEditButton\");\r\n+                if (wrapper)\r\n+                {\r\n+                    weak->PropagateColorSchemeRequested.raise(*weak, wrapper);\r\n+                }\r\n+            }\r\n+        });\r\n+        actionArgsVM.PropagateColorSchemeNamesRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+            if (auto weak = weakThis.get())\r\n+            {\r\n+                if (wrapper)\r\n+                {\r\n+                    weak->PropagateColorSchemeNamesRequested.raise(*weak, wrapper);\r\n+                }\r\n             }\r\n-            else if (viewModelProperty == L\"CurrentAction\")\r\n+        });\r\n+        actionArgsVM.PropagateWindowRootRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+            if (auto weak = weakThis.get())\r\n             {\r\n-                _NotifyChanges(L\"Name\");\r\n+                if (wrapper)\r\n+                {\r\n+                    weak->PropagateWindowRootRequested.raise(*weak, wrapper);\r\n+                }\r\n             }\r\n         });\r\n+        if (_IsNewCommand)\r\n+        {\r\n+            // for new commands, make sure we generate a new ID everytime any arg value changes\r\n+            actionArgsVM.WrapperValueChanged([weakThis = get_weak()](const IInspectable& /*sender*/, const IInspectable& /*args*/) {\r\n+                if (auto weak = weakThis.get())\r\n+                {\r\n+                    weak->_command.GenerateID();\r\n+                }\r\n+            });\r\n+        }\r\n+        else if (!IsUserAction())\r\n+        {\r\n+            actionArgsVM.WrapperValueChanged([weakThis = get_weak()](const IInspectable& /*sender*/, const IInspectable& /*args*/) {\r\n+                if (auto weak = weakThis.get())\r\n+                {\r\n+                    weak->_ReplaceCommandWithUserCopy(false);\r\n+                }\r\n+            });\r\n+        }\r\n+    }\r\n+\r\n+    void CommandViewModel::_ReplaceCommandWithUserCopy(bool reinitialize)\r\n+    {\r\n+        // the user is attempting to edit an in-box action\r\n+        // to handle this, we create a new command with the new values that has the same ID as the in-box action\r\n+        // swap out our underlying command with the copy, tell the ActionsVM that the copy needs to be added to the action map\r\n+        if (const auto actionsPageVM{ _actionsPageVM.get() })\r\n+        {\r\n+            const auto newCmd = Model::Command::CopyAsUserCommand(_command);\r\n+            _command = newCmd;\r\n+            actionsPageVM.AttemptAddCopiedCommand(_command);\r\n+            if (reinitialize)\r\n+            {\r\n+                // full reinitialize needed, recreate the action args VM\r\n+                // (this happens when the shortcut action is being changed on an in-box action)\r\n+                _CreateAndInitializeActionArgsVMHelper();\r\n+            }\r\n+            else\r\n+            {\r\n+                // no need to reinitialize, just swap out the underlying data model\r\n+                // (this happens when an additional argument is being changed on an in-box action)\r\n+                auto actionArgsVMImpl{ get_self<ActionArgsViewModel>(_ActionArgsVM) };\r\n+                actionArgsVMImpl->ReplaceActionAndArgs(_command.ActionAndArgs());\r\n+            }\r\n+        }\r\n     }\r\n \r\n-    hstring KeyBindingViewModel::EditButtonName() const noexcept { return RS_(L\"Actions_EditButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n-    hstring KeyBindingViewModel::CancelButtonName() const noexcept { return RS_(L\"Actions_CancelButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n-    hstring KeyBindingViewModel::AcceptButtonName() const noexcept { return RS_(L\"Actions_AcceptButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n-    hstring KeyBindingViewModel::DeleteButtonName() const noexcept { return RS_(L\"Actions_DeleteButton/[using:Windows.UI.Xaml.Controls]ToolTipService/ToolTip\"); }\r\n+    void CommandViewModel::_CreateAndInitializeActionArgsVMHelper()\r\n+    {\r\n+        const auto actionArgsVM = make_self<ActionArgsViewModel>(_command.ActionAndArgs());\r\n+        _RegisterActionArgsVMEvents(*actionArgsVM);\r\n+        actionArgsVM->Initialize();\r\n+        ActionArgsVM(*actionArgsVM);\r\n+        _NotifyChanges(L\"DisplayName\");\r\n+    }\r\n \r\n-    bool KeyBindingViewModel::ShowEditButton() const noexcept\r\n+    ArgWrapper::ArgWrapper(const winrt::hstring& name, const winrt::hstring& type, const bool required, const Model::ArgTag tag, const Windows::Foundation::IInspectable& value) :\r\n+        _name{ name },\r\n+        _type{ type },\r\n+        _tag{ tag },\r\n+        _required{ required }\r\n     {\r\n-        return (IsContainerFocused() || IsEditButtonFocused() || IsHovered() || IsAutomationPeerAttached()) && !IsInEditMode();\r\n+        Value(value);\r\n     }\r\n \r\n-    void KeyBindingViewModel::ToggleEditMode()\r\n+    void ArgWrapper::Initialize()\r\n     {\r\n-        // toggle edit mode\r\n-        IsInEditMode(!_IsInEditMode);\r\n-        if (_IsInEditMode)\r\n+        if (_type == L\"Model::ResizeDirection\")\r\n         {\r\n-            // if we're in edit mode,\r\n-            // - prepopulate the text box with the current keys\r\n-            // - reset the combo box with the current action\r\n-            ProposedKeys(_CurrentKeys);\r\n-            ProposedAction(box_value(_CurrentAction));\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(ResizeDirection, Model::ResizeDirection, L\"Actions_ResizeDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::FocusDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(FocusDirection, Model::FocusDirection, L\"Actions_FocusDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SettingsTarget\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SettingsTarget, Model::SettingsTarget, L\"Actions_SettingsTarget\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"MoveTabDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(MoveTabDirection, Model::MoveTabDirection, L\"Actions_MoveTabDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Microsoft::Terminal::Control::ScrollToMarkDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(ScrollToMarkDirection, Control::ScrollToMarkDirection, L\"Actions_ScrollToMarkDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"CommandPaletteLaunchMode\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(CommandPaletteLaunchMode, Model::CommandPaletteLaunchMode, L\"Actions_CommandPaletteLaunchMode\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SuggestionsSource\")\r\n+        {\r\n+            INITIALIZE_FLAG_LIST_AND_VALUE(SuggestionsSource, Model::SuggestionsSource, L\"Actions_SuggestionsSource\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"FindMatchDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(FindMatchDirection, Model::FindMatchDirection, L\"Actions_FindMatchDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::DesktopBehavior\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(DesktopBehavior, Model::DesktopBehavior, L\"Actions_DesktopBehavior\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::MonitorBehavior\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(MonitorBehavior, Model::MonitorBehavior, L\"Actions_MonitorBehavior\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"winrt::Microsoft::Terminal::Control::ClearBufferType\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(ClearBufferType, Control::ClearBufferType, L\"Actions_ClearBufferType\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SelectOutputDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SelectOutputDirection, Model::SelectOutputDirection, L\"Actions_SelectOutputDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Model::SplitDirection\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SplitDirection, Model::SplitDirection, L\"Actions_SplitDirection\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"SplitType\")\r\n+        {\r\n+            INITIALIZE_ENUM_LIST_AND_VALUE(SplitType, Model::SplitType, L\"Actions_SplitType\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Windows::Foundation::IReference<TabSwitcherMode>\")\r\n+        {\r\n+            INITIALIZE_NULLABLE_ENUM_LIST_AND_VALUE(TabSwitcherMode, Model::TabSwitcherMode, L\"Actions_TabSwitcherMode\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Windows::Foundation::IReference<Control::CopyFormat>\")\r\n+        {\r\n+            INITIALIZE_NULLABLE_FLAG_LIST_AND_VALUE(CopyFormat, Control::CopyFormat, L\"Actions_CopyFormat\", L\"Content\");\r\n+        }\r\n+        else if (_type == L\"Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>\" ||\r\n+                 _type == L\"Windows::Foundation::IReference<Windows::UI::Color>\")\r\n+        {\r\n+            ColorSchemeRequested.raise(*this, *this);\r\n+        }\r\n+        else if (_tag == Model::ArgTag::ColorScheme)\r\n+        {\r\n+            // special case of string, emit an event letting the actionsVM know we need the list of color scheme names\r\n+            ColorSchemeNamesRequested.raise(*this, *this);\r\n+\r\n+            // even though the arg type is technically a string, we want an enum list for color schemes specifically\r\n+            std::vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry> namesList;\r\n+            const auto currentSchemeName = unbox_value<winrt::hstring>(_Value);\r\n+            auto nullEntry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(RS_(L\"Actions_NullEnumValue\"), nullptr);\r\n+            if (currentSchemeName.empty())\r\n+            {\r\n+                _EnumValue = nullEntry;\r\n+            }\r\n+            for (const auto colorSchemeName : _ColorSchemeNamesList)\r\n+            {\r\n+                // eventually we will want to use localized names for the enum entries, for now just use what the settings model gives us\r\n+                auto entry = winrt::make<winrt::Microsoft::Terminal::Settings::Editor::implementation::EnumEntry>(colorSchemeName, winrt::box_value(colorSchemeName));\r\n+                namesList.emplace_back(entry);\r\n+                if (currentSchemeName == colorSchemeName)\r\n+                {\r\n+                    _EnumValue = entry;\r\n+                }\r\n+            }\r\n+            std::sort(namesList.begin(), namesList.end(), EnumEntryReverseComparator<winrt::hstring>());\r\n+            namesList.emplace_back(nullEntry);\r\n+            _EnumList = winrt::single_threaded_observable_vector<winrt::Microsoft::Terminal::Settings::Editor::EnumEntry>(std::move(namesList));\r\n+            _NotifyChanges(L\"EnumList\", L\"EnumValue\");\r\n         }\r\n     }\r\n \r\n-    void KeyBindingViewModel::AttemptAcceptChanges()\r\n+    safe_void_coroutine ArgWrapper::Browse_Click(const IInspectable&, const RoutedEventArgs&)\r\n     {\r\n-        AttemptAcceptChanges(_ProposedKeys);\r\n+        WindowRootRequested.raise(*this, *this);\r\n+        auto lifetime = get_strong();\r\n+\r\n+        static constexpr winrt::guid clientGuidFiles{ 0xbd00ae34, 0x839b, 0x43f6, { 0x8b, 0x94, 0x12, 0x37, 0x1a, 0xfe, 0xea, 0xb5 } };\r\n+        const auto parentHwnd{ reinterpret_cast<HWND>(_WindowRoot.GetHostingWindow()) };\r\n+        auto path = co_await OpenFilePicker(parentHwnd, [](auto&& dialog) {\r\n+            THROW_IF_FAILED(dialog->SetClientGuid(clientGuidFiles));\r\n+            try\r\n+            {\r\n+                auto folderShellItem{ winrt::capture<IShellItem>(&SHGetKnownFolderItem, FOLDERID_ComputerFolder, KF_FLAG_DEFAULT, nullptr) };\r\n+                dialog->SetDefaultFolder(folderShellItem.get());\r\n+            }\r\n+            CATCH_LOG(); // non-fatal\r\n+        });\r\n+\r\n+        if (!path.empty())\r\n+        {\r\n+            StringBindBack(path);\r\n+        }\r\n     }\r\n \r\n-    void KeyBindingViewModel::AttemptAcceptChanges(const Control::KeyChord newKeys)\r\n+    void ArgWrapper::EnumValue(const Windows::Foundation::IInspectable& enumValue)\r\n     {\r\n-        const auto args{ make_self<ModifyKeyBindingEventArgs>(_CurrentKeys, // OldKeys\r\n-                                                              newKeys, // NewKeys\r\n-                                                              _IsNewlyAdded ? hstring{} : _CurrentAction, // OldAction\r\n-                                                              unbox_value<hstring>(_ProposedAction)) }; // NewAction\r\n-        ModifyKeyBindingRequested.raise(*this, *args);\r\n+        if (_EnumValue != enumValue)\r\n+        {\r\n+            _EnumValue = enumValue;\r\n+            Value(_EnumValue.as<Editor::EnumEntry>().EnumValue());\r\n+        }\r\n     }\r\n \r\n-    void KeyBindingViewModel::CancelChanges()\r\n+    winrt::hstring ArgWrapper::UnboxString(const Windows::Foundation::IInspectable& value)\r\n     {\r\n-        if (_IsNewlyAdded)\r\n+        return winrt::unbox_value<winrt::hstring>(value);\r\n+    }\r\n+\r\n+    winrt::hstring ArgWrapper::UnboxGuid(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::to_hstring(winrt::unbox_value<winrt::guid>(value));\r\n+    }\r\n+\r\n+    int32_t ArgWrapper::UnboxInt32(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<int32_t>(value);\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxInt32Optional(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        const auto unboxed = winrt::unbox_value<winrt::Windows::Foundation::IReference<int32_t>>(value);\r\n+        if (unboxed)\r\n         {\r\n-            DeleteNewlyAddedKeyBinding.raise(*this, nullptr);\r\n+            return static_cast<float>(unboxed.Value());\r\n         }\r\n         else\r\n         {\r\n-            ToggleEditMode();\r\n+            return NAN;\r\n         }\r\n     }\r\n \r\n-    ActionsViewModel::ActionsViewModel(Model::CascadiaSettings settings) :\r\n-        _Settings{ settings }\r\n+    uint32_t ArgWrapper::UnboxUInt32(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<uint32_t>(value);\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxUInt32Optional(const Windows::Foundation::IInspectable& value)\r\n     {\r\n-        // Populate AvailableActionAndArgs\r\n-        _AvailableActionMap = single_threaded_map<hstring, Model::ActionAndArgs>();\r\n-        std::vector<hstring> availableActionAndArgs;\r\n-        for (const auto& [name, actionAndArgs] : _Settings.ActionMap().AvailableActions())\r\n+        const auto unboxed = winrt::unbox_value<winrt::Windows::Foundation::IReference<uint32_t>>(value);\r\n+        if (unboxed)\r\n         {\r\n-            availableActionAndArgs.push_back(name);\r\n-            _AvailableActionMap.Insert(name, actionAndArgs);\r\n+            return static_cast<float>(unboxed.Value());\r\n         }\r\n-        std::sort(begin(availableActionAndArgs), end(availableActionAndArgs));\r\n-        _AvailableActionAndArgs = single_threaded_observable_vector(std::move(availableActionAndArgs));\r\n+        else\r\n+        {\r\n+            return NAN;\r\n+        }\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxUInt64(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return static_cast<float>(winrt::unbox_value<uint64_t>(value));\r\n+    }\r\n+\r\n+    float ArgWrapper::UnboxFloat(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<float>(value);\r\n+    }\r\n \r\n-        // Convert the key bindings from our settings into a view model representation\r\n-        const auto& keyBindingMap{ _Settings.ActionMap().KeyBindings() };\r\n-        std::vector<Editor::KeyBindingViewModel> keyBindingList;\r\n-        keyBindingList.reserve(keyBindingMap.Size());\r\n-        for (const auto& [keys, cmd] : keyBindingMap)\r\n+    bool ArgWrapper::UnboxBool(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        return winrt::unbox_value<bool>(value);\r\n+    }\r\n+\r\n+    winrt::Windows::Foundation::IReference<bool> ArgWrapper::UnboxBoolOptional(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        if (!value)\r\n         {\r\n-            // convert the cmd into a KeyBindingViewModel\r\n-            auto container{ make_self<KeyBindingViewModel>(keys, cmd.Name(), _AvailableActionAndArgs) };\r\n-            _RegisterEvents(container);\r\n-            keyBindingList.push_back(*container);\r\n+            return nullptr;\r\n         }\r\n+        return winrt::unbox_value<winrt::Windows::Foundation::IReference<bool>>(value);\r\n+    }\r\n \r\n-        std::sort(begin(keyBindingList), end(keyBindingList), KeyBindingViewModelComparator{});\r\n-        _KeyBindingList = single_threaded_observable_vector(std::move(keyBindingList));\r\n+    winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> ArgWrapper::UnboxTerminalCoreColorOptional(const Windows::Foundation::IInspectable& value)\r\n+    {\r\n+        if (value)\r\n+        {\r\n+            return unbox_value<Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>>(value);\r\n+        }\r\n+        else\r\n+        {\r\n+            return nullptr;\r\n+        }\r\n     }\r\n \r\n-    void ActionsViewModel::OnAutomationPeerAttached()\r\n+    winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> ArgWrapper::UnboxWindowsUIColorOptional(const Windows::Foundation::IInspectable& value)\r\n     {\r\n-        _AutomationPeerAttached = true;\r\n-        for (const auto& kbdVM : _KeyBindingList)\r\n+        if (value)\r\n+        {\r\n+            const auto winUIColor = unbox_value<Windows::Foundation::IReference<Windows::UI::Color>>(value).Value();\r\n+            const Microsoft::Terminal::Core::Color terminalColor{ winUIColor.R, winUIColor.G, winUIColor.B, winUIColor.A };\r\n+            return Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>{ terminalColor };\r\n+        }\r\n+        else\r\n         {\r\n-            // To create a more accessible experience, we want the \"edit\" buttons to _always_\r\n-            // appear when a screen reader is attached. This ensures that the edit buttons are\r\n-            // accessible via the UIA tree.\r\n-            get_self<KeyBindingViewModel>(kbdVM)->IsAutomationPeerAttached(_AutomationPeerAttached);\r\n+            return nullptr;\r\n         }\r\n     }\r\n \r\n-    void ActionsViewModel::AddNewKeybinding()\r\n+    void ArgWrapper::StringBindBack(const winrt::hstring& newValue)\r\n     {\r\n-        // Create the new key binding and register all of the event handlers.\r\n-        auto kbdVM{ make_self<KeyBindingViewModel>(_AvailableActionAndArgs) };\r\n-        _RegisterEvents(kbdVM);\r\n-        kbdVM->DeleteNewlyAddedKeyBinding({ this, &ActionsViewModel::_KeyBindingViewModelDeleteNewlyAddedKeyBindingHandler });\r\n+        if (UnboxString(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(newValue));\r\n+        }\r\n+    }\r\n \r\n-        // Manually add the editing background. This needs to be done in Actions not the view model.\r\n-        // We also have to do this manually because it hasn't been added to the list yet.\r\n-        kbdVM->IsInEditMode(true);\r\n-        // Emit an event to let the page know to update the background of this key binding VM\r\n-        UpdateBackground.raise(*this, *kbdVM);\r\n+    void ArgWrapper::GuidBindBack(const winrt::hstring& newValue)\r\n+    {\r\n+        if (UnboxGuid(_Value) != newValue)\r\n+        {\r\n+            // todo: probably need some validation?\r\n+            Value(box_value(winrt::guid{ newValue }));\r\n+        }\r\n+    }\r\n \r\n-        // IMPORTANT: do this _after_ setting IsInEditMode. Otherwise, it'll get deleted immediately\r\n-        //              by the PropertyChangedHandler below (where we delete any IsNewlyAdded items)\r\n-        kbdVM->IsNewlyAdded(true);\r\n-        _KeyBindingList.InsertAt(0, *kbdVM);\r\n-        FocusContainer.raise(*this, *kbdVM);\r\n+    void ArgWrapper::Int32BindBack(const double newValue)\r\n+    {\r\n+        if (UnboxInt32(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<int32_t>(newValue)));\r\n+        }\r\n     }\r\n \r\n-    void ActionsViewModel::_KeyBindingViewModelPropertyChangedHandler(const IInspectable& sender, const Windows::UI::Xaml::Data::PropertyChangedEventArgs& args)\r\n+    void ArgWrapper::Int32OptionalBindBack(const double newValue)\r\n     {\r\n-        const auto senderVM{ sender.as<Editor::KeyBindingViewModel>() };\r\n-        const auto propertyName{ args.PropertyName() };\r\n-        if (propertyName == L\"IsInEditMode\")\r\n+        if (!isnan(newValue))\r\n         {\r\n-            if (senderVM.IsInEditMode())\r\n+            const auto currentValue = UnboxInt32Optional(_Value);\r\n+            if (isnan(currentValue) || static_cast<int32_t>(currentValue) != static_cast<int32_t>(newValue))\r\n             {\r\n-                // Ensure that...\r\n-                // 1. we move focus to the edit mode controls\r\n-                // 2. any actions that were newly added are removed\r\n-                // 3. this is the only entry that is in edit mode\r\n-                for (int32_t i = _KeyBindingList.Size() - 1; i >= 0; --i)\r\n+                Value(box_value(static_cast<int32_t>(newValue)));\r\n+            }\r\n+        }\r\n+        else if (!_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::UInt32BindBack(const double newValue)\r\n+    {\r\n+        if (UnboxUInt32(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<uint32_t>(newValue)));\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::UInt32OptionalBindBack(const double newValue)\r\n+    {\r\n+        if (!isnan(newValue))\r\n+        {\r\n+            const auto currentValue = UnboxUInt32Optional(_Value);\r\n+            if (isnan(currentValue) || static_cast<uint32_t>(currentValue) != static_cast<uint32_t>(newValue))\r\n+            {\r\n+                Value(box_value(static_cast<uint32_t>(newValue)));\r\n+            }\r\n+        }\r\n+        else if (!_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::UInt64BindBack(const double newValue)\r\n+    {\r\n+        if (UnboxUInt64(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<uint64_t>(newValue)));\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::FloatBindBack(const double newValue)\r\n+    {\r\n+        if (UnboxFloat(_Value) != newValue)\r\n+        {\r\n+            Value(box_value(static_cast<float>(newValue)));\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::BoolOptionalBindBack(const Windows::Foundation::IReference<bool> newValue)\r\n+    {\r\n+        if (newValue)\r\n+        {\r\n+            const auto currentValue = UnboxBoolOptional(_Value);\r\n+            if (!currentValue || currentValue.Value() != newValue.Value())\r\n+            {\r\n+                Value(box_value(newValue));\r\n+            }\r\n+        }\r\n+        else if (_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::TerminalCoreColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue)\r\n+    {\r\n+        if (newValue)\r\n+        {\r\n+            const auto currentValue = UnboxTerminalCoreColorOptional(_Value);\r\n+            if (!currentValue || currentValue.Value() != newValue.Value())\r\n+            {\r\n+                Value(box_value(newValue));\r\n+            }\r\n+        }\r\n+        else if (_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    void ArgWrapper::WindowsUIColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue)\r\n+    {\r\n+        if (newValue)\r\n+        {\r\n+            const auto terminalCoreColor = unbox_value<Windows::Foundation::IReference<Microsoft::Terminal::Core::Color>>(newValue).Value();\r\n+            const Windows::UI::Color winuiColor{\r\n+                .A = terminalCoreColor.A,\r\n+                .R = terminalCoreColor.R,\r\n+                .G = terminalCoreColor.G,\r\n+                .B = terminalCoreColor.B\r\n+            };\r\n+            // only set to the new value if our current value is not the same\r\n+            // unfortunately the Value setter does not do this check properly since\r\n+            // we create a whole new IReference even for the same underlying color\r\n+            if (_Value)\r\n+            {\r\n+                const auto currentValue = unbox_value<Windows::Foundation::IReference<Windows::UI::Color>>(_Value).Value();\r\n+                if (currentValue == winuiColor)\r\n                 {\r\n-                    const auto& kbdVM{ _KeyBindingList.GetAt(i) };\r\n-                    if (senderVM == kbdVM)\r\n+                    return;\r\n+                }\r\n+            }\r\n+            Value(box_value(Windows::Foundation::IReference<Windows::UI::Color>{ winuiColor }));\r\n+        }\r\n+        else if (_Value)\r\n+        {\r\n+            Value(nullptr);\r\n+        }\r\n+    }\r\n+\r\n+    ActionArgsViewModel::ActionArgsViewModel(const Model::ActionAndArgs actionAndArgs) :\r\n+        _actionAndArgs{ actionAndArgs }\r\n+    {\r\n+    }\r\n+\r\n+    void ActionArgsViewModel::Initialize()\r\n+    {\r\n+        const auto shortcutArgs = _actionAndArgs.Args();\r\n+        if (shortcutArgs)\r\n+        {\r\n+            const auto shortcutArgsNumItems = shortcutArgs.GetArgCount();\r\n+            std::vector<Editor::ArgWrapper> argValues;\r\n+            for (uint32_t i = 0; i < shortcutArgsNumItems; i++)\r\n+            {\r\n+                const auto argAtIndex = shortcutArgs.GetArgAt(i);\r\n+                const auto argDescription = shortcutArgs.GetArgDescriptionAt(i);\r\n+                const auto argName = argDescription.Name;\r\n+                const auto argType = argDescription.Type;\r\n+                const auto argTag = argDescription.Tag;\r\n+                const auto argRequired = argDescription.Required;\r\n+                const auto item = make_self<ArgWrapper>(argName, argType, argRequired, argTag, argAtIndex);\r\n+                item->PropertyChanged([weakThis = get_weak(), i](const IInspectable& sender, const PropertyChangedEventArgs& args) {\r\n+                    if (auto weak = weakThis.get())\r\n                     {\r\n-                        // This is the view model entry that went into edit mode.\r\n-                        // Emit an event to let the page know to move focus to\r\n-                        // this VM's container.\r\n-                        FocusContainer.raise(*this, senderVM);\r\n+                        const auto itemProperty{ args.PropertyName() };\r\n+                        if (itemProperty == L\"Value\")\r\n+                        {\r\n+                            const auto argWrapper = sender.as<Microsoft::Terminal::Settings::Editor::ArgWrapper>();\r\n+                            const auto newValue = argWrapper.Value();\r\n+                            weak->_actionAndArgs.Args().SetArgAt(i, newValue);\r\n+                            weak->WrapperValueChanged.raise(*weak, nullptr);\r\n+                        }\r\n                     }\r\n-                    else if (kbdVM.IsNewlyAdded())\r\n+                });\r\n+                item->ColorSchemeRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+                    if (auto weak = weakThis.get())\r\n                     {\r\n-                        // Remove any actions that were newly added\r\n-                        _KeyBindingList.RemoveAt(i);\r\n+                        if (wrapper)\r\n+                        {\r\n+                            weak->PropagateColorSchemeRequested.raise(*weak, wrapper);\r\n+                        }\r\n                     }\r\n-                    else\r\n+                });\r\n+                item->ColorSchemeNamesRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+                    if (auto weak = weakThis.get())\r\n                     {\r\n-                        // Exit edit mode for all other containers\r\n-                        get_self<KeyBindingViewModel>(kbdVM)->DisableEditMode();\r\n+                        if (wrapper)\r\n+                        {\r\n+                            weak->PropagateColorSchemeNamesRequested.raise(*weak, wrapper);\r\n+                        }\r\n                     }\r\n-                }\r\n-            }\r\n-            else\r\n-            {\r\n-                // Emit an event to let the page know to move focus to\r\n-                // this VM's container.\r\n-                FocusContainer.raise(*this, senderVM);\r\n+                });\r\n+                item->WindowRootRequested([weakThis = get_weak()](const IInspectable& /*sender*/, const Editor::ArgWrapper& wrapper) {\r\n+                    if (auto weak = weakThis.get())\r\n+                    {\r\n+                        if (wrapper)\r\n+                        {\r\n+                            weak->PropagateWindowRootRequested.raise(*weak, wrapper);\r\n+                        }\r\n+                    }\r\n+                });\r\n+                item->Initialize();\r\n+                argValues.push_back(*item);\r\n             }\r\n \r\n-            // Emit an event to let the page know to update the background of this key binding VM\r\n-            UpdateBackground.raise(*this, senderVM);\r\n+            _ArgValues = single_threaded_observable_vector(std::move(argValues));\r\n         }\r\n     }\r\n \r\n-    void ActionsViewModel::_KeyBindingViewModelDeleteKeyBindingHandler(const Editor::KeyBindingViewModel& senderVM, const Control::KeyChord& keys)\r\n+    bool ActionArgsViewModel::HasArgs() const noexcept\r\n     {\r\n-        // Update the settings model\r\n-        _Settings.ActionMap().DeleteKeyBinding(keys);\r\n+        return _actionAndArgs.Args() != nullptr;\r\n+    }\r\n+\r\n+    void ActionArgsViewModel::ReplaceActionAndArgs(Model::ActionAndArgs newActionAndArgs)\r\n+    {\r\n+        _actionAndArgs = newActionAndArgs;\r\n+    }\r\n+\r\n+    KeyChordViewModel::KeyChordViewModel(Control::KeyChord currentKeys)\r\n+    {\r\n+        CurrentKeys(currentKeys);\r\n+    }\r\n+\r\n+    void KeyChordViewModel::CurrentKeys(const Control::KeyChord& newKeys)\r\n+    {\r\n+        _currentKeys = newKeys;\r\n+        KeyChordText(Model::KeyChordSerialization::ToString(_currentKeys));\r\n+    }\r\n+\r\n+    Control::KeyChord KeyChordViewModel::CurrentKeys() const noexcept\r\n+    {\r\n+        return _currentKeys;\r\n+    }\r\n \r\n-        // Find the current container in our list and remove it.\r\n-        // This is much faster than rebuilding the entire ActionMap.\r\n-        uint32_t index;\r\n-        if (_KeyBindingList.IndexOf(senderVM, index))\r\n+    void KeyChordViewModel::ToggleEditMode()\r\n+    {\r\n+        // toggle edit mode\r\n+        IsInEditMode(!_IsInEditMode);\r\n+        if (_IsInEditMode)\r\n         {\r\n-            _KeyBindingList.RemoveAt(index);\r\n+            // if we're in edit mode,\r\n+            // - pre-populate the text box with the current keys\r\n+            ProposedKeys(_currentKeys);\r\n+        }\r\n+    }\r\n \r\n-            // Focus the new item at this index\r\n-            if (_KeyBindingList.Size() != 0)\r\n+    void KeyChordViewModel::AttemptAcceptChanges()\r\n+    {\r\n+        if (!_currentKeys)\r\n+        {\r\n+            AddKeyChordRequested.raise(*this, _ProposedKeys);\r\n+        }\r\n+        else if (_currentKeys.Modifiers() != _ProposedKeys.Modifiers() || _currentKeys.Vkey() != _ProposedKeys.Vkey())\r\n+        {\r\n+            const auto args{ make_self<ModifyKeyChordEventArgs>(_currentKeys, // OldKeys\r\n+                                                                _ProposedKeys) }; // NewKeys\r\n+            ModifyKeyChordRequested.raise(*this, *args);\r\n+        }\r\n+        else\r\n+        {\r\n+            // no changes being requested, toggle edit mode\r\n+            ToggleEditMode();\r\n+        }\r\n+    }\r\n+\r\n+    void KeyChordViewModel::CancelChanges()\r\n+    {\r\n+        ToggleEditMode();\r\n+    }\r\n+\r\n+    void KeyChordViewModel::DeleteKeyChord()\r\n+    {\r\n+        DeleteKeyChordRequested.raise(*this, _currentKeys);\r\n+    }\r\n+\r\n+    ActionsViewModel::ActionsViewModel(Model::CascadiaSettings settings) :\r\n+        _Settings{ settings }\r\n+    {\r\n+        _MakeCommandVMsHelper();\r\n+    }\r\n+\r\n+    void ActionsViewModel::UpdateSettings(const Model::CascadiaSettings& settings)\r\n+    {\r\n+        _Settings = settings;\r\n+\r\n+        // We want to re-initialize our CommandList, but we want to make sure\r\n+        // we still have the same CurrentCommand as before (if that command still exists)\r\n+\r\n+        // Store the ID of the current command\r\n+        const auto currentCommandID = CurrentCommand() ? CurrentCommand().ID() : hstring{};\r\n+\r\n+        // Re-initialize the command vm list\r\n+        _MakeCommandVMsHelper();\r\n+\r\n+        // Re-select the previously selected command if it exists\r\n+        if (!currentCommandID.empty())\r\n+        {\r\n+            const auto it = _CommandList.First();\r\n+            while (it.HasCurrent())\r\n             {\r\n-                const auto newFocusedIndex{ std::clamp(index, 0u, _KeyBindingList.Size() - 1) };\r\n-                // Emit an event to let the page know to move focus to\r\n-                // this VM's container.\r\n-                FocusContainer.raise(*this, winrt::box_value(newFocusedIndex));\r\n+                auto cmd = *it;\r\n+                if (cmd.ID() == currentCommandID)\r\n+                {\r\n+                    CurrentCommand(cmd);\r\n+                    break;\r\n+                }\r\n+                it.MoveNext();\r\n+            }\r\n+            if (!it.HasCurrent())\r\n+            {\r\n+                // we didn't find the previously selected command\r\n+                CurrentCommand(nullptr);\r\n+                CurrentPage(ActionsSubPage::Base);\r\n             }\r\n         }\r\n+        else\r\n+        {\r\n+            // didn't have a command,\r\n+            // so skip over looking through the command\r\n+            CurrentCommand(nullptr);\r\n+            CurrentPage(ActionsSubPage::Base);\r\n+        }\r\n     }\r\n \r\n-    void ActionsViewModel::_KeyBindingViewModelModifyKeyBindingHandler(const Editor::KeyBindingViewModel& senderVM, const Editor::ModifyKeyBindingEventArgs& args)\r\n+    void ActionsViewModel::_MakeCommandVMsHelper()\r\n     {\r\n-        const auto isNewAction{ !args.OldKeys() && args.OldActionName().empty() };\r\n+        // Populate AvailableActionsAndNames\r\n+        _AvailableActionsAndNamesMap = Model::CascadiaSettings::AvailableShortcutActionsAndNames();\r\n+        for (const auto unimplemented : UnimplementedShortcutActions)\r\n+        {\r\n+            _AvailableActionsAndNamesMap.Remove(unimplemented);\r\n+        }\r",
        "comment_created_at": "2025-05-21T20:43:53+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "We can probably cache this, right? Looks like `CascadiaSettings::AvailableShortcutActionsAndNames` does the work each time we call it, then we'll remove the same 2 unimplemented shortcut actions. Maybe we should just store it as a static so we don't regenerate it? It shouldn't change at runtime.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205473190",
    "pr_number": 19130,
    "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
    "created_at": "2025-07-14T17:41:23+00:00",
    "commented_code": "// Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2205473190",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205473190",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();",
        "comment_created_at": "2025-07-14T17:41:23+00:00",
        "comment_author": "DHowett",
        "comment_body": "TODO: we could cache both of these, and only regenerate the runs if nothing changed. that would make it cheaper in the general case. we could also cache the _runs_ and only regenerate the ones that differed, but that's starting to become a lot of work for little gain.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2114901789",
    "pr_number": 17346,
    "pr_file": "src/cascadia/TerminalControl/TermControl.cpp",
    "created_at": "2025-05-29T23:46:34+00:00",
    "commented_code": "return get_self<ControlCore>(_termControl->_core);\r\n     }\r\n \r\n+    Windows::UI::ViewManagement::AccessibilitySettings TermControl::_GetAccessibilitySettings()",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2114901789",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 17346,
        "pr_file": "src/cascadia/TerminalControl/TermControl.cpp",
        "discussion_id": "2114901789",
        "commented_code": "@@ -257,6 +257,12 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n         return get_self<ControlCore>(_termControl->_core);\r\n     }\r\n \r\n+    Windows::UI::ViewManagement::AccessibilitySettings TermControl::_GetAccessibilitySettings()\r",
        "comment_created_at": "2025-05-29T23:46:34+00:00",
        "comment_author": "DHowett",
        "comment_body": "you can save a call to `AddRef` and `Release` every time by returning an `AccessibilitySettings&`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060747049",
    "pr_number": 18700,
    "pr_file": "src/cascadia/TerminalApp/FilteredCommand.cpp",
    "created_at": "2025-04-25T18:58:15+00:00",
    "commented_code": "if (filter != _Filter)\n         {\n             Filter(filter);\n-            HighlightedName(_computeHighlightedName());\n             Weight(_computeWeight());\n+            HighlightedName(_computeHighlightedName());",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2060747049",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18700,
        "pr_file": "src/cascadia/TerminalApp/FilteredCommand.cpp",
        "discussion_id": "2060747049",
        "commented_code": "@@ -57,15 +58,16 @@ namespace winrt::TerminalApp::implementation\n         if (filter != _Filter)\n         {\n             Filter(filter);\n-            HighlightedName(_computeHighlightedName());\n             Weight(_computeWeight());\n+            HighlightedName(_computeHighlightedName());",
        "comment_created_at": "2025-04-25T18:58:15+00:00",
        "comment_author": "lhecker",
        "comment_body": "This will execute the fzf matching logic twice. I think we should replace the two functions with a single one called `_update` (or similar) which runs `ParsePattern` only once and updates both members.",
        "pr_file_module": null
      },
      {
        "comment_id": "2065390996",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18700,
        "pr_file": "src/cascadia/TerminalApp/FilteredCommand.cpp",
        "discussion_id": "2060747049",
        "commented_code": "@@ -57,15 +58,16 @@ namespace winrt::TerminalApp::implementation\n         if (filter != _Filter)\n         {\n             Filter(filter);\n-            HighlightedName(_computeHighlightedName());\n             Weight(_computeWeight());\n+            HighlightedName(_computeHighlightedName());",
        "comment_created_at": "2025-04-29T04:00:32+00:00",
        "comment_author": "e82eric",
        "comment_body": "Updated,  I think I may have gone too far with this, I realized that ParsePattern was getting executed for every item and moved the pattern parsing outside of UpdateFilter which ended up bringing the snippets pane and suggestions UI into scope.  Hopefully this isn't too invasive.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1113329450",
    "pr_number": 14825,
    "pr_file": "src/cascadia/TerminalApp/TerminalPage.cpp",
    "created_at": "2023-02-21T16:51:27+00:00",
    "commented_code": "}\n \n         // If the user set a custom name, save it\n-        if (_WindowName != L\"\")\n+        if (_WindowProperties.WindowName() != L\"\")",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1113329450",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 14825,
        "pr_file": "src/cascadia/TerminalApp/TerminalPage.cpp",
        "discussion_id": "1113329450",
        "commented_code": "@@ -1847,11 +1799,11 @@ namespace winrt::TerminalApp::implementation\n         }\n \n         // If the user set a custom name, save it\n-        if (_WindowName != L\"\")\n+        if (_WindowProperties.WindowName() != L\"\")",
        "comment_created_at": "2023-02-21T16:51:27+00:00",
        "comment_author": "lhecker",
        "comment_body": "You can avoid calling the same WinRT function repeatedly here:\r\n```cpp\r\nif (const auto windowName = _WindowProperties.WindowName())\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1871308752",
    "pr_number": 18126,
    "pr_file": "src/cascadia/TerminalApp/TerminalPage.cpp",
    "created_at": "2024-12-05T12:37:54+00:00",
    "commented_code": "button.Label(label);\n             button.Click(makeCallback(action));\n-            menu.SecondaryCommands().Append(button);\n+            targetMenu.SecondaryCommands().Append(button);\n         };\n \n+        auto makeMenuItem = [](const winrt::hstring& label,\n+                               const winrt::hstring& icon,\n+                               const auto& subMenu,\n+                               auto& targetMenu) {\n+            AppBarButton button{};\n+\n+            if (!icon.empty())\n+            {\n+                auto iconElement = UI::IconPathConverter::IconWUX(icon);\n+                Automation::AutomationProperties::SetAccessibilityView(iconElement, Automation::Peers::AccessibilityView::Raw);\n+                button.Icon(iconElement);\n+            }\n+\n+            button.Label(label);\n+            button.Flyout(subMenu);\n+            targetMenu.SecondaryCommands().Append(button);\n+        };\n+\n+        const auto focusedProfile = _GetFocusedTabImpl()->GetFocusedProfile();\n+        auto separatorItem = AppBarSeparator{};\n+        auto activeProfiles = _settings.ActiveProfiles();\n+        auto activeProfileCount = gsl::narrow_cast<int>(activeProfiles.Size());\n+        MUX::Controls::CommandBarFlyout splitPaneDownMenu{};\n+        MUX::Controls::CommandBarFlyout splitPaneUpMenu{};\n+        MUX::Controls::CommandBarFlyout splitPaneRightMenu{};\n+        MUX::Controls::CommandBarFlyout splitPaneLeftMenu{};\n+\n         // Wire up each item to the action that should be performed. By actually\n         // connecting these to actions, we ensure the implementation is\n         // consistent. This also leaves room for customizing this menu with\n         // actions in the future.\n \n-        makeItem(RS_(L\"SplitPaneText\"), L\"\\xF246\", ActionAndArgs{ ShortcutAction::SplitPane, SplitPaneArgs{ SplitType::Duplicate } });\n-        makeItem(RS_(L\"DuplicateTabText\"), L\"\\xF5ED\", ActionAndArgs{ ShortcutAction::DuplicateTab, nullptr });\n+        if (!withSelection)\n+        {\n+            makeItem(RS_(L\"FindText\"), L\"\\xF78B\", ActionAndArgs{ ShortcutAction::Find, nullptr }, menu);\n+        }\n+\n+        makeItem(RS_(L\"DuplicateTabText\"), L\"\\xF5ED\", ActionAndArgs{ ShortcutAction::DuplicateTab, nullptr }, menu);\n+\n+        makeItem(RS_(L\"SplitPaneDuplicateText\") + L\" \" + focusedProfile.Name(), focusedProfile.Icon(), ActionAndArgs{ ShortcutAction::SplitPane, SplitPaneArgs{ SplitType::Duplicate, SplitDirection::Down, .5, nullptr } }, splitPaneDownMenu);",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1871308752",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18126,
        "pr_file": "src/cascadia/TerminalApp/TerminalPage.cpp",
        "discussion_id": "1871308752",
        "commented_code": "@@ -5048,34 +5049,141 @@ namespace winrt::TerminalApp::implementation\n \n             button.Label(label);\n             button.Click(makeCallback(action));\n-            menu.SecondaryCommands().Append(button);\n+            targetMenu.SecondaryCommands().Append(button);\n         };\n \n+        auto makeMenuItem = [](const winrt::hstring& label,\n+                               const winrt::hstring& icon,\n+                               const auto& subMenu,\n+                               auto& targetMenu) {\n+            AppBarButton button{};\n+\n+            if (!icon.empty())\n+            {\n+                auto iconElement = UI::IconPathConverter::IconWUX(icon);\n+                Automation::AutomationProperties::SetAccessibilityView(iconElement, Automation::Peers::AccessibilityView::Raw);\n+                button.Icon(iconElement);\n+            }\n+\n+            button.Label(label);\n+            button.Flyout(subMenu);\n+            targetMenu.SecondaryCommands().Append(button);\n+        };\n+\n+        const auto focusedProfile = _GetFocusedTabImpl()->GetFocusedProfile();\n+        auto separatorItem = AppBarSeparator{};\n+        auto activeProfiles = _settings.ActiveProfiles();\n+        auto activeProfileCount = gsl::narrow_cast<int>(activeProfiles.Size());\n+        MUX::Controls::CommandBarFlyout splitPaneDownMenu{};\n+        MUX::Controls::CommandBarFlyout splitPaneUpMenu{};\n+        MUX::Controls::CommandBarFlyout splitPaneRightMenu{};\n+        MUX::Controls::CommandBarFlyout splitPaneLeftMenu{};\n+\n         // Wire up each item to the action that should be performed. By actually\n         // connecting these to actions, we ensure the implementation is\n         // consistent. This also leaves room for customizing this menu with\n         // actions in the future.\n \n-        makeItem(RS_(L\"SplitPaneText\"), L\"\\xF246\", ActionAndArgs{ ShortcutAction::SplitPane, SplitPaneArgs{ SplitType::Duplicate } });\n-        makeItem(RS_(L\"DuplicateTabText\"), L\"\\xF5ED\", ActionAndArgs{ ShortcutAction::DuplicateTab, nullptr });\n+        if (!withSelection)\n+        {\n+            makeItem(RS_(L\"FindText\"), L\"\\xF78B\", ActionAndArgs{ ShortcutAction::Find, nullptr }, menu);\n+        }\n+\n+        makeItem(RS_(L\"DuplicateTabText\"), L\"\\xF5ED\", ActionAndArgs{ ShortcutAction::DuplicateTab, nullptr }, menu);\n+\n+        makeItem(RS_(L\"SplitPaneDuplicateText\") + L\" \" + focusedProfile.Name(), focusedProfile.Icon(), ActionAndArgs{ ShortcutAction::SplitPane, SplitPaneArgs{ SplitType::Duplicate, SplitDirection::Down, .5, nullptr } }, splitPaneDownMenu);",
        "comment_created_at": "2024-12-05T12:37:54+00:00",
        "comment_author": "zadjii-msft",
        "comment_body": "nit: it may make sense to cache the value of `focusedProfile.Name()` and `focusedProfile.Icon()`  before all these calls, so we only need to do the lookup once. I'm not sure the compiler is smart enough to not make that function call _every time_",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989769230",
    "pr_number": 18654,
    "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.cpp",
    "created_at": "2025-03-11T17:06:28+00:00",
    "commented_code": "}\r\n }\r\n \r\n+static void _validateRegex(const winrt::hstring& regex, IVector<Model::SettingsLoadWarnings>& warnings)\r\n+{\r\n+    try\r\n+    {\r\n+        std::wregex{ regex.cbegin(), regex.cend() };",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1989769230",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18654,
        "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.cpp",
        "discussion_id": "1989769230",
        "commented_code": "@@ -583,6 +584,49 @@ void CascadiaSettings::_validateProfileEnvironmentVariables()\n     }\r\n }\r\n \r\n+static void _validateRegex(const winrt::hstring& regex, IVector<Model::SettingsLoadWarnings>& warnings)\r\n+{\r\n+    try\r\n+    {\r\n+        std::wregex{ regex.cbegin(), regex.cend() };\r",
        "comment_created_at": "2025-03-11T17:06:28+00:00",
        "comment_author": "lhecker",
        "comment_body": "AGH! STD REGEX MY MORTAL ENEMY! \ud83d\ude04\r\n\r\nThat said, regex construction can be fairly costly in general, and we should not treat this as some kind of cheap validation. It involves constructing DFAs, etc., after all. I'm not entirely sure anymore where `MatchProfilesEntry` fits into the callstack, but seeing that it's also part of `TerminalSettingsModel`, I'm sure that we can make it cache every regex instance after load and store any warnings into a list. We can then splice its list into the overall `SettingsLoadWarnings` list (or store it directly there, or something like that). Basically, a way to only construct these once.\r\n\r\nFWIW if you want to give `icu.h` a try:\r\n```cpp\r\n#include \"path/to/buffer/out/UTextAdapter.h\"\r\n\r\n// Cache this\r\nUErrorCode status = U_ZERO_ERROR;\r\nconst auto re = Microsoft::Console::ICU::CreateRegex(pattern, 0, &status);\r\nif (status > U_ZERO_ERROR) {\r\n    // bad regex\r\n}\r\n\r\n// Run this\r\nUErrorCode status = U_ZERO_ERROR;\r\nuregex_setText(re.get(), hstring.data(), hstring.size(), &status);\r\nconst auto match = uregex_matches(re.get(), 0, &status);\r\nreturn status == U_ZERO_ERROR && match;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2051247927",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18654,
        "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.cpp",
        "discussion_id": "1989769230",
        "commented_code": "@@ -583,6 +584,49 @@ void CascadiaSettings::_validateProfileEnvironmentVariables()\n     }\r\n }\r\n \r\n+static void _validateRegex(const winrt::hstring& regex, IVector<Model::SettingsLoadWarnings>& warnings)\r\n+{\r\n+    try\r\n+    {\r\n+        std::wregex{ regex.cbegin(), regex.cend() };\r",
        "comment_created_at": "2025-04-18T23:37:34+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "Alright, gave it a try with `icu.h`. It's so close! I'm just getting the following linker error and those tend to give me a hard time \ud83e\udee4. Any ideas what's missing?\r\n```\r\n>   Creating library D:\\projects\\terminal\\bin\\x64\\Debug\\Microsoft.Terminal.Settings.Model\\Microsoft.Terminal.Settings.Model.lib and object D:\\projects\\terminal\\bin\\x64\\Debug\\Microsoft.Terminal.Settings.Model\\Microsoft.Terminal.Settings.Model.exp\r\n1>Microsoft.Terminal.Settings.Model.Lib.lib(MatchProfilesEntry.obj) : error LNK2019: unresolved external symbol \"class wistd::unique_ptr<struct URegularExpression,struct wil::function_deleter<void (__cdecl*)(struct URegularExpression *),&void __cdecl uregex_close(struct URegularExpression *)> > __cdecl Microsoft::Console::ICU::CreateRegex(class std::basic_string_view<wchar_t,struct std::char_traits<wchar_t> > const &,unsigned int,enum UErrorCode *)\" (?CreateRegex@ICU@Console@Microsoft@@YA?AV?$unique_ptr@UURegularExpression@@U?$function_deleter@P6AXPEAUURegularExpression@@@Z$1?uregex_close@@YAX0@Z@wil@@@wistd@@AEBV?$basic_string_view@_WU?$char_traits@_W@std@@@std@@IPEAW4UErrorCode@@@Z) referenced in function \"private: void __cdecl winrt::Microsoft::Terminal::Settings::Model::implementation::MatchProfilesEntry::_validateName(void)\" (?_validateName@MatchProfilesEntry@implementation@Model@Settings@Terminal@Microsoft@winrt@@AEAAXXZ)\r\n1>D:\\projects\\terminal\\bin\\x64\\Debug\\Microsoft.Terminal.Settings.Model\\Microsoft.Terminal.Settings.Model.dll : fatal error LNK1120: 1 unresolved externals\r\n1>Done building project \"Microsoft.Terminal.Settings.Model.vcxproj\" -- FAILED.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]