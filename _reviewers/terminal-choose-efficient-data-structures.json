[
  {
    "discussion_id": "2273731108",
    "pr_number": 18915,
    "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgsMagic.h",
    "created_at": "2025-08-13T14:55:06+00:00",
    "commented_code": "//   * GlobalSummonArgs has the QuakeModeFromJson helper\r\n \r\n #define ACTION_ARG_BODY(className, argsMacro)                                                     \\\r\n-    className() = default;                                                                        \\\r\n+    className(){ argsMacro(APPEND_ARG_DESCRIPTION) };                                             \\\r\n     className(                                                                                    \\\r\n         argsMacro(CTOR_PARAMS) InitListPlaceholder = {}) :                                        \\\r\n-        argsMacro(CTOR_INIT) _placeholder{} {};                                                   \\\r\n+        argsMacro(CTOR_INIT) _placeholder{} {                                                     \\\r\n+            argsMacro(APPEND_ARG_DESCRIPTION)                                                     \\\r\n+        };                                                                                        \\\r\n     argsMacro(DECLARE_ARGS);                                                                      \\\r\n                                                                                                   \\\r\n private:                                                                                          \\\r\n     InitListPlaceholder _placeholder;                                                             \\\r\n+    std::vector<ArgDescriptor> _argDescriptors;                                                   \\",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2273731108",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18915,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgsMagic.h",
        "discussion_id": "2273731108",
        "commented_code": "@@ -112,14 +149,17 @@ struct InitListPlaceholder\n //   * GlobalSummonArgs has the QuakeModeFromJson helper\r\n \r\n #define ACTION_ARG_BODY(className, argsMacro)                                                     \\\r\n-    className() = default;                                                                        \\\r\n+    className(){ argsMacro(APPEND_ARG_DESCRIPTION) };                                             \\\r\n     className(                                                                                    \\\r\n         argsMacro(CTOR_PARAMS) InitListPlaceholder = {}) :                                        \\\r\n-        argsMacro(CTOR_INIT) _placeholder{} {};                                                   \\\r\n+        argsMacro(CTOR_INIT) _placeholder{} {                                                     \\\r\n+            argsMacro(APPEND_ARG_DESCRIPTION)                                                     \\\r\n+        };                                                                                        \\\r\n     argsMacro(DECLARE_ARGS);                                                                      \\\r\n                                                                                                   \\\r\n private:                                                                                          \\\r\n     InitListPlaceholder _placeholder;                                                             \\\r\n+    std::vector<ArgDescriptor> _argDescriptors;                                                   \\\r",
        "comment_created_at": "2025-08-13T14:55:06+00:00",
        "comment_author": "lhecker",
        "comment_body": "Does `_argDescriptors` need to be a mutable copy for each individual ActionArgs instance?",
        "pr_file_module": null
      },
      {
        "comment_id": "2274738712",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18915,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgsMagic.h",
        "discussion_id": "2273731108",
        "commented_code": "@@ -112,14 +149,17 @@ struct InitListPlaceholder\n //   * GlobalSummonArgs has the QuakeModeFromJson helper\r\n \r\n #define ACTION_ARG_BODY(className, argsMacro)                                                     \\\r\n-    className() = default;                                                                        \\\r\n+    className(){ argsMacro(APPEND_ARG_DESCRIPTION) };                                             \\\r\n     className(                                                                                    \\\r\n         argsMacro(CTOR_PARAMS) InitListPlaceholder = {}) :                                        \\\r\n-        argsMacro(CTOR_INIT) _placeholder{} {};                                                   \\\r\n+        argsMacro(CTOR_INIT) _placeholder{} {                                                     \\\r\n+            argsMacro(APPEND_ARG_DESCRIPTION)                                                     \\\r\n+        };                                                                                        \\\r\n     argsMacro(DECLARE_ARGS);                                                                      \\\r\n                                                                                                   \\\r\n private:                                                                                          \\\r\n     InitListPlaceholder _placeholder;                                                             \\\r\n+    std::vector<ArgDescriptor> _argDescriptors;                                                   \\\r",
        "comment_created_at": "2025-08-13T21:57:54+00:00",
        "comment_author": "PankajBhojwani",
        "comment_body": "No, the `_argDescriptors` stay the same once they're initialized",
        "pr_file_module": null
      },
      {
        "comment_id": "2274773192",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18915,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgsMagic.h",
        "discussion_id": "2273731108",
        "commented_code": "@@ -112,14 +149,17 @@ struct InitListPlaceholder\n //   * GlobalSummonArgs has the QuakeModeFromJson helper\r\n \r\n #define ACTION_ARG_BODY(className, argsMacro)                                                     \\\r\n-    className() = default;                                                                        \\\r\n+    className(){ argsMacro(APPEND_ARG_DESCRIPTION) };                                             \\\r\n     className(                                                                                    \\\r\n         argsMacro(CTOR_PARAMS) InitListPlaceholder = {}) :                                        \\\r\n-        argsMacro(CTOR_INIT) _placeholder{} {};                                                   \\\r\n+        argsMacro(CTOR_INIT) _placeholder{} {                                                     \\\r\n+            argsMacro(APPEND_ARG_DESCRIPTION)                                                     \\\r\n+        };                                                                                        \\\r\n     argsMacro(DECLARE_ARGS);                                                                      \\\r\n                                                                                                   \\\r\n private:                                                                                          \\\r\n     InitListPlaceholder _placeholder;                                                             \\\r\n+    std::vector<ArgDescriptor> _argDescriptors;                                                   \\\r",
        "comment_created_at": "2025-08-13T22:24:52+00:00",
        "comment_author": "lhecker",
        "comment_body": "In that case we should consider making these lazy initialized constant, immutable vectors right? It may tie into my other suggestion to return it as-is.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283461613",
    "pr_number": 18915,
    "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgs.h",
    "created_at": "2025-08-18T21:03:54+00:00",
    "commented_code": "h.write(SplitSize());\r\n             return h.finalize();\r\n         }\r\n+        winrt::Windows::Foundation::Collections::IVectorView<Model::ArgDescriptor> GetArgDescriptors()\r\n+        {\r\n+            static const auto thisArgs = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS);\r\n+\r\n+            // Merge into a new vector\r\n+            std::vector<Model::ArgDescriptor> merged;\r\n+\r\n+            for (const auto desc : thisArgs)\r\n+            {\r\n+                merged.push_back(desc);\r\n+            }\r\n+\r\n+            if (_ContentArgs)\r\n+            {\r\n+                if (const auto newTermArgs = _ContentArgs.try_as<NewTerminalArgs>())\r\n+                {\r\n+                    auto contentArgs = newTermArgs->GetArgDescriptors();\r\n+                    for (const auto desc : contentArgs)\r\n+                    {\r\n+                        merged.push_back(desc);\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+            return winrt::single_threaded_vector(std::move(merged)).GetView();\r\n+        }\r\n+        IInspectable GetArgAt(uint32_t index)\r\n+        {\r\n+            const auto additionalArgCount = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS).Size();\r\n+            if (index < additionalArgCount)\r\n+            {\r\n+                X_MACRO_INDEX_BASE();\r\n+                SPLIT_PANE_ARGS(GET_ARG_BY_INDEX);\r\n+            }\r\n+            else\r\n+            {\r\n+                return _ContentArgs.as<NewTerminalArgs>()->GetArgAt(index - additionalArgCount);\r\n+            }\r\n+            return nullptr;\r\n+        }\r\n+        void SetArgAt(uint32_t index, IInspectable value)\r\n+        {\r\n+            const auto additionalArgCount = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS).Size();",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2283461613",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18915,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgs.h",
        "discussion_id": "2283461613",
        "commented_code": "@@ -731,14 +755,67 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n             h.write(SplitSize());\r\n             return h.finalize();\r\n         }\r\n+        winrt::Windows::Foundation::Collections::IVectorView<Model::ArgDescriptor> GetArgDescriptors()\r\n+        {\r\n+            static const auto thisArgs = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS);\r\n+\r\n+            // Merge into a new vector\r\n+            std::vector<Model::ArgDescriptor> merged;\r\n+\r\n+            for (const auto desc : thisArgs)\r\n+            {\r\n+                merged.push_back(desc);\r\n+            }\r\n+\r\n+            if (_ContentArgs)\r\n+            {\r\n+                if (const auto newTermArgs = _ContentArgs.try_as<NewTerminalArgs>())\r\n+                {\r\n+                    auto contentArgs = newTermArgs->GetArgDescriptors();\r\n+                    for (const auto desc : contentArgs)\r\n+                    {\r\n+                        merged.push_back(desc);\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+            return winrt::single_threaded_vector(std::move(merged)).GetView();\r\n+        }\r\n+        IInspectable GetArgAt(uint32_t index)\r\n+        {\r\n+            const auto additionalArgCount = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS).Size();\r\n+            if (index < additionalArgCount)\r\n+            {\r\n+                X_MACRO_INDEX_BASE();\r\n+                SPLIT_PANE_ARGS(GET_ARG_BY_INDEX);\r\n+            }\r\n+            else\r\n+            {\r\n+                return _ContentArgs.as<NewTerminalArgs>()->GetArgAt(index - additionalArgCount);\r\n+            }\r\n+            return nullptr;\r\n+        }\r\n+        void SetArgAt(uint32_t index, IInspectable value)\r\n+        {\r\n+            const auto additionalArgCount = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS).Size();\r",
        "comment_created_at": "2025-08-18T21:03:54+00:00",
        "comment_author": "lhecker",
        "comment_body": "This seems wasteful. Why not just use the `default:` case in the switch/case you generate below?",
        "pr_file_module": null
      },
      {
        "comment_id": "2283707548",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18915,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionArgs.h",
        "discussion_id": "2283461613",
        "commented_code": "@@ -731,14 +755,67 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n             h.write(SplitSize());\r\n             return h.finalize();\r\n         }\r\n+        winrt::Windows::Foundation::Collections::IVectorView<Model::ArgDescriptor> GetArgDescriptors()\r\n+        {\r\n+            static const auto thisArgs = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS);\r\n+\r\n+            // Merge into a new vector\r\n+            std::vector<Model::ArgDescriptor> merged;\r\n+\r\n+            for (const auto desc : thisArgs)\r\n+            {\r\n+                merged.push_back(desc);\r\n+            }\r\n+\r\n+            if (_ContentArgs)\r\n+            {\r\n+                if (const auto newTermArgs = _ContentArgs.try_as<NewTerminalArgs>())\r\n+                {\r\n+                    auto contentArgs = newTermArgs->GetArgDescriptors();\r\n+                    for (const auto desc : contentArgs)\r\n+                    {\r\n+                        merged.push_back(desc);\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+            return winrt::single_threaded_vector(std::move(merged)).GetView();\r\n+        }\r\n+        IInspectable GetArgAt(uint32_t index)\r\n+        {\r\n+            const auto additionalArgCount = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS).Size();\r\n+            if (index < additionalArgCount)\r\n+            {\r\n+                X_MACRO_INDEX_BASE();\r\n+                SPLIT_PANE_ARGS(GET_ARG_BY_INDEX);\r\n+            }\r\n+            else\r\n+            {\r\n+                return _ContentArgs.as<NewTerminalArgs>()->GetArgAt(index - additionalArgCount);\r\n+            }\r\n+            return nullptr;\r\n+        }\r\n+        void SetArgAt(uint32_t index, IInspectable value)\r\n+        {\r\n+            const auto additionalArgCount = INIT_ARG_DESCRIPTORS(SPLIT_PANE_ARGS).Size();\r",
        "comment_created_at": "2025-08-18T23:37:52+00:00",
        "comment_author": "PankajBhojwani",
        "comment_body": "Even in the default case, we will need to subtract `additionalArgCount` from `index` to pass in the correct number to the `_ContentArgs`. Implemented a much more lightweight implementation to obtain the arg count instead of getting the size of the vector view.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1657984494",
    "pr_number": 17421,
    "pr_file": "src/terminal/adapter/SixelParser.hpp",
    "created_at": "2024-06-28T01:18:01+00:00",
    "commented_code": "+/*++\r\n+Copyright (c) Microsoft Corporation\r\n+Licensed under the MIT license.\r\n+\r\n+Module Name:\r\n+- SixelParser.hpp\r\n+\r\n+Abstract:\r\n+- This class handles the parsing of the Sixel image format.\r\n+--*/\r\n+\r\n+#pragma once\r\n+\r\n+#include \"til.h\"\r\n+#include \"DispatchTypes.hpp\"\r\n+\r\n+class Cursor;\r\n+class TextBuffer;\r\n+\r\n+namespace Microsoft::Console::VirtualTerminal\r\n+{\r\n+    class AdaptDispatch;\r\n+    class Page;\r\n+    class StateMachine;\r\n+\r\n+    class SixelParser\r\n+    {\r\n+    public:\r\n+        static constexpr VTInt DefaultConformance = 9;\r\n+\r\n+        static til::size CellSizeForLevel(const VTInt conformanceLevel) noexcept;\r\n+        static size_t MaxColorsForLevel(const VTInt conformanceLevel) noexcept;\r\n+\r\n+        SixelParser(AdaptDispatch& dispatcher, const StateMachine& stateMachine, const VTInt conformanceLevel = DefaultConformance) noexcept;\r\n+        void SoftReset();\r\n+        void SetDisplayMode(const bool enabled) noexcept;\r\n+        std::function<bool(wchar_t)> DefineImage(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect, const VTParameter backgroundColor);\r\n+\r\n+    private:\r\n+        // NB: If we want to support more than 256 colors, we'll also need to\r\n+        // change the IndexType to uint16_t, and use a bit field in IndexPixel\r\n+        // to retain the 16-bit size.\r\n+        static constexpr size_t MAX_COLORS = 256;\r\n+        using IndexType = uint8_t;\r\n+        struct IndexedPixel\r\n+        {\r\n+            uint8_t transparent = false;\r\n+            IndexType colorIndex = 0;\r\n+        };\r\n+\r\n+        AdaptDispatch& _dispatcher;\r\n+        const StateMachine& _stateMachine;\r\n+        const VTInt _conformanceLevel;\r\n+\r\n+        void _parseCommandChar(const wchar_t ch);\r\n+        void _parseParameterChar(const wchar_t ch);\r\n+        int _applyPendingCommand();\r\n+        void _executeCarriageReturn() noexcept;\r\n+        void _executeNextLine();\r\n+        void _executeMoveToHome();\r\n+\r\n+        enum class States : size_t\r\n+        {\r\n+            Normal,\r\n+            Attributes,\r\n+            Color,\r\n+            Repeat\r\n+        };\r\n+        States _state = States::Normal;\r\n+        std::vector<VTParameter> _parameters;\r\n+\r\n+        bool _initTextBufferBoundaries();\r\n+        void _initRasterAttributes(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect) noexcept;\r\n+        void _updateRasterAttributes(const VTParameters& rasterAttributes);\r\n+        void _scrollTextBuffer(Page& page, const int scrollAmount);\r\n+        void _updateTextCursor(Cursor& cursor) noexcept;\r\n+\r\n+        const til::size _cellSize;\r\n+        bool _displayMode = true;\r\n+        til::rect _textMargins;\r\n+        til::point _textCursor;\r\n+        bool _textCursorWasVisible;\r\n+        til::CoordType _availablePixelWidth;\r\n+        til::CoordType _availablePixelHeight;\r\n+        til::CoordType _maxPixelAspectRatio;\r\n+        til::CoordType _pixelAspectRatio;\r\n+        til::CoordType _sixelHeight;\r\n+        til::CoordType _segmentHeight;\r\n+        til::CoordType _pendingTextScrollCount;\r\n+        til::size _backgroundSize;\r\n+        bool _backgroundFillRequired;\r\n+\r\n+        void _initColorMap(const VTParameter backgroundColor);\r\n+        void _defineColor(const VTParameters& colorParameters);\r\n+        void _defineColor(const size_t colorNumber, const COLORREF color);\r\n+        COLORREF _colorFromIndex(const IndexType tableIndex) const noexcept;\r\n+        static constexpr RGBQUAD _makeRGBQUAD(const COLORREF color) noexcept;\r\n+        void _updateTextColors();\r\n+\r\n+        std::array<size_t, MAX_COLORS> _colorMap = {};\r\n+        std::array<bool, MAX_COLORS> _colorMapUsed = {};",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1657984494",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 17421,
        "pr_file": "src/terminal/adapter/SixelParser.hpp",
        "discussion_id": "1657984494",
        "commented_code": "@@ -0,0 +1,125 @@\n+/*++\r\n+Copyright (c) Microsoft Corporation\r\n+Licensed under the MIT license.\r\n+\r\n+Module Name:\r\n+- SixelParser.hpp\r\n+\r\n+Abstract:\r\n+- This class handles the parsing of the Sixel image format.\r\n+--*/\r\n+\r\n+#pragma once\r\n+\r\n+#include \"til.h\"\r\n+#include \"DispatchTypes.hpp\"\r\n+\r\n+class Cursor;\r\n+class TextBuffer;\r\n+\r\n+namespace Microsoft::Console::VirtualTerminal\r\n+{\r\n+    class AdaptDispatch;\r\n+    class Page;\r\n+    class StateMachine;\r\n+\r\n+    class SixelParser\r\n+    {\r\n+    public:\r\n+        static constexpr VTInt DefaultConformance = 9;\r\n+\r\n+        static til::size CellSizeForLevel(const VTInt conformanceLevel) noexcept;\r\n+        static size_t MaxColorsForLevel(const VTInt conformanceLevel) noexcept;\r\n+\r\n+        SixelParser(AdaptDispatch& dispatcher, const StateMachine& stateMachine, const VTInt conformanceLevel = DefaultConformance) noexcept;\r\n+        void SoftReset();\r\n+        void SetDisplayMode(const bool enabled) noexcept;\r\n+        std::function<bool(wchar_t)> DefineImage(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect, const VTParameter backgroundColor);\r\n+\r\n+    private:\r\n+        // NB: If we want to support more than 256 colors, we'll also need to\r\n+        // change the IndexType to uint16_t, and use a bit field in IndexPixel\r\n+        // to retain the 16-bit size.\r\n+        static constexpr size_t MAX_COLORS = 256;\r\n+        using IndexType = uint8_t;\r\n+        struct IndexedPixel\r\n+        {\r\n+            uint8_t transparent = false;\r\n+            IndexType colorIndex = 0;\r\n+        };\r\n+\r\n+        AdaptDispatch& _dispatcher;\r\n+        const StateMachine& _stateMachine;\r\n+        const VTInt _conformanceLevel;\r\n+\r\n+        void _parseCommandChar(const wchar_t ch);\r\n+        void _parseParameterChar(const wchar_t ch);\r\n+        int _applyPendingCommand();\r\n+        void _executeCarriageReturn() noexcept;\r\n+        void _executeNextLine();\r\n+        void _executeMoveToHome();\r\n+\r\n+        enum class States : size_t\r\n+        {\r\n+            Normal,\r\n+            Attributes,\r\n+            Color,\r\n+            Repeat\r\n+        };\r\n+        States _state = States::Normal;\r\n+        std::vector<VTParameter> _parameters;\r\n+\r\n+        bool _initTextBufferBoundaries();\r\n+        void _initRasterAttributes(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect) noexcept;\r\n+        void _updateRasterAttributes(const VTParameters& rasterAttributes);\r\n+        void _scrollTextBuffer(Page& page, const int scrollAmount);\r\n+        void _updateTextCursor(Cursor& cursor) noexcept;\r\n+\r\n+        const til::size _cellSize;\r\n+        bool _displayMode = true;\r\n+        til::rect _textMargins;\r\n+        til::point _textCursor;\r\n+        bool _textCursorWasVisible;\r\n+        til::CoordType _availablePixelWidth;\r\n+        til::CoordType _availablePixelHeight;\r\n+        til::CoordType _maxPixelAspectRatio;\r\n+        til::CoordType _pixelAspectRatio;\r\n+        til::CoordType _sixelHeight;\r\n+        til::CoordType _segmentHeight;\r\n+        til::CoordType _pendingTextScrollCount;\r\n+        til::size _backgroundSize;\r\n+        bool _backgroundFillRequired;\r\n+\r\n+        void _initColorMap(const VTParameter backgroundColor);\r\n+        void _defineColor(const VTParameters& colorParameters);\r\n+        void _defineColor(const size_t colorNumber, const COLORREF color);\r\n+        COLORREF _colorFromIndex(const IndexType tableIndex) const noexcept;\r\n+        static constexpr RGBQUAD _makeRGBQUAD(const COLORREF color) noexcept;\r\n+        void _updateTextColors();\r\n+\r\n+        std::array<size_t, MAX_COLORS> _colorMap = {};\r\n+        std::array<bool, MAX_COLORS> _colorMapUsed = {};\r",
        "comment_created_at": "2024-06-28T01:18:01+00:00",
        "comment_author": "lhecker",
        "comment_body": "It seems as if the `_colorMap` items are supposed to be `IndexType`s. Should we swap `size_t` with `IndexType` here?\r\n\r\nSide note: As an alternative you could store the `_colorMap` items as `int` and initialize them to a negative value to indicate that they're currently not used.",
        "pr_file_module": null
      },
      {
        "comment_id": "1660024781",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 17421,
        "pr_file": "src/terminal/adapter/SixelParser.hpp",
        "discussion_id": "1657984494",
        "commented_code": "@@ -0,0 +1,125 @@\n+/*++\r\n+Copyright (c) Microsoft Corporation\r\n+Licensed under the MIT license.\r\n+\r\n+Module Name:\r\n+- SixelParser.hpp\r\n+\r\n+Abstract:\r\n+- This class handles the parsing of the Sixel image format.\r\n+--*/\r\n+\r\n+#pragma once\r\n+\r\n+#include \"til.h\"\r\n+#include \"DispatchTypes.hpp\"\r\n+\r\n+class Cursor;\r\n+class TextBuffer;\r\n+\r\n+namespace Microsoft::Console::VirtualTerminal\r\n+{\r\n+    class AdaptDispatch;\r\n+    class Page;\r\n+    class StateMachine;\r\n+\r\n+    class SixelParser\r\n+    {\r\n+    public:\r\n+        static constexpr VTInt DefaultConformance = 9;\r\n+\r\n+        static til::size CellSizeForLevel(const VTInt conformanceLevel) noexcept;\r\n+        static size_t MaxColorsForLevel(const VTInt conformanceLevel) noexcept;\r\n+\r\n+        SixelParser(AdaptDispatch& dispatcher, const StateMachine& stateMachine, const VTInt conformanceLevel = DefaultConformance) noexcept;\r\n+        void SoftReset();\r\n+        void SetDisplayMode(const bool enabled) noexcept;\r\n+        std::function<bool(wchar_t)> DefineImage(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect, const VTParameter backgroundColor);\r\n+\r\n+    private:\r\n+        // NB: If we want to support more than 256 colors, we'll also need to\r\n+        // change the IndexType to uint16_t, and use a bit field in IndexPixel\r\n+        // to retain the 16-bit size.\r\n+        static constexpr size_t MAX_COLORS = 256;\r\n+        using IndexType = uint8_t;\r\n+        struct IndexedPixel\r\n+        {\r\n+            uint8_t transparent = false;\r\n+            IndexType colorIndex = 0;\r\n+        };\r\n+\r\n+        AdaptDispatch& _dispatcher;\r\n+        const StateMachine& _stateMachine;\r\n+        const VTInt _conformanceLevel;\r\n+\r\n+        void _parseCommandChar(const wchar_t ch);\r\n+        void _parseParameterChar(const wchar_t ch);\r\n+        int _applyPendingCommand();\r\n+        void _executeCarriageReturn() noexcept;\r\n+        void _executeNextLine();\r\n+        void _executeMoveToHome();\r\n+\r\n+        enum class States : size_t\r\n+        {\r\n+            Normal,\r\n+            Attributes,\r\n+            Color,\r\n+            Repeat\r\n+        };\r\n+        States _state = States::Normal;\r\n+        std::vector<VTParameter> _parameters;\r\n+\r\n+        bool _initTextBufferBoundaries();\r\n+        void _initRasterAttributes(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect) noexcept;\r\n+        void _updateRasterAttributes(const VTParameters& rasterAttributes);\r\n+        void _scrollTextBuffer(Page& page, const int scrollAmount);\r\n+        void _updateTextCursor(Cursor& cursor) noexcept;\r\n+\r\n+        const til::size _cellSize;\r\n+        bool _displayMode = true;\r\n+        til::rect _textMargins;\r\n+        til::point _textCursor;\r\n+        bool _textCursorWasVisible;\r\n+        til::CoordType _availablePixelWidth;\r\n+        til::CoordType _availablePixelHeight;\r\n+        til::CoordType _maxPixelAspectRatio;\r\n+        til::CoordType _pixelAspectRatio;\r\n+        til::CoordType _sixelHeight;\r\n+        til::CoordType _segmentHeight;\r\n+        til::CoordType _pendingTextScrollCount;\r\n+        til::size _backgroundSize;\r\n+        bool _backgroundFillRequired;\r\n+\r\n+        void _initColorMap(const VTParameter backgroundColor);\r\n+        void _defineColor(const VTParameters& colorParameters);\r\n+        void _defineColor(const size_t colorNumber, const COLORREF color);\r\n+        COLORREF _colorFromIndex(const IndexType tableIndex) const noexcept;\r\n+        static constexpr RGBQUAD _makeRGBQUAD(const COLORREF color) noexcept;\r\n+        void _updateTextColors();\r\n+\r\n+        std::array<size_t, MAX_COLORS> _colorMap = {};\r\n+        std::array<bool, MAX_COLORS> _colorMapUsed = {};\r",
        "comment_created_at": "2024-06-29T21:54:11+00:00",
        "comment_author": "j4james",
        "comment_body": "Good point. I've change it to `IndexType` now. We do need to maintain the used state separately, though, because the color map is still preinitialized with default values when it's unused. It's only when those defaults are overridden that they become \"used\".",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1887873004",
    "pr_number": 18334,
    "pr_file": "src/renderer/gdi/gdirenderer.hpp",
    "created_at": "2024-12-17T04:18:40+00:00",
    "commented_code": "// It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::basic_string<char32_t>> _polyWidths;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1887873004",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18334,
        "pr_file": "src/renderer/gdi/gdirenderer.hpp",
        "discussion_id": "1887873004",
        "commented_code": "@@ -165,7 +165,7 @@ namespace Microsoft::Console::Render\n         // It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::basic_string<char32_t>> _polyWidths;\r",
        "comment_created_at": "2024-12-17T04:18:40+00:00",
        "comment_author": "YexuanXiao",
        "comment_body": "std::char_traits\\<int\\> is a non-standard extension of STL and may be removed, use char32_t instead.\r\nhttps://github.com/microsoft/STL/issues/4935",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1889312667",
    "pr_number": 18334,
    "pr_file": "src/renderer/gdi/gdirenderer.hpp",
    "created_at": "2024-12-17T22:28:41+00:00",
    "commented_code": "// It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::vector<int>> _polyWidths;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1889312667",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18334,
        "pr_file": "src/renderer/gdi/gdirenderer.hpp",
        "discussion_id": "1889312667",
        "commented_code": "@@ -165,7 +165,7 @@ namespace Microsoft::Console::Render\n         // It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::vector<int>> _polyWidths;\r",
        "comment_created_at": "2024-12-17T22:28:41+00:00",
        "comment_author": "YexuanXiao",
        "comment_body": "Not used as string nor need the null terminator.",
        "pr_file_module": null
      },
      {
        "comment_id": "1898157714",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18334,
        "pr_file": "src/renderer/gdi/gdirenderer.hpp",
        "discussion_id": "1889312667",
        "commented_code": "@@ -165,7 +165,7 @@ namespace Microsoft::Console::Render\n         // It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::vector<int>> _polyWidths;\r",
        "comment_created_at": "2024-12-27T00:24:33+00:00",
        "comment_author": "christianparpart",
        "comment_body": "I wonder why this line was changed with the title of this PR. IIRC, some developers use `std::basic_string<T>` for non-char types to express small arrays of type T in order to make use of SSO behaviour of std::basic_string<>. The null terminator is also only guaranteed to be present when `.c_str()` is invoked, if I'm not mistaken (please correct me otherwise :) )",
        "pr_file_module": null
      },
      {
        "comment_id": "1898260977",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18334,
        "pr_file": "src/renderer/gdi/gdirenderer.hpp",
        "discussion_id": "1889312667",
        "commented_code": "@@ -165,7 +165,7 @@ namespace Microsoft::Console::Render\n         // It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::vector<int>> _polyWidths;\r",
        "comment_created_at": "2024-12-27T05:10:43+00:00",
        "comment_author": "YexuanXiao",
        "comment_body": "`std::basic_string<int>` is actually `std::basic_string<int, std::char_traits<int>, std::allocator<int>>`. However, the standard doesn't allow `std::char_traits<int>`. STL supports it because of [historical mistake](https://github.com/microsoft/STL/issues/4935#issuecomment-2330204210). When CharType is `int32_t` or `char32_t`, the STL (as well as other standard library implementations) have a very small SSO capacity of 3, making it essentially pointless. Since C++11, it is prohibited to add the null terminator when calling [`c_str`](https://en.cppreference.com/w/cpp/string/basic_string/c_str).",
        "pr_file_module": null
      },
      {
        "comment_id": "1898335841",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18334,
        "pr_file": "src/renderer/gdi/gdirenderer.hpp",
        "discussion_id": "1889312667",
        "commented_code": "@@ -165,7 +165,7 @@ namespace Microsoft::Console::Render\n         // It's important the pool is first so it can be given to the others on construction.\r\n         std::pmr::unsynchronized_pool_resource _pool;\r\n         std::pmr::vector<std::pmr::wstring> _polyStrings;\r\n-        std::pmr::vector<std::pmr::basic_string<int>> _polyWidths;\r\n+        std::pmr::vector<std::pmr::vector<int>> _polyWidths;\r",
        "comment_created_at": "2024-12-27T07:48:48+00:00",
        "comment_author": "christianparpart",
        "comment_body": "Nice. Thanks. \ud83d\udc4d",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1792253618",
    "pr_number": 18009,
    "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.h",
    "created_at": "2024-10-08T17:26:26+00:00",
    "commented_code": "void _addOrMergeUserColorScheme(const winrt::com_ptr<implementation::ColorScheme>& colorScheme);\r\n         void _executeGenerator(const IDynamicProfileGenerator& generator);\r\n \r\n-        std::unordered_set<std::wstring_view> _ignoredNamespaces;\r\n+        std::unordered_set<winrt::hstring, til::transparent_hstring_hash, til::transparent_hstring_equal_to> _ignoredNamespaces;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1792253618",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18009,
        "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.h",
        "discussion_id": "1792253618",
        "commented_code": "@@ -96,7 +96,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         void _addOrMergeUserColorScheme(const winrt::com_ptr<implementation::ColorScheme>& colorScheme);\r\n         void _executeGenerator(const IDynamicProfileGenerator& generator);\r\n \r\n-        std::unordered_set<std::wstring_view> _ignoredNamespaces;\r\n+        std::unordered_set<winrt::hstring, til::transparent_hstring_hash, til::transparent_hstring_equal_to> _ignoredNamespaces;\r",
        "comment_created_at": "2024-10-08T17:26:26+00:00",
        "comment_author": "DHowett",
        "comment_body": "can we get transparency from `unordered_set` with C++23 without our own hash/equal types?",
        "pr_file_module": null
      },
      {
        "comment_id": "1792264611",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18009,
        "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.h",
        "discussion_id": "1792253618",
        "commented_code": "@@ -96,7 +96,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         void _addOrMergeUserColorScheme(const winrt::com_ptr<implementation::ColorScheme>& colorScheme);\r\n         void _executeGenerator(const IDynamicProfileGenerator& generator);\r\n \r\n-        std::unordered_set<std::wstring_view> _ignoredNamespaces;\r\n+        std::unordered_set<winrt::hstring, til::transparent_hstring_hash, til::transparent_hstring_equal_to> _ignoredNamespaces;\r",
        "comment_created_at": "2024-10-08T17:35:55+00:00",
        "comment_author": "lhecker",
        "comment_body": "As far as I know, the only thing that C++23 adds are more heterogenous overloads, but it remains opt-in so as to not break existing code. It would also not help us here, because just like C++, cppwinrt is also frozen in time and it's what would require the `is_transparent` attribute on its hash/equal_to structs ([here](https://github.com/microsoft/cppwinrt/blob/f9ec1986083a70d2f99d726b06b00a38cb2d1054/strings/base_std_hash.h#L37-L43)).",
        "pr_file_module": null
      },
      {
        "comment_id": "1792313272",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18009,
        "pr_file": "src/cascadia/TerminalSettingsModel/CascadiaSettings.h",
        "discussion_id": "1792253618",
        "commented_code": "@@ -96,7 +96,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         void _addOrMergeUserColorScheme(const winrt::com_ptr<implementation::ColorScheme>& colorScheme);\r\n         void _executeGenerator(const IDynamicProfileGenerator& generator);\r\n \r\n-        std::unordered_set<std::wstring_view> _ignoredNamespaces;\r\n+        std::unordered_set<winrt::hstring, til::transparent_hstring_hash, til::transparent_hstring_equal_to> _ignoredNamespaces;\r",
        "comment_created_at": "2024-10-08T18:15:48+00:00",
        "comment_author": "DHowett",
        "comment_body": "\ud83e\udd72 ",
        "pr_file_module": null
      }
    ]
  }
]