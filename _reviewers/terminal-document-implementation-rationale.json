[
  {
    "discussion_id": "2252835191",
    "pr_number": 19143,
    "pr_file": "src/cascadia/UIHelpers/IconPathConverter.cpp",
    "created_at": "2025-08-05T00:21:55+00:00",
    "commented_code": "//\r\n             // Anything longer than 2 wchar_t's _isn't_ an emoji or symbol, so\r\n             // don't do this if it's just an invalid path.\r\n-            if (!iconSource && iconPath.size() <= 2)\r\n+            const std::wstring_view iconPathAsView{ iconPath };\r\n+            if (!iconSource &&\r\n+                (iconPathAsView.size() <= 2 || iconPathAsView.find_first_of(L'\\u200D') <= 8 || (iconPathAsView.size() <= 4 && (iconPathAsView.back() & 0xFE00) == 0xFE00)))",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2252835191",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19143,
        "pr_file": "src/cascadia/UIHelpers/IconPathConverter.cpp",
        "discussion_id": "2252835191",
        "commented_code": "@@ -135,7 +135,9 @@ namespace winrt::Microsoft::Terminal::UI::implementation\n             //\r\n             // Anything longer than 2 wchar_t's _isn't_ an emoji or symbol, so\r\n             // don't do this if it's just an invalid path.\r\n-            if (!iconSource && iconPath.size() <= 2)\r\n+            const std::wstring_view iconPathAsView{ iconPath };\r\n+            if (!iconSource &&\r\n+                (iconPathAsView.size() <= 2 || iconPathAsView.find_first_of(L'\\u200D') <= 8 || (iconPathAsView.size() <= 4 && (iconPathAsView.back() & 0xFE00) == 0xFE00)))\r",
        "comment_created_at": "2025-08-05T00:21:55+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "```suggestion\n            // An icon path is considered an emoji if...\n            // - its length is <= 2 code units (two surrogate pairs)\n            // - it contains a zero-width joiner (U+200D within the first 15 code units)\n            // - its length is <= 4 code units and it ends with a Unicode Variation Selector (U+FE0E or U+FE0F)\n            const std::wstring_view iconPathAsView{ iconPath };\n            if (!iconSource &&\n                (iconPathAsView.size() <= 2 || iconPathAsView.find_first_of(L'\\u200D') <= 8 || (iconPathAsView.size() <= 4 && (iconPathAsView.back() & 0xFE00) == 0xFE00)))\n```\n\nOr something like that. Really I just like that your explanation in the PR body mentions \"zero-width joiner\" and \"Unicode Variation Selector\". Including those terms as a comment makes the new if-statement much more readable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205474957",
    "pr_number": 19130,
    "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
    "created_at": "2025-07-14T17:42:27+00:00",
    "commented_code": "// Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();\n \n-            for (const auto& match : highlightedText.Segments())\n+        if (!text.empty())\n+        {\n+            size_t lastPos = 0;\n+            if (runs && runs.Size())\n             {\n-                const auto matchText = match.TextSegment();\n-                const auto fontWeight = match.IsHighlighted() ? FontWeights::Bold() : FontWeights::Normal();\n+                const auto runStyle = HighlightedRunStyle();\n+\n+                for (const auto& [start, end] : runs)\n+                {\n+                    if (start > lastPos)\n+                    {\n+                        hstring nonMatch{ til::safe_slice_abs(text, lastPos, start) };\n+                        Documents::Run run;\n+                        run.Text(nonMatch);\n+                        inlinesCollection.Append(run);\n+                    }\n+\n+                    hstring matchSeg{ til::safe_slice_abs(text, start, end + 1) };\n+                    Documents::Run run;\n+                    run.Text(matchSeg);\n+\n+                    if (runStyle)\n+                    {\n+                        _applyStyleToObject(runStyle, run);\n+                    }\n+                    else\n+                    {\n+                        // Default style: bold\n+                        run.FontWeight(FontWeights::Bold());\n+                    }\n+                    inlinesCollection.Append(run);\n \n+                    lastPos = end + 1;\n+                }\n+            }\n+\n+            // This will also be true if there are no runs at all\n+            if (lastPos < text.size())\n+            {\n+                // checking lastPos here prevents a needless deep copy of the whole text in the no-match case\n+                hstring tail{ lastPos == 0 ? text : hstring{ til::safe_slice_abs(text, lastPos, SIZE_T_MAX) } };",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2205474957",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19130,
        "pr_file": "src/cascadia/TerminalApp/HighlightedTextControl.cpp",
        "discussion_id": "2205474957",
        "commented_code": "@@ -22,70 +22,150 @@ namespace winrt::TerminalApp::implementation\n     // Our control exposes a \"Text\" property to be used with Data Binding\n     // To allow this we need to register a Dependency Property Identifier to be used by the property system\n     // (https://docs.microsoft.com/en-us/windows/uwp/xaml-platform/custom-dependency-properties)\n-    DependencyProperty HighlightedTextControl::_textProperty = DependencyProperty::Register(\n-        L\"Text\",\n-        xaml_typename<winrt::TerminalApp::HighlightedText>(),\n-        xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n-        PropertyMetadata(nullptr, HighlightedTextControl::_onTextChanged));\n+    DependencyProperty HighlightedTextControl::_TextProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunsProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_TextBlockStyleProperty{ nullptr };\n+    DependencyProperty HighlightedTextControl::_HighlightedRunStyleProperty{ nullptr };\n \n     HighlightedTextControl::HighlightedTextControl()\n     {\n-        InitializeComponent();\n+        _InitializeProperties();\n     }\n \n-    // Method Description:\n-    // - Returns the Identifier of the \"Text\" dependency property\n-    DependencyProperty HighlightedTextControl::TextProperty()\n+    void HighlightedTextControl::_InitializeProperties()\n     {\n-        return _textProperty;\n+        static auto [[maybe_unused]] registered = [] {\n+            _TextProperty = DependencyProperty::Register(\n+                L\"Text\",\n+                xaml_typename<winrt::hstring>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _HighlightedRunsProperty = DependencyProperty::Register(\n+                L\"HighlightedRuns\",\n+                xaml_typename<winrt::Windows::Foundation::Collections::IVector<winrt::TerminalApp::HighlightedRun>>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            _TextBlockStyleProperty = DependencyProperty::Register(\n+                L\"TextBlockStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata{ nullptr });\n+\n+            _HighlightedRunStyleProperty = DependencyProperty::Register(\n+                L\"HighlightedRunStyle\",\n+                xaml_typename<winrt::Windows::UI::Xaml::Style>(),\n+                xaml_typename<winrt::TerminalApp::HighlightedTextControl>(),\n+                PropertyMetadata(nullptr, HighlightedTextControl::_onPropertyChanged));\n+\n+            return true;\n+        }();\n     }\n \n-    // Method Description:\n-    // - Returns the TextBlock view used to render the highlighted text\n-    // Can be used when the Text property change is triggered by the event system to update the view\n-    // We need to expose it rather than simply bind a data source because we update the runs in code-behind\n-    Controls::TextBlock HighlightedTextControl::TextView()\n+    void HighlightedTextControl::_onPropertyChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& /*e*/)\n     {\n-        return _textView();\n+        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n+        if (control)\n+        {\n+            winrt::get_self<HighlightedTextControl>(control)->_updateTextAndStyle();\n+        }\n     }\n \n-    winrt::TerminalApp::HighlightedText HighlightedTextControl::Text()\n+    void HighlightedTextControl::OnApplyTemplate()\n     {\n-        return winrt::unbox_value<winrt::TerminalApp::HighlightedText>(GetValue(_textProperty));\n+        _updateTextAndStyle();\n     }\n \n-    void HighlightedTextControl::Text(const winrt::TerminalApp::HighlightedText& value)\n+    static void _applyStyleToObject(const winrt::Windows::UI::Xaml::Style& style, const winrt::Windows::UI::Xaml::DependencyObject& object)\n     {\n-        SetValue(_textProperty, winrt::box_value(value));\n+        if (!style)\n+        {\n+            return;\n+        }\n+\n+        static const auto fontWeightProperty{ winrt::Windows::UI::Xaml::Documents::TextElement::FontWeightProperty() };\n+\n+        const auto setters{ style.Setters() };\n+        for (auto&& setterBase : setters)\n+        {\n+            auto setter = setterBase.as<winrt::Windows::UI::Xaml::Setter>();\n+            auto property = setter.Property();\n+            auto value = setter.Value();\n+\n+            if (property == fontWeightProperty) [[unlikely]]\n+            {\n+                // BODGY - The XAML compiler emits a boxed int32, but the dependency property\n+                // here expects a boxed FontWeight (which also requires a u16. heh.)\n+                // FontWeight is one of the few properties that is broken like this, and on Run it's the\n+                // only one... so we can trivially check this case.\n+                const auto weight{ winrt::unbox_value_or<int32_t>(value, static_cast<int32_t>(400)) };\n+                value = winrt::box_value(winrt::Windows::UI::Text::FontWeight{ static_cast<uint16_t>(weight) });\n+            }\n+\n+            object.SetValue(property, value);\n+        }\n     }\n \n-    // Method Description:\n-    // - This callback is triggered when the Text property is changed. Responsible for updating the view\n-    // Arguments:\n-    // - o - dependency object that was modified, expected to be an instance of this control\n-    // - e - event arguments of the property changed event fired by the event system upon Text property change.\n-    // The new value is expected to be an instance of HighlightedText\n-    void HighlightedTextControl::_onTextChanged(const DependencyObject& o, const DependencyPropertyChangedEventArgs& e)\n+    void HighlightedTextControl::_updateTextAndStyle()\n     {\n-        const auto control = o.try_as<winrt::TerminalApp::HighlightedTextControl>();\n-        const auto highlightedText = e.NewValue().try_as<winrt::TerminalApp::HighlightedText>();\n-\n-        if (control && highlightedText)\n+        const auto textBlock = GetTemplateChild(L\"TextView\").try_as<winrt::Windows::UI::Xaml::Controls::TextBlock>();\n+        if (!textBlock)\n         {\n-            // Replace all the runs on the TextBlock\n-            // Use IsHighlighted to decide if the run should be highlighted.\n-            // To do - export the highlighting style into XAML\n-            const auto inlinesCollection = control.TextView().Inlines();\n-            inlinesCollection.Clear();\n+            return;\n+        }\n+\n+        const auto text = Text();\n+        const auto runs = HighlightedRuns();\n+\n+        // Replace all the runs on the TextBlock\n+        // Use the runs to decide if the run should be highlighted.\n+        const auto inlinesCollection = textBlock.Inlines();\n+        inlinesCollection.Clear();\n \n-            for (const auto& match : highlightedText.Segments())\n+        if (!text.empty())\n+        {\n+            size_t lastPos = 0;\n+            if (runs && runs.Size())\n             {\n-                const auto matchText = match.TextSegment();\n-                const auto fontWeight = match.IsHighlighted() ? FontWeights::Bold() : FontWeights::Normal();\n+                const auto runStyle = HighlightedRunStyle();\n+\n+                for (const auto& [start, end] : runs)\n+                {\n+                    if (start > lastPos)\n+                    {\n+                        hstring nonMatch{ til::safe_slice_abs(text, lastPos, start) };\n+                        Documents::Run run;\n+                        run.Text(nonMatch);\n+                        inlinesCollection.Append(run);\n+                    }\n+\n+                    hstring matchSeg{ til::safe_slice_abs(text, start, end + 1) };\n+                    Documents::Run run;\n+                    run.Text(matchSeg);\n+\n+                    if (runStyle)\n+                    {\n+                        _applyStyleToObject(runStyle, run);\n+                    }\n+                    else\n+                    {\n+                        // Default style: bold\n+                        run.FontWeight(FontWeights::Bold());\n+                    }\n+                    inlinesCollection.Append(run);\n \n+                    lastPos = end + 1;\n+                }\n+            }\n+\n+            // This will also be true if there are no runs at all\n+            if (lastPos < text.size())\n+            {\n+                // checking lastPos here prevents a needless deep copy of the whole text in the no-match case\n+                hstring tail{ lastPos == 0 ? text : hstring{ til::safe_slice_abs(text, lastPos, SIZE_T_MAX) } };",
        "comment_created_at": "2025-07-14T17:42:27+00:00",
        "comment_author": "DHowett",
        "comment_body": "nit: in general in this file, I should document _WHY WE HAVE TEMPORARY HSTRINGS_. i had to rediscover it for myself.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2103450726",
    "pr_number": 18940,
    "pr_file": "src/cascadia/TerminalSettingsModel/ActionMap.cpp",
    "created_at": "2025-05-22T21:54:44+00:00",
    "commented_code": "// - oldKeys: the key binding that we are rebinding\r\n     // - newKeys: the new key chord that is being used to replace oldKeys\r\n     // Return Value:\r\n-    // - true, if successful. False, otherwise.\r\n+    // - true, if successful. False; otherwise,.",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2103450726",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18940,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionMap.cpp",
        "discussion_id": "2103450726",
        "commented_code": "@@ -692,7 +692,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n     // - oldKeys: the key binding that we are rebinding\r\n     // - newKeys: the new key chord that is being used to replace oldKeys\r\n     // Return Value:\r\n-    // - true, if successful. False, otherwise.\r\n+    // - true, if successful. False; otherwise,.\r",
        "comment_created_at": "2025-05-22T21:54:44+00:00",
        "comment_author": "DHowett",
        "comment_body": "I believe these should be rephrased to `False otherwise.`; otherwise, this is somewhat of an unusual outcome",
        "pr_file_module": null
      },
      {
        "comment_id": "2103492585",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18940,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionMap.cpp",
        "discussion_id": "2103450726",
        "commented_code": "@@ -692,7 +692,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n     // - oldKeys: the key binding that we are rebinding\r\n     // - newKeys: the new key chord that is being used to replace oldKeys\r\n     // Return Value:\r\n-    // - true, if successful. False, otherwise.\r\n+    // - true, if successful. False; otherwise,.\r",
        "comment_created_at": "2025-05-22T22:39:00+00:00",
        "comment_author": "jsoref",
        "comment_body": "I'm currently struggling with `true`...`False`.\r\n\r\nA quick survey shows it happens ~9 times after `Return Value:` in the repository (including here).\r\n\r\nBy contrast `True`...`False` happens 98 times.\r\n>  // - True if ctrl was held. False otherwise.\r\n\r\nEven `true`...`false` happens more often ~33 times.\r\n\r\nHere are some examples:\r\n> // - true of light, false if dark\r\n  -- this is wrong for another reason -- it should be `if` not `of` \ud83e\udd26 -- note that this was the first one I found while looking for an example of this case\r\n> // - true if we handled the event was handled, else false.\r\n> // true iff we were able to select that tab index, false otherwise\r\n> // - showOrHide: Show is true; hide is false.\r\n   -- this is actually _before_ `// Return Value:` (I'm using VSCode's search w/ 1 line of context above&below)\r\n> // - true if partial char data is available, false otherwise",
        "pr_file_module": null
      },
      {
        "comment_id": "2103521076",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18940,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionMap.cpp",
        "discussion_id": "2103450726",
        "commented_code": "@@ -692,7 +692,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n     // - oldKeys: the key binding that we are rebinding\r\n     // - newKeys: the new key chord that is being used to replace oldKeys\r\n     // Return Value:\r\n-    // - true, if successful. False, otherwise.\r\n+    // - true, if successful. False; otherwise,.\r",
        "comment_created_at": "2025-05-22T22:52:35+00:00",
        "comment_author": "DHowett",
        "comment_body": "Many of these are great examples for Leonard's \"It's capacitity\". We seriously overdocument some otherwise obvious stuff and keep doing it out of sheer inertia.\r\n\r\n\"GetIsEnabled\" \"Gets whether the thing is enabled\" \"Arguments: thing - the thing for which to report the enablement status\" \"Returns: true of the thing is enabled; false, otherwise,.\"\r\n\r\nNow, I alone am the person to blame for using `iff`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2103647998",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18940,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionMap.cpp",
        "discussion_id": "2103450726",
        "commented_code": "@@ -692,7 +692,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n     // - oldKeys: the key binding that we are rebinding\r\n     // - newKeys: the new key chord that is being used to replace oldKeys\r\n     // Return Value:\r\n-    // - true, if successful. False, otherwise.\r\n+    // - true, if successful. False; otherwise,.\r",
        "comment_created_at": "2025-05-23T01:40:29+00:00",
        "comment_author": "jsoref",
        "comment_body": "This feels like a really good argument for deleting such things.\r\n\r\nI think I actually remember that `iff` from a number of years ago...",
        "pr_file_module": null
      },
      {
        "comment_id": "2103663181",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18940,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionMap.cpp",
        "discussion_id": "2103450726",
        "commented_code": "@@ -692,7 +692,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n     // - oldKeys: the key binding that we are rebinding\r\n     // - newKeys: the new key chord that is being used to replace oldKeys\r\n     // Return Value:\r\n-    // - true, if successful. False, otherwise.\r\n+    // - true, if successful. False; otherwise,.\r",
        "comment_created_at": "2025-05-23T02:01:49+00:00",
        "comment_author": "jsoref",
        "comment_body": "For booleans, could I propose replacing the current style with\r\n\r\n> - indicates that the thing did what it was supposed to do\r\n\r\n```diff\r\n     // Return Value:\r\n-    // - true if we handled the event was handled, else false.\r\n+    // ... if true, indicates the event was handled\r\n```\r\n(This is a real example, and it's a real mess `handled...handled`)\r\n\r\nProgrammers _should_ be able to understand binary negation. And the extra words here in so many of these instances seem to be a recipe for making mistakes.",
        "pr_file_module": null
      }
    ]
  }
]