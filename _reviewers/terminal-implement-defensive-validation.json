[
  {
    "discussion_id": "2252252965",
    "pr_number": 19210,
    "pr_file": "src/cascadia/TerminalApp/MinMaxCloseControl.cpp",
    "created_at": "2025-08-04T18:11:32+00:00",
    "commented_code": "// (which should be the default, see:\r\n         // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)\r\n         unsigned int hoverTimeoutMillis{ 400 };\r\n-        LOG_IF_WIN32_BOOL_FALSE(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0));\r\n-        const auto toolTipInterval = std::chrono::milliseconds(hoverTimeoutMillis);\r\n+        if (FAILED(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0)))\r\n+        {\r\n+            hoverTimeoutMillis = 400;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2252252965",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19210,
        "pr_file": "src/cascadia/TerminalApp/MinMaxCloseControl.cpp",
        "discussion_id": "2252252965",
        "commented_code": "@@ -35,17 +35,23 @@ namespace winrt::TerminalApp::implementation\n         // (which should be the default, see:\r\n         // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)\r\n         unsigned int hoverTimeoutMillis{ 400 };\r\n-        LOG_IF_WIN32_BOOL_FALSE(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0));\r\n-        const auto toolTipInterval = std::chrono::milliseconds(hoverTimeoutMillis);\r\n+        if (FAILED(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0)))\r\n+        {\r\n+            hoverTimeoutMillis = 400;\r",
        "comment_created_at": "2025-08-04T18:11:32+00:00",
        "comment_author": "DHowett",
        "comment_body": "does `SystemParametersInfoW` destroy the value on failure? bah!",
        "pr_file_module": null
      },
      {
        "comment_id": "2252259963",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19210,
        "pr_file": "src/cascadia/TerminalApp/MinMaxCloseControl.cpp",
        "discussion_id": "2252252965",
        "commented_code": "@@ -35,17 +35,23 @@ namespace winrt::TerminalApp::implementation\n         // (which should be the default, see:\r\n         // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)\r\n         unsigned int hoverTimeoutMillis{ 400 };\r\n-        LOG_IF_WIN32_BOOL_FALSE(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0));\r\n-        const auto toolTipInterval = std::chrono::milliseconds(hoverTimeoutMillis);\r\n+        if (FAILED(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0)))\r\n+        {\r\n+            hoverTimeoutMillis = 400;\r",
        "comment_created_at": "2025-08-04T18:14:15+00:00",
        "comment_author": "lhecker",
        "comment_body": "I don't know that, but I don't believe that we should rely on the assumption that it doesn't. I doubt that this was tested in some way too (after all, can this call even fail?).",
        "pr_file_module": null
      },
      {
        "comment_id": "2252269645",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19210,
        "pr_file": "src/cascadia/TerminalApp/MinMaxCloseControl.cpp",
        "discussion_id": "2252252965",
        "commented_code": "@@ -35,17 +35,23 @@ namespace winrt::TerminalApp::implementation\n         // (which should be the default, see:\r\n         // https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-trackmouseevent#remarks)\r\n         unsigned int hoverTimeoutMillis{ 400 };\r\n-        LOG_IF_WIN32_BOOL_FALSE(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0));\r\n-        const auto toolTipInterval = std::chrono::milliseconds(hoverTimeoutMillis);\r\n+        if (FAILED(SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hoverTimeoutMillis, 0)))\r\n+        {\r\n+            hoverTimeoutMillis = 400;\r",
        "comment_created_at": "2025-08-04T18:19:48+00:00",
        "comment_author": "lhecker",
        "comment_body": "After reviewing the kernel code, I found that the call can never fail.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143318624",
    "pr_number": 19023,
    "pr_file": "src/cascadia/TerminalApp/Pane.cpp",
    "created_at": "2025-06-12T17:46:11+00:00",
    "commented_code": "// take the control, profile, id and isDefTermSession of the pane that _wasn't_ closed.\r\n         _setPaneContent(remainingChild->_takePaneContent());",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2143318624",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19023,
        "pr_file": "src/cascadia/TerminalApp/Pane.cpp",
        "discussion_id": "2143318624",
        "commented_code": "@@ -1402,6 +1402,13 @@ void Pane::_CloseChild(const bool closeFirst)\n \r\n         // take the control, profile, id and isDefTermSession of the pane that _wasn't_ closed.\r\n         _setPaneContent(remainingChild->_takePaneContent());\r",
        "comment_created_at": "2025-06-12T17:46:11+00:00",
        "comment_author": "lhecker",
        "comment_body": "Should we still call `_setPaneContent` if `_takePaneContent` returned null?\r\n\r\n(Thanks for fixing this btw!)",
        "pr_file_module": null
      },
      {
        "comment_id": "2143346113",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19023,
        "pr_file": "src/cascadia/TerminalApp/Pane.cpp",
        "discussion_id": "2143318624",
        "commented_code": "@@ -1402,6 +1402,13 @@ void Pane::_CloseChild(const bool closeFirst)\n \r\n         // take the control, profile, id and isDefTermSession of the pane that _wasn't_ closed.\r\n         _setPaneContent(remainingChild->_takePaneContent());\r",
        "comment_created_at": "2025-06-12T18:01:57+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "https://github.com/microsoft/terminal/blob/ad149228744ca1b2ad1ee50bfbe6eb474b7141a4/src/cascadia/TerminalApp/Pane.cpp#L1720-L1734\r\n\r\nThe whole function results in a no-op, so we can totally split this up into:\r\n```cpp\r\nconst auto& content = remainingChild->_takePaneContent();\r\nif (!content)\r\n{\r\n   Closed.raise(nullptr, nullptr);\r\n   return;\r\n}\r\n_setPaneContent(content);\r\n```\r\n\r\nUp to you. I'm indifferent to it, personally.",
        "pr_file_module": null
      },
      {
        "comment_id": "2162530140",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19023,
        "pr_file": "src/cascadia/TerminalApp/Pane.cpp",
        "discussion_id": "2143318624",
        "commented_code": "@@ -1402,6 +1402,13 @@ void Pane::_CloseChild(const bool closeFirst)\n \r\n         // take the control, profile, id and isDefTermSession of the pane that _wasn't_ closed.\r\n         _setPaneContent(remainingChild->_takePaneContent());\r",
        "comment_created_at": "2025-06-23T21:04:28+00:00",
        "comment_author": "PankajBhojwani",
        "comment_body": "I think we might actually need the `_setPaneContent` call because that's what calls `Close` on our _current_ pane content",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945545111",
    "pr_number": 18347,
    "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
    "created_at": "2025-02-06T22:09:52+00:00",
    "commented_code": "searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r\n+    auto iter = buffer.GetCellDataAt(dir == SearchDirection::Forward ? searchStart : searchEnd);\r\n+    while (dir == SearchDirection::Forward ? iter.Pos() < searchEnd : iter.Pos() > searchStart)\r\n+    {\r\n+        // Don't let us select the same hyperlink again\r\n+        if (iter.Pos() < _selection->start || iter.Pos() > _selection->end)\r\n         {\r\n-            return;\r\n+            if (auto attr = iter->TextAttr(); attr.IsHyperlink())\r\n+            {\r\n+                // Found an embedded hyperlink!\r\n+                const auto hyperlinkId = attr.GetHyperlinkId();\r\n+\r\n+                // Expand the start to include the entire hyperlink\r\n+                TextBufferCellIterator hyperlinkStartIter{ buffer, iter.Pos() };\r\n+                while (attr.IsHyperlink() && attr.GetHyperlinkId() == hyperlinkId)",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1945545111",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18347,
        "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
        "discussion_id": "1945545111",
        "commented_code": "@@ -547,27 +548,69 @@ void Terminal::SelectHyperlink(const SearchDirection dir)\n                 searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r\n+    auto iter = buffer.GetCellDataAt(dir == SearchDirection::Forward ? searchStart : searchEnd);\r\n+    while (dir == SearchDirection::Forward ? iter.Pos() < searchEnd : iter.Pos() > searchStart)\r\n+    {\r\n+        // Don't let us select the same hyperlink again\r\n+        if (iter.Pos() < _selection->start || iter.Pos() > _selection->end)\r\n         {\r\n-            return;\r\n+            if (auto attr = iter->TextAttr(); attr.IsHyperlink())\r\n+            {\r\n+                // Found an embedded hyperlink!\r\n+                const auto hyperlinkId = attr.GetHyperlinkId();\r\n+\r\n+                // Expand the start to include the entire hyperlink\r\n+                TextBufferCellIterator hyperlinkStartIter{ buffer, iter.Pos() };\r\n+                while (attr.IsHyperlink() && attr.GetHyperlinkId() == hyperlinkId)\r",
        "comment_created_at": "2025-02-06T22:09:52+00:00",
        "comment_author": "lhecker",
        "comment_body": "If the hyperlink starts at the origin of the search, couldn't this accidentally leave the boundaries of it?",
        "pr_file_module": null
      },
      {
        "comment_id": "1962569430",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18347,
        "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
        "discussion_id": "1945545111",
        "commented_code": "@@ -547,27 +548,69 @@ void Terminal::SelectHyperlink(const SearchDirection dir)\n                 searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r\n+    auto iter = buffer.GetCellDataAt(dir == SearchDirection::Forward ? searchStart : searchEnd);\r\n+    while (dir == SearchDirection::Forward ? iter.Pos() < searchEnd : iter.Pos() > searchStart)\r\n+    {\r\n+        // Don't let us select the same hyperlink again\r\n+        if (iter.Pos() < _selection->start || iter.Pos() > _selection->end)\r\n         {\r\n-            return;\r\n+            if (auto attr = iter->TextAttr(); attr.IsHyperlink())\r\n+            {\r\n+                // Found an embedded hyperlink!\r\n+                const auto hyperlinkId = attr.GetHyperlinkId();\r\n+\r\n+                // Expand the start to include the entire hyperlink\r\n+                TextBufferCellIterator hyperlinkStartIter{ buffer, iter.Pos() };\r\n+                while (attr.IsHyperlink() && attr.GetHyperlinkId() == hyperlinkId)\r",
        "comment_created_at": "2025-02-20T00:22:17+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "Good catch. Fixed!\r\n\r\nThis also found another bug that I fixed in the latest commit. If my selection was at the exclusive end position of the row, we would crash when attempting to `buffer.GetCellDataAt()` it. Now I clamp just to be safe",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1844537725",
    "pr_number": 18015,
    "pr_file": "src/cascadia/TerminalSettingsEditor/NewTabMenuViewModel.cpp",
    "created_at": "2024-11-15T21:36:36+00:00",
    "commented_code": "+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+#include \"NewTabMenuViewModel.h\"\r\n+#include <LibraryResources.h>\r\n+\r\n+#include \"NewTabMenuViewModel.g.cpp\"\r\n+#include \"FolderTreeViewEntry.g.cpp\"\r\n+#include \"NewTabMenuEntryViewModel.g.cpp\"\r\n+#include \"ProfileEntryViewModel.g.cpp\"\r\n+#include \"ActionEntryViewModel.g.cpp\"\r\n+#include \"SeparatorEntryViewModel.g.cpp\"\r\n+#include \"FolderEntryViewModel.g.cpp\"\r\n+#include \"MatchProfilesEntryViewModel.g.cpp\"\r\n+#include \"RemainingProfilesEntryViewModel.g.cpp\"\r\n+\r\n+using namespace winrt::Windows::UI::Xaml::Navigation;\r\n+using namespace winrt::Windows::Foundation;\r\n+using namespace winrt::Windows::Foundation::Collections;\r\n+using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n+using namespace winrt::Windows::UI::Xaml::Data;\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n+{\r\n+    static IObservableVector<Editor::NewTabMenuEntryViewModel> _ConvertToViewModelEntries(const IVector<Model::NewTabMenuEntry>& settingsModelEntries, const Model::CascadiaSettings& settings)\r\n+    {\r\n+        std::vector<Editor::NewTabMenuEntryViewModel> result{};\r\n+        if (!settingsModelEntries)\r\n+        {\r\n+            return single_threaded_observable_vector<Editor::NewTabMenuEntryViewModel>(std::move(result));\r\n+        }\r\n+\r\n+        for (const auto& entry : settingsModelEntries)\r\n+        {\r\n+            switch (entry.Type())\r\n+            {\r\n+            case NewTabMenuEntryType::Profile:\r\n+            {\r\n+                // If the Profile isn't set, this is an invalid entry. Skip it.\r\n+                if (const auto& profileEntry = entry.as<Model::ProfileEntry>(); profileEntry.Profile())\r\n+                {\r\n+                    result.push_back(make<ProfileEntryViewModel>(profileEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Action:\r\n+            {\r\n+                if (const auto& actionEntry = entry.as<Model::ActionEntry>())\r\n+                {\r\n+                    result.push_back(make<ActionEntryViewModel>(actionEntry, settings));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Separator:\r\n+            {\r\n+                if (const auto& separatorEntry = entry.as<Model::SeparatorEntry>())\r\n+                {\r\n+                    result.push_back(make<SeparatorEntryViewModel>(separatorEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Folder:\r\n+            {\r\n+                if (const auto& folderEntry = entry.as<Model::FolderEntry>())\r\n+                {\r\n+                    // The ctor will convert the children of the folder to view models\r\n+                    result.push_back(make<FolderEntryViewModel>(folderEntry, settings));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::MatchProfiles:\r\n+            {\r\n+                if (const auto& matchProfilesEntry = entry.as<Model::MatchProfilesEntry>())\r\n+                {\r\n+                    result.push_back(make<MatchProfilesEntryViewModel>(matchProfilesEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::RemainingProfiles:\r\n+            {\r\n+                if (const auto& remainingProfilesEntry = entry.as<Model::RemainingProfilesEntry>())\r\n+                {\r\n+                    result.push_back(make<RemainingProfilesEntryViewModel>(remainingProfilesEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Invalid:\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n+        return single_threaded_observable_vector<Editor::NewTabMenuEntryViewModel>(std::move(result));\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::IsRemainingProfilesEntryMissing() const\r\n+    {\r\n+        return _IsRemainingProfilesEntryMissing(_rootEntries);\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::_IsRemainingProfilesEntryMissing(const IVector<Editor::NewTabMenuEntryViewModel>& entries)\r\n+    {\r\n+        for (const auto& entry : entries)\r\n+        {\r\n+            switch (entry.Type())\r\n+            {\r\n+            case NewTabMenuEntryType::RemainingProfiles:\r\n+            {\r\n+                return false;\r\n+            }\r\n+            case NewTabMenuEntryType::Folder:\r\n+            {\r\n+                if (!_IsRemainingProfilesEntryMissing(entry.as<Editor::FolderEntryViewModel>().Entries()))\r\n+                {\r\n+                    return false;\r\n+                }\r\n+                break;\r\n+            }\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::IsFolderView() const noexcept\r\n+    {\r\n+        return CurrentView() != _rootEntries;\r\n+    }\r\n+\r\n+    NewTabMenuViewModel::NewTabMenuViewModel(Model::CascadiaSettings settings)\r\n+    {\r\n+        UpdateSettings(settings);\r\n+\r\n+        // Add a property changed handler to our own property changed event.\r\n+        // This propagates changes from the settings model to anybody listening to our\r\n+        // unique view model members.\r\n+        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {\r\n+            const auto viewModelProperty{ args.PropertyName() };\r\n+            if (viewModelProperty == L\"AvailableProfiles\")\r\n+            {\r\n+                _NotifyChanges(L\"SelectedProfile\");\r\n+            }\r\n+            else if (viewModelProperty == L\"CurrentFolder\")\r\n+            {\r\n+                if (_CurrentFolder)\r\n+                {\r\n+                    CurrentFolderName(_CurrentFolder.Name());\r\n+                    _CurrentFolder.PropertyChanged({ this, &NewTabMenuViewModel::_FolderPropertyChanged });\r\n+                }\r\n+                _NotifyChanges(L\"IsFolderView\", L\"CurrentView\");\r\n+            }\r\n+        });\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::_FolderPropertyChanged(const IInspectable& /*sender*/, const Windows::UI::Xaml::Data::PropertyChangedEventArgs& args)\r\n+    {\r\n+        const auto viewModelProperty{ args.PropertyName() };\r\n+        if (viewModelProperty == L\"Name\")\r\n+        {\r\n+            // FolderTree needs to be updated when a folder is renamed\r\n+            _folderTreeCache = nullptr;\r\n+        }\r\n+    }\r\n+\r\n+    hstring NewTabMenuViewModel::CurrentFolderName() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.Name();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderName(const hstring& value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.Name() != value)\r\n+        {\r\n+            _CurrentFolder.Name(value);\r\n+            _NotifyChanges(L\"CurrentFolderName\");\r\n+        }\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::CurrentFolderInlining() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.Inlining();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderInlining(bool value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.Inlining() != value)\r\n+        {\r\n+            _CurrentFolder.Inlining(value);\r\n+            _NotifyChanges(L\"CurrentFolderInlining\");\r\n+        }\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::CurrentFolderAllowEmpty() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.AllowEmpty();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderAllowEmpty(bool value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.AllowEmpty() != value)\r\n+        {\r\n+            _CurrentFolder.AllowEmpty(value);\r\n+            _NotifyChanges(L\"CurrentFolderAllowEmpty\");\r\n+        }\r\n+    }\r\n+\r\n+    Windows::Foundation::Collections::IObservableVector<Editor::NewTabMenuEntryViewModel> NewTabMenuViewModel::CurrentView() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return _rootEntries;\r\n+        }\r\n+        return _CurrentFolder.Entries();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::UpdateSettings(const Model::CascadiaSettings& settings)\r\n+    {\r\n+        _Settings = settings;\r\n+        _NotifyChanges(L\"AvailableProfiles\");\r\n+\r\n+        SelectedProfile(AvailableProfiles().GetAt(0));\r\n+\r\n+        _rootEntries = _ConvertToViewModelEntries(_Settings.GlobalSettings().NewTabMenu(), _Settings);\r\n+\r\n+        _rootEntriesChangedRevoker = _rootEntries.VectorChanged(winrt::auto_revoke, [this](auto&&, const IVectorChangedEventArgs& args) {\r\n+            switch (args.CollectionChange())\r\n+            {\r\n+            case CollectionChange::Reset:\r\n+            {\r\n+                // fully replace settings model with view model structure\r\n+                std::vector<Model::NewTabMenuEntry> modelEntries;\r\n+                for (const auto& entry : _rootEntries)\r\n+                {\r\n+                    modelEntries.push_back(NewTabMenuEntryViewModel::GetModel(entry));\r\n+                }\r\n+                _Settings.GlobalSettings().NewTabMenu(single_threaded_vector<Model::NewTabMenuEntry>(std::move(modelEntries)));\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemInserted:\r\n+            {\r\n+                const auto& insertedEntryVM = _rootEntries.GetAt(args.Index());\r\n+                const auto& insertedEntry = NewTabMenuEntryViewModel::GetModel(insertedEntryVM);\r\n+                _Settings.GlobalSettings().NewTabMenu().InsertAt(args.Index(), insertedEntry);\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemRemoved:\r\n+            {\r\n+                _Settings.GlobalSettings().NewTabMenu().RemoveAt(args.Index());\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemChanged:\r\n+            {\r\n+                const auto& modifiedEntry = _rootEntries.GetAt(args.Index());\r\n+                _Settings.GlobalSettings().NewTabMenu().SetAt(args.Index(), NewTabMenuEntryViewModel::GetModel(modifiedEntry));\r\n+                return;\r\n+            }\r\n+            }\r\n+        });\r\n+\r\n+        // Clear CurrentFolder to reset the view\r\n+        _CurrentFolder = nullptr;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1844537725",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18015,
        "pr_file": "src/cascadia/TerminalSettingsEditor/NewTabMenuViewModel.cpp",
        "discussion_id": "1844537725",
        "commented_code": "@@ -0,0 +1,765 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+#include \"NewTabMenuViewModel.h\"\r\n+#include <LibraryResources.h>\r\n+\r\n+#include \"NewTabMenuViewModel.g.cpp\"\r\n+#include \"FolderTreeViewEntry.g.cpp\"\r\n+#include \"NewTabMenuEntryViewModel.g.cpp\"\r\n+#include \"ProfileEntryViewModel.g.cpp\"\r\n+#include \"ActionEntryViewModel.g.cpp\"\r\n+#include \"SeparatorEntryViewModel.g.cpp\"\r\n+#include \"FolderEntryViewModel.g.cpp\"\r\n+#include \"MatchProfilesEntryViewModel.g.cpp\"\r\n+#include \"RemainingProfilesEntryViewModel.g.cpp\"\r\n+\r\n+using namespace winrt::Windows::UI::Xaml::Navigation;\r\n+using namespace winrt::Windows::Foundation;\r\n+using namespace winrt::Windows::Foundation::Collections;\r\n+using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n+using namespace winrt::Windows::UI::Xaml::Data;\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n+{\r\n+    static IObservableVector<Editor::NewTabMenuEntryViewModel> _ConvertToViewModelEntries(const IVector<Model::NewTabMenuEntry>& settingsModelEntries, const Model::CascadiaSettings& settings)\r\n+    {\r\n+        std::vector<Editor::NewTabMenuEntryViewModel> result{};\r\n+        if (!settingsModelEntries)\r\n+        {\r\n+            return single_threaded_observable_vector<Editor::NewTabMenuEntryViewModel>(std::move(result));\r\n+        }\r\n+\r\n+        for (const auto& entry : settingsModelEntries)\r\n+        {\r\n+            switch (entry.Type())\r\n+            {\r\n+            case NewTabMenuEntryType::Profile:\r\n+            {\r\n+                // If the Profile isn't set, this is an invalid entry. Skip it.\r\n+                if (const auto& profileEntry = entry.as<Model::ProfileEntry>(); profileEntry.Profile())\r\n+                {\r\n+                    result.push_back(make<ProfileEntryViewModel>(profileEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Action:\r\n+            {\r\n+                if (const auto& actionEntry = entry.as<Model::ActionEntry>())\r\n+                {\r\n+                    result.push_back(make<ActionEntryViewModel>(actionEntry, settings));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Separator:\r\n+            {\r\n+                if (const auto& separatorEntry = entry.as<Model::SeparatorEntry>())\r\n+                {\r\n+                    result.push_back(make<SeparatorEntryViewModel>(separatorEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Folder:\r\n+            {\r\n+                if (const auto& folderEntry = entry.as<Model::FolderEntry>())\r\n+                {\r\n+                    // The ctor will convert the children of the folder to view models\r\n+                    result.push_back(make<FolderEntryViewModel>(folderEntry, settings));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::MatchProfiles:\r\n+            {\r\n+                if (const auto& matchProfilesEntry = entry.as<Model::MatchProfilesEntry>())\r\n+                {\r\n+                    result.push_back(make<MatchProfilesEntryViewModel>(matchProfilesEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::RemainingProfiles:\r\n+            {\r\n+                if (const auto& remainingProfilesEntry = entry.as<Model::RemainingProfilesEntry>())\r\n+                {\r\n+                    result.push_back(make<RemainingProfilesEntryViewModel>(remainingProfilesEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Invalid:\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n+        return single_threaded_observable_vector<Editor::NewTabMenuEntryViewModel>(std::move(result));\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::IsRemainingProfilesEntryMissing() const\r\n+    {\r\n+        return _IsRemainingProfilesEntryMissing(_rootEntries);\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::_IsRemainingProfilesEntryMissing(const IVector<Editor::NewTabMenuEntryViewModel>& entries)\r\n+    {\r\n+        for (const auto& entry : entries)\r\n+        {\r\n+            switch (entry.Type())\r\n+            {\r\n+            case NewTabMenuEntryType::RemainingProfiles:\r\n+            {\r\n+                return false;\r\n+            }\r\n+            case NewTabMenuEntryType::Folder:\r\n+            {\r\n+                if (!_IsRemainingProfilesEntryMissing(entry.as<Editor::FolderEntryViewModel>().Entries()))\r\n+                {\r\n+                    return false;\r\n+                }\r\n+                break;\r\n+            }\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::IsFolderView() const noexcept\r\n+    {\r\n+        return CurrentView() != _rootEntries;\r\n+    }\r\n+\r\n+    NewTabMenuViewModel::NewTabMenuViewModel(Model::CascadiaSettings settings)\r\n+    {\r\n+        UpdateSettings(settings);\r\n+\r\n+        // Add a property changed handler to our own property changed event.\r\n+        // This propagates changes from the settings model to anybody listening to our\r\n+        // unique view model members.\r\n+        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {\r\n+            const auto viewModelProperty{ args.PropertyName() };\r\n+            if (viewModelProperty == L\"AvailableProfiles\")\r\n+            {\r\n+                _NotifyChanges(L\"SelectedProfile\");\r\n+            }\r\n+            else if (viewModelProperty == L\"CurrentFolder\")\r\n+            {\r\n+                if (_CurrentFolder)\r\n+                {\r\n+                    CurrentFolderName(_CurrentFolder.Name());\r\n+                    _CurrentFolder.PropertyChanged({ this, &NewTabMenuViewModel::_FolderPropertyChanged });\r\n+                }\r\n+                _NotifyChanges(L\"IsFolderView\", L\"CurrentView\");\r\n+            }\r\n+        });\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::_FolderPropertyChanged(const IInspectable& /*sender*/, const Windows::UI::Xaml::Data::PropertyChangedEventArgs& args)\r\n+    {\r\n+        const auto viewModelProperty{ args.PropertyName() };\r\n+        if (viewModelProperty == L\"Name\")\r\n+        {\r\n+            // FolderTree needs to be updated when a folder is renamed\r\n+            _folderTreeCache = nullptr;\r\n+        }\r\n+    }\r\n+\r\n+    hstring NewTabMenuViewModel::CurrentFolderName() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.Name();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderName(const hstring& value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.Name() != value)\r\n+        {\r\n+            _CurrentFolder.Name(value);\r\n+            _NotifyChanges(L\"CurrentFolderName\");\r\n+        }\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::CurrentFolderInlining() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.Inlining();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderInlining(bool value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.Inlining() != value)\r\n+        {\r\n+            _CurrentFolder.Inlining(value);\r\n+            _NotifyChanges(L\"CurrentFolderInlining\");\r\n+        }\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::CurrentFolderAllowEmpty() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.AllowEmpty();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderAllowEmpty(bool value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.AllowEmpty() != value)\r\n+        {\r\n+            _CurrentFolder.AllowEmpty(value);\r\n+            _NotifyChanges(L\"CurrentFolderAllowEmpty\");\r\n+        }\r\n+    }\r\n+\r\n+    Windows::Foundation::Collections::IObservableVector<Editor::NewTabMenuEntryViewModel> NewTabMenuViewModel::CurrentView() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return _rootEntries;\r\n+        }\r\n+        return _CurrentFolder.Entries();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::UpdateSettings(const Model::CascadiaSettings& settings)\r\n+    {\r\n+        _Settings = settings;\r\n+        _NotifyChanges(L\"AvailableProfiles\");\r\n+\r\n+        SelectedProfile(AvailableProfiles().GetAt(0));\r\n+\r\n+        _rootEntries = _ConvertToViewModelEntries(_Settings.GlobalSettings().NewTabMenu(), _Settings);\r\n+\r\n+        _rootEntriesChangedRevoker = _rootEntries.VectorChanged(winrt::auto_revoke, [this](auto&&, const IVectorChangedEventArgs& args) {\r\n+            switch (args.CollectionChange())\r\n+            {\r\n+            case CollectionChange::Reset:\r\n+            {\r\n+                // fully replace settings model with view model structure\r\n+                std::vector<Model::NewTabMenuEntry> modelEntries;\r\n+                for (const auto& entry : _rootEntries)\r\n+                {\r\n+                    modelEntries.push_back(NewTabMenuEntryViewModel::GetModel(entry));\r\n+                }\r\n+                _Settings.GlobalSettings().NewTabMenu(single_threaded_vector<Model::NewTabMenuEntry>(std::move(modelEntries)));\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemInserted:\r\n+            {\r\n+                const auto& insertedEntryVM = _rootEntries.GetAt(args.Index());\r\n+                const auto& insertedEntry = NewTabMenuEntryViewModel::GetModel(insertedEntryVM);\r\n+                _Settings.GlobalSettings().NewTabMenu().InsertAt(args.Index(), insertedEntry);\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemRemoved:\r\n+            {\r\n+                _Settings.GlobalSettings().NewTabMenu().RemoveAt(args.Index());\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemChanged:\r\n+            {\r\n+                const auto& modifiedEntry = _rootEntries.GetAt(args.Index());\r\n+                _Settings.GlobalSettings().NewTabMenu().SetAt(args.Index(), NewTabMenuEntryViewModel::GetModel(modifiedEntry));\r\n+                return;\r\n+            }\r\n+            }\r\n+        });\r\n+\r\n+        // Clear CurrentFolder to reset the view\r\n+        _CurrentFolder = nullptr;\r",
        "comment_created_at": "2024-11-15T21:36:36+00:00",
        "comment_author": "PankajBhojwani",
        "comment_body": "Instead of clearing `CurrentFolder`, can we first check whether the previous `CurrentFolder` exists and then reset that as the current folder? Similar to the way the ColorSchemesPageVM resets the current scheme if that scheme still exists",
        "pr_file_module": null
      },
      {
        "comment_id": "1853212698",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18015,
        "pr_file": "src/cascadia/TerminalSettingsEditor/NewTabMenuViewModel.cpp",
        "discussion_id": "1844537725",
        "commented_code": "@@ -0,0 +1,765 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"pch.h\"\r\n+#include \"NewTabMenuViewModel.h\"\r\n+#include <LibraryResources.h>\r\n+\r\n+#include \"NewTabMenuViewModel.g.cpp\"\r\n+#include \"FolderTreeViewEntry.g.cpp\"\r\n+#include \"NewTabMenuEntryViewModel.g.cpp\"\r\n+#include \"ProfileEntryViewModel.g.cpp\"\r\n+#include \"ActionEntryViewModel.g.cpp\"\r\n+#include \"SeparatorEntryViewModel.g.cpp\"\r\n+#include \"FolderEntryViewModel.g.cpp\"\r\n+#include \"MatchProfilesEntryViewModel.g.cpp\"\r\n+#include \"RemainingProfilesEntryViewModel.g.cpp\"\r\n+\r\n+using namespace winrt::Windows::UI::Xaml::Navigation;\r\n+using namespace winrt::Windows::Foundation;\r\n+using namespace winrt::Windows::Foundation::Collections;\r\n+using namespace winrt::Microsoft::Terminal::Settings::Model;\r\n+using namespace winrt::Windows::UI::Xaml::Data;\r\n+\r\n+namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n+{\r\n+    static IObservableVector<Editor::NewTabMenuEntryViewModel> _ConvertToViewModelEntries(const IVector<Model::NewTabMenuEntry>& settingsModelEntries, const Model::CascadiaSettings& settings)\r\n+    {\r\n+        std::vector<Editor::NewTabMenuEntryViewModel> result{};\r\n+        if (!settingsModelEntries)\r\n+        {\r\n+            return single_threaded_observable_vector<Editor::NewTabMenuEntryViewModel>(std::move(result));\r\n+        }\r\n+\r\n+        for (const auto& entry : settingsModelEntries)\r\n+        {\r\n+            switch (entry.Type())\r\n+            {\r\n+            case NewTabMenuEntryType::Profile:\r\n+            {\r\n+                // If the Profile isn't set, this is an invalid entry. Skip it.\r\n+                if (const auto& profileEntry = entry.as<Model::ProfileEntry>(); profileEntry.Profile())\r\n+                {\r\n+                    result.push_back(make<ProfileEntryViewModel>(profileEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Action:\r\n+            {\r\n+                if (const auto& actionEntry = entry.as<Model::ActionEntry>())\r\n+                {\r\n+                    result.push_back(make<ActionEntryViewModel>(actionEntry, settings));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Separator:\r\n+            {\r\n+                if (const auto& separatorEntry = entry.as<Model::SeparatorEntry>())\r\n+                {\r\n+                    result.push_back(make<SeparatorEntryViewModel>(separatorEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Folder:\r\n+            {\r\n+                if (const auto& folderEntry = entry.as<Model::FolderEntry>())\r\n+                {\r\n+                    // The ctor will convert the children of the folder to view models\r\n+                    result.push_back(make<FolderEntryViewModel>(folderEntry, settings));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::MatchProfiles:\r\n+            {\r\n+                if (const auto& matchProfilesEntry = entry.as<Model::MatchProfilesEntry>())\r\n+                {\r\n+                    result.push_back(make<MatchProfilesEntryViewModel>(matchProfilesEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::RemainingProfiles:\r\n+            {\r\n+                if (const auto& remainingProfilesEntry = entry.as<Model::RemainingProfilesEntry>())\r\n+                {\r\n+                    result.push_back(make<RemainingProfilesEntryViewModel>(remainingProfilesEntry));\r\n+                }\r\n+                break;\r\n+            }\r\n+            case NewTabMenuEntryType::Invalid:\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n+        return single_threaded_observable_vector<Editor::NewTabMenuEntryViewModel>(std::move(result));\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::IsRemainingProfilesEntryMissing() const\r\n+    {\r\n+        return _IsRemainingProfilesEntryMissing(_rootEntries);\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::_IsRemainingProfilesEntryMissing(const IVector<Editor::NewTabMenuEntryViewModel>& entries)\r\n+    {\r\n+        for (const auto& entry : entries)\r\n+        {\r\n+            switch (entry.Type())\r\n+            {\r\n+            case NewTabMenuEntryType::RemainingProfiles:\r\n+            {\r\n+                return false;\r\n+            }\r\n+            case NewTabMenuEntryType::Folder:\r\n+            {\r\n+                if (!_IsRemainingProfilesEntryMissing(entry.as<Editor::FolderEntryViewModel>().Entries()))\r\n+                {\r\n+                    return false;\r\n+                }\r\n+                break;\r\n+            }\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::IsFolderView() const noexcept\r\n+    {\r\n+        return CurrentView() != _rootEntries;\r\n+    }\r\n+\r\n+    NewTabMenuViewModel::NewTabMenuViewModel(Model::CascadiaSettings settings)\r\n+    {\r\n+        UpdateSettings(settings);\r\n+\r\n+        // Add a property changed handler to our own property changed event.\r\n+        // This propagates changes from the settings model to anybody listening to our\r\n+        // unique view model members.\r\n+        PropertyChanged([this](auto&&, const PropertyChangedEventArgs& args) {\r\n+            const auto viewModelProperty{ args.PropertyName() };\r\n+            if (viewModelProperty == L\"AvailableProfiles\")\r\n+            {\r\n+                _NotifyChanges(L\"SelectedProfile\");\r\n+            }\r\n+            else if (viewModelProperty == L\"CurrentFolder\")\r\n+            {\r\n+                if (_CurrentFolder)\r\n+                {\r\n+                    CurrentFolderName(_CurrentFolder.Name());\r\n+                    _CurrentFolder.PropertyChanged({ this, &NewTabMenuViewModel::_FolderPropertyChanged });\r\n+                }\r\n+                _NotifyChanges(L\"IsFolderView\", L\"CurrentView\");\r\n+            }\r\n+        });\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::_FolderPropertyChanged(const IInspectable& /*sender*/, const Windows::UI::Xaml::Data::PropertyChangedEventArgs& args)\r\n+    {\r\n+        const auto viewModelProperty{ args.PropertyName() };\r\n+        if (viewModelProperty == L\"Name\")\r\n+        {\r\n+            // FolderTree needs to be updated when a folder is renamed\r\n+            _folderTreeCache = nullptr;\r\n+        }\r\n+    }\r\n+\r\n+    hstring NewTabMenuViewModel::CurrentFolderName() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.Name();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderName(const hstring& value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.Name() != value)\r\n+        {\r\n+            _CurrentFolder.Name(value);\r\n+            _NotifyChanges(L\"CurrentFolderName\");\r\n+        }\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::CurrentFolderInlining() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.Inlining();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderInlining(bool value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.Inlining() != value)\r\n+        {\r\n+            _CurrentFolder.Inlining(value);\r\n+            _NotifyChanges(L\"CurrentFolderInlining\");\r\n+        }\r\n+    }\r\n+\r\n+    bool NewTabMenuViewModel::CurrentFolderAllowEmpty() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return {};\r\n+        }\r\n+        return _CurrentFolder.AllowEmpty();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::CurrentFolderAllowEmpty(bool value)\r\n+    {\r\n+        if (_CurrentFolder && _CurrentFolder.AllowEmpty() != value)\r\n+        {\r\n+            _CurrentFolder.AllowEmpty(value);\r\n+            _NotifyChanges(L\"CurrentFolderAllowEmpty\");\r\n+        }\r\n+    }\r\n+\r\n+    Windows::Foundation::Collections::IObservableVector<Editor::NewTabMenuEntryViewModel> NewTabMenuViewModel::CurrentView() const\r\n+    {\r\n+        if (!_CurrentFolder)\r\n+        {\r\n+            return _rootEntries;\r\n+        }\r\n+        return _CurrentFolder.Entries();\r\n+    }\r\n+\r\n+    void NewTabMenuViewModel::UpdateSettings(const Model::CascadiaSettings& settings)\r\n+    {\r\n+        _Settings = settings;\r\n+        _NotifyChanges(L\"AvailableProfiles\");\r\n+\r\n+        SelectedProfile(AvailableProfiles().GetAt(0));\r\n+\r\n+        _rootEntries = _ConvertToViewModelEntries(_Settings.GlobalSettings().NewTabMenu(), _Settings);\r\n+\r\n+        _rootEntriesChangedRevoker = _rootEntries.VectorChanged(winrt::auto_revoke, [this](auto&&, const IVectorChangedEventArgs& args) {\r\n+            switch (args.CollectionChange())\r\n+            {\r\n+            case CollectionChange::Reset:\r\n+            {\r\n+                // fully replace settings model with view model structure\r\n+                std::vector<Model::NewTabMenuEntry> modelEntries;\r\n+                for (const auto& entry : _rootEntries)\r\n+                {\r\n+                    modelEntries.push_back(NewTabMenuEntryViewModel::GetModel(entry));\r\n+                }\r\n+                _Settings.GlobalSettings().NewTabMenu(single_threaded_vector<Model::NewTabMenuEntry>(std::move(modelEntries)));\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemInserted:\r\n+            {\r\n+                const auto& insertedEntryVM = _rootEntries.GetAt(args.Index());\r\n+                const auto& insertedEntry = NewTabMenuEntryViewModel::GetModel(insertedEntryVM);\r\n+                _Settings.GlobalSettings().NewTabMenu().InsertAt(args.Index(), insertedEntry);\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemRemoved:\r\n+            {\r\n+                _Settings.GlobalSettings().NewTabMenu().RemoveAt(args.Index());\r\n+                return;\r\n+            }\r\n+            case CollectionChange::ItemChanged:\r\n+            {\r\n+                const auto& modifiedEntry = _rootEntries.GetAt(args.Index());\r\n+                _Settings.GlobalSettings().NewTabMenu().SetAt(args.Index(), NewTabMenuEntryViewModel::GetModel(modifiedEntry));\r\n+                return;\r\n+            }\r\n+            }\r\n+        });\r\n+\r\n+        // Clear CurrentFolder to reset the view\r\n+        _CurrentFolder = nullptr;\r",
        "comment_created_at": "2024-11-22T02:45:43+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "This one took a while to fix. Since we have a PropertyChanged handler for \"CurrentFolder\" that navigates to the right subpage and updates the breadcrumbs, whenever we update CurrentFolder, there's a risk of the state being messed up. So, for most of this PR, I made it so that we'd just always navigate to the main page (to avoid doing the work of finding the folder and building the breadcrumbs).\r\n\r\nWent ahead and did it anyways in [aeab125](https://github.com/microsoft/terminal/pull/18015/commits/aeab125e44a2bbb42974b5163f0c700dfbf5e87f). Now, we _do_ navigate to the correct folder if it exists by matching the name. If no match was found, we just go back to the main page.",
        "pr_file_module": null
      }
    ]
  }
]