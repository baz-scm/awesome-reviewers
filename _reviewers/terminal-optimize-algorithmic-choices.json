[
  {
    "discussion_id": "2273611681",
    "pr_number": 18915,
    "pr_file": "src/cascadia/TerminalSettingsModel/ActionAndArgs.cpp",
    "created_at": "2025-08-13T14:14:12+00:00",
    "commented_code": "winrt::hstring ActionAndArgs::GenerateName(const winrt::Windows::ApplicationModel::Resources::Core::ResourceContext& context) const\n     {\n-        // Sentinel used to indicate this command must ALWAYS be generated by GenerateName\n-        static constexpr wil::zwstring_view MustGenerate{};\n-        // Use a magic static to initialize this map, because we won't be able\n-        // to load the resources at _init_, only at runtime.\n-        static const auto GeneratedActionNames = []() {\n-            return std::unordered_map<ShortcutAction, wil::zwstring_view>{",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2273611681",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18915,
        "pr_file": "src/cascadia/TerminalSettingsModel/ActionAndArgs.cpp",
        "discussion_id": "2273611681",
        "commented_code": "@@ -342,107 +342,6 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n \n     winrt::hstring ActionAndArgs::GenerateName(const winrt::Windows::ApplicationModel::Resources::Core::ResourceContext& context) const\n     {\n-        // Sentinel used to indicate this command must ALWAYS be generated by GenerateName\n-        static constexpr wil::zwstring_view MustGenerate{};\n-        // Use a magic static to initialize this map, because we won't be able\n-        // to load the resources at _init_, only at runtime.\n-        static const auto GeneratedActionNames = []() {\n-            return std::unordered_map<ShortcutAction, wil::zwstring_view>{",
        "comment_created_at": "2025-08-13T14:14:12+00:00",
        "comment_author": "lhecker",
        "comment_body": "FWIW this should've used a `til::static_map` or some equivalent of it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2240691099",
    "pr_number": 19156,
    "pr_file": "src/cascadia/TerminalSettingsEditor/Extensions.cpp",
    "created_at": "2025-07-29T18:54:27+00:00",
    "commented_code": "vmImpl->ExtensionPackageIdentifierTemplateSelector(_extensionPackageIdentifierTemplateSelector);\n         vmImpl->LazyLoadExtensions();\n         vmImpl->MarkAsVisited();\n+\n+        if (_ViewModel.IsExtensionView())\n+        {\n+            const auto& currentPkgVM = _ViewModel.CurrentExtensionPackage();\n+            const auto& currentPkg = currentPkgVM.Package();",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2240691099",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19156,
        "pr_file": "src/cascadia/TerminalSettingsEditor/Extensions.cpp",
        "discussion_id": "2240691099",
        "commented_code": "@@ -41,6 +42,36 @@ namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\n         vmImpl->ExtensionPackageIdentifierTemplateSelector(_extensionPackageIdentifierTemplateSelector);\n         vmImpl->LazyLoadExtensions();\n         vmImpl->MarkAsVisited();\n+\n+        if (_ViewModel.IsExtensionView())\n+        {\n+            const auto& currentPkgVM = _ViewModel.CurrentExtensionPackage();\n+            const auto& currentPkg = currentPkgVM.Package();",
        "comment_created_at": "2025-07-29T18:54:27+00:00",
        "comment_author": "DHowett",
        "comment_body": "```suggestion\n            const auto currentPkgVM = _ViewModel.CurrentExtensionPackage();\n            const auto currentPkg = currentPkgVM.Package();\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2248877986",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19156,
        "pr_file": "src/cascadia/TerminalSettingsEditor/Extensions.cpp",
        "discussion_id": "2240691099",
        "commented_code": "@@ -41,6 +42,36 @@ namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\n         vmImpl->ExtensionPackageIdentifierTemplateSelector(_extensionPackageIdentifierTemplateSelector);\n         vmImpl->LazyLoadExtensions();\n         vmImpl->MarkAsVisited();\n+\n+        if (_ViewModel.IsExtensionView())\n+        {\n+            const auto& currentPkgVM = _ViewModel.CurrentExtensionPackage();\n+            const auto& currentPkg = currentPkgVM.Package();",
        "comment_created_at": "2025-08-01T21:12:49+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "Applied. Curious, why? Since they're both COM objects, wouldn't we want the `&` to prevent the unnecessary refcount change?",
        "pr_file_module": null
      },
      {
        "comment_id": "2248919060",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19156,
        "pr_file": "src/cascadia/TerminalSettingsEditor/Extensions.cpp",
        "discussion_id": "2240691099",
        "commented_code": "@@ -41,6 +42,36 @@ namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\n         vmImpl->ExtensionPackageIdentifierTemplateSelector(_extensionPackageIdentifierTemplateSelector);\n         vmImpl->LazyLoadExtensions();\n         vmImpl->MarkAsVisited();\n+\n+        if (_ViewModel.IsExtensionView())\n+        {\n+            const auto& currentPkgVM = _ViewModel.CurrentExtensionPackage();\n+            const auto& currentPkg = currentPkgVM.Package();",
        "comment_created_at": "2025-08-01T21:45:10+00:00",
        "comment_author": "DHowett",
        "comment_body": "The & only matters if you're getting a reference from the function you're calling. It is meaningless and misleading otherwise, as it ALWAYS causes a copy (in the case of a projection pointer, a copy is an AddRef) when the function you've called does not return a reference.",
        "pr_file_module": null
      },
      {
        "comment_id": "2248980711",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19156,
        "pr_file": "src/cascadia/TerminalSettingsEditor/Extensions.cpp",
        "discussion_id": "2240691099",
        "commented_code": "@@ -41,6 +42,36 @@ namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\n         vmImpl->ExtensionPackageIdentifierTemplateSelector(_extensionPackageIdentifierTemplateSelector);\n         vmImpl->LazyLoadExtensions();\n         vmImpl->MarkAsVisited();\n+\n+        if (_ViewModel.IsExtensionView())\n+        {\n+            const auto& currentPkgVM = _ViewModel.CurrentExtensionPackage();\n+            const auto& currentPkg = currentPkgVM.Package();",
        "comment_created_at": "2025-08-01T22:59:20+00:00",
        "comment_author": "lhecker",
        "comment_body": "The rules around & for return values are just unnecessarily complex in C++. It makes no sense that you can't just write `let x = foo()` and x is inferred to be a reference if `foo()` returns one. The `let` equivalent is `decltype(auto)` which is mouthful no one types.\r\n\r\nInitially I had the stance (for myself) that we should try to take WinRT objects by reference to avoid copies, but looking at the complexity this results in I've come to conclude that simply copying parameters is simpler. (This doesn't apply to STL objects though, of course, since they're not ref-counted.)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164792944",
    "pr_number": 19014,
    "pr_file": "src/cascadia/TerminalConnection/ConptyConnection.cpp",
    "created_at": "2025-06-24T20:00:43+00:00",
    "commented_code": "}\n         CATCH_LOG()\n \n+        try\n+        {\n+            auto processImageName{ wil::QueryFullProcessImageNameW<std::wstring>(_piClient.hProcess) };\n+            _clientName = std::filesystem::path{ processImageName }.filename().wstring();",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2164792944",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19014,
        "pr_file": "src/cascadia/TerminalConnection/ConptyConnection.cpp",
        "discussion_id": "2164792944",
        "commented_code": "@@ -313,6 +313,13 @@ namespace winrt::Microsoft::Terminal::TerminalConnection::implementation\n         }\n         CATCH_LOG()\n \n+        try\n+        {\n+            auto processImageName{ wil::QueryFullProcessImageNameW<std::wstring>(_piClient.hProcess) };\n+            _clientName = std::filesystem::path{ processImageName }.filename().wstring();",
        "comment_created_at": "2025-06-24T20:00:43+00:00",
        "comment_author": "lhecker",
        "comment_body": "Could use a std::move here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2164794362",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19014,
        "pr_file": "src/cascadia/TerminalConnection/ConptyConnection.cpp",
        "discussion_id": "2164792944",
        "commented_code": "@@ -313,6 +313,13 @@ namespace winrt::Microsoft::Terminal::TerminalConnection::implementation\n         }\n         CATCH_LOG()\n \n+        try\n+        {\n+            auto processImageName{ wil::QueryFullProcessImageNameW<std::wstring>(_piClient.hProcess) };\n+            _clientName = std::filesystem::path{ processImageName }.filename().wstring();",
        "comment_created_at": "2025-06-24T20:01:50+00:00",
        "comment_author": "DHowett",
        "comment_body": "(which thing will we move? i guess we could move all of it)",
        "pr_file_module": null
      },
      {
        "comment_id": "2164794710",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19014,
        "pr_file": "src/cascadia/TerminalConnection/ConptyConnection.cpp",
        "discussion_id": "2164792944",
        "commented_code": "@@ -313,6 +313,13 @@ namespace winrt::Microsoft::Terminal::TerminalConnection::implementation\n         }\n         CATCH_LOG()\n \n+        try\n+        {\n+            auto processImageName{ wil::QueryFullProcessImageNameW<std::wstring>(_piClient.hProcess) };\n+            _clientName = std::filesystem::path{ processImageName }.filename().wstring();",
        "comment_created_at": "2025-06-24T20:02:07+00:00",
        "comment_author": "DHowett",
        "comment_body": "presumably `path{ move(image) }`; everything else is an rvalue",
        "pr_file_module": null
      },
      {
        "comment_id": "2164796022",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19014,
        "pr_file": "src/cascadia/TerminalConnection/ConptyConnection.cpp",
        "discussion_id": "2164792944",
        "commented_code": "@@ -313,6 +313,13 @@ namespace winrt::Microsoft::Terminal::TerminalConnection::implementation\n         }\n         CATCH_LOG()\n \n+        try\n+        {\n+            auto processImageName{ wil::QueryFullProcessImageNameW<std::wstring>(_piClient.hProcess) };\n+            _clientName = std::filesystem::path{ processImageName }.filename().wstring();",
        "comment_created_at": "2025-06-24T20:03:00+00:00",
        "comment_author": "lhecker",
        "comment_body": "Yeah exactly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060758370",
    "pr_number": 18700,
    "pr_file": "src/cascadia/TerminalApp/fzf/fzf.cpp",
    "created_at": "2025-04-25T19:07:26+00:00",
    "commented_code": "+#include \"pch.h\"\r\n+#include \"fzf.h\"\r\n+#include <algorithm>\r\n+#include <cwctype>\r\n+\r\n+namespace fzf\r\n+{\r\n+    namespace matcher\r\n+    {\r\n+        constexpr int ScoreMatch = 16;\r\n+        constexpr int ScoreGapStart = -3;\r\n+        constexpr int ScoreGapExtension = -1;\r\n+        constexpr int BoundaryBonus = ScoreMatch / 2;\r\n+        constexpr int NonWordBonus = ScoreMatch / 2;\r\n+        constexpr int CamelCaseBonus = BoundaryBonus + ScoreGapExtension;\r\n+        constexpr int BonusConsecutive = -(ScoreGapStart + ScoreGapExtension);\r\n+        constexpr int BonusFirstCharMultiplier = 2;\r\n+\r\n+        enum CharClass\r\n+        {\r\n+            NonWord = 0,\r\n+            CharLower = 1,\r\n+            CharUpper = 2,\r\n+            Digit = 3,\r\n+        };\r\n+\r\n+        std::wstring_view TrimStart(const std::wstring_view str)\r\n+        {\r\n+            size_t start = str.find_first_not_of(L\" \");\r\n+            return (start == std::wstring::npos) ? std::wstring_view() : std::wstring_view(str).substr(start);\r\n+        }\r\n+\r\n+        std::wstring_view TrimSuffixSpaces(std::wstring_view input)\r\n+        {\r\n+            size_t end = input.size();\r\n+            while (end > 0 && input[end - 1] == L' ')\r\n+                --end;\r\n+            return input.substr(0, end);\r\n+        }\r\n+\r\n+        int IndexOfChar(std::wstring_view input, const WCHAR value[], int startIndex)\r\n+        {\r\n+            for (size_t i = startIndex; i < input.size(); i++)\r\n+            {\r\n+                const WCHAR currentCharAsString[] = { input[i], L'\\0' };\r\n+                auto isCurrentCharMatched = lstrcmpi(value, currentCharAsString) == 0;\r\n+                if (isCurrentCharMatched)\r\n+                    return static_cast<int>(i);\r\n+            }\r\n+            return -1;\r\n+        }\r\n+\r\n+        int FuzzyIndexOf(std::wstring_view input, std::wstring_view pattern)\r\n+        {\r\n+            int idx = 0;\r\n+            int firstIdx = 0;\r\n+            for (size_t patternIndex = 0; patternIndex < pattern.size(); patternIndex++)\r\n+            {\r\n+                // GH#9941: search should be locale-aware as well\r\n+                // We use the same comparison method as upon sorting to guarantee consistent behavior\r\n+                const WCHAR searchCharAsString[] = { pattern[patternIndex], L'\\0' };\r\n+                //const WCHAR currentCharAsString[] = { currentChar, L'\\0' };\r\n+                idx = IndexOfChar(input, searchCharAsString, idx);\r\n+                if (idx < 0)\r\n+                    return -1;\r\n+                if (patternIndex == 0 && idx > 0)\r\n+                    firstIdx = idx - 1;\r\n+                idx++;\r\n+            }\r\n+            return firstIdx;\r\n+        }\r\n+\r\n+        int CalculateBonus(CharClass prevClass, CharClass currentClass)\r\n+        {\r\n+            if (prevClass == NonWord && currentClass != NonWord)\r\n+                return BoundaryBonus;\r\n+            if ((prevClass == CharLower && currentClass == CharUpper) ||\r\n+                (prevClass != Digit && currentClass == Digit))\r\n+                return CamelCaseBonus;\r\n+            if (currentClass == NonWord)\r\n+                return NonWordBonus;\r\n+            return 0;\r\n+        }\r\n+\r\n+        CharClass ClassOf(wchar_t ch)\r\n+        {\r\n+            if (std::iswlower(ch))\r\n+                return CharLower;\r\n+            if (std::iswupper(ch))\r\n+                return CharUpper;\r\n+            if (std::iswdigit(ch))\r\n+                return Digit;\r\n+            return NonWord;\r\n+        }\r\n+\r\n+        FzfResult FzfFuzzyMatchV2(std::wstring_view text, std::wstring_view pattern, std::vector<int>* pos)\r\n+        {\r\n+            size_t patternSize = pattern.size();\r\n+            size_t textSize = text.size();\r\n+\r\n+            if (patternSize == 0)\r\n+                return { 0, 0, 0 };\r\n+\r\n+            int firstIndexOf = FuzzyIndexOf(text, pattern);\r\n+            if (firstIndexOf < 0)\r\n+                return { -1, -1, 0 };\r\n+\r\n+            auto initialScores = std::vector<int>(textSize);\r\n+            auto consecutiveScores = std::vector<int>(textSize);\r\n+            auto firstOccurrenceOfEachChar = std::vector<int>(patternSize);\r\n+            int maxScore = 0;\r\n+            int maxScorePos = 0;\r\n+            size_t patternIndex = 0;\r\n+            int lastIndex = 0;\r\n+            wchar_t firstPatternChar = pattern[0];\r\n+            wchar_t currentPatternChar = pattern[0];\r\n+            int previousInitialScore = 0;\r\n+            CharClass previousClass = NonWord;\r\n+            bool inGap = false;\r\n+\r\n+            auto textCopy = std::wstring{ text };\r\n+            std::ranges::transform(textCopy, textCopy.begin(), [](wchar_t c) {\r\n+                return std::towlower(c);\r\n+            });\r\n+            std::wstring_view lowerText(textCopy.data(), textCopy.size());\r\n+            std::wstring_view lowerTextSlice = lowerText.substr(firstIndexOf, textCopy.size() - firstIndexOf);\r\n+            auto initialScoresSlice = std::span<int>(initialScores).subspan(firstIndexOf);\r\n+            auto consecutiveScoresSlice = std::span<int>(consecutiveScores).subspan(firstIndexOf);\r\n+            auto bonusesSpan = std::vector<int>(textSize);\r\n+            auto bonusesSlice = std::span<int>(bonusesSpan).subspan(firstIndexOf, textSize - firstIndexOf);\r\n+\r\n+            for (size_t i = 0; i < lowerTextSlice.size(); i++)\r\n+            {\r\n+                wchar_t currentChar = lowerTextSlice[i];\r\n+                CharClass currentClass = ClassOf(currentChar);\r\n+                int bonus = CalculateBonus(previousClass, currentClass);\r\n+                bonusesSlice[i] = bonus;\r\n+                previousClass = currentClass;\r\n+\r\n+                // GH#9941: search should be locale-aware as well\r\n+                // We use the same comparison method as upon sorting to guarantee consistent behavior\r\n+                const WCHAR searchCharAsString[] = { currentPatternChar, L'\\0' };\r\n+                const WCHAR currentCharAsString[] = { currentChar, L'\\0' };\r\n+                auto isCurrentCharMatched = lstrcmpi(searchCharAsString, currentCharAsString) == 0;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2060758370",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18700,
        "pr_file": "src/cascadia/TerminalApp/fzf/fzf.cpp",
        "discussion_id": "2060758370",
        "commented_code": "@@ -0,0 +1,379 @@\n+#include \"pch.h\"\r\n+#include \"fzf.h\"\r\n+#include <algorithm>\r\n+#include <cwctype>\r\n+\r\n+namespace fzf\r\n+{\r\n+    namespace matcher\r\n+    {\r\n+        constexpr int ScoreMatch = 16;\r\n+        constexpr int ScoreGapStart = -3;\r\n+        constexpr int ScoreGapExtension = -1;\r\n+        constexpr int BoundaryBonus = ScoreMatch / 2;\r\n+        constexpr int NonWordBonus = ScoreMatch / 2;\r\n+        constexpr int CamelCaseBonus = BoundaryBonus + ScoreGapExtension;\r\n+        constexpr int BonusConsecutive = -(ScoreGapStart + ScoreGapExtension);\r\n+        constexpr int BonusFirstCharMultiplier = 2;\r\n+\r\n+        enum CharClass\r\n+        {\r\n+            NonWord = 0,\r\n+            CharLower = 1,\r\n+            CharUpper = 2,\r\n+            Digit = 3,\r\n+        };\r\n+\r\n+        std::wstring_view TrimStart(const std::wstring_view str)\r\n+        {\r\n+            size_t start = str.find_first_not_of(L\" \");\r\n+            return (start == std::wstring::npos) ? std::wstring_view() : std::wstring_view(str).substr(start);\r\n+        }\r\n+\r\n+        std::wstring_view TrimSuffixSpaces(std::wstring_view input)\r\n+        {\r\n+            size_t end = input.size();\r\n+            while (end > 0 && input[end - 1] == L' ')\r\n+                --end;\r\n+            return input.substr(0, end);\r\n+        }\r\n+\r\n+        int IndexOfChar(std::wstring_view input, const WCHAR value[], int startIndex)\r\n+        {\r\n+            for (size_t i = startIndex; i < input.size(); i++)\r\n+            {\r\n+                const WCHAR currentCharAsString[] = { input[i], L'\\0' };\r\n+                auto isCurrentCharMatched = lstrcmpi(value, currentCharAsString) == 0;\r\n+                if (isCurrentCharMatched)\r\n+                    return static_cast<int>(i);\r\n+            }\r\n+            return -1;\r\n+        }\r\n+\r\n+        int FuzzyIndexOf(std::wstring_view input, std::wstring_view pattern)\r\n+        {\r\n+            int idx = 0;\r\n+            int firstIdx = 0;\r\n+            for (size_t patternIndex = 0; patternIndex < pattern.size(); patternIndex++)\r\n+            {\r\n+                // GH#9941: search should be locale-aware as well\r\n+                // We use the same comparison method as upon sorting to guarantee consistent behavior\r\n+                const WCHAR searchCharAsString[] = { pattern[patternIndex], L'\\0' };\r\n+                //const WCHAR currentCharAsString[] = { currentChar, L'\\0' };\r\n+                idx = IndexOfChar(input, searchCharAsString, idx);\r\n+                if (idx < 0)\r\n+                    return -1;\r\n+                if (patternIndex == 0 && idx > 0)\r\n+                    firstIdx = idx - 1;\r\n+                idx++;\r\n+            }\r\n+            return firstIdx;\r\n+        }\r\n+\r\n+        int CalculateBonus(CharClass prevClass, CharClass currentClass)\r\n+        {\r\n+            if (prevClass == NonWord && currentClass != NonWord)\r\n+                return BoundaryBonus;\r\n+            if ((prevClass == CharLower && currentClass == CharUpper) ||\r\n+                (prevClass != Digit && currentClass == Digit))\r\n+                return CamelCaseBonus;\r\n+            if (currentClass == NonWord)\r\n+                return NonWordBonus;\r\n+            return 0;\r\n+        }\r\n+\r\n+        CharClass ClassOf(wchar_t ch)\r\n+        {\r\n+            if (std::iswlower(ch))\r\n+                return CharLower;\r\n+            if (std::iswupper(ch))\r\n+                return CharUpper;\r\n+            if (std::iswdigit(ch))\r\n+                return Digit;\r\n+            return NonWord;\r\n+        }\r\n+\r\n+        FzfResult FzfFuzzyMatchV2(std::wstring_view text, std::wstring_view pattern, std::vector<int>* pos)\r\n+        {\r\n+            size_t patternSize = pattern.size();\r\n+            size_t textSize = text.size();\r\n+\r\n+            if (patternSize == 0)\r\n+                return { 0, 0, 0 };\r\n+\r\n+            int firstIndexOf = FuzzyIndexOf(text, pattern);\r\n+            if (firstIndexOf < 0)\r\n+                return { -1, -1, 0 };\r\n+\r\n+            auto initialScores = std::vector<int>(textSize);\r\n+            auto consecutiveScores = std::vector<int>(textSize);\r\n+            auto firstOccurrenceOfEachChar = std::vector<int>(patternSize);\r\n+            int maxScore = 0;\r\n+            int maxScorePos = 0;\r\n+            size_t patternIndex = 0;\r\n+            int lastIndex = 0;\r\n+            wchar_t firstPatternChar = pattern[0];\r\n+            wchar_t currentPatternChar = pattern[0];\r\n+            int previousInitialScore = 0;\r\n+            CharClass previousClass = NonWord;\r\n+            bool inGap = false;\r\n+\r\n+            auto textCopy = std::wstring{ text };\r\n+            std::ranges::transform(textCopy, textCopy.begin(), [](wchar_t c) {\r\n+                return std::towlower(c);\r\n+            });\r\n+            std::wstring_view lowerText(textCopy.data(), textCopy.size());\r\n+            std::wstring_view lowerTextSlice = lowerText.substr(firstIndexOf, textCopy.size() - firstIndexOf);\r\n+            auto initialScoresSlice = std::span<int>(initialScores).subspan(firstIndexOf);\r\n+            auto consecutiveScoresSlice = std::span<int>(consecutiveScores).subspan(firstIndexOf);\r\n+            auto bonusesSpan = std::vector<int>(textSize);\r\n+            auto bonusesSlice = std::span<int>(bonusesSpan).subspan(firstIndexOf, textSize - firstIndexOf);\r\n+\r\n+            for (size_t i = 0; i < lowerTextSlice.size(); i++)\r\n+            {\r\n+                wchar_t currentChar = lowerTextSlice[i];\r\n+                CharClass currentClass = ClassOf(currentChar);\r\n+                int bonus = CalculateBonus(previousClass, currentClass);\r\n+                bonusesSlice[i] = bonus;\r\n+                previousClass = currentClass;\r\n+\r\n+                // GH#9941: search should be locale-aware as well\r\n+                // We use the same comparison method as upon sorting to guarantee consistent behavior\r\n+                const WCHAR searchCharAsString[] = { currentPatternChar, L'\\0' };\r\n+                const WCHAR currentCharAsString[] = { currentChar, L'\\0' };\r\n+                auto isCurrentCharMatched = lstrcmpi(searchCharAsString, currentCharAsString) == 0;\r",
        "comment_created_at": "2025-04-25T19:07:26+00:00",
        "comment_author": "lhecker",
        "comment_body": "There are multiple uses of `lstrcmpiW` throughout this file (and in the current matching logic before this PR) and I don't think that's a good way to implement this. Each call to `lstrcmpiW` goes through multiple layers just to arrive at `CompareStringEx` which is rather expensive for just comparing two characters with folding.\r\n\r\nIn this particular instance, `currentChar` is already lowercase so the only problem is `currentPatternChar` which could simply get lowercases with ICU and then compared against the `currentChar`. Technically we then also need to take care of the difference between lowercasing and casefolding (e.g. the lowercase of Greek \"sigma\" has two variants), but I think that's a secondary issue.\r\n\r\nFWIW, we also _technically_ need to iterate by codepoint here instead of by character. Right now, this code is limited to UCS2 (no surrogate pair support), but I think that's similarly a secondary concern.",
        "pr_file_module": null
      },
      {
        "comment_id": "2065404762",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18700,
        "pr_file": "src/cascadia/TerminalApp/fzf/fzf.cpp",
        "discussion_id": "2060758370",
        "commented_code": "@@ -0,0 +1,379 @@\n+#include \"pch.h\"\r\n+#include \"fzf.h\"\r\n+#include <algorithm>\r\n+#include <cwctype>\r\n+\r\n+namespace fzf\r\n+{\r\n+    namespace matcher\r\n+    {\r\n+        constexpr int ScoreMatch = 16;\r\n+        constexpr int ScoreGapStart = -3;\r\n+        constexpr int ScoreGapExtension = -1;\r\n+        constexpr int BoundaryBonus = ScoreMatch / 2;\r\n+        constexpr int NonWordBonus = ScoreMatch / 2;\r\n+        constexpr int CamelCaseBonus = BoundaryBonus + ScoreGapExtension;\r\n+        constexpr int BonusConsecutive = -(ScoreGapStart + ScoreGapExtension);\r\n+        constexpr int BonusFirstCharMultiplier = 2;\r\n+\r\n+        enum CharClass\r\n+        {\r\n+            NonWord = 0,\r\n+            CharLower = 1,\r\n+            CharUpper = 2,\r\n+            Digit = 3,\r\n+        };\r\n+\r\n+        std::wstring_view TrimStart(const std::wstring_view str)\r\n+        {\r\n+            size_t start = str.find_first_not_of(L\" \");\r\n+            return (start == std::wstring::npos) ? std::wstring_view() : std::wstring_view(str).substr(start);\r\n+        }\r\n+\r\n+        std::wstring_view TrimSuffixSpaces(std::wstring_view input)\r\n+        {\r\n+            size_t end = input.size();\r\n+            while (end > 0 && input[end - 1] == L' ')\r\n+                --end;\r\n+            return input.substr(0, end);\r\n+        }\r\n+\r\n+        int IndexOfChar(std::wstring_view input, const WCHAR value[], int startIndex)\r\n+        {\r\n+            for (size_t i = startIndex; i < input.size(); i++)\r\n+            {\r\n+                const WCHAR currentCharAsString[] = { input[i], L'\\0' };\r\n+                auto isCurrentCharMatched = lstrcmpi(value, currentCharAsString) == 0;\r\n+                if (isCurrentCharMatched)\r\n+                    return static_cast<int>(i);\r\n+            }\r\n+            return -1;\r\n+        }\r\n+\r\n+        int FuzzyIndexOf(std::wstring_view input, std::wstring_view pattern)\r\n+        {\r\n+            int idx = 0;\r\n+            int firstIdx = 0;\r\n+            for (size_t patternIndex = 0; patternIndex < pattern.size(); patternIndex++)\r\n+            {\r\n+                // GH#9941: search should be locale-aware as well\r\n+                // We use the same comparison method as upon sorting to guarantee consistent behavior\r\n+                const WCHAR searchCharAsString[] = { pattern[patternIndex], L'\\0' };\r\n+                //const WCHAR currentCharAsString[] = { currentChar, L'\\0' };\r\n+                idx = IndexOfChar(input, searchCharAsString, idx);\r\n+                if (idx < 0)\r\n+                    return -1;\r\n+                if (patternIndex == 0 && idx > 0)\r\n+                    firstIdx = idx - 1;\r\n+                idx++;\r\n+            }\r\n+            return firstIdx;\r\n+        }\r\n+\r\n+        int CalculateBonus(CharClass prevClass, CharClass currentClass)\r\n+        {\r\n+            if (prevClass == NonWord && currentClass != NonWord)\r\n+                return BoundaryBonus;\r\n+            if ((prevClass == CharLower && currentClass == CharUpper) ||\r\n+                (prevClass != Digit && currentClass == Digit))\r\n+                return CamelCaseBonus;\r\n+            if (currentClass == NonWord)\r\n+                return NonWordBonus;\r\n+            return 0;\r\n+        }\r\n+\r\n+        CharClass ClassOf(wchar_t ch)\r\n+        {\r\n+            if (std::iswlower(ch))\r\n+                return CharLower;\r\n+            if (std::iswupper(ch))\r\n+                return CharUpper;\r\n+            if (std::iswdigit(ch))\r\n+                return Digit;\r\n+            return NonWord;\r\n+        }\r\n+\r\n+        FzfResult FzfFuzzyMatchV2(std::wstring_view text, std::wstring_view pattern, std::vector<int>* pos)\r\n+        {\r\n+            size_t patternSize = pattern.size();\r\n+            size_t textSize = text.size();\r\n+\r\n+            if (patternSize == 0)\r\n+                return { 0, 0, 0 };\r\n+\r\n+            int firstIndexOf = FuzzyIndexOf(text, pattern);\r\n+            if (firstIndexOf < 0)\r\n+                return { -1, -1, 0 };\r\n+\r\n+            auto initialScores = std::vector<int>(textSize);\r\n+            auto consecutiveScores = std::vector<int>(textSize);\r\n+            auto firstOccurrenceOfEachChar = std::vector<int>(patternSize);\r\n+            int maxScore = 0;\r\n+            int maxScorePos = 0;\r\n+            size_t patternIndex = 0;\r\n+            int lastIndex = 0;\r\n+            wchar_t firstPatternChar = pattern[0];\r\n+            wchar_t currentPatternChar = pattern[0];\r\n+            int previousInitialScore = 0;\r\n+            CharClass previousClass = NonWord;\r\n+            bool inGap = false;\r\n+\r\n+            auto textCopy = std::wstring{ text };\r\n+            std::ranges::transform(textCopy, textCopy.begin(), [](wchar_t c) {\r\n+                return std::towlower(c);\r\n+            });\r\n+            std::wstring_view lowerText(textCopy.data(), textCopy.size());\r\n+            std::wstring_view lowerTextSlice = lowerText.substr(firstIndexOf, textCopy.size() - firstIndexOf);\r\n+            auto initialScoresSlice = std::span<int>(initialScores).subspan(firstIndexOf);\r\n+            auto consecutiveScoresSlice = std::span<int>(consecutiveScores).subspan(firstIndexOf);\r\n+            auto bonusesSpan = std::vector<int>(textSize);\r\n+            auto bonusesSlice = std::span<int>(bonusesSpan).subspan(firstIndexOf, textSize - firstIndexOf);\r\n+\r\n+            for (size_t i = 0; i < lowerTextSlice.size(); i++)\r\n+            {\r\n+                wchar_t currentChar = lowerTextSlice[i];\r\n+                CharClass currentClass = ClassOf(currentChar);\r\n+                int bonus = CalculateBonus(previousClass, currentClass);\r\n+                bonusesSlice[i] = bonus;\r\n+                previousClass = currentClass;\r\n+\r\n+                // GH#9941: search should be locale-aware as well\r\n+                // We use the same comparison method as upon sorting to guarantee consistent behavior\r\n+                const WCHAR searchCharAsString[] = { currentPatternChar, L'\\0' };\r\n+                const WCHAR currentCharAsString[] = { currentChar, L'\\0' };\r\n+                auto isCurrentCharMatched = lstrcmpi(searchCharAsString, currentCharAsString) == 0;\r",
        "comment_created_at": "2025-04-29T04:14:43+00:00",
        "comment_author": "e82eric",
        "comment_body": "I \"think\" I have this in a better state now.\r\n- Updated to use u_foldCase for the lower casing and folding.  I think this works for everything except for some of the more complex folding, ex fold results in multiple code points\r\n- The text and pattern both get converted to UChar32 to iterate over the codepoints.\r\n- The positions get converted back to Utf16 positions for the highlighting\r\n- I tried to add some test cases for the multi language support and surrogate pairs,  but there are probably still some major holes in my understanding of Unicode,  are the there other scenarios that I should be testing for?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2054051780",
    "pr_number": 18813,
    "pr_file": "src/cascadia/TerminalSettingsModel/ApplicationState.cpp",
    "created_at": "2025-04-22T12:51:45+00:00",
    "commented_code": "_throttler();\r\n     }\r\n \r\n+    bool ApplicationState::DismissBadge(const hstring& badgeId)\r\n+    {\r\n+        bool inserted{ false };\r\n+        {\r\n+            const auto state = _state.lock();\r\n+            if (!state->DismissedBadges)\r\n+            {\r\n+                state->DismissedBadges = std::unordered_set<hstring>{};\r\n+            }\r\n+            if (!state->DismissedBadges->contains(badgeId))\r\n+            {\r\n+                state->DismissedBadges->insert(badgeId);",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2054051780",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18813,
        "pr_file": "src/cascadia/TerminalSettingsModel/ApplicationState.cpp",
        "discussion_id": "2054051780",
        "commented_code": "@@ -309,6 +309,35 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         _throttler();\r\n     }\r\n \r\n+    bool ApplicationState::DismissBadge(const hstring& badgeId)\r\n+    {\r\n+        bool inserted{ false };\r\n+        {\r\n+            const auto state = _state.lock();\r\n+            if (!state->DismissedBadges)\r\n+            {\r\n+                state->DismissedBadges = std::unordered_set<hstring>{};\r\n+            }\r\n+            if (!state->DismissedBadges->contains(badgeId))\r\n+            {\r\n+                state->DismissedBadges->insert(badgeId);\r",
        "comment_created_at": "2025-04-22T12:51:45+00:00",
        "comment_author": "lhecker",
        "comment_body": "Insert returns a tuple/pair whose second member is a bool. That bool is true if the item got inserted. This would simplify the code here because you don't need to call contains() first.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945547803",
    "pr_number": 18347,
    "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
    "created_at": "2025-02-06T22:12:46+00:00",
    "commented_code": "searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1945547803",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18347,
        "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
        "discussion_id": "1945547803",
        "commented_code": "@@ -547,27 +548,69 @@ void Terminal::SelectHyperlink(const SearchDirection dir)\n                 searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r",
        "comment_created_at": "2025-02-06T22:12:46+00:00",
        "comment_author": "zadjii-msft",
        "comment_body": "wait so if we find a hyperlink **we** marked up because it looked like a URL regex, we'll then look _inside_ the autodetected one for a manually delimited one?\r\n\r\nam I reading that right? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1962541189",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18347,
        "pr_file": "src/cascadia/TerminalCore/TerminalSelection.cpp",
        "discussion_id": "1945547803",
        "commented_code": "@@ -547,27 +548,69 @@ void Terminal::SelectHyperlink(const SearchDirection dir)\n                 searchArea = Viewport::FromDimensions(searchStart, { searchEnd.x + 1, searchEnd.y + 1 });\r\n             }\r\n         }\r\n+    }\r\n \r\n-        // 1.C) Nothing was found. Bail!\r\n-        if (!result.has_value())\r\n+    // 2. We found a hyperlink from the pattern tree. Look for embedded hyperlinks too!\r\n+    // Use the result (if one was found) to narrow down the search.\r\n+    searchStart = dir == SearchDirection::Forward ?\r\n+                      _selection->start :\r\n+                      (result ? result->second : bufferSize.Origin());\r\n+    searchEnd = dir == SearchDirection::Forward ?\r\n+                    (result ? result->first : buffer.GetLastNonSpaceCharacter()) :\r\n+                    _selection->start;\r",
        "comment_created_at": "2025-02-19T23:48:59+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "Applied [Leonard's suggestion](https://github.com/microsoft/terminal/pull/18347#discussion_r1945544034) to help make searchStart/End more clear.\r\n\r\nSo, in step 1, the search space spans from our selection to the visible start/end index. We're able to extract a regex match from `_patternIntervalTree` using `findContained()`. Since we have to pass the search space into that function, we're just calling it over and over again with an expanded search space until we find something.\r\n\r\nStep 2 has to use a `TextBufferCellIterator` to search through the buffer for a hyperlink attribute. Assuming we already found a `result` in step one, we can reduce the search space to be from our selection to the `result`. (if no result was found, search up to the buffer boundaries*)\r\n\r\n*additional optimization: use `GetLastNonSpaceCharacter()` as end instead of `bufferSize.End()` ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1970050686",
    "pr_number": 18627,
    "pr_file": "src/cascadia/TerminalApp/TerminalWindow.cpp",
    "created_at": "2025-02-25T15:46:14+00:00",
    "commented_code": "{\r\n         try\r\n         {\r\n-            const auto& args = ActionAndArgs::Deserialize(content);\r\n+            const auto args = ActionAndArgs::Deserialize(content);",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1970050686",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18627,
        "pr_file": "src/cascadia/TerminalApp/TerminalWindow.cpp",
        "discussion_id": "1970050686",
        "commented_code": "@@ -1200,7 +1196,7 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         try\r\n         {\r\n-            const auto& args = ActionAndArgs::Deserialize(content);\r\n+            const auto args = ActionAndArgs::Deserialize(content);\r",
        "comment_created_at": "2025-02-25T15:46:14+00:00",
        "comment_author": "lhecker",
        "comment_body": "C++ is a whack language so be careful when binding return values to references. Doing so incorrectly breaks return-value-optimization (as it did here)!",
        "pr_file_module": null
      },
      {
        "comment_id": "1970121310",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18627,
        "pr_file": "src/cascadia/TerminalApp/TerminalWindow.cpp",
        "discussion_id": "1970050686",
        "commented_code": "@@ -1200,7 +1196,7 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         try\r\n         {\r\n-            const auto& args = ActionAndArgs::Deserialize(content);\r\n+            const auto args = ActionAndArgs::Deserialize(content);\r",
        "comment_created_at": "2025-02-25T16:22:37+00:00",
        "comment_author": "DHowett",
        "comment_body": "/cc @carlos-zamora this is an excellent example of where `const auto&` on a _local_ goes wrong!",
        "pr_file_module": null
      },
      {
        "comment_id": "1970355992",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18627,
        "pr_file": "src/cascadia/TerminalApp/TerminalWindow.cpp",
        "discussion_id": "1970050686",
        "commented_code": "@@ -1200,7 +1196,7 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         try\r\n         {\r\n-            const auto& args = ActionAndArgs::Deserialize(content);\r\n+            const auto args = ActionAndArgs::Deserialize(content);\r",
        "comment_created_at": "2025-02-25T18:52:41+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "(Double-checking) So what's the lesson here? Don't store returned `IVector`s (or any winrt collection) to a `const auto&`? Does it still work correctly, but it just gets rid of the optimization?",
        "pr_file_module": null
      },
      {
        "comment_id": "1970467414",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18627,
        "pr_file": "src/cascadia/TerminalApp/TerminalWindow.cpp",
        "discussion_id": "1970050686",
        "commented_code": "@@ -1200,7 +1196,7 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         try\r\n         {\r\n-            const auto& args = ActionAndArgs::Deserialize(content);\r\n+            const auto args = ActionAndArgs::Deserialize(content);\r",
        "comment_created_at": "2025-02-25T20:01:48+00:00",
        "comment_author": "lhecker",
        "comment_body": "When you have a function that returns something by-value and you bind it to a reference here's what actually happens:\r\n```cpp\r\nconst auto __hidden_variable__ = ActionAndArgs::Deserialize(content);\r\nconst auto& args = __hidden_variable__;\r\n\r\n// ...\r\n\r\nreturn args;\r\n```\r\n\r\nAs you can see in the example, you return a reference at the end, not the original object. This forces C++ to make a copy of the object. If you don't bind it to a reference, then you'll also return the original object at the end and \"return value optimization\" will kick in.\r\n\r\nThe problem is when you have a function that returns a reference, but you bind it to a value. Because then you'll also make a copy:\r\n```cpp\r\nconst auto args = return_a_reference_to_arguments();\r\n//     ^        ^\r\n//     |   Because `args` is a value type, but the function returns a reference,\r\n//     |   this invokes the `vector(const vector& other)` copy constructor.\r\n//     |\r\n// \"auto\" always infers a value type, never refences, etc.\r\n// So, in this case it may be `std::vector`, not `std::vector&`.\r\n```\r\n\r\nC++ has a fix for this con job of supposed type inference and it's this:\r\n```cpp\r\ndecltype(auto) args = return_a_reference_to_arguments();\r\n//   ^\r\n// This always infers the exact type, including references, constness, pointers, etc.\r\n```\r\n\r\nIt couldn't have been just `let` or `var` or something. \ud83d\ude10\r\nIn any case, if you use Resharper (currently free to use via the so-called EAP), you get little inlay hints that tell you when an invisible copy constructor is called. This allows me to quickly spot these issues.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1658940967",
    "pr_number": 17421,
    "pr_file": "src/terminal/adapter/SixelParser.cpp",
    "created_at": "2024-06-28T15:45:09+00:00",
    "commented_code": "+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"precomp.h\"\r\n+\r\n+#include \"SixelParser.hpp\"\r\n+#include \"adaptDispatch.hpp\"\r\n+#include \"../buffer/out/ImageSlice.hpp\"\r\n+#include \"../parser/ascii.hpp\"\r\n+#include \"../renderer/base/renderer.hpp\"\r\n+#include \"../types/inc/colorTable.hpp\"\r\n+#include \"../types/inc/utils.hpp\"\r\n+\r\n+using namespace Microsoft::Console::Types;\r\n+using namespace Microsoft::Console::Utils;\r\n+using namespace Microsoft::Console::VirtualTerminal;\r\n+using namespace std::chrono;\r\n+using namespace std::chrono_literals;\r\n+\r\n+til::size SixelParser::CellSizeForLevel(const VTInt conformanceLevel) noexcept\r\n+{\r\n+    switch (conformanceLevel)\r\n+    {\r\n+    case 1: // Compatible with the VT125\r\n+        return { 9, 20 };\r\n+    default: // Compatible with the VT240 and VT340\r\n+        return { 10, 20 };\r\n+    }\r\n+}\r\n+\r\n+size_t SixelParser::MaxColorsForLevel(const VTInt conformanceLevel) noexcept\r\n+{\r\n+    switch (conformanceLevel)\r\n+    {\r\n+    case 1:\r\n+    case 2: // Compatible with the 4-color VT125 and VT240\r\n+        return 4;\r\n+    case 3: // Compatible with the 16-color VT340\r\n+        return 16;\r\n+    default: // Modern sixel apps often require 256 colors.\r\n+        return MAX_COLORS;\r\n+    }\r\n+}\r\n+\r\n+SixelParser::SixelParser(AdaptDispatch& dispatcher, const StateMachine& stateMachine, const VTInt conformanceLevel) noexcept :\r\n+    _dispatcher{ dispatcher },\r\n+    _stateMachine{ stateMachine },\r\n+    _conformanceLevel{ conformanceLevel },\r\n+    _cellSize{ CellSizeForLevel(conformanceLevel) },\r\n+    _maxColors{ MaxColorsForLevel(conformanceLevel) }\r\n+{\r\n+    // We initialize the first 16 color entries with the VT340 palette, which is\r\n+    // also compatible with the 4-color VT125 and VT240. The remaining entries\r\n+    // are initialized with the XTerm extended colors.\r\n+    Microsoft::Console::Utils::InitializeVT340ColorTable(_colorTable);\r\n+    Microsoft::Console::Utils::InitializeExtendedColorTable(_colorTable);\r\n+}\r\n+\r\n+void SixelParser::SoftReset()\r\n+{\r\n+    // The VT240 is the only terminal known to reset colors with DECSTR.\r\n+    // We only reset the first 16, since it only needs 4 of them anyway.\r\n+    if (_conformanceLevel == 2)\r\n+    {\r\n+        Microsoft::Console::Utils::InitializeVT340ColorTable(_colorTable);\r\n+        _updateTextColors();\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::SetDisplayMode(const bool enabled) noexcept\r\n+{\r\n+    // The display mode determines whether images are clamped at the bottom of\r\n+    // the screen (the set state), or scroll when they reach the bottom of the\r\n+    // margin area (the reset state). Clamping was the only mode of operation\r\n+    // supported prior to the VT340, so we don't allow the mode to be reset on\r\n+    // levels 1 and 2.\r\n+    if (_conformanceLevel >= 3)\r\n+    {\r\n+        _displayMode = enabled;\r\n+    }\r\n+}\r\n+\r\n+std::function<bool(wchar_t)> SixelParser::DefineImage(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect, const VTParameter backgroundColor)\r\n+{\r\n+    if (_initTextBufferBoundaries())\r\n+    {\r\n+        _initRasterAttributes(macroParameter, backgroundSelect);\r\n+        _initColorMap(backgroundColor);\r\n+        _initImageBuffer();\r\n+        _state = States::Normal;\r\n+        _parameters.clear();\r\n+        return [&](const auto ch) {\r\n+            _parseCommandChar(ch);\r\n+            return true;\r\n+        };\r\n+    }\r\n+    else\r\n+    {\r\n+        return nullptr;\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_parseCommandChar(const wchar_t ch)\r\n+{\r\n+    // Characters in the range `?` to `~` encode a sixel value, which is a group\r\n+    // of six vertical pixels. After subtracting `?` from the character, you've\r\n+    // got a six bit binary value which represents the six pixels.\r\n+    if (ch >= '?' && ch <= '~') [[likely]]\r\n+    {\r\n+        // When preceded by a repeat command, the repeat parameter value denotes\r\n+        // the number of times that the following sixel should be repeated.\r\n+        const auto repeatCount = _applyPendingCommand();\r\n+        _writeToImageBuffer(ch - L'?', repeatCount);\r\n+    }\r\n+    // Characters `0` to `9` and `;` are used to represent parameter values for\r\n+    // commands that require them.\r\n+    else if ((ch >= '0' && ch <= '9') || ch == ';')\r\n+    {\r\n+        _parseParameterChar(ch);\r\n+    }\r\n+    // The remaining characters represent commands, some of which will execute\r\n+    // immediately, but some requiring additional parameter values. In the\r\n+    // latter case, the command will only be applied once the next command\r\n+    // character is received.\r\n+    else\r\n+    {\r\n+        switch (ch)\r\n+        {\r\n+        case '#': // DECGCI - Color Introducer\r\n+            _applyPendingCommand();\r\n+            _state = States::Color;\r\n+            _parameters.clear();\r\n+            break;\r\n+        case '!': // DECGRI - Repeat Introducer\r\n+            _applyPendingCommand();\r\n+            _state = States::Repeat;\r\n+            _parameters.clear();\r\n+            break;\r\n+        case '$': // DECGCR - Graphics Carriage Return\r\n+            _applyPendingCommand();\r\n+            _executeCarriageReturn();\r\n+            break;\r\n+        case '-': // DECGNL - Graphics Next Line\r\n+            _applyPendingCommand();\r\n+            _executeNextLine();\r\n+            break;\r\n+        case '+': // Undocumented home command (VT240 only)\r\n+            if (_conformanceLevel == 2)\r\n+            {\r\n+                _applyPendingCommand();\r\n+                _executeMoveToHome();\r\n+            }\r\n+            break;\r\n+        case '\"': // DECGRA - Set Raster Attributes\r\n+            if (_conformanceLevel >= 3)\r\n+            {\r\n+                _applyPendingCommand();\r\n+                _state = States::Attributes;\r\n+                _parameters.clear();\r\n+            }\r\n+            break;\r\n+        case AsciiChars::ESC: // End of image sequence\r\n+            // At this point we only care about pending color changes. Raster\r\n+            // attributes have no effect at the end of a sequence, and a repeat\r\n+            // command is only applicable when followed by a sixel value.\r\n+            if (_state == States::Color)\r\n+            {\r\n+                _applyPendingCommand();\r\n+            }\r\n+            _fillImageBackground();\r\n+            _executeCarriageReturn();\r\n+            _maybeFlushImageBuffer(true);\r\n+            break;\r\n+        default:\r\n+            break;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_parseParameterChar(const wchar_t ch)\r\n+{\r\n+    // The most any command requires is 5 parameters (for the color command),\r\n+    // so anything after that can be ignored.\r\n+    if (_parameters.size() <= 5)\r\n+    {\r\n+        if (_parameters.empty())\r\n+        {\r\n+            _parameters.push_back({});\r\n+        }\r\n+\r\n+        if (ch == ';')\r\n+        {\r\n+            _parameters.push_back({});\r\n+        }\r\n+        else\r\n+        {\r\n+            const VTInt digit = ch - L'0';\r\n+            auto currentValue = _parameters.back().value_or(0);\r\n+            currentValue = currentValue * 10 + digit;\r\n+            _parameters.back() = std::min(currentValue, MAX_PARAMETER_VALUE);\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+int SixelParser::_applyPendingCommand()\r\n+{\r\n+    if (_state != States::Normal) [[unlikely]]\r\n+    {\r\n+        const auto previousState = _state;\r\n+        _state = States::Normal;\r\n+        switch (previousState)\r\n+        {\r\n+        case States::Color:\r\n+            _defineColor({ _parameters.data(), _parameters.size() });\r\n+            return 1;\r\n+        case States::Repeat:\r\n+            return VTParameters{ _parameters.data(), _parameters.size() }.at(0);\r\n+        case States::Attributes:\r\n+            _updateRasterAttributes({ _parameters.data(), _parameters.size() });\r\n+            return 1;\r\n+        }\r\n+    }\r\n+    return 1;\r\n+}\r\n+\r\n+void SixelParser::_executeCarriageReturn() noexcept\r\n+{\r\n+    _imageWidth = std::max(_imageWidth, _imageCursor.x);\r\n+    _imageCursor.x = 0;\r\n+}\r\n+\r\n+void SixelParser::_executeNextLine()\r\n+{\r\n+    _executeCarriageReturn();\r\n+    _imageLineCount++;\r\n+    _maybeFlushImageBuffer();\r\n+    _imageCursor.y += _sixelHeight;\r\n+    _availablePixelHeight -= _sixelHeight;\r\n+    _resizeImageBuffer(_sixelHeight);\r\n+}\r\n+\r\n+void SixelParser::_executeMoveToHome()\r\n+{\r\n+    _executeCarriageReturn();\r\n+    _maybeFlushImageBuffer();\r\n+    _imageCursor.y = 0;\r\n+    _availablePixelHeight = _textMargins.height() * _cellSize.height;\r\n+}\r\n+\r\n+bool SixelParser::_initTextBufferBoundaries()\r\n+{\r\n+    const auto page = _dispatcher._pages.ActivePage();\r\n+    auto validOrigin = true;\r\n+    if (_displayMode)\r\n+    {\r\n+        // When display mode is set, we can write to the full extent of the page\r\n+        // and the starting cursor position is the top left of the page.\r\n+        _textMargins = { 0, page.Top(), page.Width(), page.Bottom() };\r\n+        _textCursor = _textMargins.origin();\r\n+        _availablePixelWidth = page.Width() * _cellSize.width;\r\n+        _availablePixelHeight = page.Height() * _cellSize.height;\r\n+    }\r\n+    else\r\n+    {\r\n+        // When display mode is reset, we're constrained by the text margins,\r\n+        // and the starting position is the current cursor position. This must\r\n+        // be inside the horizontal margins and above the bottom margin, else\r\n+        // nothing will be rendered.\r\n+        const auto [topMargin, bottomMargin] = _dispatcher._GetVerticalMargins(page, true);\r\n+        const auto [leftMargin, rightMargin] = _dispatcher._GetHorizontalMargins(page.Width());\r\n+        _textMargins = til::rect{ leftMargin, topMargin, rightMargin + 1, bottomMargin + 1 };\r\n+        _textCursor = page.Cursor().GetPosition();\r\n+        _availablePixelWidth = (_textMargins.right - _textCursor.x) * _cellSize.width;\r\n+        _availablePixelHeight = (_textMargins.bottom - _textCursor.y) * _cellSize.height;\r\n+        validOrigin = _textCursor.x >= leftMargin && _textCursor.x <= rightMargin && _textCursor.y <= bottomMargin;\r\n+    }\r\n+    _pendingTextScrollCount = 0;\r\n+\r\n+    // The pixel aspect ratio can't be so large that it would prevent a sixel\r\n+    // row from fitting within the margin height, so we need to have a limit.\r\n+    _maxPixelAspectRatio = _textMargins.height() * _cellSize.height / 6;\r\n+\r\n+    // If the cursor is visible, we need to hide it while the sixel data is\r\n+    // being processed. It will be made visible again when we're done.\r\n+    _textCursorWasVisible = page.Cursor().IsVisible();\r\n+    if (_textCursorWasVisible && validOrigin)\r\n+    {\r\n+        page.Cursor().SetIsVisible(false);\r\n+    }\r\n+    return validOrigin;\r\n+}\r\n+\r\n+void SixelParser::_initRasterAttributes(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect) noexcept\r\n+{\r\n+    if (_conformanceLevel < 3)\r\n+    {\r\n+        // Prior to the VT340, the pixel aspect ratio was fixed at 2:1.\r\n+        _pixelAspectRatio = 2;\r\n+    }\r\n+    else\r\n+    {\r\n+        // The macro parameter was originally used on printers to define the\r\n+        // pixel aspect ratio and the grid size (the distance between pixels).\r\n+        // On graphic terminals, though, it's only used for the aspect ratio,\r\n+        // and then only a limited set of ratios are supported.\r\n+        switch (macroParameter)\r\n+        {\r\n+        case 0:\r\n+        case 1:\r\n+        case 5:\r\n+        case 6:\r\n+            _pixelAspectRatio = 2;\r\n+            break;\r\n+        case 2:\r\n+            _pixelAspectRatio = 5;\r\n+            break;\r\n+        case 3:\r\n+        case 4:\r\n+            _pixelAspectRatio = 3;\r\n+            break;\r\n+        case 7:\r\n+        case 8:\r\n+        case 9:\r\n+        default:\r\n+            // While the default aspect ratio is defined as 2:1, macro parameter\r\n+            // values outside the defined range of 0 to 9 should map to 1:1.\r\n+            _pixelAspectRatio = 1;\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    // The height of a sixel row is 6 virtual pixels, but if the aspect ratio is\r\n+    // greater than one, the height in device pixels is a multiple of that.\r\n+    _sixelHeight = 6 * _pixelAspectRatio;\r\n+    _segmentHeight = _sixelHeight;\r\n+\r\n+    // On the VT125, the background was always drawn, but for other terminals it\r\n+    // depends on the value of the background select parameter.\r\n+    const auto transparent = (backgroundSelect == DispatchTypes::SixelBackground::Transparent);\r\n+    _backgroundFillRequired = (_conformanceLevel == 1 || !transparent);\r\n+\r\n+    // By default, the filled area will cover the maximum extent allowed.\r\n+    _backgroundSize = { til::CoordTypeMax, til::CoordTypeMax };\r\n+}\r\n+\r\n+void SixelParser::_updateRasterAttributes(const VTParameters& rasterAttributes)\r\n+{\r\n+    // The documentation says default values should be interpreted as 1, but\r\n+    // the original VT340 hardware interprets omitted parameters as 0, and if\r\n+    // the x aspect is 0 (implying division by zero), the update is ignored.\r\n+    const auto yAspect = rasterAttributes.at(0).value_or(0);\r\n+    const auto xAspect = rasterAttributes.at(1).value_or(0);\r\n+    if (xAspect > 0)\r\n+    {\r\n+        // The documentation suggests the aspect ratio is rounded to the nearest\r\n+        // integer, but on the original VT340 hardware it was rounded up.\r\n+        _pixelAspectRatio = std::clamp(static_cast<int>(std::ceil(yAspect * 1.0 / xAspect)), 1, _maxPixelAspectRatio);\r\n+        _sixelHeight = 6 * _pixelAspectRatio;\r\n+        // When the sixel height is changed multiple times in a row, the segment\r\n+        // height has to track the maximum of all the sixel heights used.\r\n+        _segmentHeight = std::max(_segmentHeight, _sixelHeight);\r\n+        _resizeImageBuffer(_sixelHeight);\r\n+    }\r\n+\r\n+    // Although it's not clear from the documentation, we know from testing on\r\n+    // a VT340 that the background dimensions are measured in device pixels, so\r\n+    // the given height does not need to be scaled by the pixel aspect ratio.\r\n+    const auto width = rasterAttributes.at(2).value_or(0);\r\n+    const auto height = rasterAttributes.at(3).value_or(0);\r\n+\r\n+    // If these values are omitted or 0, they default to what they were before,\r\n+    // which typically would mean filling the whole screen, but could also fall\r\n+    // back to the dimensions from an earlier raster attributes command.\r\n+    _backgroundSize.width = width > 0 ? width : _backgroundSize.width;\r\n+    _backgroundSize.height = height > 0 ? height : _backgroundSize.height;\r\n+}\r\n+\r\n+void SixelParser::_scrollTextBuffer(Page& page, const int scrollAmount)\r\n+{\r\n+    // We scroll the text buffer by moving the cursor to the bottom of the\r\n+    // margin area and executing an appropriate number of line feeds.\r\n+    if (_textCursor.y != _textMargins.bottom - 1)\r\n+    {\r\n+        _textCursor = { _textCursor.x, _textMargins.bottom - 1 };\r\n+        page.Cursor().SetPosition(_textCursor);\r\n+    }\r\n+    auto panAmount = 0;\r\n+    for (auto i = 0; i < scrollAmount; i++)\r\n+    {\r\n+        if (_dispatcher._DoLineFeed(page, false, false))\r\n+        {\r\n+            page.MoveViewportDown();\r\n+            panAmount++;\r\n+        }\r\n+    }\r\n+\r\n+    // If the line feeds panned the viewport down, we need to adjust our margins\r\n+    // and text cursor coordinates to align with that movement.\r\n+    _textCursor.y += panAmount;\r\n+    _textMargins += til::point{ 0, panAmount };\r\n+\r\n+    // And if it wasn't all panning, we need to move the image origin up to\r\n+    // match the number of rows that were actually scrolled.\r\n+    if (scrollAmount > panAmount)\r\n+    {\r\n+        auto expectedMovement = scrollAmount - panAmount;\r\n+        // If constrained by margins, we can only move as far as the top margin.\r\n+        if (_textMargins.top > page.Top() || _textMargins.left > 0 || _textMargins.right < page.Width() - 1)\r\n+        {\r\n+            const auto availableSpace = std::max(_imageOriginCell.y - _textMargins.top, 0);\r\n+            if (expectedMovement > availableSpace)\r\n+            {\r\n+                // Anything more than that will need to be erased from the\r\n+                // image. And if the origin was already above the top margin,\r\n+                // this erased segment will be partway through the image.\r\n+                const auto eraseRowCount = expectedMovement - availableSpace;\r\n+                const auto eraseOffset = std::max(_textMargins.top - _imageOriginCell.y, 0);\r\n+                _eraseImageBufferRows(eraseRowCount, eraseOffset);\r\n+                // But if there was any available space, we still then need to\r\n+                // move the origin up as far as it can go.\r\n+                expectedMovement = availableSpace;\r\n+            }\r\n+        }\r\n+        _imageOriginCell.y -= expectedMovement;\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_updateTextCursor(Cursor& cursor) noexcept\r\n+{\r\n+    // Unless the sixel display mode is set, we need to update the text cursor\r\n+    // position to align with the final image cursor position. This should be\r\n+    // the cell which is intersected by the top of the final sixel row.\r\n+    if (!_displayMode)\r\n+    {\r\n+        const auto finalRow = _imageOriginCell.y + _imageCursor.y / _cellSize.height;\r\n+        if (finalRow != _textCursor.y)\r\n+        {\r\n+            cursor.SetPosition({ _textCursor.x, finalRow });\r\n+        }\r\n+    }\r\n+    // And if the cursor was visible when we started, we need to restore it.\r\n+    if (_textCursorWasVisible)\r\n+    {\r\n+        cursor.SetIsVisible(true);\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_initColorMap(const VTParameter backgroundColor)\r\n+{\r\n+    _colorsUsed = 0;\r\n+    _colorsAvailable = _maxColors;\r\n+    _colorTableChanged = false;\r\n+\r\n+    // The color numbers in a sixel image don't necessarily map directly to\r\n+    // entries in the color table. That mapping is determined by the order in\r\n+    // which the colors are defined. If they aren't defined, though, the default\r\n+    // mapping is just the color number modulo the color table size.\r\n+    for (size_t colorNumber = 0; colorNumber < _colorMap.size(); colorNumber++)\r\n+    {\r\n+        _colorMap.at(colorNumber) = colorNumber % _maxColors;\r\n+    }\r\n+\r\n+    // The _colorMapUsed field keeps track of the color numbers that have been\r\n+    // explicitly mapped to a color table entry, since that locks in the mapping\r\n+    // for the duration of the image. Additional definitions for that color\r\n+    // number will update the existing mapped table entry - they won't generate\r\n+    // new mappings for the number.\r\n+    std::fill(_colorMapUsed.begin(), _colorMapUsed.end(), false);\r\n+\r\n+    // The VT240 has an extra feature, whereby the P3 parameter defines the\r\n+    // color number to be used for the background (i.e. it's preassigned to\r\n+    // table entry 0). If you specify a value larger than the maximum color\r\n+    // table index, the number of available colors is reduced by 1, which\r\n+    // effectively protects the background color from modification.\r\n+    if (_conformanceLevel == 2 && backgroundColor.has_value()) [[unlikely]]\r\n+    {\r\n+        const size_t colorNumber = backgroundColor.value();\r\n+        if (colorNumber < _maxColors)\r\n+        {\r\n+            til::at(_colorMap, colorNumber) = 0;\r\n+            til::at(_colorMapUsed, colorNumber) = true;\r\n+        }\r\n+        else\r\n+        {\r\n+            _colorsAvailable = _maxColors - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // On the original hardware terminals, the default color index would have\r\n+    // been the last entry in the color table. But on modern terminals, it is\r\n+    // typically capped at 15 for compatibility with the 16-color VT340. This\r\n+    // is the color used if no color commands are received.\r\n+    const auto defaultColorIndex = std::min<size_t>(_maxColors - 1, 15);\r\n+    _foregroundPixel = { .colorIndex = gsl::narrow_cast<IndexType>(defaultColorIndex) };\r\n+}\r\n+\r\n+void SixelParser::_defineColor(const VTParameters& colorParameters)\r\n+{\r\n+    // The first parameter selects the color number to use. If it's greater than\r\n+    // the color map size, we just mod the value into range.\r\n+    const auto colorNumber = colorParameters.at(0).value_or(0) % _colorMap.size();\r\n+\r\n+    // If there are additional parameters, then this command will also redefine\r\n+    // the color palette associated with the selected color number. This is not\r\n+    // supported on the VT125 though.\r\n+    if (colorParameters.size() > 1 && _conformanceLevel > 1) [[unlikely]]\r\n+    {\r\n+        const auto model = DispatchTypes::ColorModel{ colorParameters.at(1) };\r\n+        const auto x = colorParameters.at(2).value_or(0);\r\n+        const auto y = colorParameters.at(3).value_or(0);\r\n+        const auto z = colorParameters.at(4).value_or(0);\r\n+        switch (model)\r\n+        {\r\n+        case DispatchTypes::ColorModel::HLS:\r\n+            _defineColor(colorNumber, Utils::ColorFromHLS(x, y, z));\r\n+            break;\r\n+        case DispatchTypes::ColorModel::RGB:\r\n+            _defineColor(colorNumber, Utils::ColorFromRGB100(x, y, z));\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    // The actual color table index we use is derived from the color number via\r\n+    // the color map. This is initially defined in _initColorMap above, but may\r\n+    // be altered when colors are set in the _defineColor method below.\r\n+    const auto colorIndex = _colorMap.at(colorNumber);\r\n+    _foregroundPixel = { .colorIndex = gsl::narrow_cast<IndexType>(colorIndex) };\r\n+}\r\n+\r\n+void SixelParser::_defineColor(const size_t colorNumber, const COLORREF color)\r\n+{\r\n+    if (til::at(_colorMapUsed, colorNumber))\r\n+    {\r\n+        // If the color is already assigned, we update the mapped table entry.\r\n+        const auto tableIndex = til::at(_colorMap, colorNumber);\r\n+        til::at(_colorTable, tableIndex) = color;\r\n+        _colorTableChanged = true;\r\n+        // If some image content has already been defined at this point, and\r\n+        // we're processing the last character in the packet, this is likely an\r\n+        // attempt to animate the palette, so we should flush the image.\r\n+        if (_imageWidth > 0 && _stateMachine.IsProcessingLastCharacter())\r\n+        {\r\n+            _maybeFlushImageBuffer();\r\n+        }\r\n+    }\r\n+    else\r\n+    {\r\n+        // Otherwise assign it to the next available color table entry.\r\n+        if (_colorsUsed < _colorsAvailable)\r\n+        {\r\n+            // Since table entry 0 is the background color, which you typically\r\n+            // want to leave unchanged, the original hardware terminals would\r\n+            // skip that and start with table entry 1, and only wrap back to 0\r\n+            // when all others had been used.\r\n+            const auto tableIndex = ++_colorsUsed % _maxColors;\r\n+            til::at(_colorMap, colorNumber) = tableIndex;\r\n+            til::at(_colorTable, tableIndex) = color;\r\n+            _colorTableChanged = true;\r\n+        }\r\n+        else if (_conformanceLevel == 2)\r\n+        {\r\n+            // If we've used up all the available color table entries, we have\r\n+            // to assign this color number to one of the previously used ones.\r\n+            // The VT240 uses the closest match from the existing color entries,\r\n+            // but the VT340 just uses the default mapping assigned at the start\r\n+            // (i.e. the color number modulo the color table size).\r\n+            size_t tableIndex = 0;\r\n+            int bestDiff = 99999;\r\n+            for (size_t i = 0; i < _maxColors; i++)\r\n+            {\r\n+                const auto existingColor = til::at(_colorTable, i);\r\n+                const auto diff = [](const auto c1, const auto c2) noexcept {\r\n+                    return std::abs(static_cast<int>(c1) - static_cast<int>(c2));\r\n+                };\r\n+                const auto redDiff = diff(GetRValue(existingColor), GetRValue(color));\r\n+                const auto greenDiff = diff(GetGValue(existingColor), GetGValue(color));\r\n+                const auto blueDiff = diff(GetBValue(existingColor), GetBValue(color));\r\n+                const auto totalDiff = redDiff + greenDiff + blueDiff;",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1658940967",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 17421,
        "pr_file": "src/terminal/adapter/SixelParser.cpp",
        "discussion_id": "1658940967",
        "commented_code": "@@ -0,0 +1,840 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"precomp.h\"\r\n+\r\n+#include \"SixelParser.hpp\"\r\n+#include \"adaptDispatch.hpp\"\r\n+#include \"../buffer/out/ImageSlice.hpp\"\r\n+#include \"../parser/ascii.hpp\"\r\n+#include \"../renderer/base/renderer.hpp\"\r\n+#include \"../types/inc/colorTable.hpp\"\r\n+#include \"../types/inc/utils.hpp\"\r\n+\r\n+using namespace Microsoft::Console::Types;\r\n+using namespace Microsoft::Console::Utils;\r\n+using namespace Microsoft::Console::VirtualTerminal;\r\n+using namespace std::chrono;\r\n+using namespace std::chrono_literals;\r\n+\r\n+til::size SixelParser::CellSizeForLevel(const VTInt conformanceLevel) noexcept\r\n+{\r\n+    switch (conformanceLevel)\r\n+    {\r\n+    case 1: // Compatible with the VT125\r\n+        return { 9, 20 };\r\n+    default: // Compatible with the VT240 and VT340\r\n+        return { 10, 20 };\r\n+    }\r\n+}\r\n+\r\n+size_t SixelParser::MaxColorsForLevel(const VTInt conformanceLevel) noexcept\r\n+{\r\n+    switch (conformanceLevel)\r\n+    {\r\n+    case 1:\r\n+    case 2: // Compatible with the 4-color VT125 and VT240\r\n+        return 4;\r\n+    case 3: // Compatible with the 16-color VT340\r\n+        return 16;\r\n+    default: // Modern sixel apps often require 256 colors.\r\n+        return MAX_COLORS;\r\n+    }\r\n+}\r\n+\r\n+SixelParser::SixelParser(AdaptDispatch& dispatcher, const StateMachine& stateMachine, const VTInt conformanceLevel) noexcept :\r\n+    _dispatcher{ dispatcher },\r\n+    _stateMachine{ stateMachine },\r\n+    _conformanceLevel{ conformanceLevel },\r\n+    _cellSize{ CellSizeForLevel(conformanceLevel) },\r\n+    _maxColors{ MaxColorsForLevel(conformanceLevel) }\r\n+{\r\n+    // We initialize the first 16 color entries with the VT340 palette, which is\r\n+    // also compatible with the 4-color VT125 and VT240. The remaining entries\r\n+    // are initialized with the XTerm extended colors.\r\n+    Microsoft::Console::Utils::InitializeVT340ColorTable(_colorTable);\r\n+    Microsoft::Console::Utils::InitializeExtendedColorTable(_colorTable);\r\n+}\r\n+\r\n+void SixelParser::SoftReset()\r\n+{\r\n+    // The VT240 is the only terminal known to reset colors with DECSTR.\r\n+    // We only reset the first 16, since it only needs 4 of them anyway.\r\n+    if (_conformanceLevel == 2)\r\n+    {\r\n+        Microsoft::Console::Utils::InitializeVT340ColorTable(_colorTable);\r\n+        _updateTextColors();\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::SetDisplayMode(const bool enabled) noexcept\r\n+{\r\n+    // The display mode determines whether images are clamped at the bottom of\r\n+    // the screen (the set state), or scroll when they reach the bottom of the\r\n+    // margin area (the reset state). Clamping was the only mode of operation\r\n+    // supported prior to the VT340, so we don't allow the mode to be reset on\r\n+    // levels 1 and 2.\r\n+    if (_conformanceLevel >= 3)\r\n+    {\r\n+        _displayMode = enabled;\r\n+    }\r\n+}\r\n+\r\n+std::function<bool(wchar_t)> SixelParser::DefineImage(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect, const VTParameter backgroundColor)\r\n+{\r\n+    if (_initTextBufferBoundaries())\r\n+    {\r\n+        _initRasterAttributes(macroParameter, backgroundSelect);\r\n+        _initColorMap(backgroundColor);\r\n+        _initImageBuffer();\r\n+        _state = States::Normal;\r\n+        _parameters.clear();\r\n+        return [&](const auto ch) {\r\n+            _parseCommandChar(ch);\r\n+            return true;\r\n+        };\r\n+    }\r\n+    else\r\n+    {\r\n+        return nullptr;\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_parseCommandChar(const wchar_t ch)\r\n+{\r\n+    // Characters in the range `?` to `~` encode a sixel value, which is a group\r\n+    // of six vertical pixels. After subtracting `?` from the character, you've\r\n+    // got a six bit binary value which represents the six pixels.\r\n+    if (ch >= '?' && ch <= '~') [[likely]]\r\n+    {\r\n+        // When preceded by a repeat command, the repeat parameter value denotes\r\n+        // the number of times that the following sixel should be repeated.\r\n+        const auto repeatCount = _applyPendingCommand();\r\n+        _writeToImageBuffer(ch - L'?', repeatCount);\r\n+    }\r\n+    // Characters `0` to `9` and `;` are used to represent parameter values for\r\n+    // commands that require them.\r\n+    else if ((ch >= '0' && ch <= '9') || ch == ';')\r\n+    {\r\n+        _parseParameterChar(ch);\r\n+    }\r\n+    // The remaining characters represent commands, some of which will execute\r\n+    // immediately, but some requiring additional parameter values. In the\r\n+    // latter case, the command will only be applied once the next command\r\n+    // character is received.\r\n+    else\r\n+    {\r\n+        switch (ch)\r\n+        {\r\n+        case '#': // DECGCI - Color Introducer\r\n+            _applyPendingCommand();\r\n+            _state = States::Color;\r\n+            _parameters.clear();\r\n+            break;\r\n+        case '!': // DECGRI - Repeat Introducer\r\n+            _applyPendingCommand();\r\n+            _state = States::Repeat;\r\n+            _parameters.clear();\r\n+            break;\r\n+        case '$': // DECGCR - Graphics Carriage Return\r\n+            _applyPendingCommand();\r\n+            _executeCarriageReturn();\r\n+            break;\r\n+        case '-': // DECGNL - Graphics Next Line\r\n+            _applyPendingCommand();\r\n+            _executeNextLine();\r\n+            break;\r\n+        case '+': // Undocumented home command (VT240 only)\r\n+            if (_conformanceLevel == 2)\r\n+            {\r\n+                _applyPendingCommand();\r\n+                _executeMoveToHome();\r\n+            }\r\n+            break;\r\n+        case '\"': // DECGRA - Set Raster Attributes\r\n+            if (_conformanceLevel >= 3)\r\n+            {\r\n+                _applyPendingCommand();\r\n+                _state = States::Attributes;\r\n+                _parameters.clear();\r\n+            }\r\n+            break;\r\n+        case AsciiChars::ESC: // End of image sequence\r\n+            // At this point we only care about pending color changes. Raster\r\n+            // attributes have no effect at the end of a sequence, and a repeat\r\n+            // command is only applicable when followed by a sixel value.\r\n+            if (_state == States::Color)\r\n+            {\r\n+                _applyPendingCommand();\r\n+            }\r\n+            _fillImageBackground();\r\n+            _executeCarriageReturn();\r\n+            _maybeFlushImageBuffer(true);\r\n+            break;\r\n+        default:\r\n+            break;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_parseParameterChar(const wchar_t ch)\r\n+{\r\n+    // The most any command requires is 5 parameters (for the color command),\r\n+    // so anything after that can be ignored.\r\n+    if (_parameters.size() <= 5)\r\n+    {\r\n+        if (_parameters.empty())\r\n+        {\r\n+            _parameters.push_back({});\r\n+        }\r\n+\r\n+        if (ch == ';')\r\n+        {\r\n+            _parameters.push_back({});\r\n+        }\r\n+        else\r\n+        {\r\n+            const VTInt digit = ch - L'0';\r\n+            auto currentValue = _parameters.back().value_or(0);\r\n+            currentValue = currentValue * 10 + digit;\r\n+            _parameters.back() = std::min(currentValue, MAX_PARAMETER_VALUE);\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+int SixelParser::_applyPendingCommand()\r\n+{\r\n+    if (_state != States::Normal) [[unlikely]]\r\n+    {\r\n+        const auto previousState = _state;\r\n+        _state = States::Normal;\r\n+        switch (previousState)\r\n+        {\r\n+        case States::Color:\r\n+            _defineColor({ _parameters.data(), _parameters.size() });\r\n+            return 1;\r\n+        case States::Repeat:\r\n+            return VTParameters{ _parameters.data(), _parameters.size() }.at(0);\r\n+        case States::Attributes:\r\n+            _updateRasterAttributes({ _parameters.data(), _parameters.size() });\r\n+            return 1;\r\n+        }\r\n+    }\r\n+    return 1;\r\n+}\r\n+\r\n+void SixelParser::_executeCarriageReturn() noexcept\r\n+{\r\n+    _imageWidth = std::max(_imageWidth, _imageCursor.x);\r\n+    _imageCursor.x = 0;\r\n+}\r\n+\r\n+void SixelParser::_executeNextLine()\r\n+{\r\n+    _executeCarriageReturn();\r\n+    _imageLineCount++;\r\n+    _maybeFlushImageBuffer();\r\n+    _imageCursor.y += _sixelHeight;\r\n+    _availablePixelHeight -= _sixelHeight;\r\n+    _resizeImageBuffer(_sixelHeight);\r\n+}\r\n+\r\n+void SixelParser::_executeMoveToHome()\r\n+{\r\n+    _executeCarriageReturn();\r\n+    _maybeFlushImageBuffer();\r\n+    _imageCursor.y = 0;\r\n+    _availablePixelHeight = _textMargins.height() * _cellSize.height;\r\n+}\r\n+\r\n+bool SixelParser::_initTextBufferBoundaries()\r\n+{\r\n+    const auto page = _dispatcher._pages.ActivePage();\r\n+    auto validOrigin = true;\r\n+    if (_displayMode)\r\n+    {\r\n+        // When display mode is set, we can write to the full extent of the page\r\n+        // and the starting cursor position is the top left of the page.\r\n+        _textMargins = { 0, page.Top(), page.Width(), page.Bottom() };\r\n+        _textCursor = _textMargins.origin();\r\n+        _availablePixelWidth = page.Width() * _cellSize.width;\r\n+        _availablePixelHeight = page.Height() * _cellSize.height;\r\n+    }\r\n+    else\r\n+    {\r\n+        // When display mode is reset, we're constrained by the text margins,\r\n+        // and the starting position is the current cursor position. This must\r\n+        // be inside the horizontal margins and above the bottom margin, else\r\n+        // nothing will be rendered.\r\n+        const auto [topMargin, bottomMargin] = _dispatcher._GetVerticalMargins(page, true);\r\n+        const auto [leftMargin, rightMargin] = _dispatcher._GetHorizontalMargins(page.Width());\r\n+        _textMargins = til::rect{ leftMargin, topMargin, rightMargin + 1, bottomMargin + 1 };\r\n+        _textCursor = page.Cursor().GetPosition();\r\n+        _availablePixelWidth = (_textMargins.right - _textCursor.x) * _cellSize.width;\r\n+        _availablePixelHeight = (_textMargins.bottom - _textCursor.y) * _cellSize.height;\r\n+        validOrigin = _textCursor.x >= leftMargin && _textCursor.x <= rightMargin && _textCursor.y <= bottomMargin;\r\n+    }\r\n+    _pendingTextScrollCount = 0;\r\n+\r\n+    // The pixel aspect ratio can't be so large that it would prevent a sixel\r\n+    // row from fitting within the margin height, so we need to have a limit.\r\n+    _maxPixelAspectRatio = _textMargins.height() * _cellSize.height / 6;\r\n+\r\n+    // If the cursor is visible, we need to hide it while the sixel data is\r\n+    // being processed. It will be made visible again when we're done.\r\n+    _textCursorWasVisible = page.Cursor().IsVisible();\r\n+    if (_textCursorWasVisible && validOrigin)\r\n+    {\r\n+        page.Cursor().SetIsVisible(false);\r\n+    }\r\n+    return validOrigin;\r\n+}\r\n+\r\n+void SixelParser::_initRasterAttributes(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect) noexcept\r\n+{\r\n+    if (_conformanceLevel < 3)\r\n+    {\r\n+        // Prior to the VT340, the pixel aspect ratio was fixed at 2:1.\r\n+        _pixelAspectRatio = 2;\r\n+    }\r\n+    else\r\n+    {\r\n+        // The macro parameter was originally used on printers to define the\r\n+        // pixel aspect ratio and the grid size (the distance between pixels).\r\n+        // On graphic terminals, though, it's only used for the aspect ratio,\r\n+        // and then only a limited set of ratios are supported.\r\n+        switch (macroParameter)\r\n+        {\r\n+        case 0:\r\n+        case 1:\r\n+        case 5:\r\n+        case 6:\r\n+            _pixelAspectRatio = 2;\r\n+            break;\r\n+        case 2:\r\n+            _pixelAspectRatio = 5;\r\n+            break;\r\n+        case 3:\r\n+        case 4:\r\n+            _pixelAspectRatio = 3;\r\n+            break;\r\n+        case 7:\r\n+        case 8:\r\n+        case 9:\r\n+        default:\r\n+            // While the default aspect ratio is defined as 2:1, macro parameter\r\n+            // values outside the defined range of 0 to 9 should map to 1:1.\r\n+            _pixelAspectRatio = 1;\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    // The height of a sixel row is 6 virtual pixels, but if the aspect ratio is\r\n+    // greater than one, the height in device pixels is a multiple of that.\r\n+    _sixelHeight = 6 * _pixelAspectRatio;\r\n+    _segmentHeight = _sixelHeight;\r\n+\r\n+    // On the VT125, the background was always drawn, but for other terminals it\r\n+    // depends on the value of the background select parameter.\r\n+    const auto transparent = (backgroundSelect == DispatchTypes::SixelBackground::Transparent);\r\n+    _backgroundFillRequired = (_conformanceLevel == 1 || !transparent);\r\n+\r\n+    // By default, the filled area will cover the maximum extent allowed.\r\n+    _backgroundSize = { til::CoordTypeMax, til::CoordTypeMax };\r\n+}\r\n+\r\n+void SixelParser::_updateRasterAttributes(const VTParameters& rasterAttributes)\r\n+{\r\n+    // The documentation says default values should be interpreted as 1, but\r\n+    // the original VT340 hardware interprets omitted parameters as 0, and if\r\n+    // the x aspect is 0 (implying division by zero), the update is ignored.\r\n+    const auto yAspect = rasterAttributes.at(0).value_or(0);\r\n+    const auto xAspect = rasterAttributes.at(1).value_or(0);\r\n+    if (xAspect > 0)\r\n+    {\r\n+        // The documentation suggests the aspect ratio is rounded to the nearest\r\n+        // integer, but on the original VT340 hardware it was rounded up.\r\n+        _pixelAspectRatio = std::clamp(static_cast<int>(std::ceil(yAspect * 1.0 / xAspect)), 1, _maxPixelAspectRatio);\r\n+        _sixelHeight = 6 * _pixelAspectRatio;\r\n+        // When the sixel height is changed multiple times in a row, the segment\r\n+        // height has to track the maximum of all the sixel heights used.\r\n+        _segmentHeight = std::max(_segmentHeight, _sixelHeight);\r\n+        _resizeImageBuffer(_sixelHeight);\r\n+    }\r\n+\r\n+    // Although it's not clear from the documentation, we know from testing on\r\n+    // a VT340 that the background dimensions are measured in device pixels, so\r\n+    // the given height does not need to be scaled by the pixel aspect ratio.\r\n+    const auto width = rasterAttributes.at(2).value_or(0);\r\n+    const auto height = rasterAttributes.at(3).value_or(0);\r\n+\r\n+    // If these values are omitted or 0, they default to what they were before,\r\n+    // which typically would mean filling the whole screen, but could also fall\r\n+    // back to the dimensions from an earlier raster attributes command.\r\n+    _backgroundSize.width = width > 0 ? width : _backgroundSize.width;\r\n+    _backgroundSize.height = height > 0 ? height : _backgroundSize.height;\r\n+}\r\n+\r\n+void SixelParser::_scrollTextBuffer(Page& page, const int scrollAmount)\r\n+{\r\n+    // We scroll the text buffer by moving the cursor to the bottom of the\r\n+    // margin area and executing an appropriate number of line feeds.\r\n+    if (_textCursor.y != _textMargins.bottom - 1)\r\n+    {\r\n+        _textCursor = { _textCursor.x, _textMargins.bottom - 1 };\r\n+        page.Cursor().SetPosition(_textCursor);\r\n+    }\r\n+    auto panAmount = 0;\r\n+    for (auto i = 0; i < scrollAmount; i++)\r\n+    {\r\n+        if (_dispatcher._DoLineFeed(page, false, false))\r\n+        {\r\n+            page.MoveViewportDown();\r\n+            panAmount++;\r\n+        }\r\n+    }\r\n+\r\n+    // If the line feeds panned the viewport down, we need to adjust our margins\r\n+    // and text cursor coordinates to align with that movement.\r\n+    _textCursor.y += panAmount;\r\n+    _textMargins += til::point{ 0, panAmount };\r\n+\r\n+    // And if it wasn't all panning, we need to move the image origin up to\r\n+    // match the number of rows that were actually scrolled.\r\n+    if (scrollAmount > panAmount)\r\n+    {\r\n+        auto expectedMovement = scrollAmount - panAmount;\r\n+        // If constrained by margins, we can only move as far as the top margin.\r\n+        if (_textMargins.top > page.Top() || _textMargins.left > 0 || _textMargins.right < page.Width() - 1)\r\n+        {\r\n+            const auto availableSpace = std::max(_imageOriginCell.y - _textMargins.top, 0);\r\n+            if (expectedMovement > availableSpace)\r\n+            {\r\n+                // Anything more than that will need to be erased from the\r\n+                // image. And if the origin was already above the top margin,\r\n+                // this erased segment will be partway through the image.\r\n+                const auto eraseRowCount = expectedMovement - availableSpace;\r\n+                const auto eraseOffset = std::max(_textMargins.top - _imageOriginCell.y, 0);\r\n+                _eraseImageBufferRows(eraseRowCount, eraseOffset);\r\n+                // But if there was any available space, we still then need to\r\n+                // move the origin up as far as it can go.\r\n+                expectedMovement = availableSpace;\r\n+            }\r\n+        }\r\n+        _imageOriginCell.y -= expectedMovement;\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_updateTextCursor(Cursor& cursor) noexcept\r\n+{\r\n+    // Unless the sixel display mode is set, we need to update the text cursor\r\n+    // position to align with the final image cursor position. This should be\r\n+    // the cell which is intersected by the top of the final sixel row.\r\n+    if (!_displayMode)\r\n+    {\r\n+        const auto finalRow = _imageOriginCell.y + _imageCursor.y / _cellSize.height;\r\n+        if (finalRow != _textCursor.y)\r\n+        {\r\n+            cursor.SetPosition({ _textCursor.x, finalRow });\r\n+        }\r\n+    }\r\n+    // And if the cursor was visible when we started, we need to restore it.\r\n+    if (_textCursorWasVisible)\r\n+    {\r\n+        cursor.SetIsVisible(true);\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_initColorMap(const VTParameter backgroundColor)\r\n+{\r\n+    _colorsUsed = 0;\r\n+    _colorsAvailable = _maxColors;\r\n+    _colorTableChanged = false;\r\n+\r\n+    // The color numbers in a sixel image don't necessarily map directly to\r\n+    // entries in the color table. That mapping is determined by the order in\r\n+    // which the colors are defined. If they aren't defined, though, the default\r\n+    // mapping is just the color number modulo the color table size.\r\n+    for (size_t colorNumber = 0; colorNumber < _colorMap.size(); colorNumber++)\r\n+    {\r\n+        _colorMap.at(colorNumber) = colorNumber % _maxColors;\r\n+    }\r\n+\r\n+    // The _colorMapUsed field keeps track of the color numbers that have been\r\n+    // explicitly mapped to a color table entry, since that locks in the mapping\r\n+    // for the duration of the image. Additional definitions for that color\r\n+    // number will update the existing mapped table entry - they won't generate\r\n+    // new mappings for the number.\r\n+    std::fill(_colorMapUsed.begin(), _colorMapUsed.end(), false);\r\n+\r\n+    // The VT240 has an extra feature, whereby the P3 parameter defines the\r\n+    // color number to be used for the background (i.e. it's preassigned to\r\n+    // table entry 0). If you specify a value larger than the maximum color\r\n+    // table index, the number of available colors is reduced by 1, which\r\n+    // effectively protects the background color from modification.\r\n+    if (_conformanceLevel == 2 && backgroundColor.has_value()) [[unlikely]]\r\n+    {\r\n+        const size_t colorNumber = backgroundColor.value();\r\n+        if (colorNumber < _maxColors)\r\n+        {\r\n+            til::at(_colorMap, colorNumber) = 0;\r\n+            til::at(_colorMapUsed, colorNumber) = true;\r\n+        }\r\n+        else\r\n+        {\r\n+            _colorsAvailable = _maxColors - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // On the original hardware terminals, the default color index would have\r\n+    // been the last entry in the color table. But on modern terminals, it is\r\n+    // typically capped at 15 for compatibility with the 16-color VT340. This\r\n+    // is the color used if no color commands are received.\r\n+    const auto defaultColorIndex = std::min<size_t>(_maxColors - 1, 15);\r\n+    _foregroundPixel = { .colorIndex = gsl::narrow_cast<IndexType>(defaultColorIndex) };\r\n+}\r\n+\r\n+void SixelParser::_defineColor(const VTParameters& colorParameters)\r\n+{\r\n+    // The first parameter selects the color number to use. If it's greater than\r\n+    // the color map size, we just mod the value into range.\r\n+    const auto colorNumber = colorParameters.at(0).value_or(0) % _colorMap.size();\r\n+\r\n+    // If there are additional parameters, then this command will also redefine\r\n+    // the color palette associated with the selected color number. This is not\r\n+    // supported on the VT125 though.\r\n+    if (colorParameters.size() > 1 && _conformanceLevel > 1) [[unlikely]]\r\n+    {\r\n+        const auto model = DispatchTypes::ColorModel{ colorParameters.at(1) };\r\n+        const auto x = colorParameters.at(2).value_or(0);\r\n+        const auto y = colorParameters.at(3).value_or(0);\r\n+        const auto z = colorParameters.at(4).value_or(0);\r\n+        switch (model)\r\n+        {\r\n+        case DispatchTypes::ColorModel::HLS:\r\n+            _defineColor(colorNumber, Utils::ColorFromHLS(x, y, z));\r\n+            break;\r\n+        case DispatchTypes::ColorModel::RGB:\r\n+            _defineColor(colorNumber, Utils::ColorFromRGB100(x, y, z));\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    // The actual color table index we use is derived from the color number via\r\n+    // the color map. This is initially defined in _initColorMap above, but may\r\n+    // be altered when colors are set in the _defineColor method below.\r\n+    const auto colorIndex = _colorMap.at(colorNumber);\r\n+    _foregroundPixel = { .colorIndex = gsl::narrow_cast<IndexType>(colorIndex) };\r\n+}\r\n+\r\n+void SixelParser::_defineColor(const size_t colorNumber, const COLORREF color)\r\n+{\r\n+    if (til::at(_colorMapUsed, colorNumber))\r\n+    {\r\n+        // If the color is already assigned, we update the mapped table entry.\r\n+        const auto tableIndex = til::at(_colorMap, colorNumber);\r\n+        til::at(_colorTable, tableIndex) = color;\r\n+        _colorTableChanged = true;\r\n+        // If some image content has already been defined at this point, and\r\n+        // we're processing the last character in the packet, this is likely an\r\n+        // attempt to animate the palette, so we should flush the image.\r\n+        if (_imageWidth > 0 && _stateMachine.IsProcessingLastCharacter())\r\n+        {\r\n+            _maybeFlushImageBuffer();\r\n+        }\r\n+    }\r\n+    else\r\n+    {\r\n+        // Otherwise assign it to the next available color table entry.\r\n+        if (_colorsUsed < _colorsAvailable)\r\n+        {\r\n+            // Since table entry 0 is the background color, which you typically\r\n+            // want to leave unchanged, the original hardware terminals would\r\n+            // skip that and start with table entry 1, and only wrap back to 0\r\n+            // when all others had been used.\r\n+            const auto tableIndex = ++_colorsUsed % _maxColors;\r\n+            til::at(_colorMap, colorNumber) = tableIndex;\r\n+            til::at(_colorTable, tableIndex) = color;\r\n+            _colorTableChanged = true;\r\n+        }\r\n+        else if (_conformanceLevel == 2)\r\n+        {\r\n+            // If we've used up all the available color table entries, we have\r\n+            // to assign this color number to one of the previously used ones.\r\n+            // The VT240 uses the closest match from the existing color entries,\r\n+            // but the VT340 just uses the default mapping assigned at the start\r\n+            // (i.e. the color number modulo the color table size).\r\n+            size_t tableIndex = 0;\r\n+            int bestDiff = 99999;\r\n+            for (size_t i = 0; i < _maxColors; i++)\r\n+            {\r\n+                const auto existingColor = til::at(_colorTable, i);\r\n+                const auto diff = [](const auto c1, const auto c2) noexcept {\r\n+                    return std::abs(static_cast<int>(c1) - static_cast<int>(c2));\r\n+                };\r\n+                const auto redDiff = diff(GetRValue(existingColor), GetRValue(color));\r\n+                const auto greenDiff = diff(GetGValue(existingColor), GetGValue(color));\r\n+                const auto blueDiff = diff(GetBValue(existingColor), GetBValue(color));\r\n+                const auto totalDiff = redDiff + greenDiff + blueDiff;\r",
        "comment_created_at": "2024-06-28T15:45:09+00:00",
        "comment_author": "lhecker",
        "comment_body": "Since RGB is a cube, I think it makes more sense to calculate the squared distance `r * r + g * g + b * b`. That also removes the need for `abs`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1660027848",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 17421,
        "pr_file": "src/terminal/adapter/SixelParser.cpp",
        "discussion_id": "1658940967",
        "commented_code": "@@ -0,0 +1,840 @@\n+// Copyright (c) Microsoft Corporation.\r\n+// Licensed under the MIT license.\r\n+\r\n+#include \"precomp.h\"\r\n+\r\n+#include \"SixelParser.hpp\"\r\n+#include \"adaptDispatch.hpp\"\r\n+#include \"../buffer/out/ImageSlice.hpp\"\r\n+#include \"../parser/ascii.hpp\"\r\n+#include \"../renderer/base/renderer.hpp\"\r\n+#include \"../types/inc/colorTable.hpp\"\r\n+#include \"../types/inc/utils.hpp\"\r\n+\r\n+using namespace Microsoft::Console::Types;\r\n+using namespace Microsoft::Console::Utils;\r\n+using namespace Microsoft::Console::VirtualTerminal;\r\n+using namespace std::chrono;\r\n+using namespace std::chrono_literals;\r\n+\r\n+til::size SixelParser::CellSizeForLevel(const VTInt conformanceLevel) noexcept\r\n+{\r\n+    switch (conformanceLevel)\r\n+    {\r\n+    case 1: // Compatible with the VT125\r\n+        return { 9, 20 };\r\n+    default: // Compatible with the VT240 and VT340\r\n+        return { 10, 20 };\r\n+    }\r\n+}\r\n+\r\n+size_t SixelParser::MaxColorsForLevel(const VTInt conformanceLevel) noexcept\r\n+{\r\n+    switch (conformanceLevel)\r\n+    {\r\n+    case 1:\r\n+    case 2: // Compatible with the 4-color VT125 and VT240\r\n+        return 4;\r\n+    case 3: // Compatible with the 16-color VT340\r\n+        return 16;\r\n+    default: // Modern sixel apps often require 256 colors.\r\n+        return MAX_COLORS;\r\n+    }\r\n+}\r\n+\r\n+SixelParser::SixelParser(AdaptDispatch& dispatcher, const StateMachine& stateMachine, const VTInt conformanceLevel) noexcept :\r\n+    _dispatcher{ dispatcher },\r\n+    _stateMachine{ stateMachine },\r\n+    _conformanceLevel{ conformanceLevel },\r\n+    _cellSize{ CellSizeForLevel(conformanceLevel) },\r\n+    _maxColors{ MaxColorsForLevel(conformanceLevel) }\r\n+{\r\n+    // We initialize the first 16 color entries with the VT340 palette, which is\r\n+    // also compatible with the 4-color VT125 and VT240. The remaining entries\r\n+    // are initialized with the XTerm extended colors.\r\n+    Microsoft::Console::Utils::InitializeVT340ColorTable(_colorTable);\r\n+    Microsoft::Console::Utils::InitializeExtendedColorTable(_colorTable);\r\n+}\r\n+\r\n+void SixelParser::SoftReset()\r\n+{\r\n+    // The VT240 is the only terminal known to reset colors with DECSTR.\r\n+    // We only reset the first 16, since it only needs 4 of them anyway.\r\n+    if (_conformanceLevel == 2)\r\n+    {\r\n+        Microsoft::Console::Utils::InitializeVT340ColorTable(_colorTable);\r\n+        _updateTextColors();\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::SetDisplayMode(const bool enabled) noexcept\r\n+{\r\n+    // The display mode determines whether images are clamped at the bottom of\r\n+    // the screen (the set state), or scroll when they reach the bottom of the\r\n+    // margin area (the reset state). Clamping was the only mode of operation\r\n+    // supported prior to the VT340, so we don't allow the mode to be reset on\r\n+    // levels 1 and 2.\r\n+    if (_conformanceLevel >= 3)\r\n+    {\r\n+        _displayMode = enabled;\r\n+    }\r\n+}\r\n+\r\n+std::function<bool(wchar_t)> SixelParser::DefineImage(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect, const VTParameter backgroundColor)\r\n+{\r\n+    if (_initTextBufferBoundaries())\r\n+    {\r\n+        _initRasterAttributes(macroParameter, backgroundSelect);\r\n+        _initColorMap(backgroundColor);\r\n+        _initImageBuffer();\r\n+        _state = States::Normal;\r\n+        _parameters.clear();\r\n+        return [&](const auto ch) {\r\n+            _parseCommandChar(ch);\r\n+            return true;\r\n+        };\r\n+    }\r\n+    else\r\n+    {\r\n+        return nullptr;\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_parseCommandChar(const wchar_t ch)\r\n+{\r\n+    // Characters in the range `?` to `~` encode a sixel value, which is a group\r\n+    // of six vertical pixels. After subtracting `?` from the character, you've\r\n+    // got a six bit binary value which represents the six pixels.\r\n+    if (ch >= '?' && ch <= '~') [[likely]]\r\n+    {\r\n+        // When preceded by a repeat command, the repeat parameter value denotes\r\n+        // the number of times that the following sixel should be repeated.\r\n+        const auto repeatCount = _applyPendingCommand();\r\n+        _writeToImageBuffer(ch - L'?', repeatCount);\r\n+    }\r\n+    // Characters `0` to `9` and `;` are used to represent parameter values for\r\n+    // commands that require them.\r\n+    else if ((ch >= '0' && ch <= '9') || ch == ';')\r\n+    {\r\n+        _parseParameterChar(ch);\r\n+    }\r\n+    // The remaining characters represent commands, some of which will execute\r\n+    // immediately, but some requiring additional parameter values. In the\r\n+    // latter case, the command will only be applied once the next command\r\n+    // character is received.\r\n+    else\r\n+    {\r\n+        switch (ch)\r\n+        {\r\n+        case '#': // DECGCI - Color Introducer\r\n+            _applyPendingCommand();\r\n+            _state = States::Color;\r\n+            _parameters.clear();\r\n+            break;\r\n+        case '!': // DECGRI - Repeat Introducer\r\n+            _applyPendingCommand();\r\n+            _state = States::Repeat;\r\n+            _parameters.clear();\r\n+            break;\r\n+        case '$': // DECGCR - Graphics Carriage Return\r\n+            _applyPendingCommand();\r\n+            _executeCarriageReturn();\r\n+            break;\r\n+        case '-': // DECGNL - Graphics Next Line\r\n+            _applyPendingCommand();\r\n+            _executeNextLine();\r\n+            break;\r\n+        case '+': // Undocumented home command (VT240 only)\r\n+            if (_conformanceLevel == 2)\r\n+            {\r\n+                _applyPendingCommand();\r\n+                _executeMoveToHome();\r\n+            }\r\n+            break;\r\n+        case '\"': // DECGRA - Set Raster Attributes\r\n+            if (_conformanceLevel >= 3)\r\n+            {\r\n+                _applyPendingCommand();\r\n+                _state = States::Attributes;\r\n+                _parameters.clear();\r\n+            }\r\n+            break;\r\n+        case AsciiChars::ESC: // End of image sequence\r\n+            // At this point we only care about pending color changes. Raster\r\n+            // attributes have no effect at the end of a sequence, and a repeat\r\n+            // command is only applicable when followed by a sixel value.\r\n+            if (_state == States::Color)\r\n+            {\r\n+                _applyPendingCommand();\r\n+            }\r\n+            _fillImageBackground();\r\n+            _executeCarriageReturn();\r\n+            _maybeFlushImageBuffer(true);\r\n+            break;\r\n+        default:\r\n+            break;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_parseParameterChar(const wchar_t ch)\r\n+{\r\n+    // The most any command requires is 5 parameters (for the color command),\r\n+    // so anything after that can be ignored.\r\n+    if (_parameters.size() <= 5)\r\n+    {\r\n+        if (_parameters.empty())\r\n+        {\r\n+            _parameters.push_back({});\r\n+        }\r\n+\r\n+        if (ch == ';')\r\n+        {\r\n+            _parameters.push_back({});\r\n+        }\r\n+        else\r\n+        {\r\n+            const VTInt digit = ch - L'0';\r\n+            auto currentValue = _parameters.back().value_or(0);\r\n+            currentValue = currentValue * 10 + digit;\r\n+            _parameters.back() = std::min(currentValue, MAX_PARAMETER_VALUE);\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+int SixelParser::_applyPendingCommand()\r\n+{\r\n+    if (_state != States::Normal) [[unlikely]]\r\n+    {\r\n+        const auto previousState = _state;\r\n+        _state = States::Normal;\r\n+        switch (previousState)\r\n+        {\r\n+        case States::Color:\r\n+            _defineColor({ _parameters.data(), _parameters.size() });\r\n+            return 1;\r\n+        case States::Repeat:\r\n+            return VTParameters{ _parameters.data(), _parameters.size() }.at(0);\r\n+        case States::Attributes:\r\n+            _updateRasterAttributes({ _parameters.data(), _parameters.size() });\r\n+            return 1;\r\n+        }\r\n+    }\r\n+    return 1;\r\n+}\r\n+\r\n+void SixelParser::_executeCarriageReturn() noexcept\r\n+{\r\n+    _imageWidth = std::max(_imageWidth, _imageCursor.x);\r\n+    _imageCursor.x = 0;\r\n+}\r\n+\r\n+void SixelParser::_executeNextLine()\r\n+{\r\n+    _executeCarriageReturn();\r\n+    _imageLineCount++;\r\n+    _maybeFlushImageBuffer();\r\n+    _imageCursor.y += _sixelHeight;\r\n+    _availablePixelHeight -= _sixelHeight;\r\n+    _resizeImageBuffer(_sixelHeight);\r\n+}\r\n+\r\n+void SixelParser::_executeMoveToHome()\r\n+{\r\n+    _executeCarriageReturn();\r\n+    _maybeFlushImageBuffer();\r\n+    _imageCursor.y = 0;\r\n+    _availablePixelHeight = _textMargins.height() * _cellSize.height;\r\n+}\r\n+\r\n+bool SixelParser::_initTextBufferBoundaries()\r\n+{\r\n+    const auto page = _dispatcher._pages.ActivePage();\r\n+    auto validOrigin = true;\r\n+    if (_displayMode)\r\n+    {\r\n+        // When display mode is set, we can write to the full extent of the page\r\n+        // and the starting cursor position is the top left of the page.\r\n+        _textMargins = { 0, page.Top(), page.Width(), page.Bottom() };\r\n+        _textCursor = _textMargins.origin();\r\n+        _availablePixelWidth = page.Width() * _cellSize.width;\r\n+        _availablePixelHeight = page.Height() * _cellSize.height;\r\n+    }\r\n+    else\r\n+    {\r\n+        // When display mode is reset, we're constrained by the text margins,\r\n+        // and the starting position is the current cursor position. This must\r\n+        // be inside the horizontal margins and above the bottom margin, else\r\n+        // nothing will be rendered.\r\n+        const auto [topMargin, bottomMargin] = _dispatcher._GetVerticalMargins(page, true);\r\n+        const auto [leftMargin, rightMargin] = _dispatcher._GetHorizontalMargins(page.Width());\r\n+        _textMargins = til::rect{ leftMargin, topMargin, rightMargin + 1, bottomMargin + 1 };\r\n+        _textCursor = page.Cursor().GetPosition();\r\n+        _availablePixelWidth = (_textMargins.right - _textCursor.x) * _cellSize.width;\r\n+        _availablePixelHeight = (_textMargins.bottom - _textCursor.y) * _cellSize.height;\r\n+        validOrigin = _textCursor.x >= leftMargin && _textCursor.x <= rightMargin && _textCursor.y <= bottomMargin;\r\n+    }\r\n+    _pendingTextScrollCount = 0;\r\n+\r\n+    // The pixel aspect ratio can't be so large that it would prevent a sixel\r\n+    // row from fitting within the margin height, so we need to have a limit.\r\n+    _maxPixelAspectRatio = _textMargins.height() * _cellSize.height / 6;\r\n+\r\n+    // If the cursor is visible, we need to hide it while the sixel data is\r\n+    // being processed. It will be made visible again when we're done.\r\n+    _textCursorWasVisible = page.Cursor().IsVisible();\r\n+    if (_textCursorWasVisible && validOrigin)\r\n+    {\r\n+        page.Cursor().SetIsVisible(false);\r\n+    }\r\n+    return validOrigin;\r\n+}\r\n+\r\n+void SixelParser::_initRasterAttributes(const VTInt macroParameter, const DispatchTypes::SixelBackground backgroundSelect) noexcept\r\n+{\r\n+    if (_conformanceLevel < 3)\r\n+    {\r\n+        // Prior to the VT340, the pixel aspect ratio was fixed at 2:1.\r\n+        _pixelAspectRatio = 2;\r\n+    }\r\n+    else\r\n+    {\r\n+        // The macro parameter was originally used on printers to define the\r\n+        // pixel aspect ratio and the grid size (the distance between pixels).\r\n+        // On graphic terminals, though, it's only used for the aspect ratio,\r\n+        // and then only a limited set of ratios are supported.\r\n+        switch (macroParameter)\r\n+        {\r\n+        case 0:\r\n+        case 1:\r\n+        case 5:\r\n+        case 6:\r\n+            _pixelAspectRatio = 2;\r\n+            break;\r\n+        case 2:\r\n+            _pixelAspectRatio = 5;\r\n+            break;\r\n+        case 3:\r\n+        case 4:\r\n+            _pixelAspectRatio = 3;\r\n+            break;\r\n+        case 7:\r\n+        case 8:\r\n+        case 9:\r\n+        default:\r\n+            // While the default aspect ratio is defined as 2:1, macro parameter\r\n+            // values outside the defined range of 0 to 9 should map to 1:1.\r\n+            _pixelAspectRatio = 1;\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    // The height of a sixel row is 6 virtual pixels, but if the aspect ratio is\r\n+    // greater than one, the height in device pixels is a multiple of that.\r\n+    _sixelHeight = 6 * _pixelAspectRatio;\r\n+    _segmentHeight = _sixelHeight;\r\n+\r\n+    // On the VT125, the background was always drawn, but for other terminals it\r\n+    // depends on the value of the background select parameter.\r\n+    const auto transparent = (backgroundSelect == DispatchTypes::SixelBackground::Transparent);\r\n+    _backgroundFillRequired = (_conformanceLevel == 1 || !transparent);\r\n+\r\n+    // By default, the filled area will cover the maximum extent allowed.\r\n+    _backgroundSize = { til::CoordTypeMax, til::CoordTypeMax };\r\n+}\r\n+\r\n+void SixelParser::_updateRasterAttributes(const VTParameters& rasterAttributes)\r\n+{\r\n+    // The documentation says default values should be interpreted as 1, but\r\n+    // the original VT340 hardware interprets omitted parameters as 0, and if\r\n+    // the x aspect is 0 (implying division by zero), the update is ignored.\r\n+    const auto yAspect = rasterAttributes.at(0).value_or(0);\r\n+    const auto xAspect = rasterAttributes.at(1).value_or(0);\r\n+    if (xAspect > 0)\r\n+    {\r\n+        // The documentation suggests the aspect ratio is rounded to the nearest\r\n+        // integer, but on the original VT340 hardware it was rounded up.\r\n+        _pixelAspectRatio = std::clamp(static_cast<int>(std::ceil(yAspect * 1.0 / xAspect)), 1, _maxPixelAspectRatio);\r\n+        _sixelHeight = 6 * _pixelAspectRatio;\r\n+        // When the sixel height is changed multiple times in a row, the segment\r\n+        // height has to track the maximum of all the sixel heights used.\r\n+        _segmentHeight = std::max(_segmentHeight, _sixelHeight);\r\n+        _resizeImageBuffer(_sixelHeight);\r\n+    }\r\n+\r\n+    // Although it's not clear from the documentation, we know from testing on\r\n+    // a VT340 that the background dimensions are measured in device pixels, so\r\n+    // the given height does not need to be scaled by the pixel aspect ratio.\r\n+    const auto width = rasterAttributes.at(2).value_or(0);\r\n+    const auto height = rasterAttributes.at(3).value_or(0);\r\n+\r\n+    // If these values are omitted or 0, they default to what they were before,\r\n+    // which typically would mean filling the whole screen, but could also fall\r\n+    // back to the dimensions from an earlier raster attributes command.\r\n+    _backgroundSize.width = width > 0 ? width : _backgroundSize.width;\r\n+    _backgroundSize.height = height > 0 ? height : _backgroundSize.height;\r\n+}\r\n+\r\n+void SixelParser::_scrollTextBuffer(Page& page, const int scrollAmount)\r\n+{\r\n+    // We scroll the text buffer by moving the cursor to the bottom of the\r\n+    // margin area and executing an appropriate number of line feeds.\r\n+    if (_textCursor.y != _textMargins.bottom - 1)\r\n+    {\r\n+        _textCursor = { _textCursor.x, _textMargins.bottom - 1 };\r\n+        page.Cursor().SetPosition(_textCursor);\r\n+    }\r\n+    auto panAmount = 0;\r\n+    for (auto i = 0; i < scrollAmount; i++)\r\n+    {\r\n+        if (_dispatcher._DoLineFeed(page, false, false))\r\n+        {\r\n+            page.MoveViewportDown();\r\n+            panAmount++;\r\n+        }\r\n+    }\r\n+\r\n+    // If the line feeds panned the viewport down, we need to adjust our margins\r\n+    // and text cursor coordinates to align with that movement.\r\n+    _textCursor.y += panAmount;\r\n+    _textMargins += til::point{ 0, panAmount };\r\n+\r\n+    // And if it wasn't all panning, we need to move the image origin up to\r\n+    // match the number of rows that were actually scrolled.\r\n+    if (scrollAmount > panAmount)\r\n+    {\r\n+        auto expectedMovement = scrollAmount - panAmount;\r\n+        // If constrained by margins, we can only move as far as the top margin.\r\n+        if (_textMargins.top > page.Top() || _textMargins.left > 0 || _textMargins.right < page.Width() - 1)\r\n+        {\r\n+            const auto availableSpace = std::max(_imageOriginCell.y - _textMargins.top, 0);\r\n+            if (expectedMovement > availableSpace)\r\n+            {\r\n+                // Anything more than that will need to be erased from the\r\n+                // image. And if the origin was already above the top margin,\r\n+                // this erased segment will be partway through the image.\r\n+                const auto eraseRowCount = expectedMovement - availableSpace;\r\n+                const auto eraseOffset = std::max(_textMargins.top - _imageOriginCell.y, 0);\r\n+                _eraseImageBufferRows(eraseRowCount, eraseOffset);\r\n+                // But if there was any available space, we still then need to\r\n+                // move the origin up as far as it can go.\r\n+                expectedMovement = availableSpace;\r\n+            }\r\n+        }\r\n+        _imageOriginCell.y -= expectedMovement;\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_updateTextCursor(Cursor& cursor) noexcept\r\n+{\r\n+    // Unless the sixel display mode is set, we need to update the text cursor\r\n+    // position to align with the final image cursor position. This should be\r\n+    // the cell which is intersected by the top of the final sixel row.\r\n+    if (!_displayMode)\r\n+    {\r\n+        const auto finalRow = _imageOriginCell.y + _imageCursor.y / _cellSize.height;\r\n+        if (finalRow != _textCursor.y)\r\n+        {\r\n+            cursor.SetPosition({ _textCursor.x, finalRow });\r\n+        }\r\n+    }\r\n+    // And if the cursor was visible when we started, we need to restore it.\r\n+    if (_textCursorWasVisible)\r\n+    {\r\n+        cursor.SetIsVisible(true);\r\n+    }\r\n+}\r\n+\r\n+void SixelParser::_initColorMap(const VTParameter backgroundColor)\r\n+{\r\n+    _colorsUsed = 0;\r\n+    _colorsAvailable = _maxColors;\r\n+    _colorTableChanged = false;\r\n+\r\n+    // The color numbers in a sixel image don't necessarily map directly to\r\n+    // entries in the color table. That mapping is determined by the order in\r\n+    // which the colors are defined. If they aren't defined, though, the default\r\n+    // mapping is just the color number modulo the color table size.\r\n+    for (size_t colorNumber = 0; colorNumber < _colorMap.size(); colorNumber++)\r\n+    {\r\n+        _colorMap.at(colorNumber) = colorNumber % _maxColors;\r\n+    }\r\n+\r\n+    // The _colorMapUsed field keeps track of the color numbers that have been\r\n+    // explicitly mapped to a color table entry, since that locks in the mapping\r\n+    // for the duration of the image. Additional definitions for that color\r\n+    // number will update the existing mapped table entry - they won't generate\r\n+    // new mappings for the number.\r\n+    std::fill(_colorMapUsed.begin(), _colorMapUsed.end(), false);\r\n+\r\n+    // The VT240 has an extra feature, whereby the P3 parameter defines the\r\n+    // color number to be used for the background (i.e. it's preassigned to\r\n+    // table entry 0). If you specify a value larger than the maximum color\r\n+    // table index, the number of available colors is reduced by 1, which\r\n+    // effectively protects the background color from modification.\r\n+    if (_conformanceLevel == 2 && backgroundColor.has_value()) [[unlikely]]\r\n+    {\r\n+        const size_t colorNumber = backgroundColor.value();\r\n+        if (colorNumber < _maxColors)\r\n+        {\r\n+            til::at(_colorMap, colorNumber) = 0;\r\n+            til::at(_colorMapUsed, colorNumber) = true;\r\n+        }\r\n+        else\r\n+        {\r\n+            _colorsAvailable = _maxColors - 1;\r\n+        }\r\n+    }\r\n+\r\n+    // On the original hardware terminals, the default color index would have\r\n+    // been the last entry in the color table. But on modern terminals, it is\r\n+    // typically capped at 15 for compatibility with the 16-color VT340. This\r\n+    // is the color used if no color commands are received.\r\n+    const auto defaultColorIndex = std::min<size_t>(_maxColors - 1, 15);\r\n+    _foregroundPixel = { .colorIndex = gsl::narrow_cast<IndexType>(defaultColorIndex) };\r\n+}\r\n+\r\n+void SixelParser::_defineColor(const VTParameters& colorParameters)\r\n+{\r\n+    // The first parameter selects the color number to use. If it's greater than\r\n+    // the color map size, we just mod the value into range.\r\n+    const auto colorNumber = colorParameters.at(0).value_or(0) % _colorMap.size();\r\n+\r\n+    // If there are additional parameters, then this command will also redefine\r\n+    // the color palette associated with the selected color number. This is not\r\n+    // supported on the VT125 though.\r\n+    if (colorParameters.size() > 1 && _conformanceLevel > 1) [[unlikely]]\r\n+    {\r\n+        const auto model = DispatchTypes::ColorModel{ colorParameters.at(1) };\r\n+        const auto x = colorParameters.at(2).value_or(0);\r\n+        const auto y = colorParameters.at(3).value_or(0);\r\n+        const auto z = colorParameters.at(4).value_or(0);\r\n+        switch (model)\r\n+        {\r\n+        case DispatchTypes::ColorModel::HLS:\r\n+            _defineColor(colorNumber, Utils::ColorFromHLS(x, y, z));\r\n+            break;\r\n+        case DispatchTypes::ColorModel::RGB:\r\n+            _defineColor(colorNumber, Utils::ColorFromRGB100(x, y, z));\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    // The actual color table index we use is derived from the color number via\r\n+    // the color map. This is initially defined in _initColorMap above, but may\r\n+    // be altered when colors are set in the _defineColor method below.\r\n+    const auto colorIndex = _colorMap.at(colorNumber);\r\n+    _foregroundPixel = { .colorIndex = gsl::narrow_cast<IndexType>(colorIndex) };\r\n+}\r\n+\r\n+void SixelParser::_defineColor(const size_t colorNumber, const COLORREF color)\r\n+{\r\n+    if (til::at(_colorMapUsed, colorNumber))\r\n+    {\r\n+        // If the color is already assigned, we update the mapped table entry.\r\n+        const auto tableIndex = til::at(_colorMap, colorNumber);\r\n+        til::at(_colorTable, tableIndex) = color;\r\n+        _colorTableChanged = true;\r\n+        // If some image content has already been defined at this point, and\r\n+        // we're processing the last character in the packet, this is likely an\r\n+        // attempt to animate the palette, so we should flush the image.\r\n+        if (_imageWidth > 0 && _stateMachine.IsProcessingLastCharacter())\r\n+        {\r\n+            _maybeFlushImageBuffer();\r\n+        }\r\n+    }\r\n+    else\r\n+    {\r\n+        // Otherwise assign it to the next available color table entry.\r\n+        if (_colorsUsed < _colorsAvailable)\r\n+        {\r\n+            // Since table entry 0 is the background color, which you typically\r\n+            // want to leave unchanged, the original hardware terminals would\r\n+            // skip that and start with table entry 1, and only wrap back to 0\r\n+            // when all others had been used.\r\n+            const auto tableIndex = ++_colorsUsed % _maxColors;\r\n+            til::at(_colorMap, colorNumber) = tableIndex;\r\n+            til::at(_colorTable, tableIndex) = color;\r\n+            _colorTableChanged = true;\r\n+        }\r\n+        else if (_conformanceLevel == 2)\r\n+        {\r\n+            // If we've used up all the available color table entries, we have\r\n+            // to assign this color number to one of the previously used ones.\r\n+            // The VT240 uses the closest match from the existing color entries,\r\n+            // but the VT340 just uses the default mapping assigned at the start\r\n+            // (i.e. the color number modulo the color table size).\r\n+            size_t tableIndex = 0;\r\n+            int bestDiff = 99999;\r\n+            for (size_t i = 0; i < _maxColors; i++)\r\n+            {\r\n+                const auto existingColor = til::at(_colorTable, i);\r\n+                const auto diff = [](const auto c1, const auto c2) noexcept {\r\n+                    return std::abs(static_cast<int>(c1) - static_cast<int>(c2));\r\n+                };\r\n+                const auto redDiff = diff(GetRValue(existingColor), GetRValue(color));\r\n+                const auto greenDiff = diff(GetGValue(existingColor), GetGValue(color));\r\n+                const auto blueDiff = diff(GetBValue(existingColor), GetBValue(color));\r\n+                const auto totalDiff = redDiff + greenDiff + blueDiff;\r",
        "comment_created_at": "2024-06-29T21:57:34+00:00",
        "comment_author": "j4james",
        "comment_body": "Yeah, that makes sense. Done.",
        "pr_file_module": null
      }
    ]
  }
]