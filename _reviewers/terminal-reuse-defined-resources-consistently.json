[
  {
    "discussion_id": "2101122099",
    "pr_number": 18917,
    "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.h",
    "created_at": "2025-05-21T20:35:52+00:00",
    "commented_code": "#pragma once\r\n \r\n #include \"ActionsViewModel.g.h\"\r\n-#include \"KeyBindingViewModel.g.h\"\r\n-#include \"ModifyKeyBindingEventArgs.g.h\"\r\n+#include \"NavigateToCommandArgs.g.h\"\r\n+#include \"CommandViewModel.g.h\"\r\n+#include \"ArgWrapper.g.h\"\r\n+#include \"ActionArgsViewModel.g.h\"\r\n+#include \"KeyChordViewModel.g.h\"\r\n+#include \"ModifyKeyChordEventArgs.g.h\"\r\n #include \"Utils.h\"\r\n #include \"ViewModelHelpers.h\"\r\n \r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    struct KeyBindingViewModelComparator\r\n+    struct CommandViewModelComparator\r\n     {\r\n-        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const\r\n+        bool operator()(const Editor::CommandViewModel& lhs, const Editor::CommandViewModel& rhs) const\r\n         {\r\n-            return lhs.Name() < rhs.Name();\r\n+            return lhs.DisplayName() < rhs.DisplayName();\r\n         }\r\n     };\r\n \r\n-    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>\r\n+    struct NavigateToCommandArgs : NavigateToCommandArgsT<NavigateToCommandArgs>\r\n     {\r\n     public:\r\n-        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :\r\n+        NavigateToCommandArgs(CommandViewModel command, Editor::IHostedInWindow windowRoot) :\r\n+            _Command(command),\r\n+            _WindowRoot(windowRoot) {}\r\n+\r\n+        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }\r\n+        Editor::CommandViewModel Command() const noexcept { return _Command; }\r\n+\r\n+    private:\r\n+        Editor::IHostedInWindow _WindowRoot;\r\n+        Editor::CommandViewModel _Command{ nullptr };\r\n+    };\r\n+\r\n+    struct ModifyKeyChordEventArgs : ModifyKeyChordEventArgsT<ModifyKeyChordEventArgs>\r\n+    {\r\n+    public:\r\n+        ModifyKeyChordEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys) :\r\n             _OldKeys{ oldKeys },\r\n-            _NewKeys{ newKeys },\r\n-            _OldActionName{ std::move(oldActionName) },\r\n-            _NewActionName{ std::move(newActionName) } {}\r\n+            _NewKeys{ newKeys } {}\r\n \r\n         WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);\r\n         WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);\r\n-        WINRT_PROPERTY(hstring, OldActionName);\r\n-        WINRT_PROPERTY(hstring, NewActionName);\r\n     };\r\n \r\n-    struct KeyBindingViewModel : KeyBindingViewModelT<KeyBindingViewModel>, ViewModelHelper<KeyBindingViewModel>\r\n+    struct CommandViewModel : CommandViewModelT<CommandViewModel>, ViewModelHelper<CommandViewModel>\r\n+    {\r\n+    public:\r\n+        CommandViewModel(winrt::Microsoft::Terminal::Settings::Model::Command cmd,\r\n+                         std::vector<Control::KeyChord> keyChordList,\r\n+                         const Editor::ActionsViewModel actionsPageVM,\r\n+                         const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring DisplayName();\r\n+        winrt::hstring Name();\r\n+        void Name(const winrt::hstring& newName);\r\n+\r\n+        winrt::hstring ID();\r\n+        void ID(const winrt::hstring& newID);\r\n+\r\n+        bool IsUserAction();\r\n+\r\n+        void Edit_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> EditRequested;\r\n+\r\n+        void Delete_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> DeleteRequested;\r\n+\r\n+        void AddKeybinding_Click();\r\n+\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeNamesRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateWindowRootRequested;\r\n+\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(IInspectable, ProposedShortcutAction);\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(Editor::ActionArgsViewModel, ActionArgsVM, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<hstring>, AvailableShortcutActions, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::KeyChordViewModel>, KeyChordViewModelList, nullptr);\r\n+        WINRT_PROPERTY(bool, IsNewCommand, false);\r\n+\r\n+    private:\r\n+        winrt::Microsoft::Terminal::Settings::Model::Command _command;\r\n+        std::vector<Control::KeyChord> _keyChordList;\r\n+        weak_ref<Editor::ActionsViewModel> _actionsPageVM{ nullptr };\r\n+        void _RegisterKeyChordVMEvents(Editor::KeyChordViewModel kcVM);\r\n+        void _RegisterActionArgsVMEvents(Editor::ActionArgsViewModel actionArgsVM);\r\n+        void _ReplaceCommandWithUserCopy(bool reinitialize);\r\n+        void _CreateAndInitializeActionArgsVMHelper();\r\n+        Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring> _AvailableActionsAndNamesMap;\r\n+        std::unordered_map<winrt::hstring, Model::ShortcutAction> _NameToActionMap;\r\n+    };\r\n+\r\n+    struct ArgWrapper : ArgWrapperT<ArgWrapper>, ViewModelHelper<ArgWrapper>\r\n     {\r\n     public:\r\n-        KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-        KeyBindingViewModel(const Control::KeyChord& keys, const hstring& name, const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-\r\n-        hstring Name() const { return _CurrentAction; }\r\n-        hstring KeyChordText() const { return _KeyChordText; }\r\n-\r\n-        // UIA Text\r\n-        hstring EditButtonName() const noexcept;\r\n-        hstring CancelButtonName() const noexcept;\r\n-        hstring AcceptButtonName() const noexcept;\r\n-        hstring DeleteButtonName() const noexcept;\r\n-\r\n-        void EnterHoverMode() { IsHovered(true); };\r\n-        void ExitHoverMode() { IsHovered(false); };\r\n-        void ActionGotFocus() { IsContainerFocused(true); };\r\n-        void ActionLostFocus() { IsContainerFocused(false); };\r\n-        void EditButtonGettingFocus() { IsEditButtonFocused(true); };\r\n-        void EditButtonLosingFocus() { IsEditButtonFocused(false); };\r\n-        bool ShowEditButton() const noexcept;\r\n+        ArgWrapper(const winrt::hstring& name, const winrt::hstring& type, const bool required, const Model::ArgTag tag, const Windows::Foundation::IInspectable& value);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring Name() const noexcept { return _name; };\r\n+        winrt::hstring Type() const noexcept { return _type; };\r\n+        Model::ArgTag Tag() const noexcept { return _tag; };\r\n+        bool Required() const noexcept { return _required; };\r\n+\r\n+        // We cannot use the macro here because we need to implement additional logic for the setter\r\n+        Windows::Foundation::IInspectable EnumValue() const noexcept { return _EnumValue; };\r\n+        void EnumValue(const Windows::Foundation::IInspectable& value);\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::EnumEntry> EnumList() const noexcept { return _EnumList; };\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::FlagEntry> FlagList() const noexcept { return _FlagList; };\r\n+\r\n+        // unboxing functions\r\n+        winrt::hstring UnboxString(const Windows::Foundation::IInspectable& value);\r\n+        winrt::hstring UnboxGuid(const Windows::Foundation::IInspectable& value);\r\n+        int32_t UnboxInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        uint32_t UnboxUInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt64(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxFloat(const Windows::Foundation::IInspectable& value);\r\n+        bool UnboxBool(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<bool> UnboxBoolOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxTerminalCoreColorOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxWindowsUIColorOptional(const Windows::Foundation::IInspectable& value);\r\n+\r\n+        // bind back functions\r\n+        void StringBindBack(const winrt::hstring& newValue);\r\n+        void GuidBindBack(const winrt::hstring& newValue);\r\n+        void Int32BindBack(const double newValue);\r\n+        void Int32OptionalBindBack(const double newValue);\r\n+        void UInt32BindBack(const double newValue);\r\n+        void UInt32OptionalBindBack(const double newValue);\r\n+        void UInt64BindBack(const double newValue);\r\n+        void FloatBindBack(const double newValue);\r\n+        void BoolOptionalBindBack(const Windows::Foundation::IReference<bool> newValue);\r\n+        void TerminalCoreColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r\n+        void WindowsUIColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2101122099",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18917,
        "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.h",
        "discussion_id": "2101122099",
        "commented_code": "@@ -4,127 +4,248 @@\n #pragma once\r\n \r\n #include \"ActionsViewModel.g.h\"\r\n-#include \"KeyBindingViewModel.g.h\"\r\n-#include \"ModifyKeyBindingEventArgs.g.h\"\r\n+#include \"NavigateToCommandArgs.g.h\"\r\n+#include \"CommandViewModel.g.h\"\r\n+#include \"ArgWrapper.g.h\"\r\n+#include \"ActionArgsViewModel.g.h\"\r\n+#include \"KeyChordViewModel.g.h\"\r\n+#include \"ModifyKeyChordEventArgs.g.h\"\r\n #include \"Utils.h\"\r\n #include \"ViewModelHelpers.h\"\r\n \r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    struct KeyBindingViewModelComparator\r\n+    struct CommandViewModelComparator\r\n     {\r\n-        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const\r\n+        bool operator()(const Editor::CommandViewModel& lhs, const Editor::CommandViewModel& rhs) const\r\n         {\r\n-            return lhs.Name() < rhs.Name();\r\n+            return lhs.DisplayName() < rhs.DisplayName();\r\n         }\r\n     };\r\n \r\n-    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>\r\n+    struct NavigateToCommandArgs : NavigateToCommandArgsT<NavigateToCommandArgs>\r\n     {\r\n     public:\r\n-        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :\r\n+        NavigateToCommandArgs(CommandViewModel command, Editor::IHostedInWindow windowRoot) :\r\n+            _Command(command),\r\n+            _WindowRoot(windowRoot) {}\r\n+\r\n+        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }\r\n+        Editor::CommandViewModel Command() const noexcept { return _Command; }\r\n+\r\n+    private:\r\n+        Editor::IHostedInWindow _WindowRoot;\r\n+        Editor::CommandViewModel _Command{ nullptr };\r\n+    };\r\n+\r\n+    struct ModifyKeyChordEventArgs : ModifyKeyChordEventArgsT<ModifyKeyChordEventArgs>\r\n+    {\r\n+    public:\r\n+        ModifyKeyChordEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys) :\r\n             _OldKeys{ oldKeys },\r\n-            _NewKeys{ newKeys },\r\n-            _OldActionName{ std::move(oldActionName) },\r\n-            _NewActionName{ std::move(newActionName) } {}\r\n+            _NewKeys{ newKeys } {}\r\n \r\n         WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);\r\n         WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);\r\n-        WINRT_PROPERTY(hstring, OldActionName);\r\n-        WINRT_PROPERTY(hstring, NewActionName);\r\n     };\r\n \r\n-    struct KeyBindingViewModel : KeyBindingViewModelT<KeyBindingViewModel>, ViewModelHelper<KeyBindingViewModel>\r\n+    struct CommandViewModel : CommandViewModelT<CommandViewModel>, ViewModelHelper<CommandViewModel>\r\n+    {\r\n+    public:\r\n+        CommandViewModel(winrt::Microsoft::Terminal::Settings::Model::Command cmd,\r\n+                         std::vector<Control::KeyChord> keyChordList,\r\n+                         const Editor::ActionsViewModel actionsPageVM,\r\n+                         const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring DisplayName();\r\n+        winrt::hstring Name();\r\n+        void Name(const winrt::hstring& newName);\r\n+\r\n+        winrt::hstring ID();\r\n+        void ID(const winrt::hstring& newID);\r\n+\r\n+        bool IsUserAction();\r\n+\r\n+        void Edit_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> EditRequested;\r\n+\r\n+        void Delete_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> DeleteRequested;\r\n+\r\n+        void AddKeybinding_Click();\r\n+\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeNamesRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateWindowRootRequested;\r\n+\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(IInspectable, ProposedShortcutAction);\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(Editor::ActionArgsViewModel, ActionArgsVM, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<hstring>, AvailableShortcutActions, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::KeyChordViewModel>, KeyChordViewModelList, nullptr);\r\n+        WINRT_PROPERTY(bool, IsNewCommand, false);\r\n+\r\n+    private:\r\n+        winrt::Microsoft::Terminal::Settings::Model::Command _command;\r\n+        std::vector<Control::KeyChord> _keyChordList;\r\n+        weak_ref<Editor::ActionsViewModel> _actionsPageVM{ nullptr };\r\n+        void _RegisterKeyChordVMEvents(Editor::KeyChordViewModel kcVM);\r\n+        void _RegisterActionArgsVMEvents(Editor::ActionArgsViewModel actionArgsVM);\r\n+        void _ReplaceCommandWithUserCopy(bool reinitialize);\r\n+        void _CreateAndInitializeActionArgsVMHelper();\r\n+        Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring> _AvailableActionsAndNamesMap;\r\n+        std::unordered_map<winrt::hstring, Model::ShortcutAction> _NameToActionMap;\r\n+    };\r\n+\r\n+    struct ArgWrapper : ArgWrapperT<ArgWrapper>, ViewModelHelper<ArgWrapper>\r\n     {\r\n     public:\r\n-        KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-        KeyBindingViewModel(const Control::KeyChord& keys, const hstring& name, const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-\r\n-        hstring Name() const { return _CurrentAction; }\r\n-        hstring KeyChordText() const { return _KeyChordText; }\r\n-\r\n-        // UIA Text\r\n-        hstring EditButtonName() const noexcept;\r\n-        hstring CancelButtonName() const noexcept;\r\n-        hstring AcceptButtonName() const noexcept;\r\n-        hstring DeleteButtonName() const noexcept;\r\n-\r\n-        void EnterHoverMode() { IsHovered(true); };\r\n-        void ExitHoverMode() { IsHovered(false); };\r\n-        void ActionGotFocus() { IsContainerFocused(true); };\r\n-        void ActionLostFocus() { IsContainerFocused(false); };\r\n-        void EditButtonGettingFocus() { IsEditButtonFocused(true); };\r\n-        void EditButtonLosingFocus() { IsEditButtonFocused(false); };\r\n-        bool ShowEditButton() const noexcept;\r\n+        ArgWrapper(const winrt::hstring& name, const winrt::hstring& type, const bool required, const Model::ArgTag tag, const Windows::Foundation::IInspectable& value);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring Name() const noexcept { return _name; };\r\n+        winrt::hstring Type() const noexcept { return _type; };\r\n+        Model::ArgTag Tag() const noexcept { return _tag; };\r\n+        bool Required() const noexcept { return _required; };\r\n+\r\n+        // We cannot use the macro here because we need to implement additional logic for the setter\r\n+        Windows::Foundation::IInspectable EnumValue() const noexcept { return _EnumValue; };\r\n+        void EnumValue(const Windows::Foundation::IInspectable& value);\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::EnumEntry> EnumList() const noexcept { return _EnumList; };\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::FlagEntry> FlagList() const noexcept { return _FlagList; };\r\n+\r\n+        // unboxing functions\r\n+        winrt::hstring UnboxString(const Windows::Foundation::IInspectable& value);\r\n+        winrt::hstring UnboxGuid(const Windows::Foundation::IInspectable& value);\r\n+        int32_t UnboxInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        uint32_t UnboxUInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt64(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxFloat(const Windows::Foundation::IInspectable& value);\r\n+        bool UnboxBool(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<bool> UnboxBoolOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxTerminalCoreColorOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxWindowsUIColorOptional(const Windows::Foundation::IInspectable& value);\r\n+\r\n+        // bind back functions\r\n+        void StringBindBack(const winrt::hstring& newValue);\r\n+        void GuidBindBack(const winrt::hstring& newValue);\r\n+        void Int32BindBack(const double newValue);\r\n+        void Int32OptionalBindBack(const double newValue);\r\n+        void UInt32BindBack(const double newValue);\r\n+        void UInt32OptionalBindBack(const double newValue);\r\n+        void UInt64BindBack(const double newValue);\r\n+        void FloatBindBack(const double newValue);\r\n+        void BoolOptionalBindBack(const Windows::Foundation::IReference<bool> newValue);\r\n+        void TerminalCoreColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r\n+        void WindowsUIColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r",
        "comment_created_at": "2025-05-21T20:35:52+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "These are all pretty simple functions, and that's great. Would there be any benefit to moving these over to be converters so they can be used throughout the project? Or am I overengineering it? \ud83d\ude05",
        "pr_file_module": null
      },
      {
        "comment_id": "2141258295",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18917,
        "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.h",
        "discussion_id": "2101122099",
        "commented_code": "@@ -4,127 +4,248 @@\n #pragma once\r\n \r\n #include \"ActionsViewModel.g.h\"\r\n-#include \"KeyBindingViewModel.g.h\"\r\n-#include \"ModifyKeyBindingEventArgs.g.h\"\r\n+#include \"NavigateToCommandArgs.g.h\"\r\n+#include \"CommandViewModel.g.h\"\r\n+#include \"ArgWrapper.g.h\"\r\n+#include \"ActionArgsViewModel.g.h\"\r\n+#include \"KeyChordViewModel.g.h\"\r\n+#include \"ModifyKeyChordEventArgs.g.h\"\r\n #include \"Utils.h\"\r\n #include \"ViewModelHelpers.h\"\r\n \r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    struct KeyBindingViewModelComparator\r\n+    struct CommandViewModelComparator\r\n     {\r\n-        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const\r\n+        bool operator()(const Editor::CommandViewModel& lhs, const Editor::CommandViewModel& rhs) const\r\n         {\r\n-            return lhs.Name() < rhs.Name();\r\n+            return lhs.DisplayName() < rhs.DisplayName();\r\n         }\r\n     };\r\n \r\n-    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>\r\n+    struct NavigateToCommandArgs : NavigateToCommandArgsT<NavigateToCommandArgs>\r\n     {\r\n     public:\r\n-        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :\r\n+        NavigateToCommandArgs(CommandViewModel command, Editor::IHostedInWindow windowRoot) :\r\n+            _Command(command),\r\n+            _WindowRoot(windowRoot) {}\r\n+\r\n+        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }\r\n+        Editor::CommandViewModel Command() const noexcept { return _Command; }\r\n+\r\n+    private:\r\n+        Editor::IHostedInWindow _WindowRoot;\r\n+        Editor::CommandViewModel _Command{ nullptr };\r\n+    };\r\n+\r\n+    struct ModifyKeyChordEventArgs : ModifyKeyChordEventArgsT<ModifyKeyChordEventArgs>\r\n+    {\r\n+    public:\r\n+        ModifyKeyChordEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys) :\r\n             _OldKeys{ oldKeys },\r\n-            _NewKeys{ newKeys },\r\n-            _OldActionName{ std::move(oldActionName) },\r\n-            _NewActionName{ std::move(newActionName) } {}\r\n+            _NewKeys{ newKeys } {}\r\n \r\n         WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);\r\n         WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);\r\n-        WINRT_PROPERTY(hstring, OldActionName);\r\n-        WINRT_PROPERTY(hstring, NewActionName);\r\n     };\r\n \r\n-    struct KeyBindingViewModel : KeyBindingViewModelT<KeyBindingViewModel>, ViewModelHelper<KeyBindingViewModel>\r\n+    struct CommandViewModel : CommandViewModelT<CommandViewModel>, ViewModelHelper<CommandViewModel>\r\n+    {\r\n+    public:\r\n+        CommandViewModel(winrt::Microsoft::Terminal::Settings::Model::Command cmd,\r\n+                         std::vector<Control::KeyChord> keyChordList,\r\n+                         const Editor::ActionsViewModel actionsPageVM,\r\n+                         const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring DisplayName();\r\n+        winrt::hstring Name();\r\n+        void Name(const winrt::hstring& newName);\r\n+\r\n+        winrt::hstring ID();\r\n+        void ID(const winrt::hstring& newID);\r\n+\r\n+        bool IsUserAction();\r\n+\r\n+        void Edit_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> EditRequested;\r\n+\r\n+        void Delete_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> DeleteRequested;\r\n+\r\n+        void AddKeybinding_Click();\r\n+\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeNamesRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateWindowRootRequested;\r\n+\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(IInspectable, ProposedShortcutAction);\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(Editor::ActionArgsViewModel, ActionArgsVM, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<hstring>, AvailableShortcutActions, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::KeyChordViewModel>, KeyChordViewModelList, nullptr);\r\n+        WINRT_PROPERTY(bool, IsNewCommand, false);\r\n+\r\n+    private:\r\n+        winrt::Microsoft::Terminal::Settings::Model::Command _command;\r\n+        std::vector<Control::KeyChord> _keyChordList;\r\n+        weak_ref<Editor::ActionsViewModel> _actionsPageVM{ nullptr };\r\n+        void _RegisterKeyChordVMEvents(Editor::KeyChordViewModel kcVM);\r\n+        void _RegisterActionArgsVMEvents(Editor::ActionArgsViewModel actionArgsVM);\r\n+        void _ReplaceCommandWithUserCopy(bool reinitialize);\r\n+        void _CreateAndInitializeActionArgsVMHelper();\r\n+        Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring> _AvailableActionsAndNamesMap;\r\n+        std::unordered_map<winrt::hstring, Model::ShortcutAction> _NameToActionMap;\r\n+    };\r\n+\r\n+    struct ArgWrapper : ArgWrapperT<ArgWrapper>, ViewModelHelper<ArgWrapper>\r\n     {\r\n     public:\r\n-        KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-        KeyBindingViewModel(const Control::KeyChord& keys, const hstring& name, const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-\r\n-        hstring Name() const { return _CurrentAction; }\r\n-        hstring KeyChordText() const { return _KeyChordText; }\r\n-\r\n-        // UIA Text\r\n-        hstring EditButtonName() const noexcept;\r\n-        hstring CancelButtonName() const noexcept;\r\n-        hstring AcceptButtonName() const noexcept;\r\n-        hstring DeleteButtonName() const noexcept;\r\n-\r\n-        void EnterHoverMode() { IsHovered(true); };\r\n-        void ExitHoverMode() { IsHovered(false); };\r\n-        void ActionGotFocus() { IsContainerFocused(true); };\r\n-        void ActionLostFocus() { IsContainerFocused(false); };\r\n-        void EditButtonGettingFocus() { IsEditButtonFocused(true); };\r\n-        void EditButtonLosingFocus() { IsEditButtonFocused(false); };\r\n-        bool ShowEditButton() const noexcept;\r\n+        ArgWrapper(const winrt::hstring& name, const winrt::hstring& type, const bool required, const Model::ArgTag tag, const Windows::Foundation::IInspectable& value);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring Name() const noexcept { return _name; };\r\n+        winrt::hstring Type() const noexcept { return _type; };\r\n+        Model::ArgTag Tag() const noexcept { return _tag; };\r\n+        bool Required() const noexcept { return _required; };\r\n+\r\n+        // We cannot use the macro here because we need to implement additional logic for the setter\r\n+        Windows::Foundation::IInspectable EnumValue() const noexcept { return _EnumValue; };\r\n+        void EnumValue(const Windows::Foundation::IInspectable& value);\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::EnumEntry> EnumList() const noexcept { return _EnumList; };\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::FlagEntry> FlagList() const noexcept { return _FlagList; };\r\n+\r\n+        // unboxing functions\r\n+        winrt::hstring UnboxString(const Windows::Foundation::IInspectable& value);\r\n+        winrt::hstring UnboxGuid(const Windows::Foundation::IInspectable& value);\r\n+        int32_t UnboxInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        uint32_t UnboxUInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt64(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxFloat(const Windows::Foundation::IInspectable& value);\r\n+        bool UnboxBool(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<bool> UnboxBoolOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxTerminalCoreColorOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxWindowsUIColorOptional(const Windows::Foundation::IInspectable& value);\r\n+\r\n+        // bind back functions\r\n+        void StringBindBack(const winrt::hstring& newValue);\r\n+        void GuidBindBack(const winrt::hstring& newValue);\r\n+        void Int32BindBack(const double newValue);\r\n+        void Int32OptionalBindBack(const double newValue);\r\n+        void UInt32BindBack(const double newValue);\r\n+        void UInt32OptionalBindBack(const double newValue);\r\n+        void UInt64BindBack(const double newValue);\r\n+        void FloatBindBack(const double newValue);\r\n+        void BoolOptionalBindBack(const Windows::Foundation::IReference<bool> newValue);\r\n+        void TerminalCoreColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r\n+        void WindowsUIColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r",
        "comment_created_at": "2025-06-11T23:24:33+00:00",
        "comment_author": "PankajBhojwani",
        "comment_body": "The `BindBack` functions all need to stay here since it involves modifying the underlying data, so I figured it would be cleaner if we just leave the `Unbox` functions here too",
        "pr_file_module": null
      },
      {
        "comment_id": "2141258722",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 18917,
        "pr_file": "src/cascadia/TerminalSettingsEditor/ActionsViewModel.h",
        "discussion_id": "2101122099",
        "commented_code": "@@ -4,127 +4,248 @@\n #pragma once\r\n \r\n #include \"ActionsViewModel.g.h\"\r\n-#include \"KeyBindingViewModel.g.h\"\r\n-#include \"ModifyKeyBindingEventArgs.g.h\"\r\n+#include \"NavigateToCommandArgs.g.h\"\r\n+#include \"CommandViewModel.g.h\"\r\n+#include \"ArgWrapper.g.h\"\r\n+#include \"ActionArgsViewModel.g.h\"\r\n+#include \"KeyChordViewModel.g.h\"\r\n+#include \"ModifyKeyChordEventArgs.g.h\"\r\n #include \"Utils.h\"\r\n #include \"ViewModelHelpers.h\"\r\n \r\n namespace winrt::Microsoft::Terminal::Settings::Editor::implementation\r\n {\r\n-    struct KeyBindingViewModelComparator\r\n+    struct CommandViewModelComparator\r\n     {\r\n-        bool operator()(const Editor::KeyBindingViewModel& lhs, const Editor::KeyBindingViewModel& rhs) const\r\n+        bool operator()(const Editor::CommandViewModel& lhs, const Editor::CommandViewModel& rhs) const\r\n         {\r\n-            return lhs.Name() < rhs.Name();\r\n+            return lhs.DisplayName() < rhs.DisplayName();\r\n         }\r\n     };\r\n \r\n-    struct ModifyKeyBindingEventArgs : ModifyKeyBindingEventArgsT<ModifyKeyBindingEventArgs>\r\n+    struct NavigateToCommandArgs : NavigateToCommandArgsT<NavigateToCommandArgs>\r\n     {\r\n     public:\r\n-        ModifyKeyBindingEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys, const hstring oldActionName, const hstring newActionName) :\r\n+        NavigateToCommandArgs(CommandViewModel command, Editor::IHostedInWindow windowRoot) :\r\n+            _Command(command),\r\n+            _WindowRoot(windowRoot) {}\r\n+\r\n+        Editor::IHostedInWindow WindowRoot() const noexcept { return _WindowRoot; }\r\n+        Editor::CommandViewModel Command() const noexcept { return _Command; }\r\n+\r\n+    private:\r\n+        Editor::IHostedInWindow _WindowRoot;\r\n+        Editor::CommandViewModel _Command{ nullptr };\r\n+    };\r\n+\r\n+    struct ModifyKeyChordEventArgs : ModifyKeyChordEventArgsT<ModifyKeyChordEventArgs>\r\n+    {\r\n+    public:\r\n+        ModifyKeyChordEventArgs(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys) :\r\n             _OldKeys{ oldKeys },\r\n-            _NewKeys{ newKeys },\r\n-            _OldActionName{ std::move(oldActionName) },\r\n-            _NewActionName{ std::move(newActionName) } {}\r\n+            _NewKeys{ newKeys } {}\r\n \r\n         WINRT_PROPERTY(Control::KeyChord, OldKeys, nullptr);\r\n         WINRT_PROPERTY(Control::KeyChord, NewKeys, nullptr);\r\n-        WINRT_PROPERTY(hstring, OldActionName);\r\n-        WINRT_PROPERTY(hstring, NewActionName);\r\n     };\r\n \r\n-    struct KeyBindingViewModel : KeyBindingViewModelT<KeyBindingViewModel>, ViewModelHelper<KeyBindingViewModel>\r\n+    struct CommandViewModel : CommandViewModelT<CommandViewModel>, ViewModelHelper<CommandViewModel>\r\n+    {\r\n+    public:\r\n+        CommandViewModel(winrt::Microsoft::Terminal::Settings::Model::Command cmd,\r\n+                         std::vector<Control::KeyChord> keyChordList,\r\n+                         const Editor::ActionsViewModel actionsPageVM,\r\n+                         const Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring>& availableShortcutActionsAndNames);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring DisplayName();\r\n+        winrt::hstring Name();\r\n+        void Name(const winrt::hstring& newName);\r\n+\r\n+        winrt::hstring ID();\r\n+        void ID(const winrt::hstring& newID);\r\n+\r\n+        bool IsUserAction();\r\n+\r\n+        void Edit_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> EditRequested;\r\n+\r\n+        void Delete_Click();\r\n+        til::typed_event<Editor::CommandViewModel, IInspectable> DeleteRequested;\r\n+\r\n+        void AddKeybinding_Click();\r\n+\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateColorSchemeNamesRequested;\r\n+        til::typed_event<IInspectable, Editor::ArgWrapper> PropagateWindowRootRequested;\r\n+\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(IInspectable, ProposedShortcutAction);\r\n+        VIEW_MODEL_OBSERVABLE_PROPERTY(Editor::ActionArgsViewModel, ActionArgsVM, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<hstring>, AvailableShortcutActions, nullptr);\r\n+        WINRT_PROPERTY(Windows::Foundation::Collections::IObservableVector<Editor::KeyChordViewModel>, KeyChordViewModelList, nullptr);\r\n+        WINRT_PROPERTY(bool, IsNewCommand, false);\r\n+\r\n+    private:\r\n+        winrt::Microsoft::Terminal::Settings::Model::Command _command;\r\n+        std::vector<Control::KeyChord> _keyChordList;\r\n+        weak_ref<Editor::ActionsViewModel> _actionsPageVM{ nullptr };\r\n+        void _RegisterKeyChordVMEvents(Editor::KeyChordViewModel kcVM);\r\n+        void _RegisterActionArgsVMEvents(Editor::ActionArgsViewModel actionArgsVM);\r\n+        void _ReplaceCommandWithUserCopy(bool reinitialize);\r\n+        void _CreateAndInitializeActionArgsVMHelper();\r\n+        Windows::Foundation::Collections::IMap<Model::ShortcutAction, winrt::hstring> _AvailableActionsAndNamesMap;\r\n+        std::unordered_map<winrt::hstring, Model::ShortcutAction> _NameToActionMap;\r\n+    };\r\n+\r\n+    struct ArgWrapper : ArgWrapperT<ArgWrapper>, ViewModelHelper<ArgWrapper>\r\n     {\r\n     public:\r\n-        KeyBindingViewModel(const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-        KeyBindingViewModel(const Control::KeyChord& keys, const hstring& name, const Windows::Foundation::Collections::IObservableVector<hstring>& availableActions);\r\n-\r\n-        hstring Name() const { return _CurrentAction; }\r\n-        hstring KeyChordText() const { return _KeyChordText; }\r\n-\r\n-        // UIA Text\r\n-        hstring EditButtonName() const noexcept;\r\n-        hstring CancelButtonName() const noexcept;\r\n-        hstring AcceptButtonName() const noexcept;\r\n-        hstring DeleteButtonName() const noexcept;\r\n-\r\n-        void EnterHoverMode() { IsHovered(true); };\r\n-        void ExitHoverMode() { IsHovered(false); };\r\n-        void ActionGotFocus() { IsContainerFocused(true); };\r\n-        void ActionLostFocus() { IsContainerFocused(false); };\r\n-        void EditButtonGettingFocus() { IsEditButtonFocused(true); };\r\n-        void EditButtonLosingFocus() { IsEditButtonFocused(false); };\r\n-        bool ShowEditButton() const noexcept;\r\n+        ArgWrapper(const winrt::hstring& name, const winrt::hstring& type, const bool required, const Model::ArgTag tag, const Windows::Foundation::IInspectable& value);\r\n+        void Initialize();\r\n+\r\n+        winrt::hstring Name() const noexcept { return _name; };\r\n+        winrt::hstring Type() const noexcept { return _type; };\r\n+        Model::ArgTag Tag() const noexcept { return _tag; };\r\n+        bool Required() const noexcept { return _required; };\r\n+\r\n+        // We cannot use the macro here because we need to implement additional logic for the setter\r\n+        Windows::Foundation::IInspectable EnumValue() const noexcept { return _EnumValue; };\r\n+        void EnumValue(const Windows::Foundation::IInspectable& value);\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::EnumEntry> EnumList() const noexcept { return _EnumList; };\r\n+        Windows::Foundation::Collections::IObservableVector<Microsoft::Terminal::Settings::Editor::FlagEntry> FlagList() const noexcept { return _FlagList; };\r\n+\r\n+        // unboxing functions\r\n+        winrt::hstring UnboxString(const Windows::Foundation::IInspectable& value);\r\n+        winrt::hstring UnboxGuid(const Windows::Foundation::IInspectable& value);\r\n+        int32_t UnboxInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        uint32_t UnboxUInt32(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt32Optional(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxUInt64(const Windows::Foundation::IInspectable& value);\r\n+        float UnboxFloat(const Windows::Foundation::IInspectable& value);\r\n+        bool UnboxBool(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<bool> UnboxBoolOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxTerminalCoreColorOptional(const Windows::Foundation::IInspectable& value);\r\n+        winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> UnboxWindowsUIColorOptional(const Windows::Foundation::IInspectable& value);\r\n+\r\n+        // bind back functions\r\n+        void StringBindBack(const winrt::hstring& newValue);\r\n+        void GuidBindBack(const winrt::hstring& newValue);\r\n+        void Int32BindBack(const double newValue);\r\n+        void Int32OptionalBindBack(const double newValue);\r\n+        void UInt32BindBack(const double newValue);\r\n+        void UInt32OptionalBindBack(const double newValue);\r\n+        void UInt64BindBack(const double newValue);\r\n+        void FloatBindBack(const double newValue);\r\n+        void BoolOptionalBindBack(const Windows::Foundation::IReference<bool> newValue);\r\n+        void TerminalCoreColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r\n+        void WindowsUIColorBindBack(const winrt::Windows::Foundation::IReference<Microsoft::Terminal::Core::Color> newValue);\r",
        "comment_created_at": "2025-06-11T23:25:09+00:00",
        "comment_author": "PankajBhojwani",
        "comment_body": "Happy to move just the unbox ones over to converters if we feel strongly about it though",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2127521047",
    "pr_number": 19001,
    "pr_file": "src/cascadia/TerminalSettingsEditor/MainPage.xaml",
    "created_at": "2025-06-04T22:05:29+00:00",
    "commented_code": "TabFocusNavigation=\"Cycle\">\r\n         <muxc:NavigationView.Resources>\r\n             <ResourceDictionary>\r\n-                <Thickness x:Key=\"NavigationViewHeaderMargin\">15,0,0,0</Thickness>\r\n+                <Thickness x:Key=\"NavigationViewHeaderMargin\">0,4,0,0</Thickness>\r\n             </ResourceDictionary>\r\n         </muxc:NavigationView.Resources>\r\n         <muxc:NavigationView.Header>\r\n-            <muxc:BreadcrumbBar x:Name=\"NavigationBreadcrumbBar\"\r\n-                                MaxWidth=\"{StaticResource StandardControlMaxWidth}\"\r\n-                                ItemClicked=\"BreadcrumbBar_ItemClicked\"\r\n-                                ItemsSource=\"{x:Bind Breadcrumbs}\">\r\n-                <muxc:BreadcrumbBar.ItemTemplate>\r\n-                    <DataTemplate x:DataType=\"local:Breadcrumb\">\r\n-                        <TextBlock Text=\"{x:Bind Label}\" />\r\n-                    </DataTemplate>\r\n-                </muxc:BreadcrumbBar.ItemTemplate>\r\n-                <muxc:BreadcrumbBar.Resources>\r\n-                    <ResourceDictionary>\r\n-                        <x:Double x:Key=\"BreadcrumbBarItemThemeFontSize\">28</x:Double>\r\n-                        <Thickness x:Key=\"BreadcrumbBarChevronPadding\">11,4,12,0</Thickness>\r\n-                        <FontWeight x:Key=\"BreadcrumbBarItemFontWeight\">SemiBold</FontWeight>\r\n-                        <x:Double x:Key=\"BreadcrumbBarChevronFontSize\">16</x:Double>\r\n-                    </ResourceDictionary>\r\n-                </muxc:BreadcrumbBar.Resources>\r\n-            </muxc:BreadcrumbBar>\r\n+            <Grid Padding=\"16,0\">\r\n+                <!--  Wrapping the breadcrumbbar in a Grid to avoid the title to drift (and no longer being aligned with the content of the page) when resizing the window. It's weird, I know. I believe it has to do with https://github.com/microsoft/microsoft-ui-xaml/issues/3842 doing funky things when setting a MaxWidth  -->\r\n+                <muxc:BreadcrumbBar x:Name=\"NavigationBreadcrumbBar\"\r\n+                                    MaxWidth=\"1000\"",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2127521047",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19001,
        "pr_file": "src/cascadia/TerminalSettingsEditor/MainPage.xaml",
        "discussion_id": "2127521047",
        "commented_code": "@@ -73,28 +71,32 @@\n                          TabFocusNavigation=\"Cycle\">\r\n         <muxc:NavigationView.Resources>\r\n             <ResourceDictionary>\r\n-                <Thickness x:Key=\"NavigationViewHeaderMargin\">15,0,0,0</Thickness>\r\n+                <Thickness x:Key=\"NavigationViewHeaderMargin\">0,4,0,0</Thickness>\r\n             </ResourceDictionary>\r\n         </muxc:NavigationView.Resources>\r\n         <muxc:NavigationView.Header>\r\n-            <muxc:BreadcrumbBar x:Name=\"NavigationBreadcrumbBar\"\r\n-                                MaxWidth=\"{StaticResource StandardControlMaxWidth}\"\r\n-                                ItemClicked=\"BreadcrumbBar_ItemClicked\"\r\n-                                ItemsSource=\"{x:Bind Breadcrumbs}\">\r\n-                <muxc:BreadcrumbBar.ItemTemplate>\r\n-                    <DataTemplate x:DataType=\"local:Breadcrumb\">\r\n-                        <TextBlock Text=\"{x:Bind Label}\" />\r\n-                    </DataTemplate>\r\n-                </muxc:BreadcrumbBar.ItemTemplate>\r\n-                <muxc:BreadcrumbBar.Resources>\r\n-                    <ResourceDictionary>\r\n-                        <x:Double x:Key=\"BreadcrumbBarItemThemeFontSize\">28</x:Double>\r\n-                        <Thickness x:Key=\"BreadcrumbBarChevronPadding\">11,4,12,0</Thickness>\r\n-                        <FontWeight x:Key=\"BreadcrumbBarItemFontWeight\">SemiBold</FontWeight>\r\n-                        <x:Double x:Key=\"BreadcrumbBarChevronFontSize\">16</x:Double>\r\n-                    </ResourceDictionary>\r\n-                </muxc:BreadcrumbBar.Resources>\r\n-            </muxc:BreadcrumbBar>\r\n+            <Grid Padding=\"16,0\">\r\n+                <!--  Wrapping the breadcrumbbar in a Grid to avoid the title to drift (and no longer being aligned with the content of the page) when resizing the window. It's weird, I know. I believe it has to do with https://github.com/microsoft/microsoft-ui-xaml/issues/3842 doing funky things when setting a MaxWidth  -->\r\n+                <muxc:BreadcrumbBar x:Name=\"NavigationBreadcrumbBar\"\r\n+                                    MaxWidth=\"1000\"\r",
        "comment_created_at": "2025-06-04T22:05:29+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "`StandardControlMaxWidth` is still set to `1000` though. Shouldn't we still reuse it here?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2211109879",
    "pr_number": 19001,
    "pr_file": "src/cascadia/TerminalSettingsEditor/CommonResources.xaml",
    "created_at": "2025-07-16T17:45:59+00:00",
    "commented_code": "<!--  Used to stack a group of settings  -->\r\n     <Style x:Key=\"SettingsStackStyle\"\r\n            TargetType=\"StackPanel\">\r\n-        <Setter Property=\"Margin\" Value=\"{StaticResource SettingStackMargin}\" />\r\n+        <Setter Property=\"MaxWidth\" Value=\"{StaticResource StandardControlMaxWidth}\" />\r\n     </Style>\r\n \r\n     <!--  Used to stack a group of settings inside a pivot  -->\r\n     <Style x:Key=\"PivotStackStyle\"\r\n            TargetType=\"StackPanel\">\r\n-        <Setter Property=\"Margin\" Value=\"{StaticResource SettingStackMargin}\" />\r\n+        <Setter Property=\"MaxWidth\" Value=\"{StaticResource StandardControlMaxWidth}\" />\r\n     </Style>",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "2211109879",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 19001,
        "pr_file": "src/cascadia/TerminalSettingsEditor/CommonResources.xaml",
        "discussion_id": "2211109879",
        "commented_code": "@@ -112,13 +111,13 @@\n     <!--  Used to stack a group of settings  -->\r\n     <Style x:Key=\"SettingsStackStyle\"\r\n            TargetType=\"StackPanel\">\r\n-        <Setter Property=\"Margin\" Value=\"{StaticResource SettingStackMargin}\" />\r\n+        <Setter Property=\"MaxWidth\" Value=\"{StaticResource StandardControlMaxWidth}\" />\r\n     </Style>\r\n \r\n     <!--  Used to stack a group of settings inside a pivot  -->\r\n     <Style x:Key=\"PivotStackStyle\"\r\n            TargetType=\"StackPanel\">\r\n-        <Setter Property=\"Margin\" Value=\"{StaticResource SettingStackMargin}\" />\r\n+        <Setter Property=\"MaxWidth\" Value=\"{StaticResource StandardControlMaxWidth}\" />\r\n     </Style>\r",
        "comment_created_at": "2025-07-16T17:45:59+00:00",
        "comment_author": "carlos-zamora",
        "comment_body": "Huh, looks like we can merge the two and just keep `SettingsStackStyle` around. `PivotStackStyle` was probably introduced back when we had a Pivot control ages ago.\r\n\r\nIf you're interested, feel free to do this as a part of this PR. Not a requirement though. More just something I took note of \ud83d\ude0a",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1643413111",
    "pr_number": 17422,
    "pr_file": "src/inc/til/rapidhash.h",
    "created_at": "2024-06-17T20:46:47+00:00",
    "commented_code": "+/*\r\n+ * rapidhash - Very fast, high quality, platform-independent hashing algorithm.\r\n+ * Copyright (C) 2024 Nicolas De Carli\r\n+ *\r\n+ * Based on 'wyhash', by Wang Yi <godspeed_china@yeah.net>\r\n+ *\r\n+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)\r\n+ *\r\n+ * Redistribution and use in source and binary forms, with or without\r\n+ * modification, are permitted provided that the following conditions are\r\n+ * met:\r\n+ *\r\n+ *    * Redistributions of source code must retain the above copyright\r\n+ *      notice, this list of conditions and the following disclaimer.\r\n+ *    * Redistributions in binary form must reproduce the above\r\n+ *      copyright notice, this list of conditions and the following disclaimer\r\n+ *      in the documentation and/or other materials provided with the\r\n+ *      distribution.\r\n+ *\r\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n+ *\r\n+ * You can contact the author at:\r\n+ *   - rapidhash source repository: https://github.com/Nicoshev/rapidhash\r\n+ */\r\n+\r\n+#ifdef __cplusplus\r\n+#define RAPIDHASH_NOEXCEPT noexcept\r\n+#else\r\n+#define RAPIDHASH_NOEXCEPT\r\n+#endif\r\n+\r\n+/*\r\n+ *  Includes.\r\n+ */\r\n+#include <stdint.h>\r\n+#include <string.h>\r\n+#if defined(_MSC_VER)\r\n+#include <intrin.h>\r\n+#if defined(_M_X64) && !defined(_M_ARM64EC)\r\n+#pragma intrinsic(_umul128)\r\n+#endif\r\n+#endif\r\n+\r\n+/*\r\n+ *  Protection macro, alters behaviour of rapid_mum multiplication function.\r\n+ *  \r\n+ *  RAPIDHASH_FAST: Normal behavior, max speed.\r\n+ *  RAPIDHASH_PROTECTED: Extra protection against entropy loss.\r\n+ */\r\n+#ifndef RAPIDHASH_PROTECTED\r\n+#define RAPIDHASH_FAST\r\n+#elif defined(RAPIDHASH_FAST)\r\n+#error \"cannot define RAPIDHASH_PROTECTED and RAPIDHASH_FAST simultaneously.\"\r\n+#endif\r\n+\r\n+/*\r\n+ *  Unrolling macros, changes code definition for main hash function.\r\n+ *  \r\n+ *  RAPIDHASH_COMPACT: Legacy variant, each loop process 48 bytes.\r\n+ *  RAPIDHASH_UNROLLED: Unrolled variant, each loop process 96 bytes.\r\n+ *\r\n+ *  Most modern CPUs should benefit from having RAPIDHASH_UNROLLED.\r\n+ *\r\n+ *  These macros do not alter the output hash.\r\n+ */\r\n+#ifndef RAPIDHASH_COMPACT\r\n+#define RAPIDHASH_UNROLLED\r\n+#elif defined(RAPIDHASH_UNROLLED)\r\n+#error \"cannot define RAPIDHASH_COMPACT and RAPIDHASH_UNROLLED simultaneously.\"\r\n+#endif\r\n+\r\n+/*\r\n+ *  Likely and unlikely macros.\r\n+ */\r\n+#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\r\n+#define _likely_(x) __builtin_expect(x, 1)\r\n+#define _unlikely_(x) __builtin_expect(x, 0)\r\n+#else\r\n+#define _likely_(x) (x)\r\n+#define _unlikely_(x) (x)\r\n+#endif\r\n+\r\n+/*\r\n+ *  Endianness macros.\r\n+ */\r\n+#ifndef RAPIDHASH_LITTLE_ENDIAN\r\n+#if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\r\n+#define RAPIDHASH_LITTLE_ENDIAN\r\n+#elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\r\n+#define RAPIDHASH_BIG_ENDIAN\r\n+#else\r\n+#warning \"could not determine endianness! Falling back to little endian.\"\r\n+#define RAPIDHASH_LITTLE_ENDIAN\r\n+#endif\r\n+#endif\r\n+\r\n+/*\r\n+ *  Default seed.\r\n+ */\r\n+#define RAPID_SEED (0xbdd89aa982704029ull)\r\n+\r\n+/*\r\n+ *  Default secret parameters.\r\n+ */\r\n+static const uint64_t rapid_secret[3] = { 0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull };",
    "repo_full_name": "microsoft/terminal",
    "discussion_comments": [
      {
        "comment_id": "1643413111",
        "repo_full_name": "microsoft/terminal",
        "pr_number": 17422,
        "pr_file": "src/inc/til/rapidhash.h",
        "discussion_id": "1643413111",
        "commented_code": "@@ -0,0 +1,384 @@\n+/*\r\n+ * rapidhash - Very fast, high quality, platform-independent hashing algorithm.\r\n+ * Copyright (C) 2024 Nicolas De Carli\r\n+ *\r\n+ * Based on 'wyhash', by Wang Yi <godspeed_china@yeah.net>\r\n+ *\r\n+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)\r\n+ *\r\n+ * Redistribution and use in source and binary forms, with or without\r\n+ * modification, are permitted provided that the following conditions are\r\n+ * met:\r\n+ *\r\n+ *    * Redistributions of source code must retain the above copyright\r\n+ *      notice, this list of conditions and the following disclaimer.\r\n+ *    * Redistributions in binary form must reproduce the above\r\n+ *      copyright notice, this list of conditions and the following disclaimer\r\n+ *      in the documentation and/or other materials provided with the\r\n+ *      distribution.\r\n+ *\r\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n+ * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n+ *\r\n+ * You can contact the author at:\r\n+ *   - rapidhash source repository: https://github.com/Nicoshev/rapidhash\r\n+ */\r\n+\r\n+#ifdef __cplusplus\r\n+#define RAPIDHASH_NOEXCEPT noexcept\r\n+#else\r\n+#define RAPIDHASH_NOEXCEPT\r\n+#endif\r\n+\r\n+/*\r\n+ *  Includes.\r\n+ */\r\n+#include <stdint.h>\r\n+#include <string.h>\r\n+#if defined(_MSC_VER)\r\n+#include <intrin.h>\r\n+#if defined(_M_X64) && !defined(_M_ARM64EC)\r\n+#pragma intrinsic(_umul128)\r\n+#endif\r\n+#endif\r\n+\r\n+/*\r\n+ *  Protection macro, alters behaviour of rapid_mum multiplication function.\r\n+ *  \r\n+ *  RAPIDHASH_FAST: Normal behavior, max speed.\r\n+ *  RAPIDHASH_PROTECTED: Extra protection against entropy loss.\r\n+ */\r\n+#ifndef RAPIDHASH_PROTECTED\r\n+#define RAPIDHASH_FAST\r\n+#elif defined(RAPIDHASH_FAST)\r\n+#error \"cannot define RAPIDHASH_PROTECTED and RAPIDHASH_FAST simultaneously.\"\r\n+#endif\r\n+\r\n+/*\r\n+ *  Unrolling macros, changes code definition for main hash function.\r\n+ *  \r\n+ *  RAPIDHASH_COMPACT: Legacy variant, each loop process 48 bytes.\r\n+ *  RAPIDHASH_UNROLLED: Unrolled variant, each loop process 96 bytes.\r\n+ *\r\n+ *  Most modern CPUs should benefit from having RAPIDHASH_UNROLLED.\r\n+ *\r\n+ *  These macros do not alter the output hash.\r\n+ */\r\n+#ifndef RAPIDHASH_COMPACT\r\n+#define RAPIDHASH_UNROLLED\r\n+#elif defined(RAPIDHASH_UNROLLED)\r\n+#error \"cannot define RAPIDHASH_COMPACT and RAPIDHASH_UNROLLED simultaneously.\"\r\n+#endif\r\n+\r\n+/*\r\n+ *  Likely and unlikely macros.\r\n+ */\r\n+#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\r\n+#define _likely_(x) __builtin_expect(x, 1)\r\n+#define _unlikely_(x) __builtin_expect(x, 0)\r\n+#else\r\n+#define _likely_(x) (x)\r\n+#define _unlikely_(x) (x)\r\n+#endif\r\n+\r\n+/*\r\n+ *  Endianness macros.\r\n+ */\r\n+#ifndef RAPIDHASH_LITTLE_ENDIAN\r\n+#if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\r\n+#define RAPIDHASH_LITTLE_ENDIAN\r\n+#elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\r\n+#define RAPIDHASH_BIG_ENDIAN\r\n+#else\r\n+#warning \"could not determine endianness! Falling back to little endian.\"\r\n+#define RAPIDHASH_LITTLE_ENDIAN\r\n+#endif\r\n+#endif\r\n+\r\n+/*\r\n+ *  Default seed.\r\n+ */\r\n+#define RAPID_SEED (0xbdd89aa982704029ull)\r\n+\r\n+/*\r\n+ *  Default secret parameters.\r\n+ */\r\n+static const uint64_t rapid_secret[3] = { 0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull };\r",
        "comment_created_at": "2024-06-17T20:46:47+00:00",
        "comment_author": "lhecker",
        "comment_body": "As far as I understand this will introduce a duplicate constant into every compilation unit. I think it'd be better if you moved it into `rapidhash_withSeed`. I mean, unless this constant is meant to be part of the API of course.",
        "pr_file_module": null
      }
    ]
  }
]