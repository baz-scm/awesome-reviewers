[
  {
    "discussion_id": "2185545006",
    "pr_number": 37288,
    "pr_file": "internal/providers/provider.go",
    "created_at": "2025-07-04T14:42:19+00:00",
    "commented_code": "// Diagnostics contains any warnings or errors from the method call.\n \tDiagnostics tfdiags.Diagnostics\n }\n+\n+type GetStatesRequest struct {\n+\t// TypeName is the name of the state store to request states data from\n+\tTypeName string\n+}\n+\n+type GetStatesResponse struct {\n+\t// States is a list of state names, sourced by inspecting persisted state data\n+\tStates []cty.Value",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2185545006",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37288,
        "pr_file": "internal/providers/provider.go",
        "discussion_id": "2185545006",
        "commented_code": "@@ -780,3 +785,30 @@ type ConfigureStateStoreResponse struct {\n \t// Diagnostics contains any warnings or errors from the method call.\n \tDiagnostics tfdiags.Diagnostics\n }\n+\n+type GetStatesRequest struct {\n+\t// TypeName is the name of the state store to request states data from\n+\tTypeName string\n+}\n+\n+type GetStatesResponse struct {\n+\t// States is a list of state names, sourced by inspecting persisted state data\n+\tStates []cty.Value",
        "comment_created_at": "2025-07-04T14:42:19+00:00",
        "comment_author": "radeksimko",
        "comment_body": "Is there a reason we want this to be `[]cty.Value` rather than `[]string`? What is the anticipation here in terms of other types and what are the side effects? ðŸ¤” \n\nThese still need to be indexable and unique, which pretty much limits it to a few primitive types anyway (number, string), does it not? And if it's number then that implies a relatively poor UX I think? - how would a user be choosing from a list of numbers?\n\nI kinda understand the desire to adapt to APIs needs and avoid state store implementations having to do some (de)serialisation when the name isn't string but considering the limitation above I'm not sure it's worth the trouble.",
        "pr_file_module": null
      },
      {
        "comment_id": "2185747474",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37288,
        "pr_file": "internal/providers/provider.go",
        "discussion_id": "2185545006",
        "commented_code": "@@ -780,3 +785,30 @@ type ConfigureStateStoreResponse struct {\n \t// Diagnostics contains any warnings or errors from the method call.\n \tDiagnostics tfdiags.Diagnostics\n }\n+\n+type GetStatesRequest struct {\n+\t// TypeName is the name of the state store to request states data from\n+\tTypeName string\n+}\n+\n+type GetStatesResponse struct {\n+\t// States is a list of state names, sourced by inspecting persisted state data\n+\tStates []cty.Value",
        "comment_created_at": "2025-07-04T16:33:21+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "I chose that because I wasn't sure what type should be there, to be honest. The only other slices used in the proto file were either slices of bytes for things like JSON data or were slices of cty values, so I assumed that cty values were required to be used.\r\n\r\nI'll change to a slice of strings",
        "pr_file_module": null
      },
      {
        "comment_id": "2185756628",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37288,
        "pr_file": "internal/providers/provider.go",
        "discussion_id": "2185545006",
        "commented_code": "@@ -780,3 +785,30 @@ type ConfigureStateStoreResponse struct {\n \t// Diagnostics contains any warnings or errors from the method call.\n \tDiagnostics tfdiags.Diagnostics\n }\n+\n+type GetStatesRequest struct {\n+\t// TypeName is the name of the state store to request states data from\n+\tTypeName string\n+}\n+\n+type GetStatesResponse struct {\n+\t// States is a list of state names, sourced by inspecting persisted state data\n+\tStates []cty.Value",
        "comment_created_at": "2025-07-04T16:36:07+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "Resolved in [241d0fe](https://github.com/hashicorp/terraform/pull/37288/commits/241d0fe82f8f94af878230b6bebfb68214a481a9)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2144548684",
    "pr_number": 37234,
    "pr_file": "internal/stacks/stackconfig/provider_requirements.go",
    "created_at": "2025-06-13T09:03:43+00:00",
    "commented_code": "func (pr *ProviderRequirements) ProviderForLocalName(localName string) (addrs.Provider, bool) {\n \tif pr == nil {\n+\t\t// Check whether the provider *might be* built-in.\n+\t\t// There might be special occasions where localName corresponds to a\n+\t\t// built-in provider names. In that case, customers will see an error\n+\t\t// occurring later in the process.\n+\t\tif _, ok := builtinProviders.BuiltInProviders()[localName]; ok {\n+\t\t\treturn addrs.Provider{}, true",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2144548684",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37234,
        "pr_file": "internal/stacks/stackconfig/provider_requirements.go",
        "discussion_id": "2144548684",
        "commented_code": "@@ -201,6 +202,13 @@ func decodeProviderRequirementsBlock(block *hcl.Block) (*ProviderRequirements, t\n \n func (pr *ProviderRequirements) ProviderForLocalName(localName string) (addrs.Provider, bool) {\n \tif pr == nil {\n+\t\t// Check whether the provider *might be* built-in.\n+\t\t// There might be special occasions where localName corresponds to a\n+\t\t// built-in provider names. In that case, customers will see an error\n+\t\t// occurring later in the process.\n+\t\tif _, ok := builtinProviders.BuiltInProviders()[localName]; ok {\n+\t\t\treturn addrs.Provider{}, true",
        "comment_created_at": "2025-06-13T09:03:43+00:00",
        "comment_author": "liamcervante",
        "comment_body": "I think there's like an `addrs.BuiltinProvider(localName)` function you can call to return a proper address here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2145059540",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37234,
        "pr_file": "internal/stacks/stackconfig/provider_requirements.go",
        "discussion_id": "2144548684",
        "commented_code": "@@ -201,6 +202,13 @@ func decodeProviderRequirementsBlock(block *hcl.Block) (*ProviderRequirements, t\n \n func (pr *ProviderRequirements) ProviderForLocalName(localName string) (addrs.Provider, bool) {\n \tif pr == nil {\n+\t\t// Check whether the provider *might be* built-in.\n+\t\t// There might be special occasions where localName corresponds to a\n+\t\t// built-in provider names. In that case, customers will see an error\n+\t\t// occurring later in the process.\n+\t\tif _, ok := builtinProviders.BuiltInProviders()[localName]; ok {\n+\t\t\treturn addrs.Provider{}, true",
        "comment_created_at": "2025-06-13T13:09:14+00:00",
        "comment_author": "matejrisek",
        "comment_body": "Thanks - there is `addrs.NewDefaultProvider` - I believe this function does what's necessary here. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2102922319",
    "pr_number": 37070,
    "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
    "created_at": "2025-05-22T16:03:26+00:00",
    "commented_code": "+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2102922319",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37070,
        "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
        "discussion_id": "2102922319",
        "commented_code": "@@ -0,0 +1,101 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
        "comment_created_at": "2025-05-22T16:03:26+00:00",
        "comment_author": "jbardin",
        "comment_body": "This is going to make evaluating a list resource difficult, because it's a list rather than an object. This is why we were thinking about making the list resource type match the schema, and holding the results as a special attribute of that object.",
        "pr_file_module": null
      },
      {
        "comment_id": "2102969763",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37070,
        "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
        "discussion_id": "2102922319",
        "commented_code": "@@ -0,0 +1,101 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
        "comment_created_at": "2025-05-22T16:28:48+00:00",
        "comment_author": "dsa0x",
        "comment_body": "While we store this as a list/tuple, we did compose it in the evaluation context as an object\r\nhttps://github.com/hashicorp/terraform/blob/15ca83851d0a2ad549324e623391ceb48b71987d/internal/terraform/evaluate.go#L821-L826\r\n\r\nIt then is a question of where we do the object composition.\r\n\r\nI mostly used it this way, so that we can reuse the existing `states.ResourceInstanceObject` structure. Perhaps it would be better to introduce a new object entirely.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2102986086",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37070,
        "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
        "discussion_id": "2102922319",
        "commented_code": "@@ -0,0 +1,101 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
        "comment_created_at": "2025-05-22T16:38:56+00:00",
        "comment_author": "jbardin",
        "comment_body": "oh interesting ðŸ¤” While there's not really any value in referencing list resource config attributes, that is how the rest of Terraform works so we may want to keep it consistent. One example I can think of is if the list resource has a `data` attribute:\r\n```\r\nlist \"provider_thing\" \"resources\" {\r\n  data = [\"some\", \"data\"]\r\n}\r\n\r\noutput \"provider_things\" {\r\n  value = list.provider_thing.resources.data\r\n}\r\n```\r\n\r\nA terraform user would expect that output reference to contain `[\"some\", \"data\"]`. That means we either need to reserve keywords from the schema, or move config into a reserved block ðŸ¤” \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2102989188",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37070,
        "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
        "discussion_id": "2102922319",
        "commented_code": "@@ -0,0 +1,101 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
        "comment_created_at": "2025-05-22T16:40:54+00:00",
        "comment_author": "dsa0x",
        "comment_body": "If I have to use the changes object instead, I will keep this in mind.",
        "pr_file_module": null
      },
      {
        "comment_id": "2102992018",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37070,
        "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
        "discussion_id": "2102922319",
        "commented_code": "@@ -0,0 +1,101 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
        "comment_created_at": "2025-05-22T16:42:44+00:00",
        "comment_author": "dsa0x",
        "comment_body": "Oh good point. Perhaps we need to retain that `data`, and potentially `identity`",
        "pr_file_module": null
      },
      {
        "comment_id": "2103007728",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37070,
        "pr_file": "internal/terraform/node_resource_plan_instance_query.go",
        "discussion_id": "2102922319",
        "commented_code": "@@ -0,0 +1,101 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package terraform\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\t\"github.com/hashicorp/terraform/internal/providers\"\n+\t\"github.com/hashicorp/terraform/internal/states\"\n+\t\"github.com/hashicorp/terraform/internal/tfdiags\"\n+\t\"github.com/zclconf/go-cty/cty\"\n+)\n+\n+func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (diags tfdiags.Diagnostics) {\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: listing resources for %s\", n.Addr)\n+\tconfig := n.Config\n+\taddr := n.ResourceInstanceAddr()\n+\tprovider, providerSchema, err := getProvider(ctx, n.ResolvedProvider)\n+\tdiags = diags.Append(err)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// validate self ref\n+\tdiags = diags.Append(validateSelfRef(addr.Resource, config.Config, providerSchema))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\tkeyData := EvalDataForInstanceKey(addr.Resource.Key, nil)\n+\tif config.ForEach != nil {\n+\t\tforEach, _, _ := evaluateForEachExpression(config.ForEach, ctx, false)\n+\t\tkeyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)\n+\t}\n+\n+\t// evaluate the list config block\n+\tvar configDiags tfdiags.Diagnostics\n+\tconfigVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)\n+\tdiags = diags.Append(configDiags)\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// Unmark before sending to provider\n+\tunmarkedConfigVal, _ := configVal.UnmarkDeepWithPaths()\n+\tconfigKnown := configVal.IsWhollyKnown()\n+\tif !configKnown {\n+\t\tdiags = diags.Append(fmt.Errorf(\"config is not known\"))\n+\t\treturn diags\n+\t}\n+\n+\tlog.Printf(\"[TRACE] NodePlannableResourceInstance: Re-validating config for %s\", n.Addr)\n+\tvalidateResp := provider.ValidateListResourceConfig(\n+\t\tproviders.ValidateListResourceConfigRequest{\n+\t\t\tTypeName: n.Config.Type,\n+\t\t\tConfig:   unmarkedConfigVal,\n+\t\t},\n+\t)\n+\tdiags = diags.Append(validateResp.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\tif diags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\t// If we get down here then our configuration is complete and we're ready\n+\t// to actually call the provider to list the data.\n+\tresp, err := provider.ListResource(providers.ListResourceRequest{\n+\t\tTypeName: n.Config.Type,\n+\t\tConfig:   unmarkedConfigVal,\n+\t})\n+\tif err != nil {\n+\t\treturn diags.Append(fmt.Errorf(\"failed to list %s: %s\", n.Addr, err))\n+\t}\n+\n+\tresources := make([]cty.Value, 0)\n+\tidentities := make([]cty.Value, 0)\n+\n+\tfor evt := range resp {\n+\t\tif evt.Diagnostics.HasErrors() {\n+\t\t\treturn diags.Append(evt.Diagnostics.InConfigBody(config.Config, n.Addr.String()))\n+\t\t}\n+\t\tresources = append(resources, evt.ResourceObject)\n+\t\tidentities = append(identities, evt.Identity)\n+\t}\n+\n+\tvar vals, ids cty.Value\n+\tif len(resources) > 0 {\n+\t\tvals = cty.ListVal(resources)\n+\t\tids = cty.ListVal(identities)\n+\t} else {\n+\t\tvals = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t\tids = cty.ListValEmpty(cty.Object(map[string]cty.Type{}))\n+\t}\n+\n+\tctx.State().SetListResourceInstance(n.Addr, &states.ResourceInstanceObject{\n+\t\tValue:    vals,",
        "comment_created_at": "2025-05-22T16:51:43+00:00",
        "comment_author": "jbardin",
        "comment_body": "The alternative from a consistency point of view is to explicitly name the config block:\r\n```\r\nlist \"provider_thing\" \"resources\" {\r\n  config {\r\n    data = [\"some\", \"data\"]\r\n  }\r\n}\r\n```\r\nWe discussed how that is different from normal resources too, but maybe because list resource always have these \"computed attributes\" containing the results they just have to be different",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1984798820",
    "pr_number": 36464,
    "pr_file": "internal/providers/provider.go",
    "created_at": "2025-03-07T10:11:39+00:00",
    "commented_code": "ServerCapabilities ServerCapabilities\n }\n \n+// GetResourceIdentitySchemasResponse is the return type for GetProviderSchema, and\n+// should only be used when handling a value for that method. The handling of\n+// of schemas in any other context should always use ProviderSchema, so that\n+// the in-memory representation can be more easily changed separately from the\n+// RCP protocol.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1984798820",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36464,
        "pr_file": "internal/providers/provider.go",
        "discussion_id": "1984798820",
        "commented_code": "@@ -127,6 +137,25 @@ type GetProviderSchemaResponse struct {\n \tServerCapabilities ServerCapabilities\n }\n \n+// GetResourceIdentitySchemasResponse is the return type for GetProviderSchema, and\n+// should only be used when handling a value for that method. The handling of\n+// of schemas in any other context should always use ProviderSchema, so that\n+// the in-memory representation can be more easily changed separately from the\n+// RCP protocol.",
        "comment_created_at": "2025-03-07T10:11:39+00:00",
        "comment_author": "dsa0x",
        "comment_body": "```suggestion\r\n// GetResourceIdentitySchemasResponse is the return type for GetResourceIdentitySchemas, and\r\n// should only be used when handling a value for that method. The handling of\r\n// of schemas in any other context should always use ResourceIdentitySchemas, so that\r\n// the in-memory representation can be more easily changed separately from the\r\n// RPC protocol.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]