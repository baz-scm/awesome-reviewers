[
  {
    "discussion_id": "2192408475",
    "pr_number": 37006,
    "pr_file": "internal/providers/provider.go",
    "created_at": "2025-07-08T12:39:54+00:00",
    "commented_code": "Body *configschema.Object\n }\n \n+type ExecutionOrder int\n+\n+const (\n+\tExecutionOrderInvalid ExecutionOrder = iota\n+\tExecutionOrderBefore\n+\tExecutionOrderAfter\n+)\n+\n+type LinkedResourceSchema struct {\n+\tTypeName string\n+}\n+\n+type UnlinkedAction struct{}\n+type LifecycleAction struct {\n+\tExectues       ExecutionOrder\n+\tLinkedResource LinkedResourceSchema\n+}\n+type LinkedAction struct {\n+\tLinkedResources []LinkedResourceSchema\n+}\n+type ActionSchema struct {\n+\tConfigSchema *configschema.Block\n+\n+\t// One of the following fields must be set, indicating the type of action.\n+\tUnlinked  *UnlinkedAction\n+\tLifecycle *LifecycleAction\n+\tLinked    *LinkedAction\n+}\n+\n+func (a ActionSchema) LinkedResources() []LinkedResourceSchema {",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2192408475",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37006,
        "pr_file": "internal/providers/provider.go",
        "discussion_id": "2192408475",
        "commented_code": "@@ -184,6 +197,48 @@ type IdentitySchema struct {\n \tBody *configschema.Object\n }\n \n+type ExecutionOrder int\n+\n+const (\n+\tExecutionOrderInvalid ExecutionOrder = iota\n+\tExecutionOrderBefore\n+\tExecutionOrderAfter\n+)\n+\n+type LinkedResourceSchema struct {\n+\tTypeName string\n+}\n+\n+type UnlinkedAction struct{}\n+type LifecycleAction struct {\n+\tExectues       ExecutionOrder\n+\tLinkedResource LinkedResourceSchema\n+}\n+type LinkedAction struct {\n+\tLinkedResources []LinkedResourceSchema\n+}\n+type ActionSchema struct {\n+\tConfigSchema *configschema.Block\n+\n+\t// One of the following fields must be set, indicating the type of action.\n+\tUnlinked  *UnlinkedAction\n+\tLifecycle *LifecycleAction\n+\tLinked    *LinkedAction\n+}\n+\n+func (a ActionSchema) LinkedResources() []LinkedResourceSchema {",
        "comment_created_at": "2025-07-08T12:39:54+00:00",
        "comment_author": "mildwonkey",
        "comment_body": "More nitpicky stuff - fine to leave this as-is, but I want to see what you think: \r\n\r\nDid you consider returning `nil` for Unlinked actions? That is a simpler check than checking the length of the returned value, and gives us a(nother) easy way to know we're dealing with an unlinked action. \r\n\r\nDo you expect that terraform will already know when it's dealing with an unlinked action, and therefore won't bother calling this method, or do you expect it gets called on every action? If it's the latter, I'd suggested making the return value a pointer so we can return nil for unlinked. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2020647752",
    "pr_number": 36703,
    "pr_file": "internal/command/views/hook_ui.go",
    "created_at": "2025-03-31T08:58:33+00:00",
    "commented_code": "return terraform.HookActionContinue, nil\n }\n \n-func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importID string) (terraform.HookAction, error) {\n-\th.println(fmt.Sprintf(\n-\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n-\t\tid.Addr, importID,\n-\t))\n+func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importTarget cty.Value) (terraform.HookAction, error) {\n+\tif importTarget.Type().IsObjectType() {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [identity=%s]\"),\n+\t\t\tid.Addr, importTarget.GoString(), // TODO improve\n+\t\t))\n+\t} else {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n+\t\t\tid.Addr, importTarget.AsString(),",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2020647752",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36703,
        "pr_file": "internal/command/views/hook_ui.go",
        "discussion_id": "2020647752",
        "commented_code": "@@ -323,11 +323,19 @@ func (h *UiHook) PostImportState(id terraform.HookResourceIdentity, imported []p\n \treturn terraform.HookActionContinue, nil\n }\n \n-func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importID string) (terraform.HookAction, error) {\n-\th.println(fmt.Sprintf(\n-\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n-\t\tid.Addr, importID,\n-\t))\n+func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importTarget cty.Value) (terraform.HookAction, error) {\n+\tif importTarget.Type().IsObjectType() {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [identity=%s]\"),\n+\t\t\tid.Addr, importTarget.GoString(), // TODO improve\n+\t\t))\n+\t} else {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n+\t\t\tid.Addr, importTarget.AsString(),",
        "comment_created_at": "2025-03-31T08:58:33+00:00",
        "comment_author": "dsa0x",
        "comment_body": "would this not panic if the value is not cty.String?",
        "pr_file_module": null
      },
      {
        "comment_id": "2020984173",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36703,
        "pr_file": "internal/command/views/hook_ui.go",
        "discussion_id": "2020647752",
        "commented_code": "@@ -323,11 +323,19 @@ func (h *UiHook) PostImportState(id terraform.HookResourceIdentity, imported []p\n \treturn terraform.HookActionContinue, nil\n }\n \n-func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importID string) (terraform.HookAction, error) {\n-\th.println(fmt.Sprintf(\n-\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n-\t\tid.Addr, importID,\n-\t))\n+func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importTarget cty.Value) (terraform.HookAction, error) {\n+\tif importTarget.Type().IsObjectType() {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [identity=%s]\"),\n+\t\t\tid.Addr, importTarget.GoString(), // TODO improve\n+\t\t))\n+\t} else {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n+\t\t\tid.Addr, importTarget.AsString(),",
        "comment_created_at": "2025-03-31T12:49:02+00:00",
        "comment_author": "dbanck",
        "comment_body": "It _should_ be an object or string at this point. But you're right, if it's something that doesn't implement `AsString`, this would panic. Do you think we should be more defensive here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2021139173",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36703,
        "pr_file": "internal/command/views/hook_ui.go",
        "discussion_id": "2020647752",
        "commented_code": "@@ -323,11 +323,19 @@ func (h *UiHook) PostImportState(id terraform.HookResourceIdentity, imported []p\n \treturn terraform.HookActionContinue, nil\n }\n \n-func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importID string) (terraform.HookAction, error) {\n-\th.println(fmt.Sprintf(\n-\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n-\t\tid.Addr, importID,\n-\t))\n+func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importTarget cty.Value) (terraform.HookAction, error) {\n+\tif importTarget.Type().IsObjectType() {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [identity=%s]\"),\n+\t\t\tid.Addr, importTarget.GoString(), // TODO improve\n+\t\t))\n+\t} else {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n+\t\t\tid.Addr, importTarget.AsString(),",
        "comment_created_at": "2025-03-31T14:15:44+00:00",
        "comment_author": "jbardin",
        "comment_body": "anything that is not a `cty.String` will panic in `AsString()`, so an object here isn't going to work. \r\n```\r\n\tif val.ty != String {\r\n\t\tpanic(\"not a string\")\r\n\t}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2021143107",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36703,
        "pr_file": "internal/command/views/hook_ui.go",
        "discussion_id": "2020647752",
        "commented_code": "@@ -323,11 +323,19 @@ func (h *UiHook) PostImportState(id terraform.HookResourceIdentity, imported []p\n \treturn terraform.HookActionContinue, nil\n }\n \n-func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importID string) (terraform.HookAction, error) {\n-\th.println(fmt.Sprintf(\n-\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n-\t\tid.Addr, importID,\n-\t))\n+func (h *UiHook) PrePlanImport(id terraform.HookResourceIdentity, importTarget cty.Value) (terraform.HookAction, error) {\n+\tif importTarget.Type().IsObjectType() {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [identity=%s]\"),\n+\t\t\tid.Addr, importTarget.GoString(), // TODO improve\n+\t\t))\n+\t} else {\n+\t\th.println(fmt.Sprintf(\n+\t\t\th.view.colorize.Color(\"[reset][bold]%s: Preparing import... [id=%s]\"),\n+\t\t\tid.Addr, importTarget.AsString(),",
        "comment_created_at": "2025-03-31T14:18:06+00:00",
        "comment_author": "dsa0x",
        "comment_body": "There seem to be a preceding conditional that handled the object type, but I dont have opinion on if the defensiveness is needed, or this is just fine",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2021167173",
    "pr_number": 36703,
    "pr_file": "internal/plans/changes.go",
    "created_at": "2025-03-31T14:29:04+00:00",
    "commented_code": "if i == nil {\n \t\treturn nil\n \t}\n-\tif i.ID.IsKnown() {\n-\t\treturn &ImportingSrc{\n-\t\t\tID: i.ID.AsString(),\n+\tif i.Target.IsKnown() {",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2021167173",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36703,
        "pr_file": "internal/plans/changes.go",
        "discussion_id": "2021167173",
        "commented_code": "@@ -560,9 +560,15 @@ func (i *Importing) Encode() *ImportingSrc {\n \tif i == nil {\n \t\treturn nil\n \t}\n-\tif i.ID.IsKnown() {\n-\t\treturn &ImportingSrc{\n-\t\t\tID: i.ID.AsString(),\n+\tif i.Target.IsKnown() {",
        "comment_created_at": "2025-03-31T14:29:04+00:00",
        "comment_author": "jbardin",
        "comment_body": "This needs to be `IsWhollyKnown`, because it would be the nested attributes which are not known.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2021177868",
    "pr_number": 36703,
    "pr_file": "internal/terraform/eval_import.go",
    "created_at": "2025-03-31T14:35:23+00:00",
    "commented_code": "return importIdVal, diags\n }\n \n+// evaluateImportIdentityExpression evaluates the given expression to determine the\n+// import identity for a resource. It uses the resource identity schema to validate\n+// the structure of the object..\n+//\n+// The given expression must be non-nil or the function will panic.\n+func evaluateImportIdentityExpression(expr hcl.Expression, identity *configschema.Object, ctx EvalContext, keyData instances.RepetitionData, allowUnknown bool) (cty.Value, tfdiags.Diagnostics) {\n+\tvar diags tfdiags.Diagnostics\n+\n+\t// import blocks only exist in the root module, and must be evaluated in\n+\t// that context.\n+\tctx = evalContextForModuleInstance(ctx, addrs.RootModuleInstance)\n+\tscope := ctx.EvaluationScope(nil, nil, keyData)\n+\timportIdentityVal, evalDiags := scope.EvalExpr(expr, identity.ImpliedType())\n+\tif evalDiags.HasErrors() {\n+\t\t// TODO? Do we need to improve the error message?\n+\t\treturn cty.NilVal, evalDiags\n+\t}\n+\n+\tif importIdentityVal.IsNull() {\n+\t\treturn cty.NilVal, diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Invalid import identity argument\",\n+\t\t\tDetail:   \"The import identity cannot be null.\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t}\n+\tif !allowUnknown && !importIdentityVal.IsKnown() {",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2021177868",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36703,
        "pr_file": "internal/terraform/eval_import.go",
        "discussion_id": "2021177868",
        "commented_code": "@@ -80,6 +76,49 @@ func evaluateImportIdExpression(expr hcl.Expression, ctx EvalContext, keyData in\n \treturn importIdVal, diags\n }\n \n+// evaluateImportIdentityExpression evaluates the given expression to determine the\n+// import identity for a resource. It uses the resource identity schema to validate\n+// the structure of the object..\n+//\n+// The given expression must be non-nil or the function will panic.\n+func evaluateImportIdentityExpression(expr hcl.Expression, identity *configschema.Object, ctx EvalContext, keyData instances.RepetitionData, allowUnknown bool) (cty.Value, tfdiags.Diagnostics) {\n+\tvar diags tfdiags.Diagnostics\n+\n+\t// import blocks only exist in the root module, and must be evaluated in\n+\t// that context.\n+\tctx = evalContextForModuleInstance(ctx, addrs.RootModuleInstance)\n+\tscope := ctx.EvaluationScope(nil, nil, keyData)\n+\timportIdentityVal, evalDiags := scope.EvalExpr(expr, identity.ImpliedType())\n+\tif evalDiags.HasErrors() {\n+\t\t// TODO? Do we need to improve the error message?\n+\t\treturn cty.NilVal, evalDiags\n+\t}\n+\n+\tif importIdentityVal.IsNull() {\n+\t\treturn cty.NilVal, diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Invalid import identity argument\",\n+\t\t\tDetail:   \"The import identity cannot be null.\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t}\n+\tif !allowUnknown && !importIdentityVal.IsKnown() {",
        "comment_created_at": "2025-03-31T14:35:23+00:00",
        "comment_author": "jbardin",
        "comment_body": "I think this also needs `IsWhollyKnown`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1987347669",
    "pr_number": 36646,
    "pr_file": "internal/moduletest/graph/apply.go",
    "created_at": "2025-03-10T13:59:59+00:00",
    "commented_code": "// actually updated by this change. We want to use the run that\n \t// most recently updated the tracked state as the cleanup\n \t// configuration.\n+\tif state := ctx.GetFileState(key); state.backend.instance != nil {\n+\t\tif state.backend.run.Name == run.Name {\n+\t\t\t// We've just done an apply for the run that contains the backend block.\n+\t\t\t// This run block is allowed to update the remote state if any changes have occurred, e.g:\n+\t\t\t//   1) Test is being run for the first time, and state is being created in the backend\n+\t\t\t//   2) Config changes mean that long-lived resources need to be updated, and state updated too.\n+\t\t\t//   3) Drift may have occurred, and this step of the test corrects remote objects to resemble config.\n+\t\t\tb := state.backend.instance\n+\t\t\tstateMgr, err := b.StateMgr(backend.DefaultStateName) // We only allow use of the default workspace\n+\t\t\tif err != nil {\n+\t\t\t\trun.Diagnostics.Append(tfdiags.Sourceless(\n+\t\t\t\t\ttfdiags.Error,\n+\t\t\t\t\tfmt.Sprintf(\"Error updating state in run block %q's backend\", state.backend.run.Name),\n+\t\t\t\t\terr.Error(),\n+\t\t\t\t))\n+\t\t\t}\n+\n+\t\t\terr = stateMgr.WriteState(updated)\n+\t\t\tif err != nil {\n+\t\t\t\trun.Diagnostics.Append(tfdiags.Sourceless(\n+\t\t\t\t\ttfdiags.Error,\n+\t\t\t\t\tfmt.Sprintf(\"Error updating state in run block %q's backend\", state.backend.run.Name),\n+\t\t\t\t\terr.Error(),\n+\t\t\t\t))\n+\t\t\t}\n+\n+\t\t}\n+\t}\n \tctx.SetFileState(key, &TestFileState{\n \t\tFile:  file,\n \t\tRun:   run,",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1987347669",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36646,
        "pr_file": "internal/moduletest/graph/apply.go",
        "discussion_id": "1987347669",
        "commented_code": "@@ -115,6 +119,34 @@ func (n *NodeTestRun) testApply(ctx *EvalContext, variables terraform.InputValue\n \t// actually updated by this change. We want to use the run that\n \t// most recently updated the tracked state as the cleanup\n \t// configuration.\n+\tif state := ctx.GetFileState(key); state.backend.instance != nil {\n+\t\tif state.backend.run.Name == run.Name {\n+\t\t\t// We've just done an apply for the run that contains the backend block.\n+\t\t\t// This run block is allowed to update the remote state if any changes have occurred, e.g:\n+\t\t\t//   1) Test is being run for the first time, and state is being created in the backend\n+\t\t\t//   2) Config changes mean that long-lived resources need to be updated, and state updated too.\n+\t\t\t//   3) Drift may have occurred, and this step of the test corrects remote objects to resemble config.\n+\t\t\tb := state.backend.instance\n+\t\t\tstateMgr, err := b.StateMgr(backend.DefaultStateName) // We only allow use of the default workspace\n+\t\t\tif err != nil {\n+\t\t\t\trun.Diagnostics.Append(tfdiags.Sourceless(\n+\t\t\t\t\ttfdiags.Error,\n+\t\t\t\t\tfmt.Sprintf(\"Error updating state in run block %q's backend\", state.backend.run.Name),\n+\t\t\t\t\terr.Error(),\n+\t\t\t\t))\n+\t\t\t}\n+\n+\t\t\terr = stateMgr.WriteState(updated)\n+\t\t\tif err != nil {\n+\t\t\t\trun.Diagnostics.Append(tfdiags.Sourceless(\n+\t\t\t\t\ttfdiags.Error,\n+\t\t\t\t\tfmt.Sprintf(\"Error updating state in run block %q's backend\", state.backend.run.Name),\n+\t\t\t\t\terr.Error(),\n+\t\t\t\t))\n+\t\t\t}\n+\n+\t\t}\n+\t}\n \tctx.SetFileState(key, &TestFileState{\n \t\tFile:  file,\n \t\tRun:   run,",
        "comment_created_at": "2025-03-10T13:59:59+00:00",
        "comment_author": "dsa0x",
        "comment_body": "This will replace the file state, but not include the run backend, and subsequent runs may then encounter nil objects, even though they were there in the beginning",
        "pr_file_module": null
      },
      {
        "comment_id": "1995471551",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36646,
        "pr_file": "internal/moduletest/graph/apply.go",
        "discussion_id": "1987347669",
        "commented_code": "@@ -115,6 +119,34 @@ func (n *NodeTestRun) testApply(ctx *EvalContext, variables terraform.InputValue\n \t// actually updated by this change. We want to use the run that\n \t// most recently updated the tracked state as the cleanup\n \t// configuration.\n+\tif state := ctx.GetFileState(key); state.backend.instance != nil {\n+\t\tif state.backend.run.Name == run.Name {\n+\t\t\t// We've just done an apply for the run that contains the backend block.\n+\t\t\t// This run block is allowed to update the remote state if any changes have occurred, e.g:\n+\t\t\t//   1) Test is being run for the first time, and state is being created in the backend\n+\t\t\t//   2) Config changes mean that long-lived resources need to be updated, and state updated too.\n+\t\t\t//   3) Drift may have occurred, and this step of the test corrects remote objects to resemble config.\n+\t\t\tb := state.backend.instance\n+\t\t\tstateMgr, err := b.StateMgr(backend.DefaultStateName) // We only allow use of the default workspace\n+\t\t\tif err != nil {\n+\t\t\t\trun.Diagnostics.Append(tfdiags.Sourceless(\n+\t\t\t\t\ttfdiags.Error,\n+\t\t\t\t\tfmt.Sprintf(\"Error updating state in run block %q's backend\", state.backend.run.Name),\n+\t\t\t\t\terr.Error(),\n+\t\t\t\t))\n+\t\t\t}\n+\n+\t\t\terr = stateMgr.WriteState(updated)\n+\t\t\tif err != nil {\n+\t\t\t\trun.Diagnostics.Append(tfdiags.Sourceless(\n+\t\t\t\t\ttfdiags.Error,\n+\t\t\t\t\tfmt.Sprintf(\"Error updating state in run block %q's backend\", state.backend.run.Name),\n+\t\t\t\t\terr.Error(),\n+\t\t\t\t))\n+\t\t\t}\n+\n+\t\t}\n+\t}\n \tctx.SetFileState(key, &TestFileState{\n \t\tFile:  file,\n \t\tRun:   run,",
        "comment_created_at": "2025-03-14T12:33:12+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "I think we'll always need a check for whether a backend is used at all. Currently as `backend` is not a pointer it cannot be nil, but the values inside can be nil. Currently the code checks that the backend.instance value isn't nil:\r\n\r\nhttps://github.com/hashicorp/terraform/blob/44189127ef5a096b9051f2f70553222fd9b72220/internal/moduletest/graph/apply.go#L73-L77\r\n\r\nWould it be better to set the `backend` field to be a pointer instead, and perform a nil check there?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1923958722",
    "pr_number": 36300,
    "pr_file": "internal/configs/test_file.go",
    "created_at": "2025-01-21T15:42:26+00:00",
    "commented_code": "// order.\n \tRuns []*TestRun\n \n+\tConfig          TestFileConfig",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1923958722",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36300,
        "pr_file": "internal/configs/test_file.go",
        "discussion_id": "1923958722",
        "commented_code": "@@ -66,6 +66,9 @@ type TestFile struct {\n \t// order.\n \tRuns []*TestRun\n \n+\tConfig          TestFileConfig",
        "comment_created_at": "2025-01-21T15:42:26+00:00",
        "comment_author": "liamcervante",
        "comment_body": "I'd make this a pointer, so we know whether it has been included or not later.",
        "pr_file_module": null
      }
    ]
  }
]