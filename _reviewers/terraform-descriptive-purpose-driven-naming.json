[
  {
    "discussion_id": "2190641650",
    "pr_number": 37287,
    "pr_file": "internal/addrs/action.go",
    "created_at": "2025-07-07T16:59:21+00:00",
    "commented_code": "type configActionKey string\n \n func (k configActionKey) uniqueKeySigil() {}\n+\n+// ActionInvocation describes the invocation of an action as part of a plan / apply.\n+type ActionInvocation struct {\n+\tTriggeringResource AbsResourceInstance\n+\tAction             AbsActionInstance\n+\tTriggerIndex       int",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2190641650",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37287,
        "pr_file": "internal/addrs/action.go",
        "discussion_id": "2190641650",
        "commented_code": "@@ -327,3 +329,22 @@ func (a ConfigAction) UniqueKey() UniqueKey {\n type configActionKey string\n \n func (k configActionKey) uniqueKeySigil() {}\n+\n+// ActionInvocation describes the invocation of an action as part of a plan / apply.\n+type ActionInvocation struct {\n+\tTriggeringResource AbsResourceInstance\n+\tAction             AbsActionInstance\n+\tTriggerIndex       int",
        "comment_created_at": "2025-07-07T16:59:21+00:00",
        "comment_author": "mildwonkey",
        "comment_body": "Since this is using absolute references, I'd name this something like AbsActionInvocation / ActionInvocationAbs/ whatever. And since you've got the trigger index in here, I'd even consider adding instance: AbsActionInvocationInstance. That name makes it much more obvious to other developers that this is referring to a single specific instance of an {Action & ActionTrigger} \r\n\r\nFor more context, I say this because at first I was going to point out that a given action could have multiple triggering resources, which is roughly when I realized that was the point of this struct, and we already have naming conventions that can be repurposed for this context!) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2191893722",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37287,
        "pr_file": "internal/addrs/action.go",
        "discussion_id": "2190641650",
        "commented_code": "@@ -327,3 +329,22 @@ func (a ConfigAction) UniqueKey() UniqueKey {\n type configActionKey string\n \n func (k configActionKey) uniqueKeySigil() {}\n+\n+// ActionInvocation describes the invocation of an action as part of a plan / apply.\n+type ActionInvocation struct {\n+\tTriggeringResource AbsResourceInstance\n+\tAction             AbsActionInstance\n+\tTriggerIndex       int",
        "comment_created_at": "2025-07-08T08:54:16+00:00",
        "comment_author": "DanielMSchmidt",
        "comment_body": "Yeah that makes sense, I didn't consider all the other varieties of this to come \ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160708225",
    "pr_number": 37246,
    "pr_file": "internal/command/workdir/config_state.go",
    "created_at": "2025-06-23T04:48:39+00:00",
    "commented_code": "import (\n \t\"github.com/hashicorp/terraform/internal/configs/configschema\"\n-\t\"github.com/hashicorp/terraform/internal/plans\"\n \t\"github.com/zclconf/go-cty/cty\"\n )\n \n // ConfigState describes a configuration block, and is used to make that config block stateful.\n-type ConfigState[T any] interface {\n+type ConfigState interface {\n \tEmpty() bool\n \tConfig(*configschema.Block) (cty.Value, error)\n \tSetConfig(cty.Value, *configschema.Block) error\n-\tForPlan(*configschema.Block, string) (*plans.Backend, error)\n+}\n+\n+// DeepCopier implementations can return deep copies of themselves for use elsewhere\n+// without mutating the original value.\n+type DeepCopier[T any] interface {\n \tDeepCopy() *T\n }\n+\n+// Planner implementations can return a representation of their data that's\n+// appropriate for storing in a plan file.\n+type Planner[T any] interface {\n+\tPlan(*configschema.Block, string) (*T, error)\n+}",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2160708225",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37246,
        "pr_file": "internal/command/workdir/config_state.go",
        "discussion_id": "2160708225",
        "commented_code": "@@ -5,15 +5,24 @@ package workdir\n \n import (\n \t\"github.com/hashicorp/terraform/internal/configs/configschema\"\n-\t\"github.com/hashicorp/terraform/internal/plans\"\n \t\"github.com/zclconf/go-cty/cty\"\n )\n \n // ConfigState describes a configuration block, and is used to make that config block stateful.\n-type ConfigState[T any] interface {\n+type ConfigState interface {\n \tEmpty() bool\n \tConfig(*configschema.Block) (cty.Value, error)\n \tSetConfig(cty.Value, *configschema.Block) error\n-\tForPlan(*configschema.Block, string) (*plans.Backend, error)\n+}\n+\n+// DeepCopier implementations can return deep copies of themselves for use elsewhere\n+// without mutating the original value.\n+type DeepCopier[T any] interface {\n \tDeepCopy() *T\n }\n+\n+// Planner implementations can return a representation of their data that's\n+// appropriate for storing in a plan file.\n+type Planner[T any] interface {\n+\tPlan(*configschema.Block, string) (*T, error)\n+}",
        "comment_created_at": "2025-06-23T04:48:39+00:00",
        "comment_author": "radeksimko",
        "comment_body": "I find the names Planner and Plan a little misleading here since the interface does not describe any kind of _planning_ but data conversion for the plan file.\r\n\r\nI'm not married to a particular name but just throwing an idea here:\r\n\r\n```go\r\ntype PlanDataProvider[T any] interface {\r\n\tPlanData(schema *configschema.Block, workspaceName string) (*T, error)\r\n}\r\n```\r\nMaybe we can come up with something different.\r\n\r\nOn a related note - I think it would help to use the argument names in the interface to further clarify what the `string` is for without having to look at the implementations.",
        "pr_file_module": null
      },
      {
        "comment_id": "2162132540",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 37246,
        "pr_file": "internal/command/workdir/config_state.go",
        "discussion_id": "2160708225",
        "commented_code": "@@ -5,15 +5,24 @@ package workdir\n \n import (\n \t\"github.com/hashicorp/terraform/internal/configs/configschema\"\n-\t\"github.com/hashicorp/terraform/internal/plans\"\n \t\"github.com/zclconf/go-cty/cty\"\n )\n \n // ConfigState describes a configuration block, and is used to make that config block stateful.\n-type ConfigState[T any] interface {\n+type ConfigState interface {\n \tEmpty() bool\n \tConfig(*configschema.Block) (cty.Value, error)\n \tSetConfig(cty.Value, *configschema.Block) error\n-\tForPlan(*configschema.Block, string) (*plans.Backend, error)\n+}\n+\n+// DeepCopier implementations can return deep copies of themselves for use elsewhere\n+// without mutating the original value.\n+type DeepCopier[T any] interface {\n \tDeepCopy() *T\n }\n+\n+// Planner implementations can return a representation of their data that's\n+// appropriate for storing in a plan file.\n+type Planner[T any] interface {\n+\tPlan(*configschema.Block, string) (*T, error)\n+}",
        "comment_created_at": "2025-06-23T17:39:58+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "Good point re: argument names.\r\n\r\nI've adopted the new name idea as it feels more correct than Planner/Plan. Making an interface name backwards from `ForPlan` felt like a losing battle so I tried to keep it simple, but I agree Planner isn't strictly true. Naming is hard!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967540275",
    "pr_number": 36482,
    "pr_file": "internal/collections/set.go",
    "created_at": "2025-02-24T12:18:51+00:00",
    "commented_code": "}\n }\n \n+// Merge inserts all the members of vs into the set.\n+//\n+// The behavior is the same as calling Add for each member of vs.\n+func (s Set[T]) Merge(vs Set[T]) {",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1967540275",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36482,
        "pr_file": "internal/collections/set.go",
        "discussion_id": "1967540275",
        "commented_code": "@@ -76,6 +76,15 @@ func (s Set[T]) Add(vs ...T) {\n \t}\n }\n \n+// Merge inserts all the members of vs into the set.\n+//\n+// The behavior is the same as calling Add for each member of vs.\n+func (s Set[T]) Merge(vs Set[T]) {",
        "comment_created_at": "2025-02-24T12:18:51+00:00",
        "comment_author": "liamcervante",
        "comment_body": "Can we call this `AddAll` or something? I feel like `Merge` implies both of the original sets will be unchanged and new third set with everything will be created, which isn't happening here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1907597678",
    "pr_number": 30121,
    "pr_file": "internal/backend/remote-state/s3/backend.go",
    "created_at": "2025-01-08T18:10:32+00:00",
    "commented_code": "Default:     \"\",\n \t\t\t},\n \n+\t\t\t\"tags\": {",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1907597678",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 30121,
        "pr_file": "internal/backend/remote-state/s3/backend.go",
        "discussion_id": "1907597678",
        "commented_code": "@@ -93,6 +93,13 @@ func New() backend.Backend {\n \t\t\t\tDefault:     \"\",\n \t\t\t},\n \n+\t\t\t\"tags\": {",
        "comment_created_at": "2025-01-08T18:10:32+00:00",
        "comment_author": "bschaatsbergen",
        "comment_body": "It might be worth considering renaming this argument to `object_tags` or bring it under an `object` block to clearly indicate where the tags are being applied. Have you thought about this already?\r\n\r\nAdded, I think that a more Terraform-native approach is cleaner than a string of tags, in a way similar to the `tags` block used for AWS provider-managed resources:\r\n\r\n```hcl\r\nobject_tags = {\r\n  Environment = \"Test\"\r\n}\r\n```\r\n\r\nSee the existing `assume_role` block schema, already featuring `tags`. I would imagine that this simply uses `cty.Map(cty.String)`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1932524650",
    "pr_number": 36258,
    "pr_file": "internal/backend/remote-state/azure/api_client.go",
    "created_at": "2025-01-28T16:48:29+00:00",
    "commented_code": "+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package azure\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids\"\n+\t\"github.com/hashicorp/go-azure-sdk/resource-manager/storage/2023-01-01/storageaccounts\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/auth\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/client\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/environments\"\n+\t\"github.com/hashicorp/terraform/internal/httpclient\"\n+\t\"github.com/hashicorp/terraform/version\"\n+\t\"github.com/jackofallops/giovanni/storage/2023-11-03/blob/blobs\"\n+\t\"github.com/jackofallops/giovanni/storage/2023-11-03/blob/containers\"\n+)\n+\n+type Client struct {\n+\t// These Clients are only initialized if an Access Key isn't provided\n+\tstorageAccountsClient *storageaccounts.StorageAccountsClient\n+\n+\t// Caching\n+\tcontainersClient *containers.Client\n+\tblobsClient      *blobs.Client\n+\n+\tenvironment        environments.Environment\n+\tstorageAccountName string\n+\n+\taccountDetail *AccountDetails\n+\n+\taccessKey string\n+\tsasToken  string\n+\t// azureAdStorageAuth is only here if we're using AzureAD Authentication but is an Authorizer for Storage\n+\tazureAdStorageAuth auth.Authorizer\n+}\n+\n+func buildClient(ctx context.Context, config BackendConfig) (*Client, error) {\n+\tclient := Client{\n+\t\tenvironment:        config.AuthConfig.Environment,\n+\t\tstorageAccountName: config.StorageAccountName,\n+\t}\n+\n+\t// if we have an Access Key - we don't need the other clients\n+\tif config.AccessKey != \"\" {\n+\t\tclient.accessKey = config.AccessKey\n+\t\treturn &client, nil\n+\t}\n+\n+\t// likewise with a SAS token\n+\tif config.SasToken != \"\" {\n+\t\tsasToken := config.SasToken\n+\t\tif strings.TrimSpace(sasToken) == \"\" {\n+\t\t\treturn nil, fmt.Errorf(\"sasToken cannot be empty\")\n+\t\t}\n+\t\tclient.sasToken = strings.TrimPrefix(sasToken, \"?\")\n+\n+\t\treturn &client, nil\n+\t}\n+\n+\tif config.UseAzureADAuthentication {\n+\t\tvar err error\n+\t\tclient.azureAdStorageAuth, err = auth.NewAuthorizerFromCredentials(ctx, *config.AuthConfig, config.AuthConfig.Environment.Storage)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"unable to build authorizer for Storage API: %+v\", err)\n+\t\t}\n+\t}\n+\n+\tresourceManagerAuth, err := auth.NewAuthorizerFromCredentials(ctx, *config.AuthConfig, config.AuthConfig.Environment.ResourceManager)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"unable to build authorizer for Resource Manager API: %+v\", err)\n+\t}\n+\n+\tclient.storageAccountsClient, err = storageaccounts.NewStorageAccountsClientWithBaseURI(config.AuthConfig.Environment.ResourceManager)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"building Storage Accounts client: %+v\", err)\n+\t}\n+\tclient.configureClient(client.storageAccountsClient.Client, resourceManagerAuth)\n+\n+\t// Populating the storage account detail\n+\tsaid := commonids.NewStorageAccountID(config.SubscriptionID, config.ResourceGroupName, client.storageAccountName)",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1932524650",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36258,
        "pr_file": "internal/backend/remote-state/azure/api_client.go",
        "discussion_id": "1932524650",
        "commented_code": "@@ -0,0 +1,291 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package azure\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids\"\n+\t\"github.com/hashicorp/go-azure-sdk/resource-manager/storage/2023-01-01/storageaccounts\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/auth\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/client\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/environments\"\n+\t\"github.com/hashicorp/terraform/internal/httpclient\"\n+\t\"github.com/hashicorp/terraform/version\"\n+\t\"github.com/jackofallops/giovanni/storage/2023-11-03/blob/blobs\"\n+\t\"github.com/jackofallops/giovanni/storage/2023-11-03/blob/containers\"\n+)\n+\n+type Client struct {\n+\t// These Clients are only initialized if an Access Key isn't provided\n+\tstorageAccountsClient *storageaccounts.StorageAccountsClient\n+\n+\t// Caching\n+\tcontainersClient *containers.Client\n+\tblobsClient      *blobs.Client\n+\n+\tenvironment        environments.Environment\n+\tstorageAccountName string\n+\n+\taccountDetail *AccountDetails\n+\n+\taccessKey string\n+\tsasToken  string\n+\t// azureAdStorageAuth is only here if we're using AzureAD Authentication but is an Authorizer for Storage\n+\tazureAdStorageAuth auth.Authorizer\n+}\n+\n+func buildClient(ctx context.Context, config BackendConfig) (*Client, error) {\n+\tclient := Client{\n+\t\tenvironment:        config.AuthConfig.Environment,\n+\t\tstorageAccountName: config.StorageAccountName,\n+\t}\n+\n+\t// if we have an Access Key - we don't need the other clients\n+\tif config.AccessKey != \"\" {\n+\t\tclient.accessKey = config.AccessKey\n+\t\treturn &client, nil\n+\t}\n+\n+\t// likewise with a SAS token\n+\tif config.SasToken != \"\" {\n+\t\tsasToken := config.SasToken\n+\t\tif strings.TrimSpace(sasToken) == \"\" {\n+\t\t\treturn nil, fmt.Errorf(\"sasToken cannot be empty\")\n+\t\t}\n+\t\tclient.sasToken = strings.TrimPrefix(sasToken, \"?\")\n+\n+\t\treturn &client, nil\n+\t}\n+\n+\tif config.UseAzureADAuthentication {\n+\t\tvar err error\n+\t\tclient.azureAdStorageAuth, err = auth.NewAuthorizerFromCredentials(ctx, *config.AuthConfig, config.AuthConfig.Environment.Storage)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"unable to build authorizer for Storage API: %+v\", err)\n+\t\t}\n+\t}\n+\n+\tresourceManagerAuth, err := auth.NewAuthorizerFromCredentials(ctx, *config.AuthConfig, config.AuthConfig.Environment.ResourceManager)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"unable to build authorizer for Resource Manager API: %+v\", err)\n+\t}\n+\n+\tclient.storageAccountsClient, err = storageaccounts.NewStorageAccountsClientWithBaseURI(config.AuthConfig.Environment.ResourceManager)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"building Storage Accounts client: %+v\", err)\n+\t}\n+\tclient.configureClient(client.storageAccountsClient.Client, resourceManagerAuth)\n+\n+\t// Populating the storage account detail\n+\tsaid := commonids.NewStorageAccountID(config.SubscriptionID, config.ResourceGroupName, client.storageAccountName)",
        "comment_created_at": "2025-01-28T16:48:29+00:00",
        "comment_author": "mbfrahry",
        "comment_body": "`said` is a word. Could we please make this `storageAccountId` or something similar ",
        "pr_file_module": null
      },
      {
        "comment_id": "1933266730",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36258,
        "pr_file": "internal/backend/remote-state/azure/api_client.go",
        "discussion_id": "1932524650",
        "commented_code": "@@ -0,0 +1,291 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package azure\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids\"\n+\t\"github.com/hashicorp/go-azure-sdk/resource-manager/storage/2023-01-01/storageaccounts\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/auth\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/client\"\n+\t\"github.com/hashicorp/go-azure-sdk/sdk/environments\"\n+\t\"github.com/hashicorp/terraform/internal/httpclient\"\n+\t\"github.com/hashicorp/terraform/version\"\n+\t\"github.com/jackofallops/giovanni/storage/2023-11-03/blob/blobs\"\n+\t\"github.com/jackofallops/giovanni/storage/2023-11-03/blob/containers\"\n+)\n+\n+type Client struct {\n+\t// These Clients are only initialized if an Access Key isn't provided\n+\tstorageAccountsClient *storageaccounts.StorageAccountsClient\n+\n+\t// Caching\n+\tcontainersClient *containers.Client\n+\tblobsClient      *blobs.Client\n+\n+\tenvironment        environments.Environment\n+\tstorageAccountName string\n+\n+\taccountDetail *AccountDetails\n+\n+\taccessKey string\n+\tsasToken  string\n+\t// azureAdStorageAuth is only here if we're using AzureAD Authentication but is an Authorizer for Storage\n+\tazureAdStorageAuth auth.Authorizer\n+}\n+\n+func buildClient(ctx context.Context, config BackendConfig) (*Client, error) {\n+\tclient := Client{\n+\t\tenvironment:        config.AuthConfig.Environment,\n+\t\tstorageAccountName: config.StorageAccountName,\n+\t}\n+\n+\t// if we have an Access Key - we don't need the other clients\n+\tif config.AccessKey != \"\" {\n+\t\tclient.accessKey = config.AccessKey\n+\t\treturn &client, nil\n+\t}\n+\n+\t// likewise with a SAS token\n+\tif config.SasToken != \"\" {\n+\t\tsasToken := config.SasToken\n+\t\tif strings.TrimSpace(sasToken) == \"\" {\n+\t\t\treturn nil, fmt.Errorf(\"sasToken cannot be empty\")\n+\t\t}\n+\t\tclient.sasToken = strings.TrimPrefix(sasToken, \"?\")\n+\n+\t\treturn &client, nil\n+\t}\n+\n+\tif config.UseAzureADAuthentication {\n+\t\tvar err error\n+\t\tclient.azureAdStorageAuth, err = auth.NewAuthorizerFromCredentials(ctx, *config.AuthConfig, config.AuthConfig.Environment.Storage)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"unable to build authorizer for Storage API: %+v\", err)\n+\t\t}\n+\t}\n+\n+\tresourceManagerAuth, err := auth.NewAuthorizerFromCredentials(ctx, *config.AuthConfig, config.AuthConfig.Environment.ResourceManager)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"unable to build authorizer for Resource Manager API: %+v\", err)\n+\t}\n+\n+\tclient.storageAccountsClient, err = storageaccounts.NewStorageAccountsClientWithBaseURI(config.AuthConfig.Environment.ResourceManager)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"building Storage Accounts client: %+v\", err)\n+\t}\n+\tclient.configureClient(client.storageAccountsClient.Client, resourceManagerAuth)\n+\n+\t// Populating the storage account detail\n+\tsaid := commonids.NewStorageAccountID(config.SubscriptionID, config.ResourceGroupName, client.storageAccountName)",
        "comment_created_at": "2025-01-29T04:59:45+00:00",
        "comment_author": "magodo",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1904241799",
    "pr_number": 36227,
    "pr_file": "internal/configs/mock_provider.go",
    "created_at": "2025-01-06T14:47:12+00:00",
    "commented_code": "return override, diags\n }\n \n+var (\n+\t// When this attribute is set to true, the values specified in the override\n+\t// block will be used for computed attributes even when planning. Otherwise,\n+\t// the computed values will be set to unknown, just like in a real plan.\n+\toverrideComputed = \"override_computed\"",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1904241799",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36227,
        "pr_file": "internal/configs/mock_provider.go",
        "discussion_id": "1904241799",
        "commented_code": "@@ -393,12 +450,20 @@ func decodeOverrideDataBlock(block *hcl.Block, source OverrideSource) (*Override\n \treturn override, diags\n }\n \n+var (\n+\t// When this attribute is set to true, the values specified in the override\n+\t// block will be used for computed attributes even when planning. Otherwise,\n+\t// the computed values will be set to unknown, just like in a real plan.\n+\toverrideComputed = \"override_computed\"",
        "comment_created_at": "2025-01-06T14:47:12+00:00",
        "comment_author": "liamcervante",
        "comment_body": "We have the `command` attribute available in the run blocks: https://developer.hashicorp.com/terraform/language/tests#run-blocks\r\n\r\nI wonder if like `compute_command` that maps to a keyword of either `plan` or `apply` might be more clear about what is happening here? We can make it default to `apply`. \r\n\r\nI think that makes it a bit more clear about what the attribute is actually doing. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1905189208",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36227,
        "pr_file": "internal/configs/mock_provider.go",
        "discussion_id": "1904241799",
        "commented_code": "@@ -393,12 +450,20 @@ func decodeOverrideDataBlock(block *hcl.Block, source OverrideSource) (*Override\n \treturn override, diags\n }\n \n+var (\n+\t// When this attribute is set to true, the values specified in the override\n+\t// block will be used for computed attributes even when planning. Otherwise,\n+\t// the computed values will be set to unknown, just like in a real plan.\n+\toverrideComputed = \"override_computed\"",
        "comment_created_at": "2025-01-07T09:51:04+00:00",
        "comment_author": "dsa0x",
        "comment_body": "Thanks for the suggestion. I contemplated quite a bit on the right name to communicate what's going on here, and you are right that `override_computed` seems a bit unclear. However, I have similar thoughts about `compute_command`, especially the `compute` part. That may be confusing. What about `override_command/override_target/override_target_command = plan/apply`? From a user POV, they have defined the override, and want it to be applied. That it is a computed attribute is more subtle.",
        "pr_file_module": null
      },
      {
        "comment_id": "1905193735",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36227,
        "pr_file": "internal/configs/mock_provider.go",
        "discussion_id": "1904241799",
        "commented_code": "@@ -393,12 +450,20 @@ func decodeOverrideDataBlock(block *hcl.Block, source OverrideSource) (*Override\n \treturn override, diags\n }\n \n+var (\n+\t// When this attribute is set to true, the values specified in the override\n+\t// block will be used for computed attributes even when planning. Otherwise,\n+\t// the computed values will be set to unknown, just like in a real plan.\n+\toverrideComputed = \"override_computed\"",
        "comment_created_at": "2025-01-07T09:54:31+00:00",
        "comment_author": "liamcervante",
        "comment_body": "I like `override_command`, I think that could work. Another idea I had was `override_during` - as an attribute it doesn't make much sense on it's own, but when coupled with `apply` or `plan` then it brings a lot of context eg. `override_during = plan`.\r\n\r\nBut, `override_command` is also good I think \ud83d\udc4d  ",
        "pr_file_module": null
      }
    ]
  }
]