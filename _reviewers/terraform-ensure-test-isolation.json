[
  {
    "discussion_id": "2067149177",
    "pr_number": 36944,
    "pr_file": "internal/stacks/stackmigrate/meta_test.go",
    "created_at": "2025-04-29T18:51:09+00:00",
    "commented_code": "+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package stackmigrate\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"github.com/hashicorp/terraform/internal/backend/local\"\n+)\n+\n+// DefaultDataDir is the default directory for storing local data.\n+const DefaultDataDir = \".terraform\"\n+\n+func TestMeta_Workspace_override(t *testing.T) {\n+\tdefer func(value string) {\n+\t\tos.Setenv(WorkspaceNameEnvVar, value)\n+\t}(os.Getenv(WorkspaceNameEnvVar))\n+\n+\tm := new(Meta)\n+\n+\ttestCases := map[string]struct {\n+\t\tworkspace string\n+\t\terr       error\n+\t}{\n+\t\t\"\": {\n+\t\t\t\"default\",\n+\t\t\tnil,\n+\t\t},\n+\t\t\"development\": {\n+\t\t\t\"development\",\n+\t\t\tnil,\n+\t\t},\n+\t\t\"invalid name\": {\n+\t\t\t\"\",\n+\t\t\terrInvalidWorkspaceNameEnvVar,\n+\t\t},\n+\t}\n+\n+\tfor name, tc := range testCases {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tos.Setenv(WorkspaceNameEnvVar, name)\n+\t\t\tworkspace, err := m.Workspace()\n+\t\t\tif workspace != tc.workspace {\n+\t\t\t\tt.Errorf(\"Unexpected workspace\n got: %s\nwant: %s\n\", workspace, tc.workspace)\n+\t\t\t}\n+\t\t\tif err != tc.err {\n+\t\t\t\tt.Errorf(\"Unexpected error\n got: %s\nwant: %s\n\", err, tc.err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// If somehow an invalid workspace has been selected, the Meta.Workspace\n+// method should not return an error, to ensure that we don't break any\n+// existing workflows with invalid workspace names.\n+func TestMeta_Workspace_invalidSelected(t *testing.T) {\n+\ttd := t.TempDir()\n+\tos.MkdirAll(td, 0755)",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2067149177",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36944,
        "pr_file": "internal/stacks/stackmigrate/meta_test.go",
        "discussion_id": "2067149177",
        "commented_code": "@@ -0,0 +1,110 @@\n+// Copyright (c) HashiCorp, Inc.\n+// SPDX-License-Identifier: BUSL-1.1\n+\n+package stackmigrate\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\n+\t\"github.com/hashicorp/terraform/internal/backend/local\"\n+)\n+\n+// DefaultDataDir is the default directory for storing local data.\n+const DefaultDataDir = \".terraform\"\n+\n+func TestMeta_Workspace_override(t *testing.T) {\n+\tdefer func(value string) {\n+\t\tos.Setenv(WorkspaceNameEnvVar, value)\n+\t}(os.Getenv(WorkspaceNameEnvVar))\n+\n+\tm := new(Meta)\n+\n+\ttestCases := map[string]struct {\n+\t\tworkspace string\n+\t\terr       error\n+\t}{\n+\t\t\"\": {\n+\t\t\t\"default\",\n+\t\t\tnil,\n+\t\t},\n+\t\t\"development\": {\n+\t\t\t\"development\",\n+\t\t\tnil,\n+\t\t},\n+\t\t\"invalid name\": {\n+\t\t\t\"\",\n+\t\t\terrInvalidWorkspaceNameEnvVar,\n+\t\t},\n+\t}\n+\n+\tfor name, tc := range testCases {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tos.Setenv(WorkspaceNameEnvVar, name)\n+\t\t\tworkspace, err := m.Workspace()\n+\t\t\tif workspace != tc.workspace {\n+\t\t\t\tt.Errorf(\"Unexpected workspace\\n got: %s\\nwant: %s\\n\", workspace, tc.workspace)\n+\t\t\t}\n+\t\t\tif err != tc.err {\n+\t\t\t\tt.Errorf(\"Unexpected error\\n got: %s\\nwant: %s\\n\", err, tc.err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// If somehow an invalid workspace has been selected, the Meta.Workspace\n+// method should not return an error, to ensure that we don't break any\n+// existing workflows with invalid workspace names.\n+func TestMeta_Workspace_invalidSelected(t *testing.T) {\n+\ttd := t.TempDir()\n+\tos.MkdirAll(td, 0755)",
        "comment_created_at": "2025-04-29T18:51:09+00:00",
        "comment_author": "sebasslash",
        "comment_body": "`t.TempDir()` should create the directory w/ appropriate permissions, we don't need to call `os.MkdirAll()`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983032624",
    "pr_number": 36614,
    "pr_file": "internal/backend/local/test.go",
    "created_at": "2025-03-06T09:46:11+00:00",
    "commented_code": "// while test files in the test directory have access to the union of\n \t// GlobalVariables and GlobalTestVariables.\n \ttestDirectoryGlobalVariables := make(map[string]backendrun.UnparsedVariableValue)\n-\tfor name, value := range runner.GlobalVariables {\n-\t\ttestDirectoryGlobalVariables[name] = value\n-\t}\n-\tfor name, value := range runner.GlobalTestVariables {\n-\t\t// We're okay to overwrite the global variables in case of name\n-\t\t// collisions, as the test directory variables should take precedence.\n-\t\ttestDirectoryGlobalVariables[name] = value\n+\tmaps.Copy(testDirectoryGlobalVariables, runner.GlobalVariables)\n+\t// We're okay to overwrite the global variables in case of name\n+\t// collisions, as the test directory variables should take precedence.\n+\tmaps.Copy(testDirectoryGlobalVariables, runner.GlobalTestVariables)\n+\n+\t// Generate a manifest that will be used to track the state files created\n+\t// during the test runs.\n+\tmanifest, err := graph.BuildStateManifest(\".\", suite.Files)",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1983032624",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36614,
        "pr_file": "internal/backend/local/test.go",
        "discussion_id": "1983032624",
        "commented_code": "@@ -105,13 +106,16 @@ func (runner *TestSuiteRunner) Test() (moduletest.Status, tfdiags.Diagnostics) {\n \t// while test files in the test directory have access to the union of\n \t// GlobalVariables and GlobalTestVariables.\n \ttestDirectoryGlobalVariables := make(map[string]backendrun.UnparsedVariableValue)\n-\tfor name, value := range runner.GlobalVariables {\n-\t\ttestDirectoryGlobalVariables[name] = value\n-\t}\n-\tfor name, value := range runner.GlobalTestVariables {\n-\t\t// We're okay to overwrite the global variables in case of name\n-\t\t// collisions, as the test directory variables should take precedence.\n-\t\ttestDirectoryGlobalVariables[name] = value\n+\tmaps.Copy(testDirectoryGlobalVariables, runner.GlobalVariables)\n+\t// We're okay to overwrite the global variables in case of name\n+\t// collisions, as the test directory variables should take precedence.\n+\tmaps.Copy(testDirectoryGlobalVariables, runner.GlobalTestVariables)\n+\n+\t// Generate a manifest that will be used to track the state files created\n+\t// during the test runs.\n+\tmanifest, err := graph.BuildStateManifest(\".\", suite.Files)",
        "comment_created_at": "2025-03-06T09:46:11+00:00",
        "comment_author": "liamcervante",
        "comment_body": "I think we want to check if (a) the manifest already exists, and (b) has anything left in the state from a previous run and prevent the test from executing if that is the case. Essentially, you must have cleaned up any prior leftover state before we'll let you add more on.\r\n\r\nThat being said, I think this is a good starting point so you could totally merge this as is with a commitment to add that functionality in later. If you do that, you could add a TODO here and update the PR description to make it clear still a work in progress \ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "1983049007",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36614,
        "pr_file": "internal/backend/local/test.go",
        "discussion_id": "1983032624",
        "commented_code": "@@ -105,13 +106,16 @@ func (runner *TestSuiteRunner) Test() (moduletest.Status, tfdiags.Diagnostics) {\n \t// while test files in the test directory have access to the union of\n \t// GlobalVariables and GlobalTestVariables.\n \ttestDirectoryGlobalVariables := make(map[string]backendrun.UnparsedVariableValue)\n-\tfor name, value := range runner.GlobalVariables {\n-\t\ttestDirectoryGlobalVariables[name] = value\n-\t}\n-\tfor name, value := range runner.GlobalTestVariables {\n-\t\t// We're okay to overwrite the global variables in case of name\n-\t\t// collisions, as the test directory variables should take precedence.\n-\t\ttestDirectoryGlobalVariables[name] = value\n+\tmaps.Copy(testDirectoryGlobalVariables, runner.GlobalVariables)\n+\t// We're okay to overwrite the global variables in case of name\n+\t// collisions, as the test directory variables should take precedence.\n+\tmaps.Copy(testDirectoryGlobalVariables, runner.GlobalTestVariables)\n+\n+\t// Generate a manifest that will be used to track the state files created\n+\t// during the test runs.\n+\tmanifest, err := graph.BuildStateManifest(\".\", suite.Files)",
        "comment_created_at": "2025-03-06T09:56:10+00:00",
        "comment_author": "dsa0x",
        "comment_body": "I did make a follow-up JIRA ticket to ensure we do that, but having a TODO is also good way to keep track of that \ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1939762824",
    "pr_number": 36356,
    "pr_file": "internal/backend/remote/backend_test.go",
    "created_at": "2025-02-03T17:23:58+00:00",
    "commented_code": "if len(diags) != 1 {\n \t\tt.Fatal(\"expected diag, but none returned\")\n \t}\n-\tif got := diags.Err().Error(); !strings.Contains(got, \"Error looking up workspace: Invalid Terraform version\") {\n+\tif got := diags.Err().Error(); !strings.Contains(got, \"The remote workspace specified an invalid Terraform version or constraint\") {\n \t\tt.Fatalf(\"unexpected error: %s\", got)\n \t}\n }\n \n+func TestRemote_VerifyWorkspaceTerraformVersion_versionConstraint(t *testing.T) {\n+\tb, bCleanup := testBackendDefault(t)\n+\tdefer bCleanup()\n+\n+\tp := tfversion.Prerelease\n+\tv := tfversion.Version\n+\tdefer func() {\n+\t\ttfversion.Prerelease = p\n+\t\ttfversion.Version = v\n+\t}()\n+\n+\t// Define our test case struct\n+\ttype testCase struct {\n+\t\tterraformVersion  string\n+\t\tversionConstraint string\n+\t\tshouldSatisfy     bool\n+\t\tprerelease        string\n+\t}\n+\n+\t// Create a slice of test cases\n+\ttestCases := []testCase{\n+\t\t{\n+\t\t\tterraformVersion:  \"1.8.0\",\n+\t\t\tversionConstraint: \"> 1.9.0\",\n+\t\t\tshouldSatisfy:     false,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.1\",\n+\t\t\tversionConstraint: \"~> 1.10.0\",\n+\t\t\tshouldSatisfy:     true,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.0\",\n+\t\t\tversionConstraint: \"> 1.9.0\",\n+\t\t\tshouldSatisfy:     true,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.8.0\",\n+\t\t\tversionConstraint: \"~> 1.9.0\",\n+\t\t\tshouldSatisfy:     false,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.0\",\n+\t\t\tversionConstraint: \"> v1.9.4\",\n+\t\t\tshouldSatisfy:     true,\n+\t\t\tprerelease:        \"dev\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.0\",\n+\t\t\tversionConstraint: \"> 1.10.0\",\n+\t\t\tshouldSatisfy:     false,\n+\t\t\tprerelease:        \"dev\",\n+\t\t},\n+\t}\n+\n+\t// Now we loop through each test case, utilizing the values of each case\n+\t// to setup our test and assert accordingly.\n+\tfor _, tc := range testCases {\n+\n+\t\t// Set the version for this test.\n+\t\ttfversion.Prerelease = tc.prerelease\n+\t\ttfversion.Version = tc.terraformVersion",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1939762824",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36356,
        "pr_file": "internal/backend/remote/backend_test.go",
        "discussion_id": "1939762824",
        "commented_code": "@@ -666,11 +666,110 @@ func TestRemote_VerifyWorkspaceTerraformVersion_workspaceErrors(t *testing.T) {\n \tif len(diags) != 1 {\n \t\tt.Fatal(\"expected diag, but none returned\")\n \t}\n-\tif got := diags.Err().Error(); !strings.Contains(got, \"Error looking up workspace: Invalid Terraform version\") {\n+\tif got := diags.Err().Error(); !strings.Contains(got, \"The remote workspace specified an invalid Terraform version or constraint\") {\n \t\tt.Fatalf(\"unexpected error: %s\", got)\n \t}\n }\n \n+func TestRemote_VerifyWorkspaceTerraformVersion_versionConstraint(t *testing.T) {\n+\tb, bCleanup := testBackendDefault(t)\n+\tdefer bCleanup()\n+\n+\tp := tfversion.Prerelease\n+\tv := tfversion.Version\n+\tdefer func() {\n+\t\ttfversion.Prerelease = p\n+\t\ttfversion.Version = v\n+\t}()\n+\n+\t// Define our test case struct\n+\ttype testCase struct {\n+\t\tterraformVersion  string\n+\t\tversionConstraint string\n+\t\tshouldSatisfy     bool\n+\t\tprerelease        string\n+\t}\n+\n+\t// Create a slice of test cases\n+\ttestCases := []testCase{\n+\t\t{\n+\t\t\tterraformVersion:  \"1.8.0\",\n+\t\t\tversionConstraint: \"> 1.9.0\",\n+\t\t\tshouldSatisfy:     false,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.1\",\n+\t\t\tversionConstraint: \"~> 1.10.0\",\n+\t\t\tshouldSatisfy:     true,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.0\",\n+\t\t\tversionConstraint: \"> 1.9.0\",\n+\t\t\tshouldSatisfy:     true,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.8.0\",\n+\t\t\tversionConstraint: \"~> 1.9.0\",\n+\t\t\tshouldSatisfy:     false,\n+\t\t\tprerelease:        \"\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.0\",\n+\t\t\tversionConstraint: \"> v1.9.4\",\n+\t\t\tshouldSatisfy:     true,\n+\t\t\tprerelease:        \"dev\",\n+\t\t},\n+\t\t{\n+\t\t\tterraformVersion:  \"1.10.0\",\n+\t\t\tversionConstraint: \"> 1.10.0\",\n+\t\t\tshouldSatisfy:     false,\n+\t\t\tprerelease:        \"dev\",\n+\t\t},\n+\t}\n+\n+\t// Now we loop through each test case, utilizing the values of each case\n+\t// to setup our test and assert accordingly.\n+\tfor _, tc := range testCases {\n+\n+\t\t// Set the version for this test.\n+\t\ttfversion.Prerelease = tc.prerelease\n+\t\ttfversion.Version = tc.terraformVersion",
        "comment_created_at": "2025-02-03T17:23:58+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "Could you please update this code to include a deferred cleanup that sets these back to their original values? For example: https://github.com/hashicorp/terraform/blob/2ce197b4a92675073f3940688b9ad7e344b6e702/internal/backend/remote/backend_test.go#L439-L445\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1977801697",
    "pr_number": 36541,
    "pr_file": "internal/command/test_test.go",
    "created_at": "2025-03-03T16:18:38+00:00",
    "commented_code": "}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1977801697",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-03T16:18:38+00:00",
        "comment_author": "dsa0x",
        "comment_body": "The flakiness is because the stdout and stderr are merged in the stream within `testView`. Testing for them separately removes the flakiness. See https://github.com/hashicorp/terraform/pull/36566",
        "pr_file_module": null
      },
      {
        "comment_id": "1977997894",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-03T18:40:28+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "Oh, thanks for the link! I'll confirm whether it's the same problem & use the fix you linked tomorrow",
        "pr_file_module": null
      },
      {
        "comment_id": "1979271810",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-04T11:49:03+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "It's a different issue - [the test failure](https://github.com/hashicorp/terraform/actions/runs/13632143097/job/38102077385#step:6:39) is due to the non-deterministic order that runs are processed in if they have different state keys. I believe the graph can process either of them first, so they're effectively racing to be the first run that's registered as using that backend config.\r\n\r\nI've solved it by making the test assert the error message content but being looser about asserting which block at which line number is at fault: [a84553d](https://github.com/hashicorp/terraform/pull/36541/commits/a84553df35fce541e43458eb3fc870e5660f7786)",
        "pr_file_module": null
      },
      {
        "comment_id": "1979286601",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-04T12:00:01+00:00",
        "comment_author": "dsa0x",
        "comment_body": "It seems to me that the error we are checking here occurs in `internal/command/test.go`. At that point, the graph is not involved at all. I think that the reason for this non-determinism is because `BackendConfig` is a map. \r\n\r\nIs it fine for the test error to be non-deterministic? We could decide that it's not, and simply sort BackendConfig before checking the duplicate validation",
        "pr_file_module": null
      },
      {
        "comment_id": "1979295881",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-04T12:06:36+00:00",
        "comment_author": "dsa0x",
        "comment_body": "Btw, If we decide to make deterministic, here is an example in https://pkg.go.dev/iter#hdr-Standard_Library_Usage uses the new iterator packages to sort map keys.",
        "pr_file_module": null
      },
      {
        "comment_id": "1982140688",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-05T20:26:34+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "Sorry I didn't see your replies here- yes it's due to use of a map. I just pushed a solution but I'll look at the example you've posted",
        "pr_file_module": null
      },
      {
        "comment_id": "1982148099",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36541,
        "pr_file": "internal/command/test_test.go",
        "discussion_id": "1977801697",
        "commented_code": "@@ -2564,6 +2564,52 @@ Failure! 0 passed, 1 failed.\n \t}\n }\n \n+// TestTest_ReusedBackendConfiguration asserts that it's not valid to re-use the same backend config (i.e the same state file)\n+// in parallel runs. This would result in multiple actions attempting to set state, potentially with different resource configurations.\n+func TestTest_ReusedBackendConfiguration(t *testing.T) {\n+\tt.Skip(\"TODO(SarahFrench): Unable to reproduce this flakiness locally, skipping for now. Need to investigate or remove.\") // Similar failure to TestTest_InvalidConfig?",
        "comment_created_at": "2025-03-05T20:32:55+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "(Marking this unresolved again)\r\n\r\nI took a look - that's a neat trick for sorting map keys! For the code I have the map goes from state_key to backend config, so map keys aren't what's needed for sorting. In [75dfe43](https://github.com/hashicorp/terraform/pull/36541/commits/75dfe43978b2ab7cdbe5c9959184d9002540aab0) I've added sorting by the position the backend block is declared in the file.",
        "pr_file_module": null
      }
    ]
  }
]