[
  {
    "discussion_id": "2042628156",
    "pr_number": 36872,
    "pr_file": "website/docs/language/backend/oci.mdx",
    "created_at": "2025-04-14T17:48:29+00:00",
    "commented_code": "+---\n+page_title: 'Backend Type: oci'\n+description: Terraform can store and lock state remotely in OCI object storage.\n+---\n+\n+# oci\n+\n+The oci backend stores the Terraform state file in [Oracle Cloud Infrastructure (OCI) Object Storage](https://docs.oracle.com/en-us/iaas/Content/Object/Concepts/objectstorageoverview.htm#overview), allowing multiple users to collaborate using a shared remote state and benefit from features such as [state locking](https://developer.hashicorp.com/terraform/language/v1.12.x/state/locking) and [workspaces](https://developer.hashicorp.com/terraform/language/v1.12.x/state/workspaces).\n+\n+> ⚠️ **Warning:** It is highly recommended that you enable\n+> [Bucket Versioning](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/usingversioning_topic-To_enable_versioning_during_bucket_creation.htm)\n+> on the object storage bucket to allow for state recovery in the case of accidental deletions and human error.\n+\n+## Example Configuration\n+\n+```hcl\n+terraform {\n+  backend \"oci\" {\n+    # Required\n+    bucket            = \"mybucket\"\n+    namespace         = \"my-namespace\"\n+     # optional\n+    tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+    user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+    fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+    private_key_path  = \"~/.oci/oci_api_key.pem\"\n+    region            = \"us-ashburn-1\"\n+    key               = \"path/to/my/key\"\n+    workspace_key_prefix = \"envs/\"\n+    kms_key_id        = \"ocid1.key.oc1.iad.xxxxxxxxxxxxxx\"\n+    auth              = \"APIKey\"\n+    config_file_profile = \"DEFAULT\"\n+  }\n+}\n+```\n+\n+This assumes we have a bucket created called `mybucket`. The Terraform state is written to the key `path/to/my/key` and Terraform state md5 is written to the key `path/to/my/key.md5`.\n+\n+Note that for the access credentials we recommend using a [partial configuration](/terraform/language/backend#partial-configuration).\n+\n+## State Storage\n+\n+The oci backend stores Terraform state files in Oracle Cloud Infrastructure (OCI) Object Storage at the path defined by the key parameter, inside the bucket specified by the bucket parameter.\n+\n+Using the example shown above, the state file would be stored at:\n+`path/to/my/key` in the bucket `mybucket`.\n+\n+When using Terraform workspaces, the state for the default workspace is stored exactly at the path described above.\n+For non-default workspaces, the state is stored using the following path format:\n+    `<workspace_key_prefix>/<workspace_name>/<key>`\n+\n+ - The default workspace_key_prefix is `tf-state-env`, but it can be customized using the `workspace_key_prefix` backend parameter.\n+\n+ - For example, with workspace `development`, the state would be stored at: `tf-state-env/development/path/to/my/key`\n+\n+ - Additionally, an MD5 checksum file will be stored alongside the state at: `tf-state-env/development/path/to/my/key.md5`\n+\n+## State Locking\n+- The oci backend supports state locking by leveraging the `If-None-Match: *` header capability of OCI Object Storage.\n+- When a user initiates a `terraform plan/apply/destroy`, the backend creates a lock object in the same bucket as the state file.\n+- For example, the lock file for the `development` workspace would be stored at: `tf-state-env/development/path/to/my/key.lock`\n+\n+This locking mechanism helps prevent concurrent operations on the same state file, reducing the risk of corruption or conflicting changes.\n+\n+## Permissions Required\n+\n+### OCI Object Storage Bucket Permissions\n+Terraform requires the following [OCI IAM permissions](https://docs.oracle.com/en-us/iaas/Content/Identity/Reference/policyreference.htm?utm_source=chatgpt.com) on the target backend bucket to manage the state file and associated lock files:\n+\n+- OBJECT_INSPECT (includes HeadObject)\n+- OBJECT_CREATE (includes PutObject, CreateMultipartUpload, UploadPart, and CommitMultipartUpload)\n+- OBJECT_DELETE (includes DeleteObject)\n+- OBJECT_READ (includes GetObject)\n+\n+Alternatively, you can specify the exact operations if you're using fine-grained policies:\n+\n+- GetObject\n+- PutObject\n+- DeleteObject\n+- HeadObject\n+- CreateMultipartUpload\n+- UploadPart\n+- CommitMultipart\n+\n+Note: These permissions should be granted on the specific bucket being used for Terraform state storage.\n+### OCI IAM Policy Reference\n+> [OCI IAM Policy Reference](https://docs.oracle.com/en-us/iaas/Content/Identity/Reference/policyreference.htm?utm_source=chatgpt.com) This resource provides comprehensive details on the required permissions and how to structure your policies to grant Terraform the appropriate access to Object Storage resources.\n+\n+## Data Source Configuration\n+\n+To make use of the oci remote state in another configuration,\n+use the [`terraform_remote_state` data source](/terraform/language/state/remote-state-data).\n+\n+```hcl\n+data \"terraform_remote_state\" \"mystate\" {\n+  backend = \"oci\"\n+  config = {\n+    bucket            = \"mybucket\"\n+    key               = \"path/to/my/key\"\n+    namespace         = \"my-namespace\"\n+    tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+    user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+    fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+    private_key_path  = \"~/.oci/oci_api_key.pem\"\n+    region            = \"us-ashburn-1\"\n+  }\n+}\n+```\n+\n+The `terraform_remote_state` data source will return all of the root module\n+outputs defined in the referenced remote state (but not any outputs from\n+nested modules unless they are explicitly output again in the root). An\n+example output might look like:\n+\n+```\n+# data.terraform_remote_state.mystate:\n+data \"terraform_remote_state\" \"mystate\" {\n+    backend = \"oci\"\n+    config  = {\n+        bucket            = \"mybucket\"\n+        key               = \"path/to/my/key\"\n+        namespace         = \"my-namespace\"\n+        tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+        user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+        fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+        private_key_path  = \"~/.oci/oci_api_key.pem\"\n+        region            = \"us-ashburn-1\"\n+    }\n+    outputs = {\n+        object_names = [\n+            \"test-object-1\",\n+            \"test-object-2\"\n+        ]\n+    }\n+}\n+```\n+\n+## Configuration\n+\n+The oci backend requires the configuration of the OCI namespace and Object Storage bucket where the Terraform state file will be stored.\n+### Credentials and Shared Configuration\n+\n+> ⚠️ **Warning:**\n+> We strongly recommend using **environment variables** to supply credentials and other sensitive data.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "2042628156",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36872,
        "pr_file": "website/docs/language/backend/oci.mdx",
        "discussion_id": "2042628156",
        "commented_code": "@@ -0,0 +1,182 @@\n+---\n+page_title: 'Backend Type: oci'\n+description: Terraform can store and lock state remotely in OCI object storage.\n+---\n+\n+# oci\n+\n+The oci backend stores the Terraform state file in [Oracle Cloud Infrastructure (OCI) Object Storage](https://docs.oracle.com/en-us/iaas/Content/Object/Concepts/objectstorageoverview.htm#overview), allowing multiple users to collaborate using a shared remote state and benefit from features such as [state locking](https://developer.hashicorp.com/terraform/language/v1.12.x/state/locking) and [workspaces](https://developer.hashicorp.com/terraform/language/v1.12.x/state/workspaces).\n+\n+> ⚠️ **Warning:** It is highly recommended that you enable\n+> [Bucket Versioning](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/usingversioning_topic-To_enable_versioning_during_bucket_creation.htm)\n+> on the object storage bucket to allow for state recovery in the case of accidental deletions and human error.\n+\n+## Example Configuration\n+\n+```hcl\n+terraform {\n+  backend \"oci\" {\n+    # Required\n+    bucket            = \"mybucket\"\n+    namespace         = \"my-namespace\"\n+     # optional\n+    tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+    user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+    fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+    private_key_path  = \"~/.oci/oci_api_key.pem\"\n+    region            = \"us-ashburn-1\"\n+    key               = \"path/to/my/key\"\n+    workspace_key_prefix = \"envs/\"\n+    kms_key_id        = \"ocid1.key.oc1.iad.xxxxxxxxxxxxxx\"\n+    auth              = \"APIKey\"\n+    config_file_profile = \"DEFAULT\"\n+  }\n+}\n+```\n+\n+This assumes we have a bucket created called `mybucket`. The Terraform state is written to the key `path/to/my/key` and Terraform state md5 is written to the key `path/to/my/key.md5`.\n+\n+Note that for the access credentials we recommend using a [partial configuration](/terraform/language/backend#partial-configuration).\n+\n+## State Storage\n+\n+The oci backend stores Terraform state files in Oracle Cloud Infrastructure (OCI) Object Storage at the path defined by the key parameter, inside the bucket specified by the bucket parameter.\n+\n+Using the example shown above, the state file would be stored at:\n+`path/to/my/key` in the bucket `mybucket`.\n+\n+When using Terraform workspaces, the state for the default workspace is stored exactly at the path described above.\n+For non-default workspaces, the state is stored using the following path format:\n+    `<workspace_key_prefix>/<workspace_name>/<key>`\n+\n+ - The default workspace_key_prefix is `tf-state-env`, but it can be customized using the `workspace_key_prefix` backend parameter.\n+\n+ - For example, with workspace `development`, the state would be stored at: `tf-state-env/development/path/to/my/key`\n+\n+ - Additionally, an MD5 checksum file will be stored alongside the state at: `tf-state-env/development/path/to/my/key.md5`\n+\n+## State Locking\n+- The oci backend supports state locking by leveraging the `If-None-Match: *` header capability of OCI Object Storage.\n+- When a user initiates a `terraform plan/apply/destroy`, the backend creates a lock object in the same bucket as the state file.\n+- For example, the lock file for the `development` workspace would be stored at: `tf-state-env/development/path/to/my/key.lock`\n+\n+This locking mechanism helps prevent concurrent operations on the same state file, reducing the risk of corruption or conflicting changes.\n+\n+## Permissions Required\n+\n+### OCI Object Storage Bucket Permissions\n+Terraform requires the following [OCI IAM permissions](https://docs.oracle.com/en-us/iaas/Content/Identity/Reference/policyreference.htm?utm_source=chatgpt.com) on the target backend bucket to manage the state file and associated lock files:\n+\n+- OBJECT_INSPECT (includes HeadObject)\n+- OBJECT_CREATE (includes PutObject, CreateMultipartUpload, UploadPart, and CommitMultipartUpload)\n+- OBJECT_DELETE (includes DeleteObject)\n+- OBJECT_READ (includes GetObject)\n+\n+Alternatively, you can specify the exact operations if you're using fine-grained policies:\n+\n+- GetObject\n+- PutObject\n+- DeleteObject\n+- HeadObject\n+- CreateMultipartUpload\n+- UploadPart\n+- CommitMultipart\n+\n+Note: These permissions should be granted on the specific bucket being used for Terraform state storage.\n+### OCI IAM Policy Reference\n+> [OCI IAM Policy Reference](https://docs.oracle.com/en-us/iaas/Content/Identity/Reference/policyreference.htm?utm_source=chatgpt.com) This resource provides comprehensive details on the required permissions and how to structure your policies to grant Terraform the appropriate access to Object Storage resources.\n+\n+## Data Source Configuration\n+\n+To make use of the oci remote state in another configuration,\n+use the [`terraform_remote_state` data source](/terraform/language/state/remote-state-data).\n+\n+```hcl\n+data \"terraform_remote_state\" \"mystate\" {\n+  backend = \"oci\"\n+  config = {\n+    bucket            = \"mybucket\"\n+    key               = \"path/to/my/key\"\n+    namespace         = \"my-namespace\"\n+    tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+    user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+    fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+    private_key_path  = \"~/.oci/oci_api_key.pem\"\n+    region            = \"us-ashburn-1\"\n+  }\n+}\n+```\n+\n+The `terraform_remote_state` data source will return all of the root module\n+outputs defined in the referenced remote state (but not any outputs from\n+nested modules unless they are explicitly output again in the root). An\n+example output might look like:\n+\n+```\n+# data.terraform_remote_state.mystate:\n+data \"terraform_remote_state\" \"mystate\" {\n+    backend = \"oci\"\n+    config  = {\n+        bucket            = \"mybucket\"\n+        key               = \"path/to/my/key\"\n+        namespace         = \"my-namespace\"\n+        tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+        user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+        fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+        private_key_path  = \"~/.oci/oci_api_key.pem\"\n+        region            = \"us-ashburn-1\"\n+    }\n+    outputs = {\n+        object_names = [\n+            \"test-object-1\",\n+            \"test-object-2\"\n+        ]\n+    }\n+}\n+```\n+\n+## Configuration\n+\n+The oci backend requires the configuration of the OCI namespace and Object Storage bucket where the Terraform state file will be stored.\n+### Credentials and Shared Configuration\n+\n+> ⚠️ **Warning:**\n+> We strongly recommend using **environment variables** to supply credentials and other sensitive data.",
        "comment_created_at": "2025-04-14T17:48:29+00:00",
        "comment_author": "SarahFrench",
        "comment_body": "Please update the documentation with a section listing which environment variables can be used to configure this backend.",
        "pr_file_module": null
      },
      {
        "comment_id": "2044785710",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36872,
        "pr_file": "website/docs/language/backend/oci.mdx",
        "discussion_id": "2042628156",
        "commented_code": "@@ -0,0 +1,182 @@\n+---\n+page_title: 'Backend Type: oci'\n+description: Terraform can store and lock state remotely in OCI object storage.\n+---\n+\n+# oci\n+\n+The oci backend stores the Terraform state file in [Oracle Cloud Infrastructure (OCI) Object Storage](https://docs.oracle.com/en-us/iaas/Content/Object/Concepts/objectstorageoverview.htm#overview), allowing multiple users to collaborate using a shared remote state and benefit from features such as [state locking](https://developer.hashicorp.com/terraform/language/v1.12.x/state/locking) and [workspaces](https://developer.hashicorp.com/terraform/language/v1.12.x/state/workspaces).\n+\n+> ⚠️ **Warning:** It is highly recommended that you enable\n+> [Bucket Versioning](https://docs.oracle.com/en-us/iaas/Content/Object/Tasks/usingversioning_topic-To_enable_versioning_during_bucket_creation.htm)\n+> on the object storage bucket to allow for state recovery in the case of accidental deletions and human error.\n+\n+## Example Configuration\n+\n+```hcl\n+terraform {\n+  backend \"oci\" {\n+    # Required\n+    bucket            = \"mybucket\"\n+    namespace         = \"my-namespace\"\n+     # optional\n+    tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+    user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+    fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+    private_key_path  = \"~/.oci/oci_api_key.pem\"\n+    region            = \"us-ashburn-1\"\n+    key               = \"path/to/my/key\"\n+    workspace_key_prefix = \"envs/\"\n+    kms_key_id        = \"ocid1.key.oc1.iad.xxxxxxxxxxxxxx\"\n+    auth              = \"APIKey\"\n+    config_file_profile = \"DEFAULT\"\n+  }\n+}\n+```\n+\n+This assumes we have a bucket created called `mybucket`. The Terraform state is written to the key `path/to/my/key` and Terraform state md5 is written to the key `path/to/my/key.md5`.\n+\n+Note that for the access credentials we recommend using a [partial configuration](/terraform/language/backend#partial-configuration).\n+\n+## State Storage\n+\n+The oci backend stores Terraform state files in Oracle Cloud Infrastructure (OCI) Object Storage at the path defined by the key parameter, inside the bucket specified by the bucket parameter.\n+\n+Using the example shown above, the state file would be stored at:\n+`path/to/my/key` in the bucket `mybucket`.\n+\n+When using Terraform workspaces, the state for the default workspace is stored exactly at the path described above.\n+For non-default workspaces, the state is stored using the following path format:\n+    `<workspace_key_prefix>/<workspace_name>/<key>`\n+\n+ - The default workspace_key_prefix is `tf-state-env`, but it can be customized using the `workspace_key_prefix` backend parameter.\n+\n+ - For example, with workspace `development`, the state would be stored at: `tf-state-env/development/path/to/my/key`\n+\n+ - Additionally, an MD5 checksum file will be stored alongside the state at: `tf-state-env/development/path/to/my/key.md5`\n+\n+## State Locking\n+- The oci backend supports state locking by leveraging the `If-None-Match: *` header capability of OCI Object Storage.\n+- When a user initiates a `terraform plan/apply/destroy`, the backend creates a lock object in the same bucket as the state file.\n+- For example, the lock file for the `development` workspace would be stored at: `tf-state-env/development/path/to/my/key.lock`\n+\n+This locking mechanism helps prevent concurrent operations on the same state file, reducing the risk of corruption or conflicting changes.\n+\n+## Permissions Required\n+\n+### OCI Object Storage Bucket Permissions\n+Terraform requires the following [OCI IAM permissions](https://docs.oracle.com/en-us/iaas/Content/Identity/Reference/policyreference.htm?utm_source=chatgpt.com) on the target backend bucket to manage the state file and associated lock files:\n+\n+- OBJECT_INSPECT (includes HeadObject)\n+- OBJECT_CREATE (includes PutObject, CreateMultipartUpload, UploadPart, and CommitMultipartUpload)\n+- OBJECT_DELETE (includes DeleteObject)\n+- OBJECT_READ (includes GetObject)\n+\n+Alternatively, you can specify the exact operations if you're using fine-grained policies:\n+\n+- GetObject\n+- PutObject\n+- DeleteObject\n+- HeadObject\n+- CreateMultipartUpload\n+- UploadPart\n+- CommitMultipart\n+\n+Note: These permissions should be granted on the specific bucket being used for Terraform state storage.\n+### OCI IAM Policy Reference\n+> [OCI IAM Policy Reference](https://docs.oracle.com/en-us/iaas/Content/Identity/Reference/policyreference.htm?utm_source=chatgpt.com) This resource provides comprehensive details on the required permissions and how to structure your policies to grant Terraform the appropriate access to Object Storage resources.\n+\n+## Data Source Configuration\n+\n+To make use of the oci remote state in another configuration,\n+use the [`terraform_remote_state` data source](/terraform/language/state/remote-state-data).\n+\n+```hcl\n+data \"terraform_remote_state\" \"mystate\" {\n+  backend = \"oci\"\n+  config = {\n+    bucket            = \"mybucket\"\n+    key               = \"path/to/my/key\"\n+    namespace         = \"my-namespace\"\n+    tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+    user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+    fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+    private_key_path  = \"~/.oci/oci_api_key.pem\"\n+    region            = \"us-ashburn-1\"\n+  }\n+}\n+```\n+\n+The `terraform_remote_state` data source will return all of the root module\n+outputs defined in the referenced remote state (but not any outputs from\n+nested modules unless they are explicitly output again in the root). An\n+example output might look like:\n+\n+```\n+# data.terraform_remote_state.mystate:\n+data \"terraform_remote_state\" \"mystate\" {\n+    backend = \"oci\"\n+    config  = {\n+        bucket            = \"mybucket\"\n+        key               = \"path/to/my/key\"\n+        namespace         = \"my-namespace\"\n+        tenancy_ocid      = \"ocid1.tenancy.oc1..xxxxxxx\"\n+        user_ocid         = \"ocid1.user.oc1..xxxxxxxx\"\n+        fingerprint       = \"xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\"\n+        private_key_path  = \"~/.oci/oci_api_key.pem\"\n+        region            = \"us-ashburn-1\"\n+    }\n+    outputs = {\n+        object_names = [\n+            \"test-object-1\",\n+            \"test-object-2\"\n+        ]\n+    }\n+}\n+```\n+\n+## Configuration\n+\n+The oci backend requires the configuration of the OCI namespace and Object Storage bucket where the Terraform state file will be stored.\n+### Credentials and Shared Configuration\n+\n+> ⚠️ **Warning:**\n+> We strongly recommend using **environment variables** to supply credentials and other sensitive data.",
        "comment_created_at": "2025-04-15T14:39:02+00:00",
        "comment_author": "ravinitp",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1984189733",
    "pr_number": 36641,
    "pr_file": "website/docs/language/backend/azurerm.mdx",
    "created_at": "2025-03-06T23:36:28+00:00",
    "commented_code": "This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n+\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to know the data plane URI for the storage account. In many cases this can simply be inferred from the `storage_account_name` and the Azure environment, but if you are using the 'Azure DNS zone endpoints' feature the backend will need to lookup the data plane URI from the management plane. There are different settings and permissions required depending on how you choose to authenticate to the storage account that we cover in this section.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1984189733",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36641,
        "pr_file": "website/docs/language/backend/azurerm.mdx",
        "discussion_id": "1984189733",
        "commented_code": "@@ -9,495 +9,671 @@ Stores the state as a Blob with the given Key within the Blob Container within [\n \n This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n+\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to know the data plane URI for the storage account. In many cases this can simply be inferred from the `storage_account_name` and the Azure environment, but if you are using the 'Azure DNS zone endpoints' feature the backend will need to lookup the data plane URI from the management plane. There are different settings and permissions required depending on how you choose to authenticate to the storage account that we cover in this section.",
        "comment_created_at": "2025-03-06T23:36:28+00:00",
        "comment_author": "magodo",
        "comment_body": "```suggestion\r\nThe `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\r\n\r\n### Data Plane URI\r\n\r\nIn [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane.\r\n```\r\n\r\n### Authentication\r\n\r\nThere are different settings and permissions required depending on how you choose to authenticate to the storage account that we cover in this section.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1992296247",
    "pr_number": 36641,
    "pr_file": "website/docs/language/backend/azurerm.mdx",
    "created_at": "2025-03-12T21:10:06+00:00",
    "commented_code": "This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1992296247",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36641,
        "pr_file": "website/docs/language/backend/azurerm.mdx",
        "discussion_id": "1992296247",
        "commented_code": "@@ -9,495 +9,501 @@ Stores the state as a Blob with the given Key within the Blob Container within [\n \n This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.",
        "comment_created_at": "2025-03-12T21:10:06+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nIn most cases, you can infer the data plane URI from the `storage_account_name` and `container_name`.  Refer to the [storage account overview documentation](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) for more information on the standard endpoints.\r\n\r\nIf you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview), the backend will need to lookup the data plane URI from the management plane. This requires that you set the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993815850",
    "pr_number": 36641,
    "pr_file": "website/docs/language/backend/azurerm.mdx",
    "created_at": "2025-03-13T15:46:29+00:00",
    "commented_code": "This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1993815850",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36641,
        "pr_file": "website/docs/language/backend/azurerm.mdx",
        "discussion_id": "1993815850",
        "commented_code": "@@ -9,495 +9,501 @@ Stores the state as a Blob with the given Key within the Blob Container within [\n \n This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.",
        "comment_created_at": "2025-03-13T15:46:29+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nTerraform retains this method for backwards compatibility only, do not use it for any new workloads.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993840988",
    "pr_number": 36641,
    "pr_file": "website/docs/language/backend/azurerm.mdx",
    "created_at": "2025-03-13T15:58:34+00:00",
    "commented_code": "This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_secret` - The client secret of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_SECRET` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Certificate\n+### Azure Active Directory with Client Certificate\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+We retain this method for backwards compatibility only, do not use it for any new workloads.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1993840988",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36641,
        "pr_file": "website/docs/language/backend/azurerm.mdx",
        "discussion_id": "1993840988",
        "commented_code": "@@ -9,495 +9,501 @@ Stores the state as a Blob with the given Key within the Blob Container within [\n \n This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_secret` - The client secret of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_SECRET` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Certificate\n+### Azure Active Directory with Client Certificate\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+We retain this method for backwards compatibility only, do not use it for any new workloads.",
        "comment_created_at": "2025-03-13T15:58:34+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nTerraform retains this method for backwards compatibility only, do not use it for any new workloads.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993842485",
    "pr_number": 36641,
    "pr_file": "website/docs/language/backend/azurerm.mdx",
    "created_at": "2025-03-13T15:59:23+00:00",
    "commented_code": "This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_secret` - The client secret of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_SECRET` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Certificate\n+### Azure Active Directory with Client Certificate\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_certificate_path` - The path to the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n+- `client_certificate_password` - The password for the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n \n-*Connect to Storage Account with Access Key*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n+    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n     client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n     client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n-\n-*Connect to Storage Account with Azure Active Directory authentication*\n-\n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n     storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n-    client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Access Key Direct\n+## Access Key\n+\n+This method requires you find the Access Key for the storage account and supply it to the backend configuration.\n+\n+The Access Key is then used to directly authenticate to the storage account data plane.\n+\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1993842485",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36641,
        "pr_file": "website/docs/language/backend/azurerm.mdx",
        "discussion_id": "1993842485",
        "commented_code": "@@ -9,495 +9,501 @@ Stores the state as a Blob with the given Key within the Blob Container within [\n \n This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_secret` - The client secret of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_SECRET` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Certificate\n+### Azure Active Directory with Client Certificate\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_certificate_path` - The path to the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n+- `client_certificate_password` - The password for the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n \n-*Connect to Storage Account with Access Key*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n+    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n     client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n     client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n-\n-*Connect to Storage Account with Azure Active Directory authentication*\n-\n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n     storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n-    client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Access Key Direct\n+## Access Key\n+\n+This method requires you find the Access Key for the storage account and supply it to the backend configuration.\n+\n+The Access Key is then used to directly authenticate to the storage account data plane.\n+\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.",
        "comment_created_at": "2025-03-13T15:59:23+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nTerraform retains this method for backwards compatibility, we do not recommend it for new workloads.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993846440",
    "pr_number": 36641,
    "pr_file": "website/docs/language/backend/azurerm.mdx",
    "created_at": "2025-03-13T16:01:26+00:00",
    "commented_code": "This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_secret` - The client secret of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_SECRET` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Certificate\n+### Azure Active Directory with Client Certificate\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_certificate_path` - The path to the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n+- `client_certificate_password` - The password for the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n \n-*Connect to Storage Account with Access Key*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n+    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n     client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n     client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n-\n-*Connect to Storage Account with Azure Active Directory authentication*\n-\n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n     storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n-    client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Access Key Direct\n+## Access Key\n+\n+This method requires you find the Access Key for the storage account and supply it to the backend configuration.\n+\n+The Access Key is then used to directly authenticate to the storage account data plane.\n+\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.\n+\n+### Required Inputs\n+\n+The following inputs are always required for this method:\n+\n+- `access_key` - The Access Key of the storage account is required to authenticate to the storage account data plane. This can also be set via the `ARM_ACCESS_KEY` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n+\n+### Storage Account Required Role Assignments\n+\n+There are no role assignments required on the storage account for this method as the Access Key is used to authenticate to the data plane.\n+\n+### Example Configuration\n \n ~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"             # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    access_key           = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_ACCESS_KEY` environment variable.\n     storage_account_name = \"abcd1234\"                                 # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                                  # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                   # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    access_key           = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_ACCESS_KEY` environment variable.\n   }\n }\n ```\n \n-### Backend: SAS Token\n+## SAS Token\n+\n+This method requires you generate a SAS Token for the storage account container or blob and supply it to the backend configuration.\n+\n+The SAS Token is then used to directly authenticate to the storage account data plane.\n+\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.\n+\n+### Required Inputs\n+\n+The following inputs are always required for this method:\n+\n+- `sas_token` - The SAS Token for the storage account container or blob is required to authenticate to the storage account data plane. This can also be set via the `ARM_SAS_TOKEN` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n+\n+### Storage Account Required Permissions\n+\n+The SAS Token requires `write` and `list` permissions on the container or blob.\n+\n+### Example Configuration\n \n ~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"             # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    sas_token            = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_SAS_TOKEN` environment variable.\n     storage_account_name = \"abcd1234\"                                 # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                                  # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                   # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    sas_token            = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_SAS_TOKEN` environment variable.\n   }\n }\n ```\n \n-## Example Data Source Configurations\n+## Access Key Lookup\n \n-### Data Source: Azure AD User Principal via Azure CLI\n+This method requires a valid Azure Active Directory principal and is a fallback for when Azure Active Directory authentication cannot be used on the storage account data plane.\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method queries the management plane to get the storage account Access Key and then uses that Access Key to authenticate to the storage account data plane. As such it requires elevated permissions on the storage account.\n \n-*Connect to Storage Account with Access Key*\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1993846440",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36641,
        "pr_file": "website/docs/language/backend/azurerm.mdx",
        "discussion_id": "1993846440",
        "commented_code": "@@ -9,495 +9,501 @@ Stores the state as a Blob with the given Key within the Blob Container within [\n \n This backend supports state locking and consistency checking with Azure Blob Storage native capabilities.\n \n-~> Terraform 1.1 and 1.2 supported a feature-flag to allow enabling/disabling the use of Microsoft Graph (and MSAL) rather than Azure Active Directory Graph (and ADAL) - however this flag has since been removed in Terraform 1.3. Microsoft Graph (and MSAL) are now enabled by default and Azure Active Directory Graph (and ADAL) can no longer be used.\n-\n ## Authentication\n \n-The `azurerm` backend supports 3 methods of authenticating to the storage account:\n+!> **Warning:**  We recommend using environment variables to supply credentials and other sensitive data. If you use `-backend-config` or hardcode these values directly in your configuration, Terraform will include these values in both the `.terraform` subdirectory and in plan files. Refer to [Credentials and Sensitive Data](/terraform/language/backend#credentials-and-sensitive-data) for details.\n \n-- Access Key (default)\n-- Azure Active Directory\n-- SAS Token\n+The `azurerm` backend needs to authenticate to the storage account data plane in order to manipulate the state file blob in the storage account container. In order to do that, it needs to authenticate and to know the data plane URI for the storage account.\n \n-The *Access Key* method can be used directly, by specifying the access key, or in combination with an Azure AD principal (e.g. user, service principal or managed identity). To use an Access Key directly you must generate one for your state file blob and specify it in the backend configuration. If neither an access key or client ID is specified, Terraform will attempt to use Azure CLI. In both cases where no access key is given, Terraform will attempt to retrieve the access key for the storage account, using the authenticated Azure AD principal.\n+At a high level, the `azurerm` backend has 5 methods it can use to authenticate to the storage account data plane:\n \n-The *Azure Active Directory* method can only be used in combination with an Azure AD principal. To use the Azure Active Directory method you must set the `use_azuread_auth` variable to `true` in your backend configuration. This will cause the backend to use the Access Token of the Azure AD principal to authenticate to the state file blob, instead of authenticating using a shared access key.\n+- [Azure Active Directory](#azure-active-directory) **(Recommended)**\n+- [SAS Token](#sas-token) *(Not recommended for new workloads)*\n+- [Access Key](#access-key) *(Not recommended for new workloads)*\n+- [Access Key Lookup](#access-key-lookup) *(Not recommended for new workloads)*\n \n-The *SAS Token* method can only be used directly. You must generate a SAS Token for your state file blob and pass it to the backend config.\n+### Azure Active Directory and Access Key Lookup Authentication Types\n \n-The `azurerm` backend supports the following authentication scenarios to connect to the storage account, based on the configuration variables provided:\n+There are 5 types of Azure Active Directory authentication supported, which apply to the Azure Active Directory and Access Key Lookup methods.\n \n-| Authentication Method | Storage Account Authentication Type | Minimum Required Configuration† |\n-|-----|---|---|\n-| User Principal via Azure CLI | Access Key | N/A |\n-| User Principal via Azure CLI | Azure AD | `use_azuread_auth = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Access Key | `use_oidc = true` |\n-| Service Principal or User Assigned Managed Identity via OIDC (Workload identity federation) | Azure AD | `use_azuread_auth = true`, `use_oidc = true` |\n-| Managed Identity Principal | Access Key | `use_msi = true` |\n-| Managed Identity Principal | Azure AD | `use_azuread_auth = true`, `use_msi = true` |\n-| Service Principal via Client Secret | Access Key | `client_secret = \"...\"` |\n-| Service Principal via Client Secret | Azure AD | `use_azuread_auth = true`, `client_secret = \"...\"` |\n-| Service Principal via Client Certificate | Access Key | `client_certificate_path = \"...\"` |\n-| Service Principal via Client Certificate | Azure AD | `client_certificate_path = \"...`, `use_azuread_auth = true` |\n-| Access Key direct | Access Key | `access_key = \"...\"` |\n-| SAS Token direct | SAS Token | `sas_token = \"...\"` |\n+- OpenID Connect / Workload identity federation **(Recommended)**\n+  - User Assigned Managed Identity with Federated Credentials **(Recommended)**\n+  - Service Princial / App Registration with Federated Credentials\n+- User or System Assigned Managed Identity\n+  - User Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+  - System Assigned Managed Identity attached to Azure compute instance (agent / runner)\n+- Service Principal / App Registration with Client Secret\n+- Service Principal / App REgistration with Client Certificate\n+- User Account with Azure CLI only (for local development cycle)\n \n-† There are sometimes more options needed for successful authentication. The variable shown is the one that triggers the backend to use a given authentication scenario. You can see examples of each option below.\n+These types can be supplied via inputs or via a pre-authenticated Azure CLI. We cover them in more depth in the following sections.\n \n--> Sensitive values should not be hardcoded into your configuration, and should instead be specified using environment variables or partial configuration flags in the `init` command of Terraform CLI.\n+### Data Plane URI\n \n-## Example Backend Configurations\n+In [most cases](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#standard-endpoints) this can simply be inferred from the `storage_account_name` and `container_name`. But if you are using the ['Azure DNS zone endpoints' feature](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-overview#azure-dns-zone-endpoints-preview) the backend will need to lookup the data plane URI from the management plane. This requires the setting the `lookup_blob_endpoint` configuration option to `true` and the `Reader` role assignment on the storage account.\n \n-### Backend: Azure AD User via Azure CLI\n+## Azure Active Directory\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method requires a valid Azure Active Directory principal and a predictable storage account data plane URI.\n \n-*Connect to Storage Account with Access Key*\n+### Required Inputs\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-  }\n-}\n-```\n+The following inputs are always required for this method:\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+- `use_azuread_auth` - Set to `true` to use Azure Active Directory authentication to the storage account data plane. This can also be set via the `ARM_USE_AZUREAD` environment variable.\n+- `tenant_id` - The tenant ID of the Azure Active Directory principal is required to authenticate to the storage account data plane. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_TENANT_ID` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"  # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                      # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                       # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"        # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_azuread_auth     = true                            # Can also be set via `ARM_USE_AZUREAD` environment variable.\n-  }\n-}\n-```\n+### Optional Inputs\n+\n+These optional inputs apply when [looking up the data plane URI](#data-plane-uri) from the management plane. They are not required when the data plane URI can be inferred from the `storage_account_name` and `container_name`.\n+\n+- `lookup_blob_endpoint` - Set to `true` to lookup the storage account data plane URI from the management plane. This is required if you are using the 'Azure DNS zone endpoints' feature. Defaults to `false`. This value can also be sourced from the `ARM_USE_DNS_ZONE_ENDPOINT` environment variable.\n+- `subscription_id` - The subscription ID of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`. If using Azure CLI, this can be inferred from the CLI session. This can also be set via the `ARM_SUBSCRIPTION_ID` environment variable.\n+- `resource_group_name` - The resource group name of the storage account is required to query the management plane. This is only required if `lookup_blob_endpoint` is set to `true`.\n+\n+### Storage Account Required Role Assignments\n+\n+The recommended data plane role assignments required for this method are either one of:\n+\n+- `Storage Blob Data Owner` on the storage account container (Recommended)\n+- `Storage Blob Data Contributor` on the storage account\n+\n+The recommended management plane role assignments required for this method are:\n \n-### Backend: Azure AD Service Principal or User Assigned Managed Identity via OIDC (Workload Identity Federation)\n+- `Reader` on the storage account *(Only required if `lookup_blob_endpoint` is set to `true`)*\n \n-You can use an App Registration (Service Principal) or a User Assigned Managed Identity to configure federated credentials. You must supply the Client ID of the principal.\n+### Azure Active Directory with OpenID Connect / Workload identity federation\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_oidc` - Set to `true` to use OpenID Connect / Workload identity federation to authenticate to the storage account data plane. This can also be set via the `ARM_USE_OIDC` environment variable.\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration or User Assigned Managed Identity is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+\n+#### Example Configuration for GitHub\n+\n+With GitHub, the ID Token environment variables are automatically found, so no further settings are required.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration for Azure DevOps\n+\n+With Azure DevOps, the ID Token endpoint environment variables are automatically found, but you need to supply the service connection ID in `oidc_azure_service_connection_id`. If you are using the `AzureCLI` or `AzurePowerShell` tasks, the service connection ID is automatically set to the  `AZURESUBSCRIPTION_SERVICE_CONNECTION_ID` environment variable.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_oidc             = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    use_oidc                         = true                                    # Can also be set via `ARM_USE_OIDC` environment variable.\n+    oidc_azure_service_connection_id = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_OIDC_AZURE_SERVICE_CONNECTION_ID` environment variable.\n+    use_azuread_auth                 = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id                        = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    storage_account_name             = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n+    container_name                   = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n+    key                              = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n   }\n }\n ```\n \n-### Backend: Azure AD Managed Identity Principal\n+### Azure Active Directory with Compute Attached Managed Identity\n \n-You can use a User Assigned Managed Identity as well as a System Assigned Managed Identity on your agent / runner compute environment. However the backend does not currently support specifying the Client ID of the User Assigned Managed Identity, so you can only supply one per compute instance.\n+#### Required Inputs\n \n-*Connect to Storage Account with Access Key*\n+The following additional inputs are always required for this sub-type:\n \n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n+- `use_msi` - Set to `true` to use the managed identity to authenticate to the storage account data plane. This can also be set via the `ARM_USE_MSI` environment variable.\n+\n+#### Optional Inputs\n+\n+The following additional inputs are optional for this sub-type:\n+\n+- `client_id` - The client ID of the User Assigned Managed Identity is required to authenticate to the storage account data plane. This is not required for System Assigned Managed Identity. This can also be set via the `ARM_CLIENT_ID` environment variable.\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable. Not required for System Assigned Managed Identity.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    use_msi              = true                                    # Can also be set via `ARM_USE_MSI` environment variable.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Secret\n+### Azure Active Directory with Azure CLI\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+You must have a pre-authenticated Azure CLI session using any supported method.\n \n-*Connect to Storage Account with Access Key*\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `use_cli` - Set to `true` to use the Azure CLI session authenticate to the storage account data plane. This can also be set via the `ARM_USE_CLI` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_cli              = true                                    # Can also be set via `ARM_USE_CLI` environment variable.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable. Azure CLI will fallback to use the connected tenant ID if not supplied.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n   }\n }\n ```\n \n-*Connect to Storage Account with Azure Active Directory authentication*\n+### Azure Active Directory with Client Secret\n+\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_secret` - The client secret of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_SECRET` environment variable.\n+\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n+    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n+    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n     storage_account_name = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_secret        = \"************************************\"  # Can also be set via `ARM_CLIENT_SECRET` environment variable.\n-    subscription_id      = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id            = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth     = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Azure AD Service Principal via Client Certificate\n+### Azure Active Directory with Client Certificate\n \n-~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n+We retain this method for backwards compatibility only, do not use it for any new workloads.\n+\n+~> **Warning!** This method requires you to manage and rotate a secret. Use OpenID Connect / Workload identity federation as a more secure approach.\n+\n+#### Required Inputs\n+\n+The following additional inputs are always required for this sub-type:\n+\n+- `client_id` - The client ID of the Azure Active Directory Service Principal / App Registration is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_ID` environment variable.\n+- `client_certificate_path` - The path to the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n+- `client_certificate_password` - The password for the client certificate bundle is required to authenticate to the storage account data plane. This can also be set via the `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n \n-*Connect to Storage Account with Access Key*\n+#### Example Configuration\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n-    storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n-    container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n-    key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n+    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n+    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n     client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n     client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n     client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-  }\n-}\n-```\n-\n-*Connect to Storage Account with Azure Active Directory authentication*\n-\n-```hcl\n-terraform {\n-  backend \"azurerm\" {\n-    resource_group_name         = \"StorageAccount-ResourceGroup\"          # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n     storage_account_name        = \"abcd1234\"                              # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name              = \"tfstate\"                               # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                         = \"prod.terraform.tfstate\"                # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    client_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_CLIENT_ID` environment variable.\n-    client_certificate_path     = \"/path/to/bundle.pfx\"                   # Can also be set via `ARM_CLIENT_CERTIFICATE_PATH` environment variable.\n-    client_certificate_password = \"************************************\"  # Can also be set via `ARM_CLIENT_CERTIFICATE_PASSWORD` environment variable.\n-    subscription_id             = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_SUBSCRIPTION_ID` environment variable.\n-    tenant_id                   = \"00000000-0000-0000-0000-000000000000\"  # Can also be set via `ARM_TENANT_ID` environment variable.\n-    use_azuread_auth            = true                                    # Can also be set via `ARM_USE_AZUREAD` environment variable.\n   }\n }\n ```\n \n-### Backend: Access Key Direct\n+## Access Key\n+\n+This method requires you find the Access Key for the storage account and supply it to the backend configuration.\n+\n+The Access Key is then used to directly authenticate to the storage account data plane.\n+\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.\n+\n+### Required Inputs\n+\n+The following inputs are always required for this method:\n+\n+- `access_key` - The Access Key of the storage account is required to authenticate to the storage account data plane. This can also be set via the `ARM_ACCESS_KEY` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n+\n+### Storage Account Required Role Assignments\n+\n+There are no role assignments required on the storage account for this method as the Access Key is used to authenticate to the data plane.\n+\n+### Example Configuration\n \n ~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"             # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    access_key           = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_ACCESS_KEY` environment variable.\n     storage_account_name = \"abcd1234\"                                 # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                                  # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                   # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    access_key           = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_ACCESS_KEY` environment variable.\n   }\n }\n ```\n \n-### Backend: SAS Token\n+## SAS Token\n+\n+This method requires you generate a SAS Token for the storage account container or blob and supply it to the backend configuration.\n+\n+The SAS Token is then used to directly authenticate to the storage account data plane.\n+\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.\n+\n+### Required Inputs\n+\n+The following inputs are always required for this method:\n+\n+- `sas_token` - The SAS Token for the storage account container or blob is required to authenticate to the storage account data plane. This can also be set via the `ARM_SAS_TOKEN` environment variable.\n+- `storage_account_name` - The name of the storage account where the state file blob resides in.\n+- `container_name` - The name of the storage account container where the state file blob resides in.\n+- `key` - The name of the blob within the storage account container that the state file will be stored in.\n+\n+### Storage Account Required Permissions\n+\n+The SAS Token requires `write` and `list` permissions on the container or blob.\n+\n+### Example Configuration\n \n ~> **Warning!** This method requires you to manage and rotate a secret. Consider using OIDC as a more secure approach.\n \n ```hcl\n terraform {\n   backend \"azurerm\" {\n-    resource_group_name  = \"StorageAccount-ResourceGroup\"             # Can be passed via `-backend-config=`\"resource_group_name=<resource group name>\"` in the `init` command.\n+    sas_token            = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_SAS_TOKEN` environment variable.\n     storage_account_name = \"abcd1234\"                                 # Can be passed via `-backend-config=`\"storage_account_name=<storage account name>\"` in the `init` command.\n     container_name       = \"tfstate\"                                  # Can be passed via `-backend-config=`\"container_name=<container name>\"` in the `init` command.\n     key                  = \"prod.terraform.tfstate\"                   # Can be passed via `-backend-config=`\"key=<blob key name>\"` in the `init` command.\n-    sas_token            = \"abcdefghijklmnopqrstuvwxyz0123456789...\"  # Can also be set via `ARM_SAS_TOKEN` environment variable.\n   }\n }\n ```\n \n-## Example Data Source Configurations\n+## Access Key Lookup\n \n-### Data Source: Azure AD User Principal via Azure CLI\n+This method requires a valid Azure Active Directory principal and is a fallback for when Azure Active Directory authentication cannot be used on the storage account data plane.\n \n-This method is not suitable for automation since it only supports a User Principal. To check which tenant and subscription you are pointed to, run `az account show`.\n+This method queries the management plane to get the storage account Access Key and then uses that Access Key to authenticate to the storage account data plane. As such it requires elevated permissions on the storage account.\n \n-*Connect to Storage Account with Access Key*\n+This method is retained for backwards compatibility, but we do not recommend it for new workloads.",
        "comment_created_at": "2025-03-13T16:01:26+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nTerraform retains this method for backwards compatibility, we do not recommend it for new workloads.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1977941156",
    "pr_number": 36605,
    "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
    "created_at": "2025-03-03T17:56:34+00:00",
    "commented_code": "<CodeBlockConfig highlight=\"11\">\n \n ```hcl\n-ephemeral \"random\" \"password\" {\n+ephemeral \"random_password\" \"db_password\" {\n   length = 16\n }\n \n-resource \"aws_db_instance\" \"test\" {\n-  instance_class      = \"db.t5.micro\"\n+resource \"aws_secretsmanager_secret\" \"db_password\" {\n+  name = \"db_password\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"db_password\" {\n+  secret_id                = aws_secretsmanager_secret.db_password.id\n+  secret_string_wo         = ephemeral.random_password.db_password.result\n+  secret_string_wo_version = 1\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"db_password\" {\n+  secret_id = aws_secretsmanager_secret.db_password.id\n+}\n+\n+resource \"aws_db_instance\" \"example\" {\n+  instance_class      = \"db.t3.micro\"\n   allocated_storage   = \"5\"\n   engine              = \"postgres\"\n-  username            = \"admin\"\n+  username            = \"example\"\n   skip_final_snapshot = true\n-  password_wo         = ephemeral.random.password.value\n+\n+  password_wo         = ephemeral.aws_secretsmanager_secret_version.db_password.secret_string\n   password_wo_version = 1\n }\n ```\n \n+### Deferring ephemeral resources\n+\n+If an input argument of an ephemeral resource references a value that is not yet known but will be during or after the plan, Terraform defers the resource’s execution to the apply stage instead of running it during the plan. This behavior allows Terraform to evaluate the ephemeral resource at the correct time and ensures that the resource is not executed prematurely.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1977941156",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36605,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1977941156",
        "commented_code": "@@ -44,21 +44,43 @@ Use write-only arguments to securely pass temporary values to resources during a\n <CodeBlockConfig highlight=\"11\">\n \n ```hcl\n-ephemeral \"random\" \"password\" {\n+ephemeral \"random_password\" \"db_password\" {\n   length = 16\n }\n \n-resource \"aws_db_instance\" \"test\" {\n-  instance_class      = \"db.t5.micro\"\n+resource \"aws_secretsmanager_secret\" \"db_password\" {\n+  name = \"db_password\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"db_password\" {\n+  secret_id                = aws_secretsmanager_secret.db_password.id\n+  secret_string_wo         = ephemeral.random_password.db_password.result\n+  secret_string_wo_version = 1\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"db_password\" {\n+  secret_id = aws_secretsmanager_secret.db_password.id\n+}\n+\n+resource \"aws_db_instance\" \"example\" {\n+  instance_class      = \"db.t3.micro\"\n   allocated_storage   = \"5\"\n   engine              = \"postgres\"\n-  username            = \"admin\"\n+  username            = \"example\"\n   skip_final_snapshot = true\n-  password_wo         = ephemeral.random.password.value\n+\n+  password_wo         = ephemeral.aws_secretsmanager_secret_version.db_password.secret_string\n   password_wo_version = 1\n }\n ```\n \n+### Deferring ephemeral resources\n+\n+If an input argument of an ephemeral resource references a value that is not yet known but will be during or after the plan, Terraform defers the resource’s execution to the apply stage instead of running it during the plan. This behavior allows Terraform to evaluate the ephemeral resource at the correct time and ensures that the resource is not executed prematurely.",
        "comment_created_at": "2025-03-03T17:56:34+00:00",
        "comment_author": "rkoron007",
        "comment_body": "I really like the way you gave a play-byplay of how Terraform approaches this, how would you feel about a numbered list here? I tried make this a little more pointed to the example so folks could follow along, but please feel free to disregard anything you don't like!\r\n```suggestion\r\nIn the above example, the ephemeral resource `aws_secretsmanager_secret_version` references a `. secret_string_wo` argument. If an ephemeral resource argument references a value that Terraform cannot know yet, then Terraform defers executing that resource until the apply stage, when Terraform has the information to evaluate that argument's value. \r\n\r\nTerraform executes this configuration in the following order:\r\n1. Terraform generates the ephemeral `random_password` resource\r\n1. Terraform retrieves that `random_password` value and assigns it to `aws_secretsmanager_secret_version.secret_string_wo`\r\n1. Terraform writes the password to the write-only `password_wo` argument of the `aws_db_instance` resource\r\n\r\nBy executing the configuration in this order, Terraform evaluates each ephemeral resource argument successfully.\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1980138389",
    "pr_number": 36605,
    "pr_file": "website/docs/language/resources/ephemeral/reference.mdx",
    "created_at": "2025-03-04T19:52:32+00:00",
    "commented_code": "```hcl\n ephemeral \"aws_secretsmanager_secret_version\" \"db_master\" {\n-  secret_id = data.aws_db_instance.example.master_user_secret[0].secret_arn\n+  secret_id = aws_secretsmanager_secret_version.db_password.secret_id",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1980138389",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36605,
        "pr_file": "website/docs/language/resources/ephemeral/reference.mdx",
        "discussion_id": "1980138389",
        "commented_code": "@@ -75,16 +79,16 @@ an ephemeral resource. Since these credentials are managed by an ephemeral resou\n \n ```hcl\n ephemeral \"aws_secretsmanager_secret_version\" \"db_master\" {\n-  secret_id = data.aws_db_instance.example.master_user_secret[0].secret_arn\n+  secret_id = aws_secretsmanager_secret_version.db_password.secret_id",
        "comment_created_at": "2025-03-04T19:52:32+00:00",
        "comment_author": "ktham",
        "comment_body": "Hi @bschaatsbergen!\r\n\r\nI’d suggest including `version_id` to make it explicit that the purpose of retrieving the `secret_id` attribute from `aws_secretsmanager_secret_version` (rather than from `aws_secretsmanager_secret`) is to target a specific version of the `aws_secretsmanager_secret_version` resource, which is uniquely identified by `version_id`.\r\n\r\nBy default, the version that the `aws_secretsmanager_secret_version` ephemeral (or data) resource will lookup  whatever secret version is in the `AWSCURRENT` stage, which is ok here because we've conditioned the \"timing\" of the lookup to happen after creation (and thus also re-creation) of `aws_secretsmanager_secret_version`.\r\n\r\nNote, by \"re-creation\" here, in Terraform, that's represented first by the destruction/removal of the `aws_secretsmanager_secret_version` and then creation of a new one. Though on the AWS side, the old version isn't exactly \"deleted\", it can still be retrieved, either by it's `version_id`, or through supplying the stage `AWSPREVIOUS`.\r\n\r\nI was reviewing your [Gist](https://gist.github.com/bschaatsbergen/cec07997d0d187d8e8c7889af96a8c45) earlier, which includes the following code:\r\n\r\n```\r\nephemeral \"aws_secretsmanager_secret_version\" \"db_password\" {\r\n  secret_id = aws_secretsmanager_secret.db_password.id\r\n}\r\n```\r\n\r\nI’m assuming you may have encountered issues with the ephemeral resource attempting to retrieve the “AWSCURRENT” version of the secret before a new version was published. (i.e. it might not have existed on the initial apply.) which is why you switched from `aws_secretsmanager_secret.db_password.id` to `aws_secretsmanager_secret_version.db_password.secret_id`\r\n\r\nThis also helps with the situation where the `aws_secretsmanager_secret_version` is being re-created, resulting in a new secret version being published and ensuring the ephemeral resource does the lookup for the `AWSCURRENT` version  _after_ the new version is created.\r\n\r\nFor consumers of the documentation here, it would be good to explain the context for grabbing `secret_id` from `aws_secretsmanager_secret_version` so that someone in the future who may not have realized this was intentional doesn't just replace it with code that grabs `secret_id` from `aws_secretsmanager_secret`.\r\n\r\nAs an alternative, I think it would be even better to explicitly specify `version_id` (which uniquely identifies a `aws_secretsmanager_secret_version ` resource) and make it clear that we are looking up a _specific_ secret version.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1979903999",
    "pr_number": 36621,
    "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
    "created_at": "2025-03-04T17:24:16+00:00",
    "commented_code": "}\n ```\n \n-In the above example, the ephemeral resource `aws_secretsmanager_secret_version` references an input argument that is initially unknown. As a result, Terraform defers its execution to the apply stage, ensuring that the resource is evaluated at the correct time. \n-This allows Terraform to first create the secret in AWS Secrets Manager using the ephemeral `random_password`, then retrieve it using the ephemeral `aws_secretsmanager_secret_version` resource, and finally write the password to the write-only `password_wo` argument of the `aws_db_instance` resource.\n-\n </CodeBlockConfig>\n \n-When Terraform creates the `aws_db_instance` resource, Terraform sends the `password_wo` argument to the `aws` provider. The `aws` provider then uses the `password_wo` value to configure the database instance, and then Terraform discards the password value without ever storing it. \n+When Terraform creates the `aws_db_instance` resource, Terraform sends the `password_wo` value to the `aws` provider. The `aws` provider then uses the `password_wo` value to create the database instance, and then Terraform discards the password value without ever storing it. \n \n-To learn more about using write-only arguments, refer to the [Use write-only arguments](/terraform/language/resources/ephemeral/write-only).\n+To learn more about this example and using write-only arguments, refer to the [Use write-only arguments](/terraform/language/resources/ephemeral/write-only).",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1979903999",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36621,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1979903999",
        "commented_code": "@@ -74,11 +74,8 @@ resource \"aws_db_instance\" \"example\" {\n }\n ```\n \n-In the above example, the ephemeral resource `aws_secretsmanager_secret_version` references an input argument that is initially unknown. As a result, Terraform defers its execution to the apply stage, ensuring that the resource is evaluated at the correct time. \n-This allows Terraform to first create the secret in AWS Secrets Manager using the ephemeral `random_password`, then retrieve it using the ephemeral `aws_secretsmanager_secret_version` resource, and finally write the password to the write-only `password_wo` argument of the `aws_db_instance` resource.\n-\n </CodeBlockConfig>\n \n-When Terraform creates the `aws_db_instance` resource, Terraform sends the `password_wo` argument to the `aws` provider. The `aws` provider then uses the `password_wo` value to configure the database instance, and then Terraform discards the password value without ever storing it. \n+When Terraform creates the `aws_db_instance` resource, Terraform sends the `password_wo` value to the `aws` provider. The `aws` provider then uses the `password_wo` value to create the database instance, and then Terraform discards the password value without ever storing it. \n \n-To learn more about using write-only arguments, refer to the [Use write-only arguments](/terraform/language/resources/ephemeral/write-only).\n+To learn more about this example and using write-only arguments, refer to the [Use write-only arguments](/terraform/language/resources/ephemeral/write-only).",
        "comment_created_at": "2025-03-04T17:24:16+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nTo learn more about this example and using write-only arguments, refer to the [Use write-only arguments](/terraform/language/resources/ephemeral/write-only) documentation.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1979967634",
    "pr_number": 36621,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-03-04T18:10:37+00:00",
    "commented_code": "override_special = \"!#$%&*()-_=+[]{}<>:?\"\n }\n \n-resource \"aws_secretsmanager_secret\" \"db_password\" {\n-  name = \"db_password\"\n-}\n-\n-resource \"aws_secretsmanager_secret_version\" \"db_password\" {\n-  secret_id                = aws_secretsmanager_secret.db_password.id\n-  secret_string_wo         = ephemeral.random_password.db_password.result\n-  secret_string_wo_version = 1\n-}\n-\n-ephemeral \"aws_secretsmanager_secret_version\" \"db_password\" {\n-  secret_id = aws_secretsmanager_secret_version.db_password.secret_id\n-}\n-\n resource \"aws_db_instance\" \"example\" {\n   instance_class      = \"db.t3.micro\"\n   allocated_storage   = \"5\"\n   engine              = \"postgres\"\n   username            = \"example\"\n   skip_final_snapshot = true\n-  password_wo         = ephemeral.aws_secretsmanager_secret_version.db_password.secret_string\n-  password_wo_version = aws_secretsmanager_secret_version.db_password.secret_string_wo_version\n+  password_wo         = ephemeral.random_password.db_password.result\n+  password_wo_version = 1\n }\n ```\n \n </CodeBlockConfig>\n \n During a Terraform operation, the provider uses the `password_wo` value to create the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n+Note that the way this is written, the `password_wo` value is lost after Terraform generates unless we capture it in another resource or output. For example of generating, storing, retrieving, and using an ephemeral password as a write-only argument, refer to the [expanded example below](#example).",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1979967634",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36621,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1979967634",
        "commented_code": "@@ -65,35 +65,23 @@ ephemeral \"random_password\" \"db_password\" {\n   override_special = \"!#$%&*()-_=+[]{}<>:?\"\n }\n \n-resource \"aws_secretsmanager_secret\" \"db_password\" {\n-  name = \"db_password\"\n-}\n-\n-resource \"aws_secretsmanager_secret_version\" \"db_password\" {\n-  secret_id                = aws_secretsmanager_secret.db_password.id\n-  secret_string_wo         = ephemeral.random_password.db_password.result\n-  secret_string_wo_version = 1\n-}\n-\n-ephemeral \"aws_secretsmanager_secret_version\" \"db_password\" {\n-  secret_id = aws_secretsmanager_secret_version.db_password.secret_id\n-}\n-\n resource \"aws_db_instance\" \"example\" {\n   instance_class      = \"db.t3.micro\"\n   allocated_storage   = \"5\"\n   engine              = \"postgres\"\n   username            = \"example\"\n   skip_final_snapshot = true\n-  password_wo         = ephemeral.aws_secretsmanager_secret_version.db_password.secret_string\n-  password_wo_version = aws_secretsmanager_secret_version.db_password.secret_string_wo_version\n+  password_wo         = ephemeral.random_password.db_password.result\n+  password_wo_version = 1\n }\n ```\n \n </CodeBlockConfig>\n \n During a Terraform operation, the provider uses the `password_wo` value to create the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n+Note that the way this is written, the `password_wo` value is lost after Terraform generates unless we capture it in another resource or output. For example of generating, storing, retrieving, and using an ephemeral password as a write-only argument, refer to the [expanded example below](#example). ",
        "comment_created_at": "2025-03-04T18:10:37+00:00",
        "comment_author": "BrianMMcClain",
        "comment_body": "```suggestion\r\nNote that the way this is written, the `password_wo` value is lost after Terraform generates unless we capture it in another resource or output. For an example of generating, storing, retrieving, and using an ephemeral password as a write-only argument, refer to the [expanded example below](#example). \r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1968463978",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
    "created_at": "2025-02-24T21:48:42+00:00",
    "commented_code": "---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state with ephemeral resource blocks and write-only arguments to manage temporary data in Terraform.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1968463978",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1968463978",
        "commented_code": "@@ -1,73 +1,61 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state with ephemeral resource blocks and write-only arguments to manage temporary data in Terraform. ",
        "comment_created_at": "2025-02-24T21:48:42+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\ndescription: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1968470784",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/reference.mdx",
    "created_at": "2025-02-24T21:54:54+00:00",
    "commented_code": "---\n-page_title: Ephemeral resource configuration reference\n-description: Learn to define ephemeral resource blocks in Terraform configurations. Ephemeral resource blocks represent temporary resources that Terraform does not store in state.\n+page_title: Ephemeral block configuration reference\n+description: Learn to define ephemeral blocks in Terraform configurations to keep temporary and sensitive information outside of Terraform state and plan files.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1968470784",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/reference.mdx",
        "discussion_id": "1968470784",
        "commented_code": "@@ -1,9 +1,9 @@\n ---\n-page_title: Ephemeral resource configuration reference\n-description: Learn to define ephemeral resource blocks in Terraform configurations. Ephemeral resource blocks represent temporary resources that Terraform does not store in state.\n+page_title: Ephemeral block configuration reference\n+description: Learn to define ephemeral blocks in Terraform configurations to keep temporary and sensitive information outside of Terraform state and plan files.",
        "comment_created_at": "2025-02-24T21:54:54+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\ndescription: Learn to define ephemeral blocks in Terraform configurations to keep temporary and sensitive information out of Terraform state and plan files.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1968502286",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-02-24T22:25:42+00:00",
    "commented_code": "---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values on resources that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use  a `resource` that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.\n \n-<!-- TODO: Update with a code sample when we have one\n+Providers implement version arguments to let practitioners track write-only argument values and control when a provider uses those write-only arguments. The implementation of write-only arguments and their version arguments is provider-specific, so consult the Registry for more details about your specific provider.\n \n-## Define a write-only value\n+For example, the `aws_db_instance` resource has an accompanying `password_wo_version` argument for the `password_wo` write-only argument:\n \n-## Set a write-only value\n+<CodeBlockConfig highlight=\"11-12\">\n \n-Example of setting an ephemeral value:\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"new-password-here\"\n+  password_wo_version = 1\n+}\n+```\n \n-Example of setting a non-ephemeral value:\n+</CodeBlockConfig>\n \n-Add guidance on avoiding acciedentally leaking a non-ephemeral value in a write-only argument.\n+The provider now uses the write-only argument value when creating the `aws_db_instance` resource and when the `password_wo_version` version argument increments. The `password_wo_version` version argument is stored in state, allowing Terraform to track when the write-only argument changes.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1968502286",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1968502286",
        "commented_code": "@@ -1,44 +1,126 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values on resources that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use  a `resource` that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.\n \n-<!-- TODO: Update with a code sample when we have one\n+Providers implement version arguments to let practitioners track write-only argument values and control when a provider uses those write-only arguments. The implementation of write-only arguments and their version arguments is provider-specific, so consult the Registry for more details about your specific provider.\n \n-## Define a write-only value\n+For example, the `aws_db_instance` resource has an accompanying `password_wo_version` argument for the `password_wo` write-only argument:\n \n-## Set a write-only value\n+<CodeBlockConfig highlight=\"11-12\">\n \n-Example of setting an ephemeral value:\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"new-password-here\"\n+  password_wo_version = 1\n+}\n+```\n \n-Example of setting a non-ephemeral value:\n+</CodeBlockConfig>\n \n-Add guidance on avoiding acciedentally leaking a non-ephemeral value in a write-only argument.\n+The provider now uses the write-only argument value when creating the `aws_db_instance` resource and when the `password_wo_version` version argument increments. The `password_wo_version` version argument is stored in state, allowing Terraform to track when the write-only argument changes.",
        "comment_created_at": "2025-02-24T22:25:42+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\nThe provider now uses the write-only argument value when creating the `aws_db_instance` resource and whenever you increment the `password_wo_version` version argument. The `password_wo_version` version argument is stored in state, allowing Terraform to track when the write-only argument changes.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1968538063",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-02-24T22:59:16+00:00",
    "commented_code": "---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo          = ephemeral.random.password.value",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1968538063",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1968538063",
        "commented_code": "@@ -1,44 +1,126 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo          = ephemeral.random.password.value",
        "comment_created_at": "2025-02-24T22:59:16+00:00",
        "comment_author": "rkoron007",
        "comment_body": "```suggestion\r\n  password_wo         = ephemeral.random.password.value\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1970657793",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-02-25T22:56:56+00:00",
    "commented_code": "---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1970657793",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1970657793",
        "commented_code": "@@ -1,44 +1,128 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.",
        "comment_created_at": "2025-02-25T22:56:56+00:00",
        "comment_author": "SBGoods",
        "comment_body": "I think this sentence implies that providers cannot use write-only arguments to update a resource. \r\n```suggestion\r\nTerraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers typically implement mechanisms such as version arguments to indicate a plan diff to Terraform.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1970680191",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1970657793",
        "commented_code": "@@ -1,44 +1,128 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.",
        "comment_created_at": "2025-02-25T23:24:52+00:00",
        "comment_author": "rkoron007",
        "comment_body": "I was trying to explain what happens if you _don't_ add an accompanying version arg (because I know most of them are optional), but I like your suggestion of going straight to version args. How does the following feel for really spelling out what is going on:\r\n```suggestion\r\nTerraform also cannot create plan diffs for write-only arguments because it does not store those values in plan files. However, providers typically include version arguments alongside write-only arguments. Terraform stores version arguments in state, and can track if a version argument changes.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1970682763",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1970657793",
        "commented_code": "@@ -1,44 +1,128 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.",
        "comment_created_at": "2025-02-25T23:28:10+00:00",
        "comment_author": "SBGoods",
        "comment_body": "That sounds good to me!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1970678214",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-02-25T23:22:19+00:00",
    "commented_code": "---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.\n \n-<!-- TODO: Update with a code sample when we have one\n+Providers implement version arguments to let practitioners track write-only argument values and control when a provider uses those write-only arguments. The implementation of write-only arguments and their version arguments is provider-specific, so consult the Registry for more details about your specific provider.\n \n-## Define a write-only value\n+For example, the `aws_db_instance` resource has an accompanying `password_wo_version` argument for the `password_wo` write-only argument:\n \n-## Set a write-only value\n+<CodeBlockConfig highlight=\"11-12\">\n \n-Example of setting an ephemeral value:\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"new-password-here\"\n+  password_wo_version = 1\n+}\n+```\n \n-Example of setting a non-ephemeral value:\n+</CodeBlockConfig>\n \n-Add guidance on avoiding acciedentally leaking a non-ephemeral value in a write-only argument.\n+The provider now uses the write-only argument value when creating the `aws_db_instance` resource and whenever you increment the `password_wo_version` version argument. The `password_wo_version` version argument is stored in state, allowing Terraform to track when the write-only argument changes.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1970678214",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1970678214",
        "commented_code": "@@ -1,44 +1,128 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\n+\n+<CodeBlockConfig highlight=\"11\">\n+\n+```hcl\n+ephemeral \"random\" \"password\" {\n+  length = 16\n+}\n+\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = ephemeral.random.password.value\n+  password_wo_version = 1\n+}\n+```\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+</CodeBlockConfig>\n \n+During a Terraform operation, the provider uses the `password_wo` value to configure the database instance, and then Terraform discards that value without storing it in the plan or state file. \n \n-## Introduction\n+## Update write-only arguments with versions\n \n-Write-only arguments are only available during runtime, and Terraform omits them from state and plan files. On a new Terraform operation, a write-only argument always start as `null` before Terraform overwrites it with a new value from your configuration.\n+Terraform does not store write-only arguments in state files, so Terraform has no way of knowing if a write-only argument value has changed. Because Terraform cannot track write-only argument values, it sends write-only arguments to the provider during every operation.\n \n-Write-only arguments are unique among other ephemeral constructs in Terraform because you can assign both ephemeral and non-ephemeral data as the value of a write-only argument.\n+Terraform also cannot create plan diffs for write-only arguments because it does not store them in plan files, so providers only use write-only arguments when creating a new resource.\n \n-<!-- TODO: Update with a code sample when we have one\n+Providers implement version arguments to let practitioners track write-only argument values and control when a provider uses those write-only arguments. The implementation of write-only arguments and their version arguments is provider-specific, so consult the Registry for more details about your specific provider.\n \n-## Define a write-only value\n+For example, the `aws_db_instance` resource has an accompanying `password_wo_version` argument for the `password_wo` write-only argument:\n \n-## Set a write-only value\n+<CodeBlockConfig highlight=\"11-12\">\n \n-Example of setting an ephemeral value:\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"new-password-here\"\n+  password_wo_version = 1\n+}\n+```\n \n-Example of setting a non-ephemeral value:\n+</CodeBlockConfig>\n \n-Add guidance on avoiding acciedentally leaking a non-ephemeral value in a write-only argument.\n+The provider now uses the write-only argument value when creating the `aws_db_instance` resource and whenever you increment the `password_wo_version` version argument. The `password_wo_version` version argument is stored in state, allowing Terraform to track when the write-only argument changes.",
        "comment_created_at": "2025-02-25T23:22:19+00:00",
        "comment_author": "rkoron007",
        "comment_body": "```suggestion\r\nThe provider uses the write-only argument value when creating the `aws_db_instance` resource and Terraform stores the `password_wo_version` argument value in state.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1972211372",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
    "created_at": "2025-02-26T19:00:57+00:00",
    "commented_code": "---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1972211372",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1972211372",
        "commented_code": "@@ -1,73 +1,66 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.",
        "comment_created_at": "2025-02-26T19:00:57+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\nEphemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system. Since Terraform does not keep track of ephemeral resources, if you need to persist data about ephemeral resources, you should do so outside of Terraform. For example, you may store this data in a secrets management system such as HashiCorp Vault.\r\n```\r\n\r\nDOes this feel to \"upsell-ey\" for docs?",
        "pr_file_module": null
      },
      {
        "comment_id": "1972518066",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1972211372",
        "commented_code": "@@ -1,73 +1,66 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.",
        "comment_created_at": "2025-02-26T22:33:57+00:00",
        "comment_author": "rkoron007",
        "comment_body": "Oh, I like that idea but maybe we can do that in a follow up PR and add a Vault example to accompany it? I'd rather keep this PR scoped just to the write-only args for now, and I can follow up with another PR to add Vault examples later!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1972331666",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
    "created_at": "2025-02-26T20:10:30+00:00",
    "commented_code": "---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n \n In your configuration, you can only reference an `ephemeral` block in [other ephemeral contexts](/terraform/language/resources/ephemeral/reference#reference-ephemeral-resources).\n \n ### Lifecycle\n \n-The lifecycle of an ephemeral resource is different from resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n+The lifecycle of an `ephemeral` resource is different from other resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n \n 1. If Terraform needs to access the result of an ephemeral resource, it opens\n that ephemeral resource. For example, if Terraform opens an ephemeral resource for a Vault secret, the Vault provider obtains a lease and returns a secret. \n \n 1. If Terraform needs access to the ephemeral resource for longer than the\n remote system's enforced expiration time, Terraform asks the provider\n-to renew it periodically. For example, if Terraform renews a Vault secret ephemeral resource, the Vault provider then calls Vault's lease renewal API endpoint to extend the expiration time.\n+to periodically renew it. For example, if Terraform renews a Vault secret `ephemeral` resource, the Vault provider calls Vault's lease renewal API endpoint to extend the expiration time.\n \n 1. Once Terraform no longer needs an ephemeral resource, Terraform closes\n-it. This happens after the providers that depend on a certain ephemeral resource\n+it. This happens after the providers that depend on an ephemeral resource\n complete all of their work for the current Terraform run phase. For example, closing a Vault secret ephemeral resource means the Vault provider explicitly ends the lease, allowing Vault to immediately revoke the associated credentials.\n \n Terraform follows these lifecycle steps for each instance of an ephemeral\n resource in a given configuration.\n \n ### Configuration model\n \n-To learn more about the `ephemeral` block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n+To learn more about the `ephemeral` resource block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n \n ## Write-only arguments\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+Terraform's managed resources, defined by `resource` blocks, can include ephemeral arguments, called **write-only arguments**. Write-only arguments are only available during the current Terraform operation, and Terraform does not store them in state or plan files.  \n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Use write-only arguments to securely pass temporary values to resources during a Terraform operation without worrying about Terraform persisting those values. For example, the `aws_db_instance` resource has a write-only `password_wo` argument that accepts a database password:",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1972331666",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1972331666",
        "commented_code": "@@ -1,73 +1,66 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n \n In your configuration, you can only reference an `ephemeral` block in [other ephemeral contexts](/terraform/language/resources/ephemeral/reference#reference-ephemeral-resources).\n \n ### Lifecycle\n \n-The lifecycle of an ephemeral resource is different from resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n+The lifecycle of an `ephemeral` resource is different from other resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n \n 1. If Terraform needs to access the result of an ephemeral resource, it opens\n that ephemeral resource. For example, if Terraform opens an ephemeral resource for a Vault secret, the Vault provider obtains a lease and returns a secret. \n \n 1. If Terraform needs access to the ephemeral resource for longer than the\n remote system's enforced expiration time, Terraform asks the provider\n-to renew it periodically. For example, if Terraform renews a Vault secret ephemeral resource, the Vault provider then calls Vault's lease renewal API endpoint to extend the expiration time.\n+to periodically renew it. For example, if Terraform renews a Vault secret `ephemeral` resource, the Vault provider calls Vault's lease renewal API endpoint to extend the expiration time.\n \n 1. Once Terraform no longer needs an ephemeral resource, Terraform closes\n-it. This happens after the providers that depend on a certain ephemeral resource\n+it. This happens after the providers that depend on an ephemeral resource\n complete all of their work for the current Terraform run phase. For example, closing a Vault secret ephemeral resource means the Vault provider explicitly ends the lease, allowing Vault to immediately revoke the associated credentials.\n \n Terraform follows these lifecycle steps for each instance of an ephemeral\n resource in a given configuration.\n \n ### Configuration model\n \n-To learn more about the `ephemeral` block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n+To learn more about the `ephemeral` resource block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n \n ## Write-only arguments\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+Terraform's managed resources, defined by `resource` blocks, can include ephemeral arguments, called **write-only arguments**. Write-only arguments are only available during the current Terraform operation, and Terraform does not store them in state or plan files.  \n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Use write-only arguments to securely pass temporary values to resources during a Terraform operation without worrying about Terraform persisting those values. For example, the `aws_db_instance` resource has a write-only `password_wo` argument that accepts a database password:",
        "comment_created_at": "2025-02-26T20:10:30+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\nUse write-only arguments to securely pass ephemeral values to resources during a Terraform operation. Like other ephemeral values, Terraform does not persist the values of write-only arguments in state or plan files. For example, the `aws_db_instance` resource has a write-only `password_wo` argument that accepts a database password:\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1972336890",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1972331666",
        "commented_code": "@@ -1,73 +1,66 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n \n In your configuration, you can only reference an `ephemeral` block in [other ephemeral contexts](/terraform/language/resources/ephemeral/reference#reference-ephemeral-resources).\n \n ### Lifecycle\n \n-The lifecycle of an ephemeral resource is different from resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n+The lifecycle of an `ephemeral` resource is different from other resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n \n 1. If Terraform needs to access the result of an ephemeral resource, it opens\n that ephemeral resource. For example, if Terraform opens an ephemeral resource for a Vault secret, the Vault provider obtains a lease and returns a secret. \n \n 1. If Terraform needs access to the ephemeral resource for longer than the\n remote system's enforced expiration time, Terraform asks the provider\n-to renew it periodically. For example, if Terraform renews a Vault secret ephemeral resource, the Vault provider then calls Vault's lease renewal API endpoint to extend the expiration time.\n+to periodically renew it. For example, if Terraform renews a Vault secret `ephemeral` resource, the Vault provider calls Vault's lease renewal API endpoint to extend the expiration time.\n \n 1. Once Terraform no longer needs an ephemeral resource, Terraform closes\n-it. This happens after the providers that depend on a certain ephemeral resource\n+it. This happens after the providers that depend on an ephemeral resource\n complete all of their work for the current Terraform run phase. For example, closing a Vault secret ephemeral resource means the Vault provider explicitly ends the lease, allowing Vault to immediately revoke the associated credentials.\n \n Terraform follows these lifecycle steps for each instance of an ephemeral\n resource in a given configuration.\n \n ### Configuration model\n \n-To learn more about the `ephemeral` block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n+To learn more about the `ephemeral` resource block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n \n ## Write-only arguments\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+Terraform's managed resources, defined by `resource` blocks, can include ephemeral arguments, called **write-only arguments**. Write-only arguments are only available during the current Terraform operation, and Terraform does not store them in state or plan files.  \n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Use write-only arguments to securely pass temporary values to resources during a Terraform operation without worrying about Terraform persisting those values. For example, the `aws_db_instance` resource has a write-only `password_wo` argument that accepts a database password:",
        "comment_created_at": "2025-02-26T20:14:01+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "We also need to mention the `password_wo_version` attribute. Incidentally, the `_version` arguments will be required whenever someone uses the `_wo` argument, at least for the [AWS provider](https://hashicorp.slack.com/archives/C071HC4JJCC/p1740499398901699).\r\n\r\nHere's what I put in the tutorial:\r\n\r\n```\r\nBecause Terraform does not store the value of write-only arguments, it cannot\r\ndetect if the value of a write-only argument changed in your configuration. To\r\ntrack whether a write-only argument changes, the AWS provider includes\r\naccompanying versioning arguments: `password_wo` uses `password_wo_version` and\r\n`value_wo` uses `value_wo_version`.\r\n\r\nVersioning arguments are tracked in state. You can indicate to Terraform and\r\nproviders that a write-only arguments has changed by incrementing the\r\ncorresponding `_version` argument. For example, incrementing\r\n`password_wo_version` lets Terraform know the value of `password_wo` has\r\nchanged. Terraform then records that change in its plan, notifying the provider\r\nthat `password_wo` has a new value it can use.\r\n```\r\n\r\nAlso, we should make it clear that the `_wo`/`_wo_version` pattern isn't required, and not every provider has to follow the same pattern AWS uses (although they probably mostly will).",
        "pr_file_module": null
      },
      {
        "comment_id": "1972379802",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1972331666",
        "commented_code": "@@ -1,73 +1,66 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n \n In your configuration, you can only reference an `ephemeral` block in [other ephemeral contexts](/terraform/language/resources/ephemeral/reference#reference-ephemeral-resources).\n \n ### Lifecycle\n \n-The lifecycle of an ephemeral resource is different from resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n+The lifecycle of an `ephemeral` resource is different from other resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n \n 1. If Terraform needs to access the result of an ephemeral resource, it opens\n that ephemeral resource. For example, if Terraform opens an ephemeral resource for a Vault secret, the Vault provider obtains a lease and returns a secret. \n \n 1. If Terraform needs access to the ephemeral resource for longer than the\n remote system's enforced expiration time, Terraform asks the provider\n-to renew it periodically. For example, if Terraform renews a Vault secret ephemeral resource, the Vault provider then calls Vault's lease renewal API endpoint to extend the expiration time.\n+to periodically renew it. For example, if Terraform renews a Vault secret `ephemeral` resource, the Vault provider calls Vault's lease renewal API endpoint to extend the expiration time.\n \n 1. Once Terraform no longer needs an ephemeral resource, Terraform closes\n-it. This happens after the providers that depend on a certain ephemeral resource\n+it. This happens after the providers that depend on an ephemeral resource\n complete all of their work for the current Terraform run phase. For example, closing a Vault secret ephemeral resource means the Vault provider explicitly ends the lease, allowing Vault to immediately revoke the associated credentials.\n \n Terraform follows these lifecycle steps for each instance of an ephemeral\n resource in a given configuration.\n \n ### Configuration model\n \n-To learn more about the `ephemeral` block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n+To learn more about the `ephemeral` resource block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n \n ## Write-only arguments\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+Terraform's managed resources, defined by `resource` blocks, can include ephemeral arguments, called **write-only arguments**. Write-only arguments are only available during the current Terraform operation, and Terraform does not store them in state or plan files.  \n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Use write-only arguments to securely pass temporary values to resources during a Terraform operation without worrying about Terraform persisting those values. For example, the `aws_db_instance` resource has a write-only `password_wo` argument that accepts a database password:",
        "comment_created_at": "2025-02-26T20:42:28+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "Oh, I see later on that it's on the write-only page, but I think we should mention it here as well since the example includes them.",
        "pr_file_module": null
      },
      {
        "comment_id": "1972526169",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/index.mdx",
        "discussion_id": "1972331666",
        "commented_code": "@@ -1,73 +1,66 @@\n ---\n page_title: Ephemeral resources\n-description: Learn how to use ephemeral resource blocks and write-only arguments to manage temporary data that Terraform does not store in state. \n+description: Learn how to keep sensitive resource data out of state and plan files in Terraform with ephemeral resource blocks and write-only arguments.\n ---\n \n # Ephemerality in resources\n \n-Managing infrastructure often requires creating and handling temporary sensitive values, such as passwords, that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n+Managing infrastructure often requires creating and handling temporary sensitive values that you may not want Terraform to persist outside of the current operation. Terraform provides two tools for resources to manage data you do not want to store in state or plan files: the `ephemeral` resource block and ephemeral write-only arguments on specific resources.\n \n ## Ephemeral resources\n \n-Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store them in its state. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n+Ephemeral resources are Terraform resources that are essentially temporary. Ephemeral resources have a unique lifecycle, and Terraform does not store information about ephemeral resources in state or plan files. Each `ephemeral` block describes one or more ephemeral resources, such as a temporary password or connection to another system.\n \n In your configuration, you can only reference an `ephemeral` block in [other ephemeral contexts](/terraform/language/resources/ephemeral/reference#reference-ephemeral-resources).\n \n ### Lifecycle\n \n-The lifecycle of an ephemeral resource is different from resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n+The lifecycle of an `ephemeral` resource is different from other resources and data sources. When Terraform provisions ephemeral resources, it performs the following steps:\n \n 1. If Terraform needs to access the result of an ephemeral resource, it opens\n that ephemeral resource. For example, if Terraform opens an ephemeral resource for a Vault secret, the Vault provider obtains a lease and returns a secret. \n \n 1. If Terraform needs access to the ephemeral resource for longer than the\n remote system's enforced expiration time, Terraform asks the provider\n-to renew it periodically. For example, if Terraform renews a Vault secret ephemeral resource, the Vault provider then calls Vault's lease renewal API endpoint to extend the expiration time.\n+to periodically renew it. For example, if Terraform renews a Vault secret `ephemeral` resource, the Vault provider calls Vault's lease renewal API endpoint to extend the expiration time.\n \n 1. Once Terraform no longer needs an ephemeral resource, Terraform closes\n-it. This happens after the providers that depend on a certain ephemeral resource\n+it. This happens after the providers that depend on an ephemeral resource\n complete all of their work for the current Terraform run phase. For example, closing a Vault secret ephemeral resource means the Vault provider explicitly ends the lease, allowing Vault to immediately revoke the associated credentials.\n \n Terraform follows these lifecycle steps for each instance of an ephemeral\n resource in a given configuration.\n \n ### Configuration model\n \n-To learn more about the `ephemeral` block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n+To learn more about the `ephemeral` resource block, refer to the [Ephemeral resource reference](/terraform/language/resources/ephemeral/reference).\n \n ## Write-only arguments\n \n--> **Public Beta**: Write-only arguments are in public beta and available in Terraform v1.11 and later.  Public beta features and APIs are subject to change.\n+Terraform's managed resources, defined by `resource` blocks, can include ephemeral arguments, called **write-only arguments**. Write-only arguments are only available during the current Terraform operation, and Terraform does not store them in state or plan files.  \n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Use write-only arguments to securely pass temporary values to resources during a Terraform operation without worrying about Terraform persisting those values. For example, the `aws_db_instance` resource has a write-only `password_wo` argument that accepts a database password:",
        "comment_created_at": "2025-02-26T22:41:19+00:00",
        "comment_author": "rkoron007",
        "comment_body": "I actually don't want to get into versioning here since this is just the overview, and I'm trying to keep the scope pretty high-level to the what/why use a write-only arg. \r\n\r\nGarvita asked I include the versioning argument for best practices, which I agree is a good idea, but I want people to go the full page for all the details of how the arg works and how versioning works.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1972338599",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-02-26T20:14:58+00:00",
    "commented_code": "---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1972338599",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1972338599",
        "commented_code": "@@ -1,44 +1,128 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. ",
        "comment_created_at": "2025-02-26T20:14:58+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\nWrite-only arguments let you securely pass ephemeral values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a password, token, or session identifier. \r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1972344378",
    "pr_number": 36572,
    "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
    "created_at": "2025-02-26T20:18:02+00:00",
    "commented_code": "---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:",
    "repo_full_name": "hashicorp/terraform",
    "discussion_comments": [
      {
        "comment_id": "1972344378",
        "repo_full_name": "hashicorp/terraform",
        "pr_number": 36572,
        "pr_file": "website/docs/language/resources/ephemeral/write-only.mdx",
        "discussion_id": "1972344378",
        "commented_code": "@@ -1,44 +1,128 @@\n ---\n page_title: Use write-only arguments\n-description: Learn how to use write-only arguments to set temporary values that can only be overwritten and are not stored in Terraform's state.\n+description: Learn how to use write-only arguments to set temporary values that are not stored in Terraform's state or plan files.\n ---\n \n-<!-- THIS IS HIDDEN FOR NOW - TODO FOR GA: unhide when we have a code snippet to share and I can add more details -->\n-\n # Use write-only arguments\n \n-Terraform resources can include ephemeral arguments, also known as attributes, for data that only needs to exist temporarily. An ephemeral argument on a resource is called a \"write-only argument\". Write-only arguments can help store generated sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier.\n+Write-only arguments let you securely pass temporary values to Terraform resources during a Terraform operation without persisting those values to state or plan files. Use write-only arguments to store sensitive data for the current Terraform operation, such as a short-lived password, token, or session identifier. \n+\n+## Background\n+\n+Write-only arguments are only available during the runtime of a Terraform operation, and Terraform omits those values from state and plan files.\n+\n+> **Hands-on**: Declare a write-only argument in the [Upgrade RDS major version](/terraform/tutorials/aws/rds-upgrade) tutorial.\n+\n+You can use write-only arguments to pass ephemeral values directly to a resource without Terraform persisting that value. For example, you can directly pass a generated password or a fetched token to a write-only argument without risking Terraform exposing that value. Use write-only arguments to ensure sensitive data only exists during the current Terraform operation.\n+\n+Unlike other ephemeral constructs in Terraform, such as ephemeral resources or variables, write-only arguments also accept both ephemeral and non-ephemeral values.\n+\n+## Requirements\n+\n+To use write-only arguments, you must use Terraform v.1.11 or later and use a resource that supports write-only arguments.\n+\n+## Declare a write-only argument\n+\n+Providers indicate in the Terraform registry whether an argument is write-only. For example, the `aws` provider's `aws_db_instance` resource has a write-only `password_wo` argument. The `password_wo` argument accepts a value to use as the database password:\n+\n+<CodeBlockConfig highlight=\"7\">\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = <ephemeral or non-ephemeral value>\n+  password_wo_version = 1\n+}\n+```\n+\n+</CodeBlockConfig>\n+\n+Write-only arguments accept both ephemeral and non-ephemeral values. For example, you could also use a string as the value of a write-only argument:\n+\n+```hcl\n+resource \"aws_db_instance\" \"test\" {\n+  instance_class      = \"db.t5.micro\"\n+  allocated_storage   = \"5\"\n+  engine              = \"postgres\"\n+  username            = \"admin\"\n+  skip_final_snapshot = true\n+  password_wo         = \"my-password-here\"\n+  password_wo_version = 1\n+}\n+```\n+\n+However, we recommend using write-only arguments for passing ephemeral values to resources. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:",
        "comment_created_at": "2025-02-26T20:18:02+00:00",
        "comment_author": "robin-norwood",
        "comment_body": "```suggestion\r\nHowever, we recommend using write-only arguments for passing ephemeral values to resources. If you use a non-ephemeral value, Terraform stores that value or hard-codes it in your configuration. For example, you can use an `ephemeral` resource to generate a random password and pass it to the `password_wo` write-only argument:\r\n```\r\n\r\nTrying to get to the \"why\" we recommend, but ignore if too much.",
        "pr_file_module": null
      }
    ]
  }
]