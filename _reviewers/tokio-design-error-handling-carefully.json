[
  {
    "discussion_id": "1530031030",
    "pr_number": 6381,
    "pr_file": "tokio/src/fs/file.rs",
    "created_at": "2024-03-19T09:42:36+00:00",
    "commented_code": "/// let std_file = std::fs::File::open(\"foo.txt\").unwrap();\n     /// let file = tokio::fs::File::from_std(std_file);\n     /// ```\n-    pub fn from_std(std: StdFile) -> File {\n+    pub fn from_std(mut std: StdFile) -> File {\n+        let pos = std.stream_position().unwrap();",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1530031030",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6381,
        "pr_file": "tokio/src/fs/file.rs",
        "discussion_id": "1530031030",
        "commented_code": "@@ -233,13 +233,14 @@ impl File {\n     /// let std_file = std::fs::File::open(\"foo.txt\").unwrap();\n     /// let file = tokio::fs::File::from_std(std_file);\n     /// ```\n-    pub fn from_std(std: StdFile) -> File {\n+    pub fn from_std(mut std: StdFile) -> File {\n+        let pos = std.stream_position().unwrap();",
        "comment_created_at": "2024-03-19T09:42:36+00:00",
        "comment_author": "Darksonn",
        "comment_body": "I think we probably want to just fall back to existing behavior if `stream_position` fails.\r\n```suggestion\r\n        let pos = std.stream_position().unwrap_or(0);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1494584142",
    "pr_number": 6345,
    "pr_file": "tokio/src/io/async_fd.rs",
    "created_at": "2024-02-19T13:54:40+00:00",
    "commented_code": "/// [`try_io`]: method@AsyncFdReadyGuard::try_io\n #[derive(Debug)]\n pub struct TryIoError(());\n+\n+/// Error returned by [`try_new`] or [`try_with_interest`].\n+///\n+/// [`try_new`]: AsyncFd::try_new\n+/// [`try_with_interest`]: AsyncFd::try_with_interest\n+pub struct AsyncFdError<T> {\n+    inner: T,\n+    cause: io::Error,\n+}\n+\n+impl<T> AsyncFdError<T> {\n+    /// Returns the original object passed to [`try_new`] or [`try_with_interest`]\n+    /// alongside the error that caused these functions to fail.\n+    ///\n+    /// [`try_new`]: AsyncFd::try_new\n+    /// [`try_with_interest`]: AsyncFd::try_with_interest\n+    pub fn into_parts(self) -> (T, io::Error) {\n+        (self.inner, self.cause)\n+    }\n+}\n+\n+impl<T> fmt::Display for AsyncFdError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.cause, f)\n+    }\n+}\n+\n+impl<T> fmt::Debug for AsyncFdError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.cause, f)\n+    }\n+}\n+\n+impl<T> Error for AsyncFdError<T> {}",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1494584142",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6345,
        "pr_file": "tokio/src/io/async_fd.rs",
        "discussion_id": "1494584142",
        "commented_code": "@@ -1257,3 +1313,43 @@ impl<'a, T: std::fmt::Debug + AsRawFd> std::fmt::Debug for AsyncFdReadyMutGuard<\n /// [`try_io`]: method@AsyncFdReadyGuard::try_io\n #[derive(Debug)]\n pub struct TryIoError(());\n+\n+/// Error returned by [`try_new`] or [`try_with_interest`].\n+///\n+/// [`try_new`]: AsyncFd::try_new\n+/// [`try_with_interest`]: AsyncFd::try_with_interest\n+pub struct AsyncFdError<T> {\n+    inner: T,\n+    cause: io::Error,\n+}\n+\n+impl<T> AsyncFdError<T> {\n+    /// Returns the original object passed to [`try_new`] or [`try_with_interest`]\n+    /// alongside the error that caused these functions to fail.\n+    ///\n+    /// [`try_new`]: AsyncFd::try_new\n+    /// [`try_with_interest`]: AsyncFd::try_with_interest\n+    pub fn into_parts(self) -> (T, io::Error) {\n+        (self.inner, self.cause)\n+    }\n+}\n+\n+impl<T> fmt::Display for AsyncFdError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.cause, f)\n+    }\n+}\n+\n+impl<T> fmt::Debug for AsyncFdError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.cause, f)\n+    }\n+}\n+\n+impl<T> Error for AsyncFdError<T> {}",
        "comment_created_at": "2024-02-19T13:54:40+00:00",
        "comment_author": "Darksonn",
        "comment_body": "You could implement the `source` method here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2176320157",
    "pr_number": 7418,
    "pr_file": "tokio/src/sync/set_once.rs",
    "created_at": "2025-07-01T03:04:31+00:00",
    "commented_code": "+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    // AtomicU8 has 3 states, EMPTY, SETTING and DONE\n+    // is described by the `AtomicState` enum.\n+    value_set: AtomicU8,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+#[repr(u8)]\n+#[derive(PartialEq, Eq)]\n+pub(crate) enum AtomicState {\n+    Empty = 0,\n+    // SETTING means \"set is currently running\"\n+    Setting = 1,\n+    Done = 2,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: Inside the drop implementation of SetOnce also\n+            // initalized. we cast `MaybeUninit<T>` to *mut T\n+            // because `MaybeUninit<T>` doesnt have a destructor\n+            unsafe {\n+                self.value.with_mut(|ptr| ptr::drop_in_place(ptr as *mut T));\n+            }\n+            // no need to change value_set here as SetOnce is being dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            // value has been initialized\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire) == AtomicState::Done as u8\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the self.value_set AtomicUsize is flipped from\n+    // AtomicState::Empty to AtomicState::Setting meaning that the value is\n+    // being set from uinitialized to initialized via this function.\n+    //\n+    // It needs to be done in the order to ensure the safety of this function\n+    // across threads, this function will mutate the value_set to be\n+    // AtomicState::Done.\n+    unsafe fn set_value(&self, value: T) {\n+        self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+\n+        // Store that we're done in Release so any `Acquire` can see\n+        self.value_set\n+            .store(AtomicState::Done as _, Ordering::Release);\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // to capture any writes that are done with `Ordering::Release`\n+        let ordering = Ordering::Acquire;\n+        let state_setting = AtomicState::Setting as u8;\n+\n+        match self.value_set.compare_exchange(\n+            // we expect the set to be uninitialized\n+            AtomicState::Empty as _,\n+            // we want to lock the Set\n+            state_setting,\n+            ordering,\n+            ordering,\n+        ) {\n+            Ok(_) => {\n+                // SAFETY: We changed the state from EMPTY to SETTING,\n+                // this declares the set to be currently running\n+                unsafe {\n+                    self.set_value(value);\n+                }\n+\n+                Ok(())\n+            }\n+            Err(true_val) => {\n+                // The value is being currently set in another thread\n+                if true_val == state_setting {\n+                    Err(SetError::InitializingError(value))\n+                } else {\n+                    // here means true_val is either Done or higher\n+                    Err(SetError::AlreadyInitializedError(value))\n+                }\n+            }\n+        }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2176320157",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2176320157",
        "commented_code": "@@ -0,0 +1,377 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    // AtomicU8 has 3 states, EMPTY, SETTING and DONE\n+    // is described by the `AtomicState` enum.\n+    value_set: AtomicU8,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+#[repr(u8)]\n+#[derive(PartialEq, Eq)]\n+pub(crate) enum AtomicState {\n+    Empty = 0,\n+    // SETTING means \"set is currently running\"\n+    Setting = 1,\n+    Done = 2,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: Inside the drop implementation of SetOnce also\n+            // initalized. we cast `MaybeUninit<T>` to *mut T\n+            // because `MaybeUninit<T>` doesnt have a destructor\n+            unsafe {\n+                self.value.with_mut(|ptr| ptr::drop_in_place(ptr as *mut T));\n+            }\n+            // no need to change value_set here as SetOnce is being dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            // value has been initialized\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire) == AtomicState::Done as u8\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the self.value_set AtomicUsize is flipped from\n+    // AtomicState::Empty to AtomicState::Setting meaning that the value is\n+    // being set from uinitialized to initialized via this function.\n+    //\n+    // It needs to be done in the order to ensure the safety of this function\n+    // across threads, this function will mutate the value_set to be\n+    // AtomicState::Done.\n+    unsafe fn set_value(&self, value: T) {\n+        self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+\n+        // Store that we're done in Release so any `Acquire` can see\n+        self.value_set\n+            .store(AtomicState::Done as _, Ordering::Release);\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // to capture any writes that are done with `Ordering::Release`\n+        let ordering = Ordering::Acquire;\n+        let state_setting = AtomicState::Setting as u8;\n+\n+        match self.value_set.compare_exchange(\n+            // we expect the set to be uninitialized\n+            AtomicState::Empty as _,\n+            // we want to lock the Set\n+            state_setting,\n+            ordering,\n+            ordering,\n+        ) {\n+            Ok(_) => {\n+                // SAFETY: We changed the state from EMPTY to SETTING,\n+                // this declares the set to be currently running\n+                unsafe {\n+                    self.set_value(value);\n+                }\n+\n+                Ok(())\n+            }\n+            Err(true_val) => {\n+                // The value is being currently set in another thread\n+                if true_val == state_setting {\n+                    Err(SetError::InitializingError(value))\n+                } else {\n+                    // here means true_val is either Done or higher\n+                    Err(SetError::AlreadyInitializedError(value))\n+                }\n+            }\n+        }",
        "comment_created_at": "2025-07-01T03:04:31+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "```rust\r\nErr(actual) if actual == state_setting => {},\r\nErr(actual) if actual == state_done => {},\r\nErr(actual) => { /* consider panic in this branch */},\r\n```\r\n\r\nThis might be more readable.",
        "pr_file_module": null
      },
      {
        "comment_id": "2177105406",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2176320157",
        "commented_code": "@@ -0,0 +1,377 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    // AtomicU8 has 3 states, EMPTY, SETTING and DONE\n+    // is described by the `AtomicState` enum.\n+    value_set: AtomicU8,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+#[repr(u8)]\n+#[derive(PartialEq, Eq)]\n+pub(crate) enum AtomicState {\n+    Empty = 0,\n+    // SETTING means \"set is currently running\"\n+    Setting = 1,\n+    Done = 2,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: Inside the drop implementation of SetOnce also\n+            // initalized. we cast `MaybeUninit<T>` to *mut T\n+            // because `MaybeUninit<T>` doesnt have a destructor\n+            unsafe {\n+                self.value.with_mut(|ptr| ptr::drop_in_place(ptr as *mut T));\n+            }\n+            // no need to change value_set here as SetOnce is being dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            // value has been initialized\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire) == AtomicState::Done as u8\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the self.value_set AtomicUsize is flipped from\n+    // AtomicState::Empty to AtomicState::Setting meaning that the value is\n+    // being set from uinitialized to initialized via this function.\n+    //\n+    // It needs to be done in the order to ensure the safety of this function\n+    // across threads, this function will mutate the value_set to be\n+    // AtomicState::Done.\n+    unsafe fn set_value(&self, value: T) {\n+        self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+\n+        // Store that we're done in Release so any `Acquire` can see\n+        self.value_set\n+            .store(AtomicState::Done as _, Ordering::Release);\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // to capture any writes that are done with `Ordering::Release`\n+        let ordering = Ordering::Acquire;\n+        let state_setting = AtomicState::Setting as u8;\n+\n+        match self.value_set.compare_exchange(\n+            // we expect the set to be uninitialized\n+            AtomicState::Empty as _,\n+            // we want to lock the Set\n+            state_setting,\n+            ordering,\n+            ordering,\n+        ) {\n+            Ok(_) => {\n+                // SAFETY: We changed the state from EMPTY to SETTING,\n+                // this declares the set to be currently running\n+                unsafe {\n+                    self.set_value(value);\n+                }\n+\n+                Ok(())\n+            }\n+            Err(true_val) => {\n+                // The value is being currently set in another thread\n+                if true_val == state_setting {\n+                    Err(SetError::InitializingError(value))\n+                } else {\n+                    // here means true_val is either Done or higher\n+                    Err(SetError::AlreadyInitializedError(value))\n+                }\n+            }\n+        }",
        "comment_created_at": "2025-07-01T10:10:29+00:00",
        "comment_author": "Darksonn",
        "comment_body": "I don't think we want two separate kinds of errors here. With `OnceCell` initialization can fail and can take a long time, so it's important to consider it to be a separate state, but with `SetOnce` the initialization state is always very short-lived and infallible, so I don't think we want to expose it to the end-user.",
        "pr_file_module": null
      },
      {
        "comment_id": "2177377290",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2176320157",
        "commented_code": "@@ -0,0 +1,377 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    // AtomicU8 has 3 states, EMPTY, SETTING and DONE\n+    // is described by the `AtomicState` enum.\n+    value_set: AtomicU8,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+#[repr(u8)]\n+#[derive(PartialEq, Eq)]\n+pub(crate) enum AtomicState {\n+    Empty = 0,\n+    // SETTING means \"set is currently running\"\n+    Setting = 1,\n+    Done = 2,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: Inside the drop implementation of SetOnce also\n+            // initalized. we cast `MaybeUninit<T>` to *mut T\n+            // because `MaybeUninit<T>` doesnt have a destructor\n+            unsafe {\n+                self.value.with_mut(|ptr| ptr::drop_in_place(ptr as *mut T));\n+            }\n+            // no need to change value_set here as SetOnce is being dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            // value has been initialized\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire) == AtomicState::Done as u8\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the self.value_set AtomicUsize is flipped from\n+    // AtomicState::Empty to AtomicState::Setting meaning that the value is\n+    // being set from uinitialized to initialized via this function.\n+    //\n+    // It needs to be done in the order to ensure the safety of this function\n+    // across threads, this function will mutate the value_set to be\n+    // AtomicState::Done.\n+    unsafe fn set_value(&self, value: T) {\n+        self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+\n+        // Store that we're done in Release so any `Acquire` can see\n+        self.value_set\n+            .store(AtomicState::Done as _, Ordering::Release);\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // to capture any writes that are done with `Ordering::Release`\n+        let ordering = Ordering::Acquire;\n+        let state_setting = AtomicState::Setting as u8;\n+\n+        match self.value_set.compare_exchange(\n+            // we expect the set to be uninitialized\n+            AtomicState::Empty as _,\n+            // we want to lock the Set\n+            state_setting,\n+            ordering,\n+            ordering,\n+        ) {\n+            Ok(_) => {\n+                // SAFETY: We changed the state from EMPTY to SETTING,\n+                // this declares the set to be currently running\n+                unsafe {\n+                    self.set_value(value);\n+                }\n+\n+                Ok(())\n+            }\n+            Err(true_val) => {\n+                // The value is being currently set in another thread\n+                if true_val == state_setting {\n+                    Err(SetError::InitializingError(value))\n+                } else {\n+                    // here means true_val is either Done or higher\n+                    Err(SetError::AlreadyInitializedError(value))\n+                }\n+            }\n+        }",
        "comment_created_at": "2025-07-01T11:42:11+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "> but with SetOnce the initialization state is always very short-lived and infallible, so I don't think we want to expose it to the end-user.\r\n\r\nI agree with this, it makes a lot of sense.",
        "pr_file_module": null
      },
      {
        "comment_id": "2180728987",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2176320157",
        "commented_code": "@@ -0,0 +1,377 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    // AtomicU8 has 3 states, EMPTY, SETTING and DONE\n+    // is described by the `AtomicState` enum.\n+    value_set: AtomicU8,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+#[repr(u8)]\n+#[derive(PartialEq, Eq)]\n+pub(crate) enum AtomicState {\n+    Empty = 0,\n+    // SETTING means \"set is currently running\"\n+    Setting = 1,\n+    Done = 2,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: Inside the drop implementation of SetOnce also\n+            // initalized. we cast `MaybeUninit<T>` to *mut T\n+            // because `MaybeUninit<T>` doesnt have a destructor\n+            unsafe {\n+                self.value.with_mut(|ptr| ptr::drop_in_place(ptr as *mut T));\n+            }\n+            // no need to change value_set here as SetOnce is being dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            // value has been initialized\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Empty as _),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicU8::new(AtomicState::Done as _),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire) == AtomicState::Done as u8\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the self.value_set AtomicUsize is flipped from\n+    // AtomicState::Empty to AtomicState::Setting meaning that the value is\n+    // being set from uinitialized to initialized via this function.\n+    //\n+    // It needs to be done in the order to ensure the safety of this function\n+    // across threads, this function will mutate the value_set to be\n+    // AtomicState::Done.\n+    unsafe fn set_value(&self, value: T) {\n+        self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+\n+        // Store that we're done in Release so any `Acquire` can see\n+        self.value_set\n+            .store(AtomicState::Done as _, Ordering::Release);\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // to capture any writes that are done with `Ordering::Release`\n+        let ordering = Ordering::Acquire;\n+        let state_setting = AtomicState::Setting as u8;\n+\n+        match self.value_set.compare_exchange(\n+            // we expect the set to be uninitialized\n+            AtomicState::Empty as _,\n+            // we want to lock the Set\n+            state_setting,\n+            ordering,\n+            ordering,\n+        ) {\n+            Ok(_) => {\n+                // SAFETY: We changed the state from EMPTY to SETTING,\n+                // this declares the set to be currently running\n+                unsafe {\n+                    self.set_value(value);\n+                }\n+\n+                Ok(())\n+            }\n+            Err(true_val) => {\n+                // The value is being currently set in another thread\n+                if true_val == state_setting {\n+                    Err(SetError::InitializingError(value))\n+                } else {\n+                    // here means true_val is either Done or higher\n+                    Err(SetError::AlreadyInitializedError(value))\n+                }\n+            }\n+        }",
        "comment_created_at": "2025-07-02T18:29:19+00:00",
        "comment_author": "Daksh14",
        "comment_body": "Resolved as we're back to using my original AtomicBool approach",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1968263372",
    "pr_number": 7166,
    "pr_file": "tokio/src/util/blocking_check.rs",
    "created_at": "2025-02-24T19:12:03+00:00",
    "commented_code": "+#[cfg(unix)]\n+use std::os::fd::AsFd;\n+\n+#[cfg(unix)]\n+#[allow(unused_variables)]\n+pub(crate) fn check_socket_for_blocking<S: AsFd>(s: &S) -> crate::io::Result<()> {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1968263372",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7166,
        "pr_file": "tokio/src/util/blocking_check.rs",
        "discussion_id": "1968263372",
        "commented_code": "@@ -0,0 +1,25 @@\n+#[cfg(unix)]\n+use std::os::fd::AsFd;\n+\n+#[cfg(unix)]\n+#[allow(unused_variables)]\n+pub(crate) fn check_socket_for_blocking<S: AsFd>(s: &S) -> crate::io::Result<()> {",
        "comment_created_at": "2025-02-24T19:12:03+00:00",
        "comment_author": "carllerche",
        "comment_body": "Why does this return `io::Result`? It doesn't seem like the fn needs a return argument.",
        "pr_file_module": null
      },
      {
        "comment_id": "1976441292",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7166,
        "pr_file": "tokio/src/util/blocking_check.rs",
        "discussion_id": "1968263372",
        "commented_code": "@@ -0,0 +1,25 @@\n+#[cfg(unix)]\n+use std::os::fd::AsFd;\n+\n+#[cfg(unix)]\n+#[allow(unused_variables)]\n+pub(crate) fn check_socket_for_blocking<S: AsFd>(s: &S) -> crate::io::Result<()> {",
        "comment_created_at": "2025-03-01T15:52:31+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "If the nonblocking check fails, propating the error seems the most straightforward response.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1943114639",
    "pr_number": 6815,
    "pr_file": "tokio-util/src/io/sync_bridge.rs",
    "created_at": "2025-02-05T15:04:23+00:00",
    "commented_code": "///     // Example: In-memory data.\n ///     let data = b\"Hello, world!\"; // A byte slice.\n ///     let reader = Cursor::new(data); // Create an in-memory AsyncRead.\n-///     compress_data(reader).await;\n+///     let _ = compress_data(reader).await;",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1943114639",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6815,
        "pr_file": "tokio-util/src/io/sync_bridge.rs",
        "discussion_id": "1943114639",
        "commented_code": "@@ -151,7 +150,7 @@ use tokio::io::{\n ///     // Example: In-memory data.\n ///     let data = b\"Hello, world!\"; // A byte slice.\n ///     let reader = Cursor::new(data); // Create an in-memory AsyncRead.\n-///     compress_data(reader).await;\n+///     let _ = compress_data(reader).await;",
        "comment_created_at": "2025-02-05T15:04:23+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Let's not ignore errors.\r\n```suggestion\r\n///     compress_data(reader).await?;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1875915507",
    "pr_number": 7024,
    "pr_file": "tokio-stream/src/wrappers/broadcast.rs",
    "created_at": "2024-12-09T12:37:29+00:00",
    "commented_code": "/// A wrapper around [`tokio::sync::broadcast::Receiver`] that implements [`Stream`].\n ///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::broadcast;\n+/// use tokio_stream::wrappers::BroadcastStream;\n+/// use tokio_stream::StreamExt;\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), Box<dyn std::error::Error>> {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1875915507",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7024,
        "pr_file": "tokio-stream/src/wrappers/broadcast.rs",
        "discussion_id": "1875915507",
        "commented_code": "@@ -10,6 +10,28 @@ use std::task::{ready, Context, Poll};\n \n /// A wrapper around [`tokio::sync::broadcast::Receiver`] that implements [`Stream`].\n ///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::broadcast;\n+/// use tokio_stream::wrappers::BroadcastStream;\n+/// use tokio_stream::StreamExt;\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), Box<dyn std::error::Error>> {",
        "comment_created_at": "2024-12-09T12:37:29+00:00",
        "comment_author": "Darksonn",
        "comment_body": "I like to avoid this error type in examples because it is not `Send` which means it only works in the `block_on` task.",
        "pr_file_module": null
      },
      {
        "comment_id": "1875933704",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7024,
        "pr_file": "tokio-stream/src/wrappers/broadcast.rs",
        "discussion_id": "1875915507",
        "commented_code": "@@ -10,6 +10,28 @@ use std::task::{ready, Context, Poll};\n \n /// A wrapper around [`tokio::sync::broadcast::Receiver`] that implements [`Stream`].\n ///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::broadcast;\n+/// use tokio_stream::wrappers::BroadcastStream;\n+/// use tokio_stream::StreamExt;\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), Box<dyn std::error::Error>> {",
        "comment_created_at": "2024-12-09T12:51:23+00:00",
        "comment_author": "joshka",
        "comment_body": "I generally aim to avoid `unwrap()` in docs - perhaps hiding the main function or omitting it entirely and specifying a typed Result::Ok might be more appropriate?",
        "pr_file_module": null
      },
      {
        "comment_id": "1875940773",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7024,
        "pr_file": "tokio-stream/src/wrappers/broadcast.rs",
        "discussion_id": "1875915507",
        "commented_code": "@@ -10,6 +10,28 @@ use std::task::{ready, Context, Poll};\n \n /// A wrapper around [`tokio::sync::broadcast::Receiver`] that implements [`Stream`].\n ///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::broadcast;\n+/// use tokio_stream::wrappers::BroadcastStream;\n+/// use tokio_stream::StreamExt;\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), Box<dyn std::error::Error>> {",
        "comment_created_at": "2024-12-09T12:56:46+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Avoiding unwrap is fine, I just prefer a different error type. E.g., it could be `Box<dyn Error+Send+Sync>`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1876994969",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7024,
        "pr_file": "tokio-stream/src/wrappers/broadcast.rs",
        "discussion_id": "1875915507",
        "commented_code": "@@ -10,6 +10,28 @@ use std::task::{ready, Context, Poll};\n \n /// A wrapper around [`tokio::sync::broadcast::Receiver`] that implements [`Stream`].\n ///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::broadcast;\n+/// use tokio_stream::wrappers::BroadcastStream;\n+/// use tokio_stream::StreamExt;\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), Box<dyn std::error::Error>> {",
        "comment_created_at": "2024-12-10T00:51:11+00:00",
        "comment_author": "joshka",
        "comment_body": "I addressed this by changing the result type to the actual result, and generally hiding the main function / return values in all examples.",
        "pr_file_module": null
      }
    ]
  }
]