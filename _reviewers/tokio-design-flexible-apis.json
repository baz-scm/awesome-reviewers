[
  {
    "discussion_id": "2173712224",
    "pr_number": 7418,
    "pr_file": "tokio/src/sync/set_once.rs",
    "created_at": "2025-06-29T10:35:53+00:00",
    "commented_code": "+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2173712224",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-29T10:35:53+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "```rust\r\npub async fn wait(&self) -> &T;\r\n```\r\n\r\nI would suggest this interface, because it is inconvenient to `await` first and then invoke `SetOnce::get`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2173713290",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-29T10:40:42+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "```rust\r\npub fn get(&self) -> Option<&T>\r\n```\r\n\r\nOther two reasons.\r\n\r\n1. `Option<T>` always create possibilities for runtime panic.\r\n2. It makes not sense to invoke `SetOnce::get` without preceding `SetOnce::wait().await`.\r\n\r\nSo I think `SetOnce::get` is unnecessary, let `SetOnce::wait` return `&T` is a better interface.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2173824103",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-29T16:33:09+00:00",
        "comment_author": "Daksh14",
        "comment_body": "@ADD-SP I agree that wait should return the T so we dont have to invoke get but shouldn't the wait return `Option<&T>` because what if you call wait on `SetOnce` which isn't initialized, should we just return a `futures::empty()`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2173824136",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-29T16:33:21+00:00",
        "comment_author": "Daksh14",
        "comment_body": "/cc @Darksonn ",
        "pr_file_module": null
      },
      {
        "comment_id": "2174157032",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-30T03:46:20+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "> shouldn't the wait return Option<&T> because what if you call wait on SetOnce which isn't initialized.\r\n\r\nI think the `SetOnce::wait().await` should only be resolved if any of the following requirements is met:\r\n\r\n1. Its value has been initialized.\r\n2. (OR) All other `SetOnce` instances has been dropped but the value is still uninitialized.\r\n\r\nI guess you meant that we should return `None` on (2). This should be a reasonable point which I didn't realized before.\r\n\r\nNow, there are two options.\r\n\r\n```rust\r\npub async fn wait(&self) -> Option<&T>;\r\n\r\n// OR\r\n\r\n// Error means all other instances\r\n// has been dropped and value\r\n// is still uninitialized.\r\npub async fn wait(&self) -> Result<&T, Error>\r\n```\r\n\r\nSelecting  `Option<&T>` indicates that we consider it a normal use case that `SetOnce` are never initialized. `Result<&T, Error`> indicates it is not.\r\n\r\nWhat do you think?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2174288319",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-30T06:02:55+00:00",
        "comment_author": "Daksh14",
        "comment_body": "we can have a `try_wait` and `wait` so we have both, `wait` should return `None` if memory is uninitialized but at that point you can just turn the result into an option with `.ok()` so I think we should keep the `-> Result<&T, Error>` to be the most descriptive as a library standpoint",
        "pr_file_module": null
      },
      {
        "comment_id": "2174466687",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-06-30T08:00:50+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Case 2 cannot happen since `SetOnce` isn't a channel that you clone. The return value can be a bare `&T`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2176303081",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-07-01T02:42:04+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "> Case 2 cannot happen since SetOnce isn't a channel that you clone. The return value can be a bare &T.\r\n\r\nAh, that's true. I would suggest `async fn wait(&self) -> &T`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2180851176",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7418,
        "pr_file": "tokio/src/sync/set_once.rs",
        "discussion_id": "2173712224",
        "commented_code": "@@ -0,0 +1,343 @@\n+use super::{Notify, SetError};\n+use crate::loom::cell::UnsafeCell;\n+use std::fmt;\n+use std::mem::MaybeUninit;\n+use std::ops::Drop;\n+use std::ptr;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+\n+// This file contains an implementation of an SetOnce. The value of SetOnce\n+// can only be modified once during initialization.\n+//\n+//  1. When `value_set` is false, the `value` is not initialized and wait()\n+//      future will keep on waiting\n+//  2. When `value_set` is true, the wait() future completes, get() will return\n+//      Some(&T)\n+//\n+// The value cannot be changed after set() is called. Subsequent calls to set()\n+// will return a `SetError`\n+\n+/// A thread-safe cell that can be written to only once.\n+/// A `SetOnce` is inspired from python's\n+/// [`asyncio.Event`](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event)\n+/// type. It can be used to wait until the value of the `SetOnce` is set like\n+/// a \"Event\" mechanism\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::SetOnce;\n+/// use std::sync::Arc;\n+///\n+/// #[tokio::main]\n+/// async fn main() {\n+///     let once = SetOnce::new();\n+///\n+///     let arc = Arc::new(once);\n+///     let first_cl = Arc::clone(&arc);\n+///     let second_cl = Arc::clone(&arc);\n+///\n+///     tokio::spawn(async move { first_cl.set(20) });\n+///\n+///     tokio::spawn(async move { second_cl.set(10) });\n+///\n+///     let res = arc.get(); // returns None\n+///     arc.wait().await; // lets wait until the value is set\n+///\n+///     println!(\"{:?}\", arc.get());\n+/// }\n+/// ```\n+///\n+/// A `SetOnce` is typically used for global variables that need to be\n+/// initialized once on first use, but need no further changes. The `SetOnce`\n+/// in Tokio allows the initialization procedure to be asynchronous.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use tokio::sync::{SetOnce, SetError};\n+///\n+///\n+/// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+///\n+/// #[tokio::main]\n+/// async fn main() -> Result<(), SetError<u32>> {\n+///     ONCE.set(2)?;\n+///     let result = ONCE.get();\n+///     assert_eq!(result, Some(&2));\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+pub struct SetOnce<T> {\n+    value_set: AtomicBool,\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    notify: Notify,\n+}\n+\n+impl<T> Default for SetOnce<T> {\n+    fn default() -> SetOnce<T> {\n+        SetOnce::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SetOnce<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"SetOnce\")\n+            .field(\"value\", &self.get())\n+            .finish()\n+    }\n+}\n+\n+impl<T: Clone> Clone for SetOnce<T> {\n+    fn clone(&self) -> SetOnce<T> {\n+        SetOnce::new_with(self.get().cloned())\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SetOnce<T> {\n+    fn eq(&self, other: &SetOnce<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SetOnce<T> {}\n+\n+impl<T> Drop for SetOnce<T> {\n+    fn drop(&mut self) {\n+        if self.initialized() {\n+            // SAFETY: We're inside the drop implementation of SetOnce\n+            // AND we're also initalized. This is the best way to ensure\n+            // out data gets dropped\n+            unsafe {\n+                let _ = self.value.with_mut(|ptr| ptr::read(ptr).assume_init());\n+            }\n+            // no need to set the flag to false as this set once is being\n+            // dropped\n+        }\n+    }\n+}\n+\n+impl<T> From<T> for SetOnce<T> {\n+    fn from(value: T) -> Self {\n+        SetOnce {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::new(),\n+        }\n+    }\n+}\n+\n+impl<T> SetOnce<T> {\n+    /// Creates a new empty `SetOnce` instance.\n+    pub fn new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::new(),\n+        }\n+    }\n+\n+    /// Creates a new empty `SetOnce` instance.\n+    ///\n+    /// Equivalent to `SetOnce::new`, except that it can be used in static\n+    /// variables.\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new` will not be instrumented. As such, it will not be visible\n+    /// in [`tokio-console`]. Instead, [`SetOnce::new`] should be used to\n+    /// create an instrumented object if that is needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use tokio::sync::{SetOnce, SetError};\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new();\n+    ///\n+    /// fn get_global_integer() -> Result<Option<&'static u32>, SetError<u32>> {\n+    ///     ONCE.set(2)?;\n+    ///     Ok(ONCE.get())\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() -> Result<(), SetError<u32>> {\n+    ///     let result = get_global_integer()?;\n+    ///\n+    ///     assert_eq!(result, Some(&2));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new() -> Self {\n+        Self {\n+            value_set: AtomicBool::new(false),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value, if any.\n+    ///\n+    /// If the `Option` is `None`, this is equivalent to `SetOnce::new`.\n+    ///\n+    /// [`SetOnce::new`]: crate::sync::SetOnce::new\n+    pub fn new_with(value: Option<T>) -> Self {\n+        if let Some(v) = value {\n+            SetOnce::from(v)\n+        } else {\n+            SetOnce::new()\n+        }\n+    }\n+\n+    /// Creates a new `SetOnce` that contains the provided value.\n+    ///\n+    /// # Example\n+    ///\n+    /// When using the `tracing` [unstable feature], a `SetOnce` created with\n+    /// `const_new_with` will not be instrumented. As such, it will not be\n+    /// visible in [`tokio-console`]. Instead, [`SetOnce::new_with`] should be\n+    /// used to create an instrumented object if that is needed.\n+    ///\n+    /// ```\n+    /// use tokio::sync::SetOnce;\n+    ///\n+    /// static ONCE: SetOnce<u32> = SetOnce::const_new_with(1);\n+    ///\n+    /// fn get_global_integer() -> Option<&'static u32> {\n+    ///     ONCE.get()\n+    /// }\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let result = get_global_integer();\n+    ///\n+    ///     assert_eq!(result, Some(&1));\n+    /// }\n+    /// ```\n+    ///\n+    /// [`tokio-console`]: https://github.com/tokio-rs/console\n+    /// [unstable feature]: crate#unstable-features\n+    #[cfg(not(all(loom, test)))]\n+    pub const fn const_new_with(value: T) -> Self {\n+        Self {\n+            value_set: AtomicBool::new(true),\n+            value: UnsafeCell::new(MaybeUninit::new(value)),\n+            notify: Notify::const_new(),\n+        }\n+    }\n+\n+    /// Returns `true` if the `SetOnce` currently contains a value, and `false`\n+    /// otherwise.\n+    pub fn initialized(&self) -> bool {\n+        // Using acquire ordering so we're able to read/catch any writes that\n+        // are done with `Ordering::Release`\n+        self.value_set.load(Ordering::Acquire)\n+    }\n+\n+    // SAFETY: The SetOnce must not be empty.\n+    unsafe fn get_unchecked(&self) -> &T {\n+        &*self.value.with(|ptr| (*ptr).as_ptr())\n+    }\n+\n+    /// Returns a reference to the value currently stored in the `SetOnce`, or\n+    /// `None` if the `SetOnce` is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.initialized() {\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // SAFETY: The caller of this function needs to ensure that this function is\n+    // called only when the value_set AtomicBool is flipped from FALSE to TRUE\n+    // meaning that the value is being set from uinitialized to initialized via\n+    // this function\n+    unsafe fn set_value(&self, value: T) {\n+        unsafe {\n+            self.value.with_mut(|ptr| (*ptr).as_mut_ptr().write(value));\n+        }\n+\n+        // notify the waiting wakers that the value is set\n+        self.notify.notify_waiters();\n+    }\n+\n+    /// Sets the value of the `SetOnce` to the given value if the `SetOnce` is\n+    /// empty.\n+    ///\n+    /// If the `SetOnce` already has a value, this call will fail with an\n+    /// [`SetError::AlreadyInitializedError`].\n+    ///\n+    /// If the `SetOnce` is empty, but some other task is currently trying to\n+    /// set the value, this call will fail with [`SetError::InitializingError`].\n+    ///\n+    /// [`SetError::AlreadyInitializedError`]: crate::sync::SetError::AlreadyInitializedError\n+    /// [`SetError::InitializingError`]: crate::sync::SetError::InitializingError\n+    pub fn set(&self, value: T) -> Result<(), SetError<T>> {\n+        if self.initialized() {\n+            return Err(SetError::AlreadyInitializedError(value));\n+        }\n+\n+        // Using release ordering so any threads that read a true from this\n+        // atomic is able to read the value we just stored.\n+        if !self.value_set.swap(true, Ordering::Release) {\n+            // SAFETY: We are swapping the value_set AtomicBool from FALSE to\n+            // TRUE with it being previously false and followed by that we are\n+            // initializing the unsafe Cell field with the value\n+            unsafe {\n+                self.set_value(value);\n+            }\n+\n+            Ok(())\n+        } else {\n+            Err(SetError::InitializingError(value))\n+        }\n+    }\n+\n+    /// Takes the value from the cell, destroying the cell in the process.\n+    /// Returns `None` if the cell is empty.\n+    pub fn into_inner(mut self) -> Option<T> {\n+        if self.initialized() {\n+            // Since we have taken ownership of self, its drop implementation\n+            // will be called by the end of this function, to prevent a double\n+            // free we will set the value_set to false so that the drop\n+            // implementation does not try to drop the value again.\n+            *self.value_set.get_mut() = false;\n+\n+            // SAFETY: The SetOnce is currently initialized, we can assume the\n+            // value is initialized and return that, when we return the value\n+            // we give the drop handler to the return scope.\n+            Some(unsafe { self.value.with_mut(|ptr| ptr::read(ptr).assume_init()) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Waits until the `SetOnce` has been initialized. Once the `SetOnce` is\n+    /// initialized the wakers are notified and the Future returned from this\n+    /// function completes.\n+    ///\n+    /// If this function is called after the `SetOnce` is initialized then\n+    /// empty future is returned which completes immediately.\n+    pub async fn wait(&self) {\n+        if !self.initialized() {\n+            let _ = self.notify.notified().await;\n+        }\n+    }",
        "comment_created_at": "2025-07-02T19:46:29+00:00",
        "comment_author": "Daksh14",
        "comment_body": "Changed to `async fn wait(&self) -> &T` and added  `async fn get_wait(&self) -> Option<&T>`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1990667451",
    "pr_number": 7212,
    "pr_file": "tokio-test/src/io.rs",
    "created_at": "2025-03-12T06:02:40+00:00",
    "commented_code": "self\n     }\n \n+    /// Set name of the mock IO object to include in panic messages and debug output\n+    pub fn name(&mut self, name: String) -> &mut Self {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1990667451",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7212,
        "pr_file": "tokio-test/src/io.rs",
        "discussion_id": "1990667451",
        "commented_code": "@@ -127,6 +129,12 @@ impl Builder {\n         self\n     }\n \n+    /// Set name of the mock IO object to include in panic messages and debug output\n+    pub fn name(&mut self, name: String) -> &mut Self {",
        "comment_created_at": "2025-03-12T06:02:40+00:00",
        "comment_author": "mox692",
        "comment_body": "How about accepting `Into<String>` for more flexibility?\r\n\r\nFor example: https://github.com/tokio-rs/tokio/blob/8507e28f89916662d2f61af823993483169d912c/tokio/src/runtime/builder.rs#L488",
        "pr_file_module": null
      },
      {
        "comment_id": "1990899510",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7212,
        "pr_file": "tokio-test/src/io.rs",
        "discussion_id": "1990667451",
        "commented_code": "@@ -127,6 +129,12 @@ impl Builder {\n         self\n     }\n \n+    /// Set name of the mock IO object to include in panic messages and debug output\n+    pub fn name(&mut self, name: String) -> &mut Self {",
        "comment_created_at": "2025-03-12T08:02:17+00:00",
        "comment_author": "vi",
        "comment_body": "Adjusted.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1940242052",
    "pr_number": 7137,
    "pr_file": "tokio/src/sync/oneshot.rs",
    "created_at": "2025-02-03T22:59:13+00:00",
    "commented_code": "}\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1940242052",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-03T22:59:13+00:00",
        "comment_author": "hawkw",
        "comment_body": "Hmm, this feels somewhat different than the semantics of `is_closed` on other channels, which only returns `true` when the other side has been dropped. On the other hand, there's a valid argument that this is just because those channels don't have the property that sending a value closes the channel. I'm not sure how I feel about this: I think it _might_ be worth being consistent that \"closed\" means \"dropped by the other side\", but I'm open to being convinced otherwise.",
        "pr_file_module": null
      },
      {
        "comment_id": "1940246099",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-03T23:04:25+00:00",
        "comment_author": "hawkw",
        "comment_body": "Also, the `Sender::is_closed` method currently exists and only inspects the value of the `CLOSED` bit: https://github.com/tokio-rs/tokio/blob/0931406db4c5d9d6cb62c3c18f2b23967272b87d/tokio/src/sync/oneshot.rs#L719-L751\r\n\r\nOf course, that method _can't ever be called_ if a value was sent, as doing so consumes the sender. so. Hm.",
        "pr_file_module": null
      },
      {
        "comment_id": "1940908359",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-04T10:30:25+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Yeah ... I'm not sure what is the least surprising here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1944108300",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-06T05:10:00+00:00",
        "comment_author": "cratelyn",
        "comment_body": "this is a very interesting conundrum!\r\n\r\nto begin by restating the problem directly: we are asking ourselves whether or\r\nnot `tokio::sync::oneshot::Receiver::is_closed()` should return `true` when\r\nthe corresponding `tokio::sync::oneshot::Sender` has been consumed by sending\r\na value.\r\n\r\nlet's consider the alternatives and how they would affect callers using them\r\nto determine whether or not a receiver may be polled.\r\n\r\n#### option a: `is_closed()` does not include completed channel\r\n\r\nin this model, `is_closed()` only returns true when the sender is dropped, or\r\nwhen the receiver closes the channel. it does **not** return true if a value\r\nwas sent.\r\n\r\nin this case, we would see the following values when inquiring about closedness\r\nand emptiness.\r\n\r\n| -                                    | `is_closed()` | `is_empty()` | safe to poll?   |\r\n| ------------------------------------ | ------------- | ------------ | --------------- |\r\n| initial                              | false         | true         | yes             |\r\n| receiver closes channel              | true          | true or false| yes             |\r\n| sender was dropped                   | true          | true         | yes             |\r\n| sender sent value (unreceived)       | false         | false        | yes             |\r\n| sender sent value (received)         | false         | true         | no              |\r\n\r\n#### option b: `is_closed()` does include completed channel\r\n\r\nin this model, `is_closed()` returns true when the receiver closes the channel,\r\nwhen the sender is dropped, **or** when the sender is used to send a value.\r\n\r\n| -                                    | `is_closed()` | `is_empty()` | safe to poll?   |\r\n| ------------------------------------ | ------------- | ------------ | --------------- |\r\n| initial                              | false         | true         | yes             |\r\n| receiver closes channel              | true          | true or false| yes             |\r\n| sender was dropped                   | true          | true         | yes             |\r\n| sender sent value (unreceived)       | true          | false        | yes             |\r\n| sender sent value (received)         | true          | true         | no              |\r\n\r\n**:balance_scale: comparing a and b**\r\n\r\nnow, this brings us to @hawkw's note:\r\n\r\n> Hmm, this feels somewhat different than the semantics of `is_closed` on other\r\n> channels, which only returns true when the other side has been dropped. On\r\n> the other hand, there's a valid argument that this is just because those\r\n> channels don't have the property that sending a value closes the channel. I'm\r\n> not sure how I feel about this: I think it might be worth being consistent\r\n> that \"closed\" means \"dropped by the other side\", but I'm open to being\r\n> convinced otherwise.\r\n\r\nfirst, i would note that we actually have some minor semantic differences\r\nbetween different channels' respective `is_closed` methods already, upon\r\ncloser inspection. i'd argue that is fine, and inherent to the fact that\r\ndifferent channel have different semantics, and that is bound to be reflected\r\nin methods querying their conceptual state.\r\n\r\nas an example, `sync::watch::Sender::is_closed` returns true if all receivers\r\nare dropped, while `sync::mpsc::Sender::is_closed` returns true if all\r\nreceivers are dropped or when `Receiver::close` is called. a `sync::watch`\r\nchannel can have many receivers, so it makes sense that its notion of\r\nclosedness would be narrower than a channel that conversely has a single\r\nreceiver.\r\n\r\nit seems like it would be in line with the above for a `oneshot` channel to\r\nhave its own unique caveat related for `is_closed`, returning true when the\r\nsender has been dropped by virtue of having sent a value.\r\n\r\n#### ...a secret third thing?\r\n\r\nnow, zooming back out for a moment: i found myself curious about this because\r\ni've frequently encountered a pattern when interacting with `oneshot` channels\r\nwherein they are very frequently wrapped in an `Option<T>`. once the receiver\r\nis polled and yields a `Poll::Ready(_)` value of some kind, the caller takes\r\nthe receiver out of the `Option<T>` and `mem::drop()`s it to prevent from being\r\npolled again.\r\n\r\nprior to reading the internals of the `oneshot` channel, and learning more\r\nabout how the sender and receiver interact, my initial intuition was that one\r\ncould check that a receiver was finished by checking that the channel was\r\nclosed, and empty.\r\n\r\nlooking at the tables above however, i've found that _neither_ option a or b\r\nprovide a surefire way to check that a receiver is finished, or if it is safe\r\nto `poll()`. for example: an empty, closed channel could indicate that the\r\nsender was dropped, but that doesn't provide information about whether the\r\n`Err(RecvError)` has been returned yet.\r\n\r\nnow, looking at the receiver, and its `Future` implementation:\r\n\r\n```rust\r\n// tokio/src/sync/oneshot.rs (abbrevated)\r\n\r\n#[derive(Debug)]\r\npub struct Receiver<T> {\r\n    inner: Option<Arc<Inner<T>>>,\r\n    // spans...\r\n}\r\n\r\nimpl<T> Future for Receiver<T> {\r\n    type Output = Result<T, RecvError>;\r\n\r\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\r\n        // If `inner` is `None`, then `poll()` has already completed.\r\n        let ret = if let Some(inner) = self.as_ref().get_ref().inner.as_ref() {\r\n            ready!(inner.poll_recv(cx))?\r\n        } else {\r\n            panic!(\"called after complete\");\r\n        };\r\n\r\n        self.inner = None;\r\n        Ready(Ok(ret))\r\n    }\r\n}\r\n```\r\n\r\ni see utility for a third method `tokio::sync::oneshot::Receiver::is_finished()`.\r\n\r\n```rust\r\nimpl<T> Receiver<T> {\r\n    /// Checks if this receiver is finished.\r\n    ///\r\n    /// This will return true after this receiver has been polled and yielded\r\n    /// a result.\r\n    fn is_finished(&self) -> bool {\r\n        self.inner.is_none()\r\n    }\r\n}\r\n```\r\n\r\nif this was an option, i would feel personally much less attached to the\r\ndecision over whether or not `is_closed` reports true when a value has been\r\nsent.\r\n\r\nthis would directly let callers check if polling the receiver would panic, and\r\nin friendly, direct terms. this would also mean that the common pattern of\r\nwrapping receivers in `Option<Receiver<T>>` would be largely outmoded.\r\n`is_finished` would let us inquire about the state of the receiver's own\r\ninternal `Option<T>`, without needing to wrap it in another outer option we\r\n_can_ inspect.\r\n\r\nwhat do you think, @Darksonn, and @hawkw?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1944446373",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-06T10:05:46+00:00",
        "comment_author": "Darksonn",
        "comment_body": "If the intent of this PR is a way to detect whether polling the channel will panic, then having a function that does exactly that sounds good to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "1948297555",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-10T01:18:40+00:00",
        "comment_author": "cratelyn",
        "comment_body": "the intent of this PR, broadly speaking, is to introduce accessors that allows `sync::oneshot::Receiver<T>` to inspect the channel's status in the same manner that other channels like `sync::mpsc`'s and `sync::broadcast`'s respective `Receiver<T>`s can.\r\n\r\ndetecting panics is one acute example, but i've also felt a need for these interfaces when writing `Body` implementations for types backed by a oneshot, to provide another example.\r\n\r\na `Body` backed by a oneshot receiver cannot report proper `is_end_stream()` hints because the receiver doesn't provide a way to inspect the channel. these felt like relatively agnostic methods to expose in part because they follow patterns exposed by other channels.\r\n\r\n91682a96 introduces an `is_finished()` method. i'd be happy to outline that into a separate PR if we don't feel a disposition to merge `is_empty()` and `is_closed()` methods. what do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1953184072",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-12T18:17:48+00:00",
        "comment_author": "hawkw",
        "comment_body": "> 91682a9 introduces an `is_finished()` method. i'd be happy to outline that into a separate PR if we don't feel a disposition to merge `is_empty()` and `is_closed()` methods. what do you think?\n\nPersonally, I'd be inclined to suggest a PR adding a method like that separately, so that the change you actually need isn't blocked on deciding the right semantics for `is_closed`. I think that change should hopefully be fairly uncontroversial. \n\nRegarding naming for that method, I think \"is_finished\" is probably fine, but I'll note that the `futures` crate's `FusedFuture` trait calls its method with similar semantics [`is_terminated`](https://docs.rs/futures/latest/futures/future/trait.FusedFuture.html#tymethod.is_terminated). Although we probably won't be adding `FusedFuture` implementations in Tokio due to stability concerns, it _might_ be worth choosing a name that's consistent with the one in `futures`? I could be convinced either way though. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1953192684",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-12T18:24:04+00:00",
        "comment_author": "hawkw",
        "comment_body": "And, to be clear, I'd *also* still like to have `is_closed()` and `is_empty()` — I just think we could add an `is_finished_and_or_terminated()` without having to wait for figuring out `is_closed()`.\n\nI think we could probably also land an `is_empty()` method separately, if you like. I don't think there's much ambiguity about what \"empty\" means in this case. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1955180581",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7137,
        "pr_file": "tokio/src/sync/oneshot.rs",
        "discussion_id": "1940242052",
        "commented_code": "@@ -931,6 +931,109 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Checks if a channel is empty.\n+    ///\n+    /// This method returns `true` if the channel has no messages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use futures::task::noop_waker_ref;\n+    /// use tokio::sync::oneshot;\n+    ///\n+    /// use std::future::Future;\n+    /// use std::pin::Pin;\n+    /// use std::task::{Context, Poll};\n+    ///\n+    /// #[tokio::main]\n+    /// async fn main() {\n+    ///     let (tx, mut rx) = oneshot::channel();\n+    ///     assert!(rx.is_empty());\n+    ///\n+    ///     tx.send(0).unwrap();\n+    ///     assert!(!rx.is_empty());\n+    ///\n+    ///     let poll = Pin::new(&mut rx).poll(&mut Context::from_waker(noop_waker_ref()));\n+    ///     assert_eq!(poll, Poll::Ready(Ok(0)));\n+    ///     assert!(rx.is_empty());\n+    /// }\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        if let Some(inner) = self.inner.as_ref() {\n+            let state = State::load(&inner.state, Acquire);\n+            if state.is_complete() {\n+                // SAFETY: If `state.is_complete()` returns true, then the\n+                // `VALUE_SENT` bit has been set and the sender side of the\n+                // channel will no longer attempt to access the inner\n+                // `UnsafeCell`. Therefore, it is now safe for us to access the\n+                // cell.\n+                //\n+                // The channel is empty if it does not have a value.\n+                unsafe { !inner.has_value() }\n+            } else if state.is_closed() {\n+                // The receiver closed the channel...\n+                true\n+            } else {\n+                // No value has been sent yet.\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Checks if the channel has been closed.\n+    ///\n+    /// This happens when the corresponding sender is either dropped or sends a\n+    /// value, or when this receiver has closed the channel.",
        "comment_created_at": "2025-02-13T20:36:40+00:00",
        "comment_author": "cratelyn",
        "comment_body": "thank you both for the advice and for your time, @Darksonn and @hawkw! i agree, landing these each separately sounds like a more prudent path forward.\r\n\r\ni'm going to close this, and let us consider each of these proposals individually.\r\n\r\nsee:\r\n* #7152\r\n* #7153\r\n* #7154",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1342431740",
    "pr_number": 6010,
    "pr_file": "tokio/src/sync/mpsc/bounded.rs",
    "created_at": "2023-10-02T08:51:35+00:00",
    "commented_code": "poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1342431740",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-02T08:51:35+00:00",
        "comment_author": "Darksonn",
        "comment_body": "If the limit is zero, then I think it would be okay to just return 0 immediately.",
        "pr_file_module": null
      },
      {
        "comment_id": "1343244963",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-02T23:08:19+00:00",
        "comment_author": "aschweig",
        "comment_body": "If the caller wants a no-op, they can instead simply not-call the method, instead of calling with a zero limit.\r\n\r\nFurthermore, immediately returning 0 means that this behavior becomes unique to a single value of `limit`; all other values of `limit` only return 0 if the channel is closed and no values are pending.  So it breaks the API's guarantee for a case of no practical value to someone seeking to receive messages on the channel.\r\n\r\nI considered the following possible ways to handle a 0 value for limit:\r\n\r\n- The fail-fast approach -- `assert!(limit > 0);`.\r\n- Have it so that `limit=0` acts the same way as `limit=usize::max_value()`.\r\n- Have it so that `limit=0` results in some reasonable default behavior, e.g., retrieve 2 or 8 messages or BLOCK_CAP.  I liked BLOCK_CAP because it corresponded to the internal chunking used.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1345721279",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-04T12:32:27+00:00",
        "comment_author": "aschweig",
        "comment_body": "A tangentially related discussion: https://github.com/tokio-rs/tokio/issues/2742\r\nIf `limit` is computed at run-time and `0`, then my sense is both `assert!(...)` and immediately return 0 violate the principal of least surprise as in both cases the function doesn't do what it is named.  But the `assert` approach also pops up within the same file, so it unsurprising from an implementation standpoint.",
        "pr_file_module": null
      },
      {
        "comment_id": "1345724783",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-04T12:35:09+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Hmm. I think immediately returning 0 is the least surprising behavior. After all, you asked to receive zero messages, and you got zero messages.",
        "pr_file_module": null
      },
      {
        "comment_id": "1345862994",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-04T14:09:10+00:00",
        "comment_author": "aschweig",
        "comment_body": "Recall, you wrote:\r\n\r\n>  Perhaps we can swap these paragraphs, and add something to the paragraph about 0 along the lines of \"this method will never return 0 if the channel is not closed\" or \"if the channel is not closed, then this method will never return 0\".\r\n\r\nNonetheless, I see that the same no-op convention is used in unistd.h's `read` function... and evidence of users running into the types of bugs I anticipate:\r\nhttps://stackoverflow.com/a/3074217\r\n\r\nIf this is acceptable, I'll update the handling and the documentation.",
        "pr_file_module": null
      },
      {
        "comment_id": "1349652399",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-08T08:36:23+00:00",
        "comment_author": "Darksonn",
        "comment_body": "If what is acceptable?\r\n\r\nI mainly see people be confused about length zero reads when they do this:\r\n```rs\r\nlet mut vec = Vec::with_capacity(1024);\r\nio.read(&mut vec);\r\n```\r\nand are surprised because `&mut vec` becomes a slice of length zero.\r\n\r\nBut that doesn't happen in our case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1349745578",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-08T16:51:07+00:00",
        "comment_author": "aschweig",
        "comment_body": "Understood regarding `io.read(&mut vec);` -- here the issue is resolved as we take a Vec.\r\n\r\nThe behavior of `recv_many(buf, 0)` is similar to calling [`rd.take(0)`](https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.take).  I am unclear when in an async context `take(0)` is ever useful -- but it is allowed -- so at least `recv_many(buf, 0)` is no worse.\r\n\r\nContrived example adapted from [Example: split a file into chunks](https://geekingfrog.com/blog/post/getting-things-done-with-async)\r\n```\r\n#[tokio::test]\r\nasync fn take_zero() {\r\n    use tokio::fs::File;\r\n    use std::path::PathBuf;\r\n    for chunk_size in [0, 1, 1024] {\r\n        let mut input_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\r\n        input_path.push(\"tests/io_take.rs\");\r\n        let input_file = File::open(input_path).await.unwrap();\r\n        let mut output_path = PathBuf::from(env!(\"CARGO_TARGET_TMPDIR\"));\r\n        output_path.push(\"takezero\");\r\n        if output_path.exists() {\r\n            tokio::fs::remove_file(&output_path).await.unwrap();\r\n        }\r\n        assert!(!output_path.exists());\r\n\r\n        // the `.take` method is coming from the AsyncReadExt trait imported above\r\n        let mut reader = input_file.take(chunk_size);\r\n        let mut output = File::create(&output_path).await.unwrap();\r\n        loop {\r\n            let bytes_copied = tokio::io::copy(&mut reader, &mut output).await.unwrap();\r\n            if bytes_copied == 0 {\r\n                break;\r\n            }\r\n            // our reader is now exhausted, but that doesn't mean the underlying reader\r\n            // is. So we recover it, and we create the next chunked reader\r\n            reader = reader.into_inner().take(chunk_size);\r\n        }\r\n        let file_size = tokio::fs::metadata(output_path).await.unwrap().len();\r\n        assert!((chunk_size > 0 && file_size > 0) || chunk_size == 0 && file_size == 0);\r\n    }\r\n}\r\n```\r\n\r\nI think this is now resolved (for me).  \r\nedit:  removed comment; I have pushed code to return 0 immediately when `limit=0`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1350477615",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6010,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1342431740",
        "commented_code": "@@ -230,6 +230,82 @@ impl<T> Receiver<T> {\n         poll_fn(|cx| self.chan.recv(cx)).await\n     }\n \n+    /// Receives the next values for this receiver and extends `buffer`.\n+    ///\n+    /// This method extends `buffer` by no more than a fixed number\n+    /// of values as specified by `limit`.  If `limit` is zero,\n+    /// then a default is used. The return value is the number\n+    /// of values added to `buffer`.",
        "comment_created_at": "2023-10-09T15:47:02+00:00",
        "comment_author": "Darksonn",
        "comment_body": "I think allowing a zero length is useful for cases where the length is computed dynamically. I've seen code along these lines:\r\n```rs\r\nlet len = io.read_u64().await? as usize;\r\nlet mut buffer = Vec::with_capacity(len);\r\nio.take(len).read_to_end(&mut buffer)?;\r\n```\r\nif there are length-zero messages, then the above makes use of `take(0)` behavior sometimes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1556198216",
    "pr_number": 6472,
    "pr_file": "tokio/src/sync/semaphore.rs",
    "created_at": "2024-04-08T17:45:31+00:00",
    "commented_code": "self.permits += other.permits;\n         other.permits = 0;\n     }\n+\n+    /// Detaches `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n+    ///\n+    /// It guarantees at least one permit held by both `self` and the new instance.",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1556198216",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6472,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1556198216",
        "commented_code": "@@ -990,6 +990,24 @@ impl<'a> SemaphorePermit<'a> {\n         self.permits += other.permits;\n         other.permits = 0;\n     }\n+\n+    /// Detaches `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n+    ///\n+    /// It guarantees at least one permit held by both `self` and the new instance.",
        "comment_created_at": "2024-04-08T17:45:31+00:00",
        "comment_author": "mox692",
        "comment_body": "I feel that allowing `detach(0)` (or `detach(n)` for a `SemaphorePermit` with `n` permits) could simplify the API. In fact, it's technically possible to create a zero-permit `SemaphorePermit` with `try_acquire_many(0)` even now.\r\nHave you experienced scenarios where you want the permit to always be more than 1?",
        "pr_file_module": null
      },
      {
        "comment_id": "1556917972",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6472,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1556198216",
        "commented_code": "@@ -990,6 +990,24 @@ impl<'a> SemaphorePermit<'a> {\n         self.permits += other.permits;\n         other.permits = 0;\n     }\n+\n+    /// Detaches `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n+    ///\n+    /// It guarantees at least one permit held by both `self` and the new instance.",
        "comment_created_at": "2024-04-09T05:21:46+00:00",
        "comment_author": "vvvviiv",
        "comment_body": "I limited this because the zero-permit `SemaphorePermit` usually makes no sense, and we have no way to tell the user how many permits are held by a `SemaphorePermit`.\r\n\r\nWhat about adding a `held_permits` (or a better name) method to return the number of permits held by a `SemaphorePermit` and removing these restrictions?",
        "pr_file_module": null
      },
      {
        "comment_id": "1557553652",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6472,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1556198216",
        "commented_code": "@@ -990,6 +990,24 @@ impl<'a> SemaphorePermit<'a> {\n         self.permits += other.permits;\n         other.permits = 0;\n     }\n+\n+    /// Detaches `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n+    ///\n+    /// It guarantees at least one permit held by both `self` and the new instance.",
        "comment_created_at": "2024-04-09T12:30:22+00:00",
        "comment_author": "mox692",
        "comment_body": "> What about adding a held_permits (or a better name) method to return the number of permits held by a SemaphorePermit and removing these restrictions?\r\n\r\nSounds good to me.\r\n\r\n@Darksonn \r\nDo you see any problems with this approach?",
        "pr_file_module": null
      },
      {
        "comment_id": "1557558357",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6472,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1556198216",
        "commented_code": "@@ -990,6 +990,24 @@ impl<'a> SemaphorePermit<'a> {\n         self.permits += other.permits;\n         other.permits = 0;\n     }\n+\n+    /// Detaches `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n+    ///\n+    /// It guarantees at least one permit held by both `self` and the new instance.",
        "comment_created_at": "2024-04-09T12:34:07+00:00",
        "comment_author": "Darksonn",
        "comment_body": "If all of the `*acquire_many` methods already allow zero permits, then I see no harm in allowing it here. I would perhaps all the method `num_permits`?",
        "pr_file_module": null
      }
    ]
  }
]