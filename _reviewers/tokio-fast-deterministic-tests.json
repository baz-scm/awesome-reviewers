[
  {
    "discussion_id": "1886478921",
    "pr_number": 7038,
    "pr_file": "tokio/src/sync/watch.rs",
    "created_at": "2024-12-16T09:33:17+00:00",
    "commented_code": "/// When this function returns, the value that was passed to the closure\n     /// when it returned `true` will be considered seen.\n     ///\n-    /// If the channel is closed, then `wait_for` will return a `RecvError`.\n+    /// If the channel is closed, then `wait_for` will return a [`RecvError`].\n     /// Once this happens, no more messages can ever be sent on the channel.\n     /// When an error is returned, it is guaranteed that the closure has been\n     /// called on the last value, and that it returned `false` for that value.\n     /// (If the closure returned `true`, then the last value would have been\n     /// returned instead of the error.)\n     ///\n-    /// Like the `borrow` method, the returned borrow holds a read lock on the\n+    /// Like the [`borrow`] method, the returned borrow holds a read lock on the\n     /// inner value. This means that long-lived borrows could cause the producer\n     /// half to block. It is recommended to keep the borrow as short-lived as\n     /// possible. See the documentation of `borrow` for more information on\n     /// this.\n     ///\n-    /// [`Receiver::changed()`]: crate::sync::watch::Receiver::changed\n+    /// [`borrow`]: Receiver::borrow\n+    /// [`RecvError`]: error::RecvError\n+    ///\n+    /// # Cancel safety\n+    ///\n+    /// This method is cancel safe. If dropped before completion, it is\n+    /// guaranteed that the last seen value `val` (if any) satisfies\n+    /// `f(val) == false`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If and only if the closure `f` panics. In that case, no resource owned\n+    /// or shared by this [`Receiver`] will be poisoned.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use tokio::sync::watch;\n+    /// use tokio::time::{sleep, Duration};\n     ///\n     /// #[tokio::main]\n-    ///\n     /// async fn main() {\n-    ///     let (tx, _rx) = watch::channel(\"hello\");\n+    ///     let (tx, mut rx) = watch::channel(\"hello\");\n     ///\n-    ///     tx.send(\"goodbye\").unwrap();\n+    ///     tokio::spawn(async move {\n+    ///         sleep(Duration::from_micros(100)).await;\n+    ///         tx.send(\"goodbye\").unwrap();\n+    ///     });",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1886478921",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7038,
        "pr_file": "tokio/src/sync/watch.rs",
        "discussion_id": "1886478921",
        "commented_code": "@@ -767,44 +767,50 @@ impl<T> Receiver<T> {\n     /// When this function returns, the value that was passed to the closure\n     /// when it returned `true` will be considered seen.\n     ///\n-    /// If the channel is closed, then `wait_for` will return a `RecvError`.\n+    /// If the channel is closed, then `wait_for` will return a [`RecvError`].\n     /// Once this happens, no more messages can ever be sent on the channel.\n     /// When an error is returned, it is guaranteed that the closure has been\n     /// called on the last value, and that it returned `false` for that value.\n     /// (If the closure returned `true`, then the last value would have been\n     /// returned instead of the error.)\n     ///\n-    /// Like the `borrow` method, the returned borrow holds a read lock on the\n+    /// Like the [`borrow`] method, the returned borrow holds a read lock on the\n     /// inner value. This means that long-lived borrows could cause the producer\n     /// half to block. It is recommended to keep the borrow as short-lived as\n     /// possible. See the documentation of `borrow` for more information on\n     /// this.\n     ///\n-    /// [`Receiver::changed()`]: crate::sync::watch::Receiver::changed\n+    /// [`borrow`]: Receiver::borrow\n+    /// [`RecvError`]: error::RecvError\n+    ///\n+    /// # Cancel safety\n+    ///\n+    /// This method is cancel safe. If dropped before completion, it is\n+    /// guaranteed that the last seen value `val` (if any) satisfies\n+    /// `f(val) == false`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If and only if the closure `f` panics. In that case, no resource owned\n+    /// or shared by this [`Receiver`] will be poisoned.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use tokio::sync::watch;\n+    /// use tokio::time::{sleep, Duration};\n     ///\n     /// #[tokio::main]\n-    ///\n     /// async fn main() {\n-    ///     let (tx, _rx) = watch::channel(\"hello\");\n+    ///     let (tx, mut rx) = watch::channel(\"hello\");\n     ///\n-    ///     tx.send(\"goodbye\").unwrap();\n+    ///     tokio::spawn(async move {\n+    ///         sleep(Duration::from_micros(100)).await;\n+    ///         tx.send(\"goodbye\").unwrap();\n+    ///     });",
        "comment_created_at": "2024-12-16T09:33:17+00:00",
        "comment_author": "Darksonn",
        "comment_body": "We like to avoid sleeps in tests to reduce the amount of time it takes to run the tests. If you make the runtime use mocked time via the `start_paused` parameter, then this test will run instantly no matter what the duration is.\r\n\r\nhttps://github.com/tokio-rs/tokio/blob/10e23d1c621ab38aadf2cefba1120494cff615f0/tokio/src/runtime/task/join.rs#L190-L205",
        "pr_file_module": null
      },
      {
        "comment_id": "1886553771",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7038,
        "pr_file": "tokio/src/sync/watch.rs",
        "discussion_id": "1886478921",
        "commented_code": "@@ -767,44 +767,50 @@ impl<T> Receiver<T> {\n     /// When this function returns, the value that was passed to the closure\n     /// when it returned `true` will be considered seen.\n     ///\n-    /// If the channel is closed, then `wait_for` will return a `RecvError`.\n+    /// If the channel is closed, then `wait_for` will return a [`RecvError`].\n     /// Once this happens, no more messages can ever be sent on the channel.\n     /// When an error is returned, it is guaranteed that the closure has been\n     /// called on the last value, and that it returned `false` for that value.\n     /// (If the closure returned `true`, then the last value would have been\n     /// returned instead of the error.)\n     ///\n-    /// Like the `borrow` method, the returned borrow holds a read lock on the\n+    /// Like the [`borrow`] method, the returned borrow holds a read lock on the\n     /// inner value. This means that long-lived borrows could cause the producer\n     /// half to block. It is recommended to keep the borrow as short-lived as\n     /// possible. See the documentation of `borrow` for more information on\n     /// this.\n     ///\n-    /// [`Receiver::changed()`]: crate::sync::watch::Receiver::changed\n+    /// [`borrow`]: Receiver::borrow\n+    /// [`RecvError`]: error::RecvError\n+    ///\n+    /// # Cancel safety\n+    ///\n+    /// This method is cancel safe. If dropped before completion, it is\n+    /// guaranteed that the last seen value `val` (if any) satisfies\n+    /// `f(val) == false`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If and only if the closure `f` panics. In that case, no resource owned\n+    /// or shared by this [`Receiver`] will be poisoned.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use tokio::sync::watch;\n+    /// use tokio::time::{sleep, Duration};\n     ///\n     /// #[tokio::main]\n-    ///\n     /// async fn main() {\n-    ///     let (tx, _rx) = watch::channel(\"hello\");\n+    ///     let (tx, mut rx) = watch::channel(\"hello\");\n     ///\n-    ///     tx.send(\"goodbye\").unwrap();\n+    ///     tokio::spawn(async move {\n+    ///         sleep(Duration::from_micros(100)).await;\n+    ///         tx.send(\"goodbye\").unwrap();\n+    ///     });",
        "comment_created_at": "2024-12-16T10:21:36+00:00",
        "comment_author": "cip999",
        "comment_body": "Fair enough, done (and \"bumped\" the duration to 1s while at it).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1721445211",
    "pr_number": 6784,
    "pr_file": "tokio/tests/task_join_set.rs",
    "created_at": "2024-08-19T08:58:36+00:00",
    "commented_code": ".is_cancelled());\n }\n \n+#[tokio::test]\n+async fn join_all() {\n+    let mut set: JoinSet<i32> = JoinSet::new();\n+\n+    for _ in 0..5 {\n+        set.spawn(async { 1 });\n+    }\n+    let res: Vec<i32> = set.join_all().await;\n+\n+    assert_eq!(res.len(), 5);\n+    for itm in res.into_iter() {\n+        assert_eq!(itm, 1)\n+    }\n+}\n+\n+#[cfg(panic = \"unwind\")]\n+#[tokio::test]",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1721445211",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6784,
        "pr_file": "tokio/tests/task_join_set.rs",
        "discussion_id": "1721445211",
        "commented_code": "@@ -156,6 +156,46 @@ fn runtime_gone() {\n         .is_cancelled());\n }\n \n+#[tokio::test]\n+async fn join_all() {\n+    let mut set: JoinSet<i32> = JoinSet::new();\n+\n+    for _ in 0..5 {\n+        set.spawn(async { 1 });\n+    }\n+    let res: Vec<i32> = set.join_all().await;\n+\n+    assert_eq!(res.len(), 5);\n+    for itm in res.into_iter() {\n+        assert_eq!(itm, 1)\n+    }\n+}\n+\n+#[cfg(panic = \"unwind\")]\n+#[tokio::test]",
        "comment_created_at": "2024-08-19T08:58:36+00:00",
        "comment_author": "Darksonn",
        "comment_body": "This will make the test run much much faster by using [simulated time](https://docs.rs/tokio/latest/tokio/time/fn.pause.html).\r\n```suggestion\r\n#[tokio::test(start_paused = true)]\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1630122447",
    "pr_number": 6618,
    "pr_file": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
    "created_at": "2024-06-06T19:36:39+00:00",
    "commented_code": "assert_ok!(th3.join());\n     });\n }\n+\n+#[test]\n+fn run_until_cancelled_completes() {\n+    loom::model(|| {\n+        block_on(async {\n+            let token = CancellationToken::new();\n+\n+            let fut = async {\n+                tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n+                42\n+            };\n+\n+            if let Some(res) = token.run_until_cancelled(fut).await {\n+                assert_eq!(res, 42);\n+            } else {\n+                panic!(\"Should not happen since we are not cancelling the token\");\n+            }\n+        });\n+    });\n+}\n+\n+#[test]\n+fn run_until_cancelled_with_cancel() {\n+    loom::model(|| {\n+        block_on(async {\n+            let token = CancellationToken::new();\n+            let token1 = token.clone();\n+\n+            let th1 = std::thread::spawn(move || {\n+                std::thread::sleep(std::time::Duration::from_millis(500));\n+                token1.cancel();\n+            });",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1630122447",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6618,
        "pr_file": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
        "discussion_id": "1630122447",
        "commented_code": "@@ -174,3 +174,46 @@ fn cancel_parent_and_child() {\n         assert_ok!(th3.join());\n     });\n }\n+\n+#[test]\n+fn run_until_cancelled_completes() {\n+    loom::model(|| {\n+        block_on(async {\n+            let token = CancellationToken::new();\n+\n+            let fut = async {\n+                tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n+                42\n+            };\n+\n+            if let Some(res) = token.run_until_cancelled(fut).await {\n+                assert_eq!(res, 42);\n+            } else {\n+                panic!(\"Should not happen since we are not cancelling the token\");\n+            }\n+        });\n+    });\n+}\n+\n+#[test]\n+fn run_until_cancelled_with_cancel() {\n+    loom::model(|| {\n+        block_on(async {\n+            let token = CancellationToken::new();\n+            let token1 = token.clone();\n+\n+            let th1 = std::thread::spawn(move || {\n+                std::thread::sleep(std::time::Duration::from_millis(500));\n+                token1.cancel();\n+            });",
        "comment_created_at": "2024-06-06T19:36:39+00:00",
        "comment_author": "Darksonn",
        "comment_body": "We do not use sleeping in tests. We have 845 tests right now. Imagine how long it would take to run the tests if every single one had a 0.5 second sleep.",
        "pr_file_module": null
      },
      {
        "comment_id": "1631644533",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6618,
        "pr_file": "tokio-util/src/sync/tests/loom_cancellation_token.rs",
        "discussion_id": "1630122447",
        "commented_code": "@@ -174,3 +174,46 @@ fn cancel_parent_and_child() {\n         assert_ok!(th3.join());\n     });\n }\n+\n+#[test]\n+fn run_until_cancelled_completes() {\n+    loom::model(|| {\n+        block_on(async {\n+            let token = CancellationToken::new();\n+\n+            let fut = async {\n+                tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n+                42\n+            };\n+\n+            if let Some(res) = token.run_until_cancelled(fut).await {\n+                assert_eq!(res, 42);\n+            } else {\n+                panic!(\"Should not happen since we are not cancelling the token\");\n+            }\n+        });\n+    });\n+}\n+\n+#[test]\n+fn run_until_cancelled_with_cancel() {\n+    loom::model(|| {\n+        block_on(async {\n+            let token = CancellationToken::new();\n+            let token1 = token.clone();\n+\n+            let th1 = std::thread::spawn(move || {\n+                std::thread::sleep(std::time::Duration::from_millis(500));\n+                token1.cancel();\n+            });",
        "comment_created_at": "2024-06-07T20:10:52+00:00",
        "comment_author": "tglane",
        "comment_body": "Yeah that was a stupid idea. I changed the test to use a channel instead of a sleep.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "423514140",
    "pr_number": 2522,
    "pr_file": "tokio-test/src/macros.rs",
    "created_at": "2020-05-12T07:19:12+00:00",
    "commented_code": "}\n     }};\n }\n+\n+/// Asserts that the expression completes within a given number of milliseconds.\n+///\n+/// This will invoke the `panic!` macro if the provided future\n+/// expression fails to complete within the given number of\n+/// milliseconds. A default timeout of 10ms is used if no duration is\n+/// passed.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use tokio_test::assert_completes;\n+/// use tokio::time::delay_for;\n+///\n+/// // Succeeds because default time is longer than delay.\n+/// assert_completes!(delay_for(Duration::from_millis(5)));\n+///\n+/// // Fails because timeout is shorter than delay.\n+/// assert_completes!(delay_for(Duration::from_millis(5)), 1);\n+/// ```\n+#[macro_export]\n+macro_rules! assert_completes {\n+    ($e:expr) => {\n+        assert_completes!($e, 10)\n+    };",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "423514140",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 2522,
        "pr_file": "tokio-test/src/macros.rs",
        "discussion_id": "423514140",
        "commented_code": "@@ -259,3 +259,78 @@ macro_rules! assert_err {\n         }\n     }};\n }\n+\n+/// Asserts that the expression completes within a given number of milliseconds.\n+///\n+/// This will invoke the `panic!` macro if the provided future\n+/// expression fails to complete within the given number of\n+/// milliseconds. A default timeout of 10ms is used if no duration is\n+/// passed.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use tokio_test::assert_completes;\n+/// use tokio::time::delay_for;\n+///\n+/// // Succeeds because default time is longer than delay.\n+/// assert_completes!(delay_for(Duration::from_millis(5)));\n+///\n+/// // Fails because timeout is shorter than delay.\n+/// assert_completes!(delay_for(Duration::from_millis(5)), 1);\n+/// ```\n+#[macro_export]\n+macro_rules! assert_completes {\n+    ($e:expr) => {\n+        assert_completes!($e, 10)\n+    };",
        "comment_created_at": "2020-05-12T07:19:12+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Maybe this timeout should be larger?",
        "pr_file_module": null
      },
      {
        "comment_id": "424020604",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 2522,
        "pr_file": "tokio-test/src/macros.rs",
        "discussion_id": "423514140",
        "commented_code": "@@ -259,3 +259,78 @@ macro_rules! assert_err {\n         }\n     }};\n }\n+\n+/// Asserts that the expression completes within a given number of milliseconds.\n+///\n+/// This will invoke the `panic!` macro if the provided future\n+/// expression fails to complete within the given number of\n+/// milliseconds. A default timeout of 10ms is used if no duration is\n+/// passed.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use tokio_test::assert_completes;\n+/// use tokio::time::delay_for;\n+///\n+/// // Succeeds because default time is longer than delay.\n+/// assert_completes!(delay_for(Duration::from_millis(5)));\n+///\n+/// // Fails because timeout is shorter than delay.\n+/// assert_completes!(delay_for(Duration::from_millis(5)), 1);\n+/// ```\n+#[macro_export]\n+macro_rules! assert_completes {\n+    ($e:expr) => {\n+        assert_completes!($e, 10)\n+    };",
        "comment_created_at": "2020-05-12T20:42:08+00:00",
        "comment_author": "RadicalZephyr",
        "comment_body": "totally open to that, I picked ten totally arbitrarily. I actually use 50ms in my own tests, and I haven't seen any test failures that weren't related to a logic error, so I think I'll change it to that.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1868378348",
    "pr_number": 6995,
    "pr_file": "tokio/tests/signal_info.rs",
    "created_at": "2024-12-03T21:17:05+00:00",
    "commented_code": "+#![warn(rust_2018_idioms)]\n+#![cfg(feature = \"full\")]\n+#![cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"illumos\"\n+))]\n+#![cfg(not(miri))] // No `sigaction` on Miri\n+\n+mod support {\n+    pub mod signal;\n+}\n+use support::signal::send_signal;\n+\n+use tokio::signal;\n+use tokio::signal::unix::SignalKind;\n+use tokio::sync::oneshot;\n+\n+#[tokio::test]\n+async fn siginfo() {\n+    let mut sig = signal::unix::signal(SignalKind::info()).expect(\"installed signal handler\");\n+\n+    let (fire, wait) = oneshot::channel();\n+\n+    // NB: simulate a signal coming in by exercising our signal handler\n+    // to avoid complications with sending SIGINFO to the test process\n+    tokio::spawn(async {\n+        wait.await.expect(\"wait failed\");\n+        send_signal(libc::SIGINFO);\n+    });\n+\n+    let _ = fire.send(());\n+\n+    sig.recv().await.expect(\"received SIGINFO signal\");",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1868378348",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6995,
        "pr_file": "tokio/tests/signal_info.rs",
        "discussion_id": "1868378348",
        "commented_code": "@@ -0,0 +1,38 @@\n+#![warn(rust_2018_idioms)]\n+#![cfg(feature = \"full\")]\n+#![cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"illumos\"\n+))]\n+#![cfg(not(miri))] // No `sigaction` on Miri\n+\n+mod support {\n+    pub mod signal;\n+}\n+use support::signal::send_signal;\n+\n+use tokio::signal;\n+use tokio::signal::unix::SignalKind;\n+use tokio::sync::oneshot;\n+\n+#[tokio::test]\n+async fn siginfo() {\n+    let mut sig = signal::unix::signal(SignalKind::info()).expect(\"installed signal handler\");\n+\n+    let (fire, wait) = oneshot::channel();\n+\n+    // NB: simulate a signal coming in by exercising our signal handler\n+    // to avoid complications with sending SIGINFO to the test process\n+    tokio::spawn(async {\n+        wait.await.expect(\"wait failed\");\n+        send_signal(libc::SIGINFO);\n+    });\n+\n+    let _ = fire.send(());\n+\n+    sig.recv().await.expect(\"received SIGINFO signal\");",
        "comment_created_at": "2024-12-03T21:17:05+00:00",
        "comment_author": "hawkw",
        "comment_body": "Should we consider setting a (very long) timeout on this, so that the test failure mode if the signal is not received is a panic, rather than running forever? Just a thought.",
        "pr_file_module": null
      },
      {
        "comment_id": "1868385390",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6995,
        "pr_file": "tokio/tests/signal_info.rs",
        "discussion_id": "1868378348",
        "commented_code": "@@ -0,0 +1,38 @@\n+#![warn(rust_2018_idioms)]\n+#![cfg(feature = \"full\")]\n+#![cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"illumos\"\n+))]\n+#![cfg(not(miri))] // No `sigaction` on Miri\n+\n+mod support {\n+    pub mod signal;\n+}\n+use support::signal::send_signal;\n+\n+use tokio::signal;\n+use tokio::signal::unix::SignalKind;\n+use tokio::sync::oneshot;\n+\n+#[tokio::test]\n+async fn siginfo() {\n+    let mut sig = signal::unix::signal(SignalKind::info()).expect(\"installed signal handler\");\n+\n+    let (fire, wait) = oneshot::channel();\n+\n+    // NB: simulate a signal coming in by exercising our signal handler\n+    // to avoid complications with sending SIGINFO to the test process\n+    tokio::spawn(async {\n+        wait.await.expect(\"wait failed\");\n+        send_signal(libc::SIGINFO);\n+    });\n+\n+    let _ = fire.send(());\n+\n+    sig.recv().await.expect(\"received SIGINFO signal\");",
        "comment_created_at": "2024-12-03T21:23:53+00:00",
        "comment_author": "sunshowers",
        "comment_body": "I copied the other signal tests which don't set that kind of timeout, but it would certainly make sense to do so. Alternatively, the timeout could be set in nextest. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1868448318",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6995,
        "pr_file": "tokio/tests/signal_info.rs",
        "discussion_id": "1868378348",
        "commented_code": "@@ -0,0 +1,38 @@\n+#![warn(rust_2018_idioms)]\n+#![cfg(feature = \"full\")]\n+#![cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"illumos\"\n+))]\n+#![cfg(not(miri))] // No `sigaction` on Miri\n+\n+mod support {\n+    pub mod signal;\n+}\n+use support::signal::send_signal;\n+\n+use tokio::signal;\n+use tokio::signal::unix::SignalKind;\n+use tokio::sync::oneshot;\n+\n+#[tokio::test]\n+async fn siginfo() {\n+    let mut sig = signal::unix::signal(SignalKind::info()).expect(\"installed signal handler\");\n+\n+    let (fire, wait) = oneshot::channel();\n+\n+    // NB: simulate a signal coming in by exercising our signal handler\n+    // to avoid complications with sending SIGINFO to the test process\n+    tokio::spawn(async {\n+        wait.await.expect(\"wait failed\");\n+        send_signal(libc::SIGINFO);\n+    });\n+\n+    let _ = fire.send(());\n+\n+    sig.recv().await.expect(\"received SIGINFO signal\");",
        "comment_created_at": "2024-12-03T22:30:44+00:00",
        "comment_author": "Darksonn",
        "comment_body": "We expect tests to run with `cargo test` too, so we shouldn't use nextest specific features. Having a timeout sgtm.",
        "pr_file_module": null
      },
      {
        "comment_id": "1868453582",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6995,
        "pr_file": "tokio/tests/signal_info.rs",
        "discussion_id": "1868378348",
        "commented_code": "@@ -0,0 +1,38 @@\n+#![warn(rust_2018_idioms)]\n+#![cfg(feature = \"full\")]\n+#![cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"macos\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"illumos\"\n+))]\n+#![cfg(not(miri))] // No `sigaction` on Miri\n+\n+mod support {\n+    pub mod signal;\n+}\n+use support::signal::send_signal;\n+\n+use tokio::signal;\n+use tokio::signal::unix::SignalKind;\n+use tokio::sync::oneshot;\n+\n+#[tokio::test]\n+async fn siginfo() {\n+    let mut sig = signal::unix::signal(SignalKind::info()).expect(\"installed signal handler\");\n+\n+    let (fire, wait) = oneshot::channel();\n+\n+    // NB: simulate a signal coming in by exercising our signal handler\n+    // to avoid complications with sending SIGINFO to the test process\n+    tokio::spawn(async {\n+        wait.await.expect(\"wait failed\");\n+        send_signal(libc::SIGINFO);\n+    });\n+\n+    let _ = fire.send(());\n+\n+    sig.recv().await.expect(\"received SIGINFO signal\");",
        "comment_created_at": "2024-12-03T22:36:53+00:00",
        "comment_author": "sunshowers",
        "comment_body": "All right, done.",
        "pr_file_module": null
      }
    ]
  }
]