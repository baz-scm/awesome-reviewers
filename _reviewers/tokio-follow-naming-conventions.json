[
  {
    "discussion_id": "1535162888",
    "pr_number": 6418,
    "pr_file": "tokio/src/sync/rwlock/owned_read_guard.rs",
    "created_at": "2024-03-22T07:41:10+00:00",
    "commented_code": "resource_span: this.resource_span,\n         })\n     }\n+\n+    /// Returns a reference to the original `Arc<RwLock>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use tokio::sync::{RwLock, OwnedRwLockReadGuard};\n+    ///\n+    /// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+    /// struct Foo(u32);\n+    ///\n+    /// # #[tokio::main]\n+    /// # async fn main() {\n+    /// let lock = Arc::new(RwLock::new(Foo(1)));\n+    ///\n+    /// let guard = lock.clone().read_owned().await;\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    ///\n+    /// let guard = OwnedRwLockReadGuard::map(guard, |f| &f.0);\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    /// # }\n+    /// ```\n+    pub fn rwlock(&self) -> &Arc<RwLock<T>> {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1535162888",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6418,
        "pr_file": "tokio/src/sync/rwlock/owned_read_guard.rs",
        "discussion_id": "1535162888",
        "commented_code": "@@ -138,6 +138,32 @@ impl<T: ?Sized, U: ?Sized> OwnedRwLockReadGuard<T, U> {\n             resource_span: this.resource_span,\n         })\n     }\n+\n+    /// Returns a reference to the original `Arc<RwLock>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use tokio::sync::{RwLock, OwnedRwLockReadGuard};\n+    ///\n+    /// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+    /// struct Foo(u32);\n+    ///\n+    /// # #[tokio::main]\n+    /// # async fn main() {\n+    /// let lock = Arc::new(RwLock::new(Foo(1)));\n+    ///\n+    /// let guard = lock.clone().read_owned().await;\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    ///\n+    /// let guard = OwnedRwLockReadGuard::map(guard, |f| &f.0);\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    /// # }\n+    /// ```\n+    pub fn rwlock(&self) -> &Arc<RwLock<T>> {",
        "comment_created_at": "2024-03-22T07:41:10+00:00",
        "comment_author": "Darksonn",
        "comment_body": "We shouldn't add new `self` methods to types that implement `Deref`.\r\n```suggestion\r\n    pub fn rwlock(this: &Self) -> &Arc<RwLock<T>> {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1535261011",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6418,
        "pr_file": "tokio/src/sync/rwlock/owned_read_guard.rs",
        "discussion_id": "1535162888",
        "commented_code": "@@ -138,6 +138,32 @@ impl<T: ?Sized, U: ?Sized> OwnedRwLockReadGuard<T, U> {\n             resource_span: this.resource_span,\n         })\n     }\n+\n+    /// Returns a reference to the original `Arc<RwLock>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use tokio::sync::{RwLock, OwnedRwLockReadGuard};\n+    ///\n+    /// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+    /// struct Foo(u32);\n+    ///\n+    /// # #[tokio::main]\n+    /// # async fn main() {\n+    /// let lock = Arc::new(RwLock::new(Foo(1)));\n+    ///\n+    /// let guard = lock.clone().read_owned().await;\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    ///\n+    /// let guard = OwnedRwLockReadGuard::map(guard, |f| &f.0);\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    /// # }\n+    /// ```\n+    pub fn rwlock(&self) -> &Arc<RwLock<T>> {",
        "comment_created_at": "2024-03-22T09:03:49+00:00",
        "comment_author": "r3v2d0g",
        "comment_body": "Ah, makes sense!",
        "pr_file_module": null
      },
      {
        "comment_id": "1536770848",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6418,
        "pr_file": "tokio/src/sync/rwlock/owned_read_guard.rs",
        "discussion_id": "1535162888",
        "commented_code": "@@ -138,6 +138,32 @@ impl<T: ?Sized, U: ?Sized> OwnedRwLockReadGuard<T, U> {\n             resource_span: this.resource_span,\n         })\n     }\n+\n+    /// Returns a reference to the original `Arc<RwLock>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use tokio::sync::{RwLock, OwnedRwLockReadGuard};\n+    ///\n+    /// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+    /// struct Foo(u32);\n+    ///\n+    /// # #[tokio::main]\n+    /// # async fn main() {\n+    /// let lock = Arc::new(RwLock::new(Foo(1)));\n+    ///\n+    /// let guard = lock.clone().read_owned().await;\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    ///\n+    /// let guard = OwnedRwLockReadGuard::map(guard, |f| &f.0);\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    /// # }\n+    /// ```\n+    pub fn rwlock(&self) -> &Arc<RwLock<T>> {",
        "comment_created_at": "2024-03-24T09:02:22+00:00",
        "comment_author": "mox692",
        "comment_body": "@Darksonn \r\nProbably I'm not following here. Could you elaborate on why we shouldn\u2019t add new &self methods to types that implement Deref?",
        "pr_file_module": null
      },
      {
        "comment_id": "1536781649",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6418,
        "pr_file": "tokio/src/sync/rwlock/owned_read_guard.rs",
        "discussion_id": "1535162888",
        "commented_code": "@@ -138,6 +138,32 @@ impl<T: ?Sized, U: ?Sized> OwnedRwLockReadGuard<T, U> {\n             resource_span: this.resource_span,\n         })\n     }\n+\n+    /// Returns a reference to the original `Arc<RwLock>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use tokio::sync::{RwLock, OwnedRwLockReadGuard};\n+    ///\n+    /// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+    /// struct Foo(u32);\n+    ///\n+    /// # #[tokio::main]\n+    /// # async fn main() {\n+    /// let lock = Arc::new(RwLock::new(Foo(1)));\n+    ///\n+    /// let guard = lock.clone().read_owned().await;\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    ///\n+    /// let guard = OwnedRwLockReadGuard::map(guard, |f| &f.0);\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    /// # }\n+    /// ```\n+    pub fn rwlock(&self) -> &Arc<RwLock<T>> {",
        "comment_created_at": "2024-03-24T10:09:06+00:00",
        "comment_author": "r3v2d0g",
        "comment_body": "@mox692 If the `Target` type of the `Deref` implementation (`T` in this case) already has a method `fn rwlock(&self)` then this will break backwards compatibility as instead of calling the target's method, `guard.rwlock()` will call the guard's.",
        "pr_file_module": null
      },
      {
        "comment_id": "1536822130",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6418,
        "pr_file": "tokio/src/sync/rwlock/owned_read_guard.rs",
        "discussion_id": "1535162888",
        "commented_code": "@@ -138,6 +138,32 @@ impl<T: ?Sized, U: ?Sized> OwnedRwLockReadGuard<T, U> {\n             resource_span: this.resource_span,\n         })\n     }\n+\n+    /// Returns a reference to the original `Arc<RwLock>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use tokio::sync::{RwLock, OwnedRwLockReadGuard};\n+    ///\n+    /// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+    /// struct Foo(u32);\n+    ///\n+    /// # #[tokio::main]\n+    /// # async fn main() {\n+    /// let lock = Arc::new(RwLock::new(Foo(1)));\n+    ///\n+    /// let guard = lock.clone().read_owned().await;\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    ///\n+    /// let guard = OwnedRwLockReadGuard::map(guard, |f| &f.0);\n+    /// assert!(Arc::ptr_eq(&lock, guard.rwlock()));\n+    /// # }\n+    /// ```\n+    pub fn rwlock(&self) -> &Arc<RwLock<T>> {",
        "comment_created_at": "2024-03-24T13:53:41+00:00",
        "comment_author": "mox692",
        "comment_body": "@r3v2d0g\r\nGot it, make sense. Thanks for the clarification.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1438625457",
    "pr_number": 6224,
    "pr_file": "tokio-util/src/task/spawn_aborting.rs",
    "created_at": "2023-12-30T15:06:49+00:00",
    "commented_code": "+use std::ops::{Deref, DerefMut};\n+\n+use tokio::task::JoinHandle;\n+\n+use futures_core::Future;\n+\n+/// This is a wrapper type around JoinHandle that allows it to be dropped.\n+#[derive(Debug)]\n+pub struct DropHandle<T>(JoinHandle<T>);",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1438625457",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6224,
        "pr_file": "tokio-util/src/task/spawn_aborting.rs",
        "discussion_id": "1438625457",
        "commented_code": "@@ -0,0 +1,38 @@\n+use std::ops::{Deref, DerefMut};\n+\n+use tokio::task::JoinHandle;\n+\n+use futures_core::Future;\n+\n+/// This is a wrapper type around JoinHandle that allows it to be dropped.\n+#[derive(Debug)]\n+pub struct DropHandle<T>(JoinHandle<T>);",
        "comment_created_at": "2023-12-30T15:06:49+00:00",
        "comment_author": "Darksonn",
        "comment_body": "This name is okay, but I think there is precedent for the name `AbortHandle` elsewhere, so we might want to prefer that name.",
        "pr_file_module": null
      },
      {
        "comment_id": "1438626665",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6224,
        "pr_file": "tokio-util/src/task/spawn_aborting.rs",
        "discussion_id": "1438625457",
        "commented_code": "@@ -0,0 +1,38 @@\n+use std::ops::{Deref, DerefMut};\n+\n+use tokio::task::JoinHandle;\n+\n+use futures_core::Future;\n+\n+/// This is a wrapper type around JoinHandle that allows it to be dropped.\n+#[derive(Debug)]\n+pub struct DropHandle<T>(JoinHandle<T>);",
        "comment_created_at": "2023-12-30T15:11:07+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Actually, we have a type called `AbortHandle` in Tokio, and that does something else ... so that name doesn't work.\r\n\r\nBut another option is `AbortOnDropHandle`. I'll let you pick.",
        "pr_file_module": null
      },
      {
        "comment_id": "1463720871",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6224,
        "pr_file": "tokio-util/src/task/spawn_aborting.rs",
        "discussion_id": "1438625457",
        "commented_code": "@@ -0,0 +1,38 @@\n+use std::ops::{Deref, DerefMut};\n+\n+use tokio::task::JoinHandle;\n+\n+use futures_core::Future;\n+\n+/// This is a wrapper type around JoinHandle that allows it to be dropped.\n+#[derive(Debug)]\n+pub struct DropHandle<T>(JoinHandle<T>);",
        "comment_created_at": "2024-01-23T17:56:10+00:00",
        "comment_author": "hawkw",
        "comment_body": "`AbortOnDropHandle` is uncomfortably verbose, but I think it's the most descriptive name...the name should make it clear what this type actually does. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "776975593",
    "pr_number": 4363,
    "pr_file": "tokio/src/net/udp.rs",
    "created_at": "2021-12-31T10:24:35+00:00",
    "commented_code": "}\n     }\n \n+    /// Sets the size of the UDP send buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_SNDBUF` socket option.\n+    pub fn set_send_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_send_buffer_size(size as usize)\n+    }\n+\n+    /// Returns the size of the UDP send buffer for this socket.\n+    ///\n+    /// On most operating systems, this is the value of the `SO_SNDBUF` socket\n+    /// option.\n+    ///\n+    /// Note that if [`set_send_buffer_size`] has been called on this socket\n+    /// previously, the value returned by this function may not be the same as\n+    /// the argument provided to `set_send_buffer_size`. This is for the\n+    /// following reasons:\n+    ///\n+    /// * Most operating systems have minimum and maximum allowed sizes for the\n+    ///   send buffer, and will clamp the provided value if it is below the\n+    ///   minimum or above the maximum. The minimum and maximum buffer sizes are\n+    ///   OS-dependent.\n+    /// * Linux will double the buffer size to account for internal bookkeeping\n+    ///   data, and returns the doubled value from `getsockopt(2)`. As per `man\n+    ///   7 socket`:\n+    ///   > Sets or gets the maximum socket send buffer in bytes. The\n+    ///   > kernel doubles this value (to allow space for bookkeeping\n+    ///   > overhead) when it is set using `setsockopt(2)`, and this doubled\n+    ///   > value is returned by `getsockopt(2)`.\n+    ///\n+    /// [`set_send_buffer_size`]: Self::set_send_buffer_size\n+    pub fn send_buffer_size(&self) -> io::Result<u32> {\n+        self.to_socket().send_buffer_size().map(|n| n as u32)\n+    }\n+\n+    /// Sets the size of the UDP receive buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_RCVBUF` socket option.\n+    pub fn set_recv_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_recv_buffer_size(size as usize)\n+    }\n+\n+    /// Returns the size of the UDP receive buffer for this socket.\n+    ///\n+    /// On most operating systems, this is the value of the `SO_RCVBUF` socket\n+    /// option.\n+    ///\n+    /// Note that if [`set_recv_buffer_size`] has been called on this socket\n+    /// previously, the value returned by this function may not be the same as\n+    /// the argument provided to `set_send_buffer_size`. This is for the\n+    /// following reasons:\n+    ///\n+    /// * Most operating systems have minimum and maximum allowed sizes for the\n+    ///   receive buffer, and will clamp the provided value if it is below the\n+    ///   minimum or above the maximum. The minimum and maximum buffer sizes are\n+    ///   OS-dependent.\n+    /// * Linux will double the buffer size to account for internal bookkeeping\n+    ///   data, and returns the doubled value from `getsockopt(2)`. As per `man\n+    ///   7 socket`:\n+    ///   > Sets or gets the maximum socket send buffer in bytes. The\n+    ///   > kernel doubles this value (to allow space for bookkeeping\n+    ///   > overhead) when it is set using `setsockopt(2)`, and this doubled\n+    ///   > value is returned by `getsockopt(2)`.\n+    ///\n+    /// [`set_recv_buffer_size`]: Self::set_recv_buffer_size\n+    pub fn recv_buffer_size(&self) -> io::Result<u32> {\n+        self.to_socket().recv_buffer_size().map(|n| n as u32)\n+    }\n+\n+    fn to_socket(&self) -> socket2::SockRef<'_> {\n+        socket2::SockRef::from(self)\n+    }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "776975593",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 4363,
        "pr_file": "tokio/src/net/udp.rs",
        "discussion_id": "776975593",
        "commented_code": "@@ -253,6 +253,78 @@ impl UdpSocket {\n         }\n     }\n \n+    /// Sets the size of the UDP send buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_SNDBUF` socket option.\n+    pub fn set_send_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_send_buffer_size(size as usize)\n+    }\n+\n+    /// Returns the size of the UDP send buffer for this socket.\n+    ///\n+    /// On most operating systems, this is the value of the `SO_SNDBUF` socket\n+    /// option.\n+    ///\n+    /// Note that if [`set_send_buffer_size`] has been called on this socket\n+    /// previously, the value returned by this function may not be the same as\n+    /// the argument provided to `set_send_buffer_size`. This is for the\n+    /// following reasons:\n+    ///\n+    /// * Most operating systems have minimum and maximum allowed sizes for the\n+    ///   send buffer, and will clamp the provided value if it is below the\n+    ///   minimum or above the maximum. The minimum and maximum buffer sizes are\n+    ///   OS-dependent.\n+    /// * Linux will double the buffer size to account for internal bookkeeping\n+    ///   data, and returns the doubled value from `getsockopt(2)`. As per `man\n+    ///   7 socket`:\n+    ///   > Sets or gets the maximum socket send buffer in bytes. The\n+    ///   > kernel doubles this value (to allow space for bookkeeping\n+    ///   > overhead) when it is set using `setsockopt(2)`, and this doubled\n+    ///   > value is returned by `getsockopt(2)`.\n+    ///\n+    /// [`set_send_buffer_size`]: Self::set_send_buffer_size\n+    pub fn send_buffer_size(&self) -> io::Result<u32> {\n+        self.to_socket().send_buffer_size().map(|n| n as u32)\n+    }\n+\n+    /// Sets the size of the UDP receive buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_RCVBUF` socket option.\n+    pub fn set_recv_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_recv_buffer_size(size as usize)\n+    }\n+\n+    /// Returns the size of the UDP receive buffer for this socket.\n+    ///\n+    /// On most operating systems, this is the value of the `SO_RCVBUF` socket\n+    /// option.\n+    ///\n+    /// Note that if [`set_recv_buffer_size`] has been called on this socket\n+    /// previously, the value returned by this function may not be the same as\n+    /// the argument provided to `set_send_buffer_size`. This is for the\n+    /// following reasons:\n+    ///\n+    /// * Most operating systems have minimum and maximum allowed sizes for the\n+    ///   receive buffer, and will clamp the provided value if it is below the\n+    ///   minimum or above the maximum. The minimum and maximum buffer sizes are\n+    ///   OS-dependent.\n+    /// * Linux will double the buffer size to account for internal bookkeeping\n+    ///   data, and returns the doubled value from `getsockopt(2)`. As per `man\n+    ///   7 socket`:\n+    ///   > Sets or gets the maximum socket send buffer in bytes. The\n+    ///   > kernel doubles this value (to allow space for bookkeeping\n+    ///   > overhead) when it is set using `setsockopt(2)`, and this doubled\n+    ///   > value is returned by `getsockopt(2)`.\n+    ///\n+    /// [`set_recv_buffer_size`]: Self::set_recv_buffer_size\n+    pub fn recv_buffer_size(&self) -> io::Result<u32> {\n+        self.to_socket().recv_buffer_size().map(|n| n as u32)\n+    }\n+\n+    fn to_socket(&self) -> socket2::SockRef<'_> {\n+        socket2::SockRef::from(self)\n+    }",
        "comment_created_at": "2021-12-31T10:24:35+00:00",
        "comment_author": "Darksonn",
        "comment_body": "According to the API guidelines, this should be called `as_socket`. It's not an expensive conversion.\r\n```suggestion\r\n    fn as_socket(&self) -> socket2::SockRef<'_> {\r\n        socket2::SockRef::from(self)\r\n    }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1573438716",
    "pr_number": 6500,
    "pr_file": "tokio/src/io/util/copy_bidirectional.rs",
    "created_at": "2024-04-20T21:52:42+00:00",
    "commented_code": "A: AsyncRead + AsyncWrite + Unpin + ?Sized,\n     B: AsyncRead + AsyncWrite + Unpin + ?Sized,\n {\n-    let mut a_to_b = TransferState::Running(CopyBuffer::new());\n-    let mut b_to_a = TransferState::Running(CopyBuffer::new());\n+    copy_bidirectional_impl(\n+        a,\n+        b,\n+        CopyBuffer::new(super::DEFAULT_BUF_SIZE),\n+        CopyBuffer::new(super::DEFAULT_BUF_SIZE),\n+    )\n+    .await\n+}\n+\n+/// The same as the [`copy_bidirectional()`], but allows to set the underlying `a` to `b` and `b` to `a` buffers sizes.\n+#[cfg_attr(docsrs, doc(cfg(feature = \"io-util\")))]\n+pub async fn copy_bidirectional_with_size<A, B>(",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1573438716",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6500,
        "pr_file": "tokio/src/io/util/copy_bidirectional.rs",
        "discussion_id": "1573438716",
        "commented_code": "@@ -74,8 +77,48 @@ where\n     A: AsyncRead + AsyncWrite + Unpin + ?Sized,\n     B: AsyncRead + AsyncWrite + Unpin + ?Sized,\n {\n-    let mut a_to_b = TransferState::Running(CopyBuffer::new());\n-    let mut b_to_a = TransferState::Running(CopyBuffer::new());\n+    copy_bidirectional_impl(\n+        a,\n+        b,\n+        CopyBuffer::new(super::DEFAULT_BUF_SIZE),\n+        CopyBuffer::new(super::DEFAULT_BUF_SIZE),\n+    )\n+    .await\n+}\n+\n+/// The same as the [`copy_bidirectional()`], but allows to set the underlying `a` to `b` and `b` to `a` buffers sizes.\n+#[cfg_attr(docsrs, doc(cfg(feature = \"io-util\")))]\n+pub async fn copy_bidirectional_with_size<A, B>(",
        "comment_created_at": "2024-04-20T21:52:42+00:00",
        "comment_author": "dd-dreams",
        "comment_body": "If it's with two buffer sizes, maybe it should be called `with_sizes`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1573628946",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6500,
        "pr_file": "tokio/src/io/util/copy_bidirectional.rs",
        "discussion_id": "1573438716",
        "commented_code": "@@ -74,8 +77,48 @@ where\n     A: AsyncRead + AsyncWrite + Unpin + ?Sized,\n     B: AsyncRead + AsyncWrite + Unpin + ?Sized,\n {\n-    let mut a_to_b = TransferState::Running(CopyBuffer::new());\n-    let mut b_to_a = TransferState::Running(CopyBuffer::new());\n+    copy_bidirectional_impl(\n+        a,\n+        b,\n+        CopyBuffer::new(super::DEFAULT_BUF_SIZE),\n+        CopyBuffer::new(super::DEFAULT_BUF_SIZE),\n+    )\n+    .await\n+}\n+\n+/// The same as the [`copy_bidirectional()`], but allows to set the underlying `a` to `b` and `b` to `a` buffers sizes.\n+#[cfg_attr(docsrs, doc(cfg(feature = \"io-util\")))]\n+pub async fn copy_bidirectional_with_size<A, B>(",
        "comment_created_at": "2024-04-21T06:01:55+00:00",
        "comment_author": "RRRadicalEdward",
        "comment_body": "Absolutely!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1541016545",
    "pr_number": 6433,
    "pr_file": "tokio/src/task/task_local.rs",
    "created_at": "2024-03-27T12:32:36+00:00",
    "commented_code": "}\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1541016545",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-03-27T12:32:36+00:00",
        "comment_author": "mox692",
        "comment_body": "I'm slightly inclined to name this method as `clone_inner`, because naming it `clone` sound like it's an implementation of Clone for LocalKey.",
        "pr_file_module": null
      },
      {
        "comment_id": "1554721340",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-06T22:11:44+00:00",
        "comment_author": "fenollp",
        "comment_body": "SGTM, amended.",
        "pr_file_module": null
      },
      {
        "comment_id": "1555045979",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-07T19:18:20+00:00",
        "comment_author": "mox692",
        "comment_body": "@fenollp \r\n~~Sorry for the confusion, but as Alice suggest [here](https://github.com/tokio-rs/tokio/pull/6433#issuecomment-2028023647), just adding a `Clone` bound to the existing `get` function seems sufficient here.~~",
        "pr_file_module": null
      },
      {
        "comment_id": "1555054738",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-07T20:09:11+00:00",
        "comment_author": "mox692",
        "comment_body": "Hmm, but if `T` only implements `Clone` then perhaps we still can't use `get`... \r\n\r\n@Darksonn \r\nAm I understanding your thoughts correctly?",
        "pr_file_module": null
      },
      {
        "comment_id": "1555456552",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-08T08:47:09+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Why not? I can't immediately see what would break if we just change `get` to `T: Clone`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1555556821",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-08T09:59:08+00:00",
        "comment_author": "fenollp",
        "comment_body": "My type is `Clone` but not `Copy` (an `Arc<_>`), if that helps.",
        "pr_file_module": null
      },
      {
        "comment_id": "1555666128",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-08T11:30:37+00:00",
        "comment_author": "mox692",
        "comment_body": "Ah, you meant to *replace* the bound from `Copy` to `Clone`? I misunderstood, sorry.\r\n\r\nThen yes, I also don't see any issue.",
        "pr_file_module": null
      },
      {
        "comment_id": "1555673348",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-08T11:36:21+00:00",
        "comment_author": "Darksonn",
        "comment_body": "This seems to compile locally:\r\n```diff\r\ndiff --git a/tokio/src/task/task_local.rs b/tokio/src/task/task_local.rs\r\nindex ba58ea6a..cb9d22c6 100644\r\n--- a/tokio/src/task/task_local.rs\r\n+++ b/tokio/src/task/task_local.rs\r\n@@ -264,16 +264,16 @@ impl<T: 'static> LocalKey<T> {\r\n     }\r\n }\r\n \r\n-impl<T: Copy + 'static> LocalKey<T> {\r\n+impl<T: Clone + 'static> LocalKey<T> {\r\n     /// Returns a copy of the task-local value\r\n-    /// if the task-local value implements `Copy`.\r\n+    /// if the task-local value implements `Clone`.\r\n     ///\r\n     /// # Panics\r\n     ///\r\n     /// This function will panic if the task local doesn't have a value set.\r\n     #[track_caller]\r\n     pub fn get(&'static self) -> T {\r\n-        self.with(|v| *v)\r\n+        self.with(|v| v.clone())\r\n     }\r\n }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1557076968",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-09T07:17:29+00:00",
        "comment_author": "fenollp",
        "comment_body": "Guys. Make up your mind, this is exactly my original commit. \n\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1557534695",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-09T12:14:43+00:00",
        "comment_author": "mox692",
        "comment_body": "What we want to do is [this change](https://github.com/tokio-rs/tokio/pull/6433#discussion_r1555673348). \r\nSorry if I missing something, but I guess you were originally trying to add a [new method with a Clone boundary](https://github.com/tokio-rs/tokio/commit/b6c21ad09363a21533919b50af7c4938551de9b2)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1557536379",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-09T12:16:05+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Is it? If so, then you changed it before I got a chance to see it, because the thing I saw originally added a new method called `clone` instead of changing the existing `get` method.\r\n\r\nEither way, I have made up my mind. I would like to change `get` instead of introducing a new method.",
        "pr_file_module": null
      },
      {
        "comment_id": "1557891538",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-09T15:48:56+00:00",
        "comment_author": "fenollp",
        "comment_body": "I'm not sure I understand what is going on in this review. Who's authoritative (I see one member and one contributor)? Why remove `get` for `Copy` inner types? Why not just add a similar impl for `Clone`? These are two orthogonal things.\r\n\r\nI'm making this PR to add a feature with a simpler dev UX than right now. I wasn't planning on removing anything. I couldn't just extend on `get` for `Copy + Clone` simply because my type isn't `Copy` (it's an `Arc<_>`).\r\n\r\nI'm not sure how to move forward anymore. Please help :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1559010829",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-10T07:53:14+00:00",
        "comment_author": "Darksonn",
        "comment_body": "I'm sorry for the confusion. First, I am on the Tokio core team and am authoritative in this case (but it doesn't seem like @mox692 and I disagree?). As for your other questions:\r\n\r\n> Why remove get for Copy inner types?\r\n\r\nI am not suggesting that you remove `get` for `Copy` types. All `Copy` types are also `Clone` (it's a subtrait), so you will still be able to use `get` with any `Copy` type after changing `T: Copy` to `T: Clone`.\r\n\r\n> Why not just add a similar impl for `Clone`?\r\n\r\nWe could also do that, but then `Copy` types have two identical methods that do the same thing. To me, it seems simpler dev UX to have a single method that works for both `Copy` and `Clone`. That's why I suggested it.\r\n\r\n> I couldn't just extend on `get` for `Copy + Clone` simply because my type isn't `Copy` (it's an `Arc<_>`).\r\n\r\nIf you make `get` require `T: Clone` (rather than `T: Copy + Clone`), then it also works for `Arc<_>`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1559122923",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6433,
        "pr_file": "tokio/src/task/task_local.rs",
        "discussion_id": "1541016545",
        "commented_code": "@@ -277,6 +277,20 @@ impl<T: Copy + 'static> LocalKey<T> {\n     }\n }\n \n+#[allow(clippy::should_implement_trait)]\n+impl<T: Clone + 'static> LocalKey<T> {\n+    /// Returns a clone of the task-local value\n+    /// if the task-local value implements `Clone`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the task local doesn't have a value set.\n+    #[track_caller]\n+    pub fn clone(&'static self) -> T {",
        "comment_created_at": "2024-04-10T09:18:35+00:00",
        "comment_author": "fenollp",
        "comment_body": " Thank you very much for the clarification! PR amended. \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1660060194",
    "pr_number": 6661,
    "pr_file": "tokio/src/sync/mpsc/bounded.rs",
    "created_at": "2024-06-30T03:18:38+00:00",
    "commented_code": ") -> Poll<usize> {\n         self.chan.recv_many(cx, buffer, limit)\n     }\n+\n+    /// Returns the number of [`Sender`] handles.\n+    pub fn strong_count(&self) -> usize {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1660060194",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6661,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1660060194",
        "commented_code": "@@ -711,6 +711,16 @@ impl<T> Receiver<T> {\n     ) -> Poll<usize> {\n         self.chan.recv_many(cx, buffer, limit)\n     }\n+\n+    /// Returns the number of [`Sender`] handles.\n+    pub fn strong_count(&self) -> usize {",
        "comment_created_at": "2024-06-30T03:18:38+00:00",
        "comment_author": "wathenjiang",
        "comment_body": "Wouldn't it be more explicit to name it `sender_strong_count` here?",
        "pr_file_module": null
      },
      {
        "comment_id": "1660153490",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6661,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1660060194",
        "commented_code": "@@ -711,6 +711,16 @@ impl<T> Receiver<T> {\n     ) -> Poll<usize> {\n         self.chan.recv_many(cx, buffer, limit)\n     }\n+\n+    /// Returns the number of [`Sender`] handles.\n+    pub fn strong_count(&self) -> usize {",
        "comment_created_at": "2024-06-30T10:52:42+00:00",
        "comment_author": "Darksonn",
        "comment_body": "I agree that `sender_strong_count` and `sender_weak_count` would be better. Otherwise, this PR looks good to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "1660192918",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6661,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1660060194",
        "commented_code": "@@ -711,6 +711,16 @@ impl<T> Receiver<T> {\n     ) -> Poll<usize> {\n         self.chan.recv_many(cx, buffer, limit)\n     }\n+\n+    /// Returns the number of [`Sender`] handles.\n+    pub fn strong_count(&self) -> usize {",
        "comment_created_at": "2024-06-30T14:33:26+00:00",
        "comment_author": "0xPoe",
        "comment_body": "Sounds good. I will update it. Thank you!",
        "pr_file_module": null
      },
      {
        "comment_id": "1660889786",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6661,
        "pr_file": "tokio/src/sync/mpsc/bounded.rs",
        "discussion_id": "1660060194",
        "commented_code": "@@ -711,6 +711,16 @@ impl<T> Receiver<T> {\n     ) -> Poll<usize> {\n         self.chan.recv_many(cx, buffer, limit)\n     }\n+\n+    /// Returns the number of [`Sender`] handles.\n+    pub fn strong_count(&self) -> usize {",
        "comment_created_at": "2024-07-01T11:16:48+00:00",
        "comment_author": "0xPoe",
        "comment_body": "Updated.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1585289578",
    "pr_number": 6520,
    "pr_file": "tokio/src/sync/notify.rs",
    "created_at": "2024-04-30T18:08:04+00:00",
    "commented_code": "// Alias for old name in 0.x\n     #[cfg_attr(docsrs, doc(alias = \"notify\"))]\n     pub fn notify_one(&self) {\n+        self.notify_with_strategy(NotifyOneStrategy::Fifo);\n+    }\n+\n+    /// Notifies the last waiting task.\n+    ///\n+    /// This function behaves identically to `notify_one` but using a\n+    /// LIFO algorithm to notify waiters from the queue, if there are any.\n+    ///\n+    /// Check the `notify_one` documentation for more info and\n+    /// examples.\n+    pub fn notify_one_lifo(&self) {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1585289578",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6520,
        "pr_file": "tokio/src/sync/notify.rs",
        "discussion_id": "1585289578",
        "commented_code": "@@ -558,6 +598,21 @@ impl Notify {\n     // Alias for old name in 0.x\n     #[cfg_attr(docsrs, doc(alias = \"notify\"))]\n     pub fn notify_one(&self) {\n+        self.notify_with_strategy(NotifyOneStrategy::Fifo);\n+    }\n+\n+    /// Notifies the last waiting task.\n+    ///\n+    /// This function behaves identically to `notify_one` but using a\n+    /// LIFO algorithm to notify waiters from the queue, if there are any.\n+    ///\n+    /// Check the `notify_one` documentation for more info and\n+    /// examples.\n+    pub fn notify_one_lifo(&self) {",
        "comment_created_at": "2024-04-30T18:08:04+00:00",
        "comment_author": "carllerche",
        "comment_body": "I'm not against calling this `notify_one_lifo`. As a consideration, do you think `notify_last_in` or `notify_one_last_in` could be better options?",
        "pr_file_module": null
      },
      {
        "comment_id": "1587188226",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6520,
        "pr_file": "tokio/src/sync/notify.rs",
        "discussion_id": "1585289578",
        "commented_code": "@@ -558,6 +598,21 @@ impl Notify {\n     // Alias for old name in 0.x\n     #[cfg_attr(docsrs, doc(alias = \"notify\"))]\n     pub fn notify_one(&self) {\n+        self.notify_with_strategy(NotifyOneStrategy::Fifo);\n+    }\n+\n+    /// Notifies the last waiting task.\n+    ///\n+    /// This function behaves identically to `notify_one` but using a\n+    /// LIFO algorithm to notify waiters from the queue, if there are any.\n+    ///\n+    /// Check the `notify_one` documentation for more info and\n+    /// examples.\n+    pub fn notify_one_lifo(&self) {",
        "comment_created_at": "2024-05-02T07:31:22+00:00",
        "comment_author": "pfreixes",
        "comment_body": "`notify_one_last_in` sounds better, users will easily understand the semantics of the method. Ill change this one.",
        "pr_file_module": null
      }
    ]
  }
]