[
  {
    "discussion_id": "1922054059",
    "pr_number": 7114,
    "pr_file": "tokio/src/io/stderr.rs",
    "created_at": "2025-01-20T09:18:03+00:00",
    "commented_code": "Pin::new(&mut self.std).poll_shutdown(cx)\n     }\n }\n+\n+impl Stderr {\n+    /// Returns true if the descriptor/handle refers to a terminal/tty.\n+    pub fn is_terminal(&self) -> bool {\n+        self.std\n+            .inner()\n+            .inner()\n+            .map(|stderr| stderr.is_terminal())\n+            .unwrap_or_default()",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1922054059",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7114,
        "pr_file": "tokio/src/io/stderr.rs",
        "discussion_id": "1922054059",
        "commented_code": "@@ -132,3 +133,14 @@ impl AsyncWrite for Stderr {\n         Pin::new(&mut self.std).poll_shutdown(cx)\n     }\n }\n+\n+impl Stderr {\n+    /// Returns true if the descriptor/handle refers to a terminal/tty.\n+    pub fn is_terminal(&self) -> bool {\n+        self.std\n+            .inner()\n+            .inner()\n+            .map(|stderr| stderr.is_terminal())\n+            .unwrap_or_default()",
        "comment_created_at": "2025-01-20T09:18:03+00:00",
        "comment_author": "Darksonn",
        "comment_body": "This will incorrectly return `false` if stderr is a terminal but there is an ongoing IO operation. Can we instead do this?\r\n```suggestion\r\n    /// Returns true if the descriptor/handle refers to a terminal/tty.\r\n    pub fn is_terminal(&self) -> bool {\r\n        std::io::stderr().is_terminal()\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1367433064",
    "pr_number": 6089,
    "pr_file": "tokio/src/io/async_fd.rs",
    "created_at": "2023-10-20T19:49:48+00:00",
    "commented_code": "Self::new_with_handle_and_interest(inner, scheduler::Handle::current(), interest)\n     }\n \n+    /// Create a new AsyncFd with the provided raw epoll flags for registration.\n+    ///\n+    /// These flags replace any epoll flags would normally set when registering the fd.\n+    ///\n+    ///  **Note**: This is an [unstable API][unstable]. The public API of this may break in 1.x\n+    /// releases.\n+    /// See [the documentation on unstable features][unstable] for details.\n+    ///\n+    ///  [unstable]: crate#unstable-features\n+    #[track_caller]\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    #[cfg_attr(docsrs, doc(cfg(tokio_unstable)), doc(cfg(target_os = \"linux\")))]\n+    pub fn with_epoll_flags(inner: T, flags: u32) -> io::Result<Self>",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1367433064",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/io/async_fd.rs",
        "discussion_id": "1367433064",
        "commented_code": "@@ -243,6 +243,25 @@ impl<T: AsRawFd> AsyncFd<T> {\n         Self::new_with_handle_and_interest(inner, scheduler::Handle::current(), interest)\n     }\n \n+    /// Create a new AsyncFd with the provided raw epoll flags for registration.\n+    ///\n+    /// These flags replace any epoll flags would normally set when registering the fd.\n+    ///\n+    ///  **Note**: This is an [unstable API][unstable]. The public API of this may break in 1.x\n+    /// releases.\n+    /// See [the documentation on unstable features][unstable] for details.\n+    ///\n+    ///  [unstable]: crate#unstable-features\n+    #[track_caller]\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    #[cfg_attr(docsrs, doc(cfg(tokio_unstable)), doc(cfg(target_os = \"linux\")))]\n+    pub fn with_epoll_flags(inner: T, flags: u32) -> io::Result<Self>",
        "comment_created_at": "2023-10-20T19:49:48+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Shouldn't this also take an interest? Otherwise we will eventually be asked to add an `with_epoll_flags_and_interest`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1367436260",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/io/async_fd.rs",
        "discussion_id": "1367433064",
        "commented_code": "@@ -243,6 +243,25 @@ impl<T: AsRawFd> AsyncFd<T> {\n         Self::new_with_handle_and_interest(inner, scheduler::Handle::current(), interest)\n     }\n \n+    /// Create a new AsyncFd with the provided raw epoll flags for registration.\n+    ///\n+    /// These flags replace any epoll flags would normally set when registering the fd.\n+    ///\n+    ///  **Note**: This is an [unstable API][unstable]. The public API of this may break in 1.x\n+    /// releases.\n+    /// See [the documentation on unstable features][unstable] for details.\n+    ///\n+    ///  [unstable]: crate#unstable-features\n+    #[track_caller]\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    #[cfg_attr(docsrs, doc(cfg(tokio_unstable)), doc(cfg(target_os = \"linux\")))]\n+    pub fn with_epoll_flags(inner: T, flags: u32) -> io::Result<Self>",
        "comment_created_at": "2023-10-20T19:54:19+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "The flags are used to specify the interest here.\r\n\r\nBecause epoll shoves everything into one int, including interest and flags, and because there can be complicated rules around what flags and interests are allowable together, it's much more practical to tell users to specify the interest manually in the flags.\r\n\r\nWe'd only end up with confusing behavior if we chose to add both as fields. For example, some of the fields we specify for readability are mutually exclusive with EPOLLEXCLUSIVE, which would confuse users since they would probably try and use EPOLLEXCLUSIVE primarily with read interest on listeners.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1368464407",
    "pr_number": 6089,
    "pr_file": "tokio/src/io/async_fd.rs",
    "created_at": "2023-10-23T10:36:53+00:00",
    "commented_code": "Self::new_with_handle_and_interest(inner, scheduler::Handle::current(), interest)\n     }\n \n+    /// Create a new AsyncFd with the provided raw epoll flags for registration.\n+    ///\n+    /// These flags replace any epoll flags would normally set when registering the fd.\n+    ///\n+    ///  **Note**: This is an [unstable API][unstable]. The public API of this may break in 1.x\n+    /// releases.\n+    /// See [the documentation on unstable features][unstable] for details.\n+    ///\n+    ///  [unstable]: crate#unstable-features",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1368464407",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/io/async_fd.rs",
        "discussion_id": "1368464407",
        "commented_code": "@@ -243,6 +243,25 @@ impl<T: AsRawFd> AsyncFd<T> {\n         Self::new_with_handle_and_interest(inner, scheduler::Handle::current(), interest)\n     }\n \n+    /// Create a new AsyncFd with the provided raw epoll flags for registration.\n+    ///\n+    /// These flags replace any epoll flags would normally set when registering the fd.\n+    ///\n+    ///  **Note**: This is an [unstable API][unstable]. The public API of this may break in 1.x\n+    /// releases.\n+    /// See [the documentation on unstable features][unstable] for details.\n+    ///\n+    ///  [unstable]: crate#unstable-features",
        "comment_created_at": "2023-10-23T10:36:53+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Please add to the documentation that `EPOLLONESHOT` must not be used, and that `EPOLLET` must be set. And please add debug asserts for this.",
        "pr_file_module": null
      },
      {
        "comment_id": "1368801492",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/io/async_fd.rs",
        "discussion_id": "1368464407",
        "commented_code": "@@ -243,6 +243,25 @@ impl<T: AsRawFd> AsyncFd<T> {\n         Self::new_with_handle_and_interest(inner, scheduler::Handle::current(), interest)\n     }\n \n+    /// Create a new AsyncFd with the provided raw epoll flags for registration.\n+    ///\n+    /// These flags replace any epoll flags would normally set when registering the fd.\n+    ///\n+    ///  **Note**: This is an [unstable API][unstable]. The public API of this may break in 1.x\n+    /// releases.\n+    /// See [the documentation on unstable features][unstable] for details.\n+    ///\n+    ///  [unstable]: crate#unstable-features",
        "comment_created_at": "2023-10-23T14:45:56+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1372169330",
    "pr_number": 6089,
    "pr_file": "tokio/src/runtime/io/driver.rs",
    "created_at": "2023-10-25T18:32:30+00:00",
    "commented_code": "Ok(scheduled_io)\n     }\n \n+    /// Registers an I/O resource with the reactor, bypassing Mio entirely and using raw epoll_ctl.\n+    ///\n+    /// This is more or less the copy-pasted from the Mio code, and exists so that we can use flags\n+    /// other than the base set of epoll ones we normally use and those representing interests.\n+    ///\n+    /// This is important for supporting things like `EPOLLEXCLUSIVE`, which is very useful for\n+    /// shared-nothing runtimes.\n+    ///\n+    /// The registries token is returned.\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    pub(super) fn add_source_raw(\n+        &self,\n+        source: &mut impl std::os::unix::io::AsRawFd,\n+        flags: u32,\n+    ) -> io::Result<Arc<ScheduledIo>> {\n+        use libc::EPOLLET;\n+        use std::os::unix::io::AsRawFd;\n+\n+        let events = EPOLLET as u32 | flags;\n+\n+        let scheduled_io = self.registrations.allocate(&mut self.synced.lock())?;\n+        let token = scheduled_io.token();\n+\n+        let mut event = libc::epoll_event {\n+            events,\n+            u64: usize::from(token) as u64,\n+        };\n+\n+        // TODO: if this returns an err, the `ScheduledIo` leaks...\n+        let res = unsafe {\n+            libc::epoll_ctl(",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1372169330",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/runtime/io/driver.rs",
        "discussion_id": "1372169330",
        "commented_code": "@@ -236,6 +236,54 @@ impl Handle {\n         Ok(scheduled_io)\n     }\n \n+    /// Registers an I/O resource with the reactor, bypassing Mio entirely and using raw epoll_ctl.\n+    ///\n+    /// This is more or less the copy-pasted from the Mio code, and exists so that we can use flags\n+    /// other than the base set of epoll ones we normally use and those representing interests.\n+    ///\n+    /// This is important for supporting things like `EPOLLEXCLUSIVE`, which is very useful for\n+    /// shared-nothing runtimes.\n+    ///\n+    /// The registries token is returned.\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    pub(super) fn add_source_raw(\n+        &self,\n+        source: &mut impl std::os::unix::io::AsRawFd,\n+        flags: u32,\n+    ) -> io::Result<Arc<ScheduledIo>> {\n+        use libc::EPOLLET;\n+        use std::os::unix::io::AsRawFd;\n+\n+        let events = EPOLLET as u32 | flags;\n+\n+        let scheduled_io = self.registrations.allocate(&mut self.synced.lock())?;\n+        let token = scheduled_io.token();\n+\n+        let mut event = libc::epoll_event {\n+            events,\n+            u64: usize::from(token) as u64,\n+        };\n+\n+        // TODO: if this returns an err, the `ScheduledIo` leaks...\n+        let res = unsafe {\n+            libc::epoll_ctl(",
        "comment_created_at": "2023-10-25T18:32:30+00:00",
        "comment_author": "carllerche",
        "comment_body": "We can't call `epoll_*` methods from Tokio as there is no guarantee that Mio uses epoll under the hood. Either we should have mio expose more APIs and call those, or we need to use epoll directly in Tokio (obviously, the first option is preferable).",
        "pr_file_module": null
      },
      {
        "comment_id": "1372225912",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/runtime/io/driver.rs",
        "discussion_id": "1372169330",
        "commented_code": "@@ -236,6 +236,54 @@ impl Handle {\n         Ok(scheduled_io)\n     }\n \n+    /// Registers an I/O resource with the reactor, bypassing Mio entirely and using raw epoll_ctl.\n+    ///\n+    /// This is more or less the copy-pasted from the Mio code, and exists so that we can use flags\n+    /// other than the base set of epoll ones we normally use and those representing interests.\n+    ///\n+    /// This is important for supporting things like `EPOLLEXCLUSIVE`, which is very useful for\n+    /// shared-nothing runtimes.\n+    ///\n+    /// The registries token is returned.\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    pub(super) fn add_source_raw(\n+        &self,\n+        source: &mut impl std::os::unix::io::AsRawFd,\n+        flags: u32,\n+    ) -> io::Result<Arc<ScheduledIo>> {\n+        use libc::EPOLLET;\n+        use std::os::unix::io::AsRawFd;\n+\n+        let events = EPOLLET as u32 | flags;\n+\n+        let scheduled_io = self.registrations.allocate(&mut self.synced.lock())?;\n+        let token = scheduled_io.token();\n+\n+        let mut event = libc::epoll_event {\n+            events,\n+            u64: usize::from(token) as u64,\n+        };\n+\n+        // TODO: if this returns an err, the `ScheduledIo` leaks...\n+        let res = unsafe {\n+            libc::epoll_ctl(",
        "comment_created_at": "2023-10-25T19:20:05+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "What guarantees are made by Mio around it's fd?",
        "pr_file_module": null
      },
      {
        "comment_id": "1372229420",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/runtime/io/driver.rs",
        "discussion_id": "1372169330",
        "commented_code": "@@ -236,6 +236,54 @@ impl Handle {\n         Ok(scheduled_io)\n     }\n \n+    /// Registers an I/O resource with the reactor, bypassing Mio entirely and using raw epoll_ctl.\n+    ///\n+    /// This is more or less the copy-pasted from the Mio code, and exists so that we can use flags\n+    /// other than the base set of epoll ones we normally use and those representing interests.\n+    ///\n+    /// This is important for supporting things like `EPOLLEXCLUSIVE`, which is very useful for\n+    /// shared-nothing runtimes.\n+    ///\n+    /// The registries token is returned.\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    pub(super) fn add_source_raw(\n+        &self,\n+        source: &mut impl std::os::unix::io::AsRawFd,\n+        flags: u32,\n+    ) -> io::Result<Arc<ScheduledIo>> {\n+        use libc::EPOLLET;\n+        use std::os::unix::io::AsRawFd;\n+\n+        let events = EPOLLET as u32 | flags;\n+\n+        let scheduled_io = self.registrations.allocate(&mut self.synced.lock())?;\n+        let token = scheduled_io.token();\n+\n+        let mut event = libc::epoll_event {\n+            events,\n+            u64: usize::from(token) as u64,\n+        };\n+\n+        // TODO: if this returns an err, the `ScheduledIo` leaks...\n+        let res = unsafe {\n+            libc::epoll_ctl(",
        "comment_created_at": "2023-10-25T19:23:29+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "I know that this behavior is not guaranteed, but we don't really say what behavior _is_.",
        "pr_file_module": null
      },
      {
        "comment_id": "1372229954",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/runtime/io/driver.rs",
        "discussion_id": "1372169330",
        "commented_code": "@@ -236,6 +236,54 @@ impl Handle {\n         Ok(scheduled_io)\n     }\n \n+    /// Registers an I/O resource with the reactor, bypassing Mio entirely and using raw epoll_ctl.\n+    ///\n+    /// This is more or less the copy-pasted from the Mio code, and exists so that we can use flags\n+    /// other than the base set of epoll ones we normally use and those representing interests.\n+    ///\n+    /// This is important for supporting things like `EPOLLEXCLUSIVE`, which is very useful for\n+    /// shared-nothing runtimes.\n+    ///\n+    /// The registries token is returned.\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    pub(super) fn add_source_raw(\n+        &self,\n+        source: &mut impl std::os::unix::io::AsRawFd,\n+        flags: u32,\n+    ) -> io::Result<Arc<ScheduledIo>> {\n+        use libc::EPOLLET;\n+        use std::os::unix::io::AsRawFd;\n+\n+        let events = EPOLLET as u32 | flags;\n+\n+        let scheduled_io = self.registrations.allocate(&mut self.synced.lock())?;\n+        let token = scheduled_io.token();\n+\n+        let mut event = libc::epoll_event {\n+            events,\n+            u64: usize::from(token) as u64,\n+        };\n+\n+        // TODO: if this returns an err, the `ScheduledIo` leaks...\n+        let res = unsafe {\n+            libc::epoll_ctl(",
        "comment_created_at": "2023-10-25T19:24:01+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "Which also I suppose begs the question \"if it isn't here so people can do this as an escape hatch, why is it here at all?\"",
        "pr_file_module": null
      },
      {
        "comment_id": "1372239207",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6089,
        "pr_file": "tokio/src/runtime/io/driver.rs",
        "discussion_id": "1372169330",
        "commented_code": "@@ -236,6 +236,54 @@ impl Handle {\n         Ok(scheduled_io)\n     }\n \n+    /// Registers an I/O resource with the reactor, bypassing Mio entirely and using raw epoll_ctl.\n+    ///\n+    /// This is more or less the copy-pasted from the Mio code, and exists so that we can use flags\n+    /// other than the base set of epoll ones we normally use and those representing interests.\n+    ///\n+    /// This is important for supporting things like `EPOLLEXCLUSIVE`, which is very useful for\n+    /// shared-nothing runtimes.\n+    ///\n+    /// The registries token is returned.\n+    #[cfg(all(target_os = \"linux\", tokio_unstable))]\n+    pub(super) fn add_source_raw(\n+        &self,\n+        source: &mut impl std::os::unix::io::AsRawFd,\n+        flags: u32,\n+    ) -> io::Result<Arc<ScheduledIo>> {\n+        use libc::EPOLLET;\n+        use std::os::unix::io::AsRawFd;\n+\n+        let events = EPOLLET as u32 | flags;\n+\n+        let scheduled_io = self.registrations.allocate(&mut self.synced.lock())?;\n+        let token = scheduled_io.token();\n+\n+        let mut event = libc::epoll_event {\n+            events,\n+            u64: usize::from(token) as u64,\n+        };\n+\n+        // TODO: if this returns an err, the `ScheduledIo` leaks...\n+        let res = unsafe {\n+            libc::epoll_ctl(",
        "comment_created_at": "2023-10-25T19:31:04+00:00",
        "comment_author": "Noah-Kennedy",
        "comment_body": "That being said, there's a deeper question here, which is \"do we need Interest::CUSTOM() in Mio, and how would that work?\"\r\n\r\nPersonally, I think if we're going to continue to use Mio within tokio, we probably need something like this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1715901664",
    "pr_number": 6772,
    "pr_file": "tokio/src/net/unix/listener.rs",
    "created_at": "2024-08-13T20:40:07+00:00",
    "commented_code": "where\n         P: AsRef<Path>,\n     {\n-        let listener = mio::net::UnixListener::bind(path)?;\n+        // For now, we handle abstract socket paths on linux here.\n+        #[cfg(target_os = \"linux\")]\n+        let addr = {\n+            let os_str_bytes = path.as_ref().as_os_str().as_bytes();\n+            if os_str_bytes.starts_with(b\"\\0\") {\n+                StdSocketAddr::from_abstract_name(os_str_bytes)?\n+            } else {\n+                StdSocketAddr::from_pathname(path)?\n+            }\n+        };",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1715901664",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6772,
        "pr_file": "tokio/src/net/unix/listener.rs",
        "discussion_id": "1715901664",
        "commented_code": "@@ -70,7 +74,20 @@ impl UnixListener {\n     where\n         P: AsRef<Path>,\n     {\n-        let listener = mio::net::UnixListener::bind(path)?;\n+        // For now, we handle abstract socket paths on linux here.\n+        #[cfg(target_os = \"linux\")]\n+        let addr = {\n+            let os_str_bytes = path.as_ref().as_os_str().as_bytes();\n+            if os_str_bytes.starts_with(b\"\\0\") {\n+                StdSocketAddr::from_abstract_name(os_str_bytes)?\n+            } else {\n+                StdSocketAddr::from_pathname(path)?\n+            }\n+        };",
        "comment_created_at": "2024-08-13T20:40:07+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Is Linux the only OS that needs this fix? Does macOS not have abstract path names? It would be worth to look at how mio did this prior to the v1 release.",
        "pr_file_module": null
      },
      {
        "comment_id": "1717090599",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6772,
        "pr_file": "tokio/src/net/unix/listener.rs",
        "discussion_id": "1715901664",
        "commented_code": "@@ -70,7 +74,20 @@ impl UnixListener {\n     where\n         P: AsRef<Path>,\n     {\n-        let listener = mio::net::UnixListener::bind(path)?;\n+        // For now, we handle abstract socket paths on linux here.\n+        #[cfg(target_os = \"linux\")]\n+        let addr = {\n+            let os_str_bytes = path.as_ref().as_os_str().as_bytes();\n+            if os_str_bytes.starts_with(b\"\\0\") {\n+                StdSocketAddr::from_abstract_name(os_str_bytes)?\n+            } else {\n+                StdSocketAddr::from_pathname(path)?\n+            }\n+        };",
        "comment_created_at": "2024-08-14T14:53:38+00:00",
        "comment_author": "mox692",
        "comment_body": "> Is Linux the only OS that needs this fix?\r\n\r\nAccording to my quick research, yes.\r\nActually `SocketAddrExt::from_abstract_name` is available on linux only.\r\n* https://doc.rust-lang.org/stable/std/os/linux/net/trait.SocketAddrExt.html\r\n* https://github.com/rust-lang/rust/issues/85410\r\n\r\nIt seems that mio previously used its own parser to handle all unix systems.\r\n* https://github.com/tokio-rs/mio/blob/cf5219446de5190752372f5401c51987248406f5/src/sys/unix/uds/mod.rs#L25-L72",
        "pr_file_module": null
      },
      {
        "comment_id": "1717093287",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6772,
        "pr_file": "tokio/src/net/unix/listener.rs",
        "discussion_id": "1715901664",
        "commented_code": "@@ -70,7 +74,20 @@ impl UnixListener {\n     where\n         P: AsRef<Path>,\n     {\n-        let listener = mio::net::UnixListener::bind(path)?;\n+        // For now, we handle abstract socket paths on linux here.\n+        #[cfg(target_os = \"linux\")]\n+        let addr = {\n+            let os_str_bytes = path.as_ref().as_os_str().as_bytes();\n+            if os_str_bytes.starts_with(b\"\\0\") {\n+                StdSocketAddr::from_abstract_name(os_str_bytes)?\n+            } else {\n+                StdSocketAddr::from_pathname(path)?\n+            }\n+        };",
        "comment_created_at": "2024-08-14T14:55:02+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Ah, ok. Does `target_os = \"linux\"` also include Android? I see that it's also available there.",
        "pr_file_module": null
      },
      {
        "comment_id": "1717122764",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6772,
        "pr_file": "tokio/src/net/unix/listener.rs",
        "discussion_id": "1715901664",
        "commented_code": "@@ -70,7 +74,20 @@ impl UnixListener {\n     where\n         P: AsRef<Path>,\n     {\n-        let listener = mio::net::UnixListener::bind(path)?;\n+        // For now, we handle abstract socket paths on linux here.\n+        #[cfg(target_os = \"linux\")]\n+        let addr = {\n+            let os_str_bytes = path.as_ref().as_os_str().as_bytes();\n+            if os_str_bytes.starts_with(b\"\\0\") {\n+                StdSocketAddr::from_abstract_name(os_str_bytes)?\n+            } else {\n+                StdSocketAddr::from_pathname(path)?\n+            }\n+        };",
        "comment_created_at": "2024-08-14T15:14:06+00:00",
        "comment_author": "mox692",
        "comment_body": "Yes, we should probably add `target_os = \"android\"` as well. I just added now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "776975741",
    "pr_number": 4363,
    "pr_file": "tokio/src/net/udp.rs",
    "created_at": "2021-12-31T10:25:16+00:00",
    "commented_code": "}\n     }\n \n+    /// Sets the size of the UDP send buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_SNDBUF` socket option.\n+    pub fn set_send_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_send_buffer_size(size as usize)\n+    }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "776975741",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 4363,
        "pr_file": "tokio/src/net/udp.rs",
        "discussion_id": "776975741",
        "commented_code": "@@ -253,6 +253,78 @@ impl UdpSocket {\n         }\n     }\n \n+    /// Sets the size of the UDP send buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_SNDBUF` socket option.\n+    pub fn set_send_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_send_buffer_size(size as usize)\n+    }",
        "comment_created_at": "2021-12-31T10:25:16+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Why the casts?",
        "pr_file_module": null
      },
      {
        "comment_id": "776988535",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 4363,
        "pr_file": "tokio/src/net/udp.rs",
        "discussion_id": "776975741",
        "commented_code": "@@ -253,6 +253,78 @@ impl UdpSocket {\n         }\n     }\n \n+    /// Sets the size of the UDP send buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_SNDBUF` socket option.\n+    pub fn set_send_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_send_buffer_size(size as usize)\n+    }",
        "comment_created_at": "2021-12-31T11:39:45+00:00",
        "comment_author": "taiki-e",
        "comment_body": "- socket2's [set_send_buffer_size](https://docs.rs/socket2/latest/socket2/struct.Socket.html#method.set_send_buffer_size) uses usize.\r\n- tokio::net::TcpSocket's [set_send_buffer_size](https://docs.rs/tokio/latest/tokio/net/struct.TcpSocket.html#method.set_send_buffer_size) uses u32.\r\n\r\nThis PR (tokio::net::UdpSocket) uses u32 for consistency with TcpSocket's methods, so we need casts here.\r\n\r\nAnd as I said in https://github.com/tokio-rs/tokio/pull/4270#discussion_r754974978, these casts are fine.\r\n\r\n> - set_send_buffer_size,set_recv_buffer_size (cast u32 as usize): on tokio, [usize is always at least 32 bits](https://github.com/tokio-rs/tokio/blob/cf3206842c0d94ecdaaeb421a58b1c963b627c3d/tokio/src/lib.rs#L357-L368).\r\n> - send_buffer_size,recv_buffer_size (cast usize as u32): socket2 gets these values as  c_int ([always i32](https://grep.app/search?q=type%20c_int%20%3D&filter[repo][0]=rust-lang/libc)) and then cast them to usize ([1](https://github.com/rust-lang/socket2/blob/cddb67b8534a46a372beb9fd63c5ce8d1473cbda/src/socket.rs#L857-L858), [2](https://github.com/rust-lang/socket2/blob/cddb67b8534a46a372beb9fd63c5ce8d1473cbda/src/socket.rs#L928-L929)).",
        "pr_file_module": null
      },
      {
        "comment_id": "776989315",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 4363,
        "pr_file": "tokio/src/net/udp.rs",
        "discussion_id": "776975741",
        "commented_code": "@@ -253,6 +253,78 @@ impl UdpSocket {\n         }\n     }\n \n+    /// Sets the size of the UDP send buffer on this socket.\n+    ///\n+    /// On most operating systems, this sets the `SO_SNDBUF` socket option.\n+    pub fn set_send_buffer_size(&self, size: u32) -> io::Result<()> {\n+        self.to_socket().set_send_buffer_size(size as usize)\n+    }",
        "comment_created_at": "2021-12-31T11:44:57+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Thanks.",
        "pr_file_module": null
      }
    ]
  }
]