[
  {
    "discussion_id": "1969372162",
    "pr_number": 7164,
    "pr_file": "tokio/src/macros/support.rs",
    "created_at": "2025-02-25T09:35:42+00:00",
    "commented_code": "pub fn thread_rng_n(n: u32) -> u32 {\n         crate::runtime::context::thread_rng_n(n)\n     }\n+\n+    #[doc(hidden)]\n+    pub fn has_budget_remaining() -> bool {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1969372162",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7164,
        "pr_file": "tokio/src/macros/support.rs",
        "discussion_id": "1969372162",
        "commented_code": "@@ -7,6 +7,14 @@ cfg_macros! {\n     pub fn thread_rng_n(n: u32) -> u32 {\n         crate::runtime::context::thread_rng_n(n)\n     }\n+\n+    #[doc(hidden)]\n+    pub fn has_budget_remaining() -> bool {",
        "comment_created_at": "2025-02-25T09:35:42+00:00",
        "comment_author": "Darksonn",
        "comment_body": "```suggestion\r\n    #[doc(hidden)]\r\n    #[inline]\r\n    pub fn has_budget_remaining() -> bool {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1536762508",
    "pr_number": 6409,
    "pr_file": "tokio-stream/src/stream_map.rs",
    "created_at": "2024-03-24T08:04:44+00:00",
    "commented_code": "}\n }\n \n+impl<K, V> StreamMap<K, V>\n+where\n+    K: Clone + Unpin,\n+    V: Stream + Unpin,\n+{\n+    /// Receives multiple items on this [`StreamMap`], extending the provided `buffer`.\n+    ///\n+    /// This method returns the number of items that is appended to the `buffer`.\n+    ///\n+    /// Note that this method does not guarantee that exactly `limit` items\n+    /// are received. Rather, if at least one item is available, it returns\n+    /// as many items as it can up to the given limit. This method returns\n+    /// zero only if the `StreamMap` is empty (or if `limit` is zero).\n+    ///\n+    /// # Cancel safety\n+    ///\n+    /// This method is cancel safe. If `next_many` is used as the event in a\n+    /// [`tokio::select!`](tokio::select) statement and some other branch\n+    /// completes first, it is guaranteed that no items were received on any of\n+    /// the underlying streams.\n+    pub async fn next_many(&mut self, buffer: &mut Vec<(K, V::Item)>, limit: usize) -> usize {\n+        poll_fn(|cx| self.poll_next_many(cx, buffer, limit)).await\n+    }\n+\n+    /// Polls to receive multiple items on this `StreamMap`, extending the provided `buffer`.\n+    ///\n+    /// This method returns:\n+    /// * `Poll::Pending` if no items are available but the `StreamMap` is not empty.\n+    /// * `Poll::Ready(count)` where `count` is the number of items successfully received and\n+    ///   stored in `buffer`. This can be less than, or equal to, `limit`.\n+    /// * `Poll::Ready(0)` if `limit` is set to zero or when the `StreamMap` is empty.\n+    ///\n+    /// When the method returns `Poll::Pending`, the `Waker` in the provided\n+    /// `Context` is scheduled to receive a wakeup when an item is sent on any of the\n+    /// underlying stream. Note that on multiple calls to `poll_next_many`, only\n+    /// the `Waker` from the `Context` passed to the most recent call is scheduled\n+    /// to receive a wakeup.\n+    ///\n+    /// Note that this method does not guarantee that exactly `limit` items\n+    /// are received. Rather, if at least one item is available, it returns\n+    /// as many items as it can up to the given limit. This method returns\n+    /// zero only if the `StreamMap` is empty (or if `limit` is zero).\n+    pub fn poll_next_many(\n+        &mut self,\n+        cx: &mut Context<'_>,\n+        buffer: &mut Vec<(K, V::Item)>,\n+        limit: usize,\n+    ) -> Poll<usize> {\n+        if limit == 0 {\n+            return Poll::Ready(0);\n+        }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1536762508",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6409,
        "pr_file": "tokio-stream/src/stream_map.rs",
        "discussion_id": "1536762508",
        "commented_code": "@@ -561,6 +566,86 @@ impl<K, V> Default for StreamMap<K, V> {\n     }\n }\n \n+impl<K, V> StreamMap<K, V>\n+where\n+    K: Clone + Unpin,\n+    V: Stream + Unpin,\n+{\n+    /// Receives multiple items on this [`StreamMap`], extending the provided `buffer`.\n+    ///\n+    /// This method returns the number of items that is appended to the `buffer`.\n+    ///\n+    /// Note that this method does not guarantee that exactly `limit` items\n+    /// are received. Rather, if at least one item is available, it returns\n+    /// as many items as it can up to the given limit. This method returns\n+    /// zero only if the `StreamMap` is empty (or if `limit` is zero).\n+    ///\n+    /// # Cancel safety\n+    ///\n+    /// This method is cancel safe. If `next_many` is used as the event in a\n+    /// [`tokio::select!`](tokio::select) statement and some other branch\n+    /// completes first, it is guaranteed that no items were received on any of\n+    /// the underlying streams.\n+    pub async fn next_many(&mut self, buffer: &mut Vec<(K, V::Item)>, limit: usize) -> usize {\n+        poll_fn(|cx| self.poll_next_many(cx, buffer, limit)).await\n+    }\n+\n+    /// Polls to receive multiple items on this `StreamMap`, extending the provided `buffer`.\n+    ///\n+    /// This method returns:\n+    /// * `Poll::Pending` if no items are available but the `StreamMap` is not empty.\n+    /// * `Poll::Ready(count)` where `count` is the number of items successfully received and\n+    ///   stored in `buffer`. This can be less than, or equal to, `limit`.\n+    /// * `Poll::Ready(0)` if `limit` is set to zero or when the `StreamMap` is empty.\n+    ///\n+    /// When the method returns `Poll::Pending`, the `Waker` in the provided\n+    /// `Context` is scheduled to receive a wakeup when an item is sent on any of the\n+    /// underlying stream. Note that on multiple calls to `poll_next_many`, only\n+    /// the `Waker` from the `Context` passed to the most recent call is scheduled\n+    /// to receive a wakeup.\n+    ///\n+    /// Note that this method does not guarantee that exactly `limit` items\n+    /// are received. Rather, if at least one item is available, it returns\n+    /// as many items as it can up to the given limit. This method returns\n+    /// zero only if the `StreamMap` is empty (or if `limit` is zero).\n+    pub fn poll_next_many(\n+        &mut self,\n+        cx: &mut Context<'_>,\n+        buffer: &mut Vec<(K, V::Item)>,\n+        limit: usize,\n+    ) -> Poll<usize> {\n+        if limit == 0 {\n+            return Poll::Ready(0);\n+        }",
        "comment_created_at": "2024-03-24T08:04:44+00:00",
        "comment_author": "mox692",
        "comment_body": "I think we could also return early when  the entry is already empty.\r\n\r\n```suggestion\r\n        if limit == 0 || self.entries.is_empty() {\r\n            return Poll::Ready(0);\r\n        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1536789081",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6409,
        "pr_file": "tokio-stream/src/stream_map.rs",
        "discussion_id": "1536762508",
        "commented_code": "@@ -561,6 +566,86 @@ impl<K, V> Default for StreamMap<K, V> {\n     }\n }\n \n+impl<K, V> StreamMap<K, V>\n+where\n+    K: Clone + Unpin,\n+    V: Stream + Unpin,\n+{\n+    /// Receives multiple items on this [`StreamMap`], extending the provided `buffer`.\n+    ///\n+    /// This method returns the number of items that is appended to the `buffer`.\n+    ///\n+    /// Note that this method does not guarantee that exactly `limit` items\n+    /// are received. Rather, if at least one item is available, it returns\n+    /// as many items as it can up to the given limit. This method returns\n+    /// zero only if the `StreamMap` is empty (or if `limit` is zero).\n+    ///\n+    /// # Cancel safety\n+    ///\n+    /// This method is cancel safe. If `next_many` is used as the event in a\n+    /// [`tokio::select!`](tokio::select) statement and some other branch\n+    /// completes first, it is guaranteed that no items were received on any of\n+    /// the underlying streams.\n+    pub async fn next_many(&mut self, buffer: &mut Vec<(K, V::Item)>, limit: usize) -> usize {\n+        poll_fn(|cx| self.poll_next_many(cx, buffer, limit)).await\n+    }\n+\n+    /// Polls to receive multiple items on this `StreamMap`, extending the provided `buffer`.\n+    ///\n+    /// This method returns:\n+    /// * `Poll::Pending` if no items are available but the `StreamMap` is not empty.\n+    /// * `Poll::Ready(count)` where `count` is the number of items successfully received and\n+    ///   stored in `buffer`. This can be less than, or equal to, `limit`.\n+    /// * `Poll::Ready(0)` if `limit` is set to zero or when the `StreamMap` is empty.\n+    ///\n+    /// When the method returns `Poll::Pending`, the `Waker` in the provided\n+    /// `Context` is scheduled to receive a wakeup when an item is sent on any of the\n+    /// underlying stream. Note that on multiple calls to `poll_next_many`, only\n+    /// the `Waker` from the `Context` passed to the most recent call is scheduled\n+    /// to receive a wakeup.\n+    ///\n+    /// Note that this method does not guarantee that exactly `limit` items\n+    /// are received. Rather, if at least one item is available, it returns\n+    /// as many items as it can up to the given limit. This method returns\n+    /// zero only if the `StreamMap` is empty (or if `limit` is zero).\n+    pub fn poll_next_many(\n+        &mut self,\n+        cx: &mut Context<'_>,\n+        buffer: &mut Vec<(K, V::Item)>,\n+        limit: usize,\n+    ) -> Poll<usize> {\n+        if limit == 0 {\n+            return Poll::Ready(0);\n+        }",
        "comment_created_at": "2024-03-24T10:58:18+00:00",
        "comment_author": "maminrayej",
        "comment_body": "You're right.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1720427838",
    "pr_number": 6779,
    "pr_file": "tokio/src/runtime/time/mod.rs",
    "created_at": "2024-08-16T22:48:26+00:00",
    "commented_code": "// ===== impl Inner =====\n \n impl Inner {\n-    /// Locks the driver's sharded wheel structure.\n-    pub(super) fn lock_sharded_wheel(\n-        &self,\n-        shard_id: u32,\n-    ) -> crate::loom::sync::MutexGuard<'_, Wheel> {\n-        let index = shard_id % (self.wheels.len() as u32);\n-        // Safety: This modulo operation ensures that the index is not out of bounds.\n-        unsafe { self.wheels.get_unchecked(index as usize).lock() }\n-    }\n-\n     // Check whether the driver has been shutdown\n     pub(super) fn is_shutdown(&self) -> bool {\n         self.is_shutdown.load(Ordering::SeqCst)\n     }\n \n     // Gets the number of shards.\n     fn get_shard_size(&self) -> u32 {\n-        self.wheels.len() as u32\n+        self.wheels\n+            .read()\n+            .expect(\"Timer wheel shards poisened\")",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1720427838",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6779,
        "pr_file": "tokio/src/runtime/time/mod.rs",
        "discussion_id": "1720427838",
        "commented_code": "@@ -443,24 +474,17 @@ impl Handle {\n // ===== impl Inner =====\n \n impl Inner {\n-    /// Locks the driver's sharded wheel structure.\n-    pub(super) fn lock_sharded_wheel(\n-        &self,\n-        shard_id: u32,\n-    ) -> crate::loom::sync::MutexGuard<'_, Wheel> {\n-        let index = shard_id % (self.wheels.len() as u32);\n-        // Safety: This modulo operation ensures that the index is not out of bounds.\n-        unsafe { self.wheels.get_unchecked(index as usize).lock() }\n-    }\n-\n     // Check whether the driver has been shutdown\n     pub(super) fn is_shutdown(&self) -> bool {\n         self.is_shutdown.load(Ordering::SeqCst)\n     }\n \n     // Gets the number of shards.\n     fn get_shard_size(&self) -> u32 {\n-        self.wheels.len() as u32\n+        self.wheels\n+            .read()\n+            .expect(\"Timer wheel shards poisened\")",
        "comment_created_at": "2024-08-16T22:48:26+00:00",
        "comment_author": "hawkw",
        "comment_body": "It's a bit unfortunate that this can panic. Not because the panic  itself is _bad_, if the lock is poisoned, we _should_ panic, but because panicking code will make this  otherwise small and trivially inlined function generate way more code. Perhaps we should  move the number of shards outside of the lock, instead? Since it will never change, it should be fine to do that...",
        "pr_file_module": null
      },
      {
        "comment_id": "1720428019",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6779,
        "pr_file": "tokio/src/runtime/time/mod.rs",
        "discussion_id": "1720427838",
        "commented_code": "@@ -443,24 +474,17 @@ impl Handle {\n // ===== impl Inner =====\n \n impl Inner {\n-    /// Locks the driver's sharded wheel structure.\n-    pub(super) fn lock_sharded_wheel(\n-        &self,\n-        shard_id: u32,\n-    ) -> crate::loom::sync::MutexGuard<'_, Wheel> {\n-        let index = shard_id % (self.wheels.len() as u32);\n-        // Safety: This modulo operation ensures that the index is not out of bounds.\n-        unsafe { self.wheels.get_unchecked(index as usize).lock() }\n-    }\n-\n     // Check whether the driver has been shutdown\n     pub(super) fn is_shutdown(&self) -> bool {\n         self.is_shutdown.load(Ordering::SeqCst)\n     }\n \n     // Gets the number of shards.\n     fn get_shard_size(&self) -> u32 {\n-        self.wheels.len() as u32\n+        self.wheels\n+            .read()\n+            .expect(\"Timer wheel shards poisened\")",
        "comment_created_at": "2024-08-16T22:48:51+00:00",
        "comment_author": "hawkw",
        "comment_body": "also, a typo: \r\n```suggestion\r\n            .expect(\"Timer wheel shards poisoned\")\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1720966245",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6779,
        "pr_file": "tokio/src/runtime/time/mod.rs",
        "discussion_id": "1720427838",
        "commented_code": "@@ -443,24 +474,17 @@ impl Handle {\n // ===== impl Inner =====\n \n impl Inner {\n-    /// Locks the driver's sharded wheel structure.\n-    pub(super) fn lock_sharded_wheel(\n-        &self,\n-        shard_id: u32,\n-    ) -> crate::loom::sync::MutexGuard<'_, Wheel> {\n-        let index = shard_id % (self.wheels.len() as u32);\n-        // Safety: This modulo operation ensures that the index is not out of bounds.\n-        unsafe { self.wheels.get_unchecked(index as usize).lock() }\n-    }\n-\n     // Check whether the driver has been shutdown\n     pub(super) fn is_shutdown(&self) -> bool {\n         self.is_shutdown.load(Ordering::SeqCst)\n     }\n \n     // Gets the number of shards.\n     fn get_shard_size(&self) -> u32 {\n-        self.wheels.len() as u32\n+        self.wheels\n+            .read()\n+            .expect(\"Timer wheel shards poisened\")",
        "comment_created_at": "2024-08-18T12:30:20+00:00",
        "comment_author": "tglane",
        "comment_body": "Seems reasonable to put it as a member variable into the `Inner` struct to avoid the lock here. The increase in size of the struct would probably be ok since it's \"only\" a `u32`, so I would agree to do it like that if nobody objects.",
        "pr_file_module": null
      },
      {
        "comment_id": "1721025538",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6779,
        "pr_file": "tokio/src/runtime/time/mod.rs",
        "discussion_id": "1720427838",
        "commented_code": "@@ -443,24 +474,17 @@ impl Handle {\n // ===== impl Inner =====\n \n impl Inner {\n-    /// Locks the driver's sharded wheel structure.\n-    pub(super) fn lock_sharded_wheel(\n-        &self,\n-        shard_id: u32,\n-    ) -> crate::loom::sync::MutexGuard<'_, Wheel> {\n-        let index = shard_id % (self.wheels.len() as u32);\n-        // Safety: This modulo operation ensures that the index is not out of bounds.\n-        unsafe { self.wheels.get_unchecked(index as usize).lock() }\n-    }\n-\n     // Check whether the driver has been shutdown\n     pub(super) fn is_shutdown(&self) -> bool {\n         self.is_shutdown.load(Ordering::SeqCst)\n     }\n \n     // Gets the number of shards.\n     fn get_shard_size(&self) -> u32 {\n-        self.wheels.len() as u32\n+        self.wheels\n+            .read()\n+            .expect(\"Timer wheel shards poisened\")",
        "comment_created_at": "2024-08-18T17:30:56+00:00",
        "comment_author": "tglane",
        "comment_body": "I included the changes in  [e9c4351](https://github.com/tokio-rs/tokio/pull/6779/commits/e9c4351901453989f917366ae36c19090238cb6d).\r\n\r\nI also removed the method to get the shard size from the struct `ShardedWheel` to prevent duplications since we can get it from the struct `Inner` everywhere where It's needed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2123891821",
    "pr_number": 7357,
    "pr_file": "tokio/src/runtime/io/driver/uring.rs",
    "created_at": "2025-06-03T13:51:04+00:00",
    "commented_code": "impl Handle {\n     #[allow(dead_code)]\n-    pub(crate) fn add_uring_source(&self, interest: Interest) -> io::Result<()> {\n-        // setup for io_uring\n-        let uringfd = self.get_uring().lock().uring.as_raw_fd();\n+    fn add_uring_source(&self, uringfd: RawFd) -> io::Result<()> {\n         let mut source = SourceFd(&uringfd);\n         self.registry\n-            .register(&mut source, TOKEN_WAKEUP, interest.to_mio())\n+            .register(&mut source, TOKEN_WAKEUP, Interest::READABLE.to_mio())\n     }\n \n     pub(crate) fn get_uring(&self) -> &Mutex<UringContext> {\n         &self.uring_context\n     }\n \n+    fn set_uring_state(&self, state: State) {\n+        self.uring_state.store(state.as_usize(), Ordering::Release);\n+    }\n+\n+    /// Check if the io_uring context is initialized. If not, it will try to initialize it.\n+    pub(crate) fn check_and_init(&self) -> io::Result<bool> {\n+        match State::from_usize(self.uring_state.load(Ordering::Acquire)) {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2123891821",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7357,
        "pr_file": "tokio/src/runtime/io/driver/uring.rs",
        "discussion_id": "2123891821",
        "commented_code": "@@ -123,23 +182,70 @@ impl Drop for UringContext {\n \n impl Handle {\n     #[allow(dead_code)]\n-    pub(crate) fn add_uring_source(&self, interest: Interest) -> io::Result<()> {\n-        // setup for io_uring\n-        let uringfd = self.get_uring().lock().uring.as_raw_fd();\n+    fn add_uring_source(&self, uringfd: RawFd) -> io::Result<()> {\n         let mut source = SourceFd(&uringfd);\n         self.registry\n-            .register(&mut source, TOKEN_WAKEUP, interest.to_mio())\n+            .register(&mut source, TOKEN_WAKEUP, Interest::READABLE.to_mio())\n     }\n \n     pub(crate) fn get_uring(&self) -> &Mutex<UringContext> {\n         &self.uring_context\n     }\n \n+    fn set_uring_state(&self, state: State) {\n+        self.uring_state.store(state.as_usize(), Ordering::Release);\n+    }\n+\n+    /// Check if the io_uring context is initialized. If not, it will try to initialize it.\n+    pub(crate) fn check_and_init(&self) -> io::Result<bool> {\n+        match State::from_usize(self.uring_state.load(Ordering::Acquire)) {",
        "comment_created_at": "2025-06-03T13:51:04+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "nit: Just curious, what is the reason for caching `uring_state` at the runtime-level?",
        "pr_file_module": null
      },
      {
        "comment_id": "2126289429",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7357,
        "pr_file": "tokio/src/runtime/io/driver/uring.rs",
        "discussion_id": "2123891821",
        "commented_code": "@@ -123,23 +182,70 @@ impl Drop for UringContext {\n \n impl Handle {\n     #[allow(dead_code)]\n-    pub(crate) fn add_uring_source(&self, interest: Interest) -> io::Result<()> {\n-        // setup for io_uring\n-        let uringfd = self.get_uring().lock().uring.as_raw_fd();\n+    fn add_uring_source(&self, uringfd: RawFd) -> io::Result<()> {\n         let mut source = SourceFd(&uringfd);\n         self.registry\n-            .register(&mut source, TOKEN_WAKEUP, interest.to_mio())\n+            .register(&mut source, TOKEN_WAKEUP, Interest::READABLE.to_mio())\n     }\n \n     pub(crate) fn get_uring(&self) -> &Mutex<UringContext> {\n         &self.uring_context\n     }\n \n+    fn set_uring_state(&self, state: State) {\n+        self.uring_state.store(state.as_usize(), Ordering::Release);\n+    }\n+\n+    /// Check if the io_uring context is initialized. If not, it will try to initialize it.\n+    pub(crate) fn check_and_init(&self) -> io::Result<bool> {\n+        match State::from_usize(self.uring_state.load(Ordering::Acquire)) {",
        "comment_created_at": "2025-06-04T10:44:36+00:00",
        "comment_author": "mox692",
        "comment_body": "`State` keeps track of whether the uring driver has been initialized (`io_uring_setup`), and since the uring driver is tied to the runtime, cache is currently maintained for each runtime.",
        "pr_file_module": null
      },
      {
        "comment_id": "2126397176",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7357,
        "pr_file": "tokio/src/runtime/io/driver/uring.rs",
        "discussion_id": "2123891821",
        "commented_code": "@@ -123,23 +182,70 @@ impl Drop for UringContext {\n \n impl Handle {\n     #[allow(dead_code)]\n-    pub(crate) fn add_uring_source(&self, interest: Interest) -> io::Result<()> {\n-        // setup for io_uring\n-        let uringfd = self.get_uring().lock().uring.as_raw_fd();\n+    fn add_uring_source(&self, uringfd: RawFd) -> io::Result<()> {\n         let mut source = SourceFd(&uringfd);\n         self.registry\n-            .register(&mut source, TOKEN_WAKEUP, interest.to_mio())\n+            .register(&mut source, TOKEN_WAKEUP, Interest::READABLE.to_mio())\n     }\n \n     pub(crate) fn get_uring(&self) -> &Mutex<UringContext> {\n         &self.uring_context\n     }\n \n+    fn set_uring_state(&self, state: State) {\n+        self.uring_state.store(state.as_usize(), Ordering::Release);\n+    }\n+\n+    /// Check if the io_uring context is initialized. If not, it will try to initialize it.\n+    pub(crate) fn check_and_init(&self) -> io::Result<bool> {\n+        match State::from_usize(self.uring_state.load(Ordering::Acquire)) {",
        "comment_created_at": "2025-06-04T11:44:24+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "Not a blocker.\r\n\r\nAre there difficulties or overhead to initialize the io_uring while building the runtime?\r\n\r\nIt looks like the `check_and_init` will be called (by `register_op()` frequently, I'm concern about the performance overhead for loading atomic value in hot path.",
        "pr_file_module": null
      },
      {
        "comment_id": "2138513943",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7357,
        "pr_file": "tokio/src/runtime/io/driver/uring.rs",
        "discussion_id": "2123891821",
        "commented_code": "@@ -123,23 +182,70 @@ impl Drop for UringContext {\n \n impl Handle {\n     #[allow(dead_code)]\n-    pub(crate) fn add_uring_source(&self, interest: Interest) -> io::Result<()> {\n-        // setup for io_uring\n-        let uringfd = self.get_uring().lock().uring.as_raw_fd();\n+    fn add_uring_source(&self, uringfd: RawFd) -> io::Result<()> {\n         let mut source = SourceFd(&uringfd);\n         self.registry\n-            .register(&mut source, TOKEN_WAKEUP, interest.to_mio())\n+            .register(&mut source, TOKEN_WAKEUP, Interest::READABLE.to_mio())\n     }\n \n     pub(crate) fn get_uring(&self) -> &Mutex<UringContext> {\n         &self.uring_context\n     }\n \n+    fn set_uring_state(&self, state: State) {\n+        self.uring_state.store(state.as_usize(), Ordering::Release);\n+    }\n+\n+    /// Check if the io_uring context is initialized. If not, it will try to initialize it.\n+    pub(crate) fn check_and_init(&self) -> io::Result<bool> {\n+        match State::from_usize(self.uring_state.load(Ordering::Acquire)) {",
        "comment_created_at": "2025-06-10T18:13:46+00:00",
        "comment_author": "mox692",
        "comment_body": "> Are there difficulties or overhead to initialize the io_uring while building the runtime?\r\n\r\nNo, there aren't any major difficulties. I think lazy initialization of uring is not strictly required here, but it has the advantage of not having to perform extra syscalls when io_uring is not actually performed.\r\n\r\n\r\n> It looks like the\u00a0`check_and_init`\u00a0will be called (by\u00a0`register_op()`\u00a0frequently, I'm concern about the performance overhead for loading atomic value in hot path.\r\n\r\nAs long as we check if io_uring is supported at *runtime*, I think we can't remove this check. Also, I don't expect loading an atomic variable to have a huge performance impact.\r\n\r\nWe could also enforce io_uring usage at compile time and remove runtime check, but that has trade-offs too.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2039832812",
    "pr_number": 7249,
    "pr_file": "tokio/src/process/mod.rs",
    "created_at": "2025-04-11T15:49:53+00:00",
    "commented_code": "/// On Unix platforms this method will fail with `std::io::ErrorKind::WouldBlock`\n     /// if the system process limit is reached (which includes other applications\n     /// running on the system).\n+    #[inline]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        imp::spawn_child(&mut self.std).map(|spawned_child| Child {\n+        self.spawn_with_inner(StdCommand::spawn)\n+    }\n+\n+    /// Executes the command as a child process with a custom spawning function,\n+    /// returning a handle to it.\n+    ///\n+    /// This is identical to [`Self::spawn`] in every aspect except the spawn:\n+    /// here, it is customizable through the `with` parameter instead of\n+    /// defaulting to the usual spawn. In fact, [`Self::spawn`] is just\n+    /// [`Self::spawn_with`] with [`StdCommand::spawn`].\n+    ///\n+    /// This is useful mostly under Windows for now, since the platform exposes\n+    /// special APIs to configure child processes when spawning them with various\n+    /// attributes that customize the exact behavior of the spawn operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// # async fn test() { // allow using await\n+    /// use std::process::Stdio;\n+    ///\n+    /// let output = tokio::process::Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .stdout(Stdio::piped())\n+    ///         .stderr(Stdio::piped())\n+    ///         .spawn_with(std::process::Command::spawn)\n+    ///         .unwrap()\n+    ///         .wait_with_output()\n+    ///         .await\n+    ///         .unwrap();\n+    /// # }\n+    /// ```\n+    ///\n+    /// Actually customizing the spawn under Windows:\n+    ///\n+    /// ```ignore\n+    /// # #[cfg(windows)]   // Windows-only nightly APIs are used here.\n+    /// # async fn test() { // Allow using await.\n+    /// use std::os::windows::io::AsRawHandle;\n+    /// use std::os::windows::process::{CommandExt, ProcThreadAttributeList};\n+    /// use std::process::Stdio;\n+    /// use tokio::process::Command;\n+    ///\n+    /// let parent = Command::new(\"cmd\").spawn().unwrap();\n+    /// let parent_process_handle = parent.as_raw_handle();\n+    ///\n+    /// const PROC_THREAD_ATTRIBUTE_PARENT_PROCESS: usize = 0x00020000;\n+    /// let mut attribute_list = ProcThreadAttributeList::build()\n+    ///     .attribute(PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parent_process_handle)\n+    ///     .finish()\n+    ///     .unwrap();\n+    ///\n+    /// let output = Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .stdout(Stdio::piped())\n+    ///         .stderr(Stdio::piped())\n+    ///         .spawn_with(|cmd| cmd.spawn_with_attributes(&attribute_list))\n+    ///         .unwrap()\n+    ///         .wait_with_output()\n+    ///         .await\n+    ///         .unwrap();\n+    /// # }\n+    /// ```\n+    #[cfg(tokio_unstable)]\n+    #[inline]\n+    pub fn spawn_with(\n+        &mut self,\n+        with: impl Fn(&mut StdCommand) -> io::Result<StdChild>,\n+    ) -> io::Result<Child> {\n+        self.spawn_with_inner(with)\n+    }\n+\n+    /// Small indirection for the implementation of [`Self::spawn`] and\n+    /// [`Self::spawn_with`] to use: [`Self::spawn`] cannot depend directly on\n+    /// on [`Self::spawn_with`] since it is behind `tokio_unstable`.\n+    fn spawn_with_inner(\n+        &mut self,\n+        with: impl Fn(&mut StdCommand) -> io::Result<StdChild>,\n+    ) -> io::Result<Child> {\n+        imp::spawn_child_with(&mut self.std, with).map(|spawned_child| Child {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2039832812",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7249,
        "pr_file": "tokio/src/process/mod.rs",
        "discussion_id": "2039832812",
        "commented_code": "@@ -860,8 +860,90 @@ impl Command {\n     /// On Unix platforms this method will fail with `std::io::ErrorKind::WouldBlock`\n     /// if the system process limit is reached (which includes other applications\n     /// running on the system).\n+    #[inline]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        imp::spawn_child(&mut self.std).map(|spawned_child| Child {\n+        self.spawn_with_inner(StdCommand::spawn)\n+    }\n+\n+    /// Executes the command as a child process with a custom spawning function,\n+    /// returning a handle to it.\n+    ///\n+    /// This is identical to [`Self::spawn`] in every aspect except the spawn:\n+    /// here, it is customizable through the `with` parameter instead of\n+    /// defaulting to the usual spawn. In fact, [`Self::spawn`] is just\n+    /// [`Self::spawn_with`] with [`StdCommand::spawn`].\n+    ///\n+    /// This is useful mostly under Windows for now, since the platform exposes\n+    /// special APIs to configure child processes when spawning them with various\n+    /// attributes that customize the exact behavior of the spawn operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// # async fn test() { // allow using await\n+    /// use std::process::Stdio;\n+    ///\n+    /// let output = tokio::process::Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .stdout(Stdio::piped())\n+    ///         .stderr(Stdio::piped())\n+    ///         .spawn_with(std::process::Command::spawn)\n+    ///         .unwrap()\n+    ///         .wait_with_output()\n+    ///         .await\n+    ///         .unwrap();\n+    /// # }\n+    /// ```\n+    ///\n+    /// Actually customizing the spawn under Windows:\n+    ///\n+    /// ```ignore\n+    /// # #[cfg(windows)]   // Windows-only nightly APIs are used here.\n+    /// # async fn test() { // Allow using await.\n+    /// use std::os::windows::io::AsRawHandle;\n+    /// use std::os::windows::process::{CommandExt, ProcThreadAttributeList};\n+    /// use std::process::Stdio;\n+    /// use tokio::process::Command;\n+    ///\n+    /// let parent = Command::new(\"cmd\").spawn().unwrap();\n+    /// let parent_process_handle = parent.as_raw_handle();\n+    ///\n+    /// const PROC_THREAD_ATTRIBUTE_PARENT_PROCESS: usize = 0x00020000;\n+    /// let mut attribute_list = ProcThreadAttributeList::build()\n+    ///     .attribute(PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parent_process_handle)\n+    ///     .finish()\n+    ///     .unwrap();\n+    ///\n+    /// let output = Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .stdout(Stdio::piped())\n+    ///         .stderr(Stdio::piped())\n+    ///         .spawn_with(|cmd| cmd.spawn_with_attributes(&attribute_list))\n+    ///         .unwrap()\n+    ///         .wait_with_output()\n+    ///         .await\n+    ///         .unwrap();\n+    /// # }\n+    /// ```\n+    #[cfg(tokio_unstable)]\n+    #[inline]\n+    pub fn spawn_with(\n+        &mut self,\n+        with: impl Fn(&mut StdCommand) -> io::Result<StdChild>,\n+    ) -> io::Result<Child> {\n+        self.spawn_with_inner(with)\n+    }\n+\n+    /// Small indirection for the implementation of [`Self::spawn`] and\n+    /// [`Self::spawn_with`] to use: [`Self::spawn`] cannot depend directly on\n+    /// on [`Self::spawn_with`] since it is behind `tokio_unstable`.\n+    fn spawn_with_inner(\n+        &mut self,\n+        with: impl Fn(&mut StdCommand) -> io::Result<StdChild>,\n+    ) -> io::Result<Child> {\n+        imp::spawn_child_with(&mut self.std, with).map(|spawned_child| Child {",
        "comment_created_at": "2025-04-11T15:49:53+00:00",
        "comment_author": "ipetkov",
        "comment_body": "Might be worth also moving the body of `map` into a helper function to avoid the generics bloat",
        "pr_file_module": null
      },
      {
        "comment_id": "2040062299",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7249,
        "pr_file": "tokio/src/process/mod.rs",
        "discussion_id": "2039832812",
        "commented_code": "@@ -860,8 +860,90 @@ impl Command {\n     /// On Unix platforms this method will fail with `std::io::ErrorKind::WouldBlock`\n     /// if the system process limit is reached (which includes other applications\n     /// running on the system).\n+    #[inline]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        imp::spawn_child(&mut self.std).map(|spawned_child| Child {\n+        self.spawn_with_inner(StdCommand::spawn)\n+    }\n+\n+    /// Executes the command as a child process with a custom spawning function,\n+    /// returning a handle to it.\n+    ///\n+    /// This is identical to [`Self::spawn`] in every aspect except the spawn:\n+    /// here, it is customizable through the `with` parameter instead of\n+    /// defaulting to the usual spawn. In fact, [`Self::spawn`] is just\n+    /// [`Self::spawn_with`] with [`StdCommand::spawn`].\n+    ///\n+    /// This is useful mostly under Windows for now, since the platform exposes\n+    /// special APIs to configure child processes when spawning them with various\n+    /// attributes that customize the exact behavior of the spawn operation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// # async fn test() { // allow using await\n+    /// use std::process::Stdio;\n+    ///\n+    /// let output = tokio::process::Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .stdout(Stdio::piped())\n+    ///         .stderr(Stdio::piped())\n+    ///         .spawn_with(std::process::Command::spawn)\n+    ///         .unwrap()\n+    ///         .wait_with_output()\n+    ///         .await\n+    ///         .unwrap();\n+    /// # }\n+    /// ```\n+    ///\n+    /// Actually customizing the spawn under Windows:\n+    ///\n+    /// ```ignore\n+    /// # #[cfg(windows)]   // Windows-only nightly APIs are used here.\n+    /// # async fn test() { // Allow using await.\n+    /// use std::os::windows::io::AsRawHandle;\n+    /// use std::os::windows::process::{CommandExt, ProcThreadAttributeList};\n+    /// use std::process::Stdio;\n+    /// use tokio::process::Command;\n+    ///\n+    /// let parent = Command::new(\"cmd\").spawn().unwrap();\n+    /// let parent_process_handle = parent.as_raw_handle();\n+    ///\n+    /// const PROC_THREAD_ATTRIBUTE_PARENT_PROCESS: usize = 0x00020000;\n+    /// let mut attribute_list = ProcThreadAttributeList::build()\n+    ///     .attribute(PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parent_process_handle)\n+    ///     .finish()\n+    ///     .unwrap();\n+    ///\n+    /// let output = Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .stdout(Stdio::piped())\n+    ///         .stderr(Stdio::piped())\n+    ///         .spawn_with(|cmd| cmd.spawn_with_attributes(&attribute_list))\n+    ///         .unwrap()\n+    ///         .wait_with_output()\n+    ///         .await\n+    ///         .unwrap();\n+    /// # }\n+    /// ```\n+    #[cfg(tokio_unstable)]\n+    #[inline]\n+    pub fn spawn_with(\n+        &mut self,\n+        with: impl Fn(&mut StdCommand) -> io::Result<StdChild>,\n+    ) -> io::Result<Child> {\n+        self.spawn_with_inner(with)\n+    }\n+\n+    /// Small indirection for the implementation of [`Self::spawn`] and\n+    /// [`Self::spawn_with`] to use: [`Self::spawn`] cannot depend directly on\n+    /// on [`Self::spawn_with`] since it is behind `tokio_unstable`.\n+    fn spawn_with_inner(\n+        &mut self,\n+        with: impl Fn(&mut StdCommand) -> io::Result<StdChild>,\n+    ) -> io::Result<Child> {\n+        imp::spawn_child_with(&mut self.std, with).map(|spawned_child| Child {",
        "comment_created_at": "2025-04-11T18:06:18+00:00",
        "comment_author": "PaulDance",
        "comment_body": "I went ahead and removed the `map` entirely for safety with regards to monomorphization bloat here.",
        "pr_file_module": null
      }
    ]
  }
]