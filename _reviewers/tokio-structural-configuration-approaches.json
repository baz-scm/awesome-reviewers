[
  {
    "discussion_id": "2173665043",
    "pr_number": 7417,
    "pr_file": "tokio/src/runtime/task/list.rs",
    "created_at": "2025-06-29T09:08:02+00:00",
    "commented_code": "task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2173665043",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-29T09:08:02+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "Not a blocker.\r\n\r\nLet `cfg` modify the parameter list is not a common pattern in Rust, I think we need to explore a better approach.\r\n\r\nI don't think this issue blocks this PR, we could open another PR to simplify the implementation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175088661",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T13:30:10+00:00",
        "comment_author": "Darksonn",
        "comment_body": "My main feedback is also this. It may make sense to merge this into a struct with the id, or to wrap the location in something that can be zero-sized on stable, or to otherwise avoid conditional compilation everywhere this information is passed around.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175514775",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T16:53:17+00:00",
        "comment_author": "hawkw",
        "comment_body": "Yeah, I didn't love the `cfg` attributes on the parameter list either â€” it was why I didn't make storing the location conditional at all in my first draft. Wrapping it in a struct that's zero-sized when `tokio_unstable` is disabled is a good idea, I'll do that. Thanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "2175582862",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T17:38:33+00:00",
        "comment_author": "hawkw",
        "comment_body": "@Darksonn @ADD-SP what do you think of https://github.com/tokio-rs/tokio/pull/7417/commits/cf74e308b2ba3986b8fbd3a637cb43d97119bc8e? It did require adding `#[cfg(tokio_unstable)]` on the calls to the `spawn` hook, since they use the location which may now not be present if unstable isn't enabled. I felt like this was probably fine since the other hook functions are only called in cfg'd code anyway, but if that's an issue, I can change this to avoid that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175601384",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T17:50:06+00:00",
        "comment_author": "hawkw",
        "comment_body": "Oh nevermind, that didn't quite work; I put them back in https://github.com/tokio-rs/tokio/pull/7417/commits/e3a70e76f3466acf6e97f548b50fa6f611ecc03d.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2079989116",
    "pr_number": 7322,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2025-05-08T15:44:53+00:00",
    "commented_code": "Self::new_unstable(worker_metrics, now)\n     }\n \n+    #[cfg(target_family = \"wasm\")]\n+    pub(crate) fn new_for_wasm() -> MetricsBatch {\n+        Self::new_unstable_for_wasm()",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2079989116",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7322,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "2079989116",
        "commented_code": "@@ -71,13 +71,18 @@ impl MetricsBatch {\n         Self::new_unstable(worker_metrics, now)\n     }\n \n+    #[cfg(target_family = \"wasm\")]\n+    pub(crate) fn new_for_wasm() -> MetricsBatch {\n+        Self::new_unstable_for_wasm()",
        "comment_created_at": "2025-05-08T15:44:53+00:00",
        "comment_author": "rcoh",
        "comment_body": "what do you think instead about a function like:\r\n\r\n```\r\nfn now() -> Option<Instant> {\r\n  if cfg!(target_family = \"wasm\") { None } else { Instant::now() }\r\n}\r\n```\r\n\r\nThen use that everywhere that its needed? Since WASM can compile the `now` function, it just can't call it, I think this should more or less take care of it",
        "pr_file_module": null
      },
      {
        "comment_id": "2080105452",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7322,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "2079989116",
        "commented_code": "@@ -71,13 +71,18 @@ impl MetricsBatch {\n         Self::new_unstable(worker_metrics, now)\n     }\n \n+    #[cfg(target_family = \"wasm\")]\n+    pub(crate) fn new_for_wasm() -> MetricsBatch {\n+        Self::new_unstable_for_wasm()",
        "comment_created_at": "2025-05-08T16:54:49+00:00",
        "comment_author": "GJason88",
        "comment_body": "Good idea, I'm on board with that",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1840443167",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2024-11-13T14:38:15+00:00",
    "commented_code": "/// Instant at which work last resumed (continued after park).\n     processing_scheduled_tasks_started_at: Instant,\n \n+    #[cfg(tokio_unstable)]\n     /// If `Some`, tracks poll times in nanoseconds\n     poll_timer: Option<PollTimer>,\n }\n \n-struct PollTimer {\n-    /// Histogram of poll counts within each band.\n-    poll_counts: HistogramBatch,\n+cfg_unstable_metrics! {\n+    struct PollTimer {\n+        /// Histogram of poll counts within each band.\n+        poll_counts: HistogramBatch,\n \n-    /// Instant when the most recent task started polling.\n-    poll_started_at: Instant,\n+        /// Instant when the most recent task started polling.\n+        poll_started_at: Instant,\n+    }\n }\n \n impl MetricsBatch {\n-    pub(crate) fn new(worker_metrics: &WorkerMetrics) -> MetricsBatch {\n+    pub(crate) fn new(_worker_metrics: &WorkerMetrics) -> MetricsBatch {\n         let now = Instant::now();\n+        #[cfg(not(tokio_unstable))]\n+        {\n+            MetricsBatch {\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+            }\n+        }\n \n-        MetricsBatch {\n-            park_count: 0,\n-            park_unpark_count: 0,\n-            noop_count: 0,\n-            steal_count: 0,\n-            steal_operations: 0,\n-            poll_count: 0,\n-            poll_count_on_last_park: 0,\n-            local_schedule_count: 0,\n-            overflow_count: 0,\n-            busy_duration_total: 0,\n-            processing_scheduled_tasks_started_at: now,\n-            poll_timer: worker_metrics\n-                .poll_count_histogram\n-                .as_ref()\n-                .map(|worker_poll_counts| PollTimer {\n-                    poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n-                    poll_started_at: now,\n-                }),\n+        #[cfg(tokio_unstable)]\n+        {\n+            MetricsBatch {\n+                park_count: 0,\n+                park_unpark_count: 0,\n+                noop_count: 0,\n+                steal_count: 0,\n+                steal_operations: 0,\n+                poll_count: 0,\n+                poll_count_on_last_park: 0,\n+                local_schedule_count: 0,\n+                overflow_count: 0,\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+                poll_timer: _worker_metrics.poll_count_histogram.as_ref().map(\n+                    |worker_poll_counts| PollTimer {\n+                        poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n+                        poll_started_at: now,\n+                    },\n+                ),\n+            }\n         }\n     }\n \n-    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, mean_poll_time: u64) {\n-        worker.mean_poll_time.store(mean_poll_time, Relaxed);\n-        worker.park_count.store(self.park_count, Relaxed);\n-        worker\n-            .park_unpark_count\n-            .store(self.park_unpark_count, Relaxed);\n-        worker.noop_count.store(self.noop_count, Relaxed);\n-        worker.steal_count.store(self.steal_count, Relaxed);\n-        worker\n-            .steal_operations\n-            .store(self.steal_operations, Relaxed);\n-        worker.poll_count.store(self.poll_count, Relaxed);\n-\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {\n+        #[cfg(tokio_unstable)]\n+        {\n+            worker.mean_poll_time.store(_mean_poll_time, Relaxed);\n+            worker.park_count.store(self.park_count, Relaxed);\n+            worker\n+                .park_unpark_count\n+                .store(self.park_unpark_count, Relaxed);\n+            worker.noop_count.store(self.noop_count, Relaxed);\n+            worker.steal_count.store(self.steal_count, Relaxed);\n+            worker\n+                .steal_operations\n+                .store(self.steal_operations, Relaxed);\n+            worker.poll_count.store(self.poll_count, Relaxed);\n+\n+            worker\n+                .local_schedule_count\n+                .store(self.local_schedule_count, Relaxed);\n+            worker.overflow_count.store(self.overflow_count, Relaxed);\n+\n+            if let Some(poll_timer) = &self.poll_timer {\n+                let dst = worker.poll_count_histogram.as_ref().unwrap();\n+                poll_timer.poll_counts.submit(dst);\n+            }\n+        }\n         worker\n             .busy_duration_total\n             .store(self.busy_duration_total, Relaxed);\n-\n-        worker\n-            .local_schedule_count\n-            .store(self.local_schedule_count, Relaxed);\n-        worker.overflow_count.store(self.overflow_count, Relaxed);\n-\n-        if let Some(poll_timer) = &self.poll_timer {\n-            let dst = worker.poll_count_histogram.as_ref().unwrap();\n-            poll_timer.poll_counts.submit(dst);\n-        }\n     }\n \n     /// The worker is about to park.\n     pub(crate) fn about_to_park(&mut self) {\n-        self.park_count += 1;\n-        self.park_unpark_count += 1;\n-\n-        if self.poll_count_on_last_park == self.poll_count {\n-            self.noop_count += 1;\n-        } else {\n-            self.poll_count_on_last_park = self.poll_count;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_count += 1;\n+            self.park_unpark_count += 1;\n+\n+            if self.poll_count_on_last_park == self.poll_count {\n+                self.noop_count += 1;\n+            } else {\n+                self.poll_count_on_last_park = self.poll_count;\n+            }\n         }\n     }\n \n     /// The worker was unparked.\n     pub(crate) fn unparked(&mut self) {\n-        self.park_unpark_count += 1;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_unpark_count += 1;\n+        }\n     }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1840443167",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1840443167",
        "commented_code": "@@ -39,87 +52,107 @@ pub(crate) struct MetricsBatch {\n     /// Instant at which work last resumed (continued after park).\n     processing_scheduled_tasks_started_at: Instant,\n \n+    #[cfg(tokio_unstable)]\n     /// If `Some`, tracks poll times in nanoseconds\n     poll_timer: Option<PollTimer>,\n }\n \n-struct PollTimer {\n-    /// Histogram of poll counts within each band.\n-    poll_counts: HistogramBatch,\n+cfg_unstable_metrics! {\n+    struct PollTimer {\n+        /// Histogram of poll counts within each band.\n+        poll_counts: HistogramBatch,\n \n-    /// Instant when the most recent task started polling.\n-    poll_started_at: Instant,\n+        /// Instant when the most recent task started polling.\n+        poll_started_at: Instant,\n+    }\n }\n \n impl MetricsBatch {\n-    pub(crate) fn new(worker_metrics: &WorkerMetrics) -> MetricsBatch {\n+    pub(crate) fn new(_worker_metrics: &WorkerMetrics) -> MetricsBatch {\n         let now = Instant::now();\n+        #[cfg(not(tokio_unstable))]\n+        {\n+            MetricsBatch {\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+            }\n+        }\n \n-        MetricsBatch {\n-            park_count: 0,\n-            park_unpark_count: 0,\n-            noop_count: 0,\n-            steal_count: 0,\n-            steal_operations: 0,\n-            poll_count: 0,\n-            poll_count_on_last_park: 0,\n-            local_schedule_count: 0,\n-            overflow_count: 0,\n-            busy_duration_total: 0,\n-            processing_scheduled_tasks_started_at: now,\n-            poll_timer: worker_metrics\n-                .poll_count_histogram\n-                .as_ref()\n-                .map(|worker_poll_counts| PollTimer {\n-                    poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n-                    poll_started_at: now,\n-                }),\n+        #[cfg(tokio_unstable)]\n+        {\n+            MetricsBatch {\n+                park_count: 0,\n+                park_unpark_count: 0,\n+                noop_count: 0,\n+                steal_count: 0,\n+                steal_operations: 0,\n+                poll_count: 0,\n+                poll_count_on_last_park: 0,\n+                local_schedule_count: 0,\n+                overflow_count: 0,\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+                poll_timer: _worker_metrics.poll_count_histogram.as_ref().map(\n+                    |worker_poll_counts| PollTimer {\n+                        poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n+                        poll_started_at: now,\n+                    },\n+                ),\n+            }\n         }\n     }\n \n-    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, mean_poll_time: u64) {\n-        worker.mean_poll_time.store(mean_poll_time, Relaxed);\n-        worker.park_count.store(self.park_count, Relaxed);\n-        worker\n-            .park_unpark_count\n-            .store(self.park_unpark_count, Relaxed);\n-        worker.noop_count.store(self.noop_count, Relaxed);\n-        worker.steal_count.store(self.steal_count, Relaxed);\n-        worker\n-            .steal_operations\n-            .store(self.steal_operations, Relaxed);\n-        worker.poll_count.store(self.poll_count, Relaxed);\n-\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {\n+        #[cfg(tokio_unstable)]\n+        {\n+            worker.mean_poll_time.store(_mean_poll_time, Relaxed);\n+            worker.park_count.store(self.park_count, Relaxed);\n+            worker\n+                .park_unpark_count\n+                .store(self.park_unpark_count, Relaxed);\n+            worker.noop_count.store(self.noop_count, Relaxed);\n+            worker.steal_count.store(self.steal_count, Relaxed);\n+            worker\n+                .steal_operations\n+                .store(self.steal_operations, Relaxed);\n+            worker.poll_count.store(self.poll_count, Relaxed);\n+\n+            worker\n+                .local_schedule_count\n+                .store(self.local_schedule_count, Relaxed);\n+            worker.overflow_count.store(self.overflow_count, Relaxed);\n+\n+            if let Some(poll_timer) = &self.poll_timer {\n+                let dst = worker.poll_count_histogram.as_ref().unwrap();\n+                poll_timer.poll_counts.submit(dst);\n+            }\n+        }\n         worker\n             .busy_duration_total\n             .store(self.busy_duration_total, Relaxed);\n-\n-        worker\n-            .local_schedule_count\n-            .store(self.local_schedule_count, Relaxed);\n-        worker.overflow_count.store(self.overflow_count, Relaxed);\n-\n-        if let Some(poll_timer) = &self.poll_timer {\n-            let dst = worker.poll_count_histogram.as_ref().unwrap();\n-            poll_timer.poll_counts.submit(dst);\n-        }\n     }\n \n     /// The worker is about to park.\n     pub(crate) fn about_to_park(&mut self) {\n-        self.park_count += 1;\n-        self.park_unpark_count += 1;\n-\n-        if self.poll_count_on_last_park == self.poll_count {\n-            self.noop_count += 1;\n-        } else {\n-            self.poll_count_on_last_park = self.poll_count;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_count += 1;\n+            self.park_unpark_count += 1;\n+\n+            if self.poll_count_on_last_park == self.poll_count {\n+                self.noop_count += 1;\n+            } else {\n+                self.poll_count_on_last_park = self.poll_count;\n+            }\n         }\n     }\n \n     /// The worker was unparked.\n     pub(crate) fn unparked(&mut self) {\n-        self.park_unpark_count += 1;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_unpark_count += 1;\n+        }\n     }",
        "comment_created_at": "2024-11-13T14:38:15+00:00",
        "comment_author": "hds",
        "comment_body": "In the rest of the Tokio code base, we do this a different way, so let's stick to that convension. Instead of gating functionality within a function, we have a separate empty function definition when the cfg flag isn't enabled. So this function would become:\r\n\r\n```rust\r\ncfg_unstable_metrics! {\r\n    /// The worker was unparked.\r\n    pub(crate) fn unparked(&mut self) {\r\n        self.park_unpark_count += 1;\r\n    }\r\n}\r\n\r\ncfg_not_unstable_metrics! {\r\n    /// The worker was unparked.\r\n    pub(crate) fn unparked(&mut self) {}\r\n}\r\n```\r\n\r\nPlease do the same here. Keep a single `cfg_unstable_metrics` block (and a single `cfg_not_unstable_metrics` block) for all the functions that require this behavior, so that they're grouped together.\r\n\r\nFor the more complex functions above that have a mix of stablized and unstablized implementation, split the unstablized part out into a separate function with an impl in each of the macro blocks (see example in the comment on `submit`).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1902127491",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2025-01-03T20:08:50+00:00",
    "commented_code": "self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1902127491",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902127491",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }",
        "comment_created_at": "2025-01-03T20:08:50+00:00",
        "comment_author": "rcoh",
        "comment_body": "reading through this, I wonder if we should make a macro specifically for this pattern, something like:\r\n\r\n```\r\ncfg_metrics! {\r\n  stable: {\r\n     ...\r\n   },\r\n   unstable: { ... }\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1902127803",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902127491",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }",
        "comment_created_at": "2025-01-03T20:09:18+00:00",
        "comment_author": "rcoh",
        "comment_body": "if we are going to have a lot of a/b code when metrics or stable or not, could be helpful to avoid bugs",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1902128590",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2025-01-03T20:10:24+00:00",
    "commented_code": "self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }\n \n-    /// Stop polling an individual task\n-    pub(crate) fn end_poll(&mut self) {\n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n-            poll_timer.poll_counts.measure(elapsed, 1);\n+    cfg_not_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {}\n+    }\n+\n+    cfg_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {\n+            self.local_schedule_count += 1;\n         }\n     }\n \n-    pub(crate) fn inc_local_schedule_count(&mut self) {\n-        self.local_schedule_count += 1;\n+    cfg_not_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {}\n     }\n }\n \n cfg_rt_multi_thread! {\n     impl MetricsBatch {\n-        pub(crate) fn incr_steal_count(&mut self, by: u16) {\n-            self.steal_count += by as u64;\n+        pub(crate) fn incr_steal_count(&mut self, _by: u16) {\n+            #[cfg(tokio_unstable)] {\n+                self.steal_count += _by as u64;\n+            }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1902128590",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902128590",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }\n \n-    /// Stop polling an individual task\n-    pub(crate) fn end_poll(&mut self) {\n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n-            poll_timer.poll_counts.measure(elapsed, 1);\n+    cfg_not_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {}\n+    }\n+\n+    cfg_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {\n+            self.local_schedule_count += 1;\n         }\n     }\n \n-    pub(crate) fn inc_local_schedule_count(&mut self) {\n-        self.local_schedule_count += 1;\n+    cfg_not_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {}\n     }\n }\n \n cfg_rt_multi_thread! {\n     impl MetricsBatch {\n-        pub(crate) fn incr_steal_count(&mut self, by: u16) {\n-            self.steal_count += by as u64;\n+        pub(crate) fn incr_steal_count(&mut self, _by: u16) {\n+            #[cfg(tokio_unstable)] {\n+                self.steal_count += _by as u64;\n+            }",
        "comment_created_at": "2025-01-03T20:10:24+00:00",
        "comment_author": "rcoh",
        "comment_body": "I think we should probably pick a patternâ€”either cfg-ing the body of the function or the function entirely instead of using both",
        "pr_file_module": null
      },
      {
        "comment_id": "1911962262",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902128590",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }\n \n-    /// Stop polling an individual task\n-    pub(crate) fn end_poll(&mut self) {\n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n-            poll_timer.poll_counts.measure(elapsed, 1);\n+    cfg_not_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {}\n+    }\n+\n+    cfg_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {\n+            self.local_schedule_count += 1;\n         }\n     }\n \n-    pub(crate) fn inc_local_schedule_count(&mut self) {\n-        self.local_schedule_count += 1;\n+    cfg_not_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {}\n     }\n }\n \n cfg_rt_multi_thread! {\n     impl MetricsBatch {\n-        pub(crate) fn incr_steal_count(&mut self, by: u16) {\n-            self.steal_count += by as u64;\n+        pub(crate) fn incr_steal_count(&mut self, _by: u16) {\n+            #[cfg(tokio_unstable)] {\n+                self.steal_count += _by as u64;\n+            }",
        "comment_created_at": "2025-01-11T10:40:06+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Thanks @rcoh . I've added a new macro and put all the ab code implementation into this macro. I also recorganize fields so that stable fields come first. Please can I have your review again ? Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1622905177",
    "pr_number": 6598,
    "pr_file": "tokio/src/util/metric_atomics.rs",
    "created_at": "2024-05-31T20:07:09+00:00",
    "commented_code": "pub(crate) fn new(_value: u64) -> Self { Self { } }\n     }\n }\n+\n+cfg_rt! {\n+    /// `AtomicUsize` for use in metrics.\n+    ///\n+    /// This exposes simplified APIs for use in metrics & uses `std::sync` instead of Loom to avoid polluting loom logs with metric information.\n+    #[derive(Debug, Default)]\n+    pub(crate) struct MetricAtomicUsize {\n+        value: std::sync::atomic::AtomicUsize,\n+    }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1622905177",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6598,
        "pr_file": "tokio/src/util/metric_atomics.rs",
        "discussion_id": "1622905177",
        "commented_code": "@@ -45,3 +45,32 @@ impl MetricAtomicU64 {\n         pub(crate) fn new(_value: u64) -> Self { Self { } }\n     }\n }\n+\n+cfg_rt! {\n+    /// `AtomicUsize` for use in metrics.\n+    ///\n+    /// This exposes simplified APIs for use in metrics & uses `std::sync` instead of Loom to avoid polluting loom logs with metric information.\n+    #[derive(Debug, Default)]\n+    pub(crate) struct MetricAtomicUsize {\n+        value: std::sync::atomic::AtomicUsize,\n+    }",
        "comment_created_at": "2024-05-31T20:07:09+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Does this need to be gated on `cfg_rt!`? Is the file not already gated on that?",
        "pr_file_module": null
      },
      {
        "comment_id": "1622918917",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6598,
        "pr_file": "tokio/src/util/metric_atomics.rs",
        "discussion_id": "1622905177",
        "commented_code": "@@ -45,3 +45,32 @@ impl MetricAtomicU64 {\n         pub(crate) fn new(_value: u64) -> Self { Self { } }\n     }\n }\n+\n+cfg_rt! {\n+    /// `AtomicUsize` for use in metrics.\n+    ///\n+    /// This exposes simplified APIs for use in metrics & uses `std::sync` instead of Loom to avoid polluting loom logs with metric information.\n+    #[derive(Debug, Default)]\n+    pub(crate) struct MetricAtomicUsize {\n+        value: std::sync::atomic::AtomicUsize,\n+    }",
        "comment_created_at": "2024-05-31T20:22:39+00:00",
        "comment_author": "rcoh",
        "comment_body": "these are only used from the `rt` module (by coincidence, the other metrics are all u64) so I gated on rt to avoid dead code warnings.",
        "pr_file_module": null
      },
      {
        "comment_id": "1623182721",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6598,
        "pr_file": "tokio/src/util/metric_atomics.rs",
        "discussion_id": "1622905177",
        "commented_code": "@@ -45,3 +45,32 @@ impl MetricAtomicU64 {\n         pub(crate) fn new(_value: u64) -> Self { Self { } }\n     }\n }\n+\n+cfg_rt! {\n+    /// `AtomicUsize` for use in metrics.\n+    ///\n+    /// This exposes simplified APIs for use in metrics & uses `std::sync` instead of Loom to avoid polluting loom logs with metric information.\n+    #[derive(Debug, Default)]\n+    pub(crate) struct MetricAtomicUsize {\n+        value: std::sync::atomic::AtomicUsize,\n+    }",
        "comment_created_at": "2024-06-01T08:49:08+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Can you add an `#[cfg_attr(not(feature = \"rt\"), allow(dead_code))]` on the module instead? The `cfg_rt!` blocks break rustfmt, so I try to avoid wrapping large blocks in them.",
        "pr_file_module": null
      },
      {
        "comment_id": "1623182777",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6598,
        "pr_file": "tokio/src/util/metric_atomics.rs",
        "discussion_id": "1622905177",
        "commented_code": "@@ -45,3 +45,32 @@ impl MetricAtomicU64 {\n         pub(crate) fn new(_value: u64) -> Self { Self { } }\n     }\n }\n+\n+cfg_rt! {\n+    /// `AtomicUsize` for use in metrics.\n+    ///\n+    /// This exposes simplified APIs for use in metrics & uses `std::sync` instead of Loom to avoid polluting loom logs with metric information.\n+    #[derive(Debug, Default)]\n+    pub(crate) struct MetricAtomicUsize {\n+        value: std::sync::atomic::AtomicUsize,\n+    }",
        "comment_created_at": "2024-06-01T08:49:44+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Or maybe it'd be better to split the file into two and wrap the `mod` statement in `cfg_rt!`.",
        "pr_file_module": null
      }
    ]
  }
]