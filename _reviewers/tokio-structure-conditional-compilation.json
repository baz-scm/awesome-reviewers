[
  {
    "discussion_id": "2173665043",
    "pr_number": 7417,
    "pr_file": "tokio/src/runtime/task/list.rs",
    "created_at": "2025-06-29T09:08:02+00:00",
    "commented_code": "task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2173665043",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-29T09:08:02+00:00",
        "comment_author": "ADD-SP",
        "comment_body": "Not a blocker.\r\n\r\nLet `cfg` modify the parameter list is not a common pattern in Rust, I think we need to explore a better approach.\r\n\r\nI don't think this issue blocks this PR, we could open another PR to simplify the implementation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175088661",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T13:30:10+00:00",
        "comment_author": "Darksonn",
        "comment_body": "My main feedback is also this. It may make sense to merge this into a struct with the id, or to wrap the location in something that can be zero-sized on stable, or to otherwise avoid conditional compilation everywhere this information is passed around.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175514775",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T16:53:17+00:00",
        "comment_author": "hawkw",
        "comment_body": "Yeah, I didn't love the `cfg` attributes on the parameter list either â€” it was why I didn't make storing the location conditional at all in my first draft. Wrapping it in a struct that's zero-sized when `tokio_unstable` is disabled is a good idea, I'll do that. Thanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "2175582862",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T17:38:33+00:00",
        "comment_author": "hawkw",
        "comment_body": "@Darksonn @ADD-SP what do you think of https://github.com/tokio-rs/tokio/pull/7417/commits/cf74e308b2ba3986b8fbd3a637cb43d97119bc8e? It did require adding `#[cfg(tokio_unstable)]` on the calls to the `spawn` hook, since they use the location which may now not be present if unstable isn't enabled. I felt like this was probably fine since the other hook functions are only called in cfg'd code anyway, but if that's an issue, I can change this to avoid that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175601384",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7417,
        "pr_file": "tokio/src/runtime/task/list.rs",
        "discussion_id": "2173665043",
        "commented_code": "@@ -91,13 +93,20 @@ impl<S: 'static> OwnedTasks<S> {\n         task: T,\n         scheduler: S,\n         id: super::Id,\n+        #[cfg(tokio_unstable)] spawned_at: &'static Location<'static>,",
        "comment_created_at": "2025-06-30T17:50:06+00:00",
        "comment_author": "hawkw",
        "comment_body": "Oh nevermind, that didn't quite work; I put them back in https://github.com/tokio-rs/tokio/pull/7417/commits/e3a70e76f3466acf6e97f548b50fa6f611ecc03d.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1796962948",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/histogram.rs",
    "created_at": "2024-10-11T13:30:36+00:00",
    "commented_code": "resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1796962948",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-11T13:30:36+00:00",
        "comment_author": "rcoh",
        "comment_body": "is this change required for the mean time stabilization or just a coincidental change?",
        "pr_file_module": null
      },
      {
        "comment_id": "1797015607",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-11T14:08:46+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "I believe this change is required.\r\n\r\nAt master we have implemented another `struct WorkerMetrics` at `tokio/src/runtime/metrics/mock.rs` which didn't use `struct Histogram` defined at `tokio/src/runtime/metrics/histogram.rs`. \r\n\r\nIn order to stabilize the API, I have to removed this mock WorkerMetrics and instead point to the \"real\" `WorkerMetrics` at `tokio/src/runtime/metrics/worker.rs`\r\n\r\nThe \"real\" `WorkerMetrics` has a field `poll_count_histogram` which is `Option<Histogram>`, and thus will attempt to parse `tokio/src/runtime/metrics/histogram.rs`. From there, you can see Histogram and HistogramBuilder both refers to `HistogramScale` which is hidden inside `tokio_unstable`. I think this wouldn't compile. \r\n\r\n(I might be wrong though so feel free to correct me)\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1797731450",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-12T16:52:48+00:00",
        "comment_author": "hds",
        "comment_body": "I need to read through this PR in more detail so bare with me, but we shouldn't be making this stable and public if it isn't actually needed to to stabilize `worker_total_busy_duration` (and I'm mostly sure that it isn't).\r\n\r\nIn general, all the `#[allow(dead_code)]` that are required for this chnage give me the impression that we're exposing something that is only really used in `tokio_unstable` and so we should find a way to expose it only unstable `tokio_unstable`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1797993751",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-13T03:44:02+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Thanks for your comment!\r\n\r\nI think the core issue here is that by exposing `worker_total_busy_duration`, we are also exposing the \"real\" `WorkerMetrics` at `tokio/src/runtime/metrics/worker.rs`, which in turn will attempt to parse `HistogramScale`.\r\n\r\nCurrently at master branch, when no `tokio_unstable` flag is passed in, the `WorkerMetrics` at `tokio/src/runtime/metrics/mock.rs` will be parsed (which is just an empty struct). And if the flag is passed in, the `WorkerMetrics` at `tokio/src/runtime/metrics/worker.rs` will be parsed\r\n\r\nhttps://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/metrics/mod.rs#L27-L40\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1799550622",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-14T13:49:46+00:00",
        "comment_author": "rcoh",
        "comment_body": "it's not actually public, it's still behind config_unstable. (Just verified via the autogenerated docs)",
        "pr_file_module": null
      },
      {
        "comment_id": "1799606233",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-14T14:20:40+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Yeah becoz `HistogramScale` is still behind `cfg_unstable_metrics`:\r\n\r\nhttps://github.com/tokio-rs/tokio/pull/6899/files#diff-15ebfca6124144b3cffd9845fa3ce5596c342ce94d84dd406ee84f856db4c66cR23-R25 \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1800766205",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-15T09:14:27+00:00",
        "comment_author": "hds",
        "comment_body": "OK, now I believe I understand.\r\n\r\nI would suggest that instead of compiling with the entire worker metrics in order to access only the `busy_duration_total` field, we should gate all the fields that we won't be using on `cfg_unstable_metrics`. Otherwise users will still be paying the price for metrics which they don't have access to - and that is something that we would really like to avoid.\r\n\r\nHave a look at the runtime Builder for an example of how we have fields and implementations that touch them gated on a cfg flag:\r\n\r\nhttps://github.com/tokio-rs/tokio/blob/512e9decfb683d22f4a145459142542caa0894c9/tokio/src/runtime/builder.rs#L125-L126\r\n\r\nAs a general rule, if you need `#[allow(dead_code)]` then there is probably something that should be gated on a cfg flag instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "1803338854",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-16T15:25:13+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Thanks @hds . I've reverted changes to `histogram.rs`. Also the real `Histogram`, `HistogramBuilder` and `HistogramBatch` are gated behind unstable flag now, and instead I've created a mocked version of these for compilation. \r\n\r\nFor `WorkerMetrics`,  as we target to stabilize more metrics, I'd suggest exposing all fields instead of stabilizing only `busy_duration_total` and putting other fields behind unstable.\r\n\r\nLet me know what you think ",
        "pr_file_module": null
      },
      {
        "comment_id": "1803420659",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-16T16:10:40+00:00",
        "comment_author": "hds",
        "comment_body": "@Owen-CH-Leung the problem with stabilizing all of `WorkerMetrics` is that when `tokio_unstable` is **not** enabled, the runtime will pay the price for all those metrics, but there will be no way to access them. For this reason I think that it would be better to only stabilize what we're exposing.",
        "pr_file_module": null
      },
      {
        "comment_id": "1807205024",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1796962948",
        "commented_code": "@@ -35,31 +35,34 @@ pub(crate) struct HistogramBatch {\n     resolution: u64,\n }\n \n-cfg_unstable! {\n-    /// Whether the histogram used to aggregate a metric uses a linear or\n-    /// logarithmic scale.\n-    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-    #[non_exhaustive]\n-    pub enum HistogramScale {\n-        /// Linear bucket scale\n-        Linear,\n-\n-        /// Logarithmic bucket scale\n-        Log,\n-    }\n+/// Whether the histogram used to aggregate a metric uses a linear or\n+/// logarithmic scale.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[non_exhaustive]\n+#[allow(unreachable_pub)]\n+pub enum HistogramScale {\n+    /// Linear bucket scale\n+    Linear,\n+\n+    /// Logarithmic bucket scale\n+    #[allow(dead_code)]",
        "comment_created_at": "2024-10-19T06:24:37+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Thanks @hds . I've made changes to hide most of the fields of `WorkerMetrics` behind unstable flag, except for `busy_duration_total`, `queue_depth` and `thread_id`. The latter 2 fields are needed in order for `set_queue_depth` and `set_thread_id` to work properly.\r\n\r\nI've also enriched the mock `MetricsBatch` to have minimal implementation of `batch::MetricsBatch` so that the `worker_total_busy_duration` API can function properly under stable build\r\n\r\nLet me know your thoughts!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1808921004",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/mock.rs",
    "created_at": "2024-10-21T14:19:49+00:00",
    "commented_code": "pub(crate) fn inc_remote_schedule_count(&self) {}\n }\n \n-impl WorkerMetrics {\n-    pub(crate) fn new() -> Self {\n-        Self {}\n-    }\n-\n-    pub(crate) fn from_config(config: &crate::runtime::Config) -> Self {\n-        // Prevent the dead-code warning from being triggered\n-        let _ = &config.metrics_poll_count_histogram;\n-        Self::new()\n-    }\n-\n-    pub(crate) fn set_queue_depth(&self, _len: usize) {}\n-    pub(crate) fn set_thread_id(&self, _thread_id: ThreadId) {}\n-}\n-\n impl MetricsBatch {\n     pub(crate) fn new(_: &WorkerMetrics) -> Self {\n-        Self {}\n+        let now = Instant::now();\n+\n+        MetricsBatch {\n+            busy_duration_total: 0,\n+            processing_scheduled_tasks_started_at: now,\n+        }\n     }\n \n-    pub(crate) fn submit(&mut self, _to: &WorkerMetrics, _mean_poll_time: u64) {}\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1808921004",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/mock.rs",
        "discussion_id": "1808921004",
        "commented_code": "@@ -20,32 +39,31 @@ impl SchedulerMetrics {\n     pub(crate) fn inc_remote_schedule_count(&self) {}\n }\n \n-impl WorkerMetrics {\n-    pub(crate) fn new() -> Self {\n-        Self {}\n-    }\n-\n-    pub(crate) fn from_config(config: &crate::runtime::Config) -> Self {\n-        // Prevent the dead-code warning from being triggered\n-        let _ = &config.metrics_poll_count_histogram;\n-        Self::new()\n-    }\n-\n-    pub(crate) fn set_queue_depth(&self, _len: usize) {}\n-    pub(crate) fn set_thread_id(&self, _thread_id: ThreadId) {}\n-}\n-\n impl MetricsBatch {\n     pub(crate) fn new(_: &WorkerMetrics) -> Self {\n-        Self {}\n+        let now = Instant::now();\n+\n+        MetricsBatch {\n+            busy_duration_total: 0,\n+            processing_scheduled_tasks_started_at: now,\n+        }\n     }\n \n-    pub(crate) fn submit(&mut self, _to: &WorkerMetrics, _mean_poll_time: u64) {}\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {",
        "comment_created_at": "2024-10-21T14:19:49+00:00",
        "comment_author": "hds",
        "comment_body": "Do I understand correctly that this function duplicates part of the `submit` function in `batch::MetricsBatch`?\r\n\r\nI think this is a problematic way of gradually stabilizing metrics, as it opens the possibility of having divirging implementations if a change is made to the \"real\" `MetricsBatch` by someone who doesn't realise that there is another one.\r\n\r\nThis is additionally confusing because this effectively becomes the \"stable\" implementation, but it lives in a module called `mock`.\r\n\r\nI would propose that we instead split the `metrics::MetricsBatch` implementation into stable (always compiles) and unstable (gated by `cfg` option), the same way we've done elsewhere in this PR. The same as with another comment, we would group all the unstable functions into a single `cfg_unstable_metrics!` block.",
        "pr_file_module": null
      },
      {
        "comment_id": "1810593189",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/mock.rs",
        "discussion_id": "1808921004",
        "commented_code": "@@ -20,32 +39,31 @@ impl SchedulerMetrics {\n     pub(crate) fn inc_remote_schedule_count(&self) {}\n }\n \n-impl WorkerMetrics {\n-    pub(crate) fn new() -> Self {\n-        Self {}\n-    }\n-\n-    pub(crate) fn from_config(config: &crate::runtime::Config) -> Self {\n-        // Prevent the dead-code warning from being triggered\n-        let _ = &config.metrics_poll_count_histogram;\n-        Self::new()\n-    }\n-\n-    pub(crate) fn set_queue_depth(&self, _len: usize) {}\n-    pub(crate) fn set_thread_id(&self, _thread_id: ThreadId) {}\n-}\n-\n impl MetricsBatch {\n     pub(crate) fn new(_: &WorkerMetrics) -> Self {\n-        Self {}\n+        let now = Instant::now();\n+\n+        MetricsBatch {\n+            busy_duration_total: 0,\n+            processing_scheduled_tasks_started_at: now,\n+        }\n     }\n \n-    pub(crate) fn submit(&mut self, _to: &WorkerMetrics, _mean_poll_time: u64) {}\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {",
        "comment_created_at": "2024-10-22T12:01:54+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Indeed spliting `metrics::MetricsBatch` is a much viable way of stabilising. I've adopted your suggestion and split it into stable & unstable (and group unstable functions into a single unstable block. Thanks a lot for reviewing!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1840443167",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2024-11-13T14:38:15+00:00",
    "commented_code": "/// Instant at which work last resumed (continued after park).\n     processing_scheduled_tasks_started_at: Instant,\n \n+    #[cfg(tokio_unstable)]\n     /// If `Some`, tracks poll times in nanoseconds\n     poll_timer: Option<PollTimer>,\n }\n \n-struct PollTimer {\n-    /// Histogram of poll counts within each band.\n-    poll_counts: HistogramBatch,\n+cfg_unstable_metrics! {\n+    struct PollTimer {\n+        /// Histogram of poll counts within each band.\n+        poll_counts: HistogramBatch,\n \n-    /// Instant when the most recent task started polling.\n-    poll_started_at: Instant,\n+        /// Instant when the most recent task started polling.\n+        poll_started_at: Instant,\n+    }\n }\n \n impl MetricsBatch {\n-    pub(crate) fn new(worker_metrics: &WorkerMetrics) -> MetricsBatch {\n+    pub(crate) fn new(_worker_metrics: &WorkerMetrics) -> MetricsBatch {\n         let now = Instant::now();\n+        #[cfg(not(tokio_unstable))]\n+        {\n+            MetricsBatch {\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+            }\n+        }\n \n-        MetricsBatch {\n-            park_count: 0,\n-            park_unpark_count: 0,\n-            noop_count: 0,\n-            steal_count: 0,\n-            steal_operations: 0,\n-            poll_count: 0,\n-            poll_count_on_last_park: 0,\n-            local_schedule_count: 0,\n-            overflow_count: 0,\n-            busy_duration_total: 0,\n-            processing_scheduled_tasks_started_at: now,\n-            poll_timer: worker_metrics\n-                .poll_count_histogram\n-                .as_ref()\n-                .map(|worker_poll_counts| PollTimer {\n-                    poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n-                    poll_started_at: now,\n-                }),\n+        #[cfg(tokio_unstable)]\n+        {\n+            MetricsBatch {\n+                park_count: 0,\n+                park_unpark_count: 0,\n+                noop_count: 0,\n+                steal_count: 0,\n+                steal_operations: 0,\n+                poll_count: 0,\n+                poll_count_on_last_park: 0,\n+                local_schedule_count: 0,\n+                overflow_count: 0,\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+                poll_timer: _worker_metrics.poll_count_histogram.as_ref().map(\n+                    |worker_poll_counts| PollTimer {\n+                        poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n+                        poll_started_at: now,\n+                    },\n+                ),\n+            }\n         }\n     }\n \n-    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, mean_poll_time: u64) {\n-        worker.mean_poll_time.store(mean_poll_time, Relaxed);\n-        worker.park_count.store(self.park_count, Relaxed);\n-        worker\n-            .park_unpark_count\n-            .store(self.park_unpark_count, Relaxed);\n-        worker.noop_count.store(self.noop_count, Relaxed);\n-        worker.steal_count.store(self.steal_count, Relaxed);\n-        worker\n-            .steal_operations\n-            .store(self.steal_operations, Relaxed);\n-        worker.poll_count.store(self.poll_count, Relaxed);\n-\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {\n+        #[cfg(tokio_unstable)]\n+        {\n+            worker.mean_poll_time.store(_mean_poll_time, Relaxed);\n+            worker.park_count.store(self.park_count, Relaxed);\n+            worker\n+                .park_unpark_count\n+                .store(self.park_unpark_count, Relaxed);\n+            worker.noop_count.store(self.noop_count, Relaxed);\n+            worker.steal_count.store(self.steal_count, Relaxed);\n+            worker\n+                .steal_operations\n+                .store(self.steal_operations, Relaxed);\n+            worker.poll_count.store(self.poll_count, Relaxed);\n+\n+            worker\n+                .local_schedule_count\n+                .store(self.local_schedule_count, Relaxed);\n+            worker.overflow_count.store(self.overflow_count, Relaxed);\n+\n+            if let Some(poll_timer) = &self.poll_timer {\n+                let dst = worker.poll_count_histogram.as_ref().unwrap();\n+                poll_timer.poll_counts.submit(dst);\n+            }\n+        }\n         worker\n             .busy_duration_total\n             .store(self.busy_duration_total, Relaxed);\n-\n-        worker\n-            .local_schedule_count\n-            .store(self.local_schedule_count, Relaxed);\n-        worker.overflow_count.store(self.overflow_count, Relaxed);\n-\n-        if let Some(poll_timer) = &self.poll_timer {\n-            let dst = worker.poll_count_histogram.as_ref().unwrap();\n-            poll_timer.poll_counts.submit(dst);\n-        }\n     }\n \n     /// The worker is about to park.\n     pub(crate) fn about_to_park(&mut self) {\n-        self.park_count += 1;\n-        self.park_unpark_count += 1;\n-\n-        if self.poll_count_on_last_park == self.poll_count {\n-            self.noop_count += 1;\n-        } else {\n-            self.poll_count_on_last_park = self.poll_count;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_count += 1;\n+            self.park_unpark_count += 1;\n+\n+            if self.poll_count_on_last_park == self.poll_count {\n+                self.noop_count += 1;\n+            } else {\n+                self.poll_count_on_last_park = self.poll_count;\n+            }\n         }\n     }\n \n     /// The worker was unparked.\n     pub(crate) fn unparked(&mut self) {\n-        self.park_unpark_count += 1;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_unpark_count += 1;\n+        }\n     }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1840443167",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1840443167",
        "commented_code": "@@ -39,87 +52,107 @@ pub(crate) struct MetricsBatch {\n     /// Instant at which work last resumed (continued after park).\n     processing_scheduled_tasks_started_at: Instant,\n \n+    #[cfg(tokio_unstable)]\n     /// If `Some`, tracks poll times in nanoseconds\n     poll_timer: Option<PollTimer>,\n }\n \n-struct PollTimer {\n-    /// Histogram of poll counts within each band.\n-    poll_counts: HistogramBatch,\n+cfg_unstable_metrics! {\n+    struct PollTimer {\n+        /// Histogram of poll counts within each band.\n+        poll_counts: HistogramBatch,\n \n-    /// Instant when the most recent task started polling.\n-    poll_started_at: Instant,\n+        /// Instant when the most recent task started polling.\n+        poll_started_at: Instant,\n+    }\n }\n \n impl MetricsBatch {\n-    pub(crate) fn new(worker_metrics: &WorkerMetrics) -> MetricsBatch {\n+    pub(crate) fn new(_worker_metrics: &WorkerMetrics) -> MetricsBatch {\n         let now = Instant::now();\n+        #[cfg(not(tokio_unstable))]\n+        {\n+            MetricsBatch {\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+            }\n+        }\n \n-        MetricsBatch {\n-            park_count: 0,\n-            park_unpark_count: 0,\n-            noop_count: 0,\n-            steal_count: 0,\n-            steal_operations: 0,\n-            poll_count: 0,\n-            poll_count_on_last_park: 0,\n-            local_schedule_count: 0,\n-            overflow_count: 0,\n-            busy_duration_total: 0,\n-            processing_scheduled_tasks_started_at: now,\n-            poll_timer: worker_metrics\n-                .poll_count_histogram\n-                .as_ref()\n-                .map(|worker_poll_counts| PollTimer {\n-                    poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n-                    poll_started_at: now,\n-                }),\n+        #[cfg(tokio_unstable)]\n+        {\n+            MetricsBatch {\n+                park_count: 0,\n+                park_unpark_count: 0,\n+                noop_count: 0,\n+                steal_count: 0,\n+                steal_operations: 0,\n+                poll_count: 0,\n+                poll_count_on_last_park: 0,\n+                local_schedule_count: 0,\n+                overflow_count: 0,\n+                busy_duration_total: 0,\n+                processing_scheduled_tasks_started_at: now,\n+                poll_timer: _worker_metrics.poll_count_histogram.as_ref().map(\n+                    |worker_poll_counts| PollTimer {\n+                        poll_counts: HistogramBatch::from_histogram(worker_poll_counts),\n+                        poll_started_at: now,\n+                    },\n+                ),\n+            }\n         }\n     }\n \n-    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, mean_poll_time: u64) {\n-        worker.mean_poll_time.store(mean_poll_time, Relaxed);\n-        worker.park_count.store(self.park_count, Relaxed);\n-        worker\n-            .park_unpark_count\n-            .store(self.park_unpark_count, Relaxed);\n-        worker.noop_count.store(self.noop_count, Relaxed);\n-        worker.steal_count.store(self.steal_count, Relaxed);\n-        worker\n-            .steal_operations\n-            .store(self.steal_operations, Relaxed);\n-        worker.poll_count.store(self.poll_count, Relaxed);\n-\n+    pub(crate) fn submit(&mut self, worker: &WorkerMetrics, _mean_poll_time: u64) {\n+        #[cfg(tokio_unstable)]\n+        {\n+            worker.mean_poll_time.store(_mean_poll_time, Relaxed);\n+            worker.park_count.store(self.park_count, Relaxed);\n+            worker\n+                .park_unpark_count\n+                .store(self.park_unpark_count, Relaxed);\n+            worker.noop_count.store(self.noop_count, Relaxed);\n+            worker.steal_count.store(self.steal_count, Relaxed);\n+            worker\n+                .steal_operations\n+                .store(self.steal_operations, Relaxed);\n+            worker.poll_count.store(self.poll_count, Relaxed);\n+\n+            worker\n+                .local_schedule_count\n+                .store(self.local_schedule_count, Relaxed);\n+            worker.overflow_count.store(self.overflow_count, Relaxed);\n+\n+            if let Some(poll_timer) = &self.poll_timer {\n+                let dst = worker.poll_count_histogram.as_ref().unwrap();\n+                poll_timer.poll_counts.submit(dst);\n+            }\n+        }\n         worker\n             .busy_duration_total\n             .store(self.busy_duration_total, Relaxed);\n-\n-        worker\n-            .local_schedule_count\n-            .store(self.local_schedule_count, Relaxed);\n-        worker.overflow_count.store(self.overflow_count, Relaxed);\n-\n-        if let Some(poll_timer) = &self.poll_timer {\n-            let dst = worker.poll_count_histogram.as_ref().unwrap();\n-            poll_timer.poll_counts.submit(dst);\n-        }\n     }\n \n     /// The worker is about to park.\n     pub(crate) fn about_to_park(&mut self) {\n-        self.park_count += 1;\n-        self.park_unpark_count += 1;\n-\n-        if self.poll_count_on_last_park == self.poll_count {\n-            self.noop_count += 1;\n-        } else {\n-            self.poll_count_on_last_park = self.poll_count;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_count += 1;\n+            self.park_unpark_count += 1;\n+\n+            if self.poll_count_on_last_park == self.poll_count {\n+                self.noop_count += 1;\n+            } else {\n+                self.poll_count_on_last_park = self.poll_count;\n+            }\n         }\n     }\n \n     /// The worker was unparked.\n     pub(crate) fn unparked(&mut self) {\n-        self.park_unpark_count += 1;\n+        #[cfg(tokio_unstable)]\n+        {\n+            self.park_unpark_count += 1;\n+        }\n     }",
        "comment_created_at": "2024-11-13T14:38:15+00:00",
        "comment_author": "hds",
        "comment_body": "In the rest of the Tokio code base, we do this a different way, so let's stick to that convension. Instead of gating functionality within a function, we have a separate empty function definition when the cfg flag isn't enabled. So this function would become:\r\n\r\n```rust\r\ncfg_unstable_metrics! {\r\n    /// The worker was unparked.\r\n    pub(crate) fn unparked(&mut self) {\r\n        self.park_unpark_count += 1;\r\n    }\r\n}\r\n\r\ncfg_not_unstable_metrics! {\r\n    /// The worker was unparked.\r\n    pub(crate) fn unparked(&mut self) {}\r\n}\r\n```\r\n\r\nPlease do the same here. Keep a single `cfg_unstable_metrics` block (and a single `cfg_not_unstable_metrics` block) for all the functions that require this behavior, so that they're grouped together.\r\n\r\nFor the more complex functions above that have a mix of stablized and unstablized implementation, split the unstablized part out into a separate function with an impl in each of the macro blocks (see example in the comment on `submit`).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1840461352",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2024-11-13T14:44:23+00:00",
    "commented_code": "/// Instant at which work last resumed (continued after park).\n     processing_scheduled_tasks_started_at: Instant,\n \n+    #[cfg(tokio_unstable)]\n     /// If `Some`, tracks poll times in nanoseconds\n     poll_timer: Option<PollTimer>,\n }\n \n-struct PollTimer {\n-    /// Histogram of poll counts within each band.\n-    poll_counts: HistogramBatch,\n+cfg_unstable_metrics! {\n+    struct PollTimer {\n+        /// Histogram of poll counts within each band.\n+        poll_counts: HistogramBatch,\n \n-    /// Instant when the most recent task started polling.\n-    poll_started_at: Instant,\n+        /// Instant when the most recent task started polling.\n+        poll_started_at: Instant,\n+    }\n }\n \n impl MetricsBatch {\n-    pub(crate) fn new(worker_metrics: &WorkerMetrics) -> MetricsBatch {\n+    pub(crate) fn new(_worker_metrics: &WorkerMetrics) -> MetricsBatch {",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1840461352",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1840461352",
        "commented_code": "@@ -39,87 +52,107 @@ pub(crate) struct MetricsBatch {\n     /// Instant at which work last resumed (continued after park).\n     processing_scheduled_tasks_started_at: Instant,\n \n+    #[cfg(tokio_unstable)]\n     /// If `Some`, tracks poll times in nanoseconds\n     poll_timer: Option<PollTimer>,\n }\n \n-struct PollTimer {\n-    /// Histogram of poll counts within each band.\n-    poll_counts: HistogramBatch,\n+cfg_unstable_metrics! {\n+    struct PollTimer {\n+        /// Histogram of poll counts within each band.\n+        poll_counts: HistogramBatch,\n \n-    /// Instant when the most recent task started polling.\n-    poll_started_at: Instant,\n+        /// Instant when the most recent task started polling.\n+        poll_started_at: Instant,\n+    }\n }\n \n impl MetricsBatch {\n-    pub(crate) fn new(worker_metrics: &WorkerMetrics) -> MetricsBatch {\n+    pub(crate) fn new(_worker_metrics: &WorkerMetrics) -> MetricsBatch {",
        "comment_created_at": "2024-11-13T14:44:23+00:00",
        "comment_author": "hds",
        "comment_body": "Split this into 2 implementations each gated by `cfg_(not_)unstable_metrics!`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1902127491",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2025-01-03T20:08:50+00:00",
    "commented_code": "self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1902127491",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902127491",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }",
        "comment_created_at": "2025-01-03T20:08:50+00:00",
        "comment_author": "rcoh",
        "comment_body": "reading through this, I wonder if we should make a macro specifically for this pattern, something like:\r\n\r\n```\r\ncfg_metrics! {\r\n  stable: {\r\n     ...\r\n   },\r\n   unstable: { ... }\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1902127803",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902127491",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }",
        "comment_created_at": "2025-01-03T20:09:18+00:00",
        "comment_author": "rcoh",
        "comment_body": "if we are going to have a lot of a/b code when metrics or stable or not, could be helpful to avoid bugs",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1902128590",
    "pr_number": 6899,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2025-01-03T20:10:24+00:00",
    "commented_code": "self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }\n \n-    /// Stop polling an individual task\n-    pub(crate) fn end_poll(&mut self) {\n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n-            poll_timer.poll_counts.measure(elapsed, 1);\n+    cfg_not_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {}\n+    }\n+\n+    cfg_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {\n+            self.local_schedule_count += 1;\n         }\n     }\n \n-    pub(crate) fn inc_local_schedule_count(&mut self) {\n-        self.local_schedule_count += 1;\n+    cfg_not_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {}\n     }\n }\n \n cfg_rt_multi_thread! {\n     impl MetricsBatch {\n-        pub(crate) fn incr_steal_count(&mut self, by: u16) {\n-            self.steal_count += by as u64;\n+        pub(crate) fn incr_steal_count(&mut self, _by: u16) {\n+            #[cfg(tokio_unstable)] {\n+                self.steal_count += _by as u64;\n+            }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1902128590",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902128590",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }\n \n-    /// Stop polling an individual task\n-    pub(crate) fn end_poll(&mut self) {\n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n-            poll_timer.poll_counts.measure(elapsed, 1);\n+    cfg_not_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {}\n+    }\n+\n+    cfg_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {\n+            self.local_schedule_count += 1;\n         }\n     }\n \n-    pub(crate) fn inc_local_schedule_count(&mut self) {\n-        self.local_schedule_count += 1;\n+    cfg_not_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {}\n     }\n }\n \n cfg_rt_multi_thread! {\n     impl MetricsBatch {\n-        pub(crate) fn incr_steal_count(&mut self, by: u16) {\n-            self.steal_count += by as u64;\n+        pub(crate) fn incr_steal_count(&mut self, _by: u16) {\n+            #[cfg(tokio_unstable)] {\n+                self.steal_count += _by as u64;\n+            }",
        "comment_created_at": "2025-01-03T20:10:24+00:00",
        "comment_author": "rcoh",
        "comment_body": "I think we should probably pick a patternâ€”either cfg-ing the body of the function or the function entirely instead of using both",
        "pr_file_module": null
      },
      {
        "comment_id": "1911962262",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6899,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "1902128590",
        "commented_code": "@@ -133,40 +193,66 @@ impl MetricsBatch {\n         self.busy_duration_total += duration_as_u64(busy_duration);\n     }\n \n-    /// Start polling an individual task\n-    pub(crate) fn start_poll(&mut self) {\n-        self.poll_count += 1;\n+    cfg_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {\n+            self.poll_count += 1;\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                poll_timer.poll_started_at = Instant::now();\n+            }\n+        }\n+    }\n+\n+    cfg_not_unstable_metrics! {\n+        /// Start polling an individual task\n+        pub(crate) fn start_poll(&mut self) {}\n+    }\n \n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            poll_timer.poll_started_at = Instant::now();\n+    cfg_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {\n+            #[cfg(tokio_unstable)]\n+            if let Some(poll_timer) = &mut self.poll_timer {\n+                let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n+                poll_timer.poll_counts.measure(elapsed, 1);\n+            }\n         }\n     }\n \n-    /// Stop polling an individual task\n-    pub(crate) fn end_poll(&mut self) {\n-        if let Some(poll_timer) = &mut self.poll_timer {\n-            let elapsed = duration_as_u64(poll_timer.poll_started_at.elapsed());\n-            poll_timer.poll_counts.measure(elapsed, 1);\n+    cfg_not_unstable_metrics! {\n+        /// Stop polling an individual task\n+        pub(crate) fn end_poll(&mut self) {}\n+    }\n+\n+    cfg_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {\n+            self.local_schedule_count += 1;\n         }\n     }\n \n-    pub(crate) fn inc_local_schedule_count(&mut self) {\n-        self.local_schedule_count += 1;\n+    cfg_not_unstable_metrics! {\n+        pub(crate) fn inc_local_schedule_count(&mut self) {}\n     }\n }\n \n cfg_rt_multi_thread! {\n     impl MetricsBatch {\n-        pub(crate) fn incr_steal_count(&mut self, by: u16) {\n-            self.steal_count += by as u64;\n+        pub(crate) fn incr_steal_count(&mut self, _by: u16) {\n+            #[cfg(tokio_unstable)] {\n+                self.steal_count += _by as u64;\n+            }",
        "comment_created_at": "2025-01-11T10:40:06+00:00",
        "comment_author": "Owen-CH-Leung",
        "comment_body": "Thanks @rcoh . I've added a new macro and put all the ab code implementation into this macro. I also recorganize fields so that stable fields come first. Please can I have your review again ? Thanks!",
        "pr_file_module": null
      }
    ]
  }
]