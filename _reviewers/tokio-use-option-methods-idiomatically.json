[
  {
    "discussion_id": "2079990271",
    "pr_number": 7322,
    "pr_file": "tokio/src/runtime/metrics/batch.rs",
    "created_at": "2025-05-08T15:45:39+00:00",
    "commented_code": "/// Start processing a batch of tasks\n     pub(crate) fn start_processing_scheduled_tasks(&mut self) {\n-        self.processing_scheduled_tasks_started_at = Instant::now();\n+        if self.processing_scheduled_tasks_started_at.is_some() {\n+            self.processing_scheduled_tasks_started_at = Some(Instant::now());\n+        }\n     }\n \n     /// Stop processing a batch of tasks\n     pub(crate) fn end_processing_scheduled_tasks(&mut self) {\n-        let busy_duration = self.processing_scheduled_tasks_started_at.elapsed();\n-        self.busy_duration_total += duration_as_u64(busy_duration);\n+        if let Some(processing_scheduled_tasks_started_at) =\n+            self.processing_scheduled_tasks_started_at\n+        {\n+            let busy_duration = processing_scheduled_tasks_started_at.elapsed();",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "2079990271",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 7322,
        "pr_file": "tokio/src/runtime/metrics/batch.rs",
        "discussion_id": "2079990271",
        "commented_code": "@@ -186,13 +208,19 @@ impl MetricsBatch {\n \n     /// Start processing a batch of tasks\n     pub(crate) fn start_processing_scheduled_tasks(&mut self) {\n-        self.processing_scheduled_tasks_started_at = Instant::now();\n+        if self.processing_scheduled_tasks_started_at.is_some() {\n+            self.processing_scheduled_tasks_started_at = Some(Instant::now());\n+        }\n     }\n \n     /// Stop processing a batch of tasks\n     pub(crate) fn end_processing_scheduled_tasks(&mut self) {\n-        let busy_duration = self.processing_scheduled_tasks_started_at.elapsed();\n-        self.busy_duration_total += duration_as_u64(busy_duration);\n+        if let Some(processing_scheduled_tasks_started_at) =\n+            self.processing_scheduled_tasks_started_at\n+        {\n+            let busy_duration = processing_scheduled_tasks_started_at.elapsed();",
        "comment_created_at": "2025-05-08T15:45:39+00:00",
        "comment_author": "rcoh",
        "comment_body": "I like the impact of making this optional since it ensures we can't call `elapsed()` unless we actually got an instant.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1802790960",
    "pr_number": 6897,
    "pr_file": "tokio/src/runtime/metrics/histogram.rs",
    "created_at": "2024-10-16T10:05:23+00:00",
    "commented_code": "}\n \n     fn value_to_bucket(&self, value: u64) -> usize {\n-        match self.scale {\n-            HistogramScale::Linear => {\n-                let max = self.buckets.len() - 1;\n-                cmp::min(value / self.resolution, max as u64) as usize\n-            }\n-            HistogramScale::Log => {\n-                let max = self.buckets.len() - 1;\n-\n-                if value < self.resolution {\n-                    0\n-                } else {\n-                    let significant_digits = 64 - value.leading_zeros();\n-                    let bucket_digits = 64 - (self.resolution - 1).leading_zeros();\n-                    cmp::min(significant_digits as usize - bucket_digits as usize, max)\n-                }\n-            }\n-        }\n+        self.configuration.value_to_bucket(value)\n     }\n }\n \n impl HistogramBuilder {\n     pub(crate) fn new() -> HistogramBuilder {\n         HistogramBuilder {\n-            scale: HistogramScale::Linear,\n-            // Resolution is in nanoseconds.\n-            resolution: 100_000,\n-            num_buckets: 10,\n+            histogram_type: HistogramType::Linear(LinearHistogram {\n+                num_buckets: 10,\n+                bucket_width: 100_000,\n+            }),\n+            legacy: None,\n+        }\n+    }\n+\n+    pub(crate) fn legacy_mut(&mut self, f: impl Fn(&mut LegacyBuilder)) {\n+        if let Some(legacy) = &mut self.legacy {\n+            f(legacy)\n+        } else {\n+            let mut legacy = LegacyBuilder::default();\n+            f(&mut legacy);\n+            self.legacy = Some(legacy)\n         }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1802790960",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6897,
        "pr_file": "tokio/src/runtime/metrics/histogram.rs",
        "discussion_id": "1802790960",
        "commented_code": "@@ -112,52 +224,62 @@ impl HistogramBatch {\n     }\n \n     fn value_to_bucket(&self, value: u64) -> usize {\n-        match self.scale {\n-            HistogramScale::Linear => {\n-                let max = self.buckets.len() - 1;\n-                cmp::min(value / self.resolution, max as u64) as usize\n-            }\n-            HistogramScale::Log => {\n-                let max = self.buckets.len() - 1;\n-\n-                if value < self.resolution {\n-                    0\n-                } else {\n-                    let significant_digits = 64 - value.leading_zeros();\n-                    let bucket_digits = 64 - (self.resolution - 1).leading_zeros();\n-                    cmp::min(significant_digits as usize - bucket_digits as usize, max)\n-                }\n-            }\n-        }\n+        self.configuration.value_to_bucket(value)\n     }\n }\n \n impl HistogramBuilder {\n     pub(crate) fn new() -> HistogramBuilder {\n         HistogramBuilder {\n-            scale: HistogramScale::Linear,\n-            // Resolution is in nanoseconds.\n-            resolution: 100_000,\n-            num_buckets: 10,\n+            histogram_type: HistogramType::Linear(LinearHistogram {\n+                num_buckets: 10,\n+                bucket_width: 100_000,\n+            }),\n+            legacy: None,\n+        }\n+    }\n+\n+    pub(crate) fn legacy_mut(&mut self, f: impl Fn(&mut LegacyBuilder)) {\n+        if let Some(legacy) = &mut self.legacy {\n+            f(legacy)\n+        } else {\n+            let mut legacy = LegacyBuilder::default();\n+            f(&mut legacy);\n+            self.legacy = Some(legacy)\n         }",
        "comment_created_at": "2024-10-16T10:05:23+00:00",
        "comment_author": "hds",
        "comment_body": "`Option` has a function that does handles the None case for you:\r\n\r\n```suggestion\r\n        let legacy = self.legacy.get_or_insert_with(|| LegacyBuilder::default());\r\n        f(legacy);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1577679729",
    "pr_number": 6512,
    "pr_file": "tokio/src/time/sleep.rs",
    "created_at": "2024-04-24T10:43:13+00:00",
    "commented_code": "#[cfg(any(not(tokio_unstable), not(feature = \"tracing\")))]\n         let coop = ready!(crate::runtime::coop::poll_proceed(cx));\n-\n-        let result = me.entry.poll_elapsed(cx).map(move |r| {\n-            coop.made_progress();\n-            r\n-        });\n+        // Safety: we have just assigned it a value of `Some`.\n+        let result = me\n+            .entry\n+            .as_pin_mut()\n+            .unwrap()\n+            .poll_elapsed(cx)\n+            .map(move |r| {\n+                coop.made_progress();\n+                r\n+            });\n \n         #[cfg(all(tokio_unstable, feature = \"tracing\"))]\n         return trace_poll_op!(\"poll_elapsed\", result);\n \n         #[cfg(any(not(tokio_unstable), not(feature = \"tracing\")))]\n         return result;\n     }\n+\n+    // This lazy initiation is for performance purposes,\n+    // it can avoid the unnecessary creation and drop of `TimerEntry`.\n+    fn lazy_init_timer_entry(self: Pin<&mut Self>, deadline: Instant) {\n+        let mut me = self.project();\n+        *me.deadline = deadline;\n+        if me.entry.is_none() {\n+            let entry = TimerEntry::new(me.handle, deadline);\n+            me.entry.as_mut().set(Some(entry));\n+        }\n+    }\n }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1577679729",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6512,
        "pr_file": "tokio/src/time/sleep.rs",
        "discussion_id": "1577679729",
        "commented_code": "@@ -412,18 +448,34 @@ impl Sleep {\n \n         #[cfg(any(not(tokio_unstable), not(feature = \"tracing\")))]\n         let coop = ready!(crate::runtime::coop::poll_proceed(cx));\n-\n-        let result = me.entry.poll_elapsed(cx).map(move |r| {\n-            coop.made_progress();\n-            r\n-        });\n+        // Safety: we have just assigned it a value of `Some`.\n+        let result = me\n+            .entry\n+            .as_pin_mut()\n+            .unwrap()\n+            .poll_elapsed(cx)\n+            .map(move |r| {\n+                coop.made_progress();\n+                r\n+            });\n \n         #[cfg(all(tokio_unstable, feature = \"tracing\"))]\n         return trace_poll_op!(\"poll_elapsed\", result);\n \n         #[cfg(any(not(tokio_unstable), not(feature = \"tracing\")))]\n         return result;\n     }\n+\n+    // This lazy initiation is for performance purposes,\n+    // it can avoid the unnecessary creation and drop of `TimerEntry`.\n+    fn lazy_init_timer_entry(self: Pin<&mut Self>, deadline: Instant) {\n+        let mut me = self.project();\n+        *me.deadline = deadline;\n+        if me.entry.is_none() {\n+            let entry = TimerEntry::new(me.handle, deadline);\n+            me.entry.as_mut().set(Some(entry));\n+        }\n+    }\n }",
        "comment_created_at": "2024-04-24T10:43:13+00:00",
        "comment_author": "paolobarbolini",
        "comment_body": "Drive-by review: could this be simplified with [`Option::get_or_insert_with`](https://doc.rust-lang.org/1.63.0/std/option/enum.Option.html#method.get_or_insert_with)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1578934098",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6512,
        "pr_file": "tokio/src/time/sleep.rs",
        "discussion_id": "1577679729",
        "commented_code": "@@ -412,18 +448,34 @@ impl Sleep {\n \n         #[cfg(any(not(tokio_unstable), not(feature = \"tracing\")))]\n         let coop = ready!(crate::runtime::coop::poll_proceed(cx));\n-\n-        let result = me.entry.poll_elapsed(cx).map(move |r| {\n-            coop.made_progress();\n-            r\n-        });\n+        // Safety: we have just assigned it a value of `Some`.\n+        let result = me\n+            .entry\n+            .as_pin_mut()\n+            .unwrap()\n+            .poll_elapsed(cx)\n+            .map(move |r| {\n+                coop.made_progress();\n+                r\n+            });\n \n         #[cfg(all(tokio_unstable, feature = \"tracing\"))]\n         return trace_poll_op!(\"poll_elapsed\", result);\n \n         #[cfg(any(not(tokio_unstable), not(feature = \"tracing\")))]\n         return result;\n     }\n+\n+    // This lazy initiation is for performance purposes,\n+    // it can avoid the unnecessary creation and drop of `TimerEntry`.\n+    fn lazy_init_timer_entry(self: Pin<&mut Self>, deadline: Instant) {\n+        let mut me = self.project();\n+        *me.deadline = deadline;\n+        if me.entry.is_none() {\n+            let entry = TimerEntry::new(me.handle, deadline);\n+            me.entry.as_mut().set(Some(entry));\n+        }\n+    }\n }",
        "comment_created_at": "2024-04-25T06:25:29+00:00",
        "comment_author": "wathenjiang",
        "comment_body": "Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1580593676",
    "pr_number": 6512,
    "pr_file": "tokio/src/runtime/time/entry.rs",
    "created_at": "2024-04-26T07:29:17+00:00",
    "commented_code": "impl TimerEntry {\n     #[track_caller]\n-    pub(crate) fn new(handle: &scheduler::Handle, deadline: Instant) -> Self {\n+    pub(crate) fn new(handle: scheduler::Handle, deadline: Instant) -> Self {\n         // Panic if the time driver is not enabled\n         let _ = handle.driver().time();\n \n-        let driver = handle.clone();\n-\n         Self {\n-            driver,\n-            inner: StdUnsafeCell::new(TimerShared::new()),\n+            driver: handle,\n+            inner: StdUnsafeCell::new(None),\n             deadline,\n             registered: false,\n             _m: std::marker::PhantomPinned,\n         }\n     }\n \n+    fn is_inner_init(&self) -> bool {\n+        unsafe { &*self.inner.get() }.is_some()\n+    }\n+\n+    // This lazy initialization is for performance purposes.\n     fn inner(&self) -> &TimerShared {\n-        unsafe { &*self.inner.get() }\n+        unsafe { &mut *self.inner.get() }.get_or_insert(TimerShared::new())\n     }",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1580593676",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6512,
        "pr_file": "tokio/src/runtime/time/entry.rs",
        "discussion_id": "1580593676",
        "commented_code": "@@ -477,35 +477,42 @@ unsafe impl linked_list::Link for TimerShared {\n \n impl TimerEntry {\n     #[track_caller]\n-    pub(crate) fn new(handle: &scheduler::Handle, deadline: Instant) -> Self {\n+    pub(crate) fn new(handle: scheduler::Handle, deadline: Instant) -> Self {\n         // Panic if the time driver is not enabled\n         let _ = handle.driver().time();\n \n-        let driver = handle.clone();\n-\n         Self {\n-            driver,\n-            inner: StdUnsafeCell::new(TimerShared::new()),\n+            driver: handle,\n+            inner: StdUnsafeCell::new(None),\n             deadline,\n             registered: false,\n             _m: std::marker::PhantomPinned,\n         }\n     }\n \n+    fn is_inner_init(&self) -> bool {\n+        unsafe { &*self.inner.get() }.is_some()\n+    }\n+\n+    // This lazy initialization is for performance purposes.\n     fn inner(&self) -> &TimerShared {\n-        unsafe { &*self.inner.get() }\n+        unsafe { &mut *self.inner.get() }.get_or_insert(TimerShared::new())\n     }",
        "comment_created_at": "2024-04-26T07:29:17+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Can you change this to only create a mutable reference if it is `None`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1587320972",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6512,
        "pr_file": "tokio/src/runtime/time/entry.rs",
        "discussion_id": "1580593676",
        "commented_code": "@@ -477,35 +477,42 @@ unsafe impl linked_list::Link for TimerShared {\n \n impl TimerEntry {\n     #[track_caller]\n-    pub(crate) fn new(handle: &scheduler::Handle, deadline: Instant) -> Self {\n+    pub(crate) fn new(handle: scheduler::Handle, deadline: Instant) -> Self {\n         // Panic if the time driver is not enabled\n         let _ = handle.driver().time();\n \n-        let driver = handle.clone();\n-\n         Self {\n-            driver,\n-            inner: StdUnsafeCell::new(TimerShared::new()),\n+            driver: handle,\n+            inner: StdUnsafeCell::new(None),\n             deadline,\n             registered: false,\n             _m: std::marker::PhantomPinned,\n         }\n     }\n \n+    fn is_inner_init(&self) -> bool {\n+        unsafe { &*self.inner.get() }.is_some()\n+    }\n+\n+    // This lazy initialization is for performance purposes.\n     fn inner(&self) -> &TimerShared {\n-        unsafe { &*self.inner.get() }\n+        unsafe { &mut *self.inner.get() }.get_or_insert(TimerShared::new())\n     }",
        "comment_created_at": "2024-05-02T09:16:30+00:00",
        "comment_author": "wathenjiang",
        "comment_body": "I have used additional `is_done` code  to achieve this goal.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1561315299",
    "pr_number": 6478,
    "pr_file": "tokio/src/sync/semaphore.rs",
    "created_at": "2024-04-11T16:40:34+00:00",
    "commented_code": "/// Splits `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n     ///\n     /// If there are insufficient permits and it's not possible to reduce by `n`, returns `None`.\n-    pub fn split(&mut self, n: u32) -> Option<Self> {\n+    pub fn split(&mut self, n: usize) -> Option<Self> {\n+        let n = match u32::try_from(n) {\n+            Ok(n) => n,\n+            Err(_) => return None,\n+        };",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1561315299",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6478,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1561315299",
        "commented_code": "@@ -994,7 +994,12 @@ impl<'a> SemaphorePermit<'a> {\n     /// Splits `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n     ///\n     /// If there are insufficient permits and it's not possible to reduce by `n`, returns `None`.\n-    pub fn split(&mut self, n: u32) -> Option<Self> {\n+    pub fn split(&mut self, n: usize) -> Option<Self> {\n+        let n = match u32::try_from(n) {\n+            Ok(n) => n,\n+            Err(_) => return None,\n+        };",
        "comment_created_at": "2024-04-11T16:40:34+00:00",
        "comment_author": "hawkw",
        "comment_body": "nit: doesn't this simplify to:\r\n```suggestion\r\n        let n = u32::try_from(n).ok()?;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1561348310",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6478,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1561315299",
        "commented_code": "@@ -994,7 +994,12 @@ impl<'a> SemaphorePermit<'a> {\n     /// Splits `n` permits from `self` and returns a new [`SemaphorePermit`] instance that holds `n` permits.\n     ///\n     /// If there are insufficient permits and it's not possible to reduce by `n`, returns `None`.\n-    pub fn split(&mut self, n: u32) -> Option<Self> {\n+    pub fn split(&mut self, n: usize) -> Option<Self> {\n+        let n = match u32::try_from(n) {\n+            Ok(n) => n,\n+            Err(_) => return None,\n+        };",
        "comment_created_at": "2024-04-11T17:11:20+00:00",
        "comment_author": "Darksonn",
        "comment_body": "Yes, thanks for the suggestion.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1561315505",
    "pr_number": 6478,
    "pr_file": "tokio/src/sync/semaphore.rs",
    "created_at": "2024-04-11T16:40:47+00:00",
    "commented_code": "/// # Note\n     ///\n     /// It will clone the owned `Arc<Semaphore>` to construct the new instance.\n-    pub fn split(&mut self, n: u32) -> Option<Self> {\n+    pub fn split(&mut self, n: usize) -> Option<Self> {\n+        let n = match u32::try_from(n) {\n+            Ok(n) => n,\n+            Err(_) => return None,\n+        };",
    "repo_full_name": "tokio-rs/tokio",
    "discussion_comments": [
      {
        "comment_id": "1561315505",
        "repo_full_name": "tokio-rs/tokio",
        "pr_number": 6478,
        "pr_file": "tokio/src/sync/semaphore.rs",
        "discussion_id": "1561315505",
        "commented_code": "@@ -1047,7 +1052,12 @@ impl OwnedSemaphorePermit {\n     /// # Note\n     ///\n     /// It will clone the owned `Arc<Semaphore>` to construct the new instance.\n-    pub fn split(&mut self, n: u32) -> Option<Self> {\n+    pub fn split(&mut self, n: usize) -> Option<Self> {\n+        let n = match u32::try_from(n) {\n+            Ok(n) => n,\n+            Err(_) => return None,\n+        };",
        "comment_created_at": "2024-04-11T16:40:47+00:00",
        "comment_author": "hawkw",
        "comment_body": "similarly:\r\nnit: doesn't this simplify to:\r\n```suggestion\r\n        let n = u32::try_from(n).ok()?;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]