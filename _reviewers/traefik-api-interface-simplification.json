[
  {
    "discussion_id": "2225007755",
    "pr_number": 11882,
    "pr_file": "pkg/healthcheck/mock_test.go",
    "created_at": "2025-07-23T09:47:33+00:00",
    "commented_code": "return gRPCService\n }\n \n+func (s *GRPCServer) List(_ context.Context, _ *healthpb.HealthListRequest) (*healthpb.HealthListResponse, error) {\n+\treturn nil, nil\n+}\n+",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2225007755",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11882,
        "pr_file": "pkg/healthcheck/mock_test.go",
        "discussion_id": "2225007755",
        "commented_code": "@@ -64,6 +64,10 @@ func newGRPCServer(healthSequence ...healthpb.HealthCheckResponse_ServingStatus)\n \treturn gRPCService\n }\n \n+func (s *GRPCServer) List(_ context.Context, _ *healthpb.HealthListRequest) (*healthpb.HealthListResponse, error) {\n+\treturn nil, nil\n+}\n+",
        "comment_created_at": "2025-07-23T09:47:33+00:00",
        "comment_author": "rtribotte",
        "comment_body": "Is it just because you stumbled onto this, or is it somehow a hard requirement to fix this now? I don't understand why there is this change TBH",
        "pr_file_module": null
      },
      {
        "comment_id": "2225024817",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11882,
        "pr_file": "pkg/healthcheck/mock_test.go",
        "discussion_id": "2225007755",
        "commented_code": "@@ -64,6 +64,10 @@ func newGRPCServer(healthSequence ...healthpb.HealthCheckResponse_ServingStatus)\n \treturn gRPCService\n }\n \n+func (s *GRPCServer) List(_ context.Context, _ *healthpb.HealthListRequest) (*healthpb.HealthListResponse, error) {\n+\treturn nil, nil\n+}\n+",
        "comment_created_at": "2025-07-23T09:54:51+00:00",
        "comment_author": "ldez",
        "comment_body": "This is a hard requirement because:\r\n- https://github.com/grpc/grpc-go/blob/8adcc948ae1f35a179afcb610aadfc3ea84f4670/health/grpc_health_v1/health_grpc.pb.go#L164\r\n- https://github.com/grpc/grpc-go/commit/78ba6616c1c3d641cf2cc861a0696fd5beb90aa3",
        "pr_file_module": null
      },
      {
        "comment_id": "2225416588",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11882,
        "pr_file": "pkg/healthcheck/mock_test.go",
        "discussion_id": "2225007755",
        "commented_code": "@@ -64,6 +64,10 @@ func newGRPCServer(healthSequence ...healthpb.HealthCheckResponse_ServingStatus)\n \treturn gRPCService\n }\n \n+func (s *GRPCServer) List(_ context.Context, _ *healthpb.HealthListRequest) (*healthpb.HealthListResponse, error) {\n+\treturn nil, nil\n+}\n+",
        "comment_created_at": "2025-07-23T12:25:11+00:00",
        "comment_author": "rtribotte",
        "comment_body": "ok got it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2158314039",
    "pr_number": 11844,
    "pr_file": "pkg/provider/kubernetes/ingress-nginx/kubernetes.go",
    "created_at": "2025-06-20T08:13:07+00:00",
    "commented_code": "+package ingressnginx\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"maps\"\n+\t\"math\"\n+\t\"net\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/cenkalti/backoff/v4\"\n+\t\"github.com/mitchellh/hashstructure\"\n+\t\"github.com/rs/zerolog/log\"\n+\tptypes \"github.com/traefik/paerser/types\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/job\"\n+\t\"github.com/traefik/traefik/v3/pkg/logs\"\n+\t\"github.com/traefik/traefik/v3/pkg/provider\"\n+\t\"github.com/traefik/traefik/v3/pkg/provider/kubernetes/k8s\"\n+\t\"github.com/traefik/traefik/v3/pkg/safe\"\n+\t\"github.com/traefik/traefik/v3/pkg/tls\"\n+\t\"github.com/traefik/traefik/v3/pkg/types\"\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\tnetv1 \"k8s.io/api/networking/v1\"\n+\t\"k8s.io/utils/ptr\"\n+)\n+\n+const (\n+\tproviderName = \"kubernetesingressnginx\"\n+\n+\tannotationIngressClass = \"kubernetes.io/ingress.class\"\n+\n+\tdefaultControllerName  = \"k8s.io/ingress-nginx\"\n+\tdefaultAnnotationValue = \"nginx\"\n+\n+\tdefaultBackendName    = \"default-backend\"\n+\tdefaultBackendTLSName = \"default-backend-tls\"\n+)\n+\n+type backendAddress struct {\n+\tAddress string\n+\tFenced  bool\n+}\n+\n+type namedServersTransport struct {\n+\tName             string\n+\tServersTransport *dynamic.ServersTransport\n+}\n+\n+type certBlocks struct {\n+\tCA          *types.FileOrContent\n+\tCertificate *tls.Certificate\n+}\n+\n+// Provider holds configurations of the provider.\n+type Provider struct {\n+\tEndpoint         string              `description:\"Kubernetes server endpoint (required for external cluster client).\" json:\"endpoint,omitempty\" toml:\"endpoint,omitempty\" yaml:\"endpoint,omitempty\"`\n+\tToken            types.FileOrContent `description:\"Kubernetes bearer token (not needed for in-cluster client). It accepts either a token value or a file path to the token.\" json:\"token,omitempty\" toml:\"token,omitempty\" yaml:\"token,omitempty\" loggable:\"false\"`\n+\tCertAuthFilePath string              `description:\"Kubernetes certificate authority file path (not needed for in-cluster client).\" json:\"certAuthFilePath,omitempty\" toml:\"certAuthFilePath,omitempty\" yaml:\"certAuthFilePath,omitempty\"`\n+\tThrottleDuration ptypes.Duration     `description:\"Ingress refresh throttle duration.\" json:\"throttleDuration,omitempty\" toml:\"throttleDuration,omitempty\" yaml:\"throttleDuration,omitempty\" export:\"true\"`\n+\n+\tWatchNamespace         string `description:\"Namespace the controller watches for updates to Kubernetes objects. All namespaces are watched if this parameter is left empty.\" json:\"watchNamespace,omitempty\" toml:\"watchNamespace,omitempty\" yaml:\"watchNamespace,omitempty\" export:\"true\"`\n+\tWatchNamespaceSelector string `description:\"Selector selects namespaces the controller watches for updates to Kubernetes objects.\" json:\"watchNamespaceSelector,omitempty\" toml:\"watchNamespaceSelector,omitempty\" yaml:\"watchNamespaceSelector,omitempty\" export:\"true\"`\n+\n+\tIngressClass             string `description:\"Name of the ingress class this controller satisfies.\" json:\"ingressClass,omitempty\" toml:\"ingressClass,omitempty\" yaml:\"ingressClass,omitempty\" export:\"true\"`\n+\tControllerClass          string `description:\"Ingress Class Controller value this controller satisfies.\" json:\"controllerClass,omitempty\" toml:\"controllerClass,omitempty\" yaml:\"controllerClass,omitempty\" export:\"true\"`\n+\tWatchIngressWithoutClass bool   `description:\"Define if Ingress Controller should also watch for Ingresses without an IngressClass or the annotation specified.\" json:\"watchIngressWithoutClass,omitempty\" toml:\"watchIngressWithoutClass,omitempty\" yaml:\"watchIngressWithoutClass,omitempty\" export:\"true\"`\n+\tIngressClassByName       bool   `description:\"Define if Ingress Controller should watch for Ingress Class by Name together with Controller Class.\" json:\"ingressClassByName,omitempty\" toml:\"ingressClassByName,omitempty\" yaml:\"ingressClassByName,omitempty\" export:\"true\"`\n+\n+\t// TODO: support report-node-internal-ip-address and update-status.\n+\tPublishService       string   `description:\"Service fronting the Ingress controller. Takes the form 'namespace/name'.\" json:\"publishService,omitempty\" toml:\"publishService,omitempty\" yaml:\"publishService,omitempty\" export:\"true\"`\n+\tPublishStatusAddress []string `description:\"Customized address (or addresses, separated by comma) to set as the load-balancer status of Ingress objects this controller satisfies.\" json:\"publishStatusAddress,omitempty\" toml:\"publishStatusAddress,omitempty\" yaml:\"publishStatusAddress,omitempty\"`\n+\n+\tDefaultBackendService  string `description:\"Service used to serve HTTP requests not matching any known server name (catch-all). Takes the form 'namespace/name'.\" json:\"defaultBackendService,omitempty\" toml:\"defaultBackendService,omitempty\" yaml:\"defaultBackendService,omitempty\" export:\"true\"`\n+\tDisableSvcExternalName bool   `description:\"Disable support for Services of type ExternalName.\" json:\"disableSvcExternalName,omitempty\" toml:\"disableSvcExternalName,omitempty\" yaml:\"disableSvcExternalName,omitempty\" export:\"true\"`\n+\n+\tdefaultBackendServiceNamespace string\n+\tdefaultBackendServiceName      string\n+\n+\tk8sClient         *clientWrapper\n+\tlastConfiguration safe.Safe\n+}\n+\n+func (p *Provider) SetDefaults() {\n+\tp.IngressClass = defaultAnnotationValue\n+\tp.ControllerClass = defaultControllerName\n+}\n+\n+// Init the provider.\n+func (p *Provider) Init() error {\n+\t// Validates and parses the default backend configuration.\n+\tif p.DefaultBackendService != \"\" {\n+\t\tparts := strings.Split(p.DefaultBackendService, \"/\")\n+\t\tif len(parts) != 2 {\n+\t\t\treturn fmt.Errorf(\"invalid default backend service format: %s, expected 'namespace/name'\", p.DefaultBackendService)\n+\t\t}\n+\t\tp.defaultBackendServiceNamespace = parts[0]\n+\t\tp.defaultBackendServiceName = parts[1]\n+\t}\n+\n+\t// Initializes Kubernetes client.\n+\tvar err error\n+\tp.k8sClient, err = p.newK8sClient()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"creating kubernetes client: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Provide allows the k8s provider to provide configurations to traefik using the given configuration channel.\n+func (p *Provider) Provide(configurationChan chan<- dynamic.Message, pool *safe.Pool) error {\n+\tlogger := log.With().Str(logs.ProviderName, providerName).Logger()\n+\tctxLog := logger.WithContext(context.Background())\n+\n+\tpool.GoCtx(func(ctxPool context.Context) {\n+\t\toperation := func() error {\n+\t\t\teventsChan, err := p.k8sClient.WatchAll(ctxPool, p.WatchNamespace, p.WatchNamespaceSelector)\n+\t\t\tif err != nil {\n+\t\t\t\tlogger.Error().Err(err).Msg(\"Error watching kubernetes events\")\n+\t\t\t\ttimer := time.NewTimer(1 * time.Second)\n+\t\t\t\tselect {\n+\t\t\t\tcase <-timer.C:\n+\t\t\t\t\treturn err\n+\t\t\t\tcase <-ctxPool.Done():\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthrottleDuration := time.Duration(p.ThrottleDuration)\n+\t\t\tthrottledChan := throttleEvents(ctxLog, throttleDuration, pool, eventsChan)\n+\t\t\tif throttledChan != nil {\n+\t\t\t\teventsChan = throttledChan\n+\t\t\t}\n+\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-ctxPool.Done():\n+\t\t\t\t\treturn nil\n+\t\t\t\tcase event := <-eventsChan:\n+\t\t\t\t\t// Note that event is the *first* event that came in during this\n+\t\t\t\t\t// throttling interval -- if we're hitting our throttle, we may have\n+\t\t\t\t\t// dropped events. This is fine, because we don't treat different\n+\t\t\t\t\t// event types differently. But if we do in the future, we'll need to\n+\t\t\t\t\t// track more information about the dropped events.\n+\t\t\t\t\tconf := p.loadConfiguration(ctxLog)\n+\n+\t\t\t\t\tconfHash, err := hashstructure.Hash(conf, nil)\n+\t\t\t\t\tswitch {\n+\t\t\t\t\tcase err != nil:\n+\t\t\t\t\t\tlogger.Error().Msg(\"Unable to hash the configuration\")\n+\t\t\t\t\tcase p.lastConfiguration.Get() == confHash:\n+\t\t\t\t\t\tlogger.Debug().Msgf(\"Skipping Kubernetes event kind %T\", event)\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tp.lastConfiguration.Set(confHash)\n+\t\t\t\t\t\tconfigurationChan <- dynamic.Message{\n+\t\t\t\t\t\t\tProviderName:  providerName,\n+\t\t\t\t\t\t\tConfiguration: conf,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// If we're throttling, we sleep here for the throttle duration to\n+\t\t\t\t\t// enforce that we don't refresh faster than our throttle. time.Sleep\n+\t\t\t\t\t// returns immediately if p.ThrottleDuration is 0 (no throttle).\n+\t\t\t\t\ttime.Sleep(throttleDuration)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tnotify := func(err error, time time.Duration) {\n+\t\t\tlogger.Error().Err(err).Msgf(\"Provider error, retrying in %s\", time)\n+\t\t}\n+\n+\t\terr := backoff.RetryNotify(safe.OperationWithRecover(operation), backoff.WithContext(job.NewBackOff(backoff.NewExponentialBackOff()), ctxPool), notify)\n+\t\tif err != nil {\n+\t\t\tlogger.Error().Err(err).Msg(\"Cannot retrieve data\")\n+\t\t}\n+\t})\n+\n+\treturn nil\n+}\n+\n+func (p *Provider) newK8sClient() (*clientWrapper, error) {\n+\twithEndpoint := \"\"\n+\tif p.Endpoint != \"\" {\n+\t\twithEndpoint = fmt.Sprintf(\" with endpoint %v\", p.Endpoint)\n+\t}\n+\n+\tswitch {\n+\tcase os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\" && os.Getenv(\"KUBERNETES_SERVICE_PORT\") != \"\":\n+\t\tlog.Info().Msgf(\"Creating in-cluster Provider client%s\", withEndpoint)\n+\t\treturn newInClusterClient(p.Endpoint)\n+\tcase os.Getenv(\"KUBECONFIG\") != \"\":\n+\t\tlog.Info().Msgf(\"Creating cluster-external Provider client from KUBECONFIG %s\", os.Getenv(\"KUBECONFIG\"))\n+\t\treturn newExternalClusterClientFromFile(os.Getenv(\"KUBECONFIG\"))\n+\tdefault:\n+\t\tlog.Info().Msgf(\"Creating cluster-external Provider client%s\", withEndpoint)\n+\t\treturn newExternalClusterClient(p.Endpoint, p.CertAuthFilePath, p.Token)\n+\t}\n+}\n+\n+func (p *Provider) loadConfiguration(ctx context.Context) *dynamic.Configuration {\n+\tconf := &dynamic.Configuration{\n+\t\tHTTP: &dynamic.HTTPConfiguration{\n+\t\t\tRouters:           map[string]*dynamic.Router{},\n+\t\t\tMiddlewares:       map[string]*dynamic.Middleware{},\n+\t\t\tServices:          map[string]*dynamic.Service{},\n+\t\t\tServersTransports: map[string]*dynamic.ServersTransport{},\n+\t\t},\n+\t\tTCP: &dynamic.TCPConfiguration{\n+\t\t\tRouters:  map[string]*dynamic.TCPRouter{},\n+\t\t\tServices: map[string]*dynamic.TCPService{},\n+\t\t},\n+\t}\n+\n+\t// We configure the default backend when it is configured at the provider level.\n+\tif p.defaultBackendServiceNamespace != \"\" && p.defaultBackendServiceName != \"\" {\n+\t\tib := netv1.IngressBackend{Service: &netv1.IngressServiceBackend{Name: p.defaultBackendServiceName}}\n+\t\tsvc, err := p.buildService(p.defaultBackendServiceNamespace, ib, ingressConfig{})\n+\t\tif err != nil {\n+\t\t\tlog.Ctx(ctx).Error().Err(err).Msg(\"Cannot build default backend service\")\n+\t\t\treturn conf\n+\t\t}\n+\n+\t\t// Add the default backend service router to the configuration.\n+\t\tconf.HTTP.Routers[defaultBackendName] = &dynamic.Router{\n+\t\t\tRule: \"PathPrefix(`/`)\",\n+\t\t\t// \"default\" stands for the default rule syntax in Traefik v3, i.e. the v3 syntax.\n+\t\t\tRuleSyntax: \"default\",\n+\t\t\tPriority:   math.MinInt32,\n+\t\t\tService:    defaultBackendName,\n+\t\t}\n+\n+\t\tconf.HTTP.Routers[defaultBackendTLSName] = &dynamic.Router{\n+\t\t\tRule: \"PathPrefix(`/`)\",\n+\t\t\t// \"default\" stands for the default rule syntax in Traefik v3, i.e. the v3 syntax.\n+\t\t\tRuleSyntax: \"default\",\n+\t\t\tPriority:   math.MinInt32,\n+\t\t\tService:    defaultBackendName,\n+\t\t\tTLS:        &dynamic.RouterTLSConfig{},\n+\t\t}\n+\n+\t\tconf.HTTP.Services[defaultBackendName] = svc\n+\t}\n+\n+\tvar ingressClasses []*netv1.IngressClass\n+\tif !p.k8sClient.IngressClassesIgnored() {",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2158314039",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11844,
        "pr_file": "pkg/provider/kubernetes/ingress-nginx/kubernetes.go",
        "discussion_id": "2158314039",
        "commented_code": "@@ -0,0 +1,1118 @@\n+package ingressnginx\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"maps\"\n+\t\"math\"\n+\t\"net\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/cenkalti/backoff/v4\"\n+\t\"github.com/mitchellh/hashstructure\"\n+\t\"github.com/rs/zerolog/log\"\n+\tptypes \"github.com/traefik/paerser/types\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/job\"\n+\t\"github.com/traefik/traefik/v3/pkg/logs\"\n+\t\"github.com/traefik/traefik/v3/pkg/provider\"\n+\t\"github.com/traefik/traefik/v3/pkg/provider/kubernetes/k8s\"\n+\t\"github.com/traefik/traefik/v3/pkg/safe\"\n+\t\"github.com/traefik/traefik/v3/pkg/tls\"\n+\t\"github.com/traefik/traefik/v3/pkg/types\"\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\tnetv1 \"k8s.io/api/networking/v1\"\n+\t\"k8s.io/utils/ptr\"\n+)\n+\n+const (\n+\tproviderName = \"kubernetesingressnginx\"\n+\n+\tannotationIngressClass = \"kubernetes.io/ingress.class\"\n+\n+\tdefaultControllerName  = \"k8s.io/ingress-nginx\"\n+\tdefaultAnnotationValue = \"nginx\"\n+\n+\tdefaultBackendName    = \"default-backend\"\n+\tdefaultBackendTLSName = \"default-backend-tls\"\n+)\n+\n+type backendAddress struct {\n+\tAddress string\n+\tFenced  bool\n+}\n+\n+type namedServersTransport struct {\n+\tName             string\n+\tServersTransport *dynamic.ServersTransport\n+}\n+\n+type certBlocks struct {\n+\tCA          *types.FileOrContent\n+\tCertificate *tls.Certificate\n+}\n+\n+// Provider holds configurations of the provider.\n+type Provider struct {\n+\tEndpoint         string              `description:\"Kubernetes server endpoint (required for external cluster client).\" json:\"endpoint,omitempty\" toml:\"endpoint,omitempty\" yaml:\"endpoint,omitempty\"`\n+\tToken            types.FileOrContent `description:\"Kubernetes bearer token (not needed for in-cluster client). It accepts either a token value or a file path to the token.\" json:\"token,omitempty\" toml:\"token,omitempty\" yaml:\"token,omitempty\" loggable:\"false\"`\n+\tCertAuthFilePath string              `description:\"Kubernetes certificate authority file path (not needed for in-cluster client).\" json:\"certAuthFilePath,omitempty\" toml:\"certAuthFilePath,omitempty\" yaml:\"certAuthFilePath,omitempty\"`\n+\tThrottleDuration ptypes.Duration     `description:\"Ingress refresh throttle duration.\" json:\"throttleDuration,omitempty\" toml:\"throttleDuration,omitempty\" yaml:\"throttleDuration,omitempty\" export:\"true\"`\n+\n+\tWatchNamespace         string `description:\"Namespace the controller watches for updates to Kubernetes objects. All namespaces are watched if this parameter is left empty.\" json:\"watchNamespace,omitempty\" toml:\"watchNamespace,omitempty\" yaml:\"watchNamespace,omitempty\" export:\"true\"`\n+\tWatchNamespaceSelector string `description:\"Selector selects namespaces the controller watches for updates to Kubernetes objects.\" json:\"watchNamespaceSelector,omitempty\" toml:\"watchNamespaceSelector,omitempty\" yaml:\"watchNamespaceSelector,omitempty\" export:\"true\"`\n+\n+\tIngressClass             string `description:\"Name of the ingress class this controller satisfies.\" json:\"ingressClass,omitempty\" toml:\"ingressClass,omitempty\" yaml:\"ingressClass,omitempty\" export:\"true\"`\n+\tControllerClass          string `description:\"Ingress Class Controller value this controller satisfies.\" json:\"controllerClass,omitempty\" toml:\"controllerClass,omitempty\" yaml:\"controllerClass,omitempty\" export:\"true\"`\n+\tWatchIngressWithoutClass bool   `description:\"Define if Ingress Controller should also watch for Ingresses without an IngressClass or the annotation specified.\" json:\"watchIngressWithoutClass,omitempty\" toml:\"watchIngressWithoutClass,omitempty\" yaml:\"watchIngressWithoutClass,omitempty\" export:\"true\"`\n+\tIngressClassByName       bool   `description:\"Define if Ingress Controller should watch for Ingress Class by Name together with Controller Class.\" json:\"ingressClassByName,omitempty\" toml:\"ingressClassByName,omitempty\" yaml:\"ingressClassByName,omitempty\" export:\"true\"`\n+\n+\t// TODO: support report-node-internal-ip-address and update-status.\n+\tPublishService       string   `description:\"Service fronting the Ingress controller. Takes the form 'namespace/name'.\" json:\"publishService,omitempty\" toml:\"publishService,omitempty\" yaml:\"publishService,omitempty\" export:\"true\"`\n+\tPublishStatusAddress []string `description:\"Customized address (or addresses, separated by comma) to set as the load-balancer status of Ingress objects this controller satisfies.\" json:\"publishStatusAddress,omitempty\" toml:\"publishStatusAddress,omitempty\" yaml:\"publishStatusAddress,omitempty\"`\n+\n+\tDefaultBackendService  string `description:\"Service used to serve HTTP requests not matching any known server name (catch-all). Takes the form 'namespace/name'.\" json:\"defaultBackendService,omitempty\" toml:\"defaultBackendService,omitempty\" yaml:\"defaultBackendService,omitempty\" export:\"true\"`\n+\tDisableSvcExternalName bool   `description:\"Disable support for Services of type ExternalName.\" json:\"disableSvcExternalName,omitempty\" toml:\"disableSvcExternalName,omitempty\" yaml:\"disableSvcExternalName,omitempty\" export:\"true\"`\n+\n+\tdefaultBackendServiceNamespace string\n+\tdefaultBackendServiceName      string\n+\n+\tk8sClient         *clientWrapper\n+\tlastConfiguration safe.Safe\n+}\n+\n+func (p *Provider) SetDefaults() {\n+\tp.IngressClass = defaultAnnotationValue\n+\tp.ControllerClass = defaultControllerName\n+}\n+\n+// Init the provider.\n+func (p *Provider) Init() error {\n+\t// Validates and parses the default backend configuration.\n+\tif p.DefaultBackendService != \"\" {\n+\t\tparts := strings.Split(p.DefaultBackendService, \"/\")\n+\t\tif len(parts) != 2 {\n+\t\t\treturn fmt.Errorf(\"invalid default backend service format: %s, expected 'namespace/name'\", p.DefaultBackendService)\n+\t\t}\n+\t\tp.defaultBackendServiceNamespace = parts[0]\n+\t\tp.defaultBackendServiceName = parts[1]\n+\t}\n+\n+\t// Initializes Kubernetes client.\n+\tvar err error\n+\tp.k8sClient, err = p.newK8sClient()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"creating kubernetes client: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Provide allows the k8s provider to provide configurations to traefik using the given configuration channel.\n+func (p *Provider) Provide(configurationChan chan<- dynamic.Message, pool *safe.Pool) error {\n+\tlogger := log.With().Str(logs.ProviderName, providerName).Logger()\n+\tctxLog := logger.WithContext(context.Background())\n+\n+\tpool.GoCtx(func(ctxPool context.Context) {\n+\t\toperation := func() error {\n+\t\t\teventsChan, err := p.k8sClient.WatchAll(ctxPool, p.WatchNamespace, p.WatchNamespaceSelector)\n+\t\t\tif err != nil {\n+\t\t\t\tlogger.Error().Err(err).Msg(\"Error watching kubernetes events\")\n+\t\t\t\ttimer := time.NewTimer(1 * time.Second)\n+\t\t\t\tselect {\n+\t\t\t\tcase <-timer.C:\n+\t\t\t\t\treturn err\n+\t\t\t\tcase <-ctxPool.Done():\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthrottleDuration := time.Duration(p.ThrottleDuration)\n+\t\t\tthrottledChan := throttleEvents(ctxLog, throttleDuration, pool, eventsChan)\n+\t\t\tif throttledChan != nil {\n+\t\t\t\teventsChan = throttledChan\n+\t\t\t}\n+\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-ctxPool.Done():\n+\t\t\t\t\treturn nil\n+\t\t\t\tcase event := <-eventsChan:\n+\t\t\t\t\t// Note that event is the *first* event that came in during this\n+\t\t\t\t\t// throttling interval -- if we're hitting our throttle, we may have\n+\t\t\t\t\t// dropped events. This is fine, because we don't treat different\n+\t\t\t\t\t// event types differently. But if we do in the future, we'll need to\n+\t\t\t\t\t// track more information about the dropped events.\n+\t\t\t\t\tconf := p.loadConfiguration(ctxLog)\n+\n+\t\t\t\t\tconfHash, err := hashstructure.Hash(conf, nil)\n+\t\t\t\t\tswitch {\n+\t\t\t\t\tcase err != nil:\n+\t\t\t\t\t\tlogger.Error().Msg(\"Unable to hash the configuration\")\n+\t\t\t\t\tcase p.lastConfiguration.Get() == confHash:\n+\t\t\t\t\t\tlogger.Debug().Msgf(\"Skipping Kubernetes event kind %T\", event)\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tp.lastConfiguration.Set(confHash)\n+\t\t\t\t\t\tconfigurationChan <- dynamic.Message{\n+\t\t\t\t\t\t\tProviderName:  providerName,\n+\t\t\t\t\t\t\tConfiguration: conf,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// If we're throttling, we sleep here for the throttle duration to\n+\t\t\t\t\t// enforce that we don't refresh faster than our throttle. time.Sleep\n+\t\t\t\t\t// returns immediately if p.ThrottleDuration is 0 (no throttle).\n+\t\t\t\t\ttime.Sleep(throttleDuration)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tnotify := func(err error, time time.Duration) {\n+\t\t\tlogger.Error().Err(err).Msgf(\"Provider error, retrying in %s\", time)\n+\t\t}\n+\n+\t\terr := backoff.RetryNotify(safe.OperationWithRecover(operation), backoff.WithContext(job.NewBackOff(backoff.NewExponentialBackOff()), ctxPool), notify)\n+\t\tif err != nil {\n+\t\t\tlogger.Error().Err(err).Msg(\"Cannot retrieve data\")\n+\t\t}\n+\t})\n+\n+\treturn nil\n+}\n+\n+func (p *Provider) newK8sClient() (*clientWrapper, error) {\n+\twithEndpoint := \"\"\n+\tif p.Endpoint != \"\" {\n+\t\twithEndpoint = fmt.Sprintf(\" with endpoint %v\", p.Endpoint)\n+\t}\n+\n+\tswitch {\n+\tcase os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\" && os.Getenv(\"KUBERNETES_SERVICE_PORT\") != \"\":\n+\t\tlog.Info().Msgf(\"Creating in-cluster Provider client%s\", withEndpoint)\n+\t\treturn newInClusterClient(p.Endpoint)\n+\tcase os.Getenv(\"KUBECONFIG\") != \"\":\n+\t\tlog.Info().Msgf(\"Creating cluster-external Provider client from KUBECONFIG %s\", os.Getenv(\"KUBECONFIG\"))\n+\t\treturn newExternalClusterClientFromFile(os.Getenv(\"KUBECONFIG\"))\n+\tdefault:\n+\t\tlog.Info().Msgf(\"Creating cluster-external Provider client%s\", withEndpoint)\n+\t\treturn newExternalClusterClient(p.Endpoint, p.CertAuthFilePath, p.Token)\n+\t}\n+}\n+\n+func (p *Provider) loadConfiguration(ctx context.Context) *dynamic.Configuration {\n+\tconf := &dynamic.Configuration{\n+\t\tHTTP: &dynamic.HTTPConfiguration{\n+\t\t\tRouters:           map[string]*dynamic.Router{},\n+\t\t\tMiddlewares:       map[string]*dynamic.Middleware{},\n+\t\t\tServices:          map[string]*dynamic.Service{},\n+\t\t\tServersTransports: map[string]*dynamic.ServersTransport{},\n+\t\t},\n+\t\tTCP: &dynamic.TCPConfiguration{\n+\t\t\tRouters:  map[string]*dynamic.TCPRouter{},\n+\t\t\tServices: map[string]*dynamic.TCPService{},\n+\t\t},\n+\t}\n+\n+\t// We configure the default backend when it is configured at the provider level.\n+\tif p.defaultBackendServiceNamespace != \"\" && p.defaultBackendServiceName != \"\" {\n+\t\tib := netv1.IngressBackend{Service: &netv1.IngressServiceBackend{Name: p.defaultBackendServiceName}}\n+\t\tsvc, err := p.buildService(p.defaultBackendServiceNamespace, ib, ingressConfig{})\n+\t\tif err != nil {\n+\t\t\tlog.Ctx(ctx).Error().Err(err).Msg(\"Cannot build default backend service\")\n+\t\t\treturn conf\n+\t\t}\n+\n+\t\t// Add the default backend service router to the configuration.\n+\t\tconf.HTTP.Routers[defaultBackendName] = &dynamic.Router{\n+\t\t\tRule: \"PathPrefix(`/`)\",\n+\t\t\t// \"default\" stands for the default rule syntax in Traefik v3, i.e. the v3 syntax.\n+\t\t\tRuleSyntax: \"default\",\n+\t\t\tPriority:   math.MinInt32,\n+\t\t\tService:    defaultBackendName,\n+\t\t}\n+\n+\t\tconf.HTTP.Routers[defaultBackendTLSName] = &dynamic.Router{\n+\t\t\tRule: \"PathPrefix(`/`)\",\n+\t\t\t// \"default\" stands for the default rule syntax in Traefik v3, i.e. the v3 syntax.\n+\t\t\tRuleSyntax: \"default\",\n+\t\t\tPriority:   math.MinInt32,\n+\t\t\tService:    defaultBackendName,\n+\t\t\tTLS:        &dynamic.RouterTLSConfig{},\n+\t\t}\n+\n+\t\tconf.HTTP.Services[defaultBackendName] = svc\n+\t}\n+\n+\tvar ingressClasses []*netv1.IngressClass\n+\tif !p.k8sClient.IngressClassesIgnored() {",
        "comment_created_at": "2025-06-20T08:13:07+00:00",
        "comment_author": "lbenguigui",
        "comment_body": "Instead of exporting and using `IngressClassesIgnored`, I\u2019d prefer using a `ListIngressClasses` that internally checks `ingressClassesIgnored` and returns an empty slice when appropriate.",
        "pr_file_module": null
      },
      {
        "comment_id": "2161476991",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11844,
        "pr_file": "pkg/provider/kubernetes/ingress-nginx/kubernetes.go",
        "discussion_id": "2158314039",
        "commented_code": "@@ -0,0 +1,1118 @@\n+package ingressnginx\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"maps\"\n+\t\"math\"\n+\t\"net\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"slices\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/cenkalti/backoff/v4\"\n+\t\"github.com/mitchellh/hashstructure\"\n+\t\"github.com/rs/zerolog/log\"\n+\tptypes \"github.com/traefik/paerser/types\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/job\"\n+\t\"github.com/traefik/traefik/v3/pkg/logs\"\n+\t\"github.com/traefik/traefik/v3/pkg/provider\"\n+\t\"github.com/traefik/traefik/v3/pkg/provider/kubernetes/k8s\"\n+\t\"github.com/traefik/traefik/v3/pkg/safe\"\n+\t\"github.com/traefik/traefik/v3/pkg/tls\"\n+\t\"github.com/traefik/traefik/v3/pkg/types\"\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\tnetv1 \"k8s.io/api/networking/v1\"\n+\t\"k8s.io/utils/ptr\"\n+)\n+\n+const (\n+\tproviderName = \"kubernetesingressnginx\"\n+\n+\tannotationIngressClass = \"kubernetes.io/ingress.class\"\n+\n+\tdefaultControllerName  = \"k8s.io/ingress-nginx\"\n+\tdefaultAnnotationValue = \"nginx\"\n+\n+\tdefaultBackendName    = \"default-backend\"\n+\tdefaultBackendTLSName = \"default-backend-tls\"\n+)\n+\n+type backendAddress struct {\n+\tAddress string\n+\tFenced  bool\n+}\n+\n+type namedServersTransport struct {\n+\tName             string\n+\tServersTransport *dynamic.ServersTransport\n+}\n+\n+type certBlocks struct {\n+\tCA          *types.FileOrContent\n+\tCertificate *tls.Certificate\n+}\n+\n+// Provider holds configurations of the provider.\n+type Provider struct {\n+\tEndpoint         string              `description:\"Kubernetes server endpoint (required for external cluster client).\" json:\"endpoint,omitempty\" toml:\"endpoint,omitempty\" yaml:\"endpoint,omitempty\"`\n+\tToken            types.FileOrContent `description:\"Kubernetes bearer token (not needed for in-cluster client). It accepts either a token value or a file path to the token.\" json:\"token,omitempty\" toml:\"token,omitempty\" yaml:\"token,omitempty\" loggable:\"false\"`\n+\tCertAuthFilePath string              `description:\"Kubernetes certificate authority file path (not needed for in-cluster client).\" json:\"certAuthFilePath,omitempty\" toml:\"certAuthFilePath,omitempty\" yaml:\"certAuthFilePath,omitempty\"`\n+\tThrottleDuration ptypes.Duration     `description:\"Ingress refresh throttle duration.\" json:\"throttleDuration,omitempty\" toml:\"throttleDuration,omitempty\" yaml:\"throttleDuration,omitempty\" export:\"true\"`\n+\n+\tWatchNamespace         string `description:\"Namespace the controller watches for updates to Kubernetes objects. All namespaces are watched if this parameter is left empty.\" json:\"watchNamespace,omitempty\" toml:\"watchNamespace,omitempty\" yaml:\"watchNamespace,omitempty\" export:\"true\"`\n+\tWatchNamespaceSelector string `description:\"Selector selects namespaces the controller watches for updates to Kubernetes objects.\" json:\"watchNamespaceSelector,omitempty\" toml:\"watchNamespaceSelector,omitempty\" yaml:\"watchNamespaceSelector,omitempty\" export:\"true\"`\n+\n+\tIngressClass             string `description:\"Name of the ingress class this controller satisfies.\" json:\"ingressClass,omitempty\" toml:\"ingressClass,omitempty\" yaml:\"ingressClass,omitempty\" export:\"true\"`\n+\tControllerClass          string `description:\"Ingress Class Controller value this controller satisfies.\" json:\"controllerClass,omitempty\" toml:\"controllerClass,omitempty\" yaml:\"controllerClass,omitempty\" export:\"true\"`\n+\tWatchIngressWithoutClass bool   `description:\"Define if Ingress Controller should also watch for Ingresses without an IngressClass or the annotation specified.\" json:\"watchIngressWithoutClass,omitempty\" toml:\"watchIngressWithoutClass,omitempty\" yaml:\"watchIngressWithoutClass,omitempty\" export:\"true\"`\n+\tIngressClassByName       bool   `description:\"Define if Ingress Controller should watch for Ingress Class by Name together with Controller Class.\" json:\"ingressClassByName,omitempty\" toml:\"ingressClassByName,omitempty\" yaml:\"ingressClassByName,omitempty\" export:\"true\"`\n+\n+\t// TODO: support report-node-internal-ip-address and update-status.\n+\tPublishService       string   `description:\"Service fronting the Ingress controller. Takes the form 'namespace/name'.\" json:\"publishService,omitempty\" toml:\"publishService,omitempty\" yaml:\"publishService,omitempty\" export:\"true\"`\n+\tPublishStatusAddress []string `description:\"Customized address (or addresses, separated by comma) to set as the load-balancer status of Ingress objects this controller satisfies.\" json:\"publishStatusAddress,omitempty\" toml:\"publishStatusAddress,omitempty\" yaml:\"publishStatusAddress,omitempty\"`\n+\n+\tDefaultBackendService  string `description:\"Service used to serve HTTP requests not matching any known server name (catch-all). Takes the form 'namespace/name'.\" json:\"defaultBackendService,omitempty\" toml:\"defaultBackendService,omitempty\" yaml:\"defaultBackendService,omitempty\" export:\"true\"`\n+\tDisableSvcExternalName bool   `description:\"Disable support for Services of type ExternalName.\" json:\"disableSvcExternalName,omitempty\" toml:\"disableSvcExternalName,omitempty\" yaml:\"disableSvcExternalName,omitempty\" export:\"true\"`\n+\n+\tdefaultBackendServiceNamespace string\n+\tdefaultBackendServiceName      string\n+\n+\tk8sClient         *clientWrapper\n+\tlastConfiguration safe.Safe\n+}\n+\n+func (p *Provider) SetDefaults() {\n+\tp.IngressClass = defaultAnnotationValue\n+\tp.ControllerClass = defaultControllerName\n+}\n+\n+// Init the provider.\n+func (p *Provider) Init() error {\n+\t// Validates and parses the default backend configuration.\n+\tif p.DefaultBackendService != \"\" {\n+\t\tparts := strings.Split(p.DefaultBackendService, \"/\")\n+\t\tif len(parts) != 2 {\n+\t\t\treturn fmt.Errorf(\"invalid default backend service format: %s, expected 'namespace/name'\", p.DefaultBackendService)\n+\t\t}\n+\t\tp.defaultBackendServiceNamespace = parts[0]\n+\t\tp.defaultBackendServiceName = parts[1]\n+\t}\n+\n+\t// Initializes Kubernetes client.\n+\tvar err error\n+\tp.k8sClient, err = p.newK8sClient()\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"creating kubernetes client: %w\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Provide allows the k8s provider to provide configurations to traefik using the given configuration channel.\n+func (p *Provider) Provide(configurationChan chan<- dynamic.Message, pool *safe.Pool) error {\n+\tlogger := log.With().Str(logs.ProviderName, providerName).Logger()\n+\tctxLog := logger.WithContext(context.Background())\n+\n+\tpool.GoCtx(func(ctxPool context.Context) {\n+\t\toperation := func() error {\n+\t\t\teventsChan, err := p.k8sClient.WatchAll(ctxPool, p.WatchNamespace, p.WatchNamespaceSelector)\n+\t\t\tif err != nil {\n+\t\t\t\tlogger.Error().Err(err).Msg(\"Error watching kubernetes events\")\n+\t\t\t\ttimer := time.NewTimer(1 * time.Second)\n+\t\t\t\tselect {\n+\t\t\t\tcase <-timer.C:\n+\t\t\t\t\treturn err\n+\t\t\t\tcase <-ctxPool.Done():\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthrottleDuration := time.Duration(p.ThrottleDuration)\n+\t\t\tthrottledChan := throttleEvents(ctxLog, throttleDuration, pool, eventsChan)\n+\t\t\tif throttledChan != nil {\n+\t\t\t\teventsChan = throttledChan\n+\t\t\t}\n+\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase <-ctxPool.Done():\n+\t\t\t\t\treturn nil\n+\t\t\t\tcase event := <-eventsChan:\n+\t\t\t\t\t// Note that event is the *first* event that came in during this\n+\t\t\t\t\t// throttling interval -- if we're hitting our throttle, we may have\n+\t\t\t\t\t// dropped events. This is fine, because we don't treat different\n+\t\t\t\t\t// event types differently. But if we do in the future, we'll need to\n+\t\t\t\t\t// track more information about the dropped events.\n+\t\t\t\t\tconf := p.loadConfiguration(ctxLog)\n+\n+\t\t\t\t\tconfHash, err := hashstructure.Hash(conf, nil)\n+\t\t\t\t\tswitch {\n+\t\t\t\t\tcase err != nil:\n+\t\t\t\t\t\tlogger.Error().Msg(\"Unable to hash the configuration\")\n+\t\t\t\t\tcase p.lastConfiguration.Get() == confHash:\n+\t\t\t\t\t\tlogger.Debug().Msgf(\"Skipping Kubernetes event kind %T\", event)\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tp.lastConfiguration.Set(confHash)\n+\t\t\t\t\t\tconfigurationChan <- dynamic.Message{\n+\t\t\t\t\t\t\tProviderName:  providerName,\n+\t\t\t\t\t\t\tConfiguration: conf,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// If we're throttling, we sleep here for the throttle duration to\n+\t\t\t\t\t// enforce that we don't refresh faster than our throttle. time.Sleep\n+\t\t\t\t\t// returns immediately if p.ThrottleDuration is 0 (no throttle).\n+\t\t\t\t\ttime.Sleep(throttleDuration)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tnotify := func(err error, time time.Duration) {\n+\t\t\tlogger.Error().Err(err).Msgf(\"Provider error, retrying in %s\", time)\n+\t\t}\n+\n+\t\terr := backoff.RetryNotify(safe.OperationWithRecover(operation), backoff.WithContext(job.NewBackOff(backoff.NewExponentialBackOff()), ctxPool), notify)\n+\t\tif err != nil {\n+\t\t\tlogger.Error().Err(err).Msg(\"Cannot retrieve data\")\n+\t\t}\n+\t})\n+\n+\treturn nil\n+}\n+\n+func (p *Provider) newK8sClient() (*clientWrapper, error) {\n+\twithEndpoint := \"\"\n+\tif p.Endpoint != \"\" {\n+\t\twithEndpoint = fmt.Sprintf(\" with endpoint %v\", p.Endpoint)\n+\t}\n+\n+\tswitch {\n+\tcase os.Getenv(\"KUBERNETES_SERVICE_HOST\") != \"\" && os.Getenv(\"KUBERNETES_SERVICE_PORT\") != \"\":\n+\t\tlog.Info().Msgf(\"Creating in-cluster Provider client%s\", withEndpoint)\n+\t\treturn newInClusterClient(p.Endpoint)\n+\tcase os.Getenv(\"KUBECONFIG\") != \"\":\n+\t\tlog.Info().Msgf(\"Creating cluster-external Provider client from KUBECONFIG %s\", os.Getenv(\"KUBECONFIG\"))\n+\t\treturn newExternalClusterClientFromFile(os.Getenv(\"KUBECONFIG\"))\n+\tdefault:\n+\t\tlog.Info().Msgf(\"Creating cluster-external Provider client%s\", withEndpoint)\n+\t\treturn newExternalClusterClient(p.Endpoint, p.CertAuthFilePath, p.Token)\n+\t}\n+}\n+\n+func (p *Provider) loadConfiguration(ctx context.Context) *dynamic.Configuration {\n+\tconf := &dynamic.Configuration{\n+\t\tHTTP: &dynamic.HTTPConfiguration{\n+\t\t\tRouters:           map[string]*dynamic.Router{},\n+\t\t\tMiddlewares:       map[string]*dynamic.Middleware{},\n+\t\t\tServices:          map[string]*dynamic.Service{},\n+\t\t\tServersTransports: map[string]*dynamic.ServersTransport{},\n+\t\t},\n+\t\tTCP: &dynamic.TCPConfiguration{\n+\t\t\tRouters:  map[string]*dynamic.TCPRouter{},\n+\t\t\tServices: map[string]*dynamic.TCPService{},\n+\t\t},\n+\t}\n+\n+\t// We configure the default backend when it is configured at the provider level.\n+\tif p.defaultBackendServiceNamespace != \"\" && p.defaultBackendServiceName != \"\" {\n+\t\tib := netv1.IngressBackend{Service: &netv1.IngressServiceBackend{Name: p.defaultBackendServiceName}}\n+\t\tsvc, err := p.buildService(p.defaultBackendServiceNamespace, ib, ingressConfig{})\n+\t\tif err != nil {\n+\t\t\tlog.Ctx(ctx).Error().Err(err).Msg(\"Cannot build default backend service\")\n+\t\t\treturn conf\n+\t\t}\n+\n+\t\t// Add the default backend service router to the configuration.\n+\t\tconf.HTTP.Routers[defaultBackendName] = &dynamic.Router{\n+\t\t\tRule: \"PathPrefix(`/`)\",\n+\t\t\t// \"default\" stands for the default rule syntax in Traefik v3, i.e. the v3 syntax.\n+\t\t\tRuleSyntax: \"default\",\n+\t\t\tPriority:   math.MinInt32,\n+\t\t\tService:    defaultBackendName,\n+\t\t}\n+\n+\t\tconf.HTTP.Routers[defaultBackendTLSName] = &dynamic.Router{\n+\t\t\tRule: \"PathPrefix(`/`)\",\n+\t\t\t// \"default\" stands for the default rule syntax in Traefik v3, i.e. the v3 syntax.\n+\t\t\tRuleSyntax: \"default\",\n+\t\t\tPriority:   math.MinInt32,\n+\t\t\tService:    defaultBackendName,\n+\t\t\tTLS:        &dynamic.RouterTLSConfig{},\n+\t\t}\n+\n+\t\tconf.HTTP.Services[defaultBackendName] = svc\n+\t}\n+\n+\tvar ingressClasses []*netv1.IngressClass\n+\tif !p.k8sClient.IngressClassesIgnored() {",
        "comment_created_at": "2025-06-23T12:13:21+00:00",
        "comment_author": "rtribotte",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2043866805",
    "pr_number": 11203,
    "pr_file": "pkg/provider/kubernetes/ingress/kubernetes.go",
    "created_at": "2025-04-15T07:40:34+00:00",
    "commented_code": "return dupKey, nil\n }\n \n+func buildRule(strictPrefixMatching bool, matcher string, path string) string {\n+\t// When enabled, strictPrefixMatching ensures that prefix matching follows\n+\t// the Kubernetes Ingress spec (path-element-wise instead of character-wise).\n+\tif strictPrefixMatching && matcher == \"PathPrefix\" {\n+\t\t// To mimic Kubernetes behavior (see:\n+\t\t// https://kubernetes.io/docs/concepts/services-networking/ingress/#examples),\n+\t\t// \"/v12\" should not match \"/v1\".\n+\t\t//\n+\t\t// Traefik's default PathPrefix matcher performs a character-wise prefix match,\n+\t\t// unlike Kubernetes which matches path elements.\n+\t\t// Use PathRegexp to replicate element-wise behavior.\n+\t\t//\n+\t\t// See TestPrefixMatchRegex() for examples.\n+\t\treturn \"PathRegexp(`\" + buildPrefixMatchRegex(path) + \"`)\"",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2043866805",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11203,
        "pr_file": "pkg/provider/kubernetes/ingress/kubernetes.go",
        "discussion_id": "2043866805",
        "commented_code": "@@ -844,6 +846,32 @@ func makeRouterKeyWithHash(key, rule string) (string, error) {\n \treturn dupKey, nil\n }\n \n+func buildRule(strictPrefixMatching bool, matcher string, path string) string {\n+\t// When enabled, strictPrefixMatching ensures that prefix matching follows\n+\t// the Kubernetes Ingress spec (path-element-wise instead of character-wise).\n+\tif strictPrefixMatching && matcher == \"PathPrefix\" {\n+\t\t// To mimic Kubernetes behavior (see:\n+\t\t// https://kubernetes.io/docs/concepts/services-networking/ingress/#examples),\n+\t\t// \"/v12\" should not match \"/v1\".\n+\t\t//\n+\t\t// Traefik's default PathPrefix matcher performs a character-wise prefix match,\n+\t\t// unlike Kubernetes which matches path elements.\n+\t\t// Use PathRegexp to replicate element-wise behavior.\n+\t\t//\n+\t\t// See TestPrefixMatchRegex() for examples.\n+\t\treturn \"PathRegexp(`\" + buildPrefixMatchRegex(path) + \"`)\"",
        "comment_created_at": "2025-04-15T07:40:34+00:00",
        "comment_author": "kevinpollet",
        "comment_body": "I think it would be great using a matcher combination to be consistent with the Kubernetes Gateway provider (which also complies with the Ingress matching specification), something like: https://github.com/traefik/traefik/blob/master/pkg/provider/kubernetes/gateway/httproute.go#L645",
        "pr_file_module": null
      },
      {
        "comment_id": "2051725336",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11203,
        "pr_file": "pkg/provider/kubernetes/ingress/kubernetes.go",
        "discussion_id": "2043866805",
        "commented_code": "@@ -844,6 +846,32 @@ func makeRouterKeyWithHash(key, rule string) (string, error) {\n \treturn dupKey, nil\n }\n \n+func buildRule(strictPrefixMatching bool, matcher string, path string) string {\n+\t// When enabled, strictPrefixMatching ensures that prefix matching follows\n+\t// the Kubernetes Ingress spec (path-element-wise instead of character-wise).\n+\tif strictPrefixMatching && matcher == \"PathPrefix\" {\n+\t\t// To mimic Kubernetes behavior (see:\n+\t\t// https://kubernetes.io/docs/concepts/services-networking/ingress/#examples),\n+\t\t// \"/v12\" should not match \"/v1\".\n+\t\t//\n+\t\t// Traefik's default PathPrefix matcher performs a character-wise prefix match,\n+\t\t// unlike Kubernetes which matches path elements.\n+\t\t// Use PathRegexp to replicate element-wise behavior.\n+\t\t//\n+\t\t// See TestPrefixMatchRegex() for examples.\n+\t\treturn \"PathRegexp(`\" + buildPrefixMatchRegex(path) + \"`)\"",
        "comment_created_at": "2025-04-20T13:29:32+00:00",
        "comment_author": "charlie0129",
        "comment_body": "I think I can extract a common function (in gateway pkg) to build Path Prefix rules to avoid duplicating code. WDYT?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1616129890",
    "pr_number": 10211,
    "pr_file": "pkg/middlewares/ratelimiter/redisrate/lua.go",
    "created_at": "2024-05-27T14:30:13+00:00",
    "commented_code": "+package redisrate\n+\n+import \"github.com/redis/go-redis/v9\"\n+\n+//nolint:dupword\n+var allowTokenBucket = redis.NewScript(`\n+local key = KEYS[1]\n+local limit, burst, ttl, t, n, max_delay = tonumber(ARGV[1]), tonumber(ARGV[2]), tonumber(ARGV[3]), tonumber(ARGV[4]),",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "1616129890",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/middlewares/ratelimiter/redisrate/lua.go",
        "discussion_id": "1616129890",
        "commented_code": "@@ -0,0 +1,56 @@\n+package redisrate\n+\n+import \"github.com/redis/go-redis/v9\"\n+\n+//nolint:dupword\n+var allowTokenBucket = redis.NewScript(`\n+local key = KEYS[1]\n+local limit, burst, ttl, t, n, max_delay = tonumber(ARGV[1]), tonumber(ARGV[2]), tonumber(ARGV[3]), tonumber(ARGV[4]),",
        "comment_created_at": "2024-05-27T14:30:13+00:00",
        "comment_author": "jspdown",
        "comment_body": "Since we are always going to take 1 request from the bucket, I think we can remove the `n` parameter. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1618664432",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/middlewares/ratelimiter/redisrate/lua.go",
        "discussion_id": "1616129890",
        "commented_code": "@@ -0,0 +1,56 @@\n+package redisrate\n+\n+import \"github.com/redis/go-redis/v9\"\n+\n+//nolint:dupword\n+var allowTokenBucket = redis.NewScript(`\n+local key = KEYS[1]\n+local limit, burst, ttl, t, n, max_delay = tonumber(ARGV[1]), tonumber(ARGV[2]), tonumber(ARGV[3]), tonumber(ARGV[4]),",
        "comment_created_at": "2024-05-29T10:42:38+00:00",
        "comment_author": "longquan0104",
        "comment_body": "If we remove the `n` Parameter, I think I have to remove this function too `AllowTokenBucketN` and replace it with `Allow` only without depending on `n`",
        "pr_file_module": null
      }
    ]
  }
]