[
  {
    "discussion_id": "2039571260",
    "pr_number": 11351,
    "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
    "created_at": "2025-04-11T13:30:33+00:00",
    "commented_code": "http.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2039571260",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039571260",
        "commented_code": "@@ -256,12 +306,30 @@ func (b *Balancer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\thttp.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
        "comment_created_at": "2025-04-11T13:30:33+00:00",
        "comment_author": "sdelicata",
        "comment_body": "The current server selection logic may be inefficient: we first pick a server with nextServer, then retry once with nextServerExcluding if the passive health checker blocks the request. However, the second server might also be disallowed due to recent failures, causing the request to fail even though other healthy servers might still be available. A different approach\u2014handling passive health checks at the load balancer level\u2014could enable more efficient server selection by filtering out unhealthy servers before picking one.\nI'd appreciate input from other maintainers on this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2062206024",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039571260",
        "commented_code": "@@ -256,12 +306,30 @@ func (b *Balancer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\thttp.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
        "comment_created_at": "2025-04-27T04:57:12+00:00",
        "comment_author": "Nelwhix",
        "comment_body": "what if I modify the loop in nextServer to:\r\n\r\n```go\r\nfor {\r\n  // Pick handler with closest deadline.\r\n  handler = heap.Pop(b).(*namedHandler)\r\n  \r\n  // curDeadline should be handler's deadline so that new added entry would have a fair competition environment with the old ones.\r\n  b.curDeadline = handler.deadline\r\n  handler.deadline += 1 / handler.weight\r\n  \r\n  heap.Push(b, handler)\r\n  \r\n  // Skip if:\r\n  if _, down := b.status[handler.name]; !down {\r\n      continue\r\n  }\r\n\r\n  if _, isFenced := b.fenced[handler.name]; isFenced {\r\n      continue\r\n  }\r\n\r\n  if handler.passiveHealthChecker != nil && !handler.passiveHealthChecker.AllowRequest() {\r\n      continue\r\n  }\r\n}\r\n```\r\n\r\nWith this we don't need nextServerExcluding... the filtering happens when selecting a server",
        "pr_file_module": null
      },
      {
        "comment_id": "2081954703",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039571260",
        "commented_code": "@@ -256,12 +306,30 @@ func (b *Balancer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\thttp.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
        "comment_created_at": "2025-05-09T15:39:08+00:00",
        "comment_author": "sdelicata",
        "comment_body": "Yes, personally, I prefer this approach.",
        "pr_file_module": null
      },
      {
        "comment_id": "2083238706",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039571260",
        "commented_code": "@@ -256,12 +306,30 @@ func (b *Balancer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\thttp.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
        "comment_created_at": "2025-05-10T16:54:48+00:00",
        "comment_author": "nelwhix-appfront",
        "comment_body": "okay, I have added it",
        "pr_file_module": null
      },
      {
        "comment_id": "2084562252",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039571260",
        "commented_code": "@@ -256,12 +306,30 @@ func (b *Balancer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\thttp.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
        "comment_created_at": "2025-05-12T12:25:12+00:00",
        "comment_author": "sdelicata",
        "comment_body": "Thanks!\r\nCan you rebase your PR, add documentation, and regenerate the reference configuration accordingly, please?",
        "pr_file_module": null
      },
      {
        "comment_id": "2094136658",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039571260",
        "commented_code": "@@ -256,12 +306,30 @@ func (b *Balancer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\thttp.SetCookie(w, cookie)\n \t}\n \n-\tserver.ServeHTTP(w, req)\n+\tcustomWriter := &CustomResponseWriter{ResponseWriter: w, StatusCode: http.StatusOK}",
        "comment_created_at": "2025-05-17T14:25:49+00:00",
        "comment_author": "Nelwhix",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1863207598",
    "pr_number": 11121,
    "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
    "created_at": "2024-11-29T09:18:39+00:00",
    "commented_code": "heap.Push(b, handler)\n \t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tbreak\n+\t\t\tif _, ok := b.fenced[handler.name]; !ok {",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "1863207598",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11121,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "1863207598",
        "commented_code": "@@ -189,7 +193,10 @@ func (b *Balancer) nextServer() (*namedHandler, error) {\n \n \t\theap.Push(b, handler)\n \t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tbreak\n+\t\t\tif _, ok := b.fenced[handler.name]; !ok {",
        "comment_created_at": "2024-11-29T09:18:39+00:00",
        "comment_author": "lbenguigui",
        "comment_body": "Unless I missed something, there seems to be an issue here. If all handlers are fenced, the for loop will hang indefinitely. I suppose we need to ensure that there is at least one handler referenced in status that is not fenced.",
        "pr_file_module": null
      },
      {
        "comment_id": "1863283716",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11121,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "1863207598",
        "commented_code": "@@ -189,7 +193,10 @@ func (b *Balancer) nextServer() (*namedHandler, error) {\n \n \t\theap.Push(b, handler)\n \t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tbreak\n+\t\t\tif _, ok := b.fenced[handler.name]; !ok {",
        "comment_created_at": "2024-11-29T10:11:37+00:00",
        "comment_author": "BZValoche",
        "comment_body": "You are correct, I added an exit condition to check for this case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1867264925",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11121,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "1863207598",
        "commented_code": "@@ -189,7 +193,10 @@ func (b *Balancer) nextServer() (*namedHandler, error) {\n \n \t\theap.Push(b, handler)\n \t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tbreak\n+\t\t\tif _, ok := b.fenced[handler.name]; !ok {",
        "comment_created_at": "2024-12-03T08:38:40+00:00",
        "comment_author": "BZValoche",
        "comment_body": "I also added a test for this particular case.",
        "pr_file_module": null
      }
    ]
  }
]