[
  {
    "discussion_id": "2215637142",
    "pr_number": 11906,
    "pr_file": "cmd/traefik/traefik.go",
    "created_at": "2025-07-18T10:00:59+00:00",
    "commented_code": "}\n \n func runCmd(staticConfiguration *static.Configuration) error {\n-\tif err := setupLogger(staticConfiguration); err != nil {\n+\tif err := setupLogger(context.Background(), staticConfiguration); err != nil {",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2215637142",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11906,
        "pr_file": "cmd/traefik/traefik.go",
        "discussion_id": "2215637142",
        "commented_code": "@@ -90,7 +90,7 @@ Complete documentation is available at https://traefik.io`,\n }\n \n func runCmd(staticConfiguration *static.Configuration) error {\n-\tif err := setupLogger(staticConfiguration); err != nil {\n+\tif err := setupLogger(context.Background(), staticConfiguration); err != nil {",
        "comment_created_at": "2025-07-18T10:00:59+00:00",
        "comment_author": "sdelicata",
        "comment_body": "Maybe I missed something, but is it intentional to not use the same context as the one declared few line below?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1616078002",
    "pr_number": 10211,
    "pr_file": "pkg/middlewares/ratelimiter/redis_limiter.go",
    "created_at": "2024-05-27T13:47:12+00:00",
    "commented_code": "+package ratelimiter\n+\n+import (\n+\t\"context\"\n+\t\"time\"\n+\n+\t\"github.com/redis/go-redis/v9\"\n+\t\"github.com/rs/zerolog\"\n+\tptypes \"github.com/traefik/paerser/types\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/middlewares/ratelimiter/redisrate\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+type RedisLimiter struct {\n+\trate     rate.Limit // reqs/s\n+\tburst    int64\n+\tmaxDelay time.Duration\n+\n+\tperiod  ptypes.Duration\n+\tlogger  *zerolog.Logger\n+\tlimiter *redisrate.Limiter\n+}\n+\n+func NewRedisLimiter(\n+\trate rate.Limit,\n+\tburst int64,\n+\tmaxDelay time.Duration,\n+\tttl int,\n+\tconfig dynamic.RateLimit,\n+\tlogger *zerolog.Logger,\n+) (Limiter, error) {\n+\toptions := &redis.UniversalOptions{\n+\t\tAddrs:        config.Redis.Endpoints,\n+\t\tUsername:     config.Redis.Username,\n+\t\tPassword:     config.Redis.Password,\n+\t\tDB:           config.Redis.DB,\n+\t\tPoolSize:     config.Redis.PoolSize,\n+\t\tMinIdleConns: config.Redis.MinIdleConns,\n+\t\tReadTimeout:  config.Redis.ReadTimeout,\n+\t\tWriteTimeout: config.Redis.WriteTimeout,\n+\t\tDialTimeout:  config.Redis.DialTimeout,\n+\t}\n+\tif config.Redis.TLS != nil {\n+\t\ttlsConfig, err := config.Redis.TLS.CreateTLSConfig(context.Background())\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\toptions.TLSConfig = tlsConfig\n+\t}\n+\n+\tlimiter := redisrate.NewLimiter(redis.NewUniversalClient(options), ttl, maxDelay)\n+\n+\treturn &RedisLimiter{\n+\t\trate:     rate,\n+\t\tburst:    burst,\n+\t\tperiod:   config.Period,\n+\t\tmaxDelay: maxDelay,\n+\t\tlogger:   logger,\n+\t\tlimiter:  limiter,\n+\t}, nil\n+}\n+\n+func (r *RedisLimiter) Allow(ctx context.Context, source string) (Result, error) {\n+\tres, err := r.limiter.Allow(\n+\t\tctx,\n+\t\tsource,\n+\t\tredisrate.Limit{\n+\t\t\tRate:   r.rate,\n+\t\t\tPeriod: time.Duration(r.period),\n+\t\t\tBurst:  r.burst,\n+\t\t},\n+\t)\n+\tif err != nil {\n+\t\treturn Result{\n+\t\t\tOk: false,\n+\t\t}, err\n+\t}\n+\n+\tif !res.Ok {\n+\t\treturn Result{\n+\t\t\tOk: false,\n+\t\t}, nil\n+\t}\n+\n+\tif res.Delay > r.maxDelay {\n+\t\treturn Result{\n+\t\t\tOk:    false,\n+\t\t\tDelay: res.Delay,\n+\t\t}, nil\n+\t}\n+\n+\ttime.Sleep(res.Delay)",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "1616078002",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/middlewares/ratelimiter/redis_limiter.go",
        "discussion_id": "1616078002",
        "commented_code": "@@ -0,0 +1,100 @@\n+package ratelimiter\n+\n+import (\n+\t\"context\"\n+\t\"time\"\n+\n+\t\"github.com/redis/go-redis/v9\"\n+\t\"github.com/rs/zerolog\"\n+\tptypes \"github.com/traefik/paerser/types\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/middlewares/ratelimiter/redisrate\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+type RedisLimiter struct {\n+\trate     rate.Limit // reqs/s\n+\tburst    int64\n+\tmaxDelay time.Duration\n+\n+\tperiod  ptypes.Duration\n+\tlogger  *zerolog.Logger\n+\tlimiter *redisrate.Limiter\n+}\n+\n+func NewRedisLimiter(\n+\trate rate.Limit,\n+\tburst int64,\n+\tmaxDelay time.Duration,\n+\tttl int,\n+\tconfig dynamic.RateLimit,\n+\tlogger *zerolog.Logger,\n+) (Limiter, error) {\n+\toptions := &redis.UniversalOptions{\n+\t\tAddrs:        config.Redis.Endpoints,\n+\t\tUsername:     config.Redis.Username,\n+\t\tPassword:     config.Redis.Password,\n+\t\tDB:           config.Redis.DB,\n+\t\tPoolSize:     config.Redis.PoolSize,\n+\t\tMinIdleConns: config.Redis.MinIdleConns,\n+\t\tReadTimeout:  config.Redis.ReadTimeout,\n+\t\tWriteTimeout: config.Redis.WriteTimeout,\n+\t\tDialTimeout:  config.Redis.DialTimeout,\n+\t}\n+\tif config.Redis.TLS != nil {\n+\t\ttlsConfig, err := config.Redis.TLS.CreateTLSConfig(context.Background())\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\toptions.TLSConfig = tlsConfig\n+\t}\n+\n+\tlimiter := redisrate.NewLimiter(redis.NewUniversalClient(options), ttl, maxDelay)\n+\n+\treturn &RedisLimiter{\n+\t\trate:     rate,\n+\t\tburst:    burst,\n+\t\tperiod:   config.Period,\n+\t\tmaxDelay: maxDelay,\n+\t\tlogger:   logger,\n+\t\tlimiter:  limiter,\n+\t}, nil\n+}\n+\n+func (r *RedisLimiter) Allow(ctx context.Context, source string) (Result, error) {\n+\tres, err := r.limiter.Allow(\n+\t\tctx,\n+\t\tsource,\n+\t\tredisrate.Limit{\n+\t\t\tRate:   r.rate,\n+\t\t\tPeriod: time.Duration(r.period),\n+\t\t\tBurst:  r.burst,\n+\t\t},\n+\t)\n+\tif err != nil {\n+\t\treturn Result{\n+\t\t\tOk: false,\n+\t\t}, err\n+\t}\n+\n+\tif !res.Ok {\n+\t\treturn Result{\n+\t\t\tOk: false,\n+\t\t}, nil\n+\t}\n+\n+\tif res.Delay > r.maxDelay {\n+\t\treturn Result{\n+\t\t\tOk:    false,\n+\t\t\tDelay: res.Delay,\n+\t\t}, nil\n+\t}\n+\n+\ttime.Sleep(res.Delay)",
        "comment_created_at": "2024-05-27T13:47:12+00:00",
        "comment_author": "jspdown",
        "comment_body": "WDYT about moving this piece in the `rateLimiter`'s `ServerHTTP` method? Since `Allow` returns a `Result` with the `Delay` field set, the caller might expect to be the one doing the sleep. It would also have the side benefit of removing the duplication in the different limiter implementations. \r\n\r\nAlso, could you replace the `time.Sleep` by something like this:\r\n\r\n```go\r\nselect {\r\ncase <-ctx.Done():\r\n    return Result{Ok: false}, nil\r\ncase <-time.After(res.Delay):\r\n}\r\n```\r\n\r\nJust to avoid keeping goroutines of a canceled request around.",
        "pr_file_module": null
      },
      {
        "comment_id": "1620124698",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/middlewares/ratelimiter/redis_limiter.go",
        "discussion_id": "1616078002",
        "commented_code": "@@ -0,0 +1,100 @@\n+package ratelimiter\n+\n+import (\n+\t\"context\"\n+\t\"time\"\n+\n+\t\"github.com/redis/go-redis/v9\"\n+\t\"github.com/rs/zerolog\"\n+\tptypes \"github.com/traefik/paerser/types\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/middlewares/ratelimiter/redisrate\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+type RedisLimiter struct {\n+\trate     rate.Limit // reqs/s\n+\tburst    int64\n+\tmaxDelay time.Duration\n+\n+\tperiod  ptypes.Duration\n+\tlogger  *zerolog.Logger\n+\tlimiter *redisrate.Limiter\n+}\n+\n+func NewRedisLimiter(\n+\trate rate.Limit,\n+\tburst int64,\n+\tmaxDelay time.Duration,\n+\tttl int,\n+\tconfig dynamic.RateLimit,\n+\tlogger *zerolog.Logger,\n+) (Limiter, error) {\n+\toptions := &redis.UniversalOptions{\n+\t\tAddrs:        config.Redis.Endpoints,\n+\t\tUsername:     config.Redis.Username,\n+\t\tPassword:     config.Redis.Password,\n+\t\tDB:           config.Redis.DB,\n+\t\tPoolSize:     config.Redis.PoolSize,\n+\t\tMinIdleConns: config.Redis.MinIdleConns,\n+\t\tReadTimeout:  config.Redis.ReadTimeout,\n+\t\tWriteTimeout: config.Redis.WriteTimeout,\n+\t\tDialTimeout:  config.Redis.DialTimeout,\n+\t}\n+\tif config.Redis.TLS != nil {\n+\t\ttlsConfig, err := config.Redis.TLS.CreateTLSConfig(context.Background())\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\toptions.TLSConfig = tlsConfig\n+\t}\n+\n+\tlimiter := redisrate.NewLimiter(redis.NewUniversalClient(options), ttl, maxDelay)\n+\n+\treturn &RedisLimiter{\n+\t\trate:     rate,\n+\t\tburst:    burst,\n+\t\tperiod:   config.Period,\n+\t\tmaxDelay: maxDelay,\n+\t\tlogger:   logger,\n+\t\tlimiter:  limiter,\n+\t}, nil\n+}\n+\n+func (r *RedisLimiter) Allow(ctx context.Context, source string) (Result, error) {\n+\tres, err := r.limiter.Allow(\n+\t\tctx,\n+\t\tsource,\n+\t\tredisrate.Limit{\n+\t\t\tRate:   r.rate,\n+\t\t\tPeriod: time.Duration(r.period),\n+\t\t\tBurst:  r.burst,\n+\t\t},\n+\t)\n+\tif err != nil {\n+\t\treturn Result{\n+\t\t\tOk: false,\n+\t\t}, err\n+\t}\n+\n+\tif !res.Ok {\n+\t\treturn Result{\n+\t\t\tOk: false,\n+\t\t}, nil\n+\t}\n+\n+\tif res.Delay > r.maxDelay {\n+\t\treturn Result{\n+\t\t\tOk:    false,\n+\t\t\tDelay: res.Delay,\n+\t\t}, nil\n+\t}\n+\n+\ttime.Sleep(res.Delay)",
        "comment_created_at": "2024-05-30T07:24:55+00:00",
        "comment_author": "longquan0104",
        "comment_body": "I keep this here to make it more like the `in_memory` `Allow` and in the `in_memory` `Allow`, I think the reservation Cancel in the `in_memory` `Allow` is necessary.",
        "pr_file_module": null
      }
    ]
  }
]