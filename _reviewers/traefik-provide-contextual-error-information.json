[
  {
    "discussion_id": "2039091729",
    "pr_number": 11238,
    "pr_file": "pkg/healthcheck/tcp.go",
    "created_at": "2025-04-11T08:41:47+00:00",
    "commented_code": "+package healthcheck\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/runtime\"\n+\t\"github.com/traefik/traefik/v3/pkg/tcp\"\n+)\n+\n+type ServiceTCPHealthChecker struct {\n+\tdialerManager *tcp.DialerManager\n+\tbalancer      StatusSetter\n+\tinfo          *runtime.TCPServiceInfo\n+\n+\tconfig   *dynamic.TCPServerHealthCheck\n+\tinterval time.Duration\n+\ttimeout  time.Duration\n+\n+\tmetrics metricsHealthCheck\n+\n+\ttargets     map[string]*net.TCPAddr\n+\tserviceName string\n+}\n+\n+func NewServiceTCPHealthChecker(dialerManager *tcp.DialerManager, metrics metricsHealthCheck, config *dynamic.TCPServerHealthCheck, service StatusSetter, info *runtime.TCPServiceInfo, targets map[string]*net.TCPAddr, serviceName string) *ServiceTCPHealthChecker {\n+\tinterval := time.Duration(config.Interval)\n+\tif interval <= 0 {\n+\t\tlog.Error().Msg(\"Health check interval smaller than zero\")\n+\t\tinterval = time.Duration(dynamic.DefaultHealthCheckInterval)\n+\t}\n+\n+\ttimeout := time.Duration(config.Timeout)\n+\tif timeout <= 0 {\n+\t\tlog.Error().Msg(\"Health check timeout smaller than zero\")\n+\t\ttimeout = time.Duration(dynamic.DefaultHealthCheckTimeout)\n+\t}\n+\n+\treturn &ServiceTCPHealthChecker{\n+\t\tdialerManager: dialerManager,\n+\t\tbalancer:      service,\n+\t\tinfo:          info,\n+\t\tconfig:        config,\n+\t\tinterval:      interval,\n+\t\ttimeout:       timeout,\n+\t\tmetrics:       metrics,\n+\t\ttargets:       targets,\n+\t\tserviceName:   serviceName,\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Launch(ctx context.Context) {\n+\tticker := time.NewTicker(thc.interval)\n+\tdefer ticker.Stop()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tthc.Check(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Check(ctx context.Context) {\n+\tfor proxyName, target := range thc.targets {\n+\t\tif ctx.Err() != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tisUp := true\n+\t\tserverUpMetricValue := float64(1)\n+\n+\t\tif err := thc.executeHealthCheck(ctx, thc.config, target); err != nil {\n+\t\t\t// The context is canceled when the dynamic configuration is refreshed.\n+\t\t\tif errors.Is(err, context.Canceled) {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tlog.Ctx(ctx).Warn().\n+\t\t\t\tStr(\"targetURL\", target.String()).\n+\t\t\t\tErr(err).\n+\t\t\t\tMsg(\"Health check failed.\")\n+\n+\t\t\tisUp = false\n+\t\t\tserverUpMetricValue = float64(0)\n+\t\t}\n+\n+\t\tthc.balancer.SetStatus(ctx, proxyName, isUp)\n+\n+\t\tthc.info.UpdateServerStatus(target.String(), isUp)\n+\n+\t\tthc.metrics.ServiceServerUpGauge().\n+\t\t\tWith(\"service\", thc.serviceName, \"url\", target.String()).\n+\t\t\tSet(serverUpMetricValue)\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) executeHealthCheck(_ context.Context, config *dynamic.TCPServerHealthCheck, target *net.TCPAddr) error {\n+\tdialer, err := thc.dialerManager.Get(config.ServersTransport, config.TLS)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tconn, err := dialer.Dial(\"tcp\", target.String())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer conn.Close()\n+\n+\tif config.Payload != \"\" {\n+\t\t_, err = conn.Write([]byte(config.Payload))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tif config.Expected != \"\" {\n+\t\terr := conn.SetReadDeadline(time.Now().Add(thc.timeout))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tbuf := make([]byte, len(config.Expected))\n+\t\t_, err = conn.Read(buf)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif string(buf) != config.Expected {\n+\t\t\treturn errors.New(\"unexpected response\")\n+\t\t}",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2039091729",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11238,
        "pr_file": "pkg/healthcheck/tcp.go",
        "discussion_id": "2039091729",
        "commented_code": "@@ -0,0 +1,141 @@\n+package healthcheck\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/runtime\"\n+\t\"github.com/traefik/traefik/v3/pkg/tcp\"\n+)\n+\n+type ServiceTCPHealthChecker struct {\n+\tdialerManager *tcp.DialerManager\n+\tbalancer      StatusSetter\n+\tinfo          *runtime.TCPServiceInfo\n+\n+\tconfig   *dynamic.TCPServerHealthCheck\n+\tinterval time.Duration\n+\ttimeout  time.Duration\n+\n+\tmetrics metricsHealthCheck\n+\n+\ttargets     map[string]*net.TCPAddr\n+\tserviceName string\n+}\n+\n+func NewServiceTCPHealthChecker(dialerManager *tcp.DialerManager, metrics metricsHealthCheck, config *dynamic.TCPServerHealthCheck, service StatusSetter, info *runtime.TCPServiceInfo, targets map[string]*net.TCPAddr, serviceName string) *ServiceTCPHealthChecker {\n+\tinterval := time.Duration(config.Interval)\n+\tif interval <= 0 {\n+\t\tlog.Error().Msg(\"Health check interval smaller than zero\")\n+\t\tinterval = time.Duration(dynamic.DefaultHealthCheckInterval)\n+\t}\n+\n+\ttimeout := time.Duration(config.Timeout)\n+\tif timeout <= 0 {\n+\t\tlog.Error().Msg(\"Health check timeout smaller than zero\")\n+\t\ttimeout = time.Duration(dynamic.DefaultHealthCheckTimeout)\n+\t}\n+\n+\treturn &ServiceTCPHealthChecker{\n+\t\tdialerManager: dialerManager,\n+\t\tbalancer:      service,\n+\t\tinfo:          info,\n+\t\tconfig:        config,\n+\t\tinterval:      interval,\n+\t\ttimeout:       timeout,\n+\t\tmetrics:       metrics,\n+\t\ttargets:       targets,\n+\t\tserviceName:   serviceName,\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Launch(ctx context.Context) {\n+\tticker := time.NewTicker(thc.interval)\n+\tdefer ticker.Stop()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tthc.Check(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Check(ctx context.Context) {\n+\tfor proxyName, target := range thc.targets {\n+\t\tif ctx.Err() != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tisUp := true\n+\t\tserverUpMetricValue := float64(1)\n+\n+\t\tif err := thc.executeHealthCheck(ctx, thc.config, target); err != nil {\n+\t\t\t// The context is canceled when the dynamic configuration is refreshed.\n+\t\t\tif errors.Is(err, context.Canceled) {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tlog.Ctx(ctx).Warn().\n+\t\t\t\tStr(\"targetURL\", target.String()).\n+\t\t\t\tErr(err).\n+\t\t\t\tMsg(\"Health check failed.\")\n+\n+\t\t\tisUp = false\n+\t\t\tserverUpMetricValue = float64(0)\n+\t\t}\n+\n+\t\tthc.balancer.SetStatus(ctx, proxyName, isUp)\n+\n+\t\tthc.info.UpdateServerStatus(target.String(), isUp)\n+\n+\t\tthc.metrics.ServiceServerUpGauge().\n+\t\t\tWith(\"service\", thc.serviceName, \"url\", target.String()).\n+\t\t\tSet(serverUpMetricValue)\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) executeHealthCheck(_ context.Context, config *dynamic.TCPServerHealthCheck, target *net.TCPAddr) error {\n+\tdialer, err := thc.dialerManager.Get(config.ServersTransport, config.TLS)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tconn, err := dialer.Dial(\"tcp\", target.String())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer conn.Close()\n+\n+\tif config.Payload != \"\" {\n+\t\t_, err = conn.Write([]byte(config.Payload))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tif config.Expected != \"\" {\n+\t\terr := conn.SetReadDeadline(time.Now().Add(thc.timeout))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tbuf := make([]byte, len(config.Expected))\n+\t\t_, err = conn.Read(buf)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif string(buf) != config.Expected {\n+\t\t\treturn errors.New(\"unexpected response\")\n+\t\t}",
        "comment_created_at": "2025-04-11T08:41:47+00:00",
        "comment_author": "sdelicata",
        "comment_body": "This may be unnecessary here, but I'm wondering if errors should be wrapped. What are the opinions of other maintainers?",
        "pr_file_module": null
      },
      {
        "comment_id": "2200851340",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11238,
        "pr_file": "pkg/healthcheck/tcp.go",
        "discussion_id": "2039091729",
        "commented_code": "@@ -0,0 +1,141 @@\n+package healthcheck\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/runtime\"\n+\t\"github.com/traefik/traefik/v3/pkg/tcp\"\n+)\n+\n+type ServiceTCPHealthChecker struct {\n+\tdialerManager *tcp.DialerManager\n+\tbalancer      StatusSetter\n+\tinfo          *runtime.TCPServiceInfo\n+\n+\tconfig   *dynamic.TCPServerHealthCheck\n+\tinterval time.Duration\n+\ttimeout  time.Duration\n+\n+\tmetrics metricsHealthCheck\n+\n+\ttargets     map[string]*net.TCPAddr\n+\tserviceName string\n+}\n+\n+func NewServiceTCPHealthChecker(dialerManager *tcp.DialerManager, metrics metricsHealthCheck, config *dynamic.TCPServerHealthCheck, service StatusSetter, info *runtime.TCPServiceInfo, targets map[string]*net.TCPAddr, serviceName string) *ServiceTCPHealthChecker {\n+\tinterval := time.Duration(config.Interval)\n+\tif interval <= 0 {\n+\t\tlog.Error().Msg(\"Health check interval smaller than zero\")\n+\t\tinterval = time.Duration(dynamic.DefaultHealthCheckInterval)\n+\t}\n+\n+\ttimeout := time.Duration(config.Timeout)\n+\tif timeout <= 0 {\n+\t\tlog.Error().Msg(\"Health check timeout smaller than zero\")\n+\t\ttimeout = time.Duration(dynamic.DefaultHealthCheckTimeout)\n+\t}\n+\n+\treturn &ServiceTCPHealthChecker{\n+\t\tdialerManager: dialerManager,\n+\t\tbalancer:      service,\n+\t\tinfo:          info,\n+\t\tconfig:        config,\n+\t\tinterval:      interval,\n+\t\ttimeout:       timeout,\n+\t\tmetrics:       metrics,\n+\t\ttargets:       targets,\n+\t\tserviceName:   serviceName,\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Launch(ctx context.Context) {\n+\tticker := time.NewTicker(thc.interval)\n+\tdefer ticker.Stop()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tthc.Check(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Check(ctx context.Context) {\n+\tfor proxyName, target := range thc.targets {\n+\t\tif ctx.Err() != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tisUp := true\n+\t\tserverUpMetricValue := float64(1)\n+\n+\t\tif err := thc.executeHealthCheck(ctx, thc.config, target); err != nil {\n+\t\t\t// The context is canceled when the dynamic configuration is refreshed.\n+\t\t\tif errors.Is(err, context.Canceled) {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tlog.Ctx(ctx).Warn().\n+\t\t\t\tStr(\"targetURL\", target.String()).\n+\t\t\t\tErr(err).\n+\t\t\t\tMsg(\"Health check failed.\")\n+\n+\t\t\tisUp = false\n+\t\t\tserverUpMetricValue = float64(0)\n+\t\t}\n+\n+\t\tthc.balancer.SetStatus(ctx, proxyName, isUp)\n+\n+\t\tthc.info.UpdateServerStatus(target.String(), isUp)\n+\n+\t\tthc.metrics.ServiceServerUpGauge().\n+\t\t\tWith(\"service\", thc.serviceName, \"url\", target.String()).\n+\t\t\tSet(serverUpMetricValue)\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) executeHealthCheck(_ context.Context, config *dynamic.TCPServerHealthCheck, target *net.TCPAddr) error {\n+\tdialer, err := thc.dialerManager.Get(config.ServersTransport, config.TLS)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tconn, err := dialer.Dial(\"tcp\", target.String())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer conn.Close()\n+\n+\tif config.Payload != \"\" {\n+\t\t_, err = conn.Write([]byte(config.Payload))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tif config.Expected != \"\" {\n+\t\terr := conn.SetReadDeadline(time.Now().Add(thc.timeout))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tbuf := make([]byte, len(config.Expected))\n+\t\t_, err = conn.Read(buf)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif string(buf) != config.Expected {\n+\t\t\treturn errors.New(\"unexpected response\")\n+\t\t}",
        "comment_created_at": "2025-07-11T14:13:48+00:00",
        "comment_author": "sdelicata",
        "comment_body": "I'd appreciate it if the `executeHealthCheck` method provides more context about which part of the health check failed, for example, connection timeout vs payload vs response mismatch.\r\nMaybe we could include the server address in error messages. WDYT?\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200854664",
    "pr_number": 11238,
    "pr_file": "pkg/healthcheck/tcp.go",
    "created_at": "2025-07-11T14:15:36+00:00",
    "commented_code": "+package healthcheck\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/runtime\"\n+\t\"github.com/traefik/traefik/v3/pkg/tcp\"\n+)\n+\n+type ServiceTCPHealthChecker struct {\n+\tdialerManager *tcp.DialerManager\n+\tbalancer      StatusSetter\n+\tinfo          *runtime.TCPServiceInfo\n+\n+\tconfig   *dynamic.TCPServerHealthCheck\n+\tinterval time.Duration\n+\ttimeout  time.Duration\n+\n+\tmetrics metricsHealthCheck\n+\n+\ttargets     map[string]*net.TCPAddr\n+\tserviceName string\n+}\n+\n+func NewServiceTCPHealthChecker(ctx context.Context, dialerManager *tcp.DialerManager, metrics metricsHealthCheck, config *dynamic.TCPServerHealthCheck, service StatusSetter, info *runtime.TCPServiceInfo, targets map[string]*net.TCPAddr, serviceName string) *ServiceTCPHealthChecker {\n+\tlogger := log.Ctx(ctx)\n+\tinterval := time.Duration(config.Interval)\n+\tif interval <= 0 {\n+\t\tlogger.Error().Msg(\"Health check interval smaller than zero\")\n+\t\tinterval = time.Duration(dynamic.DefaultHealthCheckInterval)\n+\t}\n+\n+\ttimeout := time.Duration(config.Timeout)\n+\tif timeout <= 0 {\n+\t\tlogger.Error().Msg(\"Health check timeout smaller than zero\")\n+\t\ttimeout = time.Duration(dynamic.DefaultHealthCheckTimeout)\n+\t}\n+\n+\treturn &ServiceTCPHealthChecker{\n+\t\tdialerManager: dialerManager,\n+\t\tbalancer:      service,\n+\t\tinfo:          info,\n+\t\tconfig:        config,\n+\t\tinterval:      interval,\n+\t\ttimeout:       timeout,\n+\t\tmetrics:       metrics,\n+\t\ttargets:       targets,\n+\t\tserviceName:   serviceName,\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Launch(ctx context.Context) {\n+\tticker := time.NewTicker(thc.interval)\n+\tdefer ticker.Stop()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tthc.Check(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Check(ctx context.Context) {\n+\tfor proxyName, target := range thc.targets {\n+\t\tif ctx.Err() != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tisUp := true\n+\t\tserverUpMetricValue := float64(1)\n+\n+\t\tif err := thc.executeHealthCheck(ctx, thc.config, target); err != nil {\n+\t\t\t// The context is canceled when the dynamic configuration is refreshed.\n+\t\t\tif errors.Is(err, context.Canceled) {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tlog.Ctx(ctx).Warn().\n+\t\t\t\tStr(\"targetURL\", target.String()).\n+\t\t\t\tErr(err).\n+\t\t\t\tMsg(\"Health check failed.\")\n+\n+\t\t\tisUp = false\n+\t\t\tserverUpMetricValue = float64(0)\n+\t\t}\n+\n+\t\tthc.balancer.SetStatus(ctx, proxyName, isUp)\n+\n+\t\tthc.info.UpdateServerStatus(target.String(), isUp)\n+\n+\t\tthc.metrics.ServiceServerUpGauge().\n+\t\t\tWith(\"service\", thc.serviceName, \"url\", target.String()).\n+\t\t\tSet(serverUpMetricValue)\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) executeHealthCheck(_ context.Context, config *dynamic.TCPServerHealthCheck, target *net.TCPAddr) error {\n+\tdialer, err := thc.dialerManager.Get(config.ServersTransport, config.TLS)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tconn, err := dialer.Dial(\"tcp\", target.String())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer conn.Close()",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2200854664",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11238,
        "pr_file": "pkg/healthcheck/tcp.go",
        "discussion_id": "2200854664",
        "commented_code": "@@ -0,0 +1,142 @@\n+package healthcheck\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"time\"\n+\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/dynamic\"\n+\t\"github.com/traefik/traefik/v3/pkg/config/runtime\"\n+\t\"github.com/traefik/traefik/v3/pkg/tcp\"\n+)\n+\n+type ServiceTCPHealthChecker struct {\n+\tdialerManager *tcp.DialerManager\n+\tbalancer      StatusSetter\n+\tinfo          *runtime.TCPServiceInfo\n+\n+\tconfig   *dynamic.TCPServerHealthCheck\n+\tinterval time.Duration\n+\ttimeout  time.Duration\n+\n+\tmetrics metricsHealthCheck\n+\n+\ttargets     map[string]*net.TCPAddr\n+\tserviceName string\n+}\n+\n+func NewServiceTCPHealthChecker(ctx context.Context, dialerManager *tcp.DialerManager, metrics metricsHealthCheck, config *dynamic.TCPServerHealthCheck, service StatusSetter, info *runtime.TCPServiceInfo, targets map[string]*net.TCPAddr, serviceName string) *ServiceTCPHealthChecker {\n+\tlogger := log.Ctx(ctx)\n+\tinterval := time.Duration(config.Interval)\n+\tif interval <= 0 {\n+\t\tlogger.Error().Msg(\"Health check interval smaller than zero\")\n+\t\tinterval = time.Duration(dynamic.DefaultHealthCheckInterval)\n+\t}\n+\n+\ttimeout := time.Duration(config.Timeout)\n+\tif timeout <= 0 {\n+\t\tlogger.Error().Msg(\"Health check timeout smaller than zero\")\n+\t\ttimeout = time.Duration(dynamic.DefaultHealthCheckTimeout)\n+\t}\n+\n+\treturn &ServiceTCPHealthChecker{\n+\t\tdialerManager: dialerManager,\n+\t\tbalancer:      service,\n+\t\tinfo:          info,\n+\t\tconfig:        config,\n+\t\tinterval:      interval,\n+\t\ttimeout:       timeout,\n+\t\tmetrics:       metrics,\n+\t\ttargets:       targets,\n+\t\tserviceName:   serviceName,\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Launch(ctx context.Context) {\n+\tticker := time.NewTicker(thc.interval)\n+\tdefer ticker.Stop()\n+\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase <-ticker.C:\n+\t\t\tthc.Check(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) Check(ctx context.Context) {\n+\tfor proxyName, target := range thc.targets {\n+\t\tif ctx.Err() != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tisUp := true\n+\t\tserverUpMetricValue := float64(1)\n+\n+\t\tif err := thc.executeHealthCheck(ctx, thc.config, target); err != nil {\n+\t\t\t// The context is canceled when the dynamic configuration is refreshed.\n+\t\t\tif errors.Is(err, context.Canceled) {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tlog.Ctx(ctx).Warn().\n+\t\t\t\tStr(\"targetURL\", target.String()).\n+\t\t\t\tErr(err).\n+\t\t\t\tMsg(\"Health check failed.\")\n+\n+\t\t\tisUp = false\n+\t\t\tserverUpMetricValue = float64(0)\n+\t\t}\n+\n+\t\tthc.balancer.SetStatus(ctx, proxyName, isUp)\n+\n+\t\tthc.info.UpdateServerStatus(target.String(), isUp)\n+\n+\t\tthc.metrics.ServiceServerUpGauge().\n+\t\t\tWith(\"service\", thc.serviceName, \"url\", target.String()).\n+\t\t\tSet(serverUpMetricValue)\n+\t}\n+}\n+\n+func (thc *ServiceTCPHealthChecker) executeHealthCheck(_ context.Context, config *dynamic.TCPServerHealthCheck, target *net.TCPAddr) error {\n+\tdialer, err := thc.dialerManager.Get(config.ServersTransport, config.TLS)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tconn, err := dialer.Dial(\"tcp\", target.String())\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer conn.Close()",
        "comment_created_at": "2025-07-11T14:15:36+00:00",
        "comment_author": "sdelicata",
        "comment_body": "```suggestion\r\n\tdefer func() {\r\n        if err := conn.Close(); err != nil {\r\n            log.Ctx(ctx).Warn().Err(err).Msg(\"Failed to close health check connection\")\r\n        }\r\n    }()\r\n```",
        "pr_file_module": null
      }
    ]
  }
]