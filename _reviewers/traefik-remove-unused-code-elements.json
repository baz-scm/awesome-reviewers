[
  {
    "discussion_id": "1598681046",
    "pr_number": 10211,
    "pr_file": "pkg/middlewares/ratelimiter/basic_limiter.go",
    "created_at": "2024-05-13T15:37:43+00:00",
    "commented_code": "+package ratelimiter\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"github.com/mailgun/ttlmap\"\n+\t\"github.com/rs/zerolog\"\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/middlewares/observability\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+type BasicLimiter struct {\n+\trate  rate.Limit // reqs/s\n+\tburst int64\n+\t// maxDelay is the maximum duration we're willing to wait for a bucket reservation to become effective, in nanoseconds.\n+\t// For now it is somewhat arbitrarily set to 1/(2*rate).\n+\tmaxDelay time.Duration\n+\t// each rate limiter for a given source is stored in the buckets ttlmap.\n+\t// To keep this ttlmap constrained in size,\n+\t// each ratelimiter is \"garbage collected\" when it is considered expired.\n+\t// It is considered expired after it hasn't been used for ttl seconds.\n+\tttl     int\n+\tbuckets *ttlmap.TtlMap // actual buckets, keyed by source.\n+\n+\tlogger *zerolog.Logger\n+}\n+\n+func NewBaseLimiter(\n+\trate rate.Limit,\n+\tburst int64,\n+\tmaxDelay time.Duration,\n+\tttl int,\n+\tlogger *zerolog.Logger,\n+) (Limiter, error) {\n+\tbuckets, err := ttlmap.NewConcurrent(maxSources)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &BasicLimiter{\n+\t\trate:     rate,\n+\t\tburst:    burst,\n+\t\tmaxDelay: maxDelay,\n+\t\tttl:      ttl,\n+\t\tlogger:   logger,\n+\n+\t\tbuckets: buckets,\n+\t}, nil\n+}\n+\n+func (b *BasicLimiter) Allow(\n+\tctx context.Context, source string, amount int64, req *http.Request, rw http.ResponseWriter,",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "1598681046",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/middlewares/ratelimiter/basic_limiter.go",
        "discussion_id": "1598681046",
        "commented_code": "@@ -0,0 +1,101 @@\n+package ratelimiter\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"github.com/mailgun/ttlmap\"\n+\t\"github.com/rs/zerolog\"\n+\t\"github.com/rs/zerolog/log\"\n+\t\"github.com/traefik/traefik/v3/pkg/middlewares/observability\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+type BasicLimiter struct {\n+\trate  rate.Limit // reqs/s\n+\tburst int64\n+\t// maxDelay is the maximum duration we're willing to wait for a bucket reservation to become effective, in nanoseconds.\n+\t// For now it is somewhat arbitrarily set to 1/(2*rate).\n+\tmaxDelay time.Duration\n+\t// each rate limiter for a given source is stored in the buckets ttlmap.\n+\t// To keep this ttlmap constrained in size,\n+\t// each ratelimiter is \"garbage collected\" when it is considered expired.\n+\t// It is considered expired after it hasn't been used for ttl seconds.\n+\tttl     int\n+\tbuckets *ttlmap.TtlMap // actual buckets, keyed by source.\n+\n+\tlogger *zerolog.Logger\n+}\n+\n+func NewBaseLimiter(\n+\trate rate.Limit,\n+\tburst int64,\n+\tmaxDelay time.Duration,\n+\tttl int,\n+\tlogger *zerolog.Logger,\n+) (Limiter, error) {\n+\tbuckets, err := ttlmap.NewConcurrent(maxSources)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &BasicLimiter{\n+\t\trate:     rate,\n+\t\tburst:    burst,\n+\t\tmaxDelay: maxDelay,\n+\t\tttl:      ttl,\n+\t\tlogger:   logger,\n+\n+\t\tbuckets: buckets,\n+\t}, nil\n+}\n+\n+func (b *BasicLimiter) Allow(\n+\tctx context.Context, source string, amount int64, req *http.Request, rw http.ResponseWriter,",
        "comment_created_at": "2024-05-13T15:37:43+00:00",
        "comment_author": "jspdown",
        "comment_body": "The `req` parameter is not needed here. We only need it for is context that we already take as parameter.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1615998047",
    "pr_number": 10211,
    "pr_file": "pkg/config/dynamic/middlewares.go",
    "created_at": "2024-05-27T12:38:07+00:00",
    "commented_code": "// If several strategies are defined at the same time, an error will be raised.\n \t// If none are set, the default is to use the request's remote address field (as an ipStrategy).\n \tSourceCriterion *SourceCriterion `json:\"sourceCriterion,omitempty\" toml:\"sourceCriterion,omitempty\" yaml:\"sourceCriterion,omitempty\" export:\"true\"`\n+\n+\tRedis *Redis `json:\"redis,omitempty\" toml:\"redis,omitempty\" yaml:\"redis,omitempty\" export:\"true\"`\n+}\n+\n+// +k8s:deepcopy-gen=true\n+\n+// Redis is a group of options for redis.\n+type Redis struct {\n+\tEndpoints       []string         `description:\"KV store endpoints.\" json:\"endpoints,omitempty\" toml:\"endpoints,omitempty\" yaml:\"endpoints,omitempty\"`",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "1615998047",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/config/dynamic/middlewares.go",
        "discussion_id": "1615998047",
        "commented_code": "@@ -510,6 +511,25 @@ type RateLimit struct {\n \t// If several strategies are defined at the same time, an error will be raised.\n \t// If none are set, the default is to use the request's remote address field (as an ipStrategy).\n \tSourceCriterion *SourceCriterion `json:\"sourceCriterion,omitempty\" toml:\"sourceCriterion,omitempty\" yaml:\"sourceCriterion,omitempty\" export:\"true\"`\n+\n+\tRedis *Redis `json:\"redis,omitempty\" toml:\"redis,omitempty\" yaml:\"redis,omitempty\" export:\"true\"`\n+}\n+\n+// +k8s:deepcopy-gen=true\n+\n+// Redis is a group of options for redis.\n+type Redis struct {\n+\tEndpoints       []string         `description:\"KV store endpoints.\" json:\"endpoints,omitempty\" toml:\"endpoints,omitempty\" yaml:\"endpoints,omitempty\"`",
        "comment_created_at": "2024-05-27T12:38:07+00:00",
        "comment_author": "jspdown",
        "comment_body": "Could you remove the `description` struct tags? It's only used in the static configuration for documentation purpose.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1616114487",
    "pr_number": 10211,
    "pr_file": "pkg/middlewares/ratelimiter/redisrate/rate.go",
    "created_at": "2024-05-27T14:16:33+00:00",
    "commented_code": "+package redisrate\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"strconv\"\n+\t\"time\"\n+\n+\t\"github.com/redis/go-redis/v9\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+const redisPrefix = \"rate:\"\n+\n+// Inf is the infinite rate limit; it allows all events (even if burst is zero).\n+const Inf = rate.Limit(math.MaxFloat64)\n+\n+// InfDuration is the duration returned by Delay when a Reservation is not OK.\n+const InfDuration = time.Duration(math.MaxInt64)\n+\n+type rediser interface {\n+\tEval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd\n+\tEvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd\n+\tScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd\n+\tScriptLoad(ctx context.Context, script string) *redis.StringCmd\n+\tDel(ctx context.Context, keys ...string) *redis.IntCmd\n+\n+\tEvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd\n+\tEvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd\n+}\n+\n+type Limit struct {\n+\tRate   rate.Limit\n+\tBurst  int64\n+\tPeriod time.Duration\n+}\n+\n+func (l Limit) String() string {\n+\treturn fmt.Sprintf(\"%f req/%s (burst %d)\", l.Rate, fmtDur(l.Period), l.Burst)",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "1616114487",
        "repo_full_name": "traefik/traefik",
        "pr_number": 10211,
        "pr_file": "pkg/middlewares/ratelimiter/redisrate/rate.go",
        "discussion_id": "1616114487",
        "commented_code": "@@ -0,0 +1,151 @@\n+package redisrate\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"strconv\"\n+\t\"time\"\n+\n+\t\"github.com/redis/go-redis/v9\"\n+\t\"golang.org/x/time/rate\"\n+)\n+\n+const redisPrefix = \"rate:\"\n+\n+// Inf is the infinite rate limit; it allows all events (even if burst is zero).\n+const Inf = rate.Limit(math.MaxFloat64)\n+\n+// InfDuration is the duration returned by Delay when a Reservation is not OK.\n+const InfDuration = time.Duration(math.MaxInt64)\n+\n+type rediser interface {\n+\tEval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd\n+\tEvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd\n+\tScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd\n+\tScriptLoad(ctx context.Context, script string) *redis.StringCmd\n+\tDel(ctx context.Context, keys ...string) *redis.IntCmd\n+\n+\tEvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd\n+\tEvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd\n+}\n+\n+type Limit struct {\n+\tRate   rate.Limit\n+\tBurst  int64\n+\tPeriod time.Duration\n+}\n+\n+func (l Limit) String() string {\n+\treturn fmt.Sprintf(\"%f req/%s (burst %d)\", l.Rate, fmtDur(l.Period), l.Burst)",
        "comment_created_at": "2024-05-27T14:16:33+00:00",
        "comment_author": "jspdown",
        "comment_body": "The rate is already expressed in req/s. So, I think the `fmtDur` call here will generate a wrong message.\r\nI didn't see any use of `String`, `IsZero`, `PerSecond`, `PerMinute`, `PerHour`, could you delete them?",
        "pr_file_module": null
      }
    ]
  }
]