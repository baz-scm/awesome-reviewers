[
  {
    "discussion_id": "2145064339",
    "pr_number": 11582,
    "pr_file": "pkg/server/router/tcp/manager.go",
    "created_at": "2025-06-13T13:11:11+00:00",
    "commented_code": "type nameAndConfig struct {\n \trouterName string // just so we have it as additional information when logging\n \tTLSConfig  *tls.Config\n+\tregex      bool",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2145064339",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11582,
        "pr_file": "pkg/server/router/tcp/manager.go",
        "discussion_id": "2145064339",
        "commented_code": "@@ -96,6 +96,7 @@ func (m *Manager) BuildHandlers(rootCtx context.Context, entryPoints []string) m\n type nameAndConfig struct {\n \trouterName string // just so we have it as additional information when logging\n \tTLSConfig  *tls.Config\n+\tregex      bool",
        "comment_created_at": "2025-06-13T13:11:11+00:00",
        "comment_author": "sdelicata",
        "comment_body": "WDYT about renaming it to `isRegex`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145117298",
    "pr_number": 11582,
    "pr_file": "pkg/muxer/http/mux.go",
    "created_at": "2025-06-13T13:35:47+00:00",
    "commented_code": "return nil\n }\n \n+// ParseDomainsAndRegex extract domains and regex from rule.\n+// It returns the domains and regex. If the rule is invalid, it returns an error.\n+func ParseDomainsAndRegex(rule string) ([]string, []string, error) {",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2145117298",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11582,
        "pr_file": "pkg/muxer/http/mux.go",
        "discussion_id": "2145117298",
        "commented_code": "@@ -116,6 +116,36 @@ func (m *Muxer) AddRoute(rule string, syntax string, priority int, handler http.\n \treturn nil\n }\n \n+// ParseDomainsAndRegex extract domains and regex from rule.\n+// It returns the domains and regex. If the rule is invalid, it returns an error.\n+func ParseDomainsAndRegex(rule string) ([]string, []string, error) {",
        "comment_created_at": "2025-06-13T13:35:47+00:00",
        "comment_author": "sdelicata",
        "comment_body": "WDYT about renaming it to `ParseHostMatchers`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2039519758",
    "pr_number": 11351,
    "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
    "created_at": "2025-04-11T12:57:31+00:00",
    "commented_code": "fenced map[string]struct{}\n }\n \n+type CustomResponseWriter struct {",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2039519758",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039519758",
        "commented_code": "@@ -68,6 +72,16 @@ type Balancer struct {\n \tfenced map[string]struct{}\n }\n \n+type CustomResponseWriter struct {",
        "comment_created_at": "2025-04-11T12:57:31+00:00",
        "comment_author": "sdelicata",
        "comment_body": "The naming could be improved to describe more explicitly the behavior.\nThe idea here is to capture the status code. WDYT about `StatusRecorder` for example?",
        "pr_file_module": null
      },
      {
        "comment_id": "2062208913",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2039519758",
        "commented_code": "@@ -68,6 +72,16 @@ type Balancer struct {\n \tfenced map[string]struct{}\n }\n \n+type CustomResponseWriter struct {",
        "comment_created_at": "2025-04-27T04:58:04+00:00",
        "comment_author": "Nelwhix",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2095027232",
    "pr_number": 11351,
    "pr_file": "pkg/config/dynamic/http_config.go",
    "created_at": "2025-05-19T07:29:18+00:00",
    "commented_code": "// Scheme can only be defined with label Providers.\n \tScheme string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n \tPort   string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n-\t// HealthCheck enables passive health checks for this server\n+\t// HealthCheck enables passive health checks for this server.\n \tHealthCheck *PassiveHealthCheck `json:\"healthCheck,omitempty\" toml:\"healthCheck,omitempty\" yaml:\"healthCheck,omitempty\" export:\"true\"`\n }\n \n+// +k8s:deepcopy-gen=true\n+\n type PassiveHealthCheck struct {\n+\t// FailTimeout sets the time during which a number of failed attempts must happen for the server to be marked unavailable.\n \tFailTimeout ptypes.Duration `json:\"failTimeout,omitempty\" toml:\"failTimeout,omitempty\" yaml:\"failTimeout,omitempty\" export:\"true\"`",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2095027232",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/config/dynamic/http_config.go",
        "discussion_id": "2095027232",
        "commented_code": "@@ -293,13 +293,17 @@ type Server struct {\n \t// Scheme can only be defined with label Providers.\n \tScheme string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n \tPort   string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n-\t// HealthCheck enables passive health checks for this server\n+\t// HealthCheck enables passive health checks for this server.\n \tHealthCheck *PassiveHealthCheck `json:\"healthCheck,omitempty\" toml:\"healthCheck,omitempty\" yaml:\"healthCheck,omitempty\" export:\"true\"`\n }\n \n+// +k8s:deepcopy-gen=true\n+\n type PassiveHealthCheck struct {\n+\t// FailTimeout sets the time during which a number of failed attempts must happen for the server to be marked unavailable.\n \tFailTimeout ptypes.Duration `json:\"failTimeout,omitempty\" toml:\"failTimeout,omitempty\" yaml:\"failTimeout,omitempty\" export:\"true\"`",
        "comment_created_at": "2025-05-19T07:29:18+00:00",
        "comment_author": "sdelicata",
        "comment_body": "The current name `FailTimeout` is ambiguous, as it suggests a request timeout or delay between retries.\r\nRenaming it to `FailureWindow` (or `FailurePeriod`) better reflects its actual role: defining the time frame during which failed attempts are counted before marking a server as unhealthy. WDYT?",
        "pr_file_module": null
      },
      {
        "comment_id": "2099116922",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/config/dynamic/http_config.go",
        "discussion_id": "2095027232",
        "commented_code": "@@ -293,13 +293,17 @@ type Server struct {\n \t// Scheme can only be defined with label Providers.\n \tScheme string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n \tPort   string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n-\t// HealthCheck enables passive health checks for this server\n+\t// HealthCheck enables passive health checks for this server.\n \tHealthCheck *PassiveHealthCheck `json:\"healthCheck,omitempty\" toml:\"healthCheck,omitempty\" yaml:\"healthCheck,omitempty\" export:\"true\"`\n }\n \n+// +k8s:deepcopy-gen=true\n+\n type PassiveHealthCheck struct {\n+\t// FailTimeout sets the time during which a number of failed attempts must happen for the server to be marked unavailable.\n \tFailTimeout ptypes.Duration `json:\"failTimeout,omitempty\" toml:\"failTimeout,omitempty\" yaml:\"failTimeout,omitempty\" export:\"true\"`",
        "comment_created_at": "2025-05-21T01:19:05+00:00",
        "comment_author": "Nelwhix",
        "comment_body": "I changed to FailureWindow",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2095043514",
    "pr_number": 11351,
    "pr_file": "pkg/config/dynamic/http_config.go",
    "created_at": "2025-05-19T07:35:29+00:00",
    "commented_code": "// Scheme can only be defined with label Providers.\n \tScheme string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n \tPort   string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n-\t// HealthCheck enables passive health checks for this server\n+\t// HealthCheck enables passive health checks for this server.\n \tHealthCheck *PassiveHealthCheck `json:\"healthCheck,omitempty\" toml:\"healthCheck,omitempty\" yaml:\"healthCheck,omitempty\" export:\"true\"`\n }\n \n+// +k8s:deepcopy-gen=true\n+\n type PassiveHealthCheck struct {\n+\t// FailTimeout sets the time during which a number of failed attempts must happen for the server to be marked unavailable.\n \tFailTimeout ptypes.Duration `json:\"failTimeout,omitempty\" toml:\"failTimeout,omitempty\" yaml:\"failTimeout,omitempty\" export:\"true\"`\n-\tMaxFails    int             `json:\"maxFails,omitempty\" toml:\"maxFails,omitempty\" yaml:\"maxFails,omitempty\" export:\"true\"`\n+\t// MaxFails sets the number of failed attempts that must occur during the fail timeout.\n+\tMaxFails int `json:\"maxFails,omitempty\" toml:\"maxFails,omitempty\" yaml:\"maxFails,omitempty\" export:\"true\"`",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2095043514",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/config/dynamic/http_config.go",
        "discussion_id": "2095043514",
        "commented_code": "@@ -293,13 +293,17 @@ type Server struct {\n \t// Scheme can only be defined with label Providers.\n \tScheme string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n \tPort   string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n-\t// HealthCheck enables passive health checks for this server\n+\t// HealthCheck enables passive health checks for this server.\n \tHealthCheck *PassiveHealthCheck `json:\"healthCheck,omitempty\" toml:\"healthCheck,omitempty\" yaml:\"healthCheck,omitempty\" export:\"true\"`\n }\n \n+// +k8s:deepcopy-gen=true\n+\n type PassiveHealthCheck struct {\n+\t// FailTimeout sets the time during which a number of failed attempts must happen for the server to be marked unavailable.\n \tFailTimeout ptypes.Duration `json:\"failTimeout,omitempty\" toml:\"failTimeout,omitempty\" yaml:\"failTimeout,omitempty\" export:\"true\"`\n-\tMaxFails    int             `json:\"maxFails,omitempty\" toml:\"maxFails,omitempty\" yaml:\"maxFails,omitempty\" export:\"true\"`\n+\t// MaxFails sets the number of failed attempts that must occur during the fail timeout.\n+\tMaxFails int `json:\"maxFails,omitempty\" toml:\"maxFails,omitempty\" yaml:\"maxFails,omitempty\" export:\"true\"`",
        "comment_created_at": "2025-05-19T07:35:29+00:00",
        "comment_author": "sdelicata",
        "comment_body": "`MaxFails` is slightly ambiguous to me.\r\nWDYT about replacing it with `FailureThreshold` (or `MaxFailedAttempts`) to improve clarity, making it easier to understand that it sets the limit of allowed failures within the failure window before a server is marked as unhealthy?",
        "pr_file_module": null
      },
      {
        "comment_id": "2099117033",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/config/dynamic/http_config.go",
        "discussion_id": "2095043514",
        "commented_code": "@@ -293,13 +293,17 @@ type Server struct {\n \t// Scheme can only be defined with label Providers.\n \tScheme string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n \tPort   string `json:\"-\" toml:\"-\" yaml:\"-\" file:\"-\" kv:\"-\"`\n-\t// HealthCheck enables passive health checks for this server\n+\t// HealthCheck enables passive health checks for this server.\n \tHealthCheck *PassiveHealthCheck `json:\"healthCheck,omitempty\" toml:\"healthCheck,omitempty\" yaml:\"healthCheck,omitempty\" export:\"true\"`\n }\n \n+// +k8s:deepcopy-gen=true\n+\n type PassiveHealthCheck struct {\n+\t// FailTimeout sets the time during which a number of failed attempts must happen for the server to be marked unavailable.\n \tFailTimeout ptypes.Duration `json:\"failTimeout,omitempty\" toml:\"failTimeout,omitempty\" yaml:\"failTimeout,omitempty\" export:\"true\"`\n-\tMaxFails    int             `json:\"maxFails,omitempty\" toml:\"maxFails,omitempty\" yaml:\"maxFails,omitempty\" export:\"true\"`\n+\t// MaxFails sets the number of failed attempts that must occur during the fail timeout.\n+\tMaxFails int `json:\"maxFails,omitempty\" toml:\"maxFails,omitempty\" yaml:\"maxFails,omitempty\" export:\"true\"`",
        "comment_created_at": "2025-05-21T01:19:17+00:00",
        "comment_author": "Nelwhix",
        "comment_body": "I changed to MaxFailedAttempts",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2115909366",
    "pr_number": 11351,
    "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
    "created_at": "2025-05-30T13:14:32+00:00",
    "commented_code": "handler.deadline += 1 / handler.weight\n \n \t\theap.Push(b, handler)\n-\t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tif _, ok := b.fenced[handler.name]; !ok {\n-\t\t\t\t// do not select a fenced handler.\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\tif _, down := b.status[handler.name]; !down {",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2115909366",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2115909366",
        "commented_code": "@@ -162,12 +174,17 @@ func (b *Balancer) nextServer() (*namedHandler, error) {\n \t\thandler.deadline += 1 / handler.weight\n \n \t\theap.Push(b, handler)\n-\t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tif _, ok := b.fenced[handler.name]; !ok {\n-\t\t\t\t// do not select a fenced handler.\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\tif _, down := b.status[handler.name]; !down {",
        "comment_created_at": "2025-05-30T13:14:32+00:00",
        "comment_author": "lbenguigui",
        "comment_body": "Unless I missed something, `b.status` indicates whether a server is up. Maybe renaming `down` to something like up would make the logic clearer?",
        "pr_file_module": null
      },
      {
        "comment_id": "2117798210",
        "repo_full_name": "traefik/traefik",
        "pr_number": 11351,
        "pr_file": "pkg/server/service/loadbalancer/wrr/wrr.go",
        "discussion_id": "2115909366",
        "commented_code": "@@ -162,12 +174,17 @@ func (b *Balancer) nextServer() (*namedHandler, error) {\n \t\thandler.deadline += 1 / handler.weight\n \n \t\theap.Push(b, handler)\n-\t\tif _, ok := b.status[handler.name]; ok {\n-\t\t\tif _, ok := b.fenced[handler.name]; !ok {\n-\t\t\t\t// do not select a fenced handler.\n-\t\t\t\tbreak\n-\t\t\t}\n+\t\tif _, down := b.status[handler.name]; !down {",
        "comment_created_at": "2025-05-31T12:47:03+00:00",
        "comment_author": "Nelwhix",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060319699",
    "pr_number": 8393,
    "pr_file": "pkg/tls/ocsp.go",
    "created_at": "2025-04-25T14:08:35+00:00",
    "commented_code": "+package tls\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"crypto/x509\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"github.com/patrickmn/go-cache\"\n+\t\"github.com/rs/zerolog/log\"\n+\t\"golang.org/x/crypto/ocsp\"\n+)\n+\n+const defaultCacheDuration = 24 * time.Hour\n+\n+type ocspEntry struct {\n+\tleaf       *x509.Certificate\n+\tissuer     *x509.Certificate\n+\tresponders []string\n+\tnextUpdate time.Time\n+\tstaple     []byte\n+}\n+\n+// ocspStapler retrieves staples from OCSP responders and store them in an in-memory cache.\n+// It also updates the staples on a regular basis and before they expire.\n+type ocspStapler struct {\n+\tclient             *http.Client\n+\tcache              cache.Cache\n+\tforceStapleUpdates chan struct{}\n+\tresponderOverrides map[string]string\n+}\n+\n+// newOCSPStapler creates a new ocspStapler cache.\n+func newOCSPStapler(responderOverrides map[string]string) *ocspStapler {\n+\treturn &ocspStapler{\n+\t\tclient:             &http.Client{Timeout: 10 * time.Second},\n+\t\tcache:              *cache.New(defaultCacheDuration, 5*time.Minute),\n+\t\tforceStapleUpdates: make(chan struct{}, 1),\n+\t\tresponderOverrides: responderOverrides,\n+\t}\n+}\n+\n+// Run updates the OCSP staples every hours.\n+func (o *ocspStapler) Run(ctx context.Context) {\n+\tticker := time.NewTicker(time.Hour)\n+\tdefer ticker.Stop()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn\n+\n+\tcase <-o.forceStapleUpdates:\n+\t\to.updateStaples(ctx)\n+\n+\tcase <-ticker.C:\n+\t\to.updateStaples(ctx)\n+\t}\n+}\n+\n+// ForceStapleUpdates triggers staple updates in the background instead of waiting for the Run routine to update them.\n+func (o *ocspStapler) ForceStapleUpdates() {\n+\tselect {\n+\tcase o.forceStapleUpdates <- struct{}{}:\n+\tdefault:\n+\t}\n+}\n+\n+// GetStaple retrieves the OCSP staple for the corresponding to the given key (public certificate hash).\n+func (o *ocspStapler) GetStaple(key string) ([]byte, bool) {\n+\tif item, ok := o.cache.Get(key); ok && item != nil {\n+\t\tif entry, ok := item.(*ocspEntry); ok {\n+\t\t\treturn entry.staple, true\n+\t\t}\n+\t}\n+\treturn nil, false\n+}\n+\n+// Upsert creates a new entry for the given certificate.\n+// The ocspStapler will then be responsible from retrieving and updating the corresponding OCSP obtainStaple.\n+func (o *ocspStapler) Upsert(key string, leaf, issuer *x509.Certificate) error {\n+\tif len(leaf.OCSPServer) == 0 {\n+\t\treturn errors.New(\"leaf certificate does not contain an OCSP server\")\n+\t}\n+\n+\tif item, ok := o.cache.Get(key); ok {\n+\t\to.cache.Set(key, item, cache.NoExpiration)\n+\t\treturn nil\n+\t}\n+\n+\tvar responders []string\n+\tfor _, url := range leaf.OCSPServer {\n+\t\tif len(o.responderOverrides) > 0 {\n+\t\t\tif newURL, ok := o.responderOverrides[url]; ok {\n+\t\t\t\turl = newURL\n+\t\t\t}\n+\t\t}\n+\t\tresponders = append(responders, url)\n+\t}\n+\n+\to.cache.Set(key, &ocspEntry{\n+\t\tleaf:       leaf,\n+\t\tissuer:     issuer,\n+\t\tresponders: responders,\n+\t}, cache.NoExpiration)\n+\n+\treturn nil\n+}\n+\n+// ResetTTL resets the expiration time for all items that has no expiration.\n+// This allows to set a TTL to cache that do not exist in the dynamic configuration anymore.\n+// For those existing, the TTL will be set to zero when the Upsert method will be called during\n+// the UpdateConfigs method of the TLS manager.\n+func (o *ocspStapler) ResetTTL() {\n+\tfor key, item := range o.cache.Items() {\n+\t\tif item.Expiration > 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\to.cache.Set(key, item.Object, cache.DefaultExpiration)",
    "repo_full_name": "traefik/traefik",
    "discussion_comments": [
      {
        "comment_id": "2060319699",
        "repo_full_name": "traefik/traefik",
        "pr_number": 8393,
        "pr_file": "pkg/tls/ocsp.go",
        "discussion_id": "2060319699",
        "commented_code": "@@ -0,0 +1,200 @@\n+package tls\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"crypto/x509\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"time\"\n+\n+\t\"github.com/patrickmn/go-cache\"\n+\t\"github.com/rs/zerolog/log\"\n+\t\"golang.org/x/crypto/ocsp\"\n+)\n+\n+const defaultCacheDuration = 24 * time.Hour\n+\n+type ocspEntry struct {\n+\tleaf       *x509.Certificate\n+\tissuer     *x509.Certificate\n+\tresponders []string\n+\tnextUpdate time.Time\n+\tstaple     []byte\n+}\n+\n+// ocspStapler retrieves staples from OCSP responders and store them in an in-memory cache.\n+// It also updates the staples on a regular basis and before they expire.\n+type ocspStapler struct {\n+\tclient             *http.Client\n+\tcache              cache.Cache\n+\tforceStapleUpdates chan struct{}\n+\tresponderOverrides map[string]string\n+}\n+\n+// newOCSPStapler creates a new ocspStapler cache.\n+func newOCSPStapler(responderOverrides map[string]string) *ocspStapler {\n+\treturn &ocspStapler{\n+\t\tclient:             &http.Client{Timeout: 10 * time.Second},\n+\t\tcache:              *cache.New(defaultCacheDuration, 5*time.Minute),\n+\t\tforceStapleUpdates: make(chan struct{}, 1),\n+\t\tresponderOverrides: responderOverrides,\n+\t}\n+}\n+\n+// Run updates the OCSP staples every hours.\n+func (o *ocspStapler) Run(ctx context.Context) {\n+\tticker := time.NewTicker(time.Hour)\n+\tdefer ticker.Stop()\n+\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn\n+\n+\tcase <-o.forceStapleUpdates:\n+\t\to.updateStaples(ctx)\n+\n+\tcase <-ticker.C:\n+\t\to.updateStaples(ctx)\n+\t}\n+}\n+\n+// ForceStapleUpdates triggers staple updates in the background instead of waiting for the Run routine to update them.\n+func (o *ocspStapler) ForceStapleUpdates() {\n+\tselect {\n+\tcase o.forceStapleUpdates <- struct{}{}:\n+\tdefault:\n+\t}\n+}\n+\n+// GetStaple retrieves the OCSP staple for the corresponding to the given key (public certificate hash).\n+func (o *ocspStapler) GetStaple(key string) ([]byte, bool) {\n+\tif item, ok := o.cache.Get(key); ok && item != nil {\n+\t\tif entry, ok := item.(*ocspEntry); ok {\n+\t\t\treturn entry.staple, true\n+\t\t}\n+\t}\n+\treturn nil, false\n+}\n+\n+// Upsert creates a new entry for the given certificate.\n+// The ocspStapler will then be responsible from retrieving and updating the corresponding OCSP obtainStaple.\n+func (o *ocspStapler) Upsert(key string, leaf, issuer *x509.Certificate) error {\n+\tif len(leaf.OCSPServer) == 0 {\n+\t\treturn errors.New(\"leaf certificate does not contain an OCSP server\")\n+\t}\n+\n+\tif item, ok := o.cache.Get(key); ok {\n+\t\to.cache.Set(key, item, cache.NoExpiration)\n+\t\treturn nil\n+\t}\n+\n+\tvar responders []string\n+\tfor _, url := range leaf.OCSPServer {\n+\t\tif len(o.responderOverrides) > 0 {\n+\t\t\tif newURL, ok := o.responderOverrides[url]; ok {\n+\t\t\t\turl = newURL\n+\t\t\t}\n+\t\t}\n+\t\tresponders = append(responders, url)\n+\t}\n+\n+\to.cache.Set(key, &ocspEntry{\n+\t\tleaf:       leaf,\n+\t\tissuer:     issuer,\n+\t\tresponders: responders,\n+\t}, cache.NoExpiration)\n+\n+\treturn nil\n+}\n+\n+// ResetTTL resets the expiration time for all items that has no expiration.\n+// This allows to set a TTL to cache that do not exist in the dynamic configuration anymore.\n+// For those existing, the TTL will be set to zero when the Upsert method will be called during\n+// the UpdateConfigs method of the TLS manager.\n+func (o *ocspStapler) ResetTTL() {\n+\tfor key, item := range o.cache.Items() {\n+\t\tif item.Expiration > 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\to.cache.Set(key, item.Object, cache.DefaultExpiration)",
        "comment_created_at": "2025-04-25T14:08:35+00:00",
        "comment_author": "lbenguigui",
        "comment_body": "To me, using `cache.DefaultExpiration` (which is set to 0) is misleading.\r\nIt's not immediately obvious what it does, and understanding its behavior requires digging into the implementation of the library.\r\nI'll suggest to either to add a comment or use `defaultCacheDuration`\r\n",
        "pr_file_module": null
      }
    ]
  }
]