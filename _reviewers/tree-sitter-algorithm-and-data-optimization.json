[
  {
    "discussion_id": "2295455968",
    "pr_number": 4205,
    "pr_file": "crates/cli/src/version.rs",
    "created_at": "2025-08-23T07:54:47+00:00",
    "commented_code": "use std::{fs, path::PathBuf, process::Command};\n \n use anyhow::{anyhow, Context, Result};\n+use clap::ValueEnum;\n use regex::Regex;\n+use semver::Version as SemverVersion;\n use tree_sitter_loader::TreeSitterJSON;\n \n+#[derive(Clone, Copy, Default, ValueEnum)]\n+pub enum BumpLevel {\n+    #[default]\n+    Patch,\n+    Minor,\n+    Major,\n+}\n+\n pub struct Version {\n-    pub version: String,\n+    pub version: Option<SemverVersion>,\n     pub current_dir: PathBuf,\n+    pub bump: Option<BumpLevel>,\n }\n \n impl Version {\n     #[must_use]\n-    pub const fn new(version: String, current_dir: PathBuf) -> Self {\n+    pub const fn new(\n+        version: Option<SemverVersion>,\n+        current_dir: PathBuf,\n+        bump: Option<BumpLevel>,\n+    ) -> Self {\n         Self {\n             version,\n             current_dir,\n+            bump,\n         }\n     }\n \n-    pub fn run(self) -> Result<()> {\n+    pub fn run(mut self) -> Result<()> {\n         let tree_sitter_json = self.current_dir.join(\"tree-sitter.json\");\n \n         let tree_sitter_json =\n             serde_json::from_str::<TreeSitterJSON>(&fs::read_to_string(tree_sitter_json)?)?;\n \n+        let current_version = tree_sitter_json.metadata.version;\n+        self.version = match (self.version.is_some(), self.bump) {\n+            (false, None) => {\n+                println!(\"Current version: {current_version}\");\n+                return Ok(());\n+            }\n+            (true, None) => self.version,\n+            (false, Some(bump)) => {\n+                let mut v = current_version.clone();\n+                match bump {\n+                    BumpLevel::Patch => v.patch += 1,\n+                    BumpLevel::Minor => {\n+                        v.minor += 1;\n+                        v.patch = 0;\n+                    }\n+                    BumpLevel::Major => {\n+                        v.major += 1;\n+                        v.minor = 0;\n+                        v.patch = 0;\n+                    }\n+                }\n+                Some(v)\n+            }\n+            (true, Some(_)) => unreachable!(),\n+        };\n+\n+        let new_version = self.version.as_ref().unwrap();\n+        if new_version <= &current_version {\n+            print!(\"\\x1b[93m{}\\x1b[0m: \", \"Warning\"); // Bright yellow",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "2295455968",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4205,
        "pr_file": "crates/cli/src/version.rs",
        "discussion_id": "2295455968",
        "commented_code": "@@ -1,29 +1,77 @@\n use std::{fs, path::PathBuf, process::Command};\n \n use anyhow::{anyhow, Context, Result};\n+use clap::ValueEnum;\n use regex::Regex;\n+use semver::Version as SemverVersion;\n use tree_sitter_loader::TreeSitterJSON;\n \n+#[derive(Clone, Copy, Default, ValueEnum)]\n+pub enum BumpLevel {\n+    #[default]\n+    Patch,\n+    Minor,\n+    Major,\n+}\n+\n pub struct Version {\n-    pub version: String,\n+    pub version: Option<SemverVersion>,\n     pub current_dir: PathBuf,\n+    pub bump: Option<BumpLevel>,\n }\n \n impl Version {\n     #[must_use]\n-    pub const fn new(version: String, current_dir: PathBuf) -> Self {\n+    pub const fn new(\n+        version: Option<SemverVersion>,\n+        current_dir: PathBuf,\n+        bump: Option<BumpLevel>,\n+    ) -> Self {\n         Self {\n             version,\n             current_dir,\n+            bump,\n         }\n     }\n \n-    pub fn run(self) -> Result<()> {\n+    pub fn run(mut self) -> Result<()> {\n         let tree_sitter_json = self.current_dir.join(\"tree-sitter.json\");\n \n         let tree_sitter_json =\n             serde_json::from_str::<TreeSitterJSON>(&fs::read_to_string(tree_sitter_json)?)?;\n \n+        let current_version = tree_sitter_json.metadata.version;\n+        self.version = match (self.version.is_some(), self.bump) {\n+            (false, None) => {\n+                println!(\"Current version: {current_version}\");\n+                return Ok(());\n+            }\n+            (true, None) => self.version,\n+            (false, Some(bump)) => {\n+                let mut v = current_version.clone();\n+                match bump {\n+                    BumpLevel::Patch => v.patch += 1,\n+                    BumpLevel::Minor => {\n+                        v.minor += 1;\n+                        v.patch = 0;\n+                    }\n+                    BumpLevel::Major => {\n+                        v.major += 1;\n+                        v.minor = 0;\n+                        v.patch = 0;\n+                    }\n+                }\n+                Some(v)\n+            }\n+            (true, Some(_)) => unreachable!(),\n+        };\n+\n+        let new_version = self.version.as_ref().unwrap();\n+        if new_version <= &current_version {\n+            print!(\"\\x1b[93m{}\\x1b[0m: \", \"Warning\"); // Bright yellow",
        "comment_created_at": "2025-08-23T07:54:47+00:00",
        "comment_author": "ObserverOfTime",
        "comment_body": "```suggestion\r\n            eprintln!(\"Warning: new version is lower than current!\");\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2295460693",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4205,
        "pr_file": "crates/cli/src/version.rs",
        "discussion_id": "2295455968",
        "commented_code": "@@ -1,29 +1,77 @@\n use std::{fs, path::PathBuf, process::Command};\n \n use anyhow::{anyhow, Context, Result};\n+use clap::ValueEnum;\n use regex::Regex;\n+use semver::Version as SemverVersion;\n use tree_sitter_loader::TreeSitterJSON;\n \n+#[derive(Clone, Copy, Default, ValueEnum)]\n+pub enum BumpLevel {\n+    #[default]\n+    Patch,\n+    Minor,\n+    Major,\n+}\n+\n pub struct Version {\n-    pub version: String,\n+    pub version: Option<SemverVersion>,\n     pub current_dir: PathBuf,\n+    pub bump: Option<BumpLevel>,\n }\n \n impl Version {\n     #[must_use]\n-    pub const fn new(version: String, current_dir: PathBuf) -> Self {\n+    pub const fn new(\n+        version: Option<SemverVersion>,\n+        current_dir: PathBuf,\n+        bump: Option<BumpLevel>,\n+    ) -> Self {\n         Self {\n             version,\n             current_dir,\n+            bump,\n         }\n     }\n \n-    pub fn run(self) -> Result<()> {\n+    pub fn run(mut self) -> Result<()> {\n         let tree_sitter_json = self.current_dir.join(\"tree-sitter.json\");\n \n         let tree_sitter_json =\n             serde_json::from_str::<TreeSitterJSON>(&fs::read_to_string(tree_sitter_json)?)?;\n \n+        let current_version = tree_sitter_json.metadata.version;\n+        self.version = match (self.version.is_some(), self.bump) {\n+            (false, None) => {\n+                println!(\"Current version: {current_version}\");\n+                return Ok(());\n+            }\n+            (true, None) => self.version,\n+            (false, Some(bump)) => {\n+                let mut v = current_version.clone();\n+                match bump {\n+                    BumpLevel::Patch => v.patch += 1,\n+                    BumpLevel::Minor => {\n+                        v.minor += 1;\n+                        v.patch = 0;\n+                    }\n+                    BumpLevel::Major => {\n+                        v.major += 1;\n+                        v.minor = 0;\n+                        v.patch = 0;\n+                    }\n+                }\n+                Some(v)\n+            }\n+            (true, Some(_)) => unreachable!(),\n+        };\n+\n+        let new_version = self.version.as_ref().unwrap();\n+        if new_version <= &current_version {\n+            print!(\"\\x1b[93m{}\\x1b[0m: \", \"Warning\"); // Bright yellow",
        "comment_created_at": "2025-08-23T08:04:12+00:00",
        "comment_author": "jpt13653903",
        "comment_body": "What about:\r\n\r\n```diff\r\n--- a/crates/cli/src/version.rs\r\n+++ b/crates/cli/src/version.rs\r\n@@ -67,10 +67,14 @@ impl Version {\r\n         };\r\n\r\n         let new_version = self.version.as_ref().unwrap();\r\n-        if new_version <= &current_version {\r\n-            print!(\"\\x1b[93m{}\\x1b[0m: \", \"Warning\"); // Bright yellow\r\n+        if new_version < &current_version {\r\n+            eprintln!(\"Warning: new version is lower than current!\");\r\n+            println!(\"Reverting version {current_version} to {new_version}\");\r\n+        } else if new_version > &current_version {\r\n+            println!(\"Bumping version {current_version} to {new_version}\");\r\n+        } else {\r\n+            println!(\"Keeping version {current_version}\");\r\n         }\r\n-        println!(\"Bumping version {current_version} to {new_version}\");\r\n\r\n         let is_multigrammar = tree_sitter_json.grammars.len() > 1;\r\n```\r\n\r\ninstead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2295461355",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4205,
        "pr_file": "crates/cli/src/version.rs",
        "discussion_id": "2295455968",
        "commented_code": "@@ -1,29 +1,77 @@\n use std::{fs, path::PathBuf, process::Command};\n \n use anyhow::{anyhow, Context, Result};\n+use clap::ValueEnum;\n use regex::Regex;\n+use semver::Version as SemverVersion;\n use tree_sitter_loader::TreeSitterJSON;\n \n+#[derive(Clone, Copy, Default, ValueEnum)]\n+pub enum BumpLevel {\n+    #[default]\n+    Patch,\n+    Minor,\n+    Major,\n+}\n+\n pub struct Version {\n-    pub version: String,\n+    pub version: Option<SemverVersion>,\n     pub current_dir: PathBuf,\n+    pub bump: Option<BumpLevel>,\n }\n \n impl Version {\n     #[must_use]\n-    pub const fn new(version: String, current_dir: PathBuf) -> Self {\n+    pub const fn new(\n+        version: Option<SemverVersion>,\n+        current_dir: PathBuf,\n+        bump: Option<BumpLevel>,\n+    ) -> Self {\n         Self {\n             version,\n             current_dir,\n+            bump,\n         }\n     }\n \n-    pub fn run(self) -> Result<()> {\n+    pub fn run(mut self) -> Result<()> {\n         let tree_sitter_json = self.current_dir.join(\"tree-sitter.json\");\n \n         let tree_sitter_json =\n             serde_json::from_str::<TreeSitterJSON>(&fs::read_to_string(tree_sitter_json)?)?;\n \n+        let current_version = tree_sitter_json.metadata.version;\n+        self.version = match (self.version.is_some(), self.bump) {\n+            (false, None) => {\n+                println!(\"Current version: {current_version}\");\n+                return Ok(());\n+            }\n+            (true, None) => self.version,\n+            (false, Some(bump)) => {\n+                let mut v = current_version.clone();\n+                match bump {\n+                    BumpLevel::Patch => v.patch += 1,\n+                    BumpLevel::Minor => {\n+                        v.minor += 1;\n+                        v.patch = 0;\n+                    }\n+                    BumpLevel::Major => {\n+                        v.major += 1;\n+                        v.minor = 0;\n+                        v.patch = 0;\n+                    }\n+                }\n+                Some(v)\n+            }\n+            (true, Some(_)) => unreachable!(),\n+        };\n+\n+        let new_version = self.version.as_ref().unwrap();\n+        if new_version <= &current_version {\n+            print!(\"\\x1b[93m{}\\x1b[0m: \", \"Warning\"); // Bright yellow",
        "comment_created_at": "2025-08-23T08:07:21+00:00",
        "comment_author": "ObserverOfTime",
        "comment_body": "You can use `match` with [`cmp`](https://docs.rs/semver/1.0.25/semver/struct.Version.html#method.cmp) to avoid the double check.",
        "pr_file_module": null
      },
      {
        "comment_id": "2295486731",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4205,
        "pr_file": "crates/cli/src/version.rs",
        "discussion_id": "2295455968",
        "commented_code": "@@ -1,29 +1,77 @@\n use std::{fs, path::PathBuf, process::Command};\n \n use anyhow::{anyhow, Context, Result};\n+use clap::ValueEnum;\n use regex::Regex;\n+use semver::Version as SemverVersion;\n use tree_sitter_loader::TreeSitterJSON;\n \n+#[derive(Clone, Copy, Default, ValueEnum)]\n+pub enum BumpLevel {\n+    #[default]\n+    Patch,\n+    Minor,\n+    Major,\n+}\n+\n pub struct Version {\n-    pub version: String,\n+    pub version: Option<SemverVersion>,\n     pub current_dir: PathBuf,\n+    pub bump: Option<BumpLevel>,\n }\n \n impl Version {\n     #[must_use]\n-    pub const fn new(version: String, current_dir: PathBuf) -> Self {\n+    pub const fn new(\n+        version: Option<SemverVersion>,\n+        current_dir: PathBuf,\n+        bump: Option<BumpLevel>,\n+    ) -> Self {\n         Self {\n             version,\n             current_dir,\n+            bump,\n         }\n     }\n \n-    pub fn run(self) -> Result<()> {\n+    pub fn run(mut self) -> Result<()> {\n         let tree_sitter_json = self.current_dir.join(\"tree-sitter.json\");\n \n         let tree_sitter_json =\n             serde_json::from_str::<TreeSitterJSON>(&fs::read_to_string(tree_sitter_json)?)?;\n \n+        let current_version = tree_sitter_json.metadata.version;\n+        self.version = match (self.version.is_some(), self.bump) {\n+            (false, None) => {\n+                println!(\"Current version: {current_version}\");\n+                return Ok(());\n+            }\n+            (true, None) => self.version,\n+            (false, Some(bump)) => {\n+                let mut v = current_version.clone();\n+                match bump {\n+                    BumpLevel::Patch => v.patch += 1,\n+                    BumpLevel::Minor => {\n+                        v.minor += 1;\n+                        v.patch = 0;\n+                    }\n+                    BumpLevel::Major => {\n+                        v.major += 1;\n+                        v.minor = 0;\n+                        v.patch = 0;\n+                    }\n+                }\n+                Some(v)\n+            }\n+            (true, Some(_)) => unreachable!(),\n+        };\n+\n+        let new_version = self.version.as_ref().unwrap();\n+        if new_version <= &current_version {\n+            print!(\"\\x1b[93m{}\\x1b[0m: \", \"Warning\"); // Bright yellow",
        "comment_created_at": "2025-08-23T08:30:36+00:00",
        "comment_author": "jpt13653903",
        "comment_body": "As in this?\r\n\r\n```rust\r\n        let new_version = self.version.as_ref().unwrap();\r\n        match new_version.cmp(&current_version) {\r\n            Ordering::Less => {\r\n                eprintln!(\"Warning: new version is lower than current!\");\r\n                println!(\"Reverting version {current_version} to {new_version}\");\r\n            }\r\n            Ordering::Greater => {\r\n                println!(\"Bumping version {current_version} to {new_version}\");\r\n            }\r\n            Ordering::Equal => {\r\n                println!(\"Keeping version {current_version}\");\r\n            }\r\n        }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1990380660",
    "pr_number": 4280,
    "pr_file": "cli/generate/src/node_types.rs",
    "created_at": "2025-03-12T01:16:42+00:00",
    "commented_code": "} else if a.1.contains(&b.0) {\n             Ordering::Greater\n         } else {\n-            Ordering::Equal\n+            // In order to impose a total ordering, types that are considered \"equal\"\n+            // w.r.t. their subtypes are ordered by kind.\n+            a.0.kind.cmp(&b.0.kind)",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1990380660",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4280,
        "pr_file": "cli/generate/src/node_types.rs",
        "discussion_id": "1990380660",
        "commented_code": "@@ -609,7 +609,9 @@ pub fn generate_node_types_json(\n         } else if a.1.contains(&b.0) {\n             Ordering::Greater\n         } else {\n-            Ordering::Equal\n+            // In order to impose a total ordering, types that are considered \"equal\"\n+            // w.r.t. their subtypes are ordered by kind.\n+            a.0.kind.cmp(&b.0.kind)",
        "comment_created_at": "2025-03-12T01:16:42+00:00",
        "comment_author": "atsmtat",
        "comment_body": "This may still not fix the total ordering: if A < B and B < C, then A < C must be true; but with your fix the comparison between A and C would depend on their names, not the actual dependency order.\r\n\r\nYou'll most likely have to do a topological sort, if the intention is to arrange the nodes in their dep order.",
        "pr_file_module": null
      },
      {
        "comment_id": "1990385396",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 4280,
        "pr_file": "cli/generate/src/node_types.rs",
        "discussion_id": "1990380660",
        "commented_code": "@@ -609,7 +609,9 @@ pub fn generate_node_types_json(\n         } else if a.1.contains(&b.0) {\n             Ordering::Greater\n         } else {\n-            Ordering::Equal\n+            // In order to impose a total ordering, types that are considered \"equal\"\n+            // w.r.t. their subtypes are ordered by kind.\n+            a.0.kind.cmp(&b.0.kind)",
        "comment_created_at": "2025-03-12T01:24:08+00:00",
        "comment_author": "WillLillis",
        "comment_body": "Yeah, you're right. I'll have to take another look at this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797726167",
    "pr_number": 3776,
    "pr_file": "cli/loader/src/lib.rs",
    "created_at": "2024-10-12T16:15:10+00:00",
    "commented_code": "pattern.and_then(|r| RegexBuilder::new(r).multi_line(true).build().ok())\n     }\n \n+    fn grammar_json_name(grammar_path: &Path) -> Result<String> {\n+        let file = fs::File::open(grammar_path).with_context(|| {\n+            format!(\"Failed to open grammar.json at {}\", grammar_path.display())\n+        })?;\n+\n+        let first_three_lines = BufReader::new(file)\n+            .lines()\n+            .take(3)\n+            .collect::<Result<Vec<_>, _>>()\n+            .with_context(|| {\n+                format!(\n+                    \"Failed to read the first three lines of grammar.json at {}\",\n+                    grammar_path.display()\n+                )\n+            })?\n+            .join(\"\n\");\n+\n+        let name = GRAMMAR_NAME_REGEX\n+            .captures(&first_three_lines)",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1797726167",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3776,
        "pr_file": "cli/loader/src/lib.rs",
        "discussion_id": "1797726167",
        "commented_code": "@@ -1280,6 +1247,36 @@ impl Loader {\n         pattern.and_then(|r| RegexBuilder::new(r).multi_line(true).build().ok())\n     }\n \n+    fn grammar_json_name(grammar_path: &Path) -> Result<String> {\n+        let file = fs::File::open(grammar_path).with_context(|| {\n+            format!(\"Failed to open grammar.json at {}\", grammar_path.display())\n+        })?;\n+\n+        let first_three_lines = BufReader::new(file)\n+            .lines()\n+            .take(3)\n+            .collect::<Result<Vec<_>, _>>()\n+            .with_context(|| {\n+                format!(\n+                    \"Failed to read the first three lines of grammar.json at {}\",\n+                    grammar_path.display()\n+                )\n+            })?\n+            .join(\"\\n\");\n+\n+        let name = GRAMMAR_NAME_REGEX\n+            .captures(&first_three_lines)",
        "comment_created_at": "2024-10-12T16:15:10+00:00",
        "comment_author": "clason",
        "comment_body": "> > the name field is always within the first three lines\r\n\r\nI don't think that assumption is correct; the first three lines are not guaranteed to contain that name, e.g.,\r\nhttps://github.com/tree-sitter-grammars/tree-sitter-slang/blob/dd991eb3b6957a33d9044e0f5914588f7f449a78/src/grammar.json#L2-L6\r\n\r\n(Current CLI versions no longer generate such a -- bugged -- `grammar.json`, but these still exist in the wild as my crater test showed.)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1530828691",
    "pr_number": 3191,
    "pr_file": "cli/src/tests/node_test.rs",
    "created_at": "2024-03-19T17:44:39+00:00",
    "commented_code": ");\n }\n \n+#[test]\n+fn test_node_parent_with_inlined_parent() {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "1530828691",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3191,
        "pr_file": "cli/src/tests/node_test.rs",
        "discussion_id": "1530828691",
        "commented_code": "@@ -248,6 +248,24 @@ fn test_node_parent_of_child_by_field_name() {\n     );\n }\n \n+#[test]\n+fn test_node_parent_with_inlined_parent() {",
        "comment_created_at": "2024-03-19T17:44:39+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think this test could use a different name, since `inlined` isn't really part of the issue. Maybe `parent_with_zero_length_node`? I think the issue is that there are zero-length nodes inside of the `suite`,  right?",
        "pr_file_module": null
      },
      {
        "comment_id": "1531385441",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3191,
        "pr_file": "cli/src/tests/node_test.rs",
        "discussion_id": "1530828691",
        "commented_code": "@@ -248,6 +248,24 @@ fn test_node_parent_of_child_by_field_name() {\n     );\n }\n \n+#[test]\n+fn test_node_parent_with_inlined_parent() {",
        "comment_created_at": "2024-03-20T00:50:11+00:00",
        "comment_author": "amaanq",
        "comment_body": "~~yep you're right~~\r\n\r\nActually I think it is to do with inlined nodes? Zero width nodes *can* have children which are also zero width, the issue here is that inlined nodes don't have any children, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "1533014438",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3191,
        "pr_file": "cli/src/tests/node_test.rs",
        "discussion_id": "1530828691",
        "commented_code": "@@ -248,6 +248,24 @@ fn test_node_parent_of_child_by_field_name() {\n     );\n }\n \n+#[test]\n+fn test_node_parent_with_inlined_parent() {",
        "comment_created_at": "2024-03-20T23:01:59+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "Yeah, I think the test should be called `test_parent_of_zero_width_node`. The `block` in this case (which is what you're testing the parent of) is a zero-width node, and that's why the problem was happening before.\r\n\r\nThe issue here doesn't have to do with inline subtrees. Inline subtrees are just a slightly more compact way of representing certain child-less subtrees, but it's not related to the problem.\r\n\r\nI think your fix (avoiding descending into nodes without children) helps in this case (and probably in most practical cases of this bug), but it's still possible that `ts_node_parent` could return the wrong value in the presence of zero-width nodes.\r\n\r\nFundamentally `ts_node_parent(node)` works by walking down the tree, starting from the root, trying to find the smallest possible node that contains the `node`'s byte range (and is not `node` itself). But if the node's byte range is empty, there are some problems. There might be *multiple* siblings that all contain that zero-length range. If there were multiple zero-length nodes in a row (which is uncommon), we could still get incorrect results here.\r\n\r\nI still think this fix improves the situation, and I'm glad you figured it out. I just think we should change the title of the test and \ud83d\udea2 .",
        "pr_file_module": null
      },
      {
        "comment_id": "1533015809",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 3191,
        "pr_file": "cli/src/tests/node_test.rs",
        "discussion_id": "1530828691",
        "commented_code": "@@ -248,6 +248,24 @@ fn test_node_parent_of_child_by_field_name() {\n     );\n }\n \n+#[test]\n+fn test_node_parent_with_inlined_parent() {",
        "comment_created_at": "2024-03-20T23:03:45+00:00",
        "comment_author": "amaanq",
        "comment_body": "Ahh gotcha, makes sense. Thanks for clarifying",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "786405157",
    "pr_number": 1602,
    "pr_file": "highlight/src/lib.rs",
    "created_at": "2022-01-18T04:19:46+00:00",
    "commented_code": "let (mut match_, capture_index) = layer.captures.next().unwrap();\n             let mut capture = match_.captures[capture_index];\n \n+            if layer.ignore_match_ids.contains(&match_.id()) {",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "786405157",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 1602,
        "pr_file": "highlight/src/lib.rs",
        "discussion_id": "786405157",
        "commented_code": "@@ -683,6 +685,10 @@ where\n             let (mut match_, capture_index) = layer.captures.next().unwrap();\n             let mut capture = match_.captures[capture_index];\n \n+            if layer.ignore_match_ids.contains(&match_.id()) {",
        "comment_created_at": "2022-01-18T04:19:46+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Since we're just doing contains lookups, a hashset would be better, no? Or actually I guess you could use just a u32 because match IDs are incrementing integers...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "318366691",
    "pr_number": 438,
    "pr_file": "lib/binding_rust/util.rs",
    "created_at": "2019-08-28T02:13:58+00:00",
    "commented_code": "Some(unsafe { *self.ptr.offset(i as isize) })\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.count, Some(self.count))",
    "repo_full_name": "tree-sitter/tree-sitter",
    "discussion_comments": [
      {
        "comment_id": "318366691",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 438,
        "pr_file": "lib/binding_rust/util.rs",
        "discussion_id": "318366691",
        "commented_code": "@@ -29,8 +29,14 @@ impl<T: Copy> Iterator for CBufferIter<T> {\n             Some(unsafe { *self.ptr.offset(i as isize) })\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.count, Some(self.count))",
        "comment_created_at": "2019-08-28T02:13:58+00:00",
        "comment_author": "maxbrunsfeld",
        "comment_body": "I think this needs to return the number of remaining elements, so you\u2019ll need to subtract off the current index.",
        "pr_file_module": null
      },
      {
        "comment_id": "318376012",
        "repo_full_name": "tree-sitter/tree-sitter",
        "pr_number": 438,
        "pr_file": "lib/binding_rust/util.rs",
        "discussion_id": "318366691",
        "commented_code": "@@ -29,8 +29,14 @@ impl<T: Copy> Iterator for CBufferIter<T> {\n             Some(unsafe { *self.ptr.offset(i as isize) })\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.count, Some(self.count))",
        "comment_created_at": "2019-08-28T03:10:52+00:00",
        "comment_author": "ubolonton",
        "comment_body": "Yeah, I misunderstood that. I'll fix it.",
        "pr_file_module": null
      }
    ]
  }
]